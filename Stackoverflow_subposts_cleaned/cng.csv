post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"20505325","How to Export Private Key For ECDiffieHellmanCng","I am trying to export the keys from a new instance of a ECDiffieHellmanCng object so I can create an instance of it later with the same keys. But I am getting an error when trying to export it.
//Create new ECDiffieHellmanCng which automatically creates new keys
var ecdh = new ECDiffieHellmanCng();
//Export the keys
var privateKey = ecdh.Key.Export(CngKeyBlobFormat.EccPrivateBlob);

I am getting a CryptographicException when I call the Export method with the message ""The requested operation is not supported.""  After putting some breakpoints in the code it looks like it is throwing the exception before even executing the method. Looking at the definition of the Export method it is adorned with a SecuritySafeCriticalAttribute so I am suspicious that this attribute is actually throwing the exception. What is causing this exception? How can I save the keys so I can create an instance of the same ECDiffieHellmanCng object at a later time?
","I believe you are specifying the wrong BLOB format. Try:
var privateKey = ecdh.Key.Export(CngKeyBlobFormat.Pkcs8PrivateBlob);

If that fails, you need to set up a key policy that allows private key export. See this answer: https://stackoverflow.com/a/10274270/2420979 for more details on your problem.
","4683","<c#><security><public-key-encryption><diffie-hellman><cng>","4","1","2","2013-12-13 13:26:41","20505976","0","1","","","","2013-12-10 21:11:36",""
"20505325","How to Export Private Key For ECDiffieHellmanCng","I am trying to export the keys from a new instance of a ECDiffieHellmanCng object so I can create an instance of it later with the same keys. But I am getting an error when trying to export it.
//Create new ECDiffieHellmanCng which automatically creates new keys
var ecdh = new ECDiffieHellmanCng();
//Export the keys
var privateKey = ecdh.Key.Export(CngKeyBlobFormat.EccPrivateBlob);

I am getting a CryptographicException when I call the Export method with the message ""The requested operation is not supported.""  After putting some breakpoints in the code it looks like it is throwing the exception before even executing the method. Looking at the definition of the Export method it is adorned with a SecuritySafeCriticalAttribute so I am suspicious that this attribute is actually throwing the exception. What is causing this exception? How can I save the keys so I can create an instance of the same ECDiffieHellmanCng object at a later time?
","By default, keys aren't exportable - they are securely stored in the KSP. When creating the key, it needs to be marked allowed for export. Example:
var ecdh = new ECDiffieHellmanCng(CngKey.Create(CngAlgorithm.ECDiffieHellmanP256, null, new CngKeyCreationParameters {ExportPolicy = CngExportPolicies.AllowPlaintextExport}));
//Export the keys
var privateKey = ecdh.Key.Export(CngKeyBlobFormat.EccPrivateBlob);

To make this simpler, we can just export it from the CngKey directly and not use the algorithm if all you want to do is create a new key and export the private key.
var cngKey = CngKey.Create(CngAlgorithm.ECDiffieHellmanP256, null, new CngKeyCreationParameters {ExportPolicy = CngExportPolicies.AllowPlaintextExport});
var privateKey = cngKey.Export(CngKeyBlobFormat.EccPrivateBlob);

You can re-create the CngKey from the exported blob by using CngKey.Import(yourBlob, CngKeyBlobFormat.EccPrivateBlob) and passing that to the constructor of ECDiffieHellmanCng.

SecuritySafeCriticalAttribute is part of the .NET Security Transparency model. It is not the source of your errors. 
","4683","<c#><security><public-key-encryption><diffie-hellman><cng>","4","11","2","2013-12-13 13:26:41","20505976","0","1","","","","2013-12-10 21:11:36",""
"17185429","How to grant permission to private key from powershell","I'm trying to find a way to grant permissions for private key from powershell script. Certificate is stored in CNG. All ideas are welcome.
","Cmdlet code for getting private key filename. 
[Cmdlet(""Get"", ""PrivateKeyName"")]
public class GetKeyNameCmdlet : Cmdlet
{
    [Parameter(Position = 0, Mandatory = false)]
    public X509Certificate2 Cert;

    protected override void ProcessRecord()
    {
        WriteObject(GetUniqueKeyName(Cert));
    }

    private static string GetUniqueKeyName(X509Certificate2 cert)
    {
        if (cert == null)
            throw new ArgumentNullException(""cert"");

        var cngPrivateKey = cert.GetCngPrivateKey();

        if (cngPrivateKey != null)
            return cngPrivateKey.UniqueName;

        var rsaPrivateKey = cert.PrivateKey as RSACryptoServiceProvider;
        if (rsaPrivateKey != null)
            return rsaPrivateKey.CspKeyContainerInfo.UniqueKeyContainerName;

         throw new Exception(""cert"");
    }
}

using cmdlet.  CngCrypt.dll - dll with cmdlet code.
  Import-Module .\CngCrypt.dll
  $local:certificateRootPath = join-path $env:ALLUSERSPROFILE      '\Microsoft\Crypto\RSA\MachineKeys\'
  $WorkingCert = Get-ChildItem CERT:\LocalMachine\My |where {$_.Subject -match 'Test'}| sort 
  Get-PrivateKeyName ($WorkingCert) 

","4578","<powershell><cng>","4","1","3","2016-10-14 15:38:26","21993109","2","","1368221","","2013-06-19 07:44:17","2013-06-19 07:35:55",""
"17185429","How to grant permission to private key from powershell","I'm trying to find a way to grant permissions for private key from powershell script. Certificate is stored in CNG. All ideas are welcome.
","The answer above is technically correct however it did not help me when I was looking for the same thing because it fails to mention that you need to use assemblies loaded from the CLRSecurity project on codeplex https://clrsecurity.codeplex.com/.
Here is an extract of how I achieved the same thing including loading the CLR Security assembly that you need to use Security.Cryptography.dll. There are a couple of function declarations that are needed first. I have these included in modules however you can use them as you wish. 
Function Load-Assembly()
{
    [CmdletBinding(PositionalBinding=$false)]   
    param(
        [Parameter(Mandatory)][string][ValidateScript({Test-Path $_})] $DirectoryPath,
        [Parameter(Mandatory)][string][ValidateNotNullOrEmpty()] $Name
    )

    $assemblyFileNameFullPath = Join-Path -Path $DirectoryPath -ChildPath $Name

    If (Test-Path -Path  $assemblyFileNameFullPath -PathType Leaf)
    {
        Write-Verbose ""Loading .NET assembly from path """"$assemblyFileNameFullPath""""""

        #Load the assembly using the bytes as this gets around security restrictions that stop certain assemblies from loading from external sources
        $assemblyBytes = [System.IO.File]::ReadAllBytes($assemblyFileNameFullPath)
        $assemblyLoaded = [System.Reflection.Assembly]::Load($assemblyBytes);

        if ($assemblyLoaded -ne $null)
        {
            return $assemblyLoaded
        }
        else
        {
            Throw ""Cannot load .NET assembly """"$Name"""" from directory """"$DirectoryPath""""""
        }
    }
    else
    {
        Write-Error ""Cannot find required .NET assembly at path """"$assemblyFileNameFullPath""""""
    }
}

Function Get-PrivateKeyContainerPath()
{
    [CmdletBinding(PositionalBinding=$false)]
    Param(
        [Parameter(Mandatory=$True)][string][ValidateNotNullOrEmpty()] $Name,
        [Parameter(Mandatory=$True)][boolean] $IsCNG
    )

    If ($IsCNG)
    {
        $searchDirectories = @(""Microsoft\Crypto\Keys"",""Microsoft\Crypto\SystemKeys"")
    }
    else
    {
        $searchDirectories = @(""Microsoft\Crypto\RSA\MachineKeys"",""Microsoft\Crypto\RSA\S-1-5-18"",""Microsoft\Crypto\RSA\S-1-5-19"",""Crypto\DSS\S-1-5-20"")
    }

    foreach ($searchDirectory in $searchDirectories)
    {
        $machineKeyDirectory = Join-Path -Path $([Environment]::GetFolderPath(""CommonApplicationData"")) -ChildPath $searchDirectory
        $privateKeyFile = Get-ChildItem -Path $machineKeyDirectory -Filter $Name -Recurse
        if ($privateKeyFile -ne $null)
        {
           return $privateKeyFile.FullName
        }
    }

    Throw ""Cannot find private key file path for key container """"$Name""""""
}


#Extracted code of how to obtain the private key file path (taken from a function)
#Requires an x509Certificate2 object in variable $Certificate and string variable $CertificateStore that contains the name of the certificate store

#Need to use the Security.Cryptography assembly
    $assembly = Load-Assembly -DirectoryPath $PSScriptRoot -Name Security.Cryptography.dll

    #Uses the extension methods in Security.Cryptography assembly from (https://clrsecurity.codeplex.com/)
    If ([Security.Cryptography.X509Certificates.X509CertificateExtensionMethods]::HasCngKey($Certificate))
    {
        Write-Verbose ""Private key CSP is CNG""
        $privateKey = [Security.Cryptography.X509Certificates.X509Certificate2ExtensionMethods]::GetCngPrivateKey($Certificate)
        $keyContainerName = $privateKey.UniqueName
        $privateKeyPath = Get-PrivateKeyContainerPath -Name $keyContainerName -IsCNG $true
    }
    elseif ($Certificate.PrivateKey -ne $null)
    {
        Write-Verbose ""Private key CSP is legacy""
        $privateKey = $Certificate.PrivateKey        
        $keyContainerName = $Certificate.PrivateKey.CspKeyContainerInfo.UniqueKeyContainerName      
        $privateKeyPath = Get-PrivateKeyContainerPath -Name $keyContainerName -IsCNG $false
    }
    else
    {
        Throw ""Certificate """"$($Certificate.GetNameInfo(""SimpleName"",$false))"""" in store """"$CertificateStore"""" does not have a private key, or that key is inaccessible, therefore permission cannot be granted""
    }

Sorry if this seems like a repeat from above, as I said it does use the same technique but hopefully others may find this more useful since it explains how to use the methods in the CLR Security project including how to load the assembly.
","4578","<powershell><cng>","4","7","3","2016-10-14 15:38:26","21993109","2","","1368221","","2013-06-19 07:44:17","2013-06-19 07:35:55",""
"17185429","How to grant permission to private key from powershell","I'm trying to find a way to grant permissions for private key from powershell script. Certificate is stored in CNG. All ideas are welcome.
","If you have certificate already installed on machine/server and just looking for how to give permission to specific user using powershell.
Here is the answer
How to Grant permission to user on Certificate private key using powershell? 
","4578","<powershell><cng>","4","0","3","2016-10-14 15:38:26","21993109","2","","1368221","","2013-06-19 07:44:17","2013-06-19 07:35:55",""
"30720414","How to chain BCryptEncrypt and BCryptDecrypt calls using AES in GCM mode?","Using the Windows CNG API, I am able to encrypt and decrypt individual blocks of data with authentication, using AES in GCM mode. I now want to encrypt and decrypt multiple buffers in a row.
According to documentation for CNG, the following scenario is supported:

If the input to encryption or decryption is scattered across multiple
  buffers, then you must chain calls to the BCryptEncrypt and
  BCryptDecrypt functions. Chaining is indicated by setting the
  BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG flag in the dwFlags member.

If I understand it correctly, this means that I can invoke BCryptEncrypt sequentially on multiple buffers an obtain the authentication tag for the combined buffers at the end. Similarly, I can invoke BCryptDecrypt sequentially on multiple buffers while deferring the actual authentication check until the end. I can not get that to work though, it looks like the value for dwFlags is ignored. Whenever I use BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG, I get a return value of 0xc000a002 , which is equal to STATUS_AUTH_TAG_MISMATCH as defined in ntstatus.h.
Even though the parameter pbIV is marked as in/out, the elements pointed to by the parameter pbIV do not get modified by BCryptEncrypt(). Is that expected? I also looked at the field pbNonce in the BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO structure, pointed to by the pPaddingInfo pointer, but that one does not get modified either. I also tried ""manually"" advancing the IV, modifying the contents myself according to the counter scheme, but that did not help either.
What is the right procedure to chain the BCryptEncrypt and/or BCryptDecrypt functions successfully?
","I managed to get it to work. It seems that the problem is in MSDN, it should mention setting BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG instead of BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG.
#include <windows.h>
#include <assert.h>
#include <vector>
#include <Bcrypt.h>
#pragma comment(lib, ""bcrypt.lib"")

std::vector<BYTE> MakePatternBytes(size_t a_Length)
{
    std::vector<BYTE> result(a_Length);
    for (size_t i = 0; i < result.size(); i++)
    {
        result[i] = (BYTE)i;
    }

    return result;
}

std::vector<BYTE> MakeRandomBytes(size_t a_Length)
{
    std::vector<BYTE> result(a_Length);
    for (size_t i = 0; i < result.size(); i++)
    {
        result[i] = (BYTE)rand();
    }

    return result;
}

int _tmain(int argc, _TCHAR* argv[])
{
    NTSTATUS bcryptResult = 0;
    DWORD bytesDone = 0;

    BCRYPT_ALG_HANDLE algHandle = 0;
    bcryptResult = BCryptOpenAlgorithmProvider(&algHandle, BCRYPT_AES_ALGORITHM, 0, 0);
    assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptOpenAlgorithmProvider"");

    bcryptResult = BCryptSetProperty(algHandle, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_GCM, sizeof(BCRYPT_CHAIN_MODE_GCM), 0);
    assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptSetProperty(BCRYPT_CHAINING_MODE)"");

    BCRYPT_AUTH_TAG_LENGTHS_STRUCT authTagLengths;
    bcryptResult = BCryptGetProperty(algHandle, BCRYPT_AUTH_TAG_LENGTH, (BYTE*)&authTagLengths, sizeof(authTagLengths), &bytesDone, 0);
    assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptGetProperty(BCRYPT_AUTH_TAG_LENGTH)"");

    DWORD blockLength = 0;
    bcryptResult = BCryptGetProperty(algHandle, BCRYPT_BLOCK_LENGTH, (BYTE*)&blockLength, sizeof(blockLength), &bytesDone, 0);
    assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptGetProperty(BCRYPT_BLOCK_LENGTH)"");

    BCRYPT_KEY_HANDLE keyHandle = 0;
    {
        const std::vector<BYTE> key = MakeRandomBytes(blockLength);
        bcryptResult = BCryptGenerateSymmetricKey(algHandle, &keyHandle, 0, 0, (PUCHAR)&key[0], key.size(), 0);
        assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptGenerateSymmetricKey"");
    }

    const size_t GCM_NONCE_SIZE = 12;
    const std::vector<BYTE> origNonce = MakeRandomBytes(GCM_NONCE_SIZE);
    const std::vector<BYTE> origData  = MakePatternBytes(256);

    // Encrypt data as a whole
    std::vector<BYTE> encrypted = origData;
    std::vector<BYTE> authTag(authTagLengths.dwMinLength);
    {
        BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
        BCRYPT_INIT_AUTH_MODE_INFO(authInfo);
        authInfo.pbNonce = (PUCHAR)&origNonce[0];
        authInfo.cbNonce = origNonce.size();
        authInfo.pbTag   = &authTag[0];
        authInfo.cbTag   = authTag.size();

        bcryptResult = BCryptEncrypt
            (
            keyHandle,
            &encrypted[0], encrypted.size(),
            &authInfo,
            0, 0,
            &encrypted[0], encrypted.size(),
            &bytesDone, 0
            );

        assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptEncrypt"");
        assert(bytesDone == encrypted.size());
    }

    // Decrypt data in two parts
    std::vector<BYTE> decrypted = encrypted;
    {
        DWORD partSize = decrypted.size() / 2;

        std::vector<BYTE> macContext(authTagLengths.dwMaxLength);

        BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
        BCRYPT_INIT_AUTH_MODE_INFO(authInfo);
        authInfo.pbNonce = (PUCHAR)&origNonce[0];
        authInfo.cbNonce = origNonce.size();
        authInfo.pbTag   = &authTag[0];
        authInfo.cbTag   = authTag.size();
        authInfo.pbMacContext = &macContext[0];
        authInfo.cbMacContext = macContext.size();

        // IV value is ignored on first call to BCryptDecrypt.
        // This buffer will be used to keep internal IV used for chaining.
        std::vector<BYTE> contextIV(blockLength);

        // First part
        authInfo.dwFlags = BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG;
        bcryptResult = BCryptDecrypt
            (
            keyHandle,
            &decrypted[0*partSize], partSize,
            &authInfo,
            &contextIV[0], contextIV.size(),
            &decrypted[0*partSize], partSize,
            &bytesDone, 0
            );

        assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptDecrypt"");
        assert(bytesDone == partSize);

        // Second part
        authInfo.dwFlags &= ~BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG;
        bcryptResult = BCryptDecrypt
            (
            keyHandle,
            &decrypted[1*partSize], partSize,
            &authInfo,
            &contextIV[0], contextIV.size(),
            &decrypted[1*partSize], partSize,
            &bytesDone, 0
            );

        assert(BCRYPT_SUCCESS(bcryptResult) || !""BCryptDecrypt"");
        assert(bytesDone == partSize);
    }

    // Check decryption
    assert(decrypted == origData);

    // Cleanup
    BCryptDestroyKey(keyHandle);
    BCryptCloseAlgorithmProvider(algHandle, 0);

    return 0;
}

","4490","<c><windows><aes-gcm><cng>","12","11","1","2015-07-02 18:50:08","30958068","0","2","1380680","","2015-06-24 19:12:01","2015-06-08 22:56:00",""
"36963346","What header to include for an NTSTATUS when building for ARM platforms?","I'm working under the VS2013 ARM Developer Prompt. I'm trying to use Microsoft's Cryptography Next Generation (CNG), but I'm experiencing some non-trivial problems.
I'm trying to compile a simple test program:
#include <windows.h>
#include <bcrypt.h>

int main(int argc, char* argv[])
{
    BCRYPT_ALG_HANDLE hProvider = NULL;
    NTSTATUS ret = BCryptOpenAlgorithmProvider(&hProvider, BCRYPT_RNG_ALGORITHM, MS_PRIMITIVE_PROVIDER, 0);
    if (!(BCRYPT_SUCCESS(ret)))
    {
        return -1;
    }

    unsigned char buffer[20];
    ret = BCryptGenRandom(hProvider, buffer, (ULONG)sizeof(buffer), 0);
    if (!(BCRYPT_SUCCESS(ret)))
    {
        return -2;
    }

    ret = BCryptCloseAlgorithmProvider(hProvider, 0);
    if (!(BCRYPT_SUCCESS(ret)))
    {
        return -3;
    }

    return 0;
}

I attempt to compile it with:
C:\Users\Test>cl.exe /nologo /W4 /D_MBCS /Zi /TP /EHs c /MD /FI sdkddkver.h /FI winapifamily.h /DWINAPI_FAMILY=WINAPI_FAMILY_APP /c test.cxx
Microsoft (R) C/C++ Optimizing Compiler Version 18.00.21005.1 for ARM
Copyright (C) Microsoft Corporation.  All rights reserved.

test.cxx
test.cxx(6) : error C2065: 'BCRYPT_ALG_HANDLE' : undeclared identifier
test.cxx(6) : error C2146: syntax error : missing ';' before identifier 'hProvid
er'
test.cxx(6) : error C2065: 'hProvider' : undeclared identifier
test.cxx(7) : error C2065: 'NTSTATUS' : undeclared identifier
test.cxx(7) : error C2146: syntax error : missing ';' before identifier 'ret'
test.cxx(7) : error C2065: 'ret' : undeclared identifier
test.cxx(7) : error C2065: 'hProvider' : undeclared identifier
test.cxx(7) : error C2065: 'BCRYPT_RNG_ALGORITHM' : undeclared identifier
test.cxx(7) : error C2065: 'MS_PRIMITIVE_PROVIDER' : undeclared identifier
test.cxx(7) : error C3861: 'BCryptOpenAlgorithmProvider': identifier not found
test.cxx(8) : error C2065: 'ret' : undeclared identifier
test.cxx(8) : error C3861: 'BCRYPT_SUCCESS': identifier not found
test.cxx(14) : error C2065: 'ret' : undeclared identifier
test.cxx(14) : error C2065: 'hProvider' : undeclared identifier
test.cxx(14) : error C3861: 'BCryptGenRandom': identifier not found
test.cxx(15) : error C2065: 'ret' : undeclared identifier
test.cxx(15) : error C3861: 'BCRYPT_SUCCESS': identifier not found
test.cxx(20) : error C2065: 'ret' : undeclared identifier
test.cxx(20) : error C2065: 'hProvider' : undeclared identifier
test.cxx(20) : error C3861: 'BCryptCloseAlgorithmProvider': identifier not found

test.cxx(21) : error C2065: 'ret' : undeclared identifier
test.cxx(21) : error C3861: 'BCRYPT_SUCCESS': identifier not found

When I attempt to include <ntstatus.h> (scrapped from PJ Naughter's blog because I can't seem to find anything useful from Microsoft):
cl.exe /nologo /W4 /D_MBCS /Zi /TP /EHsc /MD /FI sdkddkver.h /FI winapifamily.h /DWINAPI_FAMILY=WINAPI_FAMILY_APP /c osrng.cpp
osrng.cpp
C:\Program Files (x86)\Windows Kits\8.1\include\shared\ntstatus.h(66) : warning
C4005: 'STATUS_WAIT_0' : macro redefinition
        C:\Program Files (x86)\Windows Kits\8.1\include\um\winnt.h(2202) : see p
revious definition of 'STATUS_WAIT_0'
C:\Program Files (x86)\Windows Kits\8.1\include\shared\ntstatus.h(212) : warning
 C4005: 'STATUS_ABANDONED_WAIT_0' : macro redefinition
        C:\Program Files (x86)\Windows Kits\8.1\include\um\winnt.h(2203) : see p
revious definition of 'STATUS_ABANDONED_WAIT_0'
C:\Program Files (x86)\Windows Kits\8.1\include\shared\ntstatus.h(235) : warning
 C4005: 'STATUS_USER_APC' : macro redefinition
...

I can't make it a LONG because Microsoft macros like BCRYPT_SUCCESS cast it to a NTSTATUS code.
I can also duplicate the missing NTSTATUS problem under VS2012 ARM Developer Prompt.
What header file should I include to get a declaration for NTSTATUS under ARM?

I think this might be related, but I'm not certain: fatal error LNK1104: cannot open file 'bcrypt.lib' when building for Surface RT tablet. About all I know is this stuff does not appear to be well tested by Microsoft because there are too many damn problems trying to use it.
","The main issue is that BCRYPT is supported for the Universal Windows Platform apps (aka Windows 10 Store apps), but was not supported for Windows 8.x Store apps. VS 2013 toolset always uses the Windows 8.1 SDK so you were building a Windows 8.1 Store app. When you tried VS 2012, you were using the Windows 8.0 SDK so you were building a Windows 8.0 Store apps. Again, neither of this support BCRYPT. If you build with VS 2015 and have the Windows 10 SDK installed, then your code builds fine.
Note that /D_MBCS is not an option for Windows Store apps. All Windows Store apps should be built for Unicode /DUNICODE /D_UNICODE and not ANSI/Multibyte as you were trying to do.
Also, be sure to link with windowsapp.lib to make sure you pick up the correct DLLs when you link.

You can easily confirm that all the errors you are seeing happen in VS 2012/2013 if you do not have #include <bcrypt.h> in the file at all. The DWINAPI_FAMILY=WINAPI_FAMILY_APP ensures that all unsupported APIs are undefined, so with Windows 8.x Store that header was basically an empty file.

","4037","<visual-studio><windows-store-apps><arm><cng>","1","3","1","2016-05-01 06:12:17","36963659","0","","-1","","2017-05-23 12:16:12","2016-05-01 05:20:18",""
"6316158","Bug in RSA encryption/decryption using CryptoAPI Next Generation (CNG) in Windows?","I have written a code to encrypt and decrypt data with a hardcoded RSA key pair that was previously generated using the CNG. It is a simple program that simply generates some random input data, encrypts it with the public key, and then decrypts the resulting encrypted buffer using the private key. I print all the input, intermediate and output stages to compare whether the decrypted plaintext is the same as the original input plaintext, and repeat the whole encrypt-decrypt 10 times.
However, I am observing that in some cases, the encryption and decryption are fine, but in others, the decrypted plaintext does not match the input plaintext at all. Such buggy cases are completely random and arbitrary and there does not seem to be any pattern to these bugs.
Is this a bug in the CNG's RSA implementation or am I doing something wrongly?
Code follows:

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <bcrypt.h>

#define NT_SUCCESS(Status)          (((NTSTATUS)(Status)) >= 0)
#define STATUS_UNSUCCESSFUL         ((NTSTATUS)0xC0000001L)

#define PrivateKeySize 283
#define PublicKeySize 155
#define InputDataSize 128

PUCHAR encryptedBuffer;
ULONG encryptedBufferSize = 128;


VOID printMem(PVOID Mem, int length)
{
    int i;
    for (i = 0; i < length; i++)
        printf(""%02x "", ((unsigned char *)Mem)[i]);
}

VOID Decrypt()
{
    unsigned char PrivateKey[PrivateKeySize] = {0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xB7, 0x50, 0x52, 0xDD, 0x58, 0xE4, 0x96, 0xAF, 0x91, 0xE5, 0xB2, 0x7B, 0x0A, 0xE6, 0xAA, 0x1F, 0x71, 0x8A, 0x66, 0xC3, 0xF0, 0x21, 0xD8, 0xE6, 0x2C, 0xD6, 0x25, 0x2E, 0x77, 0x3C, 0x61, 0x08, 0x1B, 0x69, 0xE7, 0x58, 0xDF, 0x3B, 0x07, 0xFE, 0xF1, 0xDB, 0xBF, 0xA6, 0x35, 0xDF, 0xC7, 0x49, 0x06, 0xC8, 0xDB, 0x74, 0x2A, 0xB9, 0xED, 0xB3, 0x04, 0x80, 0x75, 0x5F, 0x71, 0x2C, 0xD0, 0x14, 0x0E, 0x81, 0x18, 0x00, 0x5E, 0x34, 0x5A, 0xC2, 0x3A, 0x84, 0x63, 0xB1, 0x6B, 0x04, 0x21, 0x49, 0x7F, 0xE0, 0xF3, 0x52, 0x5E, 0x61, 0x43, 0xB1, 0x8F, 0x7C, 0xF2, 0x74, 0x29, 0x28, 0x69, 0x20, 0x36, 0xC0, 0x92, 0x17, 0x42, 0x99, 0x72, 0xE5, 0xE7, 0x82, 0xBE, 0x8E, 0x3B, 0x3F, 0xC9, 0x0A, 0xE1, 0xC4, 0x63, 0x68, 0x73, 0x1D, 0x67, 0x8D, 0xC0, 0xA3, 0xB4, 0xBA, 0xF0, 0xB7, 0xB0, 0x9B, 0xBB, 0x3F, 0xB8, 0x6E, 0xC0, 0x34, 0x1E, 0xA0, 0x01, 0x4B, 0x6D, 0x47, 0x73, 0x3F, 0xA5, 0x39, 0x05, 0x27, 0xD4, 0xD1, 0x38, 0x34, 0x32, 0x2C, 0x5B, 0x03, 0x5F, 0x16, 0x21, 0x64, 0x04, 0xD5, 0x19, 0xDB, 0xE7, 0x80, 0xDA, 0xBD, 0xC4, 0x1E, 0xAB, 0x61, 0xC8, 0x84, 0xDF, 0x54, 0x16, 0x77, 0x98, 0x9B, 0x90, 0x03, 0x83, 0xC4, 0x8D, 0x25, 0xB1, 0x32, 0x67, 0x77, 0x6A, 0x1C, 0x64, 0x2D, 0xFA, 0x9E, 0xB9, 0x26, 0xB5, 0xF8, 0x47, 0x4A, 0x9C, 0x35, 0x89, 0x5F, 0x12, 0x0E, 0xFF, 0x60, 0x87, 0x1E, 0x27, 0xC1, 0xC5, 0x7C, 0x77, 0x0A, 0xAE, 0x11, 0x37, 0xE3, 0x42, 0x9B, 0xAF, 0x9D, 0xBC, 0xC2, 0x52, 0xF8, 0x85, 0xBA, 0xED, 0x8E, 0xC3, 0x73, 0x04, 0x0A, 0x53, 0xD2, 0x1D, 0xEF, 0xA0, 0x6A, 0xCD, 0xBE, 0x93, 0x49, 0x34, 0x3A, 0xBD, 0xDF, 0x6A, 0x33, 0x25, 0x91, 0xFC, 0xE7};
    BCRYPT_ALG_HANDLE hAlgorithm = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    ULONG plaintextSize = 128;
    PUCHAR decryptedBuffer;
    ULONG decryptedBufferSize;
    NTSTATUS status;

    status = BCryptOpenAlgorithmProvider(&hAlgorithm,
                                            BCRYPT_RSA_ALGORITHM,
                                            NULL,
                                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get algorithm provider..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptImportKeyPair( hAlgorithm,
                                  NULL,
                                  BCRYPT_RSAPRIVATE_BLOB,
                                  &hKey,
                                  PrivateKey,
                                  PrivateKeySize,
                                  BCRYPT_NO_KEY_VALIDATION);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to import Private key..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptDecrypt( hKey,
                            encryptedBuffer,
                            encryptedBufferSize,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            0,
                            &decryptedBufferSize,
                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get required size of buffer..status : %08x\n"", status);
        goto cleanup;
    }

    decryptedBuffer = (PUCHAR)HeapAlloc (GetProcessHeap (), 0, decryptedBufferSize);
    if (decryptedBuffer == NULL) {
        printf(""failed to allocate memory for buffer\n"");
        goto cleanup;
    }

    status = BCryptDecrypt( hKey,
                            encryptedBuffer,
                            encryptedBufferSize,
                            NULL,
                            NULL,
                            0,
                            decryptedBuffer,
                            decryptedBufferSize,
                            &decryptedBufferSize,
                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed decrypt buffer..status : %08x\n"",status);
        goto cleanup;
    }

    printf(""Decrypted buffer\n"");
    printMem(decryptedBuffer, decryptedBufferSize);
    printf(""\n\n"");

cleanup:
    HeapFree(GetProcessHeap(), 0, decryptedBuffer);

    BCryptDestroyKey(hKey);

    BCryptCloseAlgorithmProvider(hAlgorithm, 0);
}


VOID Encrypt()
{
    unsigned char PublicKey[PublicKeySize] = {0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x01, 0x00, 0x01, 0xB7,  0x50, 0x52, 0xDD, 0x58, 0xE4, 0x96, 0xAF, 0x91,  0xE5, 0xB2, 0x7B, 0x0A,  0xE6, 0xAA, 0x1F, 0x71,  0x8A, 0x66, 0xC3, 0xF0, 0x21, 0xD8, 0xE6, 0x2C,  0xD6, 0x25, 0x2E, 0x77,  0x3C, 0x61, 0x08, 0x1B,  0x69, 0xE7, 0x58, 0xDF, 0x3B, 0x07, 0xFE, 0xF1,  0xDB, 0xBF, 0xA6, 0x35,  0xDF, 0xC7, 0x49, 0x06,  0xC8, 0xDB, 0x74, 0x2A, 0xB9, 0xED, 0xB3, 0x04,  0x80, 0x75, 0x5F, 0x71,  0x2C, 0xD0, 0x14, 0x0E,  0x81, 0x18, 0x00, 0x5E, 0x34, 0x5A, 0xC2, 0x3A,  0x84, 0x63, 0xB1, 0x6B,  0x04, 0x21, 0x49, 0x7F,  0xE0, 0xF3, 0x52, 0x5E, 0x61, 0x43, 0xB1, 0x8F,  0x7C, 0xF2, 0x74, 0x29,  0x28, 0x69, 0x20, 0x36,  0xC0, 0x92, 0x17, 0x42, 0x99, 0x72, 0xE5, 0xE7,  0x82, 0xBE, 0x8E, 0x3B,  0x3F, 0xC9, 0x0A, 0xE1,  0xC4, 0x63, 0x68, 0x73, 0x1D, 0x67, 0x8D, 0xC0,  0xA3, 0xB4, 0xBA, 0xF0,  0xB7, 0xB0, 0x9B};
    unsigned char InputData[InputDataSize];
    BCRYPT_ALG_HANDLE hAlgorithm = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    NTSTATUS status;

    for (int i=0; i<128; i++)
        InputData[i] = (unsigned char)rand();

    printf(""Random Data is \n"");
    printMem(InputData, InputDataSize);
    printf(""\n\n"");

    status = BCryptOpenAlgorithmProvider(    &hAlgorithm,
                                            BCRYPT_RSA_ALGORITHM,
                                            NULL,
                                            0 );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get algorithm provider..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptImportKeyPair( hAlgorithm,
                                  NULL,
                                  BCRYPT_RSAPUBLIC_BLOB,
                                  &hKey,
                                  PublicKey,
                                  155,
                                  BCRYPT_NO_KEY_VALIDATION );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to import Private key..status : %08x\n"",status);
        goto cleanup;

    }

    status = BCryptEncrypt( hKey,
                            InputData,
                            InputDataSize,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            0,
                            &encryptedBufferSize,
                            0
                            );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get required size of buffer..status : %08x\n"",status);
        goto cleanup;
    }

    encryptedBuffer = (PUCHAR)HeapAlloc (GetProcessHeap (), 0, encryptedBufferSize);

    if (encryptedBuffer == NULL) {
        printf(""failed to allocate memory for blindedFEKBuffer\n"");
        goto cleanup;
    }

    status = BCryptEncrypt( hKey,
                            InputData,
                            InputDataSize,
                            NULL,
                            NULL,
                            0,
                            encryptedBuffer,
                            encryptedBufferSize,
                            &encryptedBufferSize,
                            0
                            );

    if (!NT_SUCCESS(status))    {
        printf(""Failed encrypt data..status : %08x\n"",status);
        goto cleanup;
    }

printf(""Encrypted Data\n"");
printMem(encryptedBuffer, encryptedBufferSize);
printf(""\n\n"");

cleanup:
            if(hKey)
                BCryptDestroyKey(hKey);
            if(hAlgorithm)
                BCryptCloseAlgorithmProvider(hAlgorithm, 0);
}


int __cdecl wmain(
                   int argc,
                   __in_ecount(argc) LPWSTR *wargv)
{

    int i;
    for (i=0; i<10; i++)
    {
        Encrypt();
        Decrypt();
    }

}

","Is it possible your problem stems from passing a NULL IV to BCryptEncrypt as remarked upon in Community notes at the bottom of:
BCryptEncrypt function
","2375","<rsa><cng>","4","-1","3","2015-01-23 15:09:34","","1","2","","","","2011-06-11 13:26:12",""
"6316158","Bug in RSA encryption/decryption using CryptoAPI Next Generation (CNG) in Windows?","I have written a code to encrypt and decrypt data with a hardcoded RSA key pair that was previously generated using the CNG. It is a simple program that simply generates some random input data, encrypts it with the public key, and then decrypts the resulting encrypted buffer using the private key. I print all the input, intermediate and output stages to compare whether the decrypted plaintext is the same as the original input plaintext, and repeat the whole encrypt-decrypt 10 times.
However, I am observing that in some cases, the encryption and decryption are fine, but in others, the decrypted plaintext does not match the input plaintext at all. Such buggy cases are completely random and arbitrary and there does not seem to be any pattern to these bugs.
Is this a bug in the CNG's RSA implementation or am I doing something wrongly?
Code follows:

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <bcrypt.h>

#define NT_SUCCESS(Status)          (((NTSTATUS)(Status)) >= 0)
#define STATUS_UNSUCCESSFUL         ((NTSTATUS)0xC0000001L)

#define PrivateKeySize 283
#define PublicKeySize 155
#define InputDataSize 128

PUCHAR encryptedBuffer;
ULONG encryptedBufferSize = 128;


VOID printMem(PVOID Mem, int length)
{
    int i;
    for (i = 0; i < length; i++)
        printf(""%02x "", ((unsigned char *)Mem)[i]);
}

VOID Decrypt()
{
    unsigned char PrivateKey[PrivateKeySize] = {0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xB7, 0x50, 0x52, 0xDD, 0x58, 0xE4, 0x96, 0xAF, 0x91, 0xE5, 0xB2, 0x7B, 0x0A, 0xE6, 0xAA, 0x1F, 0x71, 0x8A, 0x66, 0xC3, 0xF0, 0x21, 0xD8, 0xE6, 0x2C, 0xD6, 0x25, 0x2E, 0x77, 0x3C, 0x61, 0x08, 0x1B, 0x69, 0xE7, 0x58, 0xDF, 0x3B, 0x07, 0xFE, 0xF1, 0xDB, 0xBF, 0xA6, 0x35, 0xDF, 0xC7, 0x49, 0x06, 0xC8, 0xDB, 0x74, 0x2A, 0xB9, 0xED, 0xB3, 0x04, 0x80, 0x75, 0x5F, 0x71, 0x2C, 0xD0, 0x14, 0x0E, 0x81, 0x18, 0x00, 0x5E, 0x34, 0x5A, 0xC2, 0x3A, 0x84, 0x63, 0xB1, 0x6B, 0x04, 0x21, 0x49, 0x7F, 0xE0, 0xF3, 0x52, 0x5E, 0x61, 0x43, 0xB1, 0x8F, 0x7C, 0xF2, 0x74, 0x29, 0x28, 0x69, 0x20, 0x36, 0xC0, 0x92, 0x17, 0x42, 0x99, 0x72, 0xE5, 0xE7, 0x82, 0xBE, 0x8E, 0x3B, 0x3F, 0xC9, 0x0A, 0xE1, 0xC4, 0x63, 0x68, 0x73, 0x1D, 0x67, 0x8D, 0xC0, 0xA3, 0xB4, 0xBA, 0xF0, 0xB7, 0xB0, 0x9B, 0xBB, 0x3F, 0xB8, 0x6E, 0xC0, 0x34, 0x1E, 0xA0, 0x01, 0x4B, 0x6D, 0x47, 0x73, 0x3F, 0xA5, 0x39, 0x05, 0x27, 0xD4, 0xD1, 0x38, 0x34, 0x32, 0x2C, 0x5B, 0x03, 0x5F, 0x16, 0x21, 0x64, 0x04, 0xD5, 0x19, 0xDB, 0xE7, 0x80, 0xDA, 0xBD, 0xC4, 0x1E, 0xAB, 0x61, 0xC8, 0x84, 0xDF, 0x54, 0x16, 0x77, 0x98, 0x9B, 0x90, 0x03, 0x83, 0xC4, 0x8D, 0x25, 0xB1, 0x32, 0x67, 0x77, 0x6A, 0x1C, 0x64, 0x2D, 0xFA, 0x9E, 0xB9, 0x26, 0xB5, 0xF8, 0x47, 0x4A, 0x9C, 0x35, 0x89, 0x5F, 0x12, 0x0E, 0xFF, 0x60, 0x87, 0x1E, 0x27, 0xC1, 0xC5, 0x7C, 0x77, 0x0A, 0xAE, 0x11, 0x37, 0xE3, 0x42, 0x9B, 0xAF, 0x9D, 0xBC, 0xC2, 0x52, 0xF8, 0x85, 0xBA, 0xED, 0x8E, 0xC3, 0x73, 0x04, 0x0A, 0x53, 0xD2, 0x1D, 0xEF, 0xA0, 0x6A, 0xCD, 0xBE, 0x93, 0x49, 0x34, 0x3A, 0xBD, 0xDF, 0x6A, 0x33, 0x25, 0x91, 0xFC, 0xE7};
    BCRYPT_ALG_HANDLE hAlgorithm = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    ULONG plaintextSize = 128;
    PUCHAR decryptedBuffer;
    ULONG decryptedBufferSize;
    NTSTATUS status;

    status = BCryptOpenAlgorithmProvider(&hAlgorithm,
                                            BCRYPT_RSA_ALGORITHM,
                                            NULL,
                                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get algorithm provider..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptImportKeyPair( hAlgorithm,
                                  NULL,
                                  BCRYPT_RSAPRIVATE_BLOB,
                                  &hKey,
                                  PrivateKey,
                                  PrivateKeySize,
                                  BCRYPT_NO_KEY_VALIDATION);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to import Private key..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptDecrypt( hKey,
                            encryptedBuffer,
                            encryptedBufferSize,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            0,
                            &decryptedBufferSize,
                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get required size of buffer..status : %08x\n"", status);
        goto cleanup;
    }

    decryptedBuffer = (PUCHAR)HeapAlloc (GetProcessHeap (), 0, decryptedBufferSize);
    if (decryptedBuffer == NULL) {
        printf(""failed to allocate memory for buffer\n"");
        goto cleanup;
    }

    status = BCryptDecrypt( hKey,
                            encryptedBuffer,
                            encryptedBufferSize,
                            NULL,
                            NULL,
                            0,
                            decryptedBuffer,
                            decryptedBufferSize,
                            &decryptedBufferSize,
                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed decrypt buffer..status : %08x\n"",status);
        goto cleanup;
    }

    printf(""Decrypted buffer\n"");
    printMem(decryptedBuffer, decryptedBufferSize);
    printf(""\n\n"");

cleanup:
    HeapFree(GetProcessHeap(), 0, decryptedBuffer);

    BCryptDestroyKey(hKey);

    BCryptCloseAlgorithmProvider(hAlgorithm, 0);
}


VOID Encrypt()
{
    unsigned char PublicKey[PublicKeySize] = {0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x01, 0x00, 0x01, 0xB7,  0x50, 0x52, 0xDD, 0x58, 0xE4, 0x96, 0xAF, 0x91,  0xE5, 0xB2, 0x7B, 0x0A,  0xE6, 0xAA, 0x1F, 0x71,  0x8A, 0x66, 0xC3, 0xF0, 0x21, 0xD8, 0xE6, 0x2C,  0xD6, 0x25, 0x2E, 0x77,  0x3C, 0x61, 0x08, 0x1B,  0x69, 0xE7, 0x58, 0xDF, 0x3B, 0x07, 0xFE, 0xF1,  0xDB, 0xBF, 0xA6, 0x35,  0xDF, 0xC7, 0x49, 0x06,  0xC8, 0xDB, 0x74, 0x2A, 0xB9, 0xED, 0xB3, 0x04,  0x80, 0x75, 0x5F, 0x71,  0x2C, 0xD0, 0x14, 0x0E,  0x81, 0x18, 0x00, 0x5E, 0x34, 0x5A, 0xC2, 0x3A,  0x84, 0x63, 0xB1, 0x6B,  0x04, 0x21, 0x49, 0x7F,  0xE0, 0xF3, 0x52, 0x5E, 0x61, 0x43, 0xB1, 0x8F,  0x7C, 0xF2, 0x74, 0x29,  0x28, 0x69, 0x20, 0x36,  0xC0, 0x92, 0x17, 0x42, 0x99, 0x72, 0xE5, 0xE7,  0x82, 0xBE, 0x8E, 0x3B,  0x3F, 0xC9, 0x0A, 0xE1,  0xC4, 0x63, 0x68, 0x73, 0x1D, 0x67, 0x8D, 0xC0,  0xA3, 0xB4, 0xBA, 0xF0,  0xB7, 0xB0, 0x9B};
    unsigned char InputData[InputDataSize];
    BCRYPT_ALG_HANDLE hAlgorithm = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    NTSTATUS status;

    for (int i=0; i<128; i++)
        InputData[i] = (unsigned char)rand();

    printf(""Random Data is \n"");
    printMem(InputData, InputDataSize);
    printf(""\n\n"");

    status = BCryptOpenAlgorithmProvider(    &hAlgorithm,
                                            BCRYPT_RSA_ALGORITHM,
                                            NULL,
                                            0 );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get algorithm provider..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptImportKeyPair( hAlgorithm,
                                  NULL,
                                  BCRYPT_RSAPUBLIC_BLOB,
                                  &hKey,
                                  PublicKey,
                                  155,
                                  BCRYPT_NO_KEY_VALIDATION );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to import Private key..status : %08x\n"",status);
        goto cleanup;

    }

    status = BCryptEncrypt( hKey,
                            InputData,
                            InputDataSize,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            0,
                            &encryptedBufferSize,
                            0
                            );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get required size of buffer..status : %08x\n"",status);
        goto cleanup;
    }

    encryptedBuffer = (PUCHAR)HeapAlloc (GetProcessHeap (), 0, encryptedBufferSize);

    if (encryptedBuffer == NULL) {
        printf(""failed to allocate memory for blindedFEKBuffer\n"");
        goto cleanup;
    }

    status = BCryptEncrypt( hKey,
                            InputData,
                            InputDataSize,
                            NULL,
                            NULL,
                            0,
                            encryptedBuffer,
                            encryptedBufferSize,
                            &encryptedBufferSize,
                            0
                            );

    if (!NT_SUCCESS(status))    {
        printf(""Failed encrypt data..status : %08x\n"",status);
        goto cleanup;
    }

printf(""Encrypted Data\n"");
printMem(encryptedBuffer, encryptedBufferSize);
printf(""\n\n"");

cleanup:
            if(hKey)
                BCryptDestroyKey(hKey);
            if(hAlgorithm)
                BCryptCloseAlgorithmProvider(hAlgorithm, 0);
}


int __cdecl wmain(
                   int argc,
                   __in_ecount(argc) LPWSTR *wargv)
{

    int i;
    for (i=0; i<10; i++)
    {
        Encrypt();
        Decrypt();
    }

}

","I tried your code and if I make the generation of InputData static and not random such as:
ZeroMemory( InputData, InputDataSize );
std::string strInput = ""This is just a test with a long long... very long string"";
for( int i = 0; i < (int)strInput.size(); i++ )
{
    InputData[i] = strInput[i];
}

It does not return any error, I think there are problems with the extreme values of rand().
","2375","<rsa><cng>","4","-1","3","2015-01-23 15:09:34","","1","2","","","","2011-06-11 13:26:12",""
"6316158","Bug in RSA encryption/decryption using CryptoAPI Next Generation (CNG) in Windows?","I have written a code to encrypt and decrypt data with a hardcoded RSA key pair that was previously generated using the CNG. It is a simple program that simply generates some random input data, encrypts it with the public key, and then decrypts the resulting encrypted buffer using the private key. I print all the input, intermediate and output stages to compare whether the decrypted plaintext is the same as the original input plaintext, and repeat the whole encrypt-decrypt 10 times.
However, I am observing that in some cases, the encryption and decryption are fine, but in others, the decrypted plaintext does not match the input plaintext at all. Such buggy cases are completely random and arbitrary and there does not seem to be any pattern to these bugs.
Is this a bug in the CNG's RSA implementation or am I doing something wrongly?
Code follows:

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <bcrypt.h>

#define NT_SUCCESS(Status)          (((NTSTATUS)(Status)) >= 0)
#define STATUS_UNSUCCESSFUL         ((NTSTATUS)0xC0000001L)

#define PrivateKeySize 283
#define PublicKeySize 155
#define InputDataSize 128

PUCHAR encryptedBuffer;
ULONG encryptedBufferSize = 128;


VOID printMem(PVOID Mem, int length)
{
    int i;
    for (i = 0; i < length; i++)
        printf(""%02x "", ((unsigned char *)Mem)[i]);
}

VOID Decrypt()
{
    unsigned char PrivateKey[PrivateKeySize] = {0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xB7, 0x50, 0x52, 0xDD, 0x58, 0xE4, 0x96, 0xAF, 0x91, 0xE5, 0xB2, 0x7B, 0x0A, 0xE6, 0xAA, 0x1F, 0x71, 0x8A, 0x66, 0xC3, 0xF0, 0x21, 0xD8, 0xE6, 0x2C, 0xD6, 0x25, 0x2E, 0x77, 0x3C, 0x61, 0x08, 0x1B, 0x69, 0xE7, 0x58, 0xDF, 0x3B, 0x07, 0xFE, 0xF1, 0xDB, 0xBF, 0xA6, 0x35, 0xDF, 0xC7, 0x49, 0x06, 0xC8, 0xDB, 0x74, 0x2A, 0xB9, 0xED, 0xB3, 0x04, 0x80, 0x75, 0x5F, 0x71, 0x2C, 0xD0, 0x14, 0x0E, 0x81, 0x18, 0x00, 0x5E, 0x34, 0x5A, 0xC2, 0x3A, 0x84, 0x63, 0xB1, 0x6B, 0x04, 0x21, 0x49, 0x7F, 0xE0, 0xF3, 0x52, 0x5E, 0x61, 0x43, 0xB1, 0x8F, 0x7C, 0xF2, 0x74, 0x29, 0x28, 0x69, 0x20, 0x36, 0xC0, 0x92, 0x17, 0x42, 0x99, 0x72, 0xE5, 0xE7, 0x82, 0xBE, 0x8E, 0x3B, 0x3F, 0xC9, 0x0A, 0xE1, 0xC4, 0x63, 0x68, 0x73, 0x1D, 0x67, 0x8D, 0xC0, 0xA3, 0xB4, 0xBA, 0xF0, 0xB7, 0xB0, 0x9B, 0xBB, 0x3F, 0xB8, 0x6E, 0xC0, 0x34, 0x1E, 0xA0, 0x01, 0x4B, 0x6D, 0x47, 0x73, 0x3F, 0xA5, 0x39, 0x05, 0x27, 0xD4, 0xD1, 0x38, 0x34, 0x32, 0x2C, 0x5B, 0x03, 0x5F, 0x16, 0x21, 0x64, 0x04, 0xD5, 0x19, 0xDB, 0xE7, 0x80, 0xDA, 0xBD, 0xC4, 0x1E, 0xAB, 0x61, 0xC8, 0x84, 0xDF, 0x54, 0x16, 0x77, 0x98, 0x9B, 0x90, 0x03, 0x83, 0xC4, 0x8D, 0x25, 0xB1, 0x32, 0x67, 0x77, 0x6A, 0x1C, 0x64, 0x2D, 0xFA, 0x9E, 0xB9, 0x26, 0xB5, 0xF8, 0x47, 0x4A, 0x9C, 0x35, 0x89, 0x5F, 0x12, 0x0E, 0xFF, 0x60, 0x87, 0x1E, 0x27, 0xC1, 0xC5, 0x7C, 0x77, 0x0A, 0xAE, 0x11, 0x37, 0xE3, 0x42, 0x9B, 0xAF, 0x9D, 0xBC, 0xC2, 0x52, 0xF8, 0x85, 0xBA, 0xED, 0x8E, 0xC3, 0x73, 0x04, 0x0A, 0x53, 0xD2, 0x1D, 0xEF, 0xA0, 0x6A, 0xCD, 0xBE, 0x93, 0x49, 0x34, 0x3A, 0xBD, 0xDF, 0x6A, 0x33, 0x25, 0x91, 0xFC, 0xE7};
    BCRYPT_ALG_HANDLE hAlgorithm = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    ULONG plaintextSize = 128;
    PUCHAR decryptedBuffer;
    ULONG decryptedBufferSize;
    NTSTATUS status;

    status = BCryptOpenAlgorithmProvider(&hAlgorithm,
                                            BCRYPT_RSA_ALGORITHM,
                                            NULL,
                                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get algorithm provider..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptImportKeyPair( hAlgorithm,
                                  NULL,
                                  BCRYPT_RSAPRIVATE_BLOB,
                                  &hKey,
                                  PrivateKey,
                                  PrivateKeySize,
                                  BCRYPT_NO_KEY_VALIDATION);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to import Private key..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptDecrypt( hKey,
                            encryptedBuffer,
                            encryptedBufferSize,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            0,
                            &decryptedBufferSize,
                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get required size of buffer..status : %08x\n"", status);
        goto cleanup;
    }

    decryptedBuffer = (PUCHAR)HeapAlloc (GetProcessHeap (), 0, decryptedBufferSize);
    if (decryptedBuffer == NULL) {
        printf(""failed to allocate memory for buffer\n"");
        goto cleanup;
    }

    status = BCryptDecrypt( hKey,
                            encryptedBuffer,
                            encryptedBufferSize,
                            NULL,
                            NULL,
                            0,
                            decryptedBuffer,
                            decryptedBufferSize,
                            &decryptedBufferSize,
                            0);
    if (!NT_SUCCESS(status)) {
        printf(""Failed decrypt buffer..status : %08x\n"",status);
        goto cleanup;
    }

    printf(""Decrypted buffer\n"");
    printMem(decryptedBuffer, decryptedBufferSize);
    printf(""\n\n"");

cleanup:
    HeapFree(GetProcessHeap(), 0, decryptedBuffer);

    BCryptDestroyKey(hKey);

    BCryptCloseAlgorithmProvider(hAlgorithm, 0);
}


VOID Encrypt()
{
    unsigned char PublicKey[PublicKeySize] = {0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x01, 0x00, 0x01, 0xB7,  0x50, 0x52, 0xDD, 0x58, 0xE4, 0x96, 0xAF, 0x91,  0xE5, 0xB2, 0x7B, 0x0A,  0xE6, 0xAA, 0x1F, 0x71,  0x8A, 0x66, 0xC3, 0xF0, 0x21, 0xD8, 0xE6, 0x2C,  0xD6, 0x25, 0x2E, 0x77,  0x3C, 0x61, 0x08, 0x1B,  0x69, 0xE7, 0x58, 0xDF, 0x3B, 0x07, 0xFE, 0xF1,  0xDB, 0xBF, 0xA6, 0x35,  0xDF, 0xC7, 0x49, 0x06,  0xC8, 0xDB, 0x74, 0x2A, 0xB9, 0xED, 0xB3, 0x04,  0x80, 0x75, 0x5F, 0x71,  0x2C, 0xD0, 0x14, 0x0E,  0x81, 0x18, 0x00, 0x5E, 0x34, 0x5A, 0xC2, 0x3A,  0x84, 0x63, 0xB1, 0x6B,  0x04, 0x21, 0x49, 0x7F,  0xE0, 0xF3, 0x52, 0x5E, 0x61, 0x43, 0xB1, 0x8F,  0x7C, 0xF2, 0x74, 0x29,  0x28, 0x69, 0x20, 0x36,  0xC0, 0x92, 0x17, 0x42, 0x99, 0x72, 0xE5, 0xE7,  0x82, 0xBE, 0x8E, 0x3B,  0x3F, 0xC9, 0x0A, 0xE1,  0xC4, 0x63, 0x68, 0x73, 0x1D, 0x67, 0x8D, 0xC0,  0xA3, 0xB4, 0xBA, 0xF0,  0xB7, 0xB0, 0x9B};
    unsigned char InputData[InputDataSize];
    BCRYPT_ALG_HANDLE hAlgorithm = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    NTSTATUS status;

    for (int i=0; i<128; i++)
        InputData[i] = (unsigned char)rand();

    printf(""Random Data is \n"");
    printMem(InputData, InputDataSize);
    printf(""\n\n"");

    status = BCryptOpenAlgorithmProvider(    &hAlgorithm,
                                            BCRYPT_RSA_ALGORITHM,
                                            NULL,
                                            0 );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get algorithm provider..status : %08x\n"",status);
        goto cleanup;
    }

    status = BCryptImportKeyPair( hAlgorithm,
                                  NULL,
                                  BCRYPT_RSAPUBLIC_BLOB,
                                  &hKey,
                                  PublicKey,
                                  155,
                                  BCRYPT_NO_KEY_VALIDATION );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to import Private key..status : %08x\n"",status);
        goto cleanup;

    }

    status = BCryptEncrypt( hKey,
                            InputData,
                            InputDataSize,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            0,
                            &encryptedBufferSize,
                            0
                            );
    if (!NT_SUCCESS(status)) {
        printf(""Failed to get required size of buffer..status : %08x\n"",status);
        goto cleanup;
    }

    encryptedBuffer = (PUCHAR)HeapAlloc (GetProcessHeap (), 0, encryptedBufferSize);

    if (encryptedBuffer == NULL) {
        printf(""failed to allocate memory for blindedFEKBuffer\n"");
        goto cleanup;
    }

    status = BCryptEncrypt( hKey,
                            InputData,
                            InputDataSize,
                            NULL,
                            NULL,
                            0,
                            encryptedBuffer,
                            encryptedBufferSize,
                            &encryptedBufferSize,
                            0
                            );

    if (!NT_SUCCESS(status))    {
        printf(""Failed encrypt data..status : %08x\n"",status);
        goto cleanup;
    }

printf(""Encrypted Data\n"");
printMem(encryptedBuffer, encryptedBufferSize);
printf(""\n\n"");

cleanup:
            if(hKey)
                BCryptDestroyKey(hKey);
            if(hAlgorithm)
                BCryptCloseAlgorithmProvider(hAlgorithm, 0);
}


int __cdecl wmain(
                   int argc,
                   __in_ecount(argc) LPWSTR *wargv)
{

    int i;
    for (i=0; i<10; i++)
    {
        Encrypt();
        Decrypt();
    }

}

","This is not a bug in CNG, it's an artifact of the way raw RSA encryption works. Some of the random values that you are encrypting are greater than the modulus of the key (the modulus is the value of the 2 prime numbers in the RSA key multiplied together), which means values wrap-around (if you set InputData[0] = 0 you will see that input and output always match).
You'll also want to be either passing BCRYPT_PAD_PKCS1 or BCRYPT_PAD_OAEP to the dwFlags parameter of BCryptEncrypt/BCryptDecrypt as raw RSA encryption is not secure. If you use BCRYPT_PAD_OAEP you'll also have to supply a BCRYPT_OAEP_PADDING_INFO structure.
","2375","<rsa><cng>","4","2","3","2015-01-23 15:09:34","","1","2","","","","2011-06-11 13:26:12",""
"22762380","Importing ECC-based certificate from the Windows Certificate Store into CngKey","How can I get the public/private keys from an ECC-based X509Certificate2's into CngKey's for use with ECDsaCng and ECDiffieHellmanCng?
I'm currently using RSA 2048 bit key pairs to sign/encrypt stuff.  I'm doing this by pulling the certificates from the X509Store where they are securely stored with private keys marked as non-exportable.  I would like to convert the current implementation to use ECDSA and ECDH so that I can use smaller key sizes for equivalent security.
I've successfully generated ECC certs using openssl:

openssl ecparam -out private.pem -name prime256v1 -genkey
openssl req -new -key private.pem -x509 -nodes -days 365 -out public.cer
openssl pkcs12 -export -in public.cer -inkey private.pem -out export.pfx

I've successfully installed the above generated certs in to the cert store.  I can retrieve them by thumbprint, but the crypto providers for the private and public keys throw ""Algorithm not supported"" exceptions.  Instead, I understand I'm supposed to use ECDsaCng and ECDiffieHellmanCng to sign/encrypt.  But these deal in CngKey's.
Bouncy Castle isn't an option because it requires the private keys to be exportable.
CLR Security will return me a CngKey pair via GetCngPrivateKey but it cannot be used with ECDsa because the key returned by CLRSecurity is an ECDH key.  Furthermore CLR Security doesn't give me a way to get just the public key from an X509Certificate2 for signature verification (where I don't even have or need the private key of the signer).
Any ideas?  I'm at my wits end...  Any help would be much appreciated.
","You need to create the CngKey from the public key of the certificate:

certificate.PublicKey.EncodedKeyValue.RawData

The CngKey contains 8 additional bytes, the first 4 bytes are used for the name of the curve used (ECS1, ECS3 or ECS5), the last 4 are the length of the key incl. padding (32, 48 or 66).
The first byte of the public key from the certificate is removed (as it is always 0x04 for ECDSA public key). 
So for instance for ECDSA using P-256 curve and SHA-256 hash algorithm, you will get a public key of length 65 bytes. Discard the first byte, leaving 64 bytes, then prefix with 4 bytes for curve and 4 bytes for key length i.e. (Encoding.ASCII):

69 (E) 
67 (C) 
83 (S) 
49 (1) 
32 (Key length)
0 
0 
0

Now you have the public key (72 bytes) to create the CngKey from:

var cngKey = CngKey.Import([the byte array], CngKeyBlobFormat.EccPublicBlob);
var ecdsaCng = new ECDsaCng(cngKey);

And you can verify the signature:

return ecdsaCng.VerifyData(encodedBytes, signature);

","2289","<.net><security><x509certificate2><ecdsa><cng>","15","6","1","2015-06-12 18:16:00","24233060","0","1","464604","","2014-03-31 22:56:28","2014-03-31 13:07:31",""
"9711568","Does winapi's bcrypt.h actually support bcrypt hashing?","This may sound like a strange question, and it feels a bit bizarre that I actually have to ask this, but after spending a couple hours looking over the MSDN documentation for the bcrypt routines that were added in Vista, I've almost reached the conclusion that there is no actual bcrypt support!
According to Wikipedia:

bcrypt is an adaptive cryptographic hash function for passwords
  ... based on the Blowfish cipher ... Besides incorporating a
  salt to protect against rainbow table attacks, bcrypt is an adaptive
  hash: over time it can be made slower and slower so it remains
  resistant to specific brute-force search attacks against the hash and
  the salt.

However, from the documentation on MSDN, the ""bcrypt"" library is apparently actually a generic interface for encryption and hashing.  You have to obtain a handle to an ""algorithm provider"" via the BCryptOpenAlgorithmProvider function, which has several built-in algorithms to choose from.  But the word ""blowfish"" does not appear anywhere in the list.
So am I missing something?  Am I reading this wrong?  Or does Windows's ""bcrypt"" library not actually support bcrypt at all?
","the BCrypt APIs are generic and support various cryptographic hash algorithms, but bcrypt is not one of them.  The B Prefix seems to be just a way to distinguish between the older APIs and the Next Generation.
","1958","<windows><winapi><windows-vista><cng>","10","4","2","2019-08-19 10:02:26","","1","1","608639","","2019-08-19 10:02:26","2012-03-14 22:57:33",""
"9711568","Does winapi's bcrypt.h actually support bcrypt hashing?","This may sound like a strange question, and it feels a bit bizarre that I actually have to ask this, but after spending a couple hours looking over the MSDN documentation for the bcrypt routines that were added in Vista, I've almost reached the conclusion that there is no actual bcrypt support!
According to Wikipedia:

bcrypt is an adaptive cryptographic hash function for passwords
  ... based on the Blowfish cipher ... Besides incorporating a
  salt to protect against rainbow table attacks, bcrypt is an adaptive
  hash: over time it can be made slower and slower so it remains
  resistant to specific brute-force search attacks against the hash and
  the salt.

However, from the documentation on MSDN, the ""bcrypt"" library is apparently actually a generic interface for encryption and hashing.  You have to obtain a handle to an ""algorithm provider"" via the BCryptOpenAlgorithmProvider function, which has several built-in algorithms to choose from.  But the word ""blowfish"" does not appear anywhere in the list.
So am I missing something?  Am I reading this wrong?  Or does Windows's ""bcrypt"" library not actually support bcrypt at all?
","In the context of the MSDN, BCrypt is a shortform of ""BestCrypt"", but the PR name for it is:

Cryptography API: Next Generation (Cng)

It is implemented in bcrypt.dll. 
BestCrypt/BCrypt/Cng is the successor to the older CryptoAPI.
Microsoft is slowly removing references to ""BestCrypt"" from their site, but you can still see it in some pages like:

SHA256Cng Class
This algorithm is for hashing only and does not provide any encryption or decryption. It uses the BCrypt (BestCrypt) layer CNG.

It's interesting (to me anyway) that the .NET framework generally can provide you three implementations for the each kind of crypto algorithm. For example, for SHA2 hashing, there is:

SHA256Managed: an implementation written purely in managed code
SHA256CryptoServiceProvider: a wrapper around the native Cryptographic Service Provider (CSP) implementation
SHA256Cng: a wrapper around Cryptography Next Gen (Cng) implementation

Short version
No, bcrypt is short for bestcrypt. And, no, it doesn't support bcrypt (blowfish crypt) password hashing.
","1958","<windows><winapi><windows-vista><cng>","10","8","2","2019-08-19 10:02:26","","1","1","608639","","2019-08-19 10:02:26","2012-03-14 22:57:33",""
"17931487","Load certificate keys into CngKey class for use with DiffieHellman (ECDiffieHellmanCng class)","This is related to .NET / C#. Lets assume there is a certificate + private key (P521 ECC one) inside a PFX or a PKCS#12 file. We have loaded this certificate and it's private key into the Windows certificate store by installing it (either double clicking the PFX or running certutil -f -p myPfxPassword -importPFX MY SomeEcCert.pfx). I have noted that if the certificate is compatible (eg. p521 curve), it is automatically installed as a CNG certificate/key.
Now, how can I load the private key into a CngKey so I can then use it inside the ECDiffieHellmanCng class? I would also like to load the X509 (CNG) certificate to read it's serial #, issuer, common name etc for some bookkeeping. 
var myCngKey = SomehowLoadTheCngKey(""my ecc certificate""); // <== ??
var myDH = new ECDiffieHellmanCng(myCngKey);

","Well, .NET's doesn't have a good API into CNG. If you even scratch the surface of their API you immediately see it's kinda ridiculous, especially considering both are from Microsoft and CNG is the most serious of all Crypto APIs on the entire windows platform.
So you need to use CLRSecurity which provides C# interfaces (via P/Invoke) into the C++ CNG API. Even with that it's not the nicest of API designs; but it helps.
// Load the cert, many ways, one implementation
var store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
store.Open(OpenFlags.OpenExistingOnly | OpenFlags.ReadOnly);
var certs = store.Certificates.Find(X509FindType.FindBySubjectName, ""My cert subject name"", true);
store.Close();

if (certs.Count > 0)
    cert = certs[0];
else
    return;

// Magic happens here! We load the private CngKey (if it exists)
// You need CLR Security for this, it manages the P/Invoke
// into the C++ api behind the scenes. 
var pvtCngKey = cert.GetCngPrivateKey(); 

// Create the DiffieHellman helper
var ecDh = new ECDiffieHellmanCng(ourPvtEcCngKey)
{
   KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash,
   HashAlgorithm = CngAlgorithm.Sha256
};

ECDiffieHellmanCngPublicKey theirPubCngKey = LoadOtherPartiesCngPublicKey(theirCert);
byte[] symKey = ecDh.DeriveKeyMaterial(theirPubCngKey);

","1857","<c#><encryption><public-key-encryption><diffie-hellman><cng>","3","1","1","2014-04-02 18:23:25","","0","","862563","","2013-08-09 01:28:36","2013-07-29 18:27:31",""
"8589807",".Net, XmlDSigEx: CngKey.import using public key from X509Certificate2","I'm trying to validate XML Signatures that have been signed with ECDsa algorithms. I'm basing my work on the XmlDSigEx library, which I have to modify slightly to fit my needs. My present problem is related to getting the public key from the certificate and use it as a CngKey. I used:
// var cert = X509Certificate2 ...
var key = CngKey.Import(cert.GetPublicKey(), CngKeyBlobFormat.EccPublicBlob);

which throws ""The parameter is not correct"". I could not find any information which format of the public key is expected to be passed in as the key. I kindly ask therefore for help on this matter: How do I pass the public key stored in the X509Certificate to the CngKey?
TIA,
Alois
PS: I considered to use BouncyCastle to extract the public key. I tried BC's 
X509Certificate.CertificateStructure.SubjectPublicKeyInfo.GetEncoded()

as well as
X509Certificate.CertificateStructure.SubjectPublicKeyInfo.PublicKeyData.GetBytes()

to pass the key to the CngKey; however the same error occures.
","I have been battling the same type of issue but using BouncyCastle for C# and trying to import the keys into CngKey. ECDsaCng supports RFC4050 XML format for public key import. I have managed to import keys generated using BouncyCastle using the code below and verify hashes with ECDsaCng which were produced with BouncyCastle.
//Specify which curve we are using   
string theCurveName = ""prime256v1"";

X509Certificate2 x509cert = null; //get your x509 certificate here...

//BouncyCastle publickey creation from certificate publickey
var namedCurve = X962NamedCurves.GetByName(theCurveName);

ECPublicKeyParameters publickey = new ECPublicKeyParameters(""ECDSA"",
    namedCurve.Curve.DecodePoint(x509cert.GetPublicKey()), // Q
    X962NamedCurves.GetOid(theCurveName));

//now we have the public key in bouncy castle
//we can create the xml to import to CngKey            
//Prime256v1 = 1.2.840.10045.3.1.7

var xmlImport = @""<ECDSAKeyValue xmlns='http://www.w3.org/2001/04/xmldsig-more#'>
  <DomainParameters>
    <NamedCurve URN='urn:oid:"" + X962NamedCurves.GetOid(theCurveName).Id + @""' />
  </DomainParameters>
  <PublicKey>
    <X Value='"" + publickey.Q.X.ToBigInteger().ToString() + @""' xsi:type='PrimeFieldElemType' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' />
    <Y Value='"" + publickey.Q.Y.ToBigInteger().ToString() + @""' xsi:type='PrimeFieldElemType' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' />
  </PublicKey>
</ECDSAKeyValue>"";

var eccImporter = new ECDsaCng();
eccImporter.FromXmlString(xmlImport, ECKeyXmlFormat.Rfc4050);


//prep bouncy castle signature to single array
var sig0 = sig[0].ToByteArrayUnsigned();
var sig1 = sig[1].ToByteArrayUnsigned();   
byte[] newSig = new byte[sig0.Length + sig1.Length];
sig0.CopyTo(newSig, 0);
sig1.CopyTo(newSig, sig0.Length);

var isok = eccImporter.VerifyHash(manualhash, newSig);

","1835","<.net><x509certificate><cng>","3","0","1","2012-02-24 15:02:19","","0","2","542129","","2011-12-21 12:38:47","2011-12-21 12:26:09",""
"28113156","Using primitive function with key stored in Microsoft KSP","My question is about use case with CNG API and Microsoft providers. I don't write code sample because I ask for your help about the best way to use CNG API in my application compared to CSP API.
I built an application which use symetric keys stored using these steps:

enumerate certificates in ""My"" store using CertFindCertificateInStore
for each certificate found, asking for private key informations using CertGetCertificateContextProperty
for each private key informations found, storing provider name pwszProvName and container name pwszContainerName

Then, when a key is found, my application performs signature function using private key found using CSP API:

Initialize provider operation using CryptAcquireContext with pwszProvName and pwszContainerName
Compute signature using CSP functions: CryptCreateHash, CryptHashData and CryptSignHash

All is OK with CSP function.
Now I try signature operation using CNG API:

Initialize provider operation using NCryptOpenStorageProvider with pwszProvName
Open algorithm provider using CNG function BCryptOpenAlgorithmProvider fails with STATUS_NOT_FOUND

This error happens when the private key is stored in Microsoft Software Key Storage Provider.
Reading Microsoft documentation I understand that type of provider is KSP provider, and only functions about key management. That's why it fails when I try a primitive function, I need to use a ""Primitive Provider"".
I found the way to use CNG provider following these setps:

Windows Server 2008: create a certificate template with provider requirement (on ""encryption"" tab). And the only one provider availabe is ""Microsoft Software Key Storage Provider
Windows 7: user ask for key generation, the key is stored in Microsoft KSP.

So here are my questions: 

Is it normal I can't perform primitive function with ""Microsoft Software Key Storage Provider"" ?
If I can't perform primitive functions (signature, encryption, decryption, hash) with Microsoft KSP (which is KSP provider), how can I make my private key stored and managed in a Microsoft Primitive Provider? 

My trouble here, is that with CSP API, default Microsoft CSP provider performs signature (and decyrption, encryption, etc) function. But with CNG API, default provider only performs key storage management.
","For asymmetric keys, the functionality supported by a CNG Key Storage Provider is comparable to that of a Primitive Provider, apart of course from the the fact that the KSP (Key Storage Provider) allows you to persist and load keys.
In fact, the KSP API calls for doing the crypto operations look much the same as the primitive ones, except the KSP ones start with N and the primitive ones start with B.
For example:

NCryptSignHash for KSP signing
NCryptSecretAgreement for KSP secret agreement
NCryptEncrypt for KSP asymmetric encryption

What is missing from the KSP is symmetric functionality (including hashing), and this may be where the confusion has arisen. Compared to CAPI (CSP/Crypto API), the CNG signing functions are a bit more low-level - you hash the data separately first, and then pass that hash byteblock to NCryptSignHash (no hash object handle like in CAPI).
To re-iterate, as this is a source of confusion for people coming from CAPI, you can hash with any primitive provider, MS_PRIMITIVE_PROVIDER or a third-party provider, and then pass the result to any Key Storage Provider's NCryptSignHash, because it's just bytes of data, it doesn't matter who did the hashing. The NCRYPT_KEY_HANDLE passed to NCryptSignHash determines what KSP is used to do the signing; there is no CNG equivalent of HCRYPTHASH passed to NCryptSignHash.
So, if you want to sign with a KSP, you should hash the message to be signed first with a primitive provider (using BCryptCreateHash/BCryptHashData/BCryptFinishHash), and pass the result to NCryptSignHash.
","1820","<c++><certificate><key><cng>","2","1","1","2016-05-02 00:15:01","28118758","0","1","608639","","2016-05-02 00:15:01","2015-01-23 15:26:35",""
"30125416","Import a persistent key in to Windows key storage using CNG storage functions","I'm trying to import a persistent RSA public key into the key storage. I read on the CNG help page that it's possible for private keys and I wonder if I can also apply is to public keys (specifically the BCRYPT_RSAPUBLIC_BLOB). I've tried with the following code, but in the import section, when I call NCryptSetProperty to set the public blob as a property, I get ""Error 0x80090029"" which is NTE Bad Data. Having trouble debugging why this function is failing.
NCRYPT_PROV_HANDLE providerHandle = NULL;
NCRYPT_KEY_HANDLE keyHandle = NULL;
NTSTATUS status = STATUS_UNSUCCESSFUL;
PBYTE blob = NULL;
DWORD blob_len = 0;

///////////////////Export Test (extract key from storage)///////////////////////////

// Open handle to the Key Storage Provider
if(FAILED(status = NCryptOpenStorageProvider(
    &providerHandle,            //OUT: provider handle
    MS_KEY_STORAGE_PROVIDER,    //IN: Microsoft key storage provider
    0)))                        //IN: dwFlags (unused)
{
    //report fail
}

// Open key in the Key Storage Provider
if (FAILED(status = NCryptOpenKey(
    providerHandle,
    &keyHandle,
    keyName.c_str(),
    0,
    0)))
{
    //report fail
}

// (2 step key extraction process) 1. Get size of key
if (FAILED(status = NCryptExportKey(
    keyHandle,              //IN: Handle of the key to export
    NULL,                   //IN(opt): key used to encrypt exported BLOB data   <-- potentially an safer way for key extraction, encrypt it with a key during extraction (decrypt with NCryptDecrypt)
    BCRYPT_RSAPUBLIC_BLOB,  //IN: BLOB type (https://msdn.microsoft.com/en-us/library/windows/desktop/aa376263%28v=vs.85%29.aspx)
    NULL,                   //IN(opt): List of paramters for the key
    NULL,                   //OUT(opt): Output byte buffer
    0,                      //IN:  Size of the output buffer
    &blob_len,              //OUT: Amount of bytes copied to the output buffer
    0)))                    //IN: Flag to modify function behaviour (0 means no flag set)
{
    //report fail
}

// Allocate data blob to store key in
blob = (PBYTE)malloc(blob_len); 
if (NULL == blob) {
    //report fail
}

// (2 step key extraction process) 2. Get key and store in byte array (Extracted key is in form of BCRYPT_RSAKEY_BLOB)
if (FAILED(status = NCryptExportKey(
    keyHandle,
    NULL,
    BCRYPT_RSAPUBLIC_BLOB,
    NULL,
    blob,
    blob_len,
    &blob_len,
    0)))
{
    //report fail
}


///////////////Import Test (Store into storage)//////////////////////////////////////////////

// Create a persisted key
if(FAILED(status = NCryptCreatePersistedKey(
    providerHandle,             //IN: provider handle
    &keyHandle,                 //OUT: Handle to key
    NCRYPT_RSA_ALGORITHM,       //IN: CNG Algorithm Identifiers. NCRYPT_RSA_ALGORITHM creates public key
    keyName.c_str(),            //IN: Key name. If NULL, the key does not persist 
    0,                          //IN: Key type
    NCRYPT_OVERWRITE_KEY_FLAG)))//IN: Behaviour: 0 - apply to current user only, NCRYPT_MACHINE_KEY_FLAG - apply to local comp only, NCRYPT_OVERWRITE_KEY_FLAG - overwrite existing key
{
    //report fail
}

// Set the size of the key
if(FAILED(status = NCryptSetProperty(
    keyHandle,                          //IN: Handle to key
    BCRYPT_RSAPUBLIC_BLOB,              //IN: CNG Algorithm Identifiers. BCRYPT_RSAPUBLIC_BLOB allows me to use set this blob as the new key's blob
    blob,                               //IN: Key name. If NULL, the key does not persist 
    blob_len,                           //IN: Key Length
    0)))                                //IN: Bahaviour: 0 - apply to current user only, NCRYPT_MACHINE_KEY_FLAG - apply to local comp only, NCRYPT_OVERWRITE_KEY_FLAG - overwrite existing key
{
    //report fail <<-------------------------- Fail here
}

// Finalize key generation (Key is now usable, but uneditable) 
if(FAILED(status = NCryptFinalizeKey(keyHandle, 0)))            {
    //report fail
}
////////////////////////////////////////////////////////////////////////

","On creation of an asymmetric key, one of the properties that can be set is the NCRYPT_EXPORT_POLICY_PROPERTY. I used this to control whether the private could be read or not. 
//... after NCryptCreatePersistedKey()

    DWORD export_policy = NCRYPT_ALLOW_EXPORT_FLAG | NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG;

    if(FAILED(status = NCryptSetProperty(
        keyHandle,
        NCRYPT_EXPORT_POLICY_PROPERTY,
        (PBYTE)&export_policy,  
        static_cast<DWORD>(sizeof(DWORD)),
        NCRYPT_PERSIST_FLAG | NCRYPT_SILENT_FLAG)))
    {
        //report error
    }

//... before NCryptFinalizeKey()

The properties are defined here. 
https://msdn.microsoft.com/en-us/library/windows/desktop/aa376242(v=vs.85).aspx
","1790","<c++><key><blob><cng>","0","0","1","2015-05-08 19:00:08","","1","1","","","","2015-05-08 13:44:46",""
"48762602","TPM Owner password and lockout password with Windows 10 & linux","I've setup a dual boot so I have windows 10 and ubuntu.
Following steps on this page I'm able to retrieve the lockout password and the owner password of my TPM in the windows 10 registry. Result looks like this :
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TPM\WMI\Admin
OwnerAuthStatus    REG_DWORD    0x1
LastAuthLevel    REG_DWORD    0x4
OwnerAuthFull    REG_SZ    iTcW8t1B+tIKmP/uxXPL94QF2Jw=
LockoutHash    REG_SZ    Ki1RiIu8d+eqeDoEFYcAqIoi1n4=
SRKPub    REG_BINARY    A3FEFDE6DBAA425D24717422C46C7E9C85C433CB
StorageOwnerAuth    REG_SZ
TPMCleared    REG_DWORD    0x0

OwnerAuthFull and LockoutHash are both base64 encoded so I can decode them using this link for instance (it give 893716F2DD41FAD20A98FFEEC573CBF78405D89C in hexa for the owner password).
After that booting on the ubuntu I'm trying to interact with the TPM using these passwords. I'm using tpm2-tools to interact with the TPM under ubuntu.
Tpm2-tools works pretty well when the linux controls the TPM and sets up these passwords. But here I'm trying to let Windows have control of the TPM and still be able to communicate with it under Ubuntu. For instance when I run these commands (which works when ubuntu controls the TPM).

$ tpm2_createprimary --hierarchy e -g sha256 -G rsa -C primary.ctx
attributes:
  value: fixedtpm|fixedparent|sensitivedataorigin|userwithauth|restricted|decrypt
  raw: 0x30072
$ tpm2_create -g sha256 -G rsa -u key.pub -r key.priv  -c primary.ctx
algorithm:
  value: sha256
  raw: 0xb
attributes:
  value: fixedtpm|fixedparent|sensitivedataorigin|userwithauth|decrypt|sign
  raw: 0x60072
type:
  value: rsa
  raw: 0x1
  rsa: d14e5b7473972e4430b780dff0ec31a3a021fa0049ea1bafc17e2de4e232cba3afcdd8504c9f7dc2fa57df04ec1f64759f6bb0d8563c1ac53a7ce8d563ab7437f1f4b760960acfde7c414355c371ac8c94bba0e004bb08b499f115ba5e8efd655174c87309d64a23e198f6fce8e5451a851b7e96f7c172ba3d4be8e339176d136752e5d038ad9979585008e35bdedfdabe3236b92c60d5c4eabcafaabc8c65401aab5b479d8471d20ca18631c31404b38f3d373b5612ca906599914865cf281e550a748685fed4d60a7aa9c955d374c1d0852bb36ce9d39209e66fada20e4c473765160988470e93b63d81361613e3f5b918da167048ff8afe5e74768544fe03
$ tpm2_load -c primary.ctx  -u key.pub  -r key.priv -n key.name -C key.ctx

Load succ.
LoadedHandle: 0x80000100

$ tpm2_evictcontrol --auth o -c key.ctx --persistent 0x81010003 -P hex:893716F2DD41FAD20A98FFEEC573CBF78405D89C
persistentHandle: 0x81010003
ERROR: Tss2_Sys_EvictControl(0x9A2) - tpm:session(1):authorization failure without DA implications

I get  ERROR: Tss2_Sys_EvictControl(0x9A2) - tpm:session(1):authorization failure without DA implications.
Does anybody knows why I get this error / why this password doesn't work? Where could I get the right password ? Well any pointer on how to solve this problem is appreciated!
Thx!
","I think I got my answer, in fact Windows make a sha1 hash of the password then converts it to base64 and then stores it in the registry if gpedit is configured like so :
https://msdn.microsoft.com/en-us/library/windows/desktop/aa376421(v=vs.85).aspx
","1715","<encryption><cng><tpm><bitlocker>","2","1","1","2018-02-13 15:22:03","48770087","0","","","","","2018-02-13 08:41:57",""
"43980660","Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa","I have the following problem, and cant find solution:
While consuming APN (Apple push notifications) API, i implemented tokenized authorization. It's apple's new way of authorization on their push notifications api. 
Apple provides me private key, which i use to create c# CngKey object, which then i use to sign data.
    CngKey key = CngKey.Import(
       Convert.FromBase64String(privateKey),
       CngKeyBlobFormat.Pkcs8PrivateBlob);

using (ECDsaCng dsa = new ECDsaCng(key))
{
    dsa.HashAlgorithm = CngAlgorithm.Sha256;
    var unsignedJwtData =
        Url.Base64urlEncode(Encoding.UTF8.GetBytes(header)) + ""."" + Url.Base64urlEncode(Encoding.UTF8.GetBytes(payload));
    var signature =
        dsa.SignData(Encoding.UTF8.GetBytes(unsignedJwtData));
    return unsignedJwtData + ""."" + Url.Base64urlEncode(signature);
}

The result is signed token, which i then use as authorization header while consuming API and sending push notifications. 
It works well on my dev machine, but when i deploy it to Windows Server, when this code runs i get next:
System.ArgumentException: Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa.
Parameter name: key
   at System.Security.Cryptography.ECDsaCng..ctor(CngKey key)
   at OTTCommon.Encryption.ECDSA.SignES256(String privateKey, String header, String payload, ILog log)

I cant find solution, it is something with windows key storage or something like that....
What should i do?
","This is fixed in the .NET Framework 4.6.2, so the easiest solution would perhaps be to get the server upgraded.
A workaround that works for NIST P-256, NIST P-384, and NIST P-521 is to change the dwMagic value in the blob export.  (It won't work for the Windows 10 Generic ECC, because the dwMagic values aren't aligned the same way).
byte[] blob = key.Export(CngKeyBlobFormat.EccPrivateBlob);
key.Dispose();

The first 4 bytes of this blob map to the dwMagic value in the BCRYPT_ECCKEY_BLOB structure.
BCRYPT_ECDH_PRIVATE_P256_MAGIC has value 0x324B4345, which is the Little-Endian representation of ""ECK2"" (Elliptic Curve Key-exchange 2).  BCRYPT_ECDSA_PRIVATE_P256_MAGIC has value 0x32534345, which is the Little-Endian representation of ""ECS2"" (Elliptic Curve Signing 2).
// Change it from Key-exchange (ECDH) to Signing (ECDSA)
blob[1] = 0x53;

key = CngKey.Import(blob, CngKeyBlobFormat.EccPrivateBlob);

And now it sees that it's an ECDSA key, and everything is happy.
","1618","<c#><apple-push-notifications><ecdsa><apn><cng>","4","5","1","2017-05-15 14:56:41","43982666","0","2","","","","2017-05-15 13:18:11",""
"6172577","key not valid for use in specified state","we are using CNG for encrypting some of our sensitive data. As a standard, we implement the SQL Integrated Security instead of using a SQL user with DB permissions. To implement this, we define the application Pool Identity as the same Active Directory identity which is given appropriate DB permission. 
Now, the problem is when my AppPool runs under Local System i can create & retrieve keys from CNG Key Store however, the moment i change that identity to active directory user, i start getting ""Key not valid for use in specified state"" when i am trying retrieve the keys from CNG Store. Here are some of our observations:

To implement CNG at User level, we need to be able to create User Level CNG keys instead of Machine keys. we have done that and the User level keys is getting created successfully, we can see it in UserProfile - C:\Users\ADusername\AppData\Roaming\Microsoft\Crypto\Keys

We have set the ""LoadUserProfile=True"" in Pool Settings. 
We have given read/modify permission for AD user to %windows%\Microsoft.Net\Framework\Asp.Net Temp files as well


we still continue to get this error. Any help would be highly appreciated.
","I know this is an older question but I figured I would post a suggestion. I was trying to run an existing application on local IIS with the app pool running under AD creds and I was getting this same exception when calling the .ToXmlString(true) on the RSACryptoServiceProvider object. 
They way I fixed this issue was just to re-import the key on my local machine and check the ""Mark this key as exportable"" checkbox.
","1600","<asp.net><security><encryption><cng>","4","1","1","2015-10-21 14:07:59","","2","1","","","","2011-05-30 05:28:20",""
"17926341","CNG Microsoft Smart Card Key Storage Provider AcquireContext","I'm trying to acquire the Microsoft Smart Card Key Storage Provider using:
CryptAcquireContext(&hProv, contName ,L""Microsoft Smart Card Key Storage Provider"", PROV_RSA_FULL , flags);

but, this fails with error: NTE_KEYSET_NOT_DEF (0x80090019)
if I use:
CryptAcquireContext(&hProv, contName ,L"" Microsoft Base Smart Card Crypto Provider"", PROV_RSA_FULL , flags);

it works. 
But as far as my knowledge goes the Base Smart Card provider is the provider before CNG was introduced.
So what is the right Provider Name to use the CNG KSP for Smart Cards?
Thanks for your help! 
","The problem is that you don't use CryptAcquireContext for CNG providers.  To open a CNG provider use NCryptOpenStorageProvider.
","1212","<c++><smartcard><cng>","1","1","1","2013-07-31 20:30:21","17980356","0","","","","","2013-07-29 14:13:31",""
"7949471","Windows CNG ECDH Secret Agreement structure","I've spent a few days by searching what structure does ECDH secret agreement have, but no success. I found in MSDN that the NCryptSecretAgreement function sets a pointer to an NCRYPT_SECRET_HANDLE variable that receives a handle that represents the secret agreement value. I'm not familar with WinAPI at all so I simply can't do anything but reading docs.
I need to exchange keys between a Windows-based desktop app and a web app. What I need to know is how exactly CNG's KDF uses (hashes in my case) the secret agreement value. I'm using the SHA-256 algorithm as KDF and trying to hash X and Y of the secret agreement but result doesn't match to the one CNG computes. Any ideas?
Thank you.
","I cannot vouch for what Microsoft found fit to implement, but there is a standard on ECDH called X9.63. In that standard, ECDH works like this:

You run the DH thing, yielding the common curve point (X, Y) (that's the point you got from the peer, multiplied by your secret DH value).
You convert X (and only X; Y is discarded) into a sequence of bytes which we will call Z. Conversion is unsigned big-endian, and uses the field size: if X lives in field Fq, then the conversion yields exactly ceil(ceil(log q)/8). E.g. if you use the NIST P-521 curve, you work modulo a prime q which is such that 2520 < q < 2521, so ceil(log q) = 521 and the resulting byte sequence consists in exactly 66 bytes, whatever the value X. With the most commonly used elliptic curve (known as ""P-256""), that's 32 bytes.
To derive Z into a key, with a hash function H which has an output length of n bytes (e.g. n = 32 with SHA-256), you compute the potentially infinite string H1||H2||H3||... where ""||"" denotes concatenation, and Hi = H(Z||i) where ""i"" is represented as four bytes, using big-endian convention. In plain words, you hash Z along with a 32-bit counter, and do so again and again until you have enough bytes for your intended key length.

","1035","<windows><elliptic-curve><diffie-hellman><cng>","2","1","1","2019-08-19 10:32:44","7953736","0","1","608639","","2019-08-19 10:32:44","2011-10-31 02:32:03",""
"45350075","Access to the private key of CNG certificate from .NET 4.6 - GetCngPrivateKey not found","I need access to the private key of CNG certificate from .NET 4.6.
In the docs I found extension method GetCngPrivateKey but this method is not available for me in Visual Studio 2015.
Maybe this method was removed from last release of .NET framework.
Any advice what is correct way now for access to the private key of CNG certificate now.
","GetCngPrivateKey was part of the 4.6 preview, but was removed for 4.6 release.  It was replaced with GetRSAPrivateKey (and GetECDsaPrivateKey (4.6.1) and GetDSAPrivateKey (4.6.2)).
The Get[Algorithm]{Public|Private}Key methods will return CNG usually (on Windows) and CAPI (CryptoServiceProvider) when they need to.  On non-Windows systems (for .NET Core) they use whatever the appropriate backing type is for the system.
The new methods also have the advantage that you almost never need to cast the return type. On 4.6 the RSA base class was enhanced so that all RSA operations could be done without casting. On 4.6.1 ECDSA was enhanced, and on 4.6 DSA was enhanced. The only reason to cast is for interop (like trying to get the name of the persisted key).
","1035","<certificate><private-key><.net-4.6><cng>","2","2","1","2017-07-29 18:00:11","","0","","","","","2017-07-27 11:55:07",""
"17188725","How to create a self-signed Certificate using CLR Security to use with EnvelopedCms?","I am trying to create a self-signed Certificate using the CLR-Security library Security.Cryptography.dll (their homepage: http://clrsecurity.codeplex.com)
I am able to create the certificate and even to Encrypt with it,
but Decrypt fails with the following error ""Invalid provider type specified.""
Here is the certificate creation code:
public static bool generateCertificate(string distinguishedName)
{
        // Generate Key
        CngKeyCreationParameters keyParams = new CngKeyCreationParameters();
        keyParams.KeyCreationOptions = CngKeyCreationOptions.MachineKey | CngKeyCreationOptions.OverwriteExistingKey;
        keyParams.KeyUsage = CngKeyUsages.AllUsages; //CngKeyUsages.Decryption | CngKeyUsages.Signing;
        keyParams.Provider = CngProvider.MicrosoftSoftwareKeyStorageProvider;
        keyParams.ExportPolicy = CngExportPolicies.AllowExport;
        CngKey newKey = CngKey.Create(CngAlgorithm2.Rsa, Guid.NewGuid().ToString(), keyParams);

        // Init certificate
        X509CertificateCreationParameters certParams = new X509CertificateCreationParameters(new X500DistinguishedName(distinguishedName));
        certParams.SignatureAlgorithm = X509CertificateSignatureAlgorithm.RsaSha1;
        certParams.StartTime = DateTime.Now;
        certParams.EndTime = DateTime.Now.AddYears(10);

        // Create cert
        X509Certificate2 newCert = newKey.CreateSelfSignedCertificate(certParams);

        // Save to store
        X509Store lmStore = new X509Store(StoreName.My, StoreLocation.LocalMachine);
        lmStore.Open(OpenFlags.ReadWrite);
        lmStore.Add(newCert);
        lmStore.Close();

        return true;
}

Here is the Encrypt method:
public static byte[] encryptStringPKCS7(string toEncrypt, List<byte[]> recipients)
    {
        // get bytes from encrypt text
        UnicodeEncoding unicode = new UnicodeEncoding();
        byte[] msgBytes = unicode.GetBytes(toEncrypt);

        // Create the certificate collection of the intended recipients
        X509Certificate2Collection recipientsCollection = new X509Certificate2Collection();
        foreach (byte[] currCertificate in recipients)
        {
            recipientsCollection.Add(new X509Certificate2(currCertificate));
        }

        //  Place message in a ContentInfo object.
        ContentInfo contentInfo = new ContentInfo(msgBytes);
        EnvelopedCms envelopedCms = new EnvelopedCms(contentInfo);

        //  Formulate a CmsRecipientCollection object that
        //  represents information about the set of recipients 
        //  to encrypt the message for.
        CmsRecipientCollection cmsRecipients = new CmsRecipientCollection(SubjectIdentifierType.IssuerAndSerialNumber, recipientsCollection);

        //  Encrypt the message for the collection of recipients.
        envelopedCms.Encrypt(cmsRecipients);            
        return envelopedCms.Encode();
    }

Here is the Decrypt method:
public static string decryptStringPKCS7(byte[] toDecrypt)
    {
        // Place message in a ContentInfo object.
        // This is required to build an EnvelopedCms object.
        EnvelopedCms envelopedCms = new EnvelopedCms();            

        // Decrypt the message
        envelopedCms.Decode(toDecrypt);
        envelopedCms.Decrypt();
        byte[] msgDecrypted = envelopedCms.ContentInfo.Content;

        // Decode
        string msgClearText = Encoding.Unicode.GetString(msgDecrypted);
        return msgClearText;
    }

When I use exactly the same code with a certificate I created with makecert.exe - it works well.
The makecert command line I use is: makecert.exe -sr LocalMachine -ss My -n CN=[SomeDN] -sk [SomeRandomGUID] -sky exchange
Do I need to specify some extra parameters in the creation of the CngKey or the Certificate?
Or maybe pass in some extra info during Encrypt?
Thanks in advance for any help!
","","1025","<certificate><encryption><self-signed><cng>","1","","0","2013-06-19 10:18:12","","2","","","","","2013-06-19 10:18:12",""
"41824260","Create X.509 certificate in .NET with CNG (private key in HSM)","We have a self-signed CA certificate with private key stored in a HSM solution.  We need to create a short-lived X.509 certificate signed by the CA certificate through .NET code. The short-lived X.509 certificate will be used for client certificate authentication against a REST-based service over TLS/HTTPS. 
The HSM solution is using Key Storage Provider (KSP) integration with Microsoft Certificate Store, so the Crypto Next Generation (CNG) libraries must be used to get the private key. 
Through X509CertificateExtensions.GetCngPrivateKey() we're able to get access 
a CngKey object that represents the private key. 
However, we're not able to use the CngKey together with BouncyCastle 
AsymmetricCipherKeyPair issuerKeyPair=null;
if (issuerCertificate.HasCngKey())
{
   var cngPrivateKey = issuerCertificate.GetCngPrivateKey();
   var rsa = new RSACng(cngPrivateKey);

   issuerKeyPair = DotNetUtilities.GetRsaKeyPair(privateKey);
}

Fails with the following exception thrown
System.Security.Cryptography.CryptographicException: Invalid type specified.

   at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)
   at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)
   at System.Security.Cryptography.RSACng.ExportParameters(Boolean includePrivateParameters)

Edit: Think the reason this fails, is that DotNetUtilities.GetRsaKeyPair tries to Export the private key through rsa.ExportParameters(true). This is not allowed by the HSM and it throws an exception. Seems like a need a different way to reference the private key
Edit #2: Raised feature request to Bouncy Castle and there is a response on how this could be implemented as part of the framework.
","","993","<.net><bouncycastle><x509><hsm><cng>","1","","0","2017-03-01 09:05:02","","7","","250787","","2017-03-01 09:05:02","2017-01-24 09:16:44",""
"43011261","AES-CBC encrypted output in CNG is not matching with online tools","I am new to CNG. I am playing with the basic program from msdn site. 
I have modified the input plain string and testing the output using other websites that provides the aes cbc encrypted output.
Unfortunately only first half matches and the next half is not matching.
It would be great if someone can point me where the mistake lies,
original code from msdn is here.
Here is the output generated from my code (below). Please note that there is no difference in my code apart from modifying the input plain string.

Here is the output from the online website (http://aes.online-domain-tools.com/ and anothersite)

The first half ends at ""B0 C4 29 18"".. after that the 2nd half doesn't match.
Here is the code snippet
#include <windows.h>
#include <stdio.h>
#include <bcrypt.h>

#pragma comment(lib, ""bcrypt.lib"")

#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL         ((NTSTATUS)0xC0000001L)
#endif // !STATUS_UNSUCCESSFUL

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

void
print_inhex(char *buf, int len) {
    for (int i = 0; i < len; i++)
        printf("" %02x"", buf[i]);
    printf(""\n"");
}

const BYTE rgbPlaintext[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

static const BYTE rgbIV[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

static const BYTE rgbAES128Key[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};


void
CNG_aes_cbc()
{

    BCRYPT_ALG_HANDLE       hAesAlg = NULL;
    BCRYPT_KEY_HANDLE       hKey = NULL;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    DWORD                   cbCipherText = 0,
        cbPlainText = 0,
        cbData = 0,
        cbKeyObject = 0,
        cbBlockLen = 0,
        cbBlob = 0;
    PBYTE                   pbCipherText = NULL,
        pbPlainText = NULL,
        pbKeyObject = NULL,
        pbIV = NULL,
        pbBlob = NULL;

    // Open an algorithm handle.
    if (!NT_SUCCESS(status = BCryptOpenAlgorithmProvider(&hAesAlg, BCRYPT_AES_ALGORITHM, NULL, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptOpenAlgorithmProvider\n"", status);
        goto Cleanup;
    }

    // Calculate the size of the buffer to hold the KeyObject.
    if (!NT_SUCCESS(status = BCryptGetProperty(hAesAlg, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbData, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptGetProperty\n"", status);
        goto Cleanup;
    }

    // Allocate the key object on the heap.
    pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
    if (NULL == pbKeyObject) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    // Calculate the block length for the IV.
    if (!NT_SUCCESS(status = BCryptGetProperty(hAesAlg, BCRYPT_BLOCK_LENGTH, (PBYTE)&cbBlockLen, sizeof(DWORD), &cbData, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptGetProperty\n"", status);
        goto Cleanup;
    }

    // Determine whether the cbBlockLen is not longer than the IV length.
    if (cbBlockLen > sizeof(rgbIV)) {
        wprintf(L""**** block length is longer than the provided IV length\n"");
        goto Cleanup;
    }

    // Allocate a buffer for the IV. The buffer is consumed during the 
    // encrypt/decrypt process.
    pbIV = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbBlockLen);
    if (NULL == pbIV) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    memcpy(pbIV, rgbIV, cbBlockLen);

    if (!NT_SUCCESS(status = BCryptSetProperty(hAesAlg, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptSetProperty\n"", status);
        goto Cleanup;
    }

    // Generate the key from supplied input key bytes.
    if (!NT_SUCCESS(status = BCryptGenerateSymmetricKey(hAesAlg, &hKey, pbKeyObject, cbKeyObject, (PBYTE)rgbAES128Key, sizeof(rgbAES128Key), 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptGenerateSymmetricKey\n"", status);
        goto Cleanup;
    }


    // Save another copy of the key for later.
    if (!NT_SUCCESS(status = BCryptExportKey(hKey, NULL, BCRYPT_KEY_DATA_BLOB, NULL, 0, &cbBlob, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptExportKey\n"", status);
        goto Cleanup;
    }


    // Allocate the buffer to hold the BLOB.
    PUCHAR pbBlob_1 = (PUCHAR)malloc(sizeof(PUCHAR) * cbBlob);
    //pbBlob = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbBlob);
    if (NULL == pbBlob_1) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    if (!NT_SUCCESS(status = BCryptExportKey(hKey, NULL, BCRYPT_KEY_DATA_BLOB, pbBlob_1, cbBlob, &cbBlob, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptExportKey\n"", status);
        goto Cleanup;
    }

    PUCHAR blob = pbBlob_1 + sizeof(BCRYPT_KEY_DATA_BLOB_HEADER);
    int len = cbBlob - sizeof(BCRYPT_KEY_DATA_BLOB_HEADER);
    printf(""key:"");
    print_inhex(blob, len);

    cbPlainText = sizeof(rgbPlaintext);
    pbPlainText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbPlainText);
    if (NULL == pbPlainText) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    /*memcpy(pbPlainText, rgbPlaintext, sizeof(rgbPlaintext));*/
    char *test_msg = ""This is my test msg"";
    cbPlainText = strlen(test_msg) + 1;
    memcpy(pbPlainText, test_msg, cbPlainText);

    printf(""plain text:"");
    print_inhex(test_msg, strlen(test_msg));

    // Get the output buffer size.
    if (!NT_SUCCESS(status = BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, cbBlockLen, NULL, 0, &cbCipherText, BCRYPT_BLOCK_PADDING)))  {
        wprintf(L""**** Error 0x%x returned by BCryptEncrypt\n"", status);
        goto Cleanup;
    }

    pbCipherText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbCipherText);
    if (NULL == pbCipherText) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    // Use the key to encrypt the plaintext buffer.
    // For block sized messages, block padding will add an extra block.
    if (!NT_SUCCESS(status = BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, 
                         cbBlockLen, pbCipherText, cbCipherText, &cbData, BCRYPT_BLOCK_PADDING))){
        wprintf(L""**** Error 0x%x returned by BCryptEncrypt\n"", status);
        goto Cleanup;
    }

    printf(""cipher text:"");
    for (int i = 0; i < cbCipherText; i++)
        printf("" %02x"", pbCipherText[i]);

    wprintf(L""\nSuccess!\n"");

Cleanup:  
    if (hAesAlg)
        BCryptCloseAlgorithmProvider(hAesAlg, 0);

    if (hKey)
        BCryptDestroyKey(hKey);

    if (pbCipherText)
        HeapFree(GetProcessHeap(), 0, pbCipherText);

    if (pbKeyObject)
        HeapFree(GetProcessHeap(), 0, pbKeyObject);

    if (pbIV)
        HeapFree(GetProcessHeap(), 0, pbIV);
}

","The length of the data is not an exact multiple of the block size (16-bytes for AES) so padding is added but. That is where the implementation either rejects the data, pads with a default method such as 0x00 (cryptomathic), PKCS#7 (the generally used padding) or whatever junk follews the provided data in memory.
Don't use BCryptEncrypt, use AES Class
SymmetricAlgorithm.Padding Property Note: The default is PaddingMode.PKCS7.
It is best to specify the padding on instantiation of AES.
See PaddingMode Enumeration: PKCS7
The PKCS #7 padding string consists of a sequence of bytes, each of which is equal to the total number of padding bytes added.
Manually adding PKCS#7 padding to:
cryptommathic AES:
produces: 46CC2228E81B2A05E8E8EBF2B0C42918EC496128D7C45BD0B19BB2D6452A3936 
","976","<c++><encryption><aes><padding><cng>","0","0","2","2017-03-27 16:15:31","","4","","1816580","","2017-03-25 08:45:13","2017-03-25 00:45:23",""
"43011261","AES-CBC encrypted output in CNG is not matching with online tools","I am new to CNG. I am playing with the basic program from msdn site. 
I have modified the input plain string and testing the output using other websites that provides the aes cbc encrypted output.
Unfortunately only first half matches and the next half is not matching.
It would be great if someone can point me where the mistake lies,
original code from msdn is here.
Here is the output generated from my code (below). Please note that there is no difference in my code apart from modifying the input plain string.

Here is the output from the online website (http://aes.online-domain-tools.com/ and anothersite)

The first half ends at ""B0 C4 29 18"".. after that the 2nd half doesn't match.
Here is the code snippet
#include <windows.h>
#include <stdio.h>
#include <bcrypt.h>

#pragma comment(lib, ""bcrypt.lib"")

#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL         ((NTSTATUS)0xC0000001L)
#endif // !STATUS_UNSUCCESSFUL

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

void
print_inhex(char *buf, int len) {
    for (int i = 0; i < len; i++)
        printf("" %02x"", buf[i]);
    printf(""\n"");
}

const BYTE rgbPlaintext[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

static const BYTE rgbIV[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

static const BYTE rgbAES128Key[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};


void
CNG_aes_cbc()
{

    BCRYPT_ALG_HANDLE       hAesAlg = NULL;
    BCRYPT_KEY_HANDLE       hKey = NULL;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    DWORD                   cbCipherText = 0,
        cbPlainText = 0,
        cbData = 0,
        cbKeyObject = 0,
        cbBlockLen = 0,
        cbBlob = 0;
    PBYTE                   pbCipherText = NULL,
        pbPlainText = NULL,
        pbKeyObject = NULL,
        pbIV = NULL,
        pbBlob = NULL;

    // Open an algorithm handle.
    if (!NT_SUCCESS(status = BCryptOpenAlgorithmProvider(&hAesAlg, BCRYPT_AES_ALGORITHM, NULL, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptOpenAlgorithmProvider\n"", status);
        goto Cleanup;
    }

    // Calculate the size of the buffer to hold the KeyObject.
    if (!NT_SUCCESS(status = BCryptGetProperty(hAesAlg, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbData, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptGetProperty\n"", status);
        goto Cleanup;
    }

    // Allocate the key object on the heap.
    pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
    if (NULL == pbKeyObject) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    // Calculate the block length for the IV.
    if (!NT_SUCCESS(status = BCryptGetProperty(hAesAlg, BCRYPT_BLOCK_LENGTH, (PBYTE)&cbBlockLen, sizeof(DWORD), &cbData, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptGetProperty\n"", status);
        goto Cleanup;
    }

    // Determine whether the cbBlockLen is not longer than the IV length.
    if (cbBlockLen > sizeof(rgbIV)) {
        wprintf(L""**** block length is longer than the provided IV length\n"");
        goto Cleanup;
    }

    // Allocate a buffer for the IV. The buffer is consumed during the 
    // encrypt/decrypt process.
    pbIV = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbBlockLen);
    if (NULL == pbIV) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    memcpy(pbIV, rgbIV, cbBlockLen);

    if (!NT_SUCCESS(status = BCryptSetProperty(hAesAlg, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptSetProperty\n"", status);
        goto Cleanup;
    }

    // Generate the key from supplied input key bytes.
    if (!NT_SUCCESS(status = BCryptGenerateSymmetricKey(hAesAlg, &hKey, pbKeyObject, cbKeyObject, (PBYTE)rgbAES128Key, sizeof(rgbAES128Key), 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptGenerateSymmetricKey\n"", status);
        goto Cleanup;
    }


    // Save another copy of the key for later.
    if (!NT_SUCCESS(status = BCryptExportKey(hKey, NULL, BCRYPT_KEY_DATA_BLOB, NULL, 0, &cbBlob, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptExportKey\n"", status);
        goto Cleanup;
    }


    // Allocate the buffer to hold the BLOB.
    PUCHAR pbBlob_1 = (PUCHAR)malloc(sizeof(PUCHAR) * cbBlob);
    //pbBlob = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbBlob);
    if (NULL == pbBlob_1) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    if (!NT_SUCCESS(status = BCryptExportKey(hKey, NULL, BCRYPT_KEY_DATA_BLOB, pbBlob_1, cbBlob, &cbBlob, 0))) {
        wprintf(L""**** Error 0x%x returned by BCryptExportKey\n"", status);
        goto Cleanup;
    }

    PUCHAR blob = pbBlob_1 + sizeof(BCRYPT_KEY_DATA_BLOB_HEADER);
    int len = cbBlob - sizeof(BCRYPT_KEY_DATA_BLOB_HEADER);
    printf(""key:"");
    print_inhex(blob, len);

    cbPlainText = sizeof(rgbPlaintext);
    pbPlainText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbPlainText);
    if (NULL == pbPlainText) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    /*memcpy(pbPlainText, rgbPlaintext, sizeof(rgbPlaintext));*/
    char *test_msg = ""This is my test msg"";
    cbPlainText = strlen(test_msg) + 1;
    memcpy(pbPlainText, test_msg, cbPlainText);

    printf(""plain text:"");
    print_inhex(test_msg, strlen(test_msg));

    // Get the output buffer size.
    if (!NT_SUCCESS(status = BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, cbBlockLen, NULL, 0, &cbCipherText, BCRYPT_BLOCK_PADDING)))  {
        wprintf(L""**** Error 0x%x returned by BCryptEncrypt\n"", status);
        goto Cleanup;
    }

    pbCipherText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbCipherText);
    if (NULL == pbCipherText) {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    // Use the key to encrypt the plaintext buffer.
    // For block sized messages, block padding will add an extra block.
    if (!NT_SUCCESS(status = BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, 
                         cbBlockLen, pbCipherText, cbCipherText, &cbData, BCRYPT_BLOCK_PADDING))){
        wprintf(L""**** Error 0x%x returned by BCryptEncrypt\n"", status);
        goto Cleanup;
    }

    printf(""cipher text:"");
    for (int i = 0; i < cbCipherText; i++)
        printf("" %02x"", pbCipherText[i]);

    wprintf(L""\nSuccess!\n"");

Cleanup:  
    if (hAesAlg)
        BCryptCloseAlgorithmProvider(hAesAlg, 0);

    if (hKey)
        BCryptDestroyKey(hKey);

    if (pbCipherText)
        HeapFree(GetProcessHeap(), 0, pbCipherText);

    if (pbKeyObject)
        HeapFree(GetProcessHeap(), 0, pbKeyObject);

    if (pbIV)
        HeapFree(GetProcessHeap(), 0, pbIV);
}

","You aren't consistent with your value for cbPlainText.
Asides:

You also have some very scary copy/realloc code where you write a string over a buffer not guaranteed as big as the string).
You also defined NT_SUCCESS in such a way that it returns whether or not something failed.  0 is success, !0 is failure.

You hex-printed up to strlen of tst_msg.  But you set cbPlainText = strlen(tst_msg) + 1.  If you set it to strlen(tst_msg) then you get @zaph's answer (46CC2228E81B2A05E8E8EBF2B0C42918EC496128D7C45BD0B19BB2D6452A3936).
You don't match the website because you used CNG with PKCS#7 padding, and the website uses zero-padding.  You could identify the padding used in the website by taking your output ciphertext and putting it as the plaintext, then hitting decrypt.  It then says your input was 54686973206973206d792074657374206d736700000000000000000000000000.  Or, if you add 00 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C on your input to the website you'll get your original answer.  Or add 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D and you'll get @zaph's answer.
So, things to do:

Don't re-evaluate the length of things to print, make one variable (cbPlainText) and stick with it.
AES is a block cipher algorithm.  All block ciphers require complete blocks, a deficient last block must be padded (and under removable padding schemes a complete final block requires yet another block). Learn what this means before continuing. https://en.wikipedia.org/wiki/Padding_(cryptography)#Symmetric_cryptography
When something seems wrong with encryption, look at the decrypted output.


Very often the decrypted output with ""no padding"" is revealing.

Learn C, and how memory works.  Or switch to C# and have a less steep learning curve.

","976","<c++><encryption><aes><padding><cng>","0","3","2","2017-03-27 16:15:31","","4","","1816580","","2017-03-25 08:45:13","2017-03-25 00:45:23",""
"18143632","Make CNG crypto API work on Windows XP?","Is there a way to get the Microsoft Cryptography API: Next Generation to work on Windows XP?
","As you certainly already know, CNG rely on a windows vista/seven/8 CNG keyisolation service (keyiso) it's provided by the operating system and not available in XP. You can rely on cryptoAPI which is availaible in XP. It will certainly be cheaper to provide win 7/8 licence than to try to redevelop the service and to port the SDK for XP which was a nice OS but not the future.
","928","<c++><winapi><dll><windows-xp><cng>","1","0","2","2014-01-15 21:09:53","21148263","2","","","","","2013-08-09 09:33:31",""
"18143632","Make CNG crypto API work on Windows XP?","Is there a way to get the Microsoft Cryptography API: Next Generation to work on Windows XP?
","I'm afraid not. CNG is available on Windows Vista+ only. KSP is not the only dependency that CNG has. There are several other functionalities for which it requires the underlying OS to be Vista+.
","928","<c++><winapi><dll><windows-xp><cng>","1","2","2","2014-01-15 21:09:53","21148263","2","","","","","2013-08-09 09:33:31",""
"54483371","Cannot export RSA private key parameters, the requested operation is not supported","I have a certificate file provided by another party which I'm loading in my application and cannot export its private key parameters. It looks like the certificate is using CNG rather than CryptoAPI, so I can't access the private key directly, only with GetRSAPrivateKey() method. The method returns RSACngKey rather than RSACryptoServiceProvider which is a different implementation of RSA. The problem is that the returned key seems to be missing CngExportPolicies.AllowPlaintextExport in its export policies, and so I can't export RSA parameters from this certificate. I can reproduce the problem by generating a new certificate that misses necessary export policies:
using System;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

namespace TestRsaCngConsole
{
    class Program
    {
        static void Main(string[] args)
        {
            var oldCertificate = CreateCertificate();
            var oldCertificateBytes = oldCertificate.Export(X509ContentType.Pfx, """");
            var newCertificate = new X509Certificate2(oldCertificateBytes, """",
                X509KeyStorageFlags.Exportable | 
                X509KeyStorageFlags.MachineKeySet | 
                X509KeyStorageFlags.PersistKeySet);

            LogCertificate(oldCertificate, ""old certificate""); // this fails
            LogCertificate(newCertificate, ""new certificate""); // works only on Win10
            Console.ReadKey();
        }

        private static X509Certificate2 CreateCertificate()
        {
            var keyParams = new CngKeyCreationParameters();
            keyParams.KeyUsage = CngKeyUsages.Signing;
            keyParams.Provider = CngProvider.MicrosoftSoftwareKeyStorageProvider;
            keyParams.ExportPolicy = CngExportPolicies.AllowExport; // here I don't have AllowPlaintextExport
            keyParams.Parameters.Add(new CngProperty(""Length"", BitConverter.GetBytes(2048), CngPropertyOptions.None));
            var cngKey = CngKey.Create(CngAlgorithm.Rsa, Guid.NewGuid().ToString(), keyParams);
            var rsaKey = new RSACng(cngKey);
            var req = new CertificateRequest(""cn=mah_cert"", rsaKey, HashAlgorithmName.SHA256, RSASignaturePadding.Pss); // requires .net 4.7.2
            var cert = req.CreateSelfSigned(DateTimeOffset.Now, DateTimeOffset.Now.AddYears(5));
            return cert;
        }

        private static void LogCertificate(X509Certificate2 certificate, string name)
        {
            Console.WriteLine(""----- Testing "" + name + "" ------"");

            try
            {
                var rsaPrivateKey = certificate.GetRSAPrivateKey();
                var parameters = rsaPrivateKey.ExportParameters(true);
                Console.WriteLine(""Certificate private key RSA parameters were successfully exported."");

                var privateKey = certificate.PrivateKey;
                Console.WriteLine(""Certificate private key is accessible."");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
    }
}

The program shows the following output when running on Windows 10:
----- Testing old certificate ------
System.Security.Cryptography.CryptographicException: The requested operation is not supported.

   at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)
   at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)
   at System.Security.Cryptography.RSACng.ExportParameters(Boolean includePrivateParameters)
   at TestRsaCngConsole.Program.LogCertificate(X509Certificate2 certificate, String name) in D:\Projects\TestRsaCngConsole\TestRsaCngConsole\Program.cs:line 44
----- Testing new certificate ------
Certificate private key RSA parameters were successfully exported.
Certificate private key is accessible.

So the first certificate fails to export the private key, because it is missing AllowPlaintextExport flag in its export policies. But after re-loading the old certificate with exportable flags I can export the new certificate parameters just fine. However it doesn't work on Windows Server 2012 or Windows Server 2016 and throws exceptions for both certificates:
----- Testing old certificate ------
System.Security.Cryptography.CryptographicException: The requested operation is not supported.

   at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)
   at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)
   at System.Security.Cryptography.RSACng.ExportParameters(Boolean includePrivateParameters)
   at TestRsaCngConsole.Program.LogCertificate(X509Certificate2 certificate, String name) in D:\Projects\TestRsaCngConsole\TestRsaCngConsole\Program.cs:line 44
----- Testing new certificate ------
System.Security.Cryptography.CryptographicException: The requested operation is not supported.

   at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)
   at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)
   at System.Security.Cryptography.RSACng.ExportParameters(Boolean includePrivateParameters)
   at TestRsaCngConsole.Program.LogCertificate(X509Certificate2 certificate, String name) in D:\Projects\TestRsaCngConsole\TestRsaCngConsole\Program.cs:line 44

I need to be able to fix the certificate and make it possible to export the RSA parameters, even if the cert was originally missing AllowPlaintextExport. What is so different on Windows Server and is there a way to fix the certificate?
","Unfortunately, the only way to export the key in that state is to P/Invoke into NCryptExportKey to set up an encrypted export; then import that into a new key via NCryptImportKey, and then set the export policy to AllowPlaintextExport.
Starting in .NET Core 3.0 this will be easier:
using (RSA exportRewriter = RSA.Create())
{
    // Only one KDF iteration is being used here since it's immediately being
    // imported again.  Use more if you're actually exporting encrypted keys.
    exportRewriter.ImportEncryptedPkcs8(
        ""password"",
        rsa.ExportEncryptedPkcs8(
            ""password"",
            new PbeParameters(
                PbeEncryptionAlgorithm.Aes128Cbc,
                HashAlgorithmName.SHA256,
                1)),
        out _);

    return exportRewriter.ExportParameters(true);
}

The .NET Core code for exporting encrypted is at https://github.com/dotnet/corefx/blob/64477348da1ff57a43deb65a4b12d32986ed00bd/src/System.Security.Cryptography.Cng/src/System/Security/Cryptography/CngKey.Export.cs#L126-L237, it's not a very nice API to have to call from C#.
","899","<c#><certificate><rsa><cng>","0","1","1","2019-02-04 23:00:31","54525572","0","","","","","2019-02-01 16:23:14",""
"39916578","Import an ECDSA public key from CngKey to BouncyCastle","I am trying to generate an x509 certificate from a pair of keys generated with CngKey. 
I create the keys with: 
        var parameters = new CngKeyCreationParameters 
        { 
            Provider = CngProvider.MicrosoftSoftwareKeyStorageProvider, 
            ExportPolicy = CngExportPolicies.AllowPlaintextExport, 
            KeyCreationOptions = CngKeyCreationOptions.OverwriteExistingKey, 
            KeyUsage = CngKeyUsages.AllUsages, 
            UIPolicy = new CngUIPolicy(CngUIProtectionLevels.None) 
        }; 
        var key = CngKey.Create(CngAlgorithm.ECDsaP384, container, parameters); 
        byte[] ecPriKey = key.Export(CngKeyBlobFormat.Pkcs8PrivateBlob); 
        byte[] ecPubKey = key.Export(CngKeyBlobFormat.EccPublicBlob); 

I get a BouncyCastle private key with: 
        AsymmetricKeyParameter akPrivate = PrivateKeyFactory.CreateKey(ecPriKey); 

And I have no trouble in it, so that I can see the proper curve's parameters from the key. 
However, when I try to get the public key with: 
          string publicKeyBase64 = Convert.ToBase64String(ecPubKey); 
          byte[] ecPubKey2 = Base64.Decode(publicKeyBase64); 
          byte[] ecPublicKey = new byte[ecPubKey.Length -7]; 
          ecPublicKey[0] = 0x04; 
          Array.Copy(ecPubKey, 8, ecPublicKey, 7, ecPublicKey.Length); 
          AsymmetricKeyParameter akPublic = PublicKeyFactory.CreateKey(ecPublicKey - 1); 

I read I have to erase the 8 first digits from CngKey and add the uncompressed const value 0x04. 
When I execute ""PublicKeyFactory.CreateKey(ecPublicKey)"" I get the exception: 
ex  {""extra data found after object""}   System.Exception {System.IO.IOException} 
Data    {System.Collections.ListDictionaryInternal} System.Collections.IDictionary {System.Collections.ListDictionaryInternal} 
            HResult 0x80131620  int 
            HelpLink    null    string 
InnerException  null    System.Exception 
            Message ""extra data found after object"" string 
            Source  ""BouncyCastle.Crypto""   string 
            StackTrace  ""   at Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(Byte[] data)\r\n   at Org.BouncyCastle.Security.PublicKeyFactory.CreateKey(Byte[] keyInfoData)\r\n   at Plpm.Csp.Security.KeyTool.SecurityKeyTool.OpGenEc(String[] args) in ...""  string 
TargetSite  {Org.BouncyCastle.Asn1.Asn1Object FromByteArray(Byte[])}    System.Reflection.MethodBase {System.Reflection.RuntimeMethodInfo} 
Static members  
Non-Public members  

Anyway, I get the same exception if I do this directly with the key as:
        AsymmetricKeyParameter akPublic = PublicKeyFactory.CreateKey(ecPubKey); 

Can someone, please, give me some ideas about why is this error with public key? 
Thank you so much.
","","864","<c#><bouncycastle><ecdsa><cng>","3","","0","2016-10-07 11:51:22","","0","","","","","2016-10-07 11:51:22",""
"9460934","Microsoft CNG BCryptEncrypt returning ciphertext == plaintext","I am trying to implement an AES-OFB wrapper around CNG's AES for symmetric encryption.  
I have run into an issue that I cannot understand... I have created an AES algorithm handle (BCRYPT_AES_ALGORITHM) and imported an AES key. I then attempt to generate a 16 byte keystream  for use with XORing my plaintext/ciphertext. The first time I run through this mechanism, the keyStreamPtr changes from some random byte stream to another, however, the 3rd time I do this (the 3rd set of 16 bytes of keystream), I start getting the same output and it happens forever.
            status = BCryptEncrypt((BCRYPT_KEY_HANDLE)keyHandle, 
                                   keyStreamPtr,   
                                   keyStreamLength,
                                   NULL, //no padding
                                   NULL, // no IV
                                   0,  // no IV
                                   keyStreamPtr,   
                                   keyStreamLength,
                                   &Length, 
                                   0); // no option flags

Has anybody ever seen anything like this?  why would AES ever return ciphertext totally identical to the plaintext that was the input?  Again this is for an AES-OFB implementation... Perhaps I am doing something wrong?  
","The only thing I can think of is that you encrypt the key stream again. If you do this you effectively perform encrypt/decrypt: P XOR C XOR C = P where C is the key stream and P is the plain text. You might want to look at the buffer/stream handling within your code.
","834","<encryption><aes><encryption-symmetric><cng>","2","0","1","2015-11-03 05:01:30","","0","","1505120","","2015-11-03 05:01:30","2012-02-27 06:32:12",""
"45111422","EC private key to CngKey in C#","I need to convert a EC private key generated by BouncyCastle to a CngKey in C#.  Ultimately, I'm trying to create a PKCS12 that can be imported into the Windows Key Store and am following the information and code example found here. 
The EC key pair is generated as follows:
    var ecKeyPairGenerator = new ECKeyPairGenerator(""ECDSA"");
    ECKeyGenerationParameters ecKeyGenParams = new ECKeyGenerationParameters(SecObjectIdentifiers.SecP384r1, new SecureRandom());
    AsymmetricCipherKeyPair pair = ecKeyPairGenerator.GenerateKeyPair();

To create a CngKey:
PrivateKeyInfo privKeyInfo = PrivateKeyInfoFactory.CreatePrivateKeyInfo(pair.Private);
CngKey cngPrivKey = CngKey.Import(privKeyStruct.GetDerEncoded(), CngKeyBlobFormat.Pkcs8PrivateBlob);

Searching on the web, the above should work, e.g., see here. Instead, I'm getting an Unknown error exception 

(CryptographicException) at
  System.Security.Cryptography.NCryptNative.ImportKey(). If I pass
  CngKeyBlobFormat.EccPrivateBlob to CngKey.Import(), I get an
  invalid data exception.

As a new newbie to both .NET, CNG, and Cryto, I feel I'm overlooking something.  Any ideas would be appreciated.
Thanks!
","It turns out that the pkcs8 content of the private key passed in to the CngKey.Import() method should encode both private and public keys for the method to succeed.  And this is consistent with the remarks for the CngKeyBlobFormat.Pkcs8PrivateBlob property found here
So the new question is how to generate in BouncyCastle a pkcs8 byte array encoding of the private key that includes both keys.  Pkcs8Generator doesn't do this as the AsymmetricKeyParameter does not have the public key.  Any help would be greatly appreciated.
Thanks!
","830","<c#><.net><bouncycastle><cng>","1","1","1","2017-07-17 17:43:21","","0","","4972721","","2017-07-14 22:15:24","2017-07-14 20:52:06",""
"26739583","How to deal with plaintext keys using CNG?","I have a set of predefined plaintext keys that I use for symmetric encryption/decryption. These keys are used for encrypted communication with hardware devices connected to a PC.
I would like to use a CNG key storage provider to securely store these keys. Encryption and decryption must be done outside of CNG. I only need a secure place where to store and from where to retrieve my predefined plaintext keys. 
The last days I studied the CNG functions reference but couldn't find any way to import/export a plaintext symmetric key identified by name into a CNG key container.
I know that CryptoAPI provides functions to import/export session keys. But this old API doesn't provide persistent (session) keys and no way to select/identify keys by name within a key container.
Any help is heavily appreciated. Thanks in advance.
","I'm afraid you're out of luck for getting a direct solution, as the CNG key storage providers currently support asymmetric keys but not symmetric keys. Only primitive providers support symmetric keys.
This model is geared towards asymmetric keys being the ones that have to be protected in the long term, with symmetric keys being used only for one session and then thrown away. Those symmetric keys might be derived from an asymmetric key such as Diffie-Hellman or ECDH.
You say that you want the keys stored securely, but that the encryption/decryption is done outside CNG. Depending on what threats you are trying to defend against, this may not be the right approach. Normally if you are storing keys in a key storage provider, you want the crypto operations done inside the key storage provider, and don't want the keys ever to leave it (except encrypted by another key), as that exposes the key material to an attacker.
However, if you're sure this is what you want, one option would be to generate an RSA key in your key storage provider, and use it to encrypt and decrypt the symmetric keys. You would store the encrypted symmetric key blobs elsewhere, e.g. in the filesystem.
","811","<windows><encryption><key><plaintext><cng>","3","3","1","2015-03-10 12:03:47","","0","1","","","","2014-11-04 16:01:28",""
"20992760","Understanding BCryptSignHash output signature","I have signed a hash value in windows using BCryptSignHash with ECDSA algorithm. The output signature buffer is of length 64 bytes. I also generated the public and private key blobs using BCryptGenerateKeyPair function (BCRYPT_ECDSA_P256_ALGORITHM algorithm) with which i signed the hash.
I have to verify this signature with this key pair in linux. I am able to decipher the public-private key pair that got generated, using the link ""http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx"" and able to use the same in linux.
The 64-byte signature generated should ideally be signature pair (r,s) (http://en.wikipedia.org/wiki/Elliptic_Curve_DSA).
Is there a way to understand the 64-bytes signature generated so that i can map the signature blob contents to (r,s) pair in linux and verify it?
Or is there a simpler way to verify the generated signature in linux?
Thanks,
F
","
Is there a way to understand the 64-bytes signature generated so that I can map the signature blob contents to (r,s) pair in linux and verify it?

The r and s are in P1363 format, which is simply a concatenation of r and s in a 2's compliment format. That is, the signature is simply r || s.
You need to know the hash to use this format. For example, SHA1 will create a r of 20 bytes and an s of 20 bytes. If r or s is ""too short"", then it is padded on the left with 0's.
Java and OpenPGP are different than P1363. Java and OpenPGP use an ASN.1 encoding:
SEQUENCE ::= {
  r INTEGER,
  s INTEGER
}

Depending what library you use on Linux, you may have to convert between the formats. Cryptographic Interoperability: Digital Signatures gives examples of signing and verifying using a few different libraries.


Or is there a simpler way to verify the generated signature in linux?

Try Crypto++. I believe Microsoft and Crypto++ uses the same signature format, so you won't need to convert. See Elliptic Curve Digital Signature Algorithm for details.
","803","<linux><cryptoapi><ecdsa><cng>","1","2","1","2014-06-10 12:18:33","21048027","0","","","","","2014-01-08 10:20:42",""
"30721583","Where are the BCrypt NTSTATUS code return values defined?","The Windows CNG Cryptographic Primitive Functions have return values of type NTSTATUS. Several possible (symbolic) return values are mentioned, for example STATUS_AUTH_TAG_MISMATCH for the BCryptDecrypt function.
These symbols are not defined in bcrypt.h, nor in any other header file mentioned in the documentation. I can not use them in my code because they can not be resolved. Where are they located?
","They are defined in:
ntstatus.h

","795","<c><windows><cng>","3","3","1","2015-06-09 02:34:57","30721708","1","","1380680","","2015-06-09 02:34:57","2015-06-09 01:23:18",""
"26398791","Encryption/Decryption using bcrypt library","I am calling the BCryptDecrypt function which is returning an error. I get the error 120 using getlasterror which means this function is not supported in this system (in msdn).
status = BCryptDecrypt( hKey, pbInput, cbInput, NULL, NULL, sizeof(DWORD), NULL, 0, &pcbResult, BCRYPT_BLOCK_PADDING);

pbInput is the pointer to address which contains the data to be decrypted, cbInput is the length of the file  and pcbResult will get the size of the output file (decrypted data). BCryptEncrypt is working fine but BCryptDecryptis not working.
Can anyone please help me out?
few lines of code related to decrypt:
status = BCryptOpenAlgorithmProvider(&hAlgorithm , BCRYPT_AES_ALGORITHM , NULL , 0);
    if (!NT_SUCCESS(status))
    {
        return;
    }
DWORD cbKey = 0;
DWORD cbData =0;

status = BCryptSetProperty(hAlgorithm , BCRYPT_CHAINING_MODE , (PBYTE)BCRYPT_CHAIN_MODE_ECB , sizeof(BCRYPT_CHAIN_MODE_ECB) , 0);
if (!NT_SUCCESS(status))
{
    return;
}

status = BCryptGetProperty(hAlgorithm,
                    BCRYPT_OBJECT_LENGTH,
                    (LPBYTE)&cbData,
                    sizeof(DWORD),
                    &cbKey,
                    0);

LPBYTE pbKey = (BYTE*)HeapAlloc(GetProcessHeap() , 0 , cbData);
LPCSTR szpwd = (LPCSTR)Getpwd();

BCRYPT_KEY_HANDLE hKey = NULL;
status = BCryptGenerateSymmetricKey(hAlgorithm,
                                    &hKey,
                                    pbKey,
                                    cbData,
                                    (PUCHAR)szpwd,
                                    (ULONG)strlen(szpwd),
                                    0);

if (!NT_SUCCESS(status))
{
    if(hAlgorithm)
    {
        BCryptCloseAlgorithmProvider(hAlgorithm,0);
    }
    if(pbKey)
    {
        HeapFree(GetProcessHeap(), 0, pbKey);
    }
    return;
}

DWORD pcbResult = 0;
status = BCryptDecrypt( hKey,
                        pbInput,
                        cbInput,
                        NULL,
                        NULL,
                        sizeof(DWORD),
                        NULL,
                        0,
                        &pcbResult,
                        BCRYPT_BLOCK_PADDING);

DWORD cbError = GetLastError();
if(cbError != 0)
{
LPCSTR messageBuffer = NULL;

size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL, cbError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);

","","779","<c++><encryption><cng>","0","","0","2019-05-25 18:37:53","","5","","12597","","2019-05-25 18:37:53","2014-10-16 07:39:49",""
"41869313","How to write a KSP to hook up into KERB_CERTIFICATE_LOGON","Hi all I've written a custom credentialprovider that works fine when using username/password as credential, the password is transferred via bluetooth.
After all it was not that difficult as the documentation tells you what interfaces to implement.
Now I want to change the credentials to use certificates instead. I see that I should use the KERB_CERTIFICATE_LOGON structure for this. Diving deeper into the topic I found that I should implement a custom key storage provider as described in this article by microsoft. And that's the point where I am lost. Perhaps I am to silly to search for the right documentation but I just cannot find which interfaces I have to implement to have a KSP that I can refer to in the CspData-field of the KERB_CERTIFICATE_LOGON structure. I just find a bunch of methods and a quick search for NCRYPT_CERTIFICATE_PROPERTY (mentioned in the above linked article) revealed amazing two results in google.
I have found this SO-question that will help me connecting credentialprovider and KSP when I have one, but it does not explain how to write the KSP. :-(
Can anybody guide me where to find information or show a short sample of a KSP used in a similar scenario (just the method declarations, and how to use the resulting KSP in the call to KERB_CERTIFICATE_LOGON)?
","This Microsoft Cryptographic Provider Development Kit has a good sample of the KSP.
The only thing you need to do in addition to this sample is implement SmartCardKeyCertificate property.
The code will be something like this:
SECURITY_STATUS
WINAPI
KSPGetKeyProperty(
__in    NCRYPT_PROV_HANDLE hProvider,
__in    NCRYPT_KEY_HANDLE hKey,
__in    LPCWSTR pszProperty,
__out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
__in    DWORD   cbOutput,
__out   DWORD * pcbResult,
__in    DWORD   dwFlags)
{

    ...

    if (wcscmp(pszProperty, NCRYPT_CERTIFICATE_PROPERTY) == 0)
    {
        dwProperty = SAMPLEKSP_CERTIFICATE_PROPERTY;
        cbResult = GetCertificateSize(); //the size of the certificate that is associated with the key
    }

    *pcbResult = cbResult;
    if(pbOutput == NULL)
    {
        Status = ERROR_SUCCESS;
        goto cleanup;
    }

    if(cbOutput < *pcbResult)
    {
         Status = NTE_BUFFER_TOO_SMALL;
         goto cleanup;
    }

    if (wcscmp(pszProperty, NCRYPT_CERTIFICATE_PROPERTY) == 0)
    {
        CopyMemory(pbOutput, crt, sizeof(crt));
    }


    switch(dwProperty)
    {
    case SAMPLEKSP_CERTIFICATE_PROPERTY:
        CopyMemory(pbOutput, GetCertificate(), cbResult); //Copy to pbOutput the certificate in binary form 
        break;

    ...

    }

    ...

}

After you implement KSP and register it, your CredentialProvider can interact with it:
HRESULT MyCredential::GetSerialization(
    CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE* pcpgsr,
    CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION* pcpcs,
    PWSTR* ppwszOptionalStatusText,
    CREDENTIAL_PROVIDER_STATUS_ICON* pcpsiOptionalStatusIcon
    )
{

    ...

    ULONG ulAuthPackage;
    HRESULT hr = RetrieveNegotiateAuthPackage(&ulAuthPackage);
    ConstructAuthInfo(&pcpcs->rgbSerialization, &pcpcs->cbSerialization);

    if (SUCCEEDED(hr))
    {
        pcpcs->ulAuthenticationPackage = ulAuthPackage;
        pcpcs->clsidCredentialProvider = CLSID_MyCredentialProvider;

        // At this point the credential has created the serialized credential used for logon
        // By setting this to CPGSR_RETURN_CREDENTIAL_FINISHED we are letting logonUI know
        // that we have all the information we need and it should attempt to submit the 
        // serialized credential.
        *pcpgsr = CPGSR_RETURN_CREDENTIAL_FINISHED;
    }

    return hr;
}

HRESULT RetrieveNegotiateAuthPackage(ULONG * pulAuthPackage)
{
    HRESULT hr = S_OK;
    HANDLE hLsa = NULL;

    NTSTATUS status = LsaConnectUntrusted(&hLsa);
    if (SUCCEEDED(HRESULT_FROM_NT(status)))
    {

        ULONG ulAuthPackage;
        LSA_STRING lsaszKerberosName;
        LsaInitString(&lsaszKerberosName, MICROSOFT_KERBEROS_NAME_A);
        status = LsaLookupAuthenticationPackage(hLsa, &lsaszKerberosName, &ulAuthPackage);
        if (SUCCEEDED(HRESULT_FROM_NT(status)))
        {
            *pulAuthPackage = ulAuthPackage;
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_NT(status);
        }
        LsaDeregisterLogonProcess(hLsa);
    }
    else
    {
        hr = HRESULT_FROM_NT(status);
    }

    return hr;
}

void ConstructAuthInfo(LPBYTE* ppbAuthInfo, ULONG *pulAuthInfoLen)
{
    WCHAR szCardName[] = L""""; // no card name specified but you can put one if you want
    WCHAR szContainerName[] = L""my_key_name"";
    WCHAR szReaderName[] = L"""";
    WCHAR szCspName[] = L""My Key Storage Provider"";
    WCHAR szPin[] = L""11111111"";
    ULONG ulPinByteLen = wcslen(szPin) * sizeof(WCHAR);
    WCHAR szUserName[] = L""user"";
    ULONG ulUserByteLen = wcslen(szUserName) * sizeof(WCHAR);
    WCHAR szDomainName[] = L""testdomain.com"";
    ULONG ulDomainByteLen = wcslen(szDomainName) * sizeof(WCHAR);
    LPBYTE pbAuthInfo = NULL;
    ULONG  ulAuthInfoLen = 0;
    KERB_CERTIFICATE_LOGON *pKerbCertLogon;
    KERB_SMARTCARD_CSP_INFO *pKerbCspInfo;
    LPBYTE pbDomainBuffer, pbUserBuffer, pbPinBuffer;
    LPBYTE pbCspData;
    LPBYTE pbCspDataContent;

    ULONG ulCspDataLen = sizeof(KERB_SMARTCARD_CSP_INFO)-sizeof(TCHAR)+
        (wcslen(szCardName) + 1) * sizeof(WCHAR)+
        (wcslen(szCspName) + 1) * sizeof(WCHAR)+
        (wcslen(szContainerName) + 1) * sizeof(WCHAR)+
        (wcslen(szReaderName) + 1) * sizeof(WCHAR);

    ulAuthInfoLen = sizeof(KERB_CERTIFICATE_LOGON)+
        ulDomainByteLen + sizeof(WCHAR)+
        ulUserByteLen + sizeof(WCHAR)+
        ulPinByteLen + sizeof(WCHAR)+
        ulCspDataLen;

    pbAuthInfo = (LPBYTE)CoTaskMemAlloc(ulAuthInfoLen);
    ZeroMemory(pbAuthInfo, ulAuthInfoLen);

    pbDomainBuffer = pbAuthInfo + sizeof(KERB_CERTIFICATE_LOGON);
    pbUserBuffer = pbDomainBuffer + ulDomainByteLen + sizeof(WCHAR);
    pbPinBuffer = pbUserBuffer + ulUserByteLen + sizeof(WCHAR);
    pbCspData = pbPinBuffer + ulPinByteLen + sizeof(WCHAR);

    memcpy(pbDomainBuffer, szDomainName, ulDomainByteLen);
    memcpy(pbUserBuffer, szUserName, ulUserByteLen);
    memcpy(pbPinBuffer, szPin, ulPinByteLen);

    pKerbCertLogon = (KERB_CERTIFICATE_LOGON*)pbAuthInfo;

    pKerbCertLogon->MessageType = KerbCertificateLogon;
    pKerbCertLogon->DomainName.Length = (USHORT)ulDomainByteLen;
    pKerbCertLogon->DomainName.MaximumLength = (USHORT)(ulDomainByteLen + sizeof(WCHAR));
    pKerbCertLogon->DomainName.Buffer = (PWSTR)(pbDomainBuffer-pbAuthInfo);
    pKerbCertLogon->UserName.Length = (USHORT)ulUserByteLen;
    pKerbCertLogon->UserName.MaximumLength = (USHORT)(ulUserByteLen + sizeof(WCHAR));
    pKerbCertLogon->UserName.Buffer = (PWSTR)(pbUserBuffer-pbAuthInfo);
    pKerbCertLogon->Pin.Length = (USHORT)ulPinByteLen;
    pKerbCertLogon->Pin.MaximumLength = (USHORT)(ulPinByteLen + sizeof(WCHAR));
    pKerbCertLogon->Pin.Buffer = (PWSTR)(pbPinBuffer-pbAuthInfo);

    pKerbCertLogon->CspDataLength = ulCspDataLen;
    pKerbCertLogon->CspData = (PUCHAR)(pbCspData-pbAuthInfo);

    pKerbCspInfo = (KERB_SMARTCARD_CSP_INFO*)pbCspData;
    pKerbCspInfo->dwCspInfoLen = ulCspDataLen;
    pKerbCspInfo->MessageType = 1;
    pKerbCspInfo->KeySpec = CERT_NCRYPT_KEY_SPEC;

    pKerbCspInfo->nCardNameOffset = 0;
    pKerbCspInfo->nReaderNameOffset = pKerbCspInfo->nCardNameOffset + wcslen(szCardName) + 1;
    pKerbCspInfo->nContainerNameOffset = pKerbCspInfo->nReaderNameOffset + wcslen(szReaderName) + 1;
    pKerbCspInfo->nCSPNameOffset = pKerbCspInfo->nContainerNameOffset + wcslen(szContainerName) + 1;

    pbCspDataContent = pbCspData + sizeof(KERB_SMARTCARD_CSP_INFO)-sizeof(TCHAR);
    memcpy(pbCspDataContent + (pKerbCspInfo->nCardNameOffset * sizeof(WCHAR)), szCardName, wcslen(szCardName) * sizeof(WCHAR));
    memcpy(pbCspDataContent + (pKerbCspInfo->nReaderNameOffset * sizeof(WCHAR)), szReaderName, wcslen(szReaderName) * sizeof(WCHAR));
    memcpy(pbCspDataContent + (pKerbCspInfo->nContainerNameOffset * sizeof(WCHAR)), szContainerName, wcslen(szContainerName) * sizeof(WCHAR));
    memcpy(pbCspDataContent + (pKerbCspInfo->nCSPNameOffset * sizeof(WCHAR)), szCspName, wcslen(szCspName) * sizeof(WCHAR));

    *ppbAuthInfo = pbAuthInfo;
    *pulAuthInfoLen = ulAuthInfoLen;
}

There are two main things in this code:

For interacting with the KSP, pKerbCspInfo->KeySpec must be CERT_NCRYPT_KEY_SPEC.
For proper structure serialization, according to this answer:
pKerbCertLogon->DomainName.Buffer = (PWSTR)(pbDomainBuffer-pbAuthInfo);
    pKerbCertLogon->UserName.Buffer = (PWSTR)(pbUserBuffer-pbAuthInfo);
    pKerbCertLogon->Pin.Buffer = (PWSTR)(pbPinBuffer-pbAuthInfo);
    pKerbCertLogon->CspData = (PUCHAR)(pbCspData-pbAuthInfo);

Also the domain controller should issue the certificate with ""Kerberos Authentication"" template.
","776","<c++><kerberos><winlogon><credential-providers><cng>","1","3","1","2017-02-09 09:29:23","42132826","0","","-1","","2017-05-23 10:31:30","2017-01-26 08:21:20",""
"47025383","C# - Trying to create a CngKey from a .p8 file with import method, throwing error ""An error occurred during encode or decode operation.""","I'm trying to generate a JWT token using Jose.JWT.encode(payload, secretKey, JwsAlgorithm.ES256, header) (see https://github.com/dvsekhvalnov/jose-jwt) to use with Apple's new token-based APNs system. 
The JWT encode method requires the secretKey to be in CngKey format.
Here's my code converting the .p8 file from Apple to a CngKey object:
        var privateKeyContent = System.IO.File.ReadAllText(authKeyPath);
        var privateKey = privateKeyContent.Split('\n')[1];

        //convert the private key to CngKey object and generate JWT

        var secretKeyFile = Convert.FromBase64String(privateKey);
        var secretKey = CngKey.Import(secretKeyFile, CngKeyBlobFormat.Pkcs8PrivateBlob);

However, on the last line, the following error is thrown. 
System.Security.Cryptography.CryptographicException was unhandled by user code
  HResult=-2146885630
  Message=An error occurred during encode or decode operation.

  Source=System.Core
  StackTrace:
       at System.Security.Cryptography.NCryptNative.ImportKey(SafeNCryptProviderHandle provider, Byte[] keyBlob, String format)
       at System.Security.Cryptography.CngKey.Import(Byte[] keyBlob, String curveName, CngKeyBlobFormat format, CngProvider provider)
       at System.Security.Cryptography.CngKey.Import(Byte[] keyBlob, CngKeyBlobFormat format)
       at tokenauthapi.App_Start.TokenInitSendMessage.<send>d__0.MoveNext() in C:\token-push-prototype\token-auth-api\token-auth-api\App_Start\TokenInitSendMessage.cs:line 31
  InnerException: 

The input isn't in the wrong format as there's a separate error for that (that appears when I change the blob type). 
This code is running in a .NET WebApi v4.6.
I've searched high and low but haven't been able to decipher what this error is referring to. Any help would be greatly appreciated. Thank you.
","Turns out the .p8 file I was using had newlines in the middle of it for some reason. Possible that notepad added it (and saved it?). I was splitting by newlines to get the private key and therefore it was truncating the key. Once I removed the newlines it worked fine.
If you get the error occurred during encode or decode operation error, check whether your .p8 (or other) private key is malformed and is the right length. 
","775","<c#><jwt><cng>","3","2","3","2018-08-14 17:57:50","47043561","0","2","","","","2017-10-30 22:49:27",""
"47025383","C# - Trying to create a CngKey from a .p8 file with import method, throwing error ""An error occurred during encode or decode operation.""","I'm trying to generate a JWT token using Jose.JWT.encode(payload, secretKey, JwsAlgorithm.ES256, header) (see https://github.com/dvsekhvalnov/jose-jwt) to use with Apple's new token-based APNs system. 
The JWT encode method requires the secretKey to be in CngKey format.
Here's my code converting the .p8 file from Apple to a CngKey object:
        var privateKeyContent = System.IO.File.ReadAllText(authKeyPath);
        var privateKey = privateKeyContent.Split('\n')[1];

        //convert the private key to CngKey object and generate JWT

        var secretKeyFile = Convert.FromBase64String(privateKey);
        var secretKey = CngKey.Import(secretKeyFile, CngKeyBlobFormat.Pkcs8PrivateBlob);

However, on the last line, the following error is thrown. 
System.Security.Cryptography.CryptographicException was unhandled by user code
  HResult=-2146885630
  Message=An error occurred during encode or decode operation.

  Source=System.Core
  StackTrace:
       at System.Security.Cryptography.NCryptNative.ImportKey(SafeNCryptProviderHandle provider, Byte[] keyBlob, String format)
       at System.Security.Cryptography.CngKey.Import(Byte[] keyBlob, String curveName, CngKeyBlobFormat format, CngProvider provider)
       at System.Security.Cryptography.CngKey.Import(Byte[] keyBlob, CngKeyBlobFormat format)
       at tokenauthapi.App_Start.TokenInitSendMessage.<send>d__0.MoveNext() in C:\token-push-prototype\token-auth-api\token-auth-api\App_Start\TokenInitSendMessage.cs:line 31
  InnerException: 

The input isn't in the wrong format as there's a separate error for that (that appears when I change the blob type). 
This code is running in a .NET WebApi v4.6.
I've searched high and low but haven't been able to decipher what this error is referring to. Any help would be greatly appreciated. Thank you.
","I met the same issue. I use this:
var privateKey = privateKeyContent.Split('\n')[1];

Then I analyze token file downloaded from Apple. I found there are more \n in the file. I am not sure where this format is different or apple changed. 
Then I use the following codes to load the token, works.
Actually, we can directly use this token string.
var privateKeyContent = System.IO.File.ReadAllText(authKeyPath);
var privateKeyList = privateKeyContent.Split('\n');
int upperIndex = privateKeyList.Length;
StringBuilder sb = new StringBuilder();
for(int i= 1; i< upperIndex - 1; i++ )
{
    sb.Append(privateKeyList[i]);
    Debug.WriteLine(privateKeyList[i]);
}

","775","<c#><jwt><cng>","3","1","3","2018-08-14 17:57:50","47043561","0","2","","","","2017-10-30 22:49:27",""
"47025383","C# - Trying to create a CngKey from a .p8 file with import method, throwing error ""An error occurred during encode or decode operation.""","I'm trying to generate a JWT token using Jose.JWT.encode(payload, secretKey, JwsAlgorithm.ES256, header) (see https://github.com/dvsekhvalnov/jose-jwt) to use with Apple's new token-based APNs system. 
The JWT encode method requires the secretKey to be in CngKey format.
Here's my code converting the .p8 file from Apple to a CngKey object:
        var privateKeyContent = System.IO.File.ReadAllText(authKeyPath);
        var privateKey = privateKeyContent.Split('\n')[1];

        //convert the private key to CngKey object and generate JWT

        var secretKeyFile = Convert.FromBase64String(privateKey);
        var secretKey = CngKey.Import(secretKeyFile, CngKeyBlobFormat.Pkcs8PrivateBlob);

However, on the last line, the following error is thrown. 
System.Security.Cryptography.CryptographicException was unhandled by user code
  HResult=-2146885630
  Message=An error occurred during encode or decode operation.

  Source=System.Core
  StackTrace:
       at System.Security.Cryptography.NCryptNative.ImportKey(SafeNCryptProviderHandle provider, Byte[] keyBlob, String format)
       at System.Security.Cryptography.CngKey.Import(Byte[] keyBlob, String curveName, CngKeyBlobFormat format, CngProvider provider)
       at System.Security.Cryptography.CngKey.Import(Byte[] keyBlob, CngKeyBlobFormat format)
       at tokenauthapi.App_Start.TokenInitSendMessage.<send>d__0.MoveNext() in C:\token-push-prototype\token-auth-api\token-auth-api\App_Start\TokenInitSendMessage.cs:line 31
  InnerException: 

The input isn't in the wrong format as there's a separate error for that (that appears when I change the blob type). 
This code is running in a .NET WebApi v4.6.
I've searched high and low but haven't been able to decipher what this error is referring to. Any help would be greatly appreciated. Thank you.
","The security key (p8) provided by Apple for DeviceCheck also contained newlines. I used the following to get a valid CngKey:
var privateKeyContent = File.ReadAllText(""pathToApplePrivateKey.p8"");
var privateKeyList = privateKeyContent.Split('\n').ToList();
var privateKey = privateKeyList.Where((s, i) => i != 0 && i != privateKeyList.Count - 1)
                                   .Aggregate((agg, s) => agg + s);

CngKey key = CngKey.Import(Convert.FromBase64String(privateKey), CngKeyBlobFormat.Pkcs8PrivateBlob);

","775","<c#><jwt><cng>","3","2","3","2018-08-14 17:57:50","47043561","0","2","","","","2017-10-30 22:49:27",""
"36393151","Unresolved external symbol _BCryptEnumRegisteredProviders@8 when using CNG on Windows 10","I'm trying to do my first step with CNG (Cryptography Next Generation) in VC++ 2015 (Windows 10 x64). Here's the code:
#include ""stdafx.h""
#include <windows.h>

int main()
{
    NTSTATUS status;
    ULONG cbBufSize = 0;
    PCRYPT_PROVIDERS pBuf = NULL;
    status = BCryptEnumRegisteredProviders(&cbBufSize, &pBuf);
    return 0;
}

Building the project (for x86), I got an error message:

Error LNK2019 unresolved external symbol
  _BCryptEnumRegisteredProviders@8 referenced in function _main

I then tried to install ""CNG Software Development Kit"" and configured the project following this instruction: http://www.codeproject.com/Articles/18713/Simple-way-to-crypt-a-file-with-CNG
but project building gave the same error message.
Please help!
PS: I did the same thing in (Win7 x86, VS 2008) and it worked without any error.
","","710","<windows><linker-errors><cng>","0","","0","2019-08-19 10:30:38","","6","","608639","","2019-08-19 10:30:38","2016-04-04 01:01:16",""
"9798480","Problems using CNG and BCRYPT_KDF_SP80056A_CONCAT KDF","I am in the processing of implementing a CNG ECDH  and then I am trying to use the BCRYPT_KDF_SP80056A_CONCAT  KDF to derive a symmetric AES256 key (BCryptDeriveKey()).  I am having a problem (i always get back 0xc000000d status returned.)
i have generated a shared secret successfully and I have created the buffer desc ""BCryptBufferDesc"" which has an array of ""BCryptBuffer"" with 1 AlgorithmID, 1 PartyU and 1 PartyV ""other info"". I think I have the structures all defined and populated properly. I am just picking some ""values"" for PartyU and PartyV bytes (i tried 1 byte and 16 bytes for each but i get the same result). NIST documentation gives no details about what the other info should be.. 
i have followed the Microsoft web site for creating these structures, using their strings, defines, etc.     I tried with the standard L""HASH"" kdf and it works and i get the same derived key on both ""sides"", but with the concatenation KDF i always get the same 0xC000000D status back..  
Has anybody else been able to successfully use BCRYPT_KDF_SP80056A_CONCAT CNG KDF? If you did, do you have any hints? 
","This worked for me:
    ULONG derivedKeySize = 32;
    BCryptBufferDesc params;
    params.ulVersion = BCRYPTBUFFER_VERSION;
    params.cBuffers = 3;
    params.pBuffers = new BCryptBuffer[params.cBuffers];
    params.pBuffers[0].cbBuffer = 0;
    params.pBuffers[0].BufferType = KDF_ALGORITHMID;
    params.pBuffers[0].pvBuffer = new byte[0];
    params.pBuffers[1].cbBuffer = 0;
    params.pBuffers[1].BufferType = KDF_PARTYUINFO;
    params.pBuffers[1].pvBuffer = new byte[0];
    params.pBuffers[2].cbBuffer = 0;
    params.pBuffers[2].BufferType = KDF_PARTYVINFO;
    params.pBuffers[2].pvBuffer = new byte[0];

    NTSTATUS rv = BCryptDeriveKey(secretHandle, L""SP800_56A_CONCAT"", &params, NULL, 0, &derivedKeySize, 0);
    if (rv != 0){/*fail*/}

    UCHAR derivedKey = new UCHAR[derivedKeySize];

    rv = BCryptDeriveKey(secretHandle, L""SP800_56A_CONCAT"", &params, derivedKey, derivedKeySize, &derivedKeySize, 0);
    if (rv  != 0){/*fail*/}

","666","<encryption><public-key-encryption><encryption-asymmetric><bcrypt><cng>","1","2","1","2012-06-10 16:56:24","","0","","","","","2012-03-21 04:08:52",""
"44408910","Does WCF in .NET 4.6.2 support server certificates with PK in CNG KSP?","On Windows, a TLS server certificate (which sits in a certificate store) comes with a private key (PK) which sits either in a CSP keystore or CNG keystore.  Where the PK ends up, can be specified when importing the certificate (that is, on recent Windows versions), for example using the -sp (subject's provider) parameter to makecert.
Now if the provider isn't specified, the defaults aren't friendly.  The PK ends up in the CNG KSP and will be unusable by WCF.
Microsoft says that "".NET Framework 4.6.1 and earlier versions do not support these certificates because they use the legacy CryptoAPI to handle CNG/KSP certificates. The use of these certificates with .NET Framework 4.6.1 and earlier versions will cause an exception.""
However, I'm seeing the exact same behavior between .NET framework 4.6.1 and .NET framework 4.6.2 installed on the server side of the connection.  What happens is that the server appears (per its own logs) to be happily listening on the designated port, but the port is not open (per netstat -a).  Windows event logs mentions Invalid provider type specified while the server is trying to open the port.
There's net.tcp port sharing sitting between the server and the actual port if that matters.
Is anyone running any version of .NET (using WCF) successfully with server certificates in CNG KSP?  Is the Microsoft documentation above simply incorrect?
","Here is a link that talks about the limitations (link)
What I was successful on doing was to convert the private key provider to a Microsoft Enhanced Cryptographic Provider v1.0 (CryptoAPI) this resolved the issue. 
","623","<.net><windows><wcf><ssl><cng>","3","2","1","2018-02-08 09:57:11","","0","","","","","2017-06-07 09:37:37",""
"47887548","c# JWT using ES256, load privateKey into CngKey to be validated in talkdesk (jose-jwt)","I am attempting to generate a JWT using a ES256 algorithm to be validated by talk desk (documentation: https://docs.talkdesk.com/docs/using-a-signed-jwt).
BUT I have an ADO.net project so I can't use any of the frameworks they sugested, so I thought the right path would be to use the https://github.com/dvsekhvalnov/jose-jwt library.
The jose-jwt documentation state:

ES256, ES384, ES256 ECDSA signatures requires CngKey (usually private) elliptic curve key of corresponding length. Normally existing
  CngKey loaded via CngKey.Open(..) method from Key Storage Provider.
  But if you want to use raw key material (x,y) and d, jose-jwt provides
  convenient helper EccKey.New(x,y,d).

I'm having trouble understanding how does my private key that I receive from talkdesk will fit in all this.
Bellow is my code:
public static string Encode(TenantModel tenant)
        {

            byte [] keyBytes= Encoding.UTF8.GetBytes(tenant.private_key); 
            var header = new Dictionary<string, object>()
            {
                { ""header"", new { kid = tenant.key_id} }
                //{ ""algorithm"", tenant.key_algorithm }
            };

            var payload = new Dictionary<string, object>()
            {
                { ""iss"", tenant.client_id },
                { ""sub"", tenant.client_id },
                { ""aud"", ""https://"" + tenant.account_name + "".talkdeskid.com/oauth/token"" },
                { ""jti"", Guid.NewGuid().ToString() },
                { ""exp"", DateTime.Now.AddSeconds(300) },
                { ""iat"", DateTime.Now }
            };

            var privatekey = new ECDsaCng(CngKey.Create(CngAlgorithm.ECDsaP256));
            privatekey.SignData(keyBytes, 0, keyBytes.Length, HashAlgorithmName.SHA256);        

            return Jose.JWT.Encode(payload, privatekey, JwsAlgorithm.ES256,header);
        }

I've also seen that using the CngKey.Open(..) method implies the creation of a certificate and I would like to stay away from that If possible.
","I encountered the same issue connecting to Apple's app store connect API. They hand you a .p8 file with a private key and it is not clear how to integrate this with jose-jwt which assumes you have X, Y, and D or a CngKey which is a data object I'm not very familiar with. But in the end, it wasn't very hard at all. 
Open up the .p8 file in a text editor and copy out the private key. It is the character data between the ""---- BEGIN PRIVATE KEY ----"" header and footer. Remove newlines. You have a single Base64 encoded blob of data.
var privateKey = ""MAGTAguM[...]qaTKB2"";

var key = CngKey.Import(Convert.FromBase64String(privateKey), 
                        CngKeyBlobFormat.Pkcs8PrivateBlob);

return Jose.JWT.Encode(payload, key, JwsAlgorithm.ES256, extraHeaders);

","595","<c#><algorithm><encryption><cng>","1","1","1","2019-01-22 18:44:48","","0","0","6801202","","2017-12-19 14:13:44","2017-12-19 12:55:16",""
"38115602","Exporting shared secret as BYTE array from BCRYPT_SECRET_HANDLE","I'm implementing ECDHE using crypto next generation APIs (CNG). I generate public and private keys successfully. For pre-shared key, I use BCryptSecretAgreement API, which returns me the pre-shared key secret handle (BCRYPT_SECRET_HANDLE). 
How can I export the pre-shared key as BYTE array from the BCRYPT_SECRET_HANDLE?
","Once you got your BCRYPT_SECRET_HANDLE, you use BCryptDeriveKey to obtain the actual symmetric encryption key.
","592","<c++><c><tls1.2><cng><ecdhe>","3","0","4","2019-10-14 23:24:13","","0","","3364821","","2016-11-12 07:26:17","2016-06-30 06:37:24",""
"38115602","Exporting shared secret as BYTE array from BCRYPT_SECRET_HANDLE","I'm implementing ECDHE using crypto next generation APIs (CNG). I generate public and private keys successfully. For pre-shared key, I use BCryptSecretAgreement API, which returns me the pre-shared key secret handle (BCRYPT_SECRET_HANDLE). 
How can I export the pre-shared key as BYTE array from the BCRYPT_SECRET_HANDLE?
","After calling BCryptSecretAgreement, You need to use the BCryptDeriveKey function to retrieve the shared secret.
This can be done as follows:
// generates an ECDH shared secret from a public key and a private key
int get_ECDH_key(BCRYPT_KEY_HANDLE pubkey, BCRYPT_KEY_HANDLE privkey, unsigned char **key,
                 unsigned int *keylen)
{
    SECURITY_STATUS sstatus;
    BCRYPT_SECRET_HANDLE secret;
    int _len;

    // creates the shared secret, stored in a BCRYPT_SECRET_HANDLE 
    sstatus = BCryptSecretAgreement(privkey, pubkey, &secret, 0);
    if (!BCRYPT_SUCCESS(sstatus)) {
        printf(""BCryptSecretAgreement failed with status %d"", sstatus);
        return 0;
    }

    // find out how much space is needed before retrieving the shared secret
    sstatus = BCryptDeriveKey(secret, BCRYPT_KDF_HASH, NULL, NULL, 0, &_len, 0);
    if (!BCRYPT_SUCCESS(sstatus)) {
        printf(""BCryptDeriveKey failed with status %d"", sstatus);
        return 0;
    }

    // allocate space for the shared secret
    *key = malloc(_len);
    if (*key == NULL) {
        perror(""malloc failed"");
        exit(1);
    }

    // retrieve the shared secret
    sstatus = BCryptDeriveKey(secret, BCRYPT_KDF_HASH, NULL, *key, _len,
                              keylen, 0 );
    if (!BCRYPT_SUCCESS(sstatus)) {
        printf(""BCryptDeriveKey failed with status %d"", sstatus);
        return 0;
    }
    return 1;
}

For the second parameter, the constant BCRYPT_KDF_HASH says to use a hash as the key derivation function.  The hash to use can be specified in the third parameter.  In this example, the third parameter is NULL, so it uses SHA1 by default.
Also, the fourth parameter, which is a pointer to the buffer to receive the key, can be NULL.  If so, the key is not copied however the number of bytes that would be copied are written to the address given by the sixth parameter.  This allows us to allocate the proper amount of space then call the function again, this time passing in the address of the allocated buffer.
","592","<c++><c><tls1.2><cng><ecdhe>","3","-1","4","2019-10-14 23:24:13","","0","","3364821","","2016-11-12 07:26:17","2016-06-30 06:37:24",""
"38115602","Exporting shared secret as BYTE array from BCRYPT_SECRET_HANDLE","I'm implementing ECDHE using crypto next generation APIs (CNG). I generate public and private keys successfully. For pre-shared key, I use BCryptSecretAgreement API, which returns me the pre-shared key secret handle (BCRYPT_SECRET_HANDLE). 
How can I export the pre-shared key as BYTE array from the BCRYPT_SECRET_HANDLE?
","Starting with Windows 10, you can call BCryptDeriveKey() with BCRYPT_KDF_RAW_SECRET.  
The resulting key data is the raw secret.
Note 1: bcrypt.h indicates that this format works for ""WINBLUE"", which would be Windows 8.1, if I understand correctly, but I received STATUS_NOT_SUPPORTED for the use of this KDF type on both Windows 8.1 and Windows Server 2012 R2.  This works, however, on Windows 10.)
Note2: I found the data returned using this KDF type to be little-endian (where everything else in BCrypt is big-endian).  So, to use the value in an otherwise big-endian world, you need to byte-flip the data.
","592","<c++><c><tls1.2><cng><ecdhe>","3","1","4","2019-10-14 23:24:13","","0","","3364821","","2016-11-12 07:26:17","2016-06-30 06:37:24",""
"38115602","Exporting shared secret as BYTE array from BCRYPT_SECRET_HANDLE","I'm implementing ECDHE using crypto next generation APIs (CNG). I generate public and private keys successfully. For pre-shared key, I use BCryptSecretAgreement API, which returns me the pre-shared key secret handle (BCRYPT_SECRET_HANDLE). 
How can I export the pre-shared key as BYTE array from the BCRYPT_SECRET_HANDLE?
","I needed to do the following, and here is an excerpt from my code which does the critical items, you will need to import the private and public keys before this segment
DWORD bCryptStatus;
BCRYPT_SECRET_HANDLE secretHandle = NULL;
BCRYPT_KEY_HANDLE privateKeyHandle= NULL;
BCRYPT_KEY_HANDLE importedPublicKey = NULL;
BYTE *agreedSecret = NULL;
DWORD agreedSecretLength = 0;

//Import your keys here

//Generate the secret from the imported keys
bCryptStatus= BCryptSecretAgreement(privateKeyHandle, importedPublicKey, &secretHandle, 0);

//Now get the raw value of the secret agreement and copy it into an array
bCryptStatus= BCryptDeriveKey(
    secretHandle,          // Secret agreement handle
    BCRYPT_KDF_RAW_SECRET, // Key derivation function (null terminated unicode string)
    NULL,                  // KDF parameters
    NULL,                  // Buffer that recieves the derived key 
    0,                     // Length of the buffer
    &agreedSecretLength,   // Number of bytes copied to the buffer
    0);                    // Flags

    agreedSecret = (PBYTE)MALLOC(agreedSecretLength);

if (NULL != agreedSecret)
{
    _nCryptError = BCryptDeriveKey(
    secretHandle,          // Secret agreement handle
    BCRYPT_KDF_RAW_SECRET, // Key derivation function (null terminated unicode string)
    NULL,                  // KDF parameters
    agreedSecret,          // Buffer that recieves the derived key 
    agreedSecretLength,    // Length of the buffer
    &agreedSecretLength,   // Number of bytes copied to the buffer
    0);                    // Flags
}

//Free all the objects and the array when you are done, otherwise you will get memory leaks
if (NULL != importedPublicKey)
{
    BCryptDestroyKey(importedPublicKey);
}

if (NULL != privateKeyHandle)
{
    BCryptDestroyKey(privateKeyHandle);
}

if (NULL != secretHandle)
{
    BCryptDestroySecret(secretHandle);
}

if (NULL != agreedSecret)
{
    FREE(agreedSecret);
}


As a side note, if you use NCrypt, this will work also (NCryptDeriveKey), I verified it on my production code.
As it was stated earlier, the array will be reversed, and you will need to reverse the array of bytes to get the secret.
","592","<c++><c><tls1.2><cng><ecdhe>","3","0","4","2019-10-14 23:24:13","","0","","3364821","","2016-11-12 07:26:17","2016-06-30 06:37:24",""
"51072217","How to get a certificate store from a smart card (USB Token) using CNG?","I'm using Crypto API's CryptAcquireContext function (https://docs.microsoft.com/en-us/windows/desktop/api/Wincrypt/nf-wincrypt-cryptacquirecontexta) to get access to my Certificate Store contained on my USB Token, and this is working like a charm!
However, the CryptAcquireContext function is deprecated and the Crypto API documentation recommends the use of CNG to achieve the same results. All my problem now is how to use CNG to get a certificate context from my USB Token, and to achieve this I'm using the following code:
var
  Provider: NCRYPT_PROV_HANDLE;
  Reader: PByte;
  ReaderSize: DWORD;
  MemorySize: DWORD;
begin
  // Get a handle to the smartcard reader specific provider
  Status := NCryptOpenStorageProvider(@Provider
                                     ,'SafeSign Standard RSA and AES Cryptographic Service Provider'
                                     ,0); // returns ERROR_SUCCESS
  // Convert the name of the reader to a PByte
  UnicodeStringToBinary('Giesecke & Devrient GmbH StarSign CUT 0',Reader,ReaderSize);

  // Inform the name of the reader to the CNG
  Status := NCryptSetProperty(Provider
                             ,NCRYPT_READER_PROPERTY
                             ,Reader
                             ,ReaderSize
                             ,0); // returns ERROR_SUCCESS

  MemorySize := SizeOf(HCERTSTORE);

  // Try to get the size needed to a variable of type HCERTSTORE.
  // This is the first step before get the certificate store
  Status := NCryptGetProperty(Provider
                             ,NCRYPT_USER_CERTSTORE_PROPERTY
                             ,nil
                             ,0
                             ,@MemorySize
                             ,0); //Returns 0x80090029 (NTE_NOT_SUPPORTED)
end;

As you can see the NCryptGetProperty function fails with error code 0x80090029 which means NTE_NOT_SUPPORTED. What I'm doing wrong? I've found an example (C++) doing the same as me, so, I guess everything is OK with my implementation, but...
My goal is to list all certificates on my smart card (actually an USB Token). I can do this using Crypto API, but the CryptAcquireContext function is deprecated, so, I need to use another one. Using CAPI I get the Certificate Store and I can list It using the default certificate dialog, so, I need, using CNG, get the Certificate Store to do the same thing, but the way I'm doing now seems wrong.
Well, some observations:

I'm not checking the returns here (Status variable) to simplify this code sample
The UnicodeStringToBinary function is strictly correct. The returned buffer (PByte) has twice the size of the original string and the bytes are all ""nn 00 nn 00 nn 00"", so, the Reader variable contains an Unicode String, just like the NCRYPT_READER_PROPERTY property requires. I can post the code on request.
My NCryptOpenStorageProvider signature is more close of the Windows API version, so, its first argument is a pointer to NCRYPT_PROV_HANDLE

","","573","<delphi><certificate><cng>","4","","0","2018-09-04 19:58:48","","11","1","214143","","2018-09-04 19:58:48","2018-06-27 22:21:10",""
"40192062","DPAPI NG - NCryptProtectSecret returns NTE_ENCRYPTION_FAILURE","I am trying to encrypt data using DPAPI-NG but it fails on execution of NCryptProtectSecret, it returns:

0x80090034 (NTE_ENCRYPTION_FAILURE)

I have created NCryptCreateProtectionDescriptor with local user SID:
""SID=S-1-5-21-2942599413-360359348-3087651068-500""

Then I use this instance of descriptor as input for NCryptProtectSecret, but it does not work.
If I use a protection descriptor of:
""LOCAL=user""

everything seems okay, but it does not work with SID for user or group. I have tested this on Windows Server 2012R2 and Windows Server 2016.
Any idea?
Here is a code sample:
SECURITY_STATUS Status;
PBYTE       ProtectedData = NULL;
ULONG       ProtectedDataLength = 0;
NCRYPT_DESCRIPTOR_HANDLE    DescriptorHandle = NULL;
LPCWSTR ProtectionDescString = L""SID=S-1-5-21-2942599413-360359348-3087651068-500"";

Status = NCryptCreateProtectionDescriptor(
                                        ProtectionDescString,
                                        0,
                                        &DescriptorHandle
                                        );      
// Status is ERROR_SUCCESS (zero)


LPCWSTR SecretString = L""Some message to protect"";
PBYTE Secret = (PBYTE)SecretString;
DWORD SecretLength = (ULONG)( (wcslen(SecretString)+1)*sizeof(WCHAR) );

Status = NCryptProtectSecret(
                        DescriptorHandle,
                        0,
                        PlainText,
                        PlainTextLength,
                        NULL, // Use default allocations by LocalAlloc/LocalFree
                        NULL, // Use default parent windows handle.
                        &ProtectedData,  // out LocalFree
                        &ProtectedDataLength
                        );

**// Status == NTE_ENCRYPTION_FAILURE**

","Replace PlainText and PlainTextLength with Secret and SecretLength.
","550","<windows-server-2012-r2><dpapi><cng>","3","1","4","2017-10-05 21:53:51","45177887","0","1","12597","","2017-10-05 21:47:35","2016-10-22 12:16:41",""
"40192062","DPAPI NG - NCryptProtectSecret returns NTE_ENCRYPTION_FAILURE","I am trying to encrypt data using DPAPI-NG but it fails on execution of NCryptProtectSecret, it returns:

0x80090034 (NTE_ENCRYPTION_FAILURE)

I have created NCryptCreateProtectionDescriptor with local user SID:
""SID=S-1-5-21-2942599413-360359348-3087651068-500""

Then I use this instance of descriptor as input for NCryptProtectSecret, but it does not work.
If I use a protection descriptor of:
""LOCAL=user""

everything seems okay, but it does not work with SID for user or group. I have tested this on Windows Server 2012R2 and Windows Server 2016.
Any idea?
Here is a code sample:
SECURITY_STATUS Status;
PBYTE       ProtectedData = NULL;
ULONG       ProtectedDataLength = 0;
NCRYPT_DESCRIPTOR_HANDLE    DescriptorHandle = NULL;
LPCWSTR ProtectionDescString = L""SID=S-1-5-21-2942599413-360359348-3087651068-500"";

Status = NCryptCreateProtectionDescriptor(
                                        ProtectionDescString,
                                        0,
                                        &DescriptorHandle
                                        );      
// Status is ERROR_SUCCESS (zero)


LPCWSTR SecretString = L""Some message to protect"";
PBYTE Secret = (PBYTE)SecretString;
DWORD SecretLength = (ULONG)( (wcslen(SecretString)+1)*sizeof(WCHAR) );

Status = NCryptProtectSecret(
                        DescriptorHandle,
                        0,
                        PlainText,
                        PlainTextLength,
                        NULL, // Use default allocations by LocalAlloc/LocalFree
                        NULL, // Use default parent windows handle.
                        &ProtectedData,  // out LocalFree
                        &ProtectedDataLength
                        );

**// Status == NTE_ENCRYPTION_FAILURE**

","I haven't figured out what was the problem, but everything worked fine in different domain. Microsoft also confirmed that working example that we have sent to them was correct, but they didn't explain what was be the problem.
","550","<windows-server-2012-r2><dpapi><cng>","3","0","4","2017-10-05 21:53:51","45177887","0","1","12597","","2017-10-05 21:47:35","2016-10-22 12:16:41",""
"40192062","DPAPI NG - NCryptProtectSecret returns NTE_ENCRYPTION_FAILURE","I am trying to encrypt data using DPAPI-NG but it fails on execution of NCryptProtectSecret, it returns:

0x80090034 (NTE_ENCRYPTION_FAILURE)

I have created NCryptCreateProtectionDescriptor with local user SID:
""SID=S-1-5-21-2942599413-360359348-3087651068-500""

Then I use this instance of descriptor as input for NCryptProtectSecret, but it does not work.
If I use a protection descriptor of:
""LOCAL=user""

everything seems okay, but it does not work with SID for user or group. I have tested this on Windows Server 2012R2 and Windows Server 2016.
Any idea?
Here is a code sample:
SECURITY_STATUS Status;
PBYTE       ProtectedData = NULL;
ULONG       ProtectedDataLength = 0;
NCRYPT_DESCRIPTOR_HANDLE    DescriptorHandle = NULL;
LPCWSTR ProtectionDescString = L""SID=S-1-5-21-2942599413-360359348-3087651068-500"";

Status = NCryptCreateProtectionDescriptor(
                                        ProtectionDescString,
                                        0,
                                        &DescriptorHandle
                                        );      
// Status is ERROR_SUCCESS (zero)


LPCWSTR SecretString = L""Some message to protect"";
PBYTE Secret = (PBYTE)SecretString;
DWORD SecretLength = (ULONG)( (wcslen(SecretString)+1)*sizeof(WCHAR) );

Status = NCryptProtectSecret(
                        DescriptorHandle,
                        0,
                        PlainText,
                        PlainTextLength,
                        NULL, // Use default allocations by LocalAlloc/LocalFree
                        NULL, // Use default parent windows handle.
                        &ProtectedData,  // out LocalFree
                        &ProtectedDataLength
                        );

**// Status == NTE_ENCRYPTION_FAILURE**

","I ran into this problem and found that the cause was our domain was running at a functional level that was less than 2012.  After upgrading the domain to 2012 the problem was resolved.
A quick and easy way to determine the functional level is the following PowerShell cmdlet
[system.directoryservices.activedirectory.Forest]::GetCurrentForest().ForestMode

","550","<windows-server-2012-r2><dpapi><cng>","3","1","4","2017-10-05 21:53:51","45177887","0","1","12597","","2017-10-05 21:47:35","2016-10-22 12:16:41",""
"40192062","DPAPI NG - NCryptProtectSecret returns NTE_ENCRYPTION_FAILURE","I am trying to encrypt data using DPAPI-NG but it fails on execution of NCryptProtectSecret, it returns:

0x80090034 (NTE_ENCRYPTION_FAILURE)

I have created NCryptCreateProtectionDescriptor with local user SID:
""SID=S-1-5-21-2942599413-360359348-3087651068-500""

Then I use this instance of descriptor as input for NCryptProtectSecret, but it does not work.
If I use a protection descriptor of:
""LOCAL=user""

everything seems okay, but it does not work with SID for user or group. I have tested this on Windows Server 2012R2 and Windows Server 2016.
Any idea?
Here is a code sample:
SECURITY_STATUS Status;
PBYTE       ProtectedData = NULL;
ULONG       ProtectedDataLength = 0;
NCRYPT_DESCRIPTOR_HANDLE    DescriptorHandle = NULL;
LPCWSTR ProtectionDescString = L""SID=S-1-5-21-2942599413-360359348-3087651068-500"";

Status = NCryptCreateProtectionDescriptor(
                                        ProtectionDescString,
                                        0,
                                        &DescriptorHandle
                                        );      
// Status is ERROR_SUCCESS (zero)


LPCWSTR SecretString = L""Some message to protect"";
PBYTE Secret = (PBYTE)SecretString;
DWORD SecretLength = (ULONG)( (wcslen(SecretString)+1)*sizeof(WCHAR) );

Status = NCryptProtectSecret(
                        DescriptorHandle,
                        0,
                        PlainText,
                        PlainTextLength,
                        NULL, // Use default allocations by LocalAlloc/LocalFree
                        NULL, // Use default parent windows handle.
                        &ProtectedData,  // out LocalFree
                        &ProtectedDataLength
                        );

**// Status == NTE_ENCRYPTION_FAILURE**

","Check that the user running the application really is user
S-1-5-21-2942599413-360359348-3087651068-500

You can test this from and command prompt:
>whoami /user

USER INFORMATION
----------------

User Name     SID
============= ============================================
erbium\zeljko S-1-5-21-2942599413-360359348-3087651068-500

I got the NTE_ENCRYPTION_FAILURE when i was attempting to use a Group SID that i didn't actually have (the Domain Users group).
It might be you simply have the wrong sid compared to who is running the code.
","550","<windows-server-2012-r2><dpapi><cng>","3","0","4","2017-10-05 21:53:51","45177887","0","1","12597","","2017-10-05 21:47:35","2016-10-22 12:16:41",""
"29994639","Use key stored in Windows key store as a pre-shared secret key in OpenSSL","I'm wondering if this is possible. I've already implemented an SSL connection that uses PSK, but I wanted to somehow secure the PSK so that it could only be accessible by the current user. I figured the windows key store would be the safest.
Does anyone have tips that I could do this? The SSL portion is already done using OpenSSL, but I'm not sure about the key storage. I've been trying out the windows CNG api, but having a hard time figuring out how use the stored random key as the PSK.
","
I've already implemented an SSL connection that uses PSK, but I wanted to somehow secure the PSK so that it could only be accessible by the current user. I figured the windows key store would be the safest...

What you want is called ""Protected Storage"". It goes by different names depending on the platform you are using. For example, its called a Keychain on Apple platforms, and KeyChain on Android platforms.
Microsoft has protected storage, and a few implementations depending on the technology you are working with. In the early days, Microsoft called it Protected Storage and it was provided by the Protected Storage Service.
Microsoft deprecated Protected Storage with Windows Server 2003 and Windows XP, and offered Protected Storage (Pstore) for those operating systems. See Protected Storage (Pstore) on MSDN. Microsoft also recommended using the Data Protection API (DPAPI) for encrypting secrets under the user logins. That ended sometime around Windows 8.
Microsoft provides the Credential Manager for Windows 7 and above. It allows you to store passwords for user logins, and bits like PSK keys.
If you need something stronger with a key hierarchy, then the Cryptography API or Crypto API Next Generation can be used. If you use CryptoAPI or CNG, then I believe you need to create a public/private keypair, and then encrypt the PSK under the public key. You decrypt it with the private key when needed. You store the encrypted PSK anywhere you like, from the file system to the registry or online. Also see Softwariness's answer at How to deal with plaintext keys using CNG?
","529","<openssl><cng>","1","1","1","2016-05-02 00:40:41","36973588","0","","","","","2015-05-01 20:27:47",""
"44670980",".NET wrapper for DPAPI-NG and user group access configuration","I have a number of workstations which are part of my domain, each running some .NET application. One central server stores secrets which I would like to be encrypted by a key which is accessible to all users of the system which have the appropriate user group.
I found that .NET does offer a wrapper for DPAPI, but I was wondering if the same applies for DPAPI-NG, where a wrapper function exists for NCryptProtectSecret and NCreatProtectionDescription. Furthermore, how would I go about configuring the descriptor, so as to only allow a specific user group from my domain to decrypt the secret?
In case there is no wrapper I'd have to import the ncrypt.dll and work with that. Can anyone who has experience with this library confirm that this URL has an up-to-date API https://msdn.microsoft.com/en-us/library/windows/desktop/hh706795(v=vs.85).aspx?
","
I found that .NET does offer a wrapper for DPAPI, but I was wondering if the same applies for DPAPI-NG, where a wrapper function exists for NCryptProtectSecret

NCryptProtectSecret has no hits on referencesource.microsoft.com. So it is probable that no such wrapper API exists within the framework.

Can anyone who has experience with this library confirm that this URL has an up-to-date API https://msdn.microsoft.com/en-us/library/windows/desktop/hh706795(v=vs.85).aspx?

Function signatures in Win32 never change.  The documentation may have errors in the prose, but almost never in the API surface.  The best way to be sure is to find a copy of the header file it was declared in, but really that's usually only necessary if a) a named constant is referenced but no value is provided or b) you P/Invoke and crash and are trying to figure out why.
A quick search shows that https://github.com/NuGet/NuGet.Operations/blob/master/src/NuGet.Services.Operations/Secrets/DpapiNg/NativeMethods.cs has P/Invoked these.  If NuGet's Apache license is compatible with your usages/needs you could compare your conclusions to theirs.
","526","<c#><.net><encryption><dpapi><cng>","1","0","1","2017-06-21 16:05:50","","0","","","","","2017-06-21 08:42:09",""
"51748439","How to use bcrypt_gensalt with /dev/urandom on Windows?","I used this BCrypt lib to generate a hash with salt: https://github.com/rg3/libbcrypt
The problem is in bcrypt.c (int bcrypt_gensalt). open(""/dev/urandom"", O_RDONLY) does not work on Windows. I have tried the following:
int bcrypt_gensalt(int factor, char salt[BCRYPT_HASHSIZE]) {
    int fd;
    unsigned char input[RANDBYTES];
    int workf;
    char *aux;

    HCRYPTPROV hCryptProv;

    if (CryptAcquireContext(
        &hCryptProv,
        NULL,
        (LPCSTR)""Microsoft Base Cryptographic Provider v1.0"",
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT)) {
        if (CryptGenRandom(
            hCryptProv,
            RANDBYTES,
            input)) {

            if (CryptReleaseContext(hCryptProv, 0)) {
                return 0;
            }
            else {
                printf(""Error during CryptReleaseContext.\n"");
            return 4;
            }
        }
        else {
            if (CryptReleaseContext(hCryptProv, 0)) {
                printf(""Error during CryptGenRandom.\n"");
                return 2;
            }
            else {
                printf(""Error during CryptReleaseContext.\n"");
                return 3;
            }
        }
    }
    else {
        printf(""Error during CryptAcquireContext!\n"");
        return 1;
    }

    /* Generate salt. */
    workf = (factor < 4 || factor > 31)?12:factor;
    aux = crypt_gensalt_rn(""$2a$"", workf, input, RANDBYTES,
                   salt, BCRYPT_HASHSIZE);
    return (aux == NULL)?5:0;
}

But the result is:
Generated salt:
Hashed password: *0
Time taken: 0.000000 seconds
First hash check: OK
Second hash check: OK
First hash check with bcrypt_checkpw: OK
Time taken: 0.060000 seconds
Second hash check with bcrypt_checkpw: OK
Time taken: 0.060000 seconds

The salt will be not generated correctly.
","In your call to:
aux = crypt_gensalt_rn(""$2a$"", workf, input, RANDBYTES,
                   salt, BCRYPT_HASHSIZE);

The values of RANDBYTES and BCRYPT_HASHSIZE need one more byte for terminated \0.
Have you tried that (using RANDBYTES-1 and BCRYPT_HASHSIZE-1)?
","509","<c++><windows><visual-studio><cng>","1","0","1","2019-08-19 10:08:03","","8","","608639","","2019-08-19 10:08:03","2018-08-08 13:50:52",""
"25507100","CNG replacements for CryptBinaryToString/CryptStringToBinary?","I was expecting to find CNG alternatives to the older Crypto API calls for serializing BLOB data.  However there do not seem to be CNG replacements for CryptBinaryToString and CryptStringToBinary.
Am I missing something, or do most programmers either go ahead and load and use Crypt32.dll or do they just roll their own, use a 3rd party library, or ...?
","I expect that CNG doesn't have counterparts for CryptBinaryToString and CryptStringToBinary because CNG focuses on improving the base cryptographic functionality and has fewer helper functions than CAPI. Also, in many applications they would not be applicable, as the crypto code would be integrated with a protocol that will want cryptographic material to be marshalled in a particular way that these CAPI functions don't support.
I can see though that these CAPI functions would be useful when dealing with Base64/PEM formats for e.g. RSA public keys. There's no reason not to continue to use these CAPI functions with CNG if they do the job you want, or you could use a third-party library like you say.
","501","<cng>","1","1","1","2015-01-23 14:22:57","28111960","0","","","","","2014-08-26 13:29:56",""
"23512596","Adding new cipher suites in SSL (TLS) using CNG","As far as I know since Windows Vista CNG(Cryptography Next Generation), a personal user can add a new own cipher algorithm, which makes an own coded message (according information, for example, from http://technet.microsoft.com/en-us/library/cc730763(v=ws.10).aspx).
But CNG SDK has not commented whether we can also add new cipher suites in SSL.
Is it possible, IE (Internet Explorer) could use new algorithms for a
security connection through 'https'? What methods are possible to it
in CNG? I need assistance to add new chiper suites in ssl(tls), making a new
provider for ssl(tls) and so on.
Thanks for you help.
","","442","<ssl><cng>","1","","0","2014-05-07 08:27:26","","0","","","","","2014-05-07 08:27:26",""
"17987520","Windows Phone ANID to ANID2 conversion on C#?","Windows Phone 7 had a anonymous user ID property called ANID. Windows Phone 8 has replaced that with ANID2. The difference is that ANID2 is dependent on the app's publisher ID.
It's possible to convert ANID to ANID2 as the following code sample on MSDN shows. Only things you need are the original WP7 ANID and the publisher ID (guid). The problem is that the example is in C++. I've been trying to port it to C# but with no success. 
The algorithm itself is quite easy:
var data = HMAC(ANID, publisherId) // Uses SHA-256
var result = ToBase64(data)

The problem is that I'm not able to get the results match. I've made sure that the C++ works correctly by creating two apps (WP7 and WP8), running them on same devices and then converting the ANID from WP7 app using the publisher GUID. On C++ the converted ANID2 and the ANID2 from the device match. On C# the converted ANID2 is something else.
The C# code is simple:
        var anidBytes = System.Text.Encoding.UTF8.GetBytes(this.anidBox.Text);
        var publisherGuid = Guid.Parse(this.publisherBox.Text.ToUpper());

        var macObject = new HMACSHA256(anidBytes);
        var hashed = macObject.ComputeHash(publisherGuid.ToByteArray());

        var result = Convert.ToBase64String(hashed);

The C++ version uses something called CNG (Cryptography API: Next Generation). Here's some code from it:
BCryptOpenAlgorithmProvider(&Algorithm, BCRYPT_SHA256_ALGORITHM, NULL, BCRYPT_ALG_HANDLE_HMAC_FLAG);
BCryptGetProperty(Algorithm,BCRYPT_OBJECT_LENGTH,reinterpret_cast<BYTE*>(&HashObjectLength),PropertyLength,&PropertyLength,0);
BCryptCreateHash(Algorithm, &Hash, HashObject, HashObjectLength, pAnidId, dwAnidLength, 0);
BCryptHashData(Hash, const_cast<BYTE*>(pPublisherId), dwPublisherIdLength, 0);
BCryptFinishHash(Hash, pUniqueId, GETDEVICEUNIQUEID_V1_OUTPUT, 0);

After which the ""pUniqueId"" is converter to Base64 using some custom built function.
Any help is appreciated.
Update:
Visual Studio reports that the anidBytes (C#) and pAnidId (C++) (this is the ANID string converted to bytes) both have length of 44. This is how C# debugger reports the byte array:

And here's the C++ debugger:

I don't know C++ so I'm not sure if these two are identical. They are, but the C++ has these '\0' chars after each and I'm not sure if that's OK. I think it is, as the length in both cases is reported as 44.
Another byte array comparison is the publisherGuid (C#) vs pPublisherId (C++) (publisher id as GUID). I think they again match. C#:

C++:

If I then look at the output after the value has been crypted, I can see a difference:
On C# I get the output from this code:
        var macObject = new HMACSHA256(anidBytes);
        var hashed = macObject.ComputeHash(publisherBytes);

And the byte array looks like this:

On C++ code, if I check the pUniqueId (result of BCryptFinishHash), I see this:

The length seems to be the same in both of these cases but the outcome isn't. 
On C#, if I change the encoding type from UTF8 to Unicode, the anidBytes byte array changes to this:

So it's identical to what C++ debugger shows. Also the result changes but it still differs from C++. Here's the new C# outcome:

This is the correct result from C++:

","In C#, for your HMACSHA256 object, try setting the Key property rather than initializing it in the constructor. 
var anidBytes = System.Text.Encoding.Unicode.GetBytes(this.anidBox.Text);
var macObject = new HMACSHA256();
macObject.Key = anidBytes;

http://msdn.microsoft.com/en-us/library/9c9tf8wc.aspx says that the constructor pads the key to 64 bytes. 
(I'm not 100% sure what the property setter does but it's worth a shot).
","432","<c#><c++><windows-phone-8><cng>","2","1","3","2015-06-29 01:33:35","18020771","6","","66988","","2013-08-01 09:31:04","2013-08-01 07:18:20",""
"17987520","Windows Phone ANID to ANID2 conversion on C#?","Windows Phone 7 had a anonymous user ID property called ANID. Windows Phone 8 has replaced that with ANID2. The difference is that ANID2 is dependent on the app's publisher ID.
It's possible to convert ANID to ANID2 as the following code sample on MSDN shows. Only things you need are the original WP7 ANID and the publisher ID (guid). The problem is that the example is in C++. I've been trying to port it to C# but with no success. 
The algorithm itself is quite easy:
var data = HMAC(ANID, publisherId) // Uses SHA-256
var result = ToBase64(data)

The problem is that I'm not able to get the results match. I've made sure that the C++ works correctly by creating two apps (WP7 and WP8), running them on same devices and then converting the ANID from WP7 app using the publisher GUID. On C++ the converted ANID2 and the ANID2 from the device match. On C# the converted ANID2 is something else.
The C# code is simple:
        var anidBytes = System.Text.Encoding.UTF8.GetBytes(this.anidBox.Text);
        var publisherGuid = Guid.Parse(this.publisherBox.Text.ToUpper());

        var macObject = new HMACSHA256(anidBytes);
        var hashed = macObject.ComputeHash(publisherGuid.ToByteArray());

        var result = Convert.ToBase64String(hashed);

The C++ version uses something called CNG (Cryptography API: Next Generation). Here's some code from it:
BCryptOpenAlgorithmProvider(&Algorithm, BCRYPT_SHA256_ALGORITHM, NULL, BCRYPT_ALG_HANDLE_HMAC_FLAG);
BCryptGetProperty(Algorithm,BCRYPT_OBJECT_LENGTH,reinterpret_cast<BYTE*>(&HashObjectLength),PropertyLength,&PropertyLength,0);
BCryptCreateHash(Algorithm, &Hash, HashObject, HashObjectLength, pAnidId, dwAnidLength, 0);
BCryptHashData(Hash, const_cast<BYTE*>(pPublisherId), dwPublisherIdLength, 0);
BCryptFinishHash(Hash, pUniqueId, GETDEVICEUNIQUEID_V1_OUTPUT, 0);

After which the ""pUniqueId"" is converter to Base64 using some custom built function.
Any help is appreciated.
Update:
Visual Studio reports that the anidBytes (C#) and pAnidId (C++) (this is the ANID string converted to bytes) both have length of 44. This is how C# debugger reports the byte array:

And here's the C++ debugger:

I don't know C++ so I'm not sure if these two are identical. They are, but the C++ has these '\0' chars after each and I'm not sure if that's OK. I think it is, as the length in both cases is reported as 44.
Another byte array comparison is the publisherGuid (C#) vs pPublisherId (C++) (publisher id as GUID). I think they again match. C#:

C++:

If I then look at the output after the value has been crypted, I can see a difference:
On C# I get the output from this code:
        var macObject = new HMACSHA256(anidBytes);
        var hashed = macObject.ComputeHash(publisherBytes);

And the byte array looks like this:

On C++ code, if I check the pUniqueId (result of BCryptFinishHash), I see this:

The length seems to be the same in both of these cases but the outcome isn't. 
On C#, if I change the encoding type from UTF8 to Unicode, the anidBytes byte array changes to this:

So it's identical to what C++ debugger shows. Also the result changes but it still differs from C++. Here's the new C# outcome:

This is the correct result from C++:

","Make sure you cut the ANID byte array into half before you use it as the secret key for the HMACSHA256. The conversion algorithm only needs the first 44 bytes and not the entire 88. Don't ask me why, but AFAIK, it's a bug in the C++ code they use when converting ANID to ANID2 if you look at the sample code at http://code.msdn.microsoft.com/wpapps/ANID-to-ANID2-Converter-cc428038 - they must have mistaken wchar for char!
","432","<c#><c++><windows-phone-8><cng>","2","1","3","2015-06-29 01:33:35","18020771","6","","66988","","2013-08-01 09:31:04","2013-08-01 07:18:20",""
"17987520","Windows Phone ANID to ANID2 conversion on C#?","Windows Phone 7 had a anonymous user ID property called ANID. Windows Phone 8 has replaced that with ANID2. The difference is that ANID2 is dependent on the app's publisher ID.
It's possible to convert ANID to ANID2 as the following code sample on MSDN shows. Only things you need are the original WP7 ANID and the publisher ID (guid). The problem is that the example is in C++. I've been trying to port it to C# but with no success. 
The algorithm itself is quite easy:
var data = HMAC(ANID, publisherId) // Uses SHA-256
var result = ToBase64(data)

The problem is that I'm not able to get the results match. I've made sure that the C++ works correctly by creating two apps (WP7 and WP8), running them on same devices and then converting the ANID from WP7 app using the publisher GUID. On C++ the converted ANID2 and the ANID2 from the device match. On C# the converted ANID2 is something else.
The C# code is simple:
        var anidBytes = System.Text.Encoding.UTF8.GetBytes(this.anidBox.Text);
        var publisherGuid = Guid.Parse(this.publisherBox.Text.ToUpper());

        var macObject = new HMACSHA256(anidBytes);
        var hashed = macObject.ComputeHash(publisherGuid.ToByteArray());

        var result = Convert.ToBase64String(hashed);

The C++ version uses something called CNG (Cryptography API: Next Generation). Here's some code from it:
BCryptOpenAlgorithmProvider(&Algorithm, BCRYPT_SHA256_ALGORITHM, NULL, BCRYPT_ALG_HANDLE_HMAC_FLAG);
BCryptGetProperty(Algorithm,BCRYPT_OBJECT_LENGTH,reinterpret_cast<BYTE*>(&HashObjectLength),PropertyLength,&PropertyLength,0);
BCryptCreateHash(Algorithm, &Hash, HashObject, HashObjectLength, pAnidId, dwAnidLength, 0);
BCryptHashData(Hash, const_cast<BYTE*>(pPublisherId), dwPublisherIdLength, 0);
BCryptFinishHash(Hash, pUniqueId, GETDEVICEUNIQUEID_V1_OUTPUT, 0);

After which the ""pUniqueId"" is converter to Base64 using some custom built function.
Any help is appreciated.
Update:
Visual Studio reports that the anidBytes (C#) and pAnidId (C++) (this is the ANID string converted to bytes) both have length of 44. This is how C# debugger reports the byte array:

And here's the C++ debugger:

I don't know C++ so I'm not sure if these two are identical. They are, but the C++ has these '\0' chars after each and I'm not sure if that's OK. I think it is, as the length in both cases is reported as 44.
Another byte array comparison is the publisherGuid (C#) vs pPublisherId (C++) (publisher id as GUID). I think they again match. C#:

C++:

If I then look at the output after the value has been crypted, I can see a difference:
On C# I get the output from this code:
        var macObject = new HMACSHA256(anidBytes);
        var hashed = macObject.ComputeHash(publisherBytes);

And the byte array looks like this:

On C++ code, if I check the pUniqueId (result of BCryptFinishHash), I see this:

The length seems to be the same in both of these cases but the outcome isn't. 
On C#, if I change the encoding type from UTF8 to Unicode, the anidBytes byte array changes to this:

So it's identical to what C++ debugger shows. Also the result changes but it still differs from C++. Here's the new C# outcome:

This is the correct result from C++:

","public string Convert(string winPhone7Anid)
{
    var anidAsBytes = System.Text.Encoding.Unicode.GetBytes(""A="" + winPhone7Anid + ""&E=f48&W=3"");
    var macObject = new HMACSHA256(anidAsBytes.Take(anidAsBytes.Length / 2).ToArray());
    var hashedBytes = macObject.ComputeHash(new Guid(""XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"").ToByteArray());
    return System.Convert.ToBase64String(hashedBytes);
}

","432","<c#><c++><windows-phone-8><cng>","2","0","3","2015-06-29 01:33:35","18020771","6","","66988","","2013-08-01 09:31:04","2013-08-01 07:18:20",""
"36714111","What is an analog CryptSetProvParam(PP_SIGNATURE_PIN) analog in CryptoAPI NG?","I'm writing an application for smartcards. I know how my application can obtain the PIN using a method CryptSetProvParam, but I don't know how to do the same thing when I'm using CryptoAPI NG. I want to prevent the PIN request UI window pop up.
","Setting CspParameters.KeyPassword is equivalent to calling CryptSetProvParam with PP_KEYEXCHANGE_PIN (or PP_SIGNATURE_PIN). This flag is not supported by the default Microsoft crypto-service-provider (it is intended for use with smartcard-based CSPs).
","410","<smartcard><cryptoapi><cng>","1","1","1","2017-04-21 00:09:37","43531875","0","","","","","2016-04-19 09:22:58",""
"45426767",".NET - Porting RSACryptoServiceProvider to CNG for signing data","I'm trying to port an RSA signing function written in C#, from the (relatively easy to use) RSACryptoServiceProvider.SignHash method, to the CNG API, in order to use a specific cryptographic service provider.
This is the original (before porting) function:
    private static byte[] SignDigest(RSAParameters keyMaterial, byte[] digest, string hashAlgo)
    {
        using (var cryptoProvider = new RSACryptoServiceProvider())
        {
            cryptoProvider.ImportParameters( keyMaterial );
            // hashAlgo can only be one of ""SHA1"", ""SHA256"", ""SHA384"" and ""SHA512"".
            return cryptoProvider.SignHash( digest, CryptoConfig.MapNameToOID( hashAlgo ) );
        }
    }

Quite simple, don't you think? When porting to CNG, this is the best I could do so far:
    private static byte[] SignDigest(RSAParameters keyMaterial, byte[] digest, string hashAlgo)
    {
        var size = 6 * 4 + keyMaterial.Exponent.Length + keyMaterial.Modulus.Length + keyMaterial.P.Length + keyMaterial.Q.Length;
        var keyBlob = new byte[size];            
        using (var writer = new BinaryWriter(new MemoryStream(keyBlob)))
        {
            // This is BCRYPT_RSAKEY_BLOB structure (https://msdn.microsoft.com/en-us/library/windows/desktop/aa375531(v=vs.85).aspx).
            writer.Write(0x32415352); // BCRYPT_RSAPRIVATE_MAGIC
            writer.Write(keyMaterial.Modulus.Length * 8); // BitLength
            writer.Write(keyMaterial.Exponent.Length); // cbPublicExp
            writer.Write(keyMaterial.Modulus.Length); // cbModulus
            writer.Write(keyMaterial.P.Length); // cbPrime1
            writer.Write(keyMaterial.Q.Length); // cbPrime2
            writer.Write(keyMaterial.Exponent); // PublicExponent
            writer.Write(keyMaterial.Modulus); // Modulus
            writer.Write(keyMaterial.P); // Prime1
            writer.Write(keyMaterial.Q); // Prime2
        }

        // Function NCryptImportKey uses ""RSAPRIVATEBLOB"" to indicate a BCRYPT_RSAPRIVATE_BLOB structure.
        // See https://msdn.microsoft.com/en-us/library/windows/desktop/aa376276(v=vs.85).aspx.

        var key = CngKey.Import( keyBlob, new CngKeyBlobFormat( ""RSAPRIVATEBLOB"" ), _myProvider );

        IntPtr pPaddingInfo = question; // What do I specify here?
        byte[] pbHashValue = question; // Should I calculate hash from digest? How can I make sure it will be valid for verification?
        byte[] pbSignature = question; // Is the signature size related to hash size? Or RSA key size?
        int dwFlags = question; // Should I use BCRYPT_PAD_PKCS1 here or simply zero?

        int pcbResult;
        int result;

        using ( var hKey = key.Handle )
        {
            result = NCryptSignHash( hKey, pPaddingInfo, pbHashValue, pbHashValue.Length, pbSignature, pbSignature.Length, out pcbResult, dwFlags );
        }

        if (result != 0)
            throw new Exception();

        return TrimArray(pbSignature, pcbResult);
    }

    // As described on https://msdn.microsoft.com/en-us/library/windows/desktop/aa376295(v=vs.85).aspx.
    [DllImport(""ncrypt.dll"")]
    internal static extern NCryptErrorCode NCryptSignHash(
        SafeNCryptKeyHandle hKey, 
        IntPtr pPaddingInfo, 
        [MarshalAs(UnmanagedType.LPArray)] byte[] pbHashValue, 
        int cbHashValue, 
        [MarshalAs(UnmanagedType.LPArray)] byte[] pbSignature, 
        int cbSignature, 
        out int pcbResult, 
        int dwFlags);

I can successfully import the key to CNG, but I don't know how to perform the signing operation. Any help is welcome...
","If you're on .NET 4.6 or higher, then after var key = CngKey.Import(...)
using (RSACng rsa = new RSACng(key))
{
    // Consider changing your signature to take a HashAlgorithmName instead of string.
    // I'm assuming you want RSA-SSA PKCS#1 v1.5 instead of RSA-SSA-PSS.
    return rsa.SignHash(digest, new HashAlgorithmName(hashAlgo), RSASignaturePadding.Pkcs1);
}

Or you can just check out https://referencesource.microsoft.com/#System.Core/System/Security/Cryptography/RsaCng.cs,672daeef0962f4ad if you want to see the P/Invokes (assuming that you're not doing anything that violates the license of referencesource.microsoft.com).
","404","<.net><rsa><digital-signature><public-key-encryption><cng>","0","1","1","2017-08-03 14:55:03","45487814","0","","","","","2017-07-31 23:31:12",""
"54222565","Verify a signature file (PKCS7) with WinCrypt or CNG","I need to verify a signed JAR file using Windows crypto API methods. I have only a basic understanding of encryption and signing matters. I'm also new to those crypto APIs (WinCrypt, Bcrypt, Ncrypt). Verifying the file hashes wasn't a problem, but the signature part is blocking me.
Thanks to OpenSSL, the PKCS7 RFC (https://tools.ietf.org/html/rfc2315) and various other sources I was able to figure out the actual file contents of META-INF/LOCALSIG.DSA contained in the JAR. But after two weeks of digging, trial and error I'm still stuck and don't know what else to try.
OpenSSL has the nice command openssl smime -verify -inform der -in LOCALSIG.DSA -content LOCALSIG.SF -noverify, which does exactly what I want to do. Unfortunately, I couldn't find such a high-level command in the Windows APIs.
I've tried to use the VerifySignature family of functions from all three APIs, but I need to provide the public key for those, and I had no luck using any of the ImportKey functions. So I tried to manually dissect the ASN1 format using CryptDecodeObjectEx, in order to pass the individual parts as BLOBs to the API functions. While I had some success with this, I'm stuck again because I can't figure out how to parse sets. I don't want to write my own ASN1 parser from scratch...
So, how do I use a PKCS7 signature file with the Windows crypto APIs?
I guess it might be easier using OpenSSL, but then I would have to convince my employer to add OpenSSL to our codebase just for this one purpose...

UPDATE: The LOCALSIG.DSA file contains the signers certificate and the signed hash of the LOCALSIG.SF file. This can be verified using openssl pkcs7 -inform der -print_certs -text -in LOCALSIG.DSA or openssl cms -cmsout -inform DER -print -in LOCALSIG.DSA.
The certificate is self-signed by our company and in the certificate store. I might need to provide the whole chain of trust. That's why I added the -noverify option to openssl smime -verify.
In fact, there are two scenarios with different certificates (internal and external releases), one using DSA (sig file contains one cert), the other using RSA (sig file contains three certs). That means I can't hardcode which certificate or method to use. I need to extract that information from the provided file. How do I do that?
","I am not sure whether we have all the information needed so I do not have any definitive answers. However, let's see if we can make progress towards a solution.
You asked:

How do I know which certificate to load and from where?

You as the verifier need to have that trusted certificate in your possession in some form. With Windows, it would be good if that certificate were installed in your certificate store. This is what I assumed in my answer. If you do not know where the certificate is, then you will have to figure that out first, otherwise you will not be able to properly verify the signature.Somehow, the certificate needs to be provided to the verifier (you) by the signer, via a trusted channel.
You also wrote:

OpenSSL has the nice command openssl smime -verify -inform der -in
  LOCALSIG.DSA -content LOCALSIG.SF -noverify, which does exactly what I
  want to do.

Are you sure this does exactly what you want to do? Since you are passing in the -noverify flag, all that this command does, is verifying that LOCALSIG.DSA contains a correct signature of the contents LOCALSIG.SF. However, it does not verify that this signature was created by an identity that you trust. Anybody with a valid certificate and key pair could have created that signature.
In order to verify the signature, including the signer's identity, with a stock-openssl version, you need to have the entire certificate chain available to you, in a format that openssl understands (PEM or DER), up to the self-signed root certificate. Then you can check it with the slightly different command
openssl smime -verify -inform der -in LOCALSIG.DSA -content LOCALSIG.SF -CAfile trusted-cert.pem


Your question is updated to indicate that the signing certificate is self-signed and in the certificate store. There are still multiple possible routes, but I will assume at this point that you know what the subject name is of the signer that you expect to have generated this signature. (If not, then please indicate what you do expect.) With that information, you can use the following steps to verify your signature:
First use CertEnumCertificatesInStore() to look up the certificate in the certificate store. For example usage, see Example C Program: Listing the Certificates in a Store.
When you have a handle to that certificate, use CryptImportPublicKeyInfoEx2() to get a handle to the required public key.
That handle, which is of type BCRYPT_KEY_HANDLE, you can use with BCryptVerifySignature() to do the verification.
","401","<sign><asn.1><cng><wincrypt>","1","1","2","2019-09-17 21:09:18","54249813","0","","608639","","2019-09-17 21:09:18","2019-01-16 17:42:13",""
"54222565","Verify a signature file (PKCS7) with WinCrypt or CNG","I need to verify a signed JAR file using Windows crypto API methods. I have only a basic understanding of encryption and signing matters. I'm also new to those crypto APIs (WinCrypt, Bcrypt, Ncrypt). Verifying the file hashes wasn't a problem, but the signature part is blocking me.
Thanks to OpenSSL, the PKCS7 RFC (https://tools.ietf.org/html/rfc2315) and various other sources I was able to figure out the actual file contents of META-INF/LOCALSIG.DSA contained in the JAR. But after two weeks of digging, trial and error I'm still stuck and don't know what else to try.
OpenSSL has the nice command openssl smime -verify -inform der -in LOCALSIG.DSA -content LOCALSIG.SF -noverify, which does exactly what I want to do. Unfortunately, I couldn't find such a high-level command in the Windows APIs.
I've tried to use the VerifySignature family of functions from all three APIs, but I need to provide the public key for those, and I had no luck using any of the ImportKey functions. So I tried to manually dissect the ASN1 format using CryptDecodeObjectEx, in order to pass the individual parts as BLOBs to the API functions. While I had some success with this, I'm stuck again because I can't figure out how to parse sets. I don't want to write my own ASN1 parser from scratch...
So, how do I use a PKCS7 signature file with the Windows crypto APIs?
I guess it might be easier using OpenSSL, but then I would have to convince my employer to add OpenSSL to our codebase just for this one purpose...

UPDATE: The LOCALSIG.DSA file contains the signers certificate and the signed hash of the LOCALSIG.SF file. This can be verified using openssl pkcs7 -inform der -print_certs -text -in LOCALSIG.DSA or openssl cms -cmsout -inform DER -print -in LOCALSIG.DSA.
The certificate is self-signed by our company and in the certificate store. I might need to provide the whole chain of trust. That's why I added the -noverify option to openssl smime -verify.
In fact, there are two scenarios with different certificates (internal and external releases), one using DSA (sig file contains one cert), the other using RSA (sig file contains three certs). That means I can't hardcode which certificate or method to use. I need to extract that information from the provided file. How do I do that?
","As i understand from your question you need to verify PKC7 with detached signature. For this purpose you can use function CryptVerifyDetachedMessageSignature.  
Sample code:  
CRYPT_VERIFY_MESSAGE_PARA vparam = { 0 };
    vparam.cbSize = sizeof(CRYPT_VERIFY_MESSAGE_PARA);
    vparam.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    vparam.pfnGetSignerCertificate = nullptr;
    vparam.pvGetArg = nullptr;


    /* read your files somehow */
    std::vector<char> sig;
    if (!ReadFile(""LOCALSIG.DSA"", &sig))
    {
        std::cout << ""Failed to read file"" << std::endl;
        return;
    }

    std::vector<char> mes;
    if (!ReadFile(""LOCALSIG.SF"", &mes))
    {
        std::cout << ""Failed to read file"" << std::endl;
        return;
    }

    /* CryptVerifyDetachedMessageSignature requires array of messages to verify */
    const BYTE* marray[] = {
        reinterpret_cast<BYTE*>(mes.data())
    };
    DWORD marray_len[] = {
        static_cast<DWORD>(mes.size())
    };

    if (!CryptVerifyDetachedMessageSignature(vparam,
        0, 
        reinterpret_cast<BYTE*>(sig.data()),
        static_cast<DWORD>(sig.size()), 
        1, /* number of messages in marray */
        marray,
        marray_len,
        nullptr))
    {
        std::cout << ""Failed to verify signature, error: "" << GetLastError() << std::endl;
    }
    else
    {
        std::cout << ""Verify success, signature valid"" << std::endl;
    }

UPDATE
To verify certificate chain you need to use CertGetCertificateChain 
Sample code:  
PCCERT_CHAIN_CONTEXT pChain = nullptr;
CERT_CHAIN_PARA chainPara = {0};
HCERTSTORE hStore = nullptr;
/* you sig file */
DATA_BLOB db = {
    static_cast<DWORD>(sig.size()), reinterpret_cast<BYTE *>(sig.data())};

/* you can open your sig file as certificate store */
hStore = CertOpenStore(CERT_STORE_PROV_PKCS7, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 0, reinterpret_cast<BYTE *>(&db));
if (!hStore)
{
    goto Exit;
}

chainPara.cbSize = sizeof(CERT_CHAIN_PARA);
chainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
chainPara.RequestedUsage.Usage.cUsageIdentifier = 0;

if (!CertGetCertificateChain(NULL,  /* use default chain engine */
                             pCert, /*  pCert - pointer to signer cert structure (the parameter that was obtained in the previous step) */
                             NULL,
                             hStore, /* point to additional store where need to search for certificates to build chain */
                             &chainPara,
                             CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                             NULL,
                             &pChain))
{
    std::cout << ""failed to build chain: "" << GetLastError();
    goto Exit;
}

if (pChain->TrustStatus.dwErrorStatus == CERT_TRUST_NO_ERROR)
{
    std::cout << ""certificate valid"";
    goto Exit;
}
if (pChain->TrustStatus.dwErrorStatus & CERT_TRUST_REVOCATION_STATUS_UNKNOWN)
{
    std::cout << ""certificate revocation status unknown"";
}
/* you need to place root certificate to the Trusted Root Store */
if (pChain->TrustStatus.dwErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT)
{
    std::cout << ""untrusted CA"";
}
/* and so on */

Exit : 
if (pCert)
{
    CertFreeCertificateContext(pCert);
}
if (pChain)
{
    CertFreeCertificateChain(pChain);
}
if (hStore)
{
    CertCloseStore(hStore, 0);
}

","401","<sign><asn.1><cng><wincrypt>","1","3","2","2019-09-17 21:09:18","54249813","0","","608639","","2019-09-17 21:09:18","2019-01-16 17:42:13",""
"18106135","Debugging Smart Card Minidriver","I'm currently working on a CNG Smart Card minidriver.
To test some functionality I'd like to use makecert to import a Private Key into the Smart Card.
Unfortunately for every change I make I have to copy my minidriver.dll to the system32 directory. But once I called makecert for the first time, the minidriver.dll will be in use, and I can't overwrite it unless I reboot my PC (which honestly takes too much time..)
Is there way to overwrite it without rebooting? 
My second attempt would be to debug it using Visual Studio and starting makecert from Visual Studio. But I will be prompted with: The breakpoint will not currently be hit. No symbols have been loaded for this document.
Is there a way to debug the minidriver.dll within Visual Studio using makecert.exe?
Thanks for your help.
","","396","<debugging><visual-studio-2012><smartcard><cng><mscapi>","3","","0","2013-08-07 14:29:37","","0","","","","","2013-08-07 14:29:37",""
"44305299","Export CngKey in PKCS8 with encryption c#","How can I export CngKey to PKCS#8 with encryption?
static void Main(string[] args)
    {
        CngKeyCreationParameters ckcParams = new CngKeyCreationParameters()
        {
            ExportPolicy = CngExportPolicies.AllowExport,
            KeyCreationOptions = CngKeyCreationOptions.None,
            KeyUsage = CngKeyUsages.AllUsages,                
        };
        ckcParams.Parameters.Add(new CngProperty(""Length"", BitConverter.GetBytes(2048), CngPropertyOptions.None));

        myCngKey = CngKey.Create(CngAlgorithm.Rsa, ""theCngKey"", ckcParams);

        byte[] privatePlainTextBlob = myCngKey.Export(CngKeyBlobFormat.Pkcs8PrivateBlob);
 }

Setting the ExportPolicy to AllowPlainTextExport allows the key to be exported, but only in plain text. I would like to create a PCKS8 blob which is encrypted with a symmetric key.
Thanks
","Since CngKey.Export doesn't accept a password, you'd have to manually P/Invoke to NCryptExportKey, providing a NCRYPTBUFFER_PKCS_SECRET value (Unicode/UCS-2 encoded password with explicit null terminator).
http://source.dot.net/#System.Security.Cryptography.Cng/Common/System/Security/Cryptography/ECCng.ImportExport.cs,8b172741466df7a1 can be used as an example of building the parameter list.  It's not fun.
","388","<c#><encryption><encryption-asymmetric><cng>","1","1","1","2017-06-02 03:15:33","","0","","","","","2017-06-01 10:38:23",""
"46185428","BCryptImportKeyPair returns STATUS_INVALID_PARAMETER when i try to import public key","I followed this example. I am trying to add the public key which i got from the server into the key Pair and I am getting STATUS_INVALID_PARAMETER. 
    BCRYPT_DH_KEY_BLOB header;
    header.dwMagic = BCRYPT_DH_PUBLIC_MAGIC;
    header.cbKey = (ULONG)(pub_key.size());
    cout << ""header contents "" << header.dwMagic << "" : "" << header.cbKey << endl;
    memcpy(&pubKeyBlobFromServer[0], &header, sizeof(BCRYPT_DH_KEY_BLOB));
    // copy Public key
    cout << ""size of pub_key "" << pub_key.size() << endl;
    cout << ""size of pubKeyBlobFromServer before :"" << pubKeyBlobFromServer.size() << endl;
    cout << ""size of BCRYPT_DH_KEY_BLOB "" << sizeof(BCRYPT_DH_KEY_BLOB) << endl;
    pubKeyBlobFromServer.insert(pubKeyBlobFromServer.end(), pub_key.begin(), pub_key.end());
    cout << ""size of pubKeyBlobFromServer after :"" << pubKeyBlobFromServer.size() << endl;
    Status = BCryptImportKeyPair(
                                        ExchAlgHandleB,             // Alg handle
                                        nullptr,                       // Parameter not used
                                        BCRYPT_DH_PUBLIC_BLOB,      // Blob type (Null terminated unicode string)
                                        &PubKeyHandleB,             // Key handle that will be recieved
                                        const_cast<PUCHAR>(pubKeyBlobFromServer.data()),            // Buffer than points to the key blob
                                        (ULONG)pubKeyBlobFromServer.size(),     // Buffer length in bytes
                                        0);                         // Flags

I am getting the following output.
header contents 1112557636 : 128
size of pub_key 128
size of pubKeyBlobFromServer before :8
size of BCRYPT_DH_KEY_BLOB 8
size of pubKeyBlobFromServer after :136

I tried printing the bytes of pubKeyBlobFromServer. the public key starts from 8th byte. first 8 is reserved for BCRYPT_DH_KEY_BLOB . I am not sure what is wrong. Please suggest the place where i am making mistake. If not please suggest a sample which imports public key from string. Thanks in Advance.
","Microsoft's sample code takes the easy way out; because the same API exported the key, it is already in the right format.
In order to construct a valid key blob yourself, you need to look up the documentation for the BCRYPT_DH_KEY_BLOB structure:

A Diffie-Hellman public key BLOB (BCRYPT_DH_PUBLIC_BLOB) has the following format in contiguous memory. The Modulus, Generator, and Public numbers are in big-endian format.

BCRYPT_DH_KEY_BLOB
Modulus[cbKey] // Big-endian.
Generator[cbKey] // Big-endian.
Public[cbKey] // Big-endian.

Looks like your code was only including one of the three components.
","365","<c++11><winapi><cryptoapi><cng><wincrypt>","0","1","1","2017-09-13 21:33:46","46207161","2","1","1294545","","2017-09-12 22:50:06","2017-09-12 21:15:45",""
"55236230","Export private key (PKCS#8) of CNG RSA certificate with oldschool .NET","I have a PKCS #12 (PFX) file that is a certificate with CNG RSA key and want to export the private key.
MIIJ4gIBAzCCCZ4GCSqGSIb3DQEHAaCCCY8EggmLMIIJhzCCBgAGCSqGSIb3DQEHAaCCBfEEggXtMII
F6TCCBeUGCyqGSIb3DQEMCgECoIIE/CCBPowHAYKKoZIhvcNAQwBAzAOBAjBalb3hEiYXQICB9AEggT
Y80gGrPwpOpwdA1V9f55nVex6JzumPGb000ePt4jilZ3ktcY9SaE9krxBycNzRVFRVosJOZfHby8u2z
8PDj0bCgNUOE1yU5Jzf5yDyq1bRyLSi4zpwPaN5zj3CsJ3zqhvzzSmTRW2S4zeT1CgjQnsPkRHOMluX
0b+qNo+oY2v1fqRXwh5S2GX7joFHWOp5Xr425LiNLCZVxfnO64znKhzZLPJoG0jb8rfZkVC9p3zKt/J
VJJodqV+9jmnBcdGkQTN1jY7GRpi3aykLHGyaxDmp+0dSKZ5yMognY2tabJxAVQBnesCfwhtmZlxPx2
KBN2GHyfGV+4377t6crvPq4chVMEpX7regGO3uLl0ks4PhZwr0peCGfOTueRC+HWt6zwnCl6Iw8gTu/
99EjJgMp7OK98aHpBfWeUeFwHVnxcYSd/OElEL7wqyXHU3MeeTxYmAojRWN3SrlcL3LPtT9THxQO5Yq
vLPWhk2gSiqz8AommoJOv5roeB+tnR7LLFrJvYicPcRi0rjsCk0v8a/c6SeMvfdao2xrATFT6yEbHB9
xAoHGnWLTi4KCAP+sWCU+yr6/0iZCB76XFJsHUP/pt6rPQsBDfHmz/mC8DqYlmQZ5Xibv2jYpXu2DyM
LTgGzM3cbjdIFWnjJtPYpvH55q++Lws3rInQL/mR9M7oCwtFVA0s8IyDFhQbd1+r4VuJ3f9nRjaBfNJ
rKQlUzfvn/WGOEZe/+jRue/JfYSLUo59JwWe+8TFDxjO+5DnXXbCtBQsEZcPVtlUCCD6KopoWo4zTBO
l6lvguqTvFd8tvJPSR2bGvckSHw4JfF2ITVqMWzMqye7Dfck8J6CjnqDcYAOPfZ8btQMvKNyHS+Sex2
Kf7LfOsi5Fb1qE2RjMGO6YyzgsU80clS0A4U3okhXBbRmuZLDgXKOM08EejQPJycDPfX0irtIu06zRO
PgbCT8Zmx6Ch3dEx+NmuV86bA/WDNvl+ARIFD9ZQjIYsCjYrqp0LSfVSaZ2MSFU/avtaUYAEwri/Kkc
clmxD9S3H1SoY7H4Wrh3yXT/kR4LF+O2BkzJD4nMyR1NQ6t3fFkz4boXTWZv8k0QXkVxffnf1w80BAv
1VGf7jQNK2aSBI7kVoVYqbf31LVxoQ8sKmUVP3/v2vXc8bdZR5/hoYsIIAddCaYmmRGY31SGef/0G7k
z1XK/0QForcaug51yJOWGGrcOEBT1vfG2k2DTX1NVE0y+XL8pAL2rq2nmDUL2h7Al3LuonQMwyjrEQC
z08Tw/J8AMZVwj9QuhgCrsFeFfFD7n6xete8sQdGEqb2vyC/1IQgPAWWU3gu5LCd2BL5HDSSH3XQVHB
MbDYBWJeAAmhNSQZlGNqMaCcFhR0Q3Z5YwAs1a1fFE0isQf1xeqjxDzggH9d5RmXdH0MWd/BcBKH40y
EDnX89OEi/AlqyAFKzbC17dYEJWbOk9eny5YMohMVATAMLRr3KtzSeJZcb4zUfa/ayOmABjixQeODYx
eKksQW5+lkRipTqn9Hr5cIFTVkgB6irQHxecLShDKILiH/jJGgLH3G6X2q8y5uJuAb6WGN2aq4MyMsY
pHFcxs554/ueWcUHjQEfZ95ppJJmbea7iPo8rV2k1Ahox7ghRBik4mMuTfJGcx8sf6iTRslElkTGB0z
ATBgkqhkiG9w0BCRUxBgQEAQAAADBdBgkqhkiG9w0BCRQxUB5OAHQAcAAtADcAMgBkAGMANABlADMAN
gAtAGMAMwBjAGUALQA0ADkAMwBiAC0AOAA2ADYAMgAtADAAOQBjADQAMgBkAGQANABlAGMAYQBlMF0G
CSsGAQQBgjcRATFQHk4ATQBpAGMAcgBvAHMAbwBmAHQAIABTAG8AZgB0AHcAYQByAGUAIABLAGUAeQA
gAFMAdABvAHIAYQBnAGUAIABQAHIAbwB2AGkAZABlAHIwggN/BgkqhkiG9w0BBwagggNwMIIDbAIBAD
CCA2UGCSqGSIb3DQEHATAcBgoqhkiG9w0BDAEDMA4ECPbFkV7hGKnVAgIH0ICCAzis/V3JhKnazUT5y
ENekVJQ3HMH+CT1GTCgCMI2tZ41zCyLnEQ0qCxoxVmeGrx5AD7bIFA3bbedwjvyAASP74Co0A9uTPTc
fHet1aVwTE8cMk+7kzQl6yM3qvVjqb9zVyrvnBugLha02iHfSn+ssj08Rar0oji0gUIUuvDYsB2jkzB
Mny+KJo7JtXIAeK5L82N7R3+Q4LSZzrgC5GO/B4cQolNfYjoiopcTebAKC4Jm5F9pyo1pgnTGQD+gy1
jo8+NJqT0BVB2He7Fyh07PJuHjtT6Un93SbQVmZ+TuJf39yvvH4LsGv3XQU3u8w25Jtvt7FO5GTOaQU
QcntWFm/xw67Z0mShBGtTv8132Uu6lg4jiqEvNKEomzjk4wxqtdnTbuOtMvN7cnPMXBFMHRyaIXr8wM
X9P9qJhcos4Zbx6KNc7eQWr9YJv/nyeGQK4ffuv4hMIYZJxV/WPkHbthDx7LYWDouXjolXQDXbpq2L0
9ro7N7T0KgP19SqNqxcUTdYbF5LxQFRe7cZP1xBeiXiSbk4W1YNXl6syz5Dm4UBS6rVz1qtwPjkc636
CBr0HdTMbfst3BDq2J1DP13cMFPTBZ4RYYmoKfG67e7n2DMTI035dfeHJD/2zSloaG32tfJK6mrcbdX
86+01wj/8meQI3gY/OiL9Zcz2JnvBvsJoTuarV0sJUL7oAGZP3m5QvTRenR07Qj/aZ0Oe6nDU8lsV8l
Ss5XpyGIm0YM2Sr3Z8/SVCkuXeu03WNEkRSaZhpmeSg4winf7unx2019k2KhQj0ic+5BQk0LhcTsA8J
+PhnuB/jh7qBrr8hu9rnvwGEHs9FAnGot9lUtBeNSDGw94mKPQnf4Ff+TXacpKfCMeUOVuwcIxZN4u4
ueKwhOOOY9eCbZeYk2SMu8B6xadp2NV2j8ALPBpDddL4sHx5kXeaMJtRfeki8+RUlY7oudo4vaf6N26
lw6YjwVvikvLQLLF20e4fPoAs5kcxthKUslZ+IMs1jRZijPbBnqzHCkIbY37xXTiKbB5Et43voqI4bR
3Rj2fQIEx0So1hhsjpJnseoM7vdvT290e9UwvqXSxHA/2iDRGD0ZgYL0jDA7MB8wBwYFKw4DAhoEFEw
MfAVl0oh+KBfFBh+2O+zNA+qRBBTacVg8LCnjGHYUuC+PXDW7UOVSNgICB9A=

The file is a sample for reproduction and the password is: 1234
I already tried to export the RsaParameters as well as exporting the private key from the CngKey with no success - operation not supported.
The issue is the missing CngExportPolicies.AllowPlaintextExport flag. I also had no success in setting the flag with native NCrypt calls as the key is in a finalized state.
There was a hint on the process (export, import & set flag & export) in another questions comment (Cannot export RSA private key parameters, the requested operation is not supported) that also points to a few lines of .NET core code.
I tried to port the code to oldschool C# .NET (without Span<T> for instance) but get a invalid argument on the following call:
    internal static unsafe bool ExportPkcs8KeyBlob(
        SafeNCryptKeyHandle keyHandle,
        string password,
        int kdfCount,
        out int bytesWritten,
        out byte[] allocated)
    {
      using (var stringHandle = new SafeUnicodeStringHandle(password))
      {
        var pbrParamsPtr =
          Marshal.AllocHGlobal(Marshal.SizeOf(typeof(NativeMethods.NCrypt.PbeParams)));
        var pbeParams = new NativeMethods.NCrypt.PbeParams();
        fixed (byte* oidPtr = s_pkcs12TripleDesOidBytes)
        {

          var salt = new byte[8];
          RandomNumberGenerator.GetBytes(salt);
          pbeParams.rgbSalt = salt;
          pbeParams.Params.cbSalt = pbeParams.rgbSalt.Length;
          pbeParams.Params.iIterations = kdfCount;

          var buffers = stackalloc NativeMethods.NCrypt.NCryptBuffer[3];
          buffers[0] = new NativeMethods.NCrypt.NCryptBuffer
          {
            BufferType = NativeMethods.NCrypt.BufferType.PkcsSecret,
            cbBuffer = checked(2 * (password.Length + 1)),
            pvBuffer = stringHandle.DangerousGetHandle(),
          };

          if (buffers[0].pvBuffer == IntPtr.Zero)
          {
            buffers[0].cbBuffer = 0;
          }

          buffers[1] = new NativeMethods.NCrypt.NCryptBuffer
          {
            BufferType = NativeMethods.NCrypt.BufferType.PkcsAlgOid,
            cbBuffer = s_pkcs12TripleDesOidBytes.Length,
            pvBuffer = (IntPtr)oidPtr,
          };

          Marshal.StructureToPtr(pbeParams, pbrParamsPtr, true);
          buffers[2] = new NativeMethods.NCrypt.NCryptBuffer
          {
            BufferType = NativeMethods.NCrypt.BufferType.PkcsAlgParam,
            cbBuffer = Marshal.SizeOf(typeof(NativeMethods.NCrypt.PbeParams)),
            pvBuffer = pbrParamsPtr
          };

          var desc = new NativeMethods.NCrypt.NCryptBufferDesc
          {
            cBuffers = 3,
            pBuffers = (IntPtr)buffers,
            ulVersion = 0,
          };


          var pbOutput = Array.Empty<byte>();
          var errorCode = NativeMethods.NCrypt.NCryptExportKey(
              keyHandle,
              IntPtr.Zero,
              NCRYPT_PKCS8_PRIVATE_KEY_BLOB,
              ref desc,
              ref pbOutput,
              0,
              out int numBytesNeeded,
              0);

          if (errorCode != 0)
          {
            throw new Win32Exception(errorCode);
...

I created a repository for the complete code with a unit test that fails at github: https://github.com/lennybacon/CngPfxKeyExport
Any hints where I failed in the conversion from .Net Core or stuffed wrong data or pointers are welcome as documentation on the usage seems to be very rare...
","You seem to have introduced two main porting errors and one calling the native method:
1) PbeParams.
Yours:
[StructLayout(LayoutKind.Sequential)]
internal struct PbeParams
{
    internal const int RgbSaltSize = 8;

    internal CryptPkcs12PbeParams Params;
    internal byte[] rgbSalt;
}

CoreFX:
[StructLayout(LayoutKind.Sequential)]
internal unsafe struct PBE_PARAMS
{
    internal const int RgbSaltSize = 8;

    internal CRYPT_PKCS12_PBE_PARAMS Params;
    internal fixed byte rgbSalt[RgbSaltSize];
}

The layout in memory of yours is that after the CRYPT_PKCS12_PBE_PARAMS value is a pointer to more data.  The layout of the CoreFX version is that directly after CRYPT_PKCS12_PBE_PARAMS  is 8 bytes of placeholder for the salt, which is what the crypto API expects (since it doesn't take pbSalt).
Restoring the fixed byte rgbSalt[RgbSaltSize] is important.
2) NCryptExportKey's pbOutput:
Yours:
[DllImport(""ncrypt.dll"", CharSet = CharSet.Unicode)]
internal static extern int NCryptExportKey(
    SafeNCryptKeyHandle hKey,
    IntPtr hExportKey,
    string pszBlobType,
    ref NCryptBufferDesc pParameterList,
    ref byte[] pbOutput,
    int cbOutput,
    [Out] out int pcbResult,
    int dwFlags);

CoreFX:
[DllImport(Interop.Libraries.NCrypt, CharSet = CharSet.Unicode)]
internal static extern ErrorCode NCryptExportKey(
    SafeNCryptKeyHandle hKey,
    IntPtr hExportKey,
    string pszBlobType,
    ref NCryptBufferDesc pParameterList,
    ref byte pbOutput,
    int cbOutput,
    [Out] out int pcbResult,
    int dwFlags);

Notably, the CoreFX version was ref byte pbOutput and yours is ref byte[] pbOutput, making the value differ by a pointer indirection.
3) The first call to export wants C NULL, not valid pointer.

Squishing your corrected interop code into one file, dropping the comments and unused enum members (for reducing post size) and fixing it up (then simplifying the usage since you can use string (guaranteed \0 terminator) instead of ReadOnlySpan<char> (no terminator guarantee)) yields this on .NET Framework 4.7.2:
internal static class CngEncryptedExport
{
    internal const string NCRYPT_PKCS8_PRIVATE_KEY_BLOB = ""PKCS8_PRIVATEKEY"";
    private static readonly byte[] s_pkcs12TripleDesOidBytes =
        System.Text.Encoding.ASCII.GetBytes(""1.2.840.113549.1.12.1.3\0"");

    internal static void Go()
    {
        using (var cert = new X509Certificate2(s_pfx, PfxPassword, X509KeyStorageFlags.Exportable))
        using (RSA rsa = cert.GetRSAPrivateKey())
        {
            RSACng rsaCng = (RSACng)rsa;

            using (CngKey key = rsaCng.Key)
            {
                Console.WriteLine(key.ExportPolicy);

                Console.WriteLine(
                    Convert.ToBase64String(
                        ExportPkcs8KeyBlob(key.Handle, ""123"", 21)));
            }
        }
    }

    private static unsafe byte[] ExportPkcs8KeyBlob(
        SafeNCryptKeyHandle keyHandle,
        string password,
        int kdfCount)
    {
        var pbeParams = new NativeMethods.NCrypt.PbeParams();
        NativeMethods.NCrypt.PbeParams* pbeParamsPtr = &pbeParams;

        byte[] salt = new byte[NativeMethods.NCrypt.PbeParams.RgbSaltSize];

        using (RandomNumberGenerator rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(salt);
        }

        pbeParams.Params.cbSalt = salt.Length;
        Marshal.Copy(salt, 0, (IntPtr)pbeParams.rgbSalt, salt.Length);
        pbeParams.Params.iIterations = kdfCount;

        fixed (char* stringPtr = password)
        fixed (byte* oidPtr = s_pkcs12TripleDesOidBytes)
        {
            NativeMethods.NCrypt.NCryptBuffer* buffers =
                stackalloc NativeMethods.NCrypt.NCryptBuffer[3];

            buffers[0] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsSecret,
                cbBuffer = checked(2 * (password.Length + 1)),
                pvBuffer = (IntPtr)stringPtr,
            };

            if (buffers[0].pvBuffer == IntPtr.Zero)
            {
                buffers[0].cbBuffer = 0;
            }

            buffers[1] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsAlgOid,
                cbBuffer = s_pkcs12TripleDesOidBytes.Length,
                pvBuffer = (IntPtr)oidPtr,
            };

            buffers[2] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsAlgParam,
                cbBuffer = sizeof(NativeMethods.NCrypt.PbeParams),
                pvBuffer = (IntPtr)pbeParamsPtr,
            };

            var desc = new NativeMethods.NCrypt.NCryptBufferDesc
            {
                cBuffers = 3,
                pBuffers = (IntPtr)buffers,
                ulVersion = 0,
            };

            int result = NativeMethods.NCrypt.NCryptExportKey(
                keyHandle,
                IntPtr.Zero,
                NCRYPT_PKCS8_PRIVATE_KEY_BLOB,
                ref desc,
                null,
                0,
                out int bytesNeeded,
                0);

            if (result != 0)
            {
                throw new Win32Exception(result);
            }

            byte[] exported = new byte[bytesNeeded];

            result = NativeMethods.NCrypt.NCryptExportKey(
                keyHandle,
                IntPtr.Zero,
                NCRYPT_PKCS8_PRIVATE_KEY_BLOB,
                ref desc,
                exported,
                exported.Length,
                out bytesNeeded,
                0);

            if (result != 0)
            {
                throw new Win32Exception(result);
            }

            if (bytesNeeded != exported.Length)
            {
                Array.Resize(ref exported, bytesNeeded);
            }

            return exported;
        }
    }

    private static class NativeMethods
    {
        internal static class NCrypt
        {
            [DllImport(""ncrypt.dll"", CharSet = CharSet.Unicode)]
            internal static extern int NCryptExportKey(
                SafeNCryptKeyHandle hKey,
                IntPtr hExportKey,
                string pszBlobType,
                ref NCryptBufferDesc pParameterList,
                byte[] pbOutput,
                int cbOutput,
                [Out] out int pcbResult,
                int dwFlags);

            [StructLayout(LayoutKind.Sequential)]
            internal unsafe struct PbeParams
            {
                internal const int RgbSaltSize = 8;

                internal CryptPkcs12PbeParams Params;
                internal fixed byte rgbSalt[RgbSaltSize];
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct CryptPkcs12PbeParams
            {
                internal int iIterations;
                internal int cbSalt;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct NCryptBufferDesc
            {
                public int ulVersion;
                public int cBuffers;
                public IntPtr pBuffers;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct NCryptBuffer
            {
                public int cbBuffer;
                public BufferType BufferType;
                public IntPtr pvBuffer;
            }

            internal enum BufferType
            {
                PkcsAlgOid = 41,
                PkcsAlgParam = 42,
                PkcsSecret = 46,
            }
        }
    }

    // PFX and password omitted
}

","357","<.net><certificate><rsa><pinvoke><cng>","1","3","1","2019-03-20 22:46:40","55249105","0","","","","","2019-03-19 08:13:54",""
"51018834","CngKey Assign permission to machine key","I've created a machine wide CngKey (MachineKey=true), but my applications aren't able to access it.
How to I assign permissions to so that my App Pool can access the key? Preferably pragmatically so that I can build it into the installer. 
Powershell create script:
[System.Security.Cryptography.CngKeyCreationParameters] $cngKeyParameter =  [System.Security.Cryptography.CngKeyCreationParameters]::new()
    $cngKeyParameter.KeyUsage = [System.Security.Cryptography.CngKeyUsages]::AllUsages
    $cngKeyParameter.ExportPolicy = [System.Security.Cryptography.CngExportPolicies]::AllowPlaintextExport

    $cngKeyParameter.Provider = [System.Security.Cryptography.CngProvider]::MicrosoftSoftwareKeyStorageProvider
    $cngKeyParameter.UIPolicy = [System.Security.Cryptography.CngUIPolicy]::new([System.Security.Cryptography.CngUIProtectionLevels]::None)
    $cngKeyParameter.KeyCreationOptions = [System.Security.Cryptography.CngKeyCreationOptions]::MachineKey

    #Create Cng Property for Length, set its value and add it to Cng Key Parameter
    [System.Security.Cryptography.CngProperty] $cngProperty = [System.Security.Cryptography.CngProperty]::new($cngPropertyName, [System.BitConverter]::GetBytes(2048), [System.Security.Cryptography.CngPropertyOptions]::None)
    $cngKeyParameter.Parameters.Add($cngProperty)

    #Create Cng Key for given $keyName using Rsa Algorithm
    [System.Security.Cryptography.CngKey] $key = [System.Security.Cryptography.CngKey]::Create([System.Security.Cryptography.CngAlgorithm]::Rsa, ""MyKey"", $cngKeyParameter)

","The permissions for a CNG key are a bit indirect.
If you know the full set of permissions you want to apply you can do it at creation (you'll have to translate the C# to PowerShell, sorry):
CryptoKeySecurity sec = new CryptoKeySecurity();

sec.AddAccessRule(
    new CryptoKeyAccessRule(
        new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null),
        CryptoKeyRights.FullControl,
        AccessControlType.Allow));

sec.AddAccessRule(
    new CryptoKeyAccessRule(
        new SecurityIdentifier(WellKnownSidType.NetworkServiceSid, null),
        CryptoKeyRights.GenericRead,
        AccessControlType.Allow));

const string NCRYPT_SECURITY_DESCR_PROPERTY = ""Security Descr"";
const CngPropertyOptions DACL_SECURITY_INFORMATION = (CngPropertyOptions)4;

CngProperty permissions = new CngProperty(
    NCRYPT_SECURITY_DESCR_PROPERTY,
    sec.GetSecurityDescriptorBinaryForm(),
    CngPropertyOptions.Persist | DACL_SECURITY_INFORMATION);

cngKeyParameter.Parameters.Add(permissions);

If you want to append a rule later (such as after creating it with the default permissions):
CngProperty prop = key.GetProperty(NCRYPT_SECURITY_DESCR_PROPERTY, DACL_SECURITY_INFORMATION);
CryptoKeySecurity sec = new CryptoKeySecurity();
sec.SetSecurityDescriptorBinaryForm(prop.GetValue());

sec.AddAccessRule(
    new CryptoKeyAccessRule(
        new SecurityIdentifier(WellKnownSidType.NetworkServiceSid, null),
        CryptoKeyRights.GenericRead,
        AccessControlType.Allow));

CngProperty newProp = new CngProperty(
    prop.Name,
    sec.GetSecurityDescriptorBinaryForm(),
    CngPropertyOptions.Persist | DACL_SECURITY_INFORMATION);

key.SetProperty(newProp);

","341","<security><encryption><cng>","0","4","1","2018-06-25 17:02:18","51028524","0","","","","","2018-06-25 08:09:30",""
"42433973","Structure of the certificate pointed to by NCRYPT_KEY_HANDLE","I've written a credential provider and a key storage provider to logon to windows via certificate. As the documentation in this points is quite vague I used different samples from Microsoft to get things working.
I think I'm nearly there, but the logon behaves unpredictably. Sometimes I get through to the kerberos server (which complains about the certificate), sometimes the process fails with 0x80090029 without any information and sometimes windows crashes. As these crashes all have to do with access violations or null pointers and happen to occur in various places (kerberos.dll,  Windows.UI.Logon.dll, ...) I think it has something to do with my key structure that i point the given NCRYT_KEY_HANDLE to in my OpenKey-implementation. 
The KeyStorageProviderSample in the CNG-Kit has an example, but relies on a RSA-key stored in %AppData%. I don't have the private key available as it is stored in secure hardware, I just have the public part (i.e. the public certificate), that I read from another device and import via the following code:
SECURITY_STATUS WINAPI KeyHandler::ReadPemCert(__inout  KSP_KEY *keyHandle)
{
    LOG_FUNCTION;

    CERT_CONTEXT certContext = {};
    DWORD readLength = 0;

    LOG(""Fetch certificate"");
    const int maxSizeInBytes = 4096;
    char pemCertificateAsBytes[maxSizeInBytes];
    BluetoothClient bluetoothClient = BluetoothClient();
    bluetoothClient.getCertificate((PBYTE)pemCertificateAsBytes, readLength);

    DWORD certAsDerLen = readLength;
    BYTE* certAsDer = new BYTE[certAsDerLen];
    LOG(""convert PEM to DER"");
    if (!CryptStringToBinaryA(pemCertificateAsBytes, 0, CRYPT_STRING_BASE64, certAsDer, &certAsDerLen, NULL, NULL))
    {
        LOG_LAST_ERROR(""CryptStringToBinary failed. Err:"");
    }
    LOG_BYTES_AS_HEX(""DER-Zertifikat"", certAsDer, certAsDerLen);

    PCCERT_CONTEXT pcCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, certAsDer, certAsDerLen);
    certContext->pCertInfo = pcCertContext->pCertInfo;
    certContext->cbCertEncoded = pcCertContext->cbCertEncoded;
    certContext->pbCertEncoded = pcCertContext->pbCertEncoded;
    certContext->dwCertEncodingType = pcCertContext->dwCertEncodingType;

    CERT_INFO *certInfo;
    certInfo = certContext.pCertInfo;

    CERT_PUBLIC_KEY_INFO pubKeyInfo = certInfo->SubjectPublicKeyInfo;

    LOG(""Aquire cryptocontext"");
    HCRYPTPROV hProv = 0;
    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        {
            LOG_LAST_ERROR(""CryptAcquireContext failed. Err:"");
            return -1;
        }
    }

    LOG(""Importing public key"");
    NCRYPT_KEY_HANDLE publicKeyHandle = NULL;
    if (!CryptImportPublicKeyInfo(hProv, X509_ASN_ENCODING, &pubKeyInfo, &publicKeyHandle))
    {
        LOG_LAST_ERROR(""CryptImportPublicKeyInfo failed. Err:"");
        return -1;
    }

    keyHandle->fFinished = TRUE;
    keyHandle->hPublicKey = (BCRYPT_KEY_HANDLE)publicKeyHandle;
    keyHandle->pszKeyBlobType = BCRYPT_RSAPUBLIC_BLOB;

    LocalFree(certInfo);

    return ERROR_SUCCESS;
}

The key structure is initialized this way:
SECURITY_STATUS
WINAPI
KeyHandler::CreateNewKeyObject(
    __in_opt LPCWSTR pszKeyName,
    __deref_out KSP_KEY **ppKey)
{
    LOG_FUNCTION;

    KSP_KEY *pKey = NULL;
    DWORD   cbKeyName = 0;
    SECURITY_STATUS   Status = NTE_INTERNAL_ERROR;
    NTSTATUS          ntStatus = STATUS_INTERNAL_ERROR;

    pKey = (KSP_KEY *)HeapAlloc(GetProcessHeap(), 0, sizeof(KSP_KEY));
    if (pKey == NULL)
    {
        return NTE_NO_MEMORY;
    }
    pKey->cbLength = sizeof(KSP_KEY);
    pKey->dwMagic = KSP_KEY_MAGIC;
    pKey->dwAlgID = KSP_RSA_ALGID;
    pKey->pszKeyFilePath = NULL;
    pKey->pszKeyBlobType = NULL;
    pKey->dwKeyBitLength = 0;
    pKey->fFinished = FALSE;

    //Copy the keyname into the key struct.
    if (pszKeyName != NULL)
    {
        cbKeyName = (DWORD)(wcslen(pszKeyName) + 1) * sizeof(WCHAR);
        pKey->pszKeyName = (LPWSTR)HeapAlloc(
            GetProcessHeap(),
            0,
            cbKeyName + sizeof(WCHAR));
        if (pKey->pszKeyName == NULL)
        {
            return NTE_NO_MEMORY;
        }
        CopyMemory(pKey->pszKeyName, pszKeyName, cbKeyName);
        pKey->pszKeyName[cbKeyName / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        pKey->pszKeyName = NULL;
    }

    if (globalRSAProviderHandle == NULL)
    {
        ntStatus = BCryptOpenAlgorithmProvider(
            &globalRSAProviderHandle,
            BCRYPT_RSA_ALGORITHM,
            NULL,
            0);
        if (!NT_SUCCESS(ntStatus))
        {
            return NormalizeNteStatus(ntStatus);
        }

    }
    pKey->hProvider = globalRSAProviderHandle;

    pKey->pbKeyFile = NULL;
    pKey->cbKeyFile = 0;

    pKey->pbPrivateKey = NULL;
    pKey->cbPrivateKey = 0;

    pKey->hPublicKey = NULL;
    pKey->hPrivateKey = NULL;

    pKey->dwExportPolicy = NCRYPT_ALLOW_EXPORT_FLAG | NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG;

    pKey->dwKeyUsagePolicy = NCRYPT_ALLOW_DECRYPT_FLAG | NCRYPT_ALLOW_SIGNING_FLAG;

    pKey->pbSecurityDescr = NULL;
    pKey->cbSecurityDescr = 0;

    InitializeListHead(&pKey->PropertyList);
    *ppKey = pKey;
    pKey = NULL;
    return ERROR_SUCCESS;
}

Somewhere in there must be the mistake leading to the various memory errors. But as I'm quite new to windows programming and c/c++ I just can't spot the point and can't find any documentation about the datastructure that windows expects for the NCRYTP_KEY_HANDLE.
Does anybody know more about this structure?
","NCRYPT_KEY_HANDLE is just a pointer to a structure that you defined. 
Windows itself doesn't care about this structure and expect that your provider knows how to work with it.
In KeyHandler::ReadPemCert you mixed legacy CryptoAPI and CNG API. Since you are implementing KSP you should use only CNG API (CryptImportPublicKeyInfoEx2).
DWORD error = NTE_FAIL;
BCRYPT_KEY_HANDLE hKey = NULL;

...

PCCERT_CONTEXT pcCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, certAsDer, certAsDerLen);
if(!pcCertContext)
{
    goto Exit;
}


if (!CryptImportPublicKeyInfoEx2(X509_ASN_ENCODING, &pcCertContext->pCertInfo->SubjectPublicKeyInfo, 0, nullptr, &hKey))
{   
    goto Exit;
}

/* Also you can export key and print out the result to make sure everything works

    DWORD temp  = 0;
    status = BCryptExportKey(hKey, 0, BCRYPT_RSAPUBLIC_BLOB, nullptr, 0, &temp, 0);
    if (status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    std::vector<BYTE> key(temp);
    status = BCryptExportKey(hKey, 0, BCRYPT_RSAPUBLIC_BLOB, key.data(), key.size(), &temp, 0);
    if (status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    for (auto const& i : key)
    {
        std::cout << std::hex << (int)i;
    }
}
*/

keyHandle->fFinished = TRUE;
keyHandle->hPublicKey = hKey;
keyHandle->pszKeyBlobType = BCRYPT_RSAPUBLIC_BLOB;

erro = ERROR_SUCCESS;

Exit:

if(pcCertContext)
{
    CertFreeCertificateContext(pcCertContext);
}

return error;

","335","<windows><certificate><kerberos><cng>","0","1","1","2017-03-21 20:48:20","42937867","1","","","","","2017-02-24 08:30:11",""
"49112408","Why are CNG requirements in .NET lower than in unmanaged CNG?","Is there a logical reason why the minimum requirements for CNG in .NET and in unmanaged code are so inconsistent? For example,
NCryptDeleteKey (unmanaged CNG) requires Windows Vista or Server 2008:
https://msdn.microsoft.com/en-us/library/windows/desktop/aa376251(v=vs.85).aspx
But CngKey.delete (apparently managed CNG) requires only .NET 3.5 which is accessible from Windows 7:
https://msdn.microsoft.com/en-us/library/system.security.cryptography.cngkey.delete(v=vs.110).aspx
Some of the requirements are as steep as 4.6.2 depending on the call, Example:
The AesCng Constructor to access an existing AES CNG key:
https://msdn.microsoft.com/en-us/library/mt693435(v=vs.110).aspx
But you can still call that from a properly updated Windows 7 machine. So why is there such a difference? 
Is it possible that a properly updated Windows 7 machine could reliably call NCryptDeleteKey?
","Managed means they are implemented in the .NET Framework. Unmanaged means they have to be provided by the operating system and Microsoft has been evolving what has shipped with Windows over time.
","304","<c#><.net><cng>","0","1","1","2018-03-05 14:17:31","","5","","","","","2018-03-05 14:13:41",""
"54355676","Convert HEX to printable string/char","I'm using CNG to generate a hash.
Result of BCryptFinishHash call is MD5 of a input in hex form.
Example:
char *outHash = ""\x02\x34\x75\01...""

I want to convert it to printable string: 02347501...
How can I do that?
","If you need an easy, one time solution, this is a useful tool:
https://codebeautify.org/hex-string-converter
However, if you're looking to do this within your code itself, I found this from an earlier thread (AKA, this is not my work but that of @KEINE LUST from here )

int main(void)
{
unsigned char readingreg[4];
readingreg[0] = 0x4a;
readingreg[1] = 0xaa;
readingreg[2] = 0xaa;
readingreg[3] = 0xa0;
char temp[4];

sprintf(temp, ""%x"", readingreg[0]);
printf(""This is element 0: %s\n"", temp);
return 0;
}


","301","<c++><c><debugging><winapi><cng>","1","0","6","2019-01-25 08:04:27","54355981","3","","","","","2019-01-24 21:38:02",""
"54355676","Convert HEX to printable string/char","I'm using CNG to generate a hash.
Result of BCryptFinishHash call is MD5 of a input in hex form.
Example:
char *outHash = ""\x02\x34\x75\01...""

I want to convert it to printable string: 02347501...
How can I do that?
","You can print it like this:
for(const char *wsk=outHash; *wsk; ++wsk){
    printf(""%02hhx"", *wsk);
}

Edit based that cstring can have 0x00 numbers.

C
const char outHash[] = ""\x02\x34\x75"";
const int size = sizeof(outHash)/sizeof(char) - 1;
for(int i = 0; i < size; ++i){
    printf(""%02hhx"", outHash [i]);
}

C++
std::string outHash = ""\x02\x34\x75"";
for(int i = 0; i < outHash.size(); ++i) {
    printf(""%02hhx"", outHash [i]);
}

","301","<c++><c><debugging><winapi><cng>","1","0","6","2019-01-25 08:04:27","54355981","3","","","","","2019-01-24 21:38:02",""
"54355676","Convert HEX to printable string/char","I'm using CNG to generate a hash.
Result of BCryptFinishHash call is MD5 of a input in hex form.
Example:
char *outHash = ""\x02\x34\x75\01...""

I want to convert it to printable string: 02347501...
How can I do that?
","we can use CryptBinaryToString here with CRYPT_STRING_HEXASCII or CRYPT_STRING_HEX or CRYPT_STRING_HEXRAW or CRYPT_STRING_HEX | CRYPT_STRING_NOCRLF or CRYPT_STRING_HEXRAW | CRYPT_STRING_NOCRLF depen how you want format string. for example
void print(PUCHAR pbHash, ULONG cbHash, DWORD dwFlags = CRYPT_STRING_HEXRAW | CRYPT_STRING_NOCRLF)
{
    ULONG cch = 0;
    if (CryptBinaryToStringW(pbHash, cbHash, dwFlags, 0, &cch))
    {
        if (PWSTR sz = (PWSTR)_malloca(cch * sizeof(WCHAR)))
        {
            if (CryptBinaryToStringW(pbHash, cbHash, dwFlags, sz, &cch))
            {
                DbgPrint(""%S\n"", sz);
            }
            _freea(sz);
        }
    }
}

","301","<c++><c><debugging><winapi><cng>","1","1","6","2019-01-25 08:04:27","54355981","3","","","","","2019-01-24 21:38:02",""
"54355676","Convert HEX to printable string/char","I'm using CNG to generate a hash.
Result of BCryptFinishHash call is MD5 of a input in hex form.
Example:
char *outHash = ""\x02\x34\x75\01...""

I want to convert it to printable string: 02347501...
How can I do that?
","To encode a byte array in hex and write the encoded data to a std::string, do this:
static inline char
hex_digit(unsigned int n)
{
    if (n < 10) return '0' + n;
    if (n < 16) return 'a' + (n - 10);
    abort();
}

std::string
encode_bytes(const unsigned char *bytes, size_t len)
{
    std::string rv;
    rv.reserve(len * 2);
    for (size_t i = 0; i < len; i++) {
        rv.push_back(hex_digit((bytes[i] & 0xF0) >> 4));
        rv.push_back(hex_digit((bytes[i] & 0x0F) >> 0));
    }
    return rv;
}

Note that you must know the length of the byte array.  It is not safe to treat it as a NUL-terminated ""C string"", because binary data can contain internal zero bytes.  To know the length of a hash generated by CNG, call BCryptGetProperty to get the BCRYPT_HASH_LENGTH property.
","301","<c++><c><debugging><winapi><cng>","1","2","6","2019-01-25 08:04:27","54355981","3","","","","","2019-01-24 21:38:02",""
"54355676","Convert HEX to printable string/char","I'm using CNG to generate a hash.
Result of BCryptFinishHash call is MD5 of a input in hex form.
Example:
char *outHash = ""\x02\x34\x75\01...""

I want to convert it to printable string: 02347501...
How can I do that?
","Loop over the characters and print the numerical value (in hex).
#include <iostream>
#include <iomanip>

int main()
{
    char*  outHash = ""\x02\x34\x75\x01\x23\xff"";  // Get from your Hash function.
    int    sizeOfHash = 6;                        // Use appropriate size for BCryptFinishHash()


    // Set up the characteristics of the stream.
    // setw(2):       Each printed object will use a min width of 2
    // setfill('0'):  If the object is less than 2 char then fill the space with '0'
    // hex:           Print numbers in hex.
    std::cout << std::setw(2) << std::setfill('0') << std::hex;

    // Create a view of the object.
    // Makes it simpler to loop over.
    std::string_view view(outHash, sizeOfHash);

    // Loop over the string.
    for(unsigned char val: view) {
        // Convert to `unsigned char` to make sure you don't print
        // negative numbers. Then convert from there to `int` so that
        // the `std::hex will kick in and convert to hex value.
        std::cout << static_cast<int>(val);
    }   
    std::cout << ""\n"";
}

","301","<c++><c><debugging><winapi><cng>","1","0","6","2019-01-25 08:04:27","54355981","3","","","","","2019-01-24 21:38:02",""
"54355676","Convert HEX to printable string/char","I'm using CNG to generate a hash.
Result of BCryptFinishHash call is MD5 of a input in hex form.
Example:
char *outHash = ""\x02\x34\x75\01...""

I want to convert it to printable string: 02347501...
How can I do that?
","I am working on C++ wrapper around Windows Crypto API & CNG which I am using in my projects. I plan to move all of it to github but for now it is just a work in progress, but you can find it useful for Crypto basics like HEX / Base64 encode / decode etc.
https://github.com/m4x1m1l14n/Crypto
You can use Crypto::Hex::Encode() method to achieve what you want.
#include <Crypto\Hex.hpp>
#include <Crypto\Random.hpp>

using namespace m4x1m1l14n;

char arr[] = { 0xaa, 0xbb, 0xcc, 0xdd, 0x99, 0x00 };

encoded = Crypto::Hex::Encode(arr, sizeof(arr));

/* encoded = ""aabbccdd9900"" */

Also you can use wrapper for MD5 which is located in Hash namespace, like this. (If you are not using large amount of data)
#include <Crypto\Hex.hpp>
#include <Crypto\Hash.hpp>

using namespace m4x1m1l14n;

encoded = Crypto::Hex::Encode(Crypto::Hash::MD5(""Whatever you want to hash""));


","301","<c++><c><debugging><winapi><cng>","1","0","6","2019-01-25 08:04:27","54355981","3","","","","","2019-01-24 21:38:02",""
"48673289","How to calculate Subject Key Identifier in CNG?","My goal is to populate the Subject Key Identifier Extension (2.5.29.14) for a certificate using Microsoft CNG. I did it previously with Microsoft CAPI but the function I used:
CryptHashPublicKeyInfo
https://msdn.microsoft.com/en-us/library/windows/desktop/aa380204(v=vs.85).aspx
Is now depreciated. CNG has no such method. However, the descripion for CryptHashPublicKeyInfo in the link above says that they do a SHA1 hash of the public key information. So I did a SHA1 hash of the public key bytes in CNG on the same data in CryptHashPublicKeyInfo (CAPI) and the two hashes are different. I need to resolve this difference. To be clear, my logic is running on the same public key from the same CSR.
Details in RFC 5280 seem to confirm what Microsoft says:
https://tools.ietf.org/html/rfc5280#section-4.2.1.2

(1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
             value of the BIT STRING subjectPublicKey (excluding the tag,
             length, and number of unused bits).
Cooper, et al.              Standards Track                    [Page
  28]   RFC 5280            PKIX Certificate and CRL Profile
  May 2008
  (2) The keyIdentifier is composed of a four-bit type field with
       the value 0100 followed by the least significant 60 bits of
       the SHA-1 hash of the value of the BIT STRING
       subjectPublicKey (excluding the tag, length, and number of
       unused bits).


^I'm guessing Microsoft is doing case #1.
Here is my CAPI code:
//depreciated (CAPI)
//get data for subject key identifier
//get length
HCRYPTPROV hHashProv = NULL;
if (!CryptHashPublicKeyInfo(
    hHashProv,
    CALG_SHA1, //sha1
    0,
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    &serverCertInfo.SubjectPublicKeyInfo,
    NULL,
    &dwSubjectKeyIdentifier
))
{
    throw std::runtime_error(""Unable to get length of public key info hash"");
}

//alocate data buffer
pbSubjectKeyIdentifier = (LPBYTE)LocalAlloc(0, dwSubjectKeyIdentifier);
//fill data buffer with subject key identifier
if (!CryptHashPublicKeyInfo(
    hHashProv,
    CALG_SHA1, //sha1
    0,
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    &serverCertInfo.SubjectPublicKeyInfo,
    pbSubjectKeyIdentifier,
    &dwSubjectKeyIdentifier
))
{
    throw std::runtime_error(""Unable to fill public key info hash"");
}

CRYPT_DATA_BLOB skiBlob;
skiBlob.cbData = dwSubjectKeyIdentifier;
skiBlob.pbData = pbSubjectKeyIdentifier;

//encode subject key identifier extension
LPBYTE pbEncodeSKI = NULL;
DWORD dwEncodedSKI;
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&skiBlob,
    NULL,
    &dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to get length to encode extension: subject key identifier"");
}

pbEncodeSKI = (LPBYTE)LocalAlloc(0, dwEncodedSKI);
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&skiBlob,
    pbEncodeSKI,
    &dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to encode extension: subject key identifier"");
}

This produces this value in the extension (same public key in certificate request): 9d77f29e4fa15e46237d59a7c00efde9d286b9dc
This is my CNG code:
NTSTATUS statusBCryptOpenAlgorithmProvider;
NTSTATUS statusBCryptHash;
BCRYPT_ALG_HANDLE hHashAlg;
LPBYTE pbHash;
DWORD dwHash = 20;
LPSTR lpstrPublicKeyEncoded;
DWORD dwPublicKeyEncoded;
CRYPT_DATA_BLOB skiBlob;

if (!CryptBinaryToStringA(
    infoPublicKey.PublicKey.pbData,
    infoPublicKey.PublicKey.cbData,
    CRYPT_STRING_BINARY,
    NULL,
    &dwPublicKeyEncoded
))
{
    throw std::runtime_error(""Error getting length of encoded binary string (CryptBinaryToString)"");
}

lpstrPublicKeyEncoded = (LPSTR)LocalAlloc(0, dwPublicKeyEncoded);
if (!CryptBinaryToStringA(
    infoPublicKey.PublicKey.pbData,
    infoPublicKey.PublicKey.cbData,
    CRYPT_STRING_BINARY,
    lpstrPublicKeyEncoded,
    &dwPublicKeyEncoded
))
{
    LocalFree(lpstrPublicKeyEncoded);
    throw std::runtime_error(""Error encoding binary string (CryptBinaryToString)"");
}

statusBCryptOpenAlgorithmProvider = BCryptOpenAlgorithmProvider(
    &hHashAlg,
    BCRYPT_SHA1_ALGORITHM,
    MS_PRIMITIVE_PROVIDER,
    0
);

if (0 != statusBCryptOpenAlgorithmProvider)
{
    LocalFree(lpstrPublicKeyEncoded);
    throw std::runtime_error(""Error opening SHA1 algorithm provider (BCryptOpenAlgorithmProvider)"");
}

pbHash = (LPBYTE)LocalAlloc(0, dwHash);
statusBCryptHash = BCryptHash(
    hHashAlg,
    NULL,
    0,
    (BYTE*)lpstrPublicKeyEncoded,
    dwPublicKeyEncoded,
    pbHash,
    dwHash
);

if (0 != statusBCryptHash)
{
    LocalFree(lpstrPublicKeyEncoded);
    BCryptCloseAlgorithmProvider(hHashAlg, 0);
    LocalFree(pbHash);
    throw std::runtime_error(""Error hashing public key (BCryptHash)"");
}

skiBlob.pbData = pbHash;
skiBlob.cbData = dwHash;

BCryptCloseAlgorithmProvider(hHashAlg, 0);
LocalFree(pbHash);
LocalFree(lpstrPublicKeyEncoded);

//encode subject key identifier extension
LPBYTE pbEncodeSKI = NULL;
DWORD dwEncodedSKI;
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&skiBlob,
    NULL,
    &dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to get length to encode extension: subject key identifier"");
}

pbEncodeSKI = (LPBYTE)LocalAlloc(0, dwEncodedSKI);
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&skiBlob,
    pbEncodeSKI,
    &dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to encode extension: subject key identifier"");
}

This produces this SKI value (different): 210816297e8e76879f99ec4762452b5d38967b5b
Any clue what I am doing wrong in the CNG code sample? There is apparently a magic sequence of calls but I don't know what it is.
","Here you go: both CNG and CAPI variants.
HRESULT capiCreateKeyIdentifierFromPublicKey(NCRYPT_KEY_HANDLE hCngKey, CRYPT_DATA_BLOB* outHash)
{
    HRESULT                 hr         = S_OK;
    BOOL                    bResult    = FALSE;

    PCERT_PUBLIC_KEY_INFO   pCertInfo  = NULL;
    DWORD                   cbCertInfo = 0;

    outHash->pbData = NULL;
    outHash->cbData = 0;


    /* STEP1: Extract public key. */
    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, &cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pCertInfo = (PCERT_PUBLIC_KEY_INFO)HeapAlloc(GetProcessHeap(), 0, cbCertInfo);
    if (NULL == pCertInfo) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }


    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, &cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }



    /* STEP2: Make hash. */
    bResult = CryptHashPublicKeyInfo(NULL, CALG_SHA1, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, NULL, &outHash->cbData);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    outHash->pbData = (BYTE*)HeapAlloc(GetProcessHeap(), 0, outHash->cbData);

    bResult = CryptHashPublicKeyInfo(NULL, CALG_SHA1, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, outHash->pbData, &outHash->cbData);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }


Cleanup:
    if (!SUCCEEDED(hr) && NULL != outHash->pbData) {
        HeapFree(GetProcessHeap(), 0, outHash->pbData);
        outHash->pbData = NULL;
        outHash->cbData = 0;
    }

    if (NULL != pCertInfo) {
        HeapFree(GetProcessHeap(), 0, pCertInfo);
        pCertInfo = 0;
    }

    return hr;
}


HRESULT cngCreateKeyIdentifierFromPublicKey(NCRYPT_KEY_HANDLE hCngKey, CRYPT_DATA_BLOB* outHash)
{
    // @see https://docs.microsoft.com/en-us/windows/desktop/seccng/creating-a-hash-with-cng
    HRESULT                 hr           = S_OK;
    BOOL                    bResult      = FALSE;

    BCRYPT_ALG_HANDLE       hAlg         = NULL;
    BCRYPT_HASH_HANDLE      hHash        = NULL;
    NTSTATUS                status       = 0;

    DWORD                   cbData       = 0;
    DWORD                   cbHashObject = 0;
    PBYTE                   pbHashObject = NULL;

    PCERT_PUBLIC_KEY_INFO   pCertInfo    = NULL;
    DWORD                   cbCertInfo   = 0;

    BYTE*                   pbEncodedCertInfo = NULL;
    ULONG                   cbEncodedCertInfo = 0;

    outHash->pbData = NULL;
    outHash->cbData = 0;

    /* STEP1: Extract public key. */
    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, &cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pCertInfo = (PCERT_PUBLIC_KEY_INFO)HeapAlloc(GetProcessHeap(), 0, cbCertInfo);
    if (NULL == pCertInfo) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }


    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, &cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }



    /* STEP2: Encode the public key. */
    bResult = CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pCertInfo, pbEncodedCertInfo, &cbEncodedCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pbEncodedCertInfo = (BYTE*)HeapAlloc(GetProcessHeap(), 0, cbEncodedCertInfo);

    bResult = CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pCertInfo, pbEncodedCertInfo, &cbEncodedCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }



    /* STEP3: Open an algorithm handle. */
    status = BCryptOpenAlgorithmProvider(
        &hAlg,
        BCRYPT_SHA1_ALGORITHM,
        NULL,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP4: Calculate the size of the buffer to hold the hash object. */
    status = BCryptGetProperty(
        hAlg,
        BCRYPT_OBJECT_LENGTH,
        (PBYTE)&cbHashObject,
        sizeof(DWORD),
        &cbData,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP5: Allocate the buffer for hash object on the heap. */
    pbHashObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbHashObject);
    if (NULL == pbHashObject) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }



    /* STEP6: Create a hash object (get handle to CNG hash object). */
    status = BCryptCreateHash(
        hAlg,
        &hHash,
        pbHashObject,
        cbHashObject,
        NULL,
        0,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP7: Calculate the length of buffer for result hash. */
    status = BCryptGetProperty(
        hAlg,
        BCRYPT_HASH_LENGTH,
        (PBYTE)&outHash->cbData,
        sizeof(DWORD),
        &cbData,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP8: Allocate buffer for result hash on the heap. */
    outHash->pbData = (PBYTE)HeapAlloc(GetProcessHeap(), 0, outHash->cbData);
    if (NULL == outHash->pbData) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }



    /* STEP9: Hash data. */
    status = BCryptHashData(
        hHash,
        (PBYTE)pbEncodedCertInfo,
        cbEncodedCertInfo,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }


    /* STEP10: Close hash object and get result value. */
    status = BCryptFinishHash(
        hHash,
        outHash->pbData,
        outHash->cbData,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }

Cleanup:
    if (!SUCCEEDED(hr) && NULL != outHash->pbData) {
        HeapFree(GetProcessHeap(), 0, outHash->pbData);
        outHash->pbData = NULL;
        outHash->cbData = 0;
    }

    if (NULL != hHash) {
        BCryptDestroyHash(hHash);
        hHash = NULL;
    }

    if (NULL != pbHashObject) {
        HeapFree(GetProcessHeap(), 0, pbHashObject);
        pbHashObject = NULL;
    }

    if (NULL != hAlg) {
        BCryptCloseAlgorithmProvider(hAlg, 0);
        hAlg = NULL;
    }

    if (NULL != pbEncodedCertInfo) {
        HeapFree(GetProcessHeap(), 0, pbEncodedCertInfo);
        pCertInfo = 0;
    }

    if (NULL != pCertInfo) {
        HeapFree(GetProcessHeap(), 0, pCertInfo);
        pCertInfo = 0;
    }

    return hr;
}

Usage:
CRYPT_DATA_BLOB subjectKeyIdentifier = { 0 };
NCRYPT_KEY_HANDLE hCngKey = NULL;

HRESULT hr = NCryptOpenStorageProvider(&hProvider, MS_KEY_STORAGE_PROVIDER, 0);
if (hr) {
    hr = NCryptOpenKey(hProvider, &hCngKey, wszKeyName, 0, 0);
    if (ERROR_SUCCESS == hr) {
        hr = cngCreateKeyIdentifierFromPublicKey(hCngKey, &subjectKeyIdentifier);
        if (hr) {
            // do smth with data
            // clear the memory
            HeapFree(GetProcessHeap(), 0, subjectKeyIdentifier.pbData);
            subjectKeyIdentifier.pbData = NULL;
            subjectKeyIdentifier.cbData = 0;
        }

    }
}

......

","301","<c++><hash><cryptoapi><cng>","0","2","1","2018-07-05 15:13:46","51194439","1","","","","","2018-02-07 21:09:30",""
"54196796","How to get a CNG key handle to a public certificate previously imported to windows Cert: store (in Delphi)?","I need to use CNG to verify a message signature (RSA). The only problem is how to get the CNG key handle (NCRYPT_KEY_HANDLE or BCRYPT_KEY_HANDLE) if I have the public certificate stored in windows certs (Cert:\CurrentUser\My).
I am using a 
NCryptOpenStorageProvider({out}hProv, MS_KEY_STORAGE_PROVIDER, 0)

and I tried to get the public key handle using
NCryptOpenKey(hProv, {out}hKey, PWideChar('my.test.com'), AT_KEYEXCHANGE, 0) 

but it seems that NCryptOpenKey() can only open the certificates that also have private keys.
I was also looking at BCryptImportKeyPair() but this requires to have the public key in BCRYPT_RSAKEY_BLOB structure which I don't know how to achieve. 
The last function I was looking at was NCryptImportKey() but this again only works with private keys.
Anyone knows how to get the public key handle using CNG?
I have the public key in a file (cer/pem) and I imported it to windows Cert: store but if you know how to load it directly from a file to CNG key handle I would be happy as well.
","NCrypt* functions works with persisted key pairs which stored at Key Storage Provider. If you import certificate in certificate store and this certificate does not contain private key then public key will not save in KSP.
You can use function CryptImportPublicKeyInfoEx2 to acquire BCRYPT_KEY_HANDLE.
Sample code in C:  
HCERTSTORE hStore = nullptr;
    PCCERT_CONTEXT pCert = nullptr;
    BCRYPT_KEY_HANDLE hKey = nullptr;

    /* Open MY certificate store */
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, L""MY"");
    if (!hStore) {
        goto Exit;
    }

    /* Find your certificate in store. For example search by subject name */
    pCert = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_STR, L""subject name"", nullptr);
    if (!pCert) {
        goto Exit;
    }

    /* Or if you want to load certificate from file (assuming you read file to cert_data): 

        pCert = CertCreateCertificateContext(X509_ASN_ENCODING, cert_data, cert_size);

    */

    /* Now you can create BCRYPTKEY_HANDLE from your public key */
    if (!CryptImportPublicKeyInfoEx2(X509_ASN_ENCODING, &pCert->pCertInfo->SubjectPublicKeyInfo, 0, nullptr, &hKey)) {
        goto Exit;
    }

    /* Now you can verify signature with BCryptVerifySignature(hKey...) */


Exit:
    /* Don't forget to free handle after use */
    if (hKey) {
        BCryptDestroyKey(hKey);
    }
    if (pCert) {
        CertFreeCertificateContext(pCert);
    }
    if (hStore) {
        CertCloseStore(hStore, 0);
    }
    return 0;

","300","<signature><cng>","0","1","1","2019-01-15 20:07:30","54206122","0","","","","","2019-01-15 10:15:44",""
"50322187","What is the GUID suffix on key container storage files in Windows?","I am wondering what are the GUID suffixes for the RSA key container files stored in the machine and user key container stores. I cannot identify some of these as key containers through CAPI/CNG, although I'll expose my case using command line tools instead. Commands below are for PowerShell in an elevated prompt. On most machines, the GUID suffix is the same for all these file names, but on this one there are four different GUIDs, while the API is returning only keys with only one. What is this GUID? I do not like random secrets stored by I do not know what on my machine; are they safe to delete?
The content of the machine store directory is:
> ls -n $env:ProgramData\Microsoft\Crypto\Rsa\MachineKeys  | sort { ""$_""[-3..-1] }
d1f9044f5d7345da71c0d2efd2e4f59e_e9f96f2e-b8b7-49b2-85a5-840195eca603
d6d986f09a1ee04e24c949879fdb506c_a4dc5a56-574d-4e4b-ba8d-d88984f9a6c5
6de9cb26d2b98c01ec4e9e8b34824aa2_a4dc5a56-574d-4e4b-ba8d-d88984f9a6c5
76944fb33636aeddb9590521c2e8815a_a4dc5a56-574d-4e4b-ba8d-d88984f9a6c5
d6d986f09a1ee04e24c949879fdb506c_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
d1f9044f5d7345da71c0d2efd2e4f59e_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
76944fb33636aeddb9590521c2e8815a_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
6de9cb26d2b98c01ec4e9e8b34824aa2_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
ba8e1b9b5510957b3af7b811f05660de_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
d1f9044f5d7345da71c0d2efd2e4f59e_c6a7fc9d-32a6-41e4-afd5-7dc7b822029e

I sorted the list by the last three characters, so that it's easy to see in a glance that there are 4 distinct GUID suffixes to the key container files. Now let's enumerate the key reported by all installed CSPs. I'll get the list of providers, and later the list of each provider's keys using the certutil tool that comes with Windows. Its output requires some regex magic for parsing, which is not essential, just convenient:
> certutil -csplist | sls  '^Provider Name: (.*)' | %{ $_.Matches[0].Groups[1].Value }
Microsoft Base Cryptographic Provider v1.0
Microsoft Base DSS and Diffie-Hellman Cryptographic Provider
Microsoft Base DSS Cryptographic Provider
[...snip...]

The output for a single key lists the name, flags and the key container ID, the latter matching respective file name in the above directory (of course, we can see more keys from additional KSPs, smart cards, TPM etc.). Example for one provider (the -q makes some providers fail silently instead of asking for user's action, such as inserting a SmartCard):
> certutil -key -q
Microsoft Strong Cryptographic Provider:
  iisConfigurationKey
  6de9cb26d2b98c01ec4e9e8b34824aa2_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  RSA
    AT_KEYEXCHANGE

  iisWasKey
  76944fb33636aeddb9590521c2e8815a_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  [...snip...]

Some key names are just GUIDs too, but if we grep out only the lines that start with at the least 20 hex digits, there will be only the IDs listed. So all key IDs from all providers can be concisely shown with:
> certutil -csplist | sls '^Provider Name: (.*)' | %{ $_.Matches[0].Groups[1].Value } |
%{ certutil -key -q -csp ""$_"" } | sls '^\s+[0-9a-f]{20}.+' | sort -u

  597367cc37b886d7ee6c493e3befb421_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  6de9cb26d2b98c01ec4e9e8b34824aa2_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  76944fb33636aeddb9590521c2e8815a_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  ba8e1b9b5510957b3af7b811f05660de_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  d6d986f09a1ee04e24c949879fdb506c_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  f0e91f6485ac2d09485e4ec18135601e_f7fe3b04-ef9b-4b27-827f-953c5743e2ec

Here are actually 2 more keys than there are in the MachineKeys directory (they come from the KSP, in fact, certutil -key -csp KSP shows them, if you are wondering). But the fact is they all have the same GUID suffix _f7fe3b04-ef9b-4b27-827f-953c5743e2ec.
The machine was installed by the vendor (an HP notebook, to be exact). This is unlike other machines, that we assemble or buy barebone and install and configure by ourselves. And I am working with some sensitive data sometimes, so I am indeed paranoid vetting the software thoroughly before allowing machines to access sensitive data.
The OS is Windows 10, if that matters, but the same type of storage has not changed from Windows 7, AFAIK, even with the introduction of the new CNG API in 8.0 (or 8.1?).

Just in case anyone would find useful a PowerShell snippet to readably list keys by provider, I used this command:
> certutil -csplist | sls  '^Provider Name: (.*)' | %{ $_.Matches[0].Groups[1].Value } |
%{ Write-Host -for Yellow ""`n$_""; certutil -key -q -csp ""$_"" }

","Found the answer here: https://serverfault.com/a/642279/451491

The file naming convention is x_y, where x is a random GUID to
  uniquely identify the key, and y is the machine GUID found at
  HKLM\SOFTWARE\Microsoft\Cryptography.

","275","<windows><security><cryptoapi><cng>","2","1","1","2019-04-25 13:29:59","","1","","15168","","2018-06-19 15:53:59","2018-05-14 01:48:42",""
"10908227","Is there a way to view the ECDH Shared Secret generated within microsoft CNG?","I am trying to perform a ECDH key exchange between MS CNG and another device.  In order to debug things, I would like to see what shared secret is being generated in CNG so i can compare it with the secret generated by my other device. Anybody know of a way to do this? 
","Take a look at CNG documentation at MSDN: NCryptSecretAgreement function. The same function is accessible from .NET.
","274","<encryption><encryption-asymmetric><diffie-hellman><cng>","1","-1","1","2012-07-25 23:59:55","","2","1","","","","2012-06-06 04:37:29",""
"46532698","Add C# X509Certificate2 to X509Store with AllowPlaintextExport flag?","When I import a certificate into a store using CertUtil, e.g., certutil -f -v -user -privatekey -importPFX my mycert.p12, and then read it in in C#, I see that its export policy is AllowExport | AllowPlaintextExport.
However, when importing the same certificate to the same store using the X509Store.Add() method and then read it back in, the export policy is only AllowExport; I use the X509KeyStorageFlags.Exportable flag when importing the certificate to the store, e.g.,:
...
X509Certificate2Collection x509cert2Collection = new X509Certificate2Collection();
x509cert2Collection.Import(myp12bytes, passwd, X509KeyStorageFlags.Exportable);
foreach (X509Certificate2 x509cert2 in x509cert2Collection) {
    X509Store myStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    myStore.Add(x509cert2);                          
    myStore.Close();
}
...

My question is: is there a way to add a X509Certificate2 to the X509Store in C# so that the certificate's export policy includes both AllowExport and AllowPlaintextExport?  X509KeyStorageFlags does not seem to define the AllowPlaintextExport flag; only the CngExportPolicies does.  
FYI, I'm using .NET Framework 4.6.1 as the target.
Thanks.
","","257","<c#><.net><x509certificate><x509certificate2><cng>","1","","0","2017-10-02 19:48:06","","2","","","","","2017-10-02 19:48:06",""
"9628286","How can I detect at compile time in VS2008 whether I am building on an XP or Windows 7 machine","I have an application that includes some CNG (Bcrypt.dll) code. I want to be able to build my app on windows 7 and have the bcrypt funcitonality compile and run, but I want to ""skip"" it if I am building on a windows XP machine (at compile time) (i want to printout ""skipping encryption"" or something if i compiled it under XP).
is there a way at compile time know if my machine is windows 7 or XP so it will compile the appropriate code?    I don't really want to change my build target/makefile/project file based on this (I dont want to /D anything) , I want anyone who builds this to just build and it will generate whatever their computer supports... 
Is this possible?
Thanks!
","","244","<windows><visual-studio-2008><windows-7><windows-xp><cng>","2","","0","2012-03-09 02:54:56","","5","","","","","2012-03-09 02:49:46",""
"51472090","BCRYPT_XTS_AES_ALGORITHM CNG algorithm fails in BCryptGenerateSymmetricKey API","I am trying to use Windows CNG BCRYPT_XTS_AES_ALGORITHM algorithm to encrypt and decrypt the files. As part of this, I had written the following code for encryption and decryption. 
When I use this code with BCRYPT_AES_ALGORITHM algorithm, both encrypt and decrypt are working fine. But when the same is being used with BCRYPT_XTS_AES_ALGORITHM, it is throwing the STATUS_INVALID_PARAMETER error in BCryptGenerateSymmetricKey API. 
Any help on this is very much appreciated.
auto AesCrypt::CreateAESProviderAlgo()->void
{
    auto status = BCryptOpenAlgorithmProvider(&m_aesHandle, BCRYPT_AES_ALGORITHM, nullptr, 0);
    //auto status = BCryptOpenAlgorithmProvider(&m_aesHandle, BCRYPT_XTS_AES_ALGORITHM, nullptr, 0);
    if (0 != status) {
        N2S_THROW(""BCryptException::Failed to get provider for BCRYPT_XTS_AES_ALGORITHM. Reason: "" + GetErrorCodeAsString(status));
    }

    DWORD cbData = 0;
    DWORD cbKeyObject = 0;
    status = BCryptGetProperty(m_aesHandle, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbData, 0);
    if (0 != status) {
        N2S_THROW(""CreateSymmetricKeySHA1Hash::BCryptGetProperty return with error "" + GetErrorCodeAsString(status));
    }

    m_pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
    if (nullptr == m_pbKeyObject) {
        N2S_THROW(""CreateSymmetricKeySHA1Hash::Memory allocation failed."");
    }

    status = BCryptGenerateSymmetricKey(m_aesHandle, &m_keyHandle, m_pbKeyObject, cbKeyObject, (PUCHAR)m_encrptKey.c_str(), SYMM_KEY_SIZE_SECRET, 0);
    if (0 != status) {
        N2S_THROW(""CreateSymmetricKeySHA1Hash::BCryptGenerateSymmetricKey return with error "" + GetErrorCodeAsString(status));
    }
}

auto AesCrypt::ProcessEncryptFile() ->void
{
    DWORD bytesToSave = 0;
    UCHAR bufFileToOpen[BLOCK_SIZE] = { 0 };
    UCHAR bufFileToSave[BLOCK_SIZE * 2] = { 0 }; // TODO: Need to alloc on heap and reuse it.

    auto toReadBytes = GetFileSize(m_workOnFile);

    for (;;) // TODO: Need to take out the duplicate code from both locations.
    {
        m_readStream.read((CHAR *)bufFileToOpen, BLOCK_SIZE);
        auto bytesRead = m_readStream.gcount();

        if (0 == bytesRead) {
            N2S_THROW(""Error reading the file "" + GetStringFromWstring(m_workOnFile));
        }

        toReadBytes -= bytesRead;

        if (0 != toReadBytes && bytesRead == BLOCK_SIZE) {
            GetCryptStatus(BCryptEncrypt(m_keyHandle, bufFileToOpen, (ULONG)bytesRead, nullptr, nullptr, 0, bufFileToSave, (ULONG)bytesRead, &bytesToSave, 0));
            m_writeStream.write((CHAR *)bufFileToSave, bytesToSave);
            continue;
        }

        // Reading the last byte
        if (0 != BCryptEncrypt(m_keyHandle, bufFileToOpen, (ULONG)bytesRead, nullptr, nullptr, 0, nullptr, 0, &bytesToSave, BCRYPT_BLOCK_PADDING)) {
            N2S_THROW(""BCryptEncrypt::Error receiving the size required for the ciphertext."");
        }

        GetCryptStatus(BCryptEncrypt(m_keyHandle, bufFileToOpen, (ULONG)bytesRead, nullptr, nullptr, 0, bufFileToSave, bytesToSave, &bytesToSave, BCRYPT_BLOCK_PADDING));
        m_writeStream.write((CHAR *)bufFileToSave, bytesToSave);
        return; // Last block done.
    }
}

auto AesCrypt::ProcessDecryptFile()->void
{
    DWORD bytesToSave = 0;
    UCHAR bufFileToOpen[BLOCK_SIZE] = { 0 };
    UCHAR bufFileToSave[BLOCK_SIZE * 2] = { 0 }; // TODO: Need to alloc on heap and reuse it.

    auto toReadBytes = GetFileSize(m_workOnFile);

    for (;;)
    {
        m_readStream.read((CHAR *)bufFileToOpen, BLOCK_SIZE);
        auto bytesRead = m_readStream.gcount();

        if (0 == bytesRead) {
            N2S_THROW(""Error reading the file "" + GetStringFromWstring(m_workOnFile));
        }

        toReadBytes -= bytesRead;

        if (0 != toReadBytes && bytesRead == BLOCK_SIZE) {
            GetCryptStatus(BCryptDecrypt(m_keyHandle, bufFileToOpen, (ULONG)bytesRead, nullptr, nullptr, 0, bufFileToSave, (ULONG)bytesRead, &bytesToSave, 0));
            m_writeStream.write((CHAR *)bufFileToSave, bytesToSave);
            continue;
        }

        // Reading last block data
        if (0 != BCryptDecrypt(m_keyHandle, bufFileToOpen, (ULONG)bytesRead, nullptr, nullptr, 0, nullptr, 0, &bytesToSave, BCRYPT_BLOCK_PADDING)) {
            N2S_THROW(""BCryptEncrypt::Error receiving the size required for the ciphertext."");
        }

        GetCryptStatus(BCryptDecrypt(m_keyHandle, bufFileToOpen, (ULONG)bytesRead, nullptr, nullptr, 0, bufFileToSave, bytesToSave, &bytesToSave, BCRYPT_BLOCK_PADDING));
        m_writeStream.write((CHAR *)bufFileToSave, bytesToSave);
        return; // Last block done.
    }
}

","In your AesCrypt::CreateAESProviderAlgo method above, insure that SYMM_KEY_SIZE_SECRET is 32 and that the associated string is also 32 bytes long.
A copy and paste of your function into my test program worked for me when SYMM_KEY_SIZE_SECRET was specified as 32.  It didn't work when I specified a SYMM_KEY_SIZE_SECRET value of 16.
In addition, this algorithm is only supported on Windows 10 and above.
Further info:
XTS is a 2 key variant of AES.  It also requires a Message Block Size (sector size) and a Sector Number.
I used BCryptGenerateSymmetricKey to build the key.  I took an input 'string' of either 32 bytes (2 16 byte keys) or 64 bytes (2 32 byte keys) to generate the keys from the 'string'.  No other values were accepted.
The Message Block Size is set as the BCRYPT_MESSAGE_BLOCK_LENGTH parameter on the key handle.  It does not have to be an integral multiple of the AES block length - this is the difference between XTS and XEX.
The Sector Number is supplied as the IV value in the Encrypt / Decrypt APIs.  For me, only a length of 8 for the IV was accepted.
Working code snippet:
    BCRYPT_ALG_HANDLE m_aesHandle;
    auto status = BCryptOpenAlgorithmProvider(&m_aesHandle, /* BCRYPT_XTS_AES_ALGORITHM */ L""XTS-AES"", nullptr, 0);
    if (0 != status)
    {
        csMsg.Format(TEXT(""\r\nBCryptException::Failed to get provider for BCRYPT_XTS_AES_ALGORITHM. Error: %d""), status);
        csText += csMsg;
    }
    else
    {
        csMsg.Format(TEXT(""\r\nBCryptOpenAlgorithmProvider XTS SUCCESS!""));
        csText += csMsg;

        DWORD cbData = 0;
        DWORD cbKeyObject = 0;
        status = BCryptGetProperty(m_aesHandle, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbData, 0);
        if (0 != status)
        {
            csMsg.Format(TEXT(""\r\nBCryptGetProperty BCRYPT_OBJECT_LENGTH return error %d (0x%x)""), status, status);
            csText += csMsg;
        }
        else
        {
            csMsg.Format(TEXT(""\r\nBCryptGetProperty BCRYPT_OBJECT_LENGTH returned object length %u""), cbKeyObject);
            csText += csMsg;

            PBYTE m_pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
            if (nullptr == m_pbKeyObject)
            {
                csMsg.Format(TEXT(""\r\nMemory allocation failed.""));
                csText += csMsg;
            }
            else
            {
                BCRYPT_KEY_HANDLE m_keyHandle;
                CHAR String[] = ""1234567890abcdef01234567890abcdef1234567890abcdef01234567890abcdef"";
                static ULONG uStringLen = 32;
                BYTE Dummy[128] = { 0 };

                status = BCryptGenerateSymmetricKey(m_aesHandle, &m_keyHandle, m_pbKeyObject, cbKeyObject, (PUCHAR)String, uStringLen, 0);
                if (0 != status)
                {
                    csMsg.Format(TEXT(""\r\nBCryptGenerateSymmetricKey return with error %d (0x%x)""), status, status);
                    csText += csMsg;
                }
                else
                {
                    csMsg.Format(TEXT(""\r\nBCryptGenerateSymmetricKey SUCCESS!""));
                    csText += csMsg;

                    DWORD cbKey = 0;
                    status = BCryptGetProperty(m_keyHandle, BCRYPT_KEY_LENGTH, (PBYTE)&cbKey, sizeof(DWORD), &cbData, 0);
                    if (0 != status)
                    {
                        csMsg.Format(TEXT(""\r\nBCryptGetProperty BCRYPT_KEY_LENGTH return error %d (0x%x)""), status, status);
                        csText += csMsg;
                    }
                    else
                    {
                        csMsg.Format(TEXT(""\r\nBCryptGetProperty BCRYPT_KEY_LENGTH returned key length %u""), cbKey);
                        csText += csMsg;
                    }

                    DWORD cbBlock = 0;
                    status = BCryptGetProperty(m_aesHandle, BCRYPT_BLOCK_LENGTH, (PBYTE)&cbBlock, sizeof(DWORD), &cbData, 0);
                    if (0 != status)
                    {
                        csMsg.Format(TEXT(""\r\nBCryptGetProperty BCRYPT_BLOCK_LENGTH return error %d (0x%x)""), status, status);
                        csText += csMsg;
                    }
                    else
                    {
                        csMsg.Format(TEXT(""\r\nBCryptGetProperty BCRYPT_BLOCK_LENGTH returned key block length %u""), cbBlock);
                        csText += csMsg;
                    }

                    DWORD cbMessage = 512;
                    status = BCryptSetProperty(m_keyHandle, /* BCRYPT_MESSAGE_BLOCK_LENGTH */ L""MessageBlockLength"", (PBYTE)&cbMessage, sizeof(DWORD), 0);
                    if (0 != status)
                    {
                        csMsg.Format(TEXT(""\r\nBCryptSetProperty BCRYPT_MESSAGE_BLOCK_LENGTH return error %d (0x%x)""), status, status);
                        csText += csMsg;
                    }
                    else
                    {
                        csMsg.Format(TEXT(""\r\nBCryptSetProperty BCRYPT_MESSAGE_BLOCK_LENGTH SUCCESS message length %u""), cbMessage);
                        csText += csMsg;
                    }

                    BYTE PlaintextBuf[512], CipherTextBuf[512], DecryptedTextBuf[512];
                    int i;

                    for (i = 0; i < _countof(PlaintextBuf); i++)
                    {
                        PlaintextBuf[i] = String[i % _countof(String)];
                    }

                    BYTE IV[] = 
                    { 
                         0,  1,  2,  3,  4,  5,  6, 7, 
                         8,  9, 10, 11, 12, 13, 14, 15, 
                        16, 17, 18, 19, 20, 21, 22, 23, 
                        24, 25, 26, 27, 28, 29, 30, 31, 
                    };
                    static DWORD dwIVLen = 8;

                    status = BCryptEncrypt(m_keyHandle, PlaintextBuf, sizeof(PlaintextBuf), nullptr, 
                        IV, dwIVLen, CipherTextBuf, sizeof(CipherTextBuf), &cbData, 0);
                    if (0 != status)
                    {
                        csMsg.Format(TEXT(""\r\nBCryptEncrypt return with error %d (0x%x)""), status, status);
                        csText += csMsg;
                    }
                    else
                    {
                        csMsg.Format(TEXT(""\r\nBCryptEncrypt SUCCESS!""));
                        csText += csMsg;

                        status = BCryptDecrypt(m_keyHandle, CipherTextBuf, sizeof(CipherTextBuf), nullptr,
                            IV, dwIVLen, DecryptedTextBuf, sizeof(DecryptedTextBuf), &cbData, 0);
                        if (0 != status)
                        {
                            csMsg.Format(TEXT(""\r\nBCryptDecrypt return with error %d (0x%x)""), status, status);
                            csText += csMsg;
                        }
                        else
                        {
                            csMsg.Format(TEXT(""\r\nBCryptDecrypt SUCCESS!""));
                            csText += csMsg;

                            bool bGood = true;
                            for (i = 0; i < _countof(PlaintextBuf); i++)
                            {
                                if (PlaintextBuf[i] != DecryptedTextBuf[i])
                                {
                                    bGood = false;
                                    break;
                                }
                            }

                            if (bGood)
                                csMsg.Format(TEXT(""\r\nCrypt Verification SUCCESS!""));
                            else
                                csMsg.Format(TEXT(""\r\nCrypt Verification FAILURE, pos=%u!""), i);
                            csText += csMsg;
                        }
                    }

                    BCryptDestroyKey(m_keyHandle);
                }

                HeapFree(GetProcessHeap(), 0, m_pbKeyObject);
            }
        }

        BCryptCloseAlgorithmProvider(m_aesHandle, 0);
    }

","225","<windows><encryption-symmetric><cng>","1","1","1","2019-09-06 16:42:54","","4","1","608639","","2019-08-19 09:56:31","2018-07-23 05:32:04",""
"48198741","CNG replacement for CryptQueryObject","I'm interested in trying to read fields out of a digital signature.  I have code that calls CryptQueryObject, then CryptMsgGetParam to get some fields and finally CertFindCertificateInStore to load the certificate.  
Any hints on how to do this using the Cryptography Next Generation APIs?  Microsoft tells me CryptQueryObject is deprecated but doesn't point to its replacement.
","","213","<digital-signature><cng>","5","","0","2018-01-11 01:52:03","","3","2","","","","2018-01-11 01:52:03",""
"46081741","STATUS_INVALID_PARAMETER error import diffie hellman public key using BCryptImportKeyPair","I am trying to add a public key into diffie Hellman implementation of Bcrypt. 
example suggested to create and export a public key. In my case I already got the public key from the client. I am trying to use that public key to generate shared session key. I get STATUS_INVALID_PARAMETER when i try to use BCryptImportKeyPair. 
I created PBCRYPT_DH_KEY_BLOB and added the values manually. 
Is there any other way to do this? an example of importing public key into BCrypt from string would be appreciated. 
Thanks in Advance. Please check the code below.  
KeyLength = 1024;//bits
const int sz = 1024;
char * shared_public_key = ""48DE15D8E46B857B387E315D518B7D9EDDA1FCA6661CFC9C066B3A352E8644A30BFBB7F84C93818F67B7037235D11A5B0F31E15BCB344C2A7C13E339ED98939CF3F092E64C0DEA28A150404432E3B7077DE3E4D40E421EA88FFAF4D7AD53851912389674B24C80E5FD05D1C60344535159E7A4CAF9F9DCAF712C2A41EF524632"";
char * prime      = ""CBBD1F895B751A803674B4CF6178DAFF87E3AADD017B96CA0D536215091AC55C0D777ADB6206581E7681C5059BEFF7990E4B3DD074266B608800CF7110BE99B861D189A82A26D569CAA2F314E8E79838AEE8DA96380BDFA55B34CA43866B24C0A822947E669C9AA037A8FA765F637663AB4103A9251C70000A689796CE42A2A3"";
BYTE OakleyGroup1P[sz /8];
int fld_sz = sz / 8;
string s_prime(prime, fld_sz*2);
transform(s_prime.begin(), s_prime.end(), s_prime.begin(), ::tolower);
string res = """";
for (int i = 0; i < s_prime.size(); i += 2) {
  res += s_prime.substr(i, 2);
  res += "" "";
}
std::istringstream hex_chars_stream(res);

unsigned int c;
int i = 0;
while (hex_chars_stream >> std::hex >> c)
{
  OakleyGroup1P[i++] = c;
}
cout << ""size of OakleyGroup1P :"" << i << endl;
/*for (unsigned char x : OakleyGroup1P) {
  cout << ((x >> 4) & 0x0F) << "" "" << (x & 0x0F) << endl;
}*/

PBYTE PubBlobA2 = new BYTE[sz/8];
string s_shared(shared_public_key, fld_sz * 2);
transform(s_shared.begin(), s_shared.end(), s_shared.begin(), ::tolower);
string temp = """";
for (int i = 0; i < s_shared.size(); i += 2) {
  temp += s_shared.substr(i, 2);
  temp += "" "";
}
std::istringstream hex_chars_stream2(temp);

i = 0;
while (hex_chars_stream2 >> std::hex >> c)
{
  PubBlobA2[i++] = c;
}
cout << ""size of PubBlobA2 :"" << i << endl;
for (int j = 0; j < i; j++) {
  cout << ((*(PubBlobA2 + j) >> 4) & 0x0F) << "" "" << (*(PubBlobA2 + j) & 0x0F) << endl;
}

//
// Construct the DH parameter blob. this is the only supported
// method for DH in CNG.
//
// Calculate size of param blob and allocate memory

DhParamBlobLength = sizeof(BCRYPT_DH_PARAMETER_HEADER) + 
                sizeof(OakleyGroup1G) + 
                sizeof(OakleyGroup1P);

DhParamBlob = (PBYTE)HeapAlloc (
                                    GetProcessHeap (), 
                                    0, 
                                    DhParamBlobLength);
if( NULL == DhParamBlob )
{
    Status = STATUS_NO_MEMORY;
    ReportError(Status);
    goto cleanup;
}

DhParamHdrPointer  = (BCRYPT_DH_PARAMETER_HEADER *)DhParamBlob;

//
// Set header properties on param blob
//

DhParamHdrPointer->cbLength      = DhParamBlobLength;
DhParamHdrPointer->cbKeyLength   = KeyLength/8;//bytes
DhParamHdrPointer->dwMagic       = BCRYPT_DH_PARAMETERS_MAGIC;

//
// Set prime
//

memcpy(DhParamBlob + sizeof(BCRYPT_DH_PARAMETER_HEADER),
        OakleyGroup1P,
        sizeof(OakleyGroup1P));

//
// Set generator
//

memcpy(DhParamBlob + sizeof(BCRYPT_DH_PARAMETER_HEADER) + sizeof(OakleyGroup1P),
       OakleyGroup1G,
       sizeof(OakleyGroup1G));


//
// Open alg provider handle
//

Status = BCryptOpenAlgorithmProvider(
                                    &ExchAlgHandleB, 
                                    BCRYPT_DH_ALGORITHM, 
                                    NULL, 
                                    0);
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}



//
// B generates a private key
// 

Status = BCryptGenerateKeyPair(
                                    ExchAlgHandleB,             // Algorithm handle
                                    &PrivKeyHandleB,            // Key handle - will be created
                                    KeyLength,                  // Length of the key - in bits
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

Status = BCryptSetProperty(
                                    PrivKeyHandleB,
                                    BCRYPT_DH_PARAMETERS,
                                    DhParamBlob,
                                    DhParamBlobLength,
                                    0);
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

Status = BCryptFinalizeKeyPair(
                                    PrivKeyHandleB,             // Key handle
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

//
// B exports DH public key
//

Status = BCryptExportKey(
                                    PrivKeyHandleB,             // Handle of the key to export
                                    NULL,                       // Handle of the key used to wrap the exported key
                                    BCRYPT_DH_PUBLIC_BLOB,      // Blob type (null terminated unicode string)
                                    NULL,                       // Buffer that recieves the key blob
                                    0,                          // Buffer length (in bytes)
                                    &PubBlobLengthB,            // Number of bytes copied to the buffer
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

PubBlobB = (PBYTE)HeapAlloc (
                                    GetProcessHeap (), 
                                    0, 
                                    PubBlobLengthB);
if( NULL == PubBlobB )
{
    Status = STATUS_NO_MEMORY;
    ReportError(Status);
    goto cleanup;
}


Status = BCryptExportKey(
                                    PrivKeyHandleB,             // Handle of the key to export
                                    NULL,                       // Handle of the key used to wrap the exported key
                                    BCRYPT_DH_PUBLIC_BLOB,      // Blob type (null terminated unicode string)
                                    PubBlobB,                   // Buffer that recieves the key blob
                                    PubBlobLengthB,             // Buffer length (in bytes)
                                    &PubBlobLengthB,            // Number of bytes copied to the buffer
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}


//
// Build KDF parameter list
//

//specify hash algorithm, SHA1 if null

//specify secret to append
BufferArray[0].BufferType = KDF_TLS_PRF_SEED;
BufferArray[0].cbBuffer = sizeof(rgbrgbTlsSeed);
BufferArray[0].pvBuffer = (PVOID)rgbrgbTlsSeed;

//specify secret to prepend
BufferArray[1].BufferType = KDF_TLS_PRF_LABEL;
BufferArray[1].cbBuffer = (DWORD)((wcslen(Label) + 1) * sizeof(WCHAR));
BufferArray[1].pvBuffer = (PVOID)Label;

ParameterList.cBuffers  = 2;
ParameterList.pBuffers  = BufferArray;
ParameterList.ulVersion = BCRYPTBUFFER_VERSION;

//
// B imports A's public key
//
// dh public key blob structure
PBCRYPT_DH_KEY_BLOB p_dh_pub_key_blob = (PBCRYPT_DH_KEY_BLOB)HeapAlloc(
  GetProcessHeap(),
  0,
  sizeof(BCRYPT_DH_KEY_BLOB));
p_dh_pub_key_blob->dwMagic = BCRYPT_DH_PUBLIC_MAGIC;
p_dh_pub_key_blob->cbKey = sz/8;
DWORD df_pub_key_data_length = sizeof(BCRYPT_DH_KEY_BLOB) + sz / 8;

PBYTE p_df_pub_key_data = (PBYTE)HeapAlloc(
  GetProcessHeap(),
  0,
  df_pub_key_data_length);
memcpy(p_df_pub_key_data,
  p_dh_pub_key_blob,
  sizeof(BCRYPT_DH_KEY_BLOB));
memcpy(p_df_pub_key_data + sizeof(BCRYPT_DH_KEY_BLOB),
  PubBlobA2,
  sz/8);
Status = BCryptImportKeyPair(
  ExchAlgHandleB,             // Alg handle
  NULL,                       // Parameter not used
  BCRYPT_DH_PUBLIC_BLOB,      // Blob type (Null terminated unicode string)
  &PubKeyHandleB,             // Key handle that will be recieved
  p_df_pub_key_data,            // Buffer than points to the key blob
  df_pub_key_data_length,     // Buffer length in bytes
  0);    

","","204","<c++><winapi><cryptoapi><cng><wincrypt>","1","","0","2017-09-07 15:01:09","","3","","1294545","","2017-09-07 15:01:09","2017-09-06 18:08:31",""
"56594954","CngKey how i can append accessrule to previously created and assigned rules to a machine key?","How can i append access rule(CryptoAccessRule) to already/previously created and assigned(some default crypto access rule already assigned) machine key which is Crypto api?
I have a already created crypto api . I have used below code so as to append crypto access rule to this key. But, it failed and returned me 'invalid flags '  exceptions in HasProperty/GetProperty. Please suggest. Please note this is Crypto api key so, it dosn't contain CngProperty option, but as Cng api provides backword compatibility, there should be some way to retrieve the previosuly applied CryptoAccessRules from CryptoApi using RSACng . 
NCRYPT_SECURITY_DESCR_PROPERTY=""Security Descr"";
DACL_SECURITY_INFORMATION=(CngPropertyOptions)4;
if (cngKey.HasProperty(NCRYPT_SECURITY_DESCR_PROPERTY, CngPropertyOptions.Persist | DACL_SECURITY_INFORMATION))
                {
                    CngProperty prop = cngKey.GetProperty(NCRYPT_SECURITY_DESCR_PROPERTY,
                        DACL_SECURITY_INFORMATION);
                    sec.SetSecurityDescriptorBinaryForm(prop.GetValue());

                }
               CryptoKeyAccessRule rule =
                new CryptoKeyAccessRule(new SecurityIdentifier(WellKnownSidType.LocalSystemSid, null),
                    CryptoKeyRights.GenericAll, AccessControlType.Allow);



            sec.AddAccessRule(rule);

Expected :- I want to append acceess rule to previously existing default access rules in machine key.
actual:- I am getting an exception 'Invalid Flags specified.!'.
Please suggest.
","","203","<security><encryption><public-key-encryption><pki><cng>","0","","0","2019-06-20 13:25:42","","8","","5061847","","2019-06-20 13:25:42","2019-06-14 09:10:10",""
"48985494","Not able to import back CngKey from raw bytes","I am generating a CngKey using below given powershell code and exporting the key in a file using bytes.
the same created file is not getting imported and getting created as key when run again. It says Bad Data when same is imported again. 
Param(
[string] $keyName,    
[string] $exportPublicKeyFilePath)
function AddAccessToIISUser($filePath)
{
$filePath
[string] $iisUser = ""IIS_IUSRS""
if([System.IO.File]::Exists($filePath))
{

    #Get File Security
    [System.Security.AccessControl.FileSecurity] $fSecurity = [System.IO.File]::GetAccessControl($filePath);

    #Add the FileSystemAccessRule
    [System.Security.AccessControl.FileSystemAccessRule] $accessRule = [System.Security.AccessControl.FileSystemAccessRule]::new($iisUser, [System.Security.AccessControl.FileSystemRights]::FullControl, [System.Security.AccessControl.AccessControlType]::Allow)

    #Add access rule
    $fSecurity.AddAccessRule($accessRule)

    #Set the new access settings.
    [System.IO.File]::SetAccessControl($filePath, $fSecurity);  
    Write-Output ""Access to $iisUser is provided on $filePath""  
}
}

TRY{    
[string] $fileName = $exportPublicKeyFilePath
[string] $globalkeyName = $keyName
[string] $cngPropertyName = ""Length""

if($exportPublicKeyFilePath -eq """")
{
        $fileName = ""C:\\Users\\user\\Desktop\\PublicKeyBytes""
}
Write-Output ""Public Key File : $fileName ""

if($keyName -eq """")
{
    $globalkeyName = ""MyWorkplaceEncryptionKey2"";
}
Write-Output ""Global Key : $globalkeyName ""

$isFileExists = [System.IO.File]::Exists($fileName)
$isKeyExists = [System.Security.Cryptography.CngKey]::Exists($globalkeyName, [System.Security.Cryptography.CngProvider]::MicrosoftSoftwareKeyStorageProvider, [System.Security.Cryptography.CngKeyCreationOptions]::MachineKey)
Write-Output ""CNG Key : $globalkeyName - Exists :: $isKeyExists""
$isKeyExists

if(!$isKeyExists)
{   
    #Create Cng Key Parameter and set its properties
    [System.Security.Cryptography.CngKeyCreationParameters] $cngKeyParameter =  [System.Security.Cryptography.CngKeyCreationParameters]::new()
    $cngKeyParameter.KeyUsage = [System.Security.Cryptography.CngKeyUsages]::AllUsages
    $cngKeyParameter.ExportPolicy = [System.Security.Cryptography.CngExportPolicies]::AllowPlaintextExport

    $cngKeyParameter.Provider = [System.Security.Cryptography.CngProvider]::MicrosoftSoftwareKeyStorageProvider
    $cngKeyParameter.UIPolicy = [System.Security.Cryptography.CngUIPolicy]::new([System.Security.Cryptography.CngUIProtectionLevels]::None)
    $cngKeyParameter.KeyCreationOptions = [System.Security.Cryptography.CngKeyCreationOptions]::MachineKey

    if($isFileExists)
    {
    Write-Output 'true 1'

    $bytes = [System.IO.File]::ReadAllBytes((""C:\\Users\\user\\Desktop\\PublicKeyBytes""))
    #[System.Security.Cryptography.CngKey]::Import($bytes, [System.Security.Cryptography.CngKeyBlobFormat]::Pkcs8PrivateBlob)
    }
    else{
    Write-Output 'false 1'
    $bytes = [System.BitConverter]::GetBytes(2048)
    }
    #$bytes

    #Create Cng Property for Length, set its value and add it to Cng Key Parameter
    [System.Security.Cryptography.CngProperty] $cngProperty = [System.Security.Cryptography.CngProperty]::new($cngPropertyName, $bytes, [System.Security.Cryptography.CngPropertyOptions]::None)
    $cngProperty
    $cngKeyParameter.Parameters.Add($cngProperty)
    $cngKeyParameter
    #Create Cng Key for given $keyName using Rsa Algorithm
    [System.Security.Cryptography.CngKey] $key = [System.Security.Cryptography.CngKey]::Create([System.Security.Cryptography.CngAlgorithm]::Rsa, $globalkeyName, $cngKeyParameter)

    Write-Output ""CNG Key : $globalkeyName - Created with below given properties""
    $key

    #Delete exportedKeyFile, re-create it and Write key bytes to it
    if($isFileExists)
    {
    Write-Output ""File $fileName exist - deleting  file""
        [System.IO.File]::Delete($fileName)



       # [System.IO.File]::WriteAllBytes($fileName, $key.Export([System.Security.Cryptography.CngKeyBlobFormat]::Pkcs8PrivateBlob));

    }
    else
    {
        Write-Output ""File $fileName doesn't exist - creting file""
        [System.IO.File]::WriteAllBytes($fileName, $key.Export([System.Security.Cryptography.CngKeyBlobFormat]::Pkcs8PrivateBlob));

    }

    Write-Output ""Allow access to IIS User - IIS_USRS on exported key file  ""
    #Allow access to IIS User - IIS_USRS on exported key file
    AddAccessToIISUser($env:ProgramData + ""\Microsoft\Crypto\Keys\"" + $key.UniqueName)        
}
else
{
Write-Output ""opening key - $fileName  ""
    [System.Security.Cryptography.CngKey] $key = [System.Security.Cryptography.CngKey]::Open($globalkeyName, [System.Security.Cryptography.CngProvider]::MicrosoftSoftwareKeyStorageProvider, [System.Security.Cryptography.CngKeyCreationOptions]::MachineKey)

    #Delete exportedKeyFile, re-create it and Write key bytes to it
    if($isFileExists)
    {
        [System.IO.File]::Delete($fileName)
        [System.IO.File]::WriteAllBytes($fileName, $key.Export([System.Security.Cryptography.CngKeyBlobFormat]::Pkcs8PrivateBlob));
    }
    else
    {
        Write-Output ""File $fileName doesn't exist""
        [System.IO.File]::WriteAllBytes($fileName, $key.Export([System.Security.Cryptography.CngKeyBlobFormat]::Pkcs8PrivateBlob));
    }

    #Allow access to IIS User - IIS_USRS on exported key file
    AddAccessToIISUser($env:ProgramData + ""\Microsoft\Crypto\Keys\"" + $key.UniqueName)


    $key.Delete()
}  
}
CATCH{
Write-Output ""CNG Key for RSA encryption not created""
$_.Exception.Message
throw $_.Exception
}

I am generating a CngKey using below given powershell code and exporting the key in a file using bytes.
the same created file is not getting imported and getting created as key when run again. It says Bad Data when same is imported again. 
","","189","<c#><powershell><security><powershell-3.0><cng>","0","","0","2018-02-26 09:47:14","","2","","","","","2018-02-26 09:47:14",""
"24141360","Endianness of BcryptSignHash output signature","The private and public key blobs generated by BcryptGenerateKeyPair are big-endian encoded (http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx).
Using these keys, i sign a data using BcryptSignHash and generate a 64-byte signature which ideally should be (r,s). Is this signature also big-endian encoded?
I need this information to extract r and s from 64-byte signature. I am assuming 64-byte signature to be concatenation of r (first 32 bytes) and s (last 32 bytes).
Please correct me if am wrong
","For DSA signatures, yes the signature output from BCryptSignHash is as you describe, namely (r,s) in big-endian format.
(I've had to extract these values in the past when interoperating with OpenSSL).
","180","<cryptoapi><cng><libgcrypt>","1","1","1","2015-01-24 14:09:57","","0","","","","","2014-06-10 12:46:07",""
"40984950","Mapping of access mask in DACL for CNG keys","(Note: IMO the question is mainly about WinAPI and DACL and not about CNG, so please read on!)
I'm currently trying to modify the sample CNG key storage provider of Microsoft's Cryptographic Provider Development Kit in such a way that it does not store the keys in single files. However, I'm in trouble with the security descriptors that can be assigned to the private keys.
In the Certificates Snap-in of the Windows Server Management Console, private keys of certificates can be managed, i.e. the owner, DACL and SACL of a key can be changed, which results in a NCryptSetProperty call with a security descriptor as parameter. For the DACL, the snap-in only allows to allow/deny ""full control"" or ""read"", which results in the GENERIC_ALL or GENERIC_READ bit to be set in the access mask of the ACE.
As I have learnt, these generic bits need to be mapped to application specific rights - otherwise AccessCheck will not work. But do I really need to do this by hand???
CreatePrivateObjectSecurity+SetPrivateObjectSecurity does not always work since CreatePrivateObjectSecurity is very picky about the owner and group in the input security descriptor. Moreover, when the mapping is applied, the generic bits are cleared in the access mask, which results in the snap-in showing wrong settings (as I said, the snap-in only considers the GA and GR bits when displaying current permissions).
Seems I'm missing some pieces here...
","in your CPSetProvParam implementation for PP_KEYSET_SEC_DESCR you got address of a SECURITY_DESCRIPTOR, which you need somehow apply to your private key storage. if your storage based on file(s) or registry key(s) ( in principle any kernel object type, but what more can be used here ?) you need call SetKernelObjectSecurity with file or key HANDLE (which must have WRITE_DAC access) (may be multiple time if you say have multiple files for store single key). in kernel GENERIC access to object will be auto converted to object specific rights. 
if your implementation of storage not direct based on some kernel object, but custom - you need yourself at this point convert GENERIC access (0xF0000000 mask) to specific access rights (0x0000FFFF mask)
__________________ EDIT ____________________
after more check i found that provider must not only convert generic to specific access in CPSetProvParam but also convert specific to generic in CPGetProvParam despite this not directly point in documentation.
this is how MS_ENHANCED_PROV (implemented in rsaenh.dll) approximately do this:
void CheckAndChangeAccessMask(PSECURITY_DESCRIPTOR SecurityDescriptor)
{
    BOOL bDaclPresent, bDaclDefaulted;
    PACL Dacl;
    ACL_SIZE_INFORMATION asi;

    if (
        GetSecurityDescriptorDacl(SecurityDescriptor, &bDaclPresent, &Dacl, &bDaclDefaulted) 
        &&
        bDaclPresent
        &&
        Dacl
        &&
        GetAclInformation(Dacl, &asi, sizeof(asi), AclSizeInformation)
        &&
        asi.AceCount
        )
    {

        union{
            PVOID pAce;
            PACE_HEADER pah;
            PACCESS_ALLOWED_ACE paa;
        };

        do 
        {
            if (GetAce(Dacl, --asi.AceCount, &pAce))
            {
                switch (pah->AceType)
                {
                case ACCESS_ALLOWED_ACE_TYPE:
                case ACCESS_DENIED_ACE_TYPE:
                    ACCESS_MASK Mask = paa->Mask, Gen_Mask = 0;

                    if (Mask & FILE_READ_DATA)
                    {
                        Gen_Mask |= GENERIC_READ;
                    }

                    if (Mask & FILE_WRITE_DATA)
                    {
                        Gen_Mask |= GENERIC_ALL;
                    }

                    paa->Mask = Gen_Mask;
                    break;
                }
            }
        } while (asi.AceCount);
    }
}

so FILE_READ_DATA converted to GENERIC_READ and FILE_WRITE_DATA to GENERIC_ALL (this is exactly algorithm) - however you can look yourself code of rsaenh.CheckAndChangeAccessMask (name from pdb symbols)
rsaenh first get SD from file by GetNamedSecurityInfoW (SE_FILE_OBJECT) and then convert it specific to generic access.
here the call graph and modified DACL (in the top-right, modified ACCESS_MASK in red color)

","180","<winapi><permissions><cng><dacl>","0","0","1","2016-12-07 20:42:41","","0","","","","","2016-12-05 23:03:40",""
"27016172","BCrypt obtain symmetric key from BCRYPT_KEY_HANDLE","Hence given a BCRYPT_KEY_HANDLE (Lets say from the BCryptEncrypt function) is it possible to obtain the 'Master secret' or the 'SymmetricKey' to see SSL stream on wireshark un encrypted?
","","178","<ssl><winapi><encryption><wireshark><cng>","1","","0","2019-05-25 18:36:55","","2","0","12597","","2019-05-25 18:36:55","2014-11-19 11:51:49",""
"40812124","Building a private CngKey(ECDH_P384) from a passphrase","Context: VS 2015 winforms, Windows 7, using SecurityDriven Inferno library.
I'm coding an offline app which produces encrypted files to be sent as email attachments (thus not used in a client-server context). The files are first encrypted with Inferno(ETM_Transform), then sent with (sometimes, to reset password) another file, handling DHM key exchange.
The public key of each user is stored in a datatable created and persisted by the app, allowing quick access during key exchange process. For the private key, however, my problem is that the users (including myself) would prefer to recreate their private key from a pass phrase, eliminating the need to hide the key away, increasing security and portability. So I would need to build a key from the stored public key and the hashed pass phrase.
Is this a sound approach or perhaps there's a better one for this specific context?
Here is a very short code example which throws the exception: ""The requested operation is not supported"". How should I proceed to import the data into the key?
    internal static void CreateKey(string passPhrase)
    {
        byte[] keyType = new byte[] { 0x45, 0x43, 0x4B, 0x34 };
        byte[] keyLength = new byte[] { 0x30, 0x0, 0x0, 0x0 };            

        CryptoRandom cr = new CryptoRandom(); // rng used for this example
        byte[] prKey = cr.NextBytes(48); // salt+hash passphrase and pass it to the private key part
        byte[] pbKey = cr.NextBytes(96); // the public part, if I understand the format correctly for a cngkey using ECDH_P384
        byte[] blob = Utils.Combine(keyType, keyLength); // same as concat
        blob = Utils.Combine(blob, pbKey, prKey);

        CngKey key = CngKey.Import(blob, CngKeyBlobFormat.EccPrivateBlob);                        
    }

","You can't randomly generate the public key. The public key is calculated from the private key (and the curve), and you are likely getting an error that a) the public X does not match what is expected from the private key, and b) that the Y coordinate is incorrect for the given X coordinate.
You would need to compute the value of a public key from your chosen private key. As far as I know, neither .Net nor Windows CNG expose that functionality.
","169","<c#><encryption><cng>","2","2","2","2016-12-05 19:23:55","40816509","0","","5795643","","2016-11-25 21:50:50","2016-11-25 20:49:47",""
"40812124","Building a private CngKey(ECDH_P384) from a passphrase","Context: VS 2015 winforms, Windows 7, using SecurityDriven Inferno library.
I'm coding an offline app which produces encrypted files to be sent as email attachments (thus not used in a client-server context). The files are first encrypted with Inferno(ETM_Transform), then sent with (sometimes, to reset password) another file, handling DHM key exchange.
The public key of each user is stored in a datatable created and persisted by the app, allowing quick access during key exchange process. For the private key, however, my problem is that the users (including myself) would prefer to recreate their private key from a pass phrase, eliminating the need to hide the key away, increasing security and portability. So I would need to build a key from the stored public key and the hashed pass phrase.
Is this a sound approach or perhaps there's a better one for this specific context?
Here is a very short code example which throws the exception: ""The requested operation is not supported"". How should I proceed to import the data into the key?
    internal static void CreateKey(string passPhrase)
    {
        byte[] keyType = new byte[] { 0x45, 0x43, 0x4B, 0x34 };
        byte[] keyLength = new byte[] { 0x30, 0x0, 0x0, 0x0 };            

        CryptoRandom cr = new CryptoRandom(); // rng used for this example
        byte[] prKey = cr.NextBytes(48); // salt+hash passphrase and pass it to the private key part
        byte[] pbKey = cr.NextBytes(96); // the public part, if I understand the format correctly for a cngkey using ECDH_P384
        byte[] blob = Utils.Combine(keyType, keyLength); // same as concat
        blob = Utils.Combine(blob, pbKey, prKey);

        CngKey key = CngKey.Import(blob, CngKeyBlobFormat.EccPrivateBlob);                        
    }

","CngKey DHM blob has a specific format which includes a header - it is not a mere random byte array. You are missing that header, which is why you get an exception. Be glad that you get an exception, since what you're attempting to do is conceptually wrong. ECDH_P384 is not designed for every random private-key combination to be a valid/proper private key. You should not hand-generate a CngKey - leave CngKey generation to corresponding CngKey methods.
curve25519, on the other hand, is designed for any random private-key to be valid. You can look at reinventing or reimplementing Minilock.
","169","<c#><encryption><cng>","2","1","2","2016-12-05 19:23:55","40816509","0","","5795643","","2016-11-25 21:50:50","2016-11-25 20:49:47",""
"52863913","Opening Encryption Key Works in Powershell Not in C#","I am opening an encryption key stored in an HSM. I have the HSM's client library installed on my machine. If I run the following Windows Powershell snippet:
##Open an existing Key
$keyName = 'foo'
$providername = 'SafeNetProtectApp Key Storage Provider'
$provider = New-Object 'System.Security.Cryptography.CngProvider' -ArgumentList $providername
$key = [System.Security.Cryptography.CngKey]::Open($keyName, $provider)

It works.
If I attempt to compile the following C# snippet:
using System.Security.Cryptography;

namespace SaveSecret
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("">>> Starting application <<<"");

            string keyName = ""foo"";
            string providerName = ""SafeNetProtectApp Key Storage Provider"";
            CngProvider provider = new CngProvider(providerName);
            CngKey key = null;
            key = CngKey.Open(keyName, provider);

            System.Console.Write(""[Hit Enter to Continue]"");
            System.Console.ReadLine();
        }
    }
}

I get the following exception:
System.Security.Cryptography.CryptographicException
  HResult=0x8009001E
  Message=Provider DLL could not be found.

  Source=System.Core
  StackTrace:
   at System.Security.Cryptography.NCryptNative.OpenStorageProvider(String providerName)
   at System.Security.Cryptography.CngKey.Open(String keyName, CngProvider provider, CngKeyOpenOptions openOptions)
   at System.Security.Cryptography.CngKey.Open(String keyName, CngProvider provider)

I'm confused why I can open the key using the same libraries in Powershell without an issue. On the same machine, if I attempt the action in C#, I get an exception. Can anyone explain why this is happening?
Additional facts...

Project doesn't target .NET Core
Compiling C# Console App in Visual Studio 2017 Shell

","The project I wrote was targeting the wrong processor architecture. The provider library was 64-bit, but my project was targeting 32-bit. I changed my project to target a 64-bit executable, and it worked.

Thanks for the help all!
","164","<c#><powershell><cng>","1","0","1","2018-10-18 13:45:54","52875503","4","","8803234","","2018-10-18 13:13:56","2018-10-17 21:30:36",""
"53171248","Microsoft MSCAPI-CSP and CNG compatibility","We have previously developed an RSA MSCAPI CSP for use with the classical Windows crypto API and this has worked fine for years. Unfortunately, newer versions of Outlook refuse to work with this CSP in the case of AES encryption. It still supports 3DES but not AES. This is quite bizarre because it is actually not the CSP which handles the symmetric decryption, but apparently Microsoft doesn't want to support the AES-case for MS-CAPI. For AES-support, the RSA key needs to be in a newer provider type namely a Key Storage Provider conforming to the CNG framework.
OK fine, but here's the rub: How can I ensure backwards-compatibility for clients that have software that relies on the MS-CAPI interface?
According to my understanding (which could be wrong), the certificate store is the same for MSCAPI and CNG. The difference comes in in terms of how the private key is referenced. The certificate has an attribute ""CERT_KEY_PROV_INFO_PROP_ID"" containing a number of fields including provider name, container name and provider type. If provider type is ""0"" (which was not a legal value in the old API) it indicates that the provider specified is actually one of the new CNG providers.
An old application will use the values from CERT_KEY_PROV_INFO_PROP_ID to acquire a crypto context using the legacy functions, i.e. CryptAcquireContext().  However, this function fails in the case of a CNG provider (i.e. provider type = 0) - here it seems the program will have to use the new CNG functions i.e. NCryptOpenStorageProvider, NCryptOpenKey etc. again passing in the values from CERT_KEY_PROV_INFO_PROP_ID. So if this understanding/testing is correct it means it is not possible to migrate to a CNG provider and still have the same certificates/keys working from the point-of-view of legacy application programs. I have not been able to find this stated explicitly in the documentation, but it seems each application program which will need to look at the CERT_KEY_PROV_INFO_PROP_ID content, and have a switch: If it is provider type = 0, this is a key in a CNG provider so the program will use the new CNG functions. On the other hand, if provider type is > 0 the program should use the legacy functions. But of course, a legacy program will not have this logic and will thus fail in case of the keys in CNG providers. Meaning it is not possible to satisfy the needs of both new and legacy programs because you have to either put in a reference to a legacy provider og a new provider in CERT_KEY_PROV_INFO_PROP_ID, but you can't have both. And Outlook only wants a reference to a new provider, and old programs can only work with old providers.
But can this really be so, or is there some thing I am missing or some error in my understanding? It seems there would have been multiple ways for Microsoft to help programs have some type of interoperability (for instance so old programs could use the new KSP's using the old API).
","There's to my knowledge no solution that can solve the problem exactly as stated. BUT the new CNG API provides a function NCryptTranslateHandle() that a program can use to translate an old-style reference from CERT_KEY_PROV_INFO_PROP_ID to a handle to a corresponding KSP. When the KSP registers itself it can specify one or more ""aliases"" i.e. names of classic MS-CAPI providers it is aliases for. If a program then calls the NCryptTranslateHandle() handle on a handle from the classic MS-CAPI CSP, Windows will look to see if there's an installed KSP that has registered itself as an alias of that CSP. If so, the handle will get translated into a handle for the corresponding CSP. The program can then go on and use the new CNG functions on that handle, which will invoke the new provider.
So what to do: 1) Keep the CERT_KEY_PROV_INFO_PROP_ID reference in the certificate  what it is now (i.e. pointing to old CSP), 2) Register a KSP provider that has the old CSP as alias (don't have the SDK in front of me now but it is one of the registration parameters you can provide. Let me know if you can't find it!).
What is a bit unsatisfactory about this is that it all rests on the calling program calling the NCryptTranslateHandle() handle. An old legacy program - written before the advent of CNG - obviously won't call this function, since the function didn't exist when it was developed. But Microsoft Outlook (at least newer functions) - which is a very common use case - does know to call this function. So if you offer a dual CSP+KSP solution as I described in the previous paragraphs, it will work out alright: Outlook will end up calling your solution via the KSP API, due to its use of the translate functions.
When implementing the solution you should write a program to test it before testing with Outlook. Let the program get a handle to the key the old-fashioned way, and then use the translation function and see you get a handle, then use the KSP functions on the resulting handle.
","162","<cng><mscapi>","0","0","1","2019-08-05 19:19:46","57364876","3","","","","","2018-11-06 11:44:40",""
"36974545","Random numbers for Windows Phone 8 and Windows Store 8?","I'm struggling with a port of a couple of security libraries to the Windows Phone 8 and Windows Store 8 platform. I need a function which provides random numbers.
Win32 has CryptGenRandom and even RtlGenRandom. Windows Store 10 and Universal Windows has BCryptGenRandom. However, there's a hole for Windows Phone 8 and Windows Store 8 because CryptoAPI is not available, and CNG is only available on Windows 10 and Universal Windows. The MSDN docs say BCryptGenRandom is available for ""Windows Store"", but they don't say its Windows Store 10 and UWP (thanks CW).
The libraries are unmanaged C/C++. They are written in standard/portable C and C++. On occasion, they have to use a OS specific API like those for gathering random number. They don't compile against managed APIs, and they don't link to managed libraries.
What do we use for random numbers for Windows Phone 8 and Windows Store 8?
","In WP8.1 and Windows 8+ we are using CryptographicBuffer.GenerateRandomNumber
","160","<windows-phone-8><random><windows-store-apps><cryptoapi><cng>","0","1","1","2016-05-05 09:00:59","","0","","-1","","2017-05-23 10:31:35","2016-05-02 03:24:40",""
"37428233","DTLS 1.2 Master key derivation","I am implementing DTLS 1.2 and using cipher TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
I am creating pre-master secret and master secret key using following steps
1- Open algorithm provider using API BCryptOpenAlgorithmProvider
2- Generate key pair using API BCryptGenerateKeyPair
3- Than export public key using API BCryptExportKey
4- Than import other party public key using API BCryptImportKeyPair
5- After that generate secret agreement handle using my private key and other party public key by using API BCryptSecretAgreement
6- Finally get secret key using API BCryptDeriveKey
Am i missing something because my master key is not correct.
","I guess it all depends on the parameters you are passing to BCryptDeriveKey.
You should specify the TLS 1.2 pseudorandom function in the parameters which is based on SHA256 and not on MD5 and SHA1 as TLS 1.1 / DTLS 1.0.
","150","<ssl><visual-c++><tls1.2><cng><dtls>","-1","1","1","2019-05-25 18:39:15","","0","","12597","","2019-05-25 18:39:15","2016-05-25 05:07:04",""
"57265305","HSM decryption + encryption chaining","My application is acting as a switchboard to transfer very sensitive messages between two parties and I'm trying to figure out how I can do this without ""looking"" at the message they're trying to send. 
I have a HSM, and I've generated a keypair for the sender - they're going to encrypt the message with their public key that I gave them, and I can decrypt the message using the private key I have in the HSM. 
I'm going to then pass that message on by encrypting it with the public key of the ultimate receiver, which I have. 
Is there any way to chain these two operations inside the HSM, without having the decrypted message anywhere near my application memory? I would like the plaintext content to never leave the boundaries of the HSM.
I know that some HSMs have a CodeSafe / SEE machine feature that lets me write embedded system code and run it inside the HSM, before I get into that I'd like to see if there's a way using the general PKCS / JCE / CNG APIs to do this safely.
","If all you need is to re-encrypt the same secret under a different key, you can use C_Unwrap to create a temporal HSM object with value of the translated secret and then use C_Wrap to encrypt the value of this temporal HSM object for all the recipients.
This way the secret will never leave HSM.
Something like this (verified to be working on SafeNet Luna 7 with RSA-OAEP):
// Your private key for 'decrypting' secret. Must have key unwrapping allowed
CK_OBJECT_HANDLE hsmPrivateKey = ... ;

// Encrypted secret
byte[] wrappedKey = ... ; // 

// Template for temporal generic secret key with value of the secret
CK_ATTRIBUTE[] tempTemplate = new CK_ATTRIBUTE[] {
        new CK_ATTRIBUTE(CKA.CLASS, CKO.SECRET_KEY),
        new CK_ATTRIBUTE(CKA.KEY_TYPE, CKK.GENERIC_SECRET),
        new CK_ATTRIBUTE(CKA.TOKEN, false),
        new CK_ATTRIBUTE(CKA.PRIVATE, true),
        new CK_ATTRIBUTE(CKA.EXTRACTABLE, true),
        new CK_ATTRIBUTE(CKA.SENSITIVE, true),
        new CK_ATTRIBUTE(CKA.ENCRYPT, false),
        new CK_ATTRIBUTE(CKA.DECRYPT, false),
        new CK_ATTRIBUTE(CKA.WRAP, false),
        new CK_ATTRIBUTE(CKA.UNWRAP, false),
        new CK_ATTRIBUTE(CKA.SIGN, false),
        new CK_ATTRIBUTE(CKA.VERIFY, false),
        new CK_ATTRIBUTE(CKA.DERIVE, false)
};

// Unwrapping/decryption mechanism
CK_MECHANISM mechanism = ... ;

// Handle for temporal generic secret key with value of the secret
CK_OBJECT_HANDLE temporalValueHandle = new CK_OBJECT_HANDLE();

// Unwrap/decrypt the secret into temporal key
CryptokiEx.C_UnwrapKey(session, mechanism, hsmPrivateKey, wrappedKey, wrappedKey.length, tempTemplate, tempTemplate.length, temporalValueHandle);

// Wrap/encrypt the secret for recipients. Recipient public keys must have key wrapping allowed
for(CK_OBJECT_HANDLE recipientPublicKey : ... ) {
    LongRef resSize = new LongRef(0);
    CryptokiEx.C_WrapKey(session, mechanism, recipientPublicKey, temporalValueHandle, null, resSize);
    byte[] rewrappedKey = new byte[CryptokiUtils.safeIntCast(resSize.value)];
    CryptokiEx.C_WrapKey(session, mechanism, recipientPublicKey, temporalValueHandle, rewrappedKey, resSize);
    System.out.println(""Re-wrapped key: "" + bytesToHexString(rewrappedKey));
}

// Delete temporal generic secret key
CryptokiEx.C_DestroyObject(session, temporalValueHandle);

Good luck!
","143","<encryption><pkcs#11><jce><hsm><cng>","2","0","1","2019-08-04 15:12:06","","12","1","","","","2019-07-30 06:10:46",""
"39314596","C++ - Decrypting without encryption size","I've looked for a while and I have not found the solution to this problem. I am using BCryptDecrypt to decrypt my encrypted data but it requires the size of the EncryptedData, How are you able to decrypt without knowing the size?
I know BCryptEncrypt gives you the length after it has successfully encrypted the data, the only way I know how I would be able to is send it with the encrypted data / IV.
For example: Let's say I were to encrypt data and then send it over a socket with the IV to my WinSock server that would decrypt the data. How would that server be able to decrypt it without knowing the size? even though it knows the Key and IV.
Thanks
","If size is required, I see two ways to get it:

Send it explicitly together with the encrypted data.
Buffer all data on server side until it is received completely. Keep track of how many bytes you received.

With first, you could try something like this:
<number of bytes to follow><separator symbol><message data>

Second requires that you are able to detect the end of the message properly. You could detect this via a specific message end sequences. Then, however, you need to escape such a sequence within the message, if it appears. Something similar to how characters are escaped in C/C++/Java/C#... If not chosing the first approach, which appears the simplest to me, this is what I would probably prefer against the variant below...
An alternative might be closing the connection after a message is complete. Then, however, you need to detect if the connection was closed regularly or if it got broken, because in the latter case, you must not try to decode...
You might even combine both approaches:
<message start sequence>
<number of bytes to follow>
<separator symbol>
<encrypted data>
<message end sequence>

Both message start sequence and message end sequence would have to be escaped. If you detect message start sequence then within the encrypted data, or message end sequence before number of bytes have been read, you know on server side, that something has gone badly wrong...
","142","<c++><cng>","1","0","1","2019-05-25 18:37:15","39314788","3","","12597","","2019-05-25 18:37:15","2016-09-04 07:34:03",""
"48511954","Porting code from CryptoAPI to CNG","I started writing code in CryptoAPI in unmananaged C++ to:

Create private keys
Create self signed certificate (CA)
Create CSRs
Process CSRs and sign with private CA to make certificates
So most of the PKI...CryptoAPI is being depreciated so now I now port it all to CNG before the ship sinks. This provides mostly reference information:

https://msdn.microsoft.com/en-us/library/windows/desktop/bb204779(v=vs.85).aspx
But what are the major architectural differences and gotchas? From what I can tell they splitted out some of the provider/agorithm stuff and changed function names to make it work better with FIPS but that's all that stood out. What do I need to look out for? There are hardly any CNG code samples.
","","141","<cryptoapi><cng>","1","","0","2018-01-30 00:01:29","","0","","","","","2018-01-30 00:01:29",""
"54827993","Error importing RSA Public Key with BCryptImportKeyPair","I'm trying to use Microsofts CNG to verify a Signature in Delphi 2007.
I got stuck importing the public key with BCryptImportKeyPair.
I always get a STATUS_INVALID_PARAMETER Error.
The Code looks like this:
var
   i: Smallint;
   LResult: NTSTATUS;
   LRSA: BCRYPT_ALG_HANDLE;
   LKey: BCRYPT_KEY_HANDLE;
   LRsaKeyBlob: ^BCRYPT_RSAKEY_BLOB;
   LKeyInput: Pointer;
   LKeyCurrent: PByte;
   LKeySize: DWORD;
begin
   LRSA := 0;
   LKey := 0;

   LKeySize := SizeOf(BCRYPT_RSAKEY_BLOB) + 259; // 3 Bytes Exponent + 256 Bytes Modulus
   LKeyInput := GetMemory(LKeySize);
   try
      ZeroMemory(LKeyInput, LKeySize);

      LRsaKeyBlob := LKeyInput;
      LRsaKeyBlob.Magic := BCRYPT_RSAPUBLIC_MAGIC;
      LRsaKeyBlob.BitLength := 2048;
      LRsaKeyBlob.cbPublicExp := 3;
      LRsaKeyBlob.cbModulus := 256;
      LRsaKeyBlob.cbPrime1 := 0;
      LRsaKeyBlob.cbPrime2 := 15;

      LKeyCurrent := PByte(LKeyInput);
      Inc(LKeyCurrent, SizeOf(BCRYPT_RSAKEY_BLOB));
      for i := 0 to 2 do
      begin
         LKeyCurrent^ := CExponent[i];
         Inc(LKeyCurrent);
      end;
      for i := 0 to 255 do
      begin
         LKeyCurrent^ := CModulus[i];
         Inc(LKeyCurrent);
      end;

      LResult := BCryptOpenAlgorithmProvider(LRSA, BCRYPT_RSA_ALGORITHM, nil, 0);
      if not BCRYPT_SUCCESS(LResult) then Exit;
      LResult := BCryptImportKeyPair(LRSA, nil, BCRYPT_RSAPUBLIC_BLOB, LKey, PUCHAR(LKeyInput), LKeySize, 0);
      if not BCRYPT_SUCCESS(LResult) then Exit;

      ShowMessage('Yeah!');
   finally
      FreeMem(LKeyInput);
   end;
end;

I generated the Public/Private-Key pair in another Application (node.js-Backend).
The Problem I think is, that the Modulus may be incorrect. I saved the Public-Key as a PEM-File and converted it to an XML. (Used an Online-Service for this) This XML-File works perfeclty fine with an C#-Test-Application. I then converted the Base64 Modulus- and Exponent-Strings into HEX-Values and added them as constants to my Delphi-App.
","","131","<delphi><rsa><public-key><delphi-2007><cng>","0","","0","2019-02-22 13:59:09","","0","","6375322","","2019-02-22 13:59:09","2019-02-22 13:15:28",""
"56051834","Signing data in c++ app using CNG and verifying in php api","I read a lot about asymmetric encryption and still can't understand how is the step by step process to achieve what I need.
What I need:

Create 1 Private and 1 Public key only once.
Include the private key in my C++ app without the user being able to read it (ofc everything can be hacked, but you know what I mean, don't let the user see it in plain text).
Distribute the app.
Then my app, when used, will Hash an string.
Encrypt this hash with the included private key.
Send this signed hash to my api using an http request.
Decrypt the signed hash in my api (php) using my Public Key.

What I don't understand:
Using the example here: Signing Data with CNG I don't get how can I create the keys once then store the private one in my c++ app and the public one in my api (php).
What I achieved
I learned to hash and encrypt/decrypt data using bCrypt but I don't understand what steps I have to do to achieve what I wrote before
","You have to change the design. Currently you design has a major security flaw. You got the concepts of the pubkey/prikey correct, but the implementation is incorrect. The private key should be kept private. Currently it is easy to derive the public key, given the private key for a lot of algorithms, but not the other way around. The right design is as follows.

Generate a self-signed certificate. This certificate will contain private and public key
Export the public certificate and embed it as resource/or hardcode it in your application that you are going to distribute
The application will then hash the data to be signed and use the public key from the application resource.
This hashed data is then sent over the http to your server that has the copy of private key.
The server will hash the data and verify the hash with the private key.

All of the above steps are well documented with samples on MSDN. If you need further help, let me know and I can point it to the articles.
The above design will make sure that your private key is never in the wild. If you distribute your private key in your application, it will take literally only few minutes to get your private key.
Storing the public key in the application is just the matter of either hardcoding the key in the application using byte array or putting the certificate in the resource file.
The private key portion of the key pair should never be hardcoded in any application. The private key should be non exportable and be managed by the operating system only. Windows now has keyguard that uses VSM technology that makes it impossible for even the local administrator to know the private key. The admin can only use it for signing and verifying (and exporting the key, if exporting is enabled) but never be able to look at the private key and misuse it.
Regarding step by step process.

Create a self-signed certificate. This will generate a certificate with both public and private key in the pfx file.
Import the self-signed certificate in the certificate store. This can be achived by simply double-clicking on the file and following the directions.
Export the public portion of newly imported certificate from by opening the certificate manager.
You can embed this public exported certificate in your application as a resource.
The application can then load the certificate from the resource and use it to sign the hash.
On the server side, if the certificate with private key is not already imported, follow the step 2 to import it.
Server can then use the Apis to verify the signed data using private key.

","129","<php><c++><winapi><public-key-encryption><cng>","1","0","1","2019-05-17 22:12:28","56191239","4","1","11467293","","2019-05-09 03:49:31","2019-05-09 03:40:14",""
"50856998","Can someone explain C# CngKey.Import please?","I'm encrypting a db using Always Encrypted with the master key in the software ksp.
The key is created with CngKey.Create, I can also export it, but I'm stuck after that. Using the CngKey.Import creates a non-named key, meaning IsEphemeral=true, so the key gets destroyed when there is no more handles.
How can I'm import the key as a named key that will be persisted?
The ultimate goal is to be able to export the key used as the master encryption key with the db and give that along with the db backup to party x who wants to use the db. The tool should then recreate the key in party x's machine.
","CnhKey.Create has an overload that takes a name.
The linked documents say:

If keyName is provided, this overload creates a persisted key

","120","<c#><security><encryption><cng>","0","0","2","2018-06-14 15:42:26","50861324","0","","","","","2018-06-14 11:56:33",""
"50856998","Can someone explain C# CngKey.Import please?","I'm encrypting a db using Always Encrypted with the master key in the software ksp.
The key is created with CngKey.Create, I can also export it, but I'm stuck after that. Using the CngKey.Import creates a non-named key, meaning IsEphemeral=true, so the key gets destroyed when there is no more handles.
How can I'm import the key as a named key that will be persisted?
The ultimate goal is to be able to export the key used as the master encryption key with the db and give that along with the db backup to party x who wants to use the db. The tool should then recreate the key in party x's machine.
","I believe (based on vague recollection and a similar answer) that you can make Create import at the same time, unless it's an encrypted PKCS#8.
byte[] exported = key.Export(blobType);

Send exported and blobType to somewhere else.
var keyParams = new CngKeyCreationParameters();
// whatever else you want to assign here.

// Add an import to the create step.
keyParams.Properties.Add(new CngProperty(blobType.Format, exported, CngPropertyOptions.None));

CngKey key = CngKey.Create(algorithm, keyName, keyParams);

","120","<c#><security><encryption><cng>","0","1","2","2018-06-14 15:42:26","50861324","0","","","","","2018-06-14 11:56:33",""
"57269726","X509Certificate2.Import with NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG","I have a PFX certificate with CNG key inside (KSP provider information is specified in the PFX). I can't find a way to import the certificate in .NET in the way that would allow private key export in plain text (MS-CAPI format).
var cert = new X509Certificate2(pfxBytes,password,X509KeyStorageFlags.Exportable);

then I use this handle to acquire private key context by calling CryptAcquireCertificatePrivateKey function with enabled flag to allow CNG keys. The call succeeds.
When I call NCryptExportKey, the call fails with 0x8009000b error:

Key not valid for use in specified state.

To debug this, I called NCryptGetProperty function to get export policy and indeed, NCRYPT_ALLOW_EXPORT_FLAG flag is enabled, but NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG is not. Tried to call the NCryptSetProperty function to enable this flag in Export Policy property, but the call fails with the same 0x8009000b error.
The question: how do I import pfx file in .NET from file without persisting the key and enabled NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG flag for CNG keys?
p.s. for some reasons I'm limited to .NET 4.0/4.5.
","The best flow I've found:

Open the PFX Exportable (sets the exportable bit, but not the plaintext exportable bit)
Export encrypted PKCS#8
Import encrypted PKCS#8 with overwrite, no finalize
Change the export policy
Finalize (to commit the overwrite)
Now if you ask the cert for its key it's plaintext exportable.

In net45 this takes a lot of code (thankfully Export private key (PKCS#8) of CNG RSA certificate with oldschool .NET did a lot of the work for me).  netcoreapp30 would do better, except that the import+alter+finalize would still need to be manual P/Invokes.
Tested with ECDsa, since that was the easiest way to force the CNG->CAPI bridge to not be utilized:
internal static partial class Program
{
    internal static void Main(string[] args)
    {
        X509Certificate2 cert = ImportExportable(ECDsaP256_DigitalSignature_Pfx_Windows, ""Test"", machineScope: false);

        try
        {
            bool gotKey = NativeMethods.Crypt32.CryptAcquireCertificatePrivateKey(
                cert.Handle,
                NativeMethods.Crypt32.AcquireCertificateKeyOptions.CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG,
                IntPtr.Zero,
                out SafeNCryptKeyHandle keyHandle,
                out int keySpec,
                out bool callerFree);

            using (CngKey cngKey = CngKey.Open(keyHandle, 0))
            {
                Console.WriteLine(cngKey.ExportPolicy);

                Console.WriteLine(
                    Convert.ToBase64String(
                        cngKey.Export(CngKeyBlobFormat.Pkcs8PrivateBlob)));
            }
        }
        finally
        {
            cert.Reset();
        }
    }

    private static X509Certificate2 ImportExportable(byte[] pfxBytes, string password, bool machineScope)
    {
        X509KeyStorageFlags flags = X509KeyStorageFlags.Exportable;

        if (machineScope)
        {
            flags |= X509KeyStorageFlags.MachineKeySet;
        }
        else
        {
            flags |= X509KeyStorageFlags.UserKeySet;
        }

        X509Certificate2 cert = new X509Certificate2(pfxBytes, password, flags);

        try
        {
            bool gotKey = NativeMethods.Crypt32.CryptAcquireCertificatePrivateKey(
                cert.Handle,
                NativeMethods.Crypt32.AcquireCertificateKeyOptions.CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG,
                IntPtr.Zero,
                out SafeNCryptKeyHandle keyHandle,
                out int keySpec,
                out bool callerFree);

            if (!gotKey)
            {
                keyHandle.Dispose();
                throw new InvalidOperationException(""No private key"");
            }

            if (!callerFree)
            {
                keyHandle.SetHandleAsInvalid();
                keyHandle.Dispose();
                throw new InvalidOperationException(""Key is not persisted"");
            }

            using (keyHandle)
            {
                // -1 == CNG, otherwise CAPI
                if (keySpec == -1)
                {
                    using (CngKey cngKey = CngKey.Open(keyHandle, CngKeyHandleOpenOptions.None))
                    {
                        // If the CNG->CAPI bridge opened the key then AllowPlaintextExport is already set.
                        if ((cngKey.ExportPolicy & CngExportPolicies.AllowPlaintextExport) == 0)
                        {
                            FixExportability(cngKey, machineScope);
                        }
                    }
                }
            }
        }
        catch
        {
            cert.Reset();
            throw;
        }

        return cert;
    }

    internal static void FixExportability(CngKey cngKey, bool machineScope)
    {
        string password = nameof(NativeMethods.Crypt32.AcquireCertificateKeyOptions);
        byte[] encryptedPkcs8 = ExportEncryptedPkcs8(cngKey, password, 1);
        string keyName = cngKey.KeyName;

        using (SafeNCryptProviderHandle provHandle = cngKey.ProviderHandle)
        {
            ImportEncryptedPkcs8Overwrite(
                encryptedPkcs8,
                keyName,
                provHandle,
                machineScope,
                password);
        }
    }

    internal const string NCRYPT_PKCS8_PRIVATE_KEY_BLOB = ""PKCS8_PRIVATEKEY"";
    private static readonly byte[] s_pkcs12TripleDesOidBytes =
        System.Text.Encoding.ASCII.GetBytes(""1.2.840.113549.1.12.1.3\0"");

    private static unsafe byte[] ExportEncryptedPkcs8(
        CngKey cngKey,
        string password,
        int kdfCount)
    {
        var pbeParams = new NativeMethods.NCrypt.PbeParams();
        NativeMethods.NCrypt.PbeParams* pbeParamsPtr = &pbeParams;

        byte[] salt = new byte[NativeMethods.NCrypt.PbeParams.RgbSaltSize];

        using (RandomNumberGenerator rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(salt);
        }

        pbeParams.Params.cbSalt = salt.Length;
        Marshal.Copy(salt, 0, (IntPtr)pbeParams.rgbSalt, salt.Length);
        pbeParams.Params.iIterations = kdfCount;

        fixed (char* stringPtr = password)
        fixed (byte* oidPtr = s_pkcs12TripleDesOidBytes)
        {
            NativeMethods.NCrypt.NCryptBuffer* buffers =
                stackalloc NativeMethods.NCrypt.NCryptBuffer[3];

            buffers[0] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsSecret,
                cbBuffer = checked(2 * (password.Length + 1)),
                pvBuffer = (IntPtr)stringPtr,
            };

            if (buffers[0].pvBuffer == IntPtr.Zero)
            {
                buffers[0].cbBuffer = 0;
            }

            buffers[1] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsAlgOid,
                cbBuffer = s_pkcs12TripleDesOidBytes.Length,
                pvBuffer = (IntPtr)oidPtr,
            };

            buffers[2] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsAlgParam,
                cbBuffer = sizeof(NativeMethods.NCrypt.PbeParams),
                pvBuffer = (IntPtr)pbeParamsPtr,
            };

            var desc = new NativeMethods.NCrypt.NCryptBufferDesc
            {
                cBuffers = 3,
                pBuffers = (IntPtr)buffers,
                ulVersion = 0,
            };

            using (var keyHandle = cngKey.Handle)
            {
                int result = NativeMethods.NCrypt.NCryptExportKey(
                    keyHandle,
                    IntPtr.Zero,
                    NCRYPT_PKCS8_PRIVATE_KEY_BLOB,
                    ref desc,
                    null,
                    0,
                    out int bytesNeeded,
                    0);

                if (result != 0)
                {
                    throw new Win32Exception(result);
                }

                byte[] exported = new byte[bytesNeeded];

                result = NativeMethods.NCrypt.NCryptExportKey(
                    keyHandle,
                    IntPtr.Zero,
                    NCRYPT_PKCS8_PRIVATE_KEY_BLOB,
                    ref desc,
                    exported,
                    exported.Length,
                    out bytesNeeded,
                    0);

                if (result != 0)
                {
                    throw new Win32Exception(result);
                }

                if (bytesNeeded != exported.Length)
                {
                    Array.Resize(ref exported, bytesNeeded);
                }

                return exported;
            }
        }
    }

    private static unsafe void ImportEncryptedPkcs8Overwrite(
        byte[] encryptedPkcs8,
        string keyName,
        SafeNCryptProviderHandle provHandle,
        bool machineScope,
        string password)
    {
        SafeNCryptKeyHandle keyHandle;

        fixed (char* passwordPtr = password)
        fixed (char* keyNamePtr = keyName)
        fixed (byte* blobPtr = encryptedPkcs8)
        {
            NativeMethods.NCrypt.NCryptBuffer* buffers = stackalloc NativeMethods.NCrypt.NCryptBuffer[2];

            buffers[0] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsSecret,
                cbBuffer = checked(2 * (password.Length + 1)),
                pvBuffer = new IntPtr(passwordPtr),
            };

            if (buffers[0].pvBuffer == IntPtr.Zero)
            {
                buffers[0].cbBuffer = 0;
            }

            buffers[1] = new NativeMethods.NCrypt.NCryptBuffer
            {
                BufferType = NativeMethods.NCrypt.BufferType.PkcsName,
                cbBuffer = checked(2 * (keyName.Length + 1)),
                pvBuffer = new IntPtr(keyNamePtr),
            };

            NativeMethods.NCrypt.NCryptBufferDesc desc = new NativeMethods.NCrypt.NCryptBufferDesc
            {
                cBuffers = 2,
                pBuffers = (IntPtr)buffers,
                ulVersion = 0,
            };

            NativeMethods.NCrypt.NCryptImportFlags flags =
                NativeMethods.NCrypt.NCryptImportFlags.NCRYPT_OVERWRITE_KEY_FLAG |
                NativeMethods.NCrypt.NCryptImportFlags.NCRYPT_DO_NOT_FINALIZE_FLAG;

            if (machineScope)
            {
                flags |= NativeMethods.NCrypt.NCryptImportFlags.NCRYPT_MACHINE_KEY_FLAG;
            }

            int errorCode = NativeMethods.NCrypt.NCryptImportKey(
                provHandle,
                IntPtr.Zero,
                NCRYPT_PKCS8_PRIVATE_KEY_BLOB,
                ref desc,
                out keyHandle,
                new IntPtr(blobPtr),
                encryptedPkcs8.Length,
                flags);

            if (errorCode != 0)
            {
                keyHandle.Dispose();
                throw new Win32Exception(errorCode);
            }

            using (keyHandle)
            using (CngKey cngKey = CngKey.Open(keyHandle, CngKeyHandleOpenOptions.None))
            {
                const CngExportPolicies desiredPolicies =
                    CngExportPolicies.AllowExport | CngExportPolicies.AllowPlaintextExport;

                cngKey.SetProperty(
                    new CngProperty(
                        ""Export Policy"",
                        BitConverter.GetBytes((int)desiredPolicies),
                        CngPropertyOptions.Persist));

                int error = NativeMethods.NCrypt.NCryptFinalizeKey(keyHandle, 0);

                if (error != 0)
                {
                    throw new Win32Exception(error);
                }
            }
        }
    }
}

internal static class NativeMethods
{
    internal static class Crypt32
    {
        internal enum AcquireCertificateKeyOptions
        {
            None = 0x00000000,
            CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG = 0x00040000,
        }

        [DllImport(""crypt32.dll"", SetLastError = true)]
        internal static extern bool CryptAcquireCertificatePrivateKey(
            IntPtr pCert,
            AcquireCertificateKeyOptions dwFlags,
            IntPtr pvReserved,
            out SafeNCryptKeyHandle phCryptProvOrNCryptKey,
            out int dwKeySpec,
            out bool pfCallerFreeProvOrNCryptKey);
    }

    internal static class NCrypt
    {
        [DllImport(""ncrypt.dll"", CharSet = CharSet.Unicode)]
        internal static extern int NCryptExportKey(
            SafeNCryptKeyHandle hKey,
            IntPtr hExportKey,
            string pszBlobType,
            ref NCryptBufferDesc pParameterList,
            byte[] pbOutput,
            int cbOutput,
            [Out] out int pcbResult,
            int dwFlags);

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct PbeParams
        {
            internal const int RgbSaltSize = 8;

            internal CryptPkcs12PbeParams Params;
            internal fixed byte rgbSalt[RgbSaltSize];
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct CryptPkcs12PbeParams
        {
            internal int iIterations;
            internal int cbSalt;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct NCryptBufferDesc
        {
            public int ulVersion;
            public int cBuffers;
            public IntPtr pBuffers;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct NCryptBuffer
        {
            public int cbBuffer;
            public BufferType BufferType;
            public IntPtr pvBuffer;
        }

        internal enum BufferType
        {
            PkcsAlgOid = 41,
            PkcsAlgParam = 42,
            PkcsName = 45,
            PkcsSecret = 46,
        }

        [DllImport(""ncrypt.dll"", CharSet = CharSet.Unicode)]
        internal static extern int NCryptOpenStorageProvider(
            out SafeNCryptProviderHandle phProvider,
            string pszProviderName,
            int dwFlags);

        internal enum NCryptImportFlags
        {
            None = 0,
            NCRYPT_MACHINE_KEY_FLAG = 0x00000020,
            NCRYPT_OVERWRITE_KEY_FLAG = 0x00000080,
            NCRYPT_DO_NOT_FINALIZE_FLAG = 0x00000400,
        }

        [DllImport(""ncrypt.dll"", CharSet = CharSet.Unicode)]
        internal static extern int NCryptImportKey(
            SafeNCryptProviderHandle hProvider,
            IntPtr hImportKey,
            string pszBlobType,
            ref NCryptBufferDesc pParameterList,
            out SafeNCryptKeyHandle phKey,
            IntPtr pbData,
            int cbData,
            NCryptImportFlags dwFlags);

        [DllImport(""ncrypt.dll"", CharSet = CharSet.Unicode)]
        internal static extern int NCryptFinalizeKey(SafeNCryptKeyHandle hKey, int dwFlags);
    }
}

","107","<c#><x509certificate><x509certificate2><cng>","1","1","1","2019-08-02 16:37:55","","0","","","","","2019-07-30 10:36:16",""
"56373848","Unresolved external symbol bcrypt_gensalt","I have one problem with library <bcrypt.h>. Compiler say error with function bcrypt_gensalt.
#include <iostream>
#include <bcrypt.h>

using namespace std;

int main() {

    const char* passwd = ""Secret_Password"";

    char results[BCRYPT_HASHSIZE];

    bcrypt_gensalt(10, results);

    system(""pause"");
    return 0;
}

Error from compiler: 
unresolved external symbol bcrypt_gensalt referenced in function main

","You need to reference Bcrypt.lib.
See here: http://msdn.microsoft.com/en-us/library/ba1z7822.aspx.
","105","<c><windows><linker-errors><cng>","0","0","1","2019-08-19 09:44:58","","1","","608639","","2019-08-19 09:44:58","2019-05-30 07:42:11",""
"36470729","How to export the GetHashInterface function?","I'm going to write a simple algorithm provider under CNG (Cryptography Next Generation), exactly an user-mode Hash Provider.
According to the instruction in CNG Development Kit Help ""A hash provider must implement the GetHashInterface function and export it by name"".
To implement an algorithm provider, I need to include the ""bcrypt.h"" file from the CNG Development Kit. This file also define the interface for GetHashInterface function but WITHOUT an export directive, exactly:
__checkReturn
NTSTATUS
WINAPI
GetHashInterface(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_HASH_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG   dwFlags);

If I redefine the function in my header file as an exportable function, for example
#ifndef __CngHashProvider
#define __CngHashProvider
///////////////////////////////////////////////////////////////
#ifndef EXPORT
#define EXPORT extern ""C"" __declspec(dllexport)
#endif

EXPORT NTSTATUS WINAPI GetHashInterface(
    __in   LPCWSTR pszProviderName,
    __in   LPCWSTR pszAlgId,
    __out  BCRYPT_HASH_FUNCTION_TABLE **ppFunctionTable,
    __in   ULONG dwFlags
);

////////////////////////////////////////////////////////////////
#endif __CngHashProvider

I should get an error message:

Error C2375   'GetHashInterface': redefinition; different linkage

If I remove the EXPORT directive (or remove the whole of interface predefinition for the function), the error message should disappear, but the function can not be exported from my DLL.
So please help me, telling me the way to solve the problem to export the needed GetHashInterface function.
","At the moment I ""found"" a way to solve the problem.
I coppied  the file bcrypt.h from the CNG Development Kit to my project folder and then removed the definition of the GetHashInterface function. My project should include the modified header file, but not the original one.
I don't know is it a right way, but it works for me.
","101","<visual-c++><dll><provider><cng>","1","1","2","2018-05-17 10:37:04","","0","","1033581","","2018-05-17 10:37:04","2016-04-07 08:30:27",""
"36470729","How to export the GetHashInterface function?","I'm going to write a simple algorithm provider under CNG (Cryptography Next Generation), exactly an user-mode Hash Provider.
According to the instruction in CNG Development Kit Help ""A hash provider must implement the GetHashInterface function and export it by name"".
To implement an algorithm provider, I need to include the ""bcrypt.h"" file from the CNG Development Kit. This file also define the interface for GetHashInterface function but WITHOUT an export directive, exactly:
__checkReturn
NTSTATUS
WINAPI
GetHashInterface(
    __in    LPCWSTR pszProviderName,
    __in    LPCWSTR pszAlgId,
    __out   BCRYPT_HASH_FUNCTION_TABLE **ppFunctionTable,
    __in    ULONG   dwFlags);

If I redefine the function in my header file as an exportable function, for example
#ifndef __CngHashProvider
#define __CngHashProvider
///////////////////////////////////////////////////////////////
#ifndef EXPORT
#define EXPORT extern ""C"" __declspec(dllexport)
#endif

EXPORT NTSTATUS WINAPI GetHashInterface(
    __in   LPCWSTR pszProviderName,
    __in   LPCWSTR pszAlgId,
    __out  BCRYPT_HASH_FUNCTION_TABLE **ppFunctionTable,
    __in   ULONG dwFlags
);

////////////////////////////////////////////////////////////////
#endif __CngHashProvider

I should get an error message:

Error C2375   'GetHashInterface': redefinition; different linkage

If I remove the EXPORT directive (or remove the whole of interface predefinition for the function), the error message should disappear, but the function can not be exported from my DLL.
So please help me, telling me the way to solve the problem to export the needed GetHashInterface function.
","You can use .def file without the need to edit bcrypt.h. In Visual Studio: Add->New item->Code->Module-definition file.
Just add to this file:
LIBRARY ""yourlibraryname""

EXPORTS

  GetHashInterface = GetHashInterface

","101","<visual-c++><dll><provider><cng>","1","0","2","2018-05-17 10:37:04","","0","","1033581","","2018-05-17 10:37:04","2016-04-07 08:30:27",""
"53507617","CA2202: Object can be disposed of more than once","I'm getting the following warning in the following code snippet but I cannot understand why

warning CA2202: Microsoft.Usage : Object 'memStream' can be disposed more than once in method 'Encrypt(string)'. To avoid generating a System.ObjectDisposedException you should not call Dispose more than one time on an object.

Code:
string Encrypt(string toEncrypt)
{
    byte[] key = ...
    byte[] iv = ...

    using (AesCng aes = new AesCng())
    using (ICryptoTransform encryptor = aes.CreateEncryptor(key, iv))
    using (MemoryStream memStream = new MemoryStream())
    using (CryptoStream cryptoStream = new CryptoStream(memStream, encryptor, CryptoStreamMode.Write))
    {
        UTF7Encoding encoder = new UTF7Encoding();
        byte[] bytes = encoder.GetBytes(toEncrypt);

        cryptoStream.Write(bytes, 0, bytes.Length);
        cryptoStream.FlushFinalBlock();

        return Convert.ToBase64String(memStream.ToArray());
    }
}

The CryptoStream object, to the best of my knowledge, does not dispose of the passed in Stream when it itself is disposed. So how is it possible that the variable memStream can be disposed of more than once?
Many thanks.
","CryptoStream.Dispose() will, by default, dispose the underlying stream. If you don't want that behavior you need to use the constructor overload that explicitly makes the underlying stream remain open when the CryptoStream is disposed.
You can see how that's implemented here.
","92","<c#><cng>","0","2","2","2018-11-27 20:50:38","53507703","3","","5198140","","2018-11-27 20:47:28","2018-11-27 20:28:18",""
"53507617","CA2202: Object can be disposed of more than once","I'm getting the following warning in the following code snippet but I cannot understand why

warning CA2202: Microsoft.Usage : Object 'memStream' can be disposed more than once in method 'Encrypt(string)'. To avoid generating a System.ObjectDisposedException you should not call Dispose more than one time on an object.

Code:
string Encrypt(string toEncrypt)
{
    byte[] key = ...
    byte[] iv = ...

    using (AesCng aes = new AesCng())
    using (ICryptoTransform encryptor = aes.CreateEncryptor(key, iv))
    using (MemoryStream memStream = new MemoryStream())
    using (CryptoStream cryptoStream = new CryptoStream(memStream, encryptor, CryptoStreamMode.Write))
    {
        UTF7Encoding encoder = new UTF7Encoding();
        byte[] bytes = encoder.GetBytes(toEncrypt);

        cryptoStream.Write(bytes, 0, bytes.Length);
        cryptoStream.FlushFinalBlock();

        return Convert.ToBase64String(memStream.ToArray());
    }
}

The CryptoStream object, to the best of my knowledge, does not dispose of the passed in Stream when it itself is disposed. So how is it possible that the variable memStream can be disposed of more than once?
Many thanks.
","You can use overloaded CryptoStream constructor with leaveOpen parameter.
And no need this because CryptoStream object in using block
cryptoStream.FlushFinalBlock();
Code:
string Encrypt(string toEncrypt)
{
    byte[] key = ...
    byte[] iv = ...

    using (AesCng aes = new AesCng())
    using (ICryptoTransform encryptor = aes.CreateEncryptor(key, iv))
    using (MemoryStream memStream = new MemoryStream())
    using (CryptoStream cryptoStream = new CryptoStream(memStream, encryptor, CryptoStreamMode.Write,true))
    {
        UTF7Encoding encoder = new UTF7Encoding();
        byte[] bytes = encoder.GetBytes(toEncrypt);

        cryptoStream.Write(bytes, 0, bytes.Length);

        return Convert.ToBase64String(memStream.ToArray());
    }
}


leaveOpen: true to not close the underlying stream when the CryptoStream object is disposed

CryptoStream ctor
","92","<c#><cng>","0","-1","2","2018-11-27 20:50:38","53507703","3","","5198140","","2018-11-27 20:47:28","2018-11-27 20:28:18",""
"55568012","std::ifstream read file as BYTE (unsigned char) not char","I'm using Microsoft's CNG Cryptography API's to compute the hash of a file, so far all works fine except that computed hash is wrong comparing to hash computed with external 3rd party program.
I'm not 100% sure but I think the problem is that I read the file into signed char array instead of into BYTE (unsigned char) array.
Bellow code is how I read the file now: (note: I omitted error checking code)
std::ifstream file;
file.open(""sample.txt"", std::ifstream::binary | std::ifstream::in | std::ifstream::ate);
const int file_length = file.tellg();

char* data = new char[file_length];
file.seekg(file.beg);
file.read(data, file_length);

Problem with above code is that data is read into signed char array but crypto functions expect unsigned char / BYTE and I'm guessing this is why my computed hash is wrong.
Bellow code is what I would like to do but it doesn't work (added comment) since ifstream::read() method expects char array not unsigned char / BYTE
std::ifstream file;
file.open(""sample.txt"", std::ifstream::binary | std::ifstream::in | std::ifstream::ate);
const int file_length = file.tellg();

PBYTE data = new BYTE[file_length];
file.seekg(file.beg);
file.read(data, file_length); // error PBYTE is incompatibe with char*

So my question is: how do I read data as BYTE not char do I need to use CreateFile API or is there a way with std::ifstream?
Maybe there is something else causing bad computed hash, I don't know if so tell me.
EDIT:
Below is fully working code to compute the SHA256 hash for given file name, but the hash is bad. (ie. not the same as if done with 3rd party hash utility)
#include <windows.h>
#include <bcrypt.h>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>


#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)

std::string ByteToHex(PBYTE data, size_t len)
{
    std::stringstream ss;
    ss << std::hex << std::setfill('0') << std::uppercase;

    for (size_t i = 0; i < len; ++i)
    {
        ss << std::setw(2) << static_cast<short>(data[i]);
    }

    return ss.str();
}

int main()
{
    BCRYPT_ALG_HANDLE hAlg = nullptr;
    BCRYPT_HASH_HANDLE hHash = nullptr;
    DWORD cbHash, cbObject, cbData;
    PBYTE pbHash, pbObject;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    std::ifstream file;
    file.open(""sample.exe"", std::ifstream::binary | std::ifstream::in | std::ifstream::ate);
    const int file_length = file.tellg();

    if (!file.is_open())
    {
        abort();
    }

    PBYTE data = new BYTE[file_length];
    file.seekg(file.beg);
    file.read(reinterpret_cast<char*>(data), file_length);

    status = BCryptOpenAlgorithmProvider(
        &hAlg,
        BCRYPT_SHA256_ALGORITHM,
        nullptr,
        0);

    if (NT_SUCCESS(status))
    {
        status = BCryptGetProperty(
            hAlg,
            BCRYPT_OBJECT_LENGTH,
            reinterpret_cast<PBYTE>(&cbObject),
            sizeof(DWORD),
            &cbData,
            0);
    }
    else
    {
        abort();
    }

    pbObject = reinterpret_cast<PBYTE>(
        HeapAlloc(GetProcessHeap(), 0, cbObject));

    if (!pbObject)
    {
        abort();
    }

    if (NT_SUCCESS(status))
    {
        status = BCryptGetProperty(
            hAlg,
            BCRYPT_HASH_LENGTH,
            reinterpret_cast<PBYTE>(&cbHash),
            sizeof(DWORD),
            &cbData,
            0);
    }
    else
    {
        abort();
    }

    pbHash = reinterpret_cast<PBYTE>(
        HeapAlloc(GetProcessHeap(), 0, cbHash));

    if (!pbHash)
    {
        abort();
    }

    if (NT_SUCCESS(status))
    {
        status = BCryptCreateHash(
            hAlg,
            &hHash,
            pbObject,
            cbObject,
            nullptr,
            0,
            0);
    }
    else
    {
        abort();
    }

    if (NT_SUCCESS(status))
    {
        status = BCryptHashData(
            hHash,
            (PBYTE)(data),
            sizeof(data),
            0);
    }
    else
    {
        abort();
    }

    if (NT_SUCCESS(status))
    {
        status = BCryptFinishHash(
            hHash,
            pbHash,
            cbHash,
            0);
    }
    else
    {
        abort();
    }

    std::cout << ByteToHex(pbHash, cbHash).c_str();
    delete[] data;

    if(hAlg) BCryptCloseAlgorithmProvider(hAlg, 0);
    if(hHash) BCryptDestroyHash(hHash);
    if(pbHash) HeapFree(GetProcessHeap(), 0, pbHash);
    if(pbObject) HeapFree(GetProcessHeap(), 0, pbObject);
    return 0;
}

","When calling read or write, that's one of the few situations where it's considered okay to use reinterpret_cast. In some cases there's no other viable solution.
So for your case:
file.read(reinterpret_cast<char*>(data), file_length);

","89","<c++><file><byte><cng>","1","2","1","2019-05-25 18:49:18","55568067","0","","12597","","2019-05-25 18:49:18","2019-04-08 07:13:05",""
"54266459","Wrapping/Unwrapping private keys with CNG","PKCS #11 Defines a procedure for wrapping/unwrapping of private keys using symmetric keys PKCS #11 v2.20 (Section 12.6). The unwrapping procedure simply reverses the wrapping procedure; so there is a C_UnwrapKey function to complement C_WrapKey.
I was wondering if there is a similar procedure with CNG (or CAPI; but i prefer CNG). Importing PKCS#8 encrypted key to RSACng is the best i found to describe the capabilities of CNG with regard to accepting PKCS#8 encrypted private keys (to unwrap them). However, there it mentions only PKCS#8 keys that were encrypted using a password - i know Microsoft did this in order to be compatible with PKCS#12 to support PFX files, yet i want to be able to decrypt an encrypted PKCS#8 private key using an existing key in the CNG provider (i.e. to unwrap the key) just as described in PKCS#11.
Can anybody confirm whether such a capability exists anywhere within CNG and if it exists, then i would appreciate any directions.
","","88","<winapi><pkcs#11><cng>","2","","0","2019-01-19 11:11:09","","0","1","","","","2019-01-19 11:11:09",""
"45004848","""Keyset does not exist"" trying to create a CngKeyStore","Trying to call CngKeyStore.Open() with a non-admin account, and was initially getting an ""Access denied"" exception.
After granting the user account access to the c:\programdata\microsoft\crypto\keys folder, am now getting the above ""Keyset does not exist"" exception.
Does the user have to be an administrator in order create keys?  Or can non-admin accounts do it, and if so how?
I can find no definitive answer on this in the MS documentation here:
https://msdn.microsoft.com/en-us/library/windows/desktop/aa376210(v=vs.85).aspx 
or here:
https://msdn.microsoft.com/en-us/library/system.security.cryptography.cngkey(v=vs.110).aspx
Thanks!
","","81","<c#><cng>","1","","0","2017-07-11 08:23:52","","0","","7688090","","2017-07-11 08:23:52","2017-07-10 06:11:37",""
"50855541","Generate private key in specific pkcs8 format (custom CNG)","I have a task to develope a CNG. I got a working source code of CNG which supports some algorithms like GOST and etc. I need to make it to generate private key (pkcs8 format) and support x509 certificates in other structures. For example:
this is private key which is generated by this CNG in PKCS8:

3042020100301906092A865C030F01010201300C060A2A865C030F010102010104220220583E4721B1854891532AC05E7033B77D2D357A418A99D473CF05125EA6BDE2C8

ASN1:
SEQUENCE(3 elem)
INTEGER 0
SEQUENCE(2 elem)
OBJECT IDENTIFIER 1.2.860.3.15.1.1.2.1
SEQUENCE(1 elem)
OBJECT IDENTIFIER 1.2.860.3.15.1.1.2.1.1
OCTET STRING(1 elem)
INTEGER(255 bit) 3991356612570766941491045091107680786406690561132958956606466907746255…

I need to make it to generate private key (pkcs8) in this structure:

30819A020100301706092A865C030F01010201060A2A865C030F0101020101047C307A020101042024342757366A76776A2E13580929AD7E3D26B2C11656F30CD7CAF32A354B78D5A00C060A2A865C030F0101020101A145034300044058713A68F3EF7AD72BE6DFCCEBC6576A37B97E2A753C5A34FAA0C3BC818AE461E6F0E2C397BCBFF1314B19A25AF30DCD2653F90B1D73908EB5568D0BAFA87DD1

ASN1:
SEQUENCE(3 elem)
INTEGER 0
SEQUENCE(2 elem)
OBJECT IDENTIFIER 1.2.860.3.15.1.1.2.1
OBJECT IDENTIFIER 1.2.860.3.15.1.1.2.1.1
OCTET STRING(1 elem)
SEQUENCE(4 elem)
INTEGER 1
OCTET STRING(32 byte) 24342757366A76776A2E13580929AD7E3D26B2C11656F30CD7CAF32A354B78D5
[0](1 elem)
OBJECT IDENTIFIER 1.2.860.3.15.1.1.2.1.1
[1](1 elem)
BIT STRING(1 elem)
OCTET STRING(64 byte) 58713A68F3EF7AD72BE6DFCCEBC6576A37B97E2A753C5A34FAA0C3BC818AE461E6F0E2…

does anyone can help me with it, where I should look for to change any ideas or solutions.
The following function allocates memory and generates the ASN buffers of the private key, Algorithm parameters and the name of the algorithm for the given CNG
Blob. These buffers are required to fill the structure Crypt_private_key_info.
I think I need to change this piece of code:
SxKS_AllocAndEncodePrivateKey(
    __in PBYTE pbKeyBlobCNG,
    __in DWORD cbKeyBlobCNG,
    __out PBYTE *ppbKeyBufASN,
    __out DWORD *pcbKeyBufASN,
    __out PBYTE *ppbAlgParamASN,
    __out DWORD *pcbAlgParamASN,
    __out LPSTR *pszAlgOID)
{
    PBYTE pbKeyBufASN = NULL;
    DWORD cbKeyBufASN = 0;
    PBYTE pbAlgParamASN = NULL;
    DWORD cbAlgParamASN = 0;
    LPSTR szAlgOID = NULL;
    PSTYX_SYMMKEY_BLOB pSymmBlob = NULL;
    PSTYX_ASYMMKEY_BLOB pAsymmBlob = NULL;
    PSTYX_KEYBLOB_HEADER pHdrBlob = NULL;
    SECURITY_STATUS Status = ERROR_SUCCESS;
    ULONG dwPubParamId = 0;
    ULONG dwMDParamId = 0;
    ULONG dwEncParamId = 0;
    ULONG cbParam1 = 0;
    ULONG cbParam2 = 0;
    PBYTE pPrivKeyData;
    DWORD fLeadingZero = 0;

    // Проверяем входные данные
    if ((NULL == pbKeyBlobCNG) ||
        (0 == cbKeyBlobCNG) ||
        (NULL == ppbKeyBufASN) ||
        (NULL == pcbKeyBufASN) ||
        (NULL == ppbAlgParamASN) ||
        (NULL == pcbAlgParamASN) ||
        (NULL == pszAlgOID))
    {
        Status = NTE_BAD_DATA;
        goto Cleanup;
    }
    pHdrBlob = (PSTYX_KEYBLOB_HEADER)pbKeyBlobCNG;
    // Проверяем корректность блоба
    if (0 == pHdrBlob->cbKey)
    {
        Status = NTE_BAD_DATA;
        goto Cleanup;
    }
    pAsymmBlob = (PSTYX_ASYMMKEY_BLOB)pbKeyBlobCNG;
    // Проверяем корректность блоба
    // Длина ключа
    if ((sizeof(STYX_ASYMMKEY_BLOB) + 3 * pAsymmBlob->cbKey) < cbKeyBlobCNG)
    {
        Status = NTE_BAD_DATA;
        goto Cleanup;
    }
    dwPubParamId = pAsymmBlob->dwPubParamId;
    // При необходимости задаем параметры алгоритма по умолчанию.
    if (0 == dwPubParamId)
        dwPubParamId = 2; 
    dwMDParamId = pAsymmBlob->dwMDParamId;
    // При необходимости задаем блок подстановок хэш по умолчанию.
    if (0 == dwMDParamId)
        dwMDParamId = 10; 
    dwEncParamId = pAsymmBlob->dwEncParamId;
    // При необходимости задаем блок подстановок по умолчанию.
    if (0 == dwEncParamId)
        dwEncParamId = 2; 
    // Устанавливаем указатель значения закрытого ключа
    pPrivKeyData = pbKeyBlobCNG + sizeof(STYX_ASYMMKEY_BLOB) + 2 * pAsymmBlob->cbKey;
    // Считаем размер для ASN буфера закрытого ключа
    // TRIPLET INTEGER (1) + LENGTH (1) + KEYDATA (32) = 34
    cbKeyBufASN = 2 + pAsymmBlob->cbKey;
    // Устанавливаем флаг fLeadingZero для триплета INTEGER
    if (0x80 == (0x80 & pPrivKeyData[0]))
    {
        fLeadingZero = 1;
        cbKeyBufASN++;
    }
    // Выделяем память для ASN буфера закрытого ключа
    pbKeyBufASN = (PBYTE)STYXMALLOC(cbKeyBufASN);
    if (NULL == pbKeyBufASN)
    {
        Status = NTE_NO_MEMORY;
        goto Cleanup;
    }
    // Заполняем ASN буфер закрытого ключа
    pbKeyBufASN[0] = 0x02;                     // ASN.1 TRIPLET TYPE INTEGER
    pbKeyBufASN[1] = (BYTE) pAsymmBlob->cbKey; // ASN.1 TRIPLET LENGTH 32 octets
    if (1 == fLeadingZero)
    {
        pbKeyBufASN[1]++;
        pbKeyBufASN[2] = 0;
        memcpy(pbKeyBufASN + 3, pPrivKeyData, pAsymmBlob->cbKey);
    }
    else
    {
        memcpy(pbKeyBufASN + 2, pPrivKeyData, pAsymmBlob->cbKey);
    }
    // Считаем размер для ASN буфера параметров алгоритма
    // TRIPLET SEQ (1) + SEQLEN(1) + 
    // OBJ(1) + OBJLEN(1) + PubParamOIDdata +
    // OBJ(1) + OBJLEN(1) + MDParamOIDdata
    SxH_GetOIDoctets_fromGS01PubParamID(dwPubParamId, NULL, &cbParam1);
    SxH_GetOIDoctets_fromSBoxID(dwMDParamId, NULL, &cbParam2);
    cbAlgParamASN = 6 + (BYTE)(cbParam1 + cbParam2);
    // Выделяем память для ASN буфера параметров алгоритма
    pbAlgParamASN = (PBYTE)STYXMALLOC(cbAlgParamASN);
    if (NULL == pbAlgParamASN)
    {
        Status = NTE_NO_MEMORY;
        goto Cleanup;
    }
    // Заполняем ASN буфер параметров алгоритма
    pbAlgParamASN[0] = 0x30; // ASN.1 TRIPLET SEQ
    pbAlgParamASN[1] = 4 + (BYTE)(cbParam1 + cbParam2); // ASN.1 TRIPLET SEQ LEN
    pbAlgParamASN[2] = 0x06; // ASN.1 TRIPLET OBJ
    pbAlgParamASN[3] = (BYTE)cbParam1; // ASN.1 TRIPLET OBJ LEN
    SxH_GetOIDoctets_fromGS01PubParamID(dwPubParamId, pbAlgParamASN + 4, &cbParam1);
    pbAlgParamASN[4 + cbParam1] = 0x06; // ASN.1 TRIPLET OBJ
    pbAlgParamASN[5 + cbParam1] = (BYTE)cbParam2; // ASN.1 TRIPLET OBJ LEN
    SxH_GetOIDoctets_fromSBoxID(dwEncParamId, pbAlgParamASN + 6 + cbParam1, &cbParam2);
    // Заполняе указатель OID'а алгоритма
    szAlgOID = szOID_OS_A2;

    *ppbKeyBufASN = pbKeyBufASN;
    *pcbKeyBufASN = cbKeyBufASN;
    *ppbAlgParamASN = pbAlgParamASN;
    *pcbAlgParamASN = cbAlgParamASN;
    *pszAlgOID = szAlgOID;
    // Сбрасываем указатели чтобы не освобождать память буферов при выходе
    pbKeyBufASN = NULL;
    pbAlgParamASN = NULL;
Cleanup:
    if (NULL != pbKeyBufASN) STYXFREE(pbKeyBufASN);
    if (NULL != pbAlgParamASN) STYXFREE(pbAlgParamASN);
    return Status;
}

","","79","<c><cng>","0","","0","2018-06-14 10:57:21","","2","","9941075","","2018-06-14 10:57:21","2018-06-14 10:40:24",""
"57472787","Compile errors when using C++ and bcrypt header","I'm trying to test Windows Bcrypt. I have a test program:
#include <bcrypt.h>
#include <iostream>
#include <string>

#pragma comment (lib, ""bcrypt.lib"")

int main(int argc, char* argv[])
{
    return 0;
}

Attempting to compile it:
>cl.exe /DWINVER=0x0600 /TP /GR /EHsc bcrypt-test.cpp /link /out:bcrypt-test.exe
Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24210 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

bcrypt-test.cpp
C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\shared\bcrypt.h(39):
 error C2059: syntax error: 'return'
C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\shared\bcrypt.h(40):
 error C2143: syntax error: missing ';' before '*'
C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\shared\bcrypt.h(40):
 error C4430: missing type specifier - int assumed. Note: C++ does not support d
efault-int
...
C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\shared\bcrypt.h(681)
: error C3646: 'cbKeyLength': unknown override specifier
C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\shared\bcrypt.h(681)
: fatal error C1003: error count exceeds 100; stopping compilation

I am using a Visual C++ x64 Build Tools command prompt. As I understand things, Bcrypt needs to target Vista or above. WINVER=0x0600 should satisfy the requirement. I found a similar question on the MSDN forums at bcrypt.h build error?, and it says to use a modern SDK. I believe the Windows Kit SDK should satisfy the requirement.
Why am I experiencing compile errors, and how do I fix it?

Line 39 in bcrypt.h is the first typedef below. The preamble, like copyright and header guards, were skipped for brevity.
#ifndef WINAPI
#define WINAPI __stdcall
#endif

#ifndef _NTDEF_
typedef _Return_type_success_(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

#ifndef BCRYPT_SUCCESS
#define BCRYPT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

","You are missing an include.
#include <Windows.h> // <- Added this
#include <bcrypt.h>
#include <iostream>
#include <string>

#pragma comment (lib, ""bcrypt.lib"")

int main()
{
    return 0;
}

","70","<c++><windows><compiler-errors><cng>","0","1","1","2019-08-19 09:44:05","57472974","2","","608639","","2019-08-19 09:44:05","2019-08-13 07:11:31",""
"54410333","Does Windows have AEAD API? (c.f. CryptProtectData, but using a key)","Does Windows provide a high-level, tested, supported, function to perform authenticated encryption using a symmetric key?
Of course AEAD (Authenticated Encryption with Additional Data) would be better. But this question is only asking AE (Authenticated Encryption).
Background
Windows provides a (relatively) simple API to encrypt a blob using the CryptProtectData API, which we can wrap in an easy to use function:
public Byte[] ProtectBytes(Byte[] plaintext)
{
   //...
}

The details of ProtectBytes are less important than the idea that you can use it quite easily:

here are the bytes I want encrypted by a secret key held in the System
give me back the encrypted blob

The returned blob is an undocumented documentation structure that contains everything needed (i.e. hash algorithm, cipher algorithm, salt, HMAC signature, etc) to decrypt and return the original data .
For completeness, here's the sample pseudocode implementation of ProtectBytes that uses the Crypt API to protect bytes:
public Byte[] ProtectBytes(Byte[] plaintext)
{
   //Setup our n-byte plaintext blob
   DATA_BLOB dataIn;
   dataIn.cbData = plaintext.Length;
   dataIn.pbData = Addr(plaintext[0]);

   DATA_BLOB dataOut;

   //dataOut = EncryptedFormOf(dataIn)
   BOOL bRes = CryptProtectData(
         dataIn,
         null,     //data description (optional PWideChar)
         null,     //optional entropy (PDATA_BLOB)
         null,     //reserved
         null,     //prompt struct
         CRYPTPROTECT_UI_FORBIDDEN || CRYPTPROTECT_LOCAL_MACHINE,
         ref dataOut);
   if (!bRes) then
   {
      DWORD le = GetLastError();
      throw new Win32Error(le, ""Error calling CryptProtectData"");
   }

   //Copy ciphertext from dataOut blob into an actual array
   bytes[] result;
   SetLength(result, dataOut.cbData);
   CopyMemory(dataOut.pbData, Addr(result[0]), dataOut.cbData);

   //When you have finished using the DATA_BLOB structure, free its pbData member by calling the LocalFree function
   LocalFree(HANDLE(dataOut.pbData)); //LocalFree takes a handle, not a pointer. But that's what the SDK says.
}

An important point in all this is that CryptProtectData can operate in one of two modes:

the data can only be decrypted by you (becuase it's, essentially, encrypted with your Windows password)
the data can be decrypted by anyone running on the same local machine (because it is encrypted, essentially, with the password of the local security subsystem)

CryptProtectDataWithPassword?
How to do the same with an explicit password?
The downside of CryptProtectData is that the decryption is tied to either:

me
my machine

This means that the encrypted data cannot be passed to anyone else. I need something more portable between different people. (e.g. people on other computers, people not on the same domain, people not on a domain)
Crypto API Next Gen on Windows 8 also doesn't support it
There is the bcrypt (aka BestCrypt, aka Cng, aka CryptoNG, aka Crypto NextGen, aka Cryptography Next Generation API) which provides an updated version of
the Windows 2000-era CryptProtectData called
ProtectSecret. 
This function allows you to specify who on the domain can decrypt the secret - either through an SID, e.g.:

""SID=S-1-1-0"": Everyone group 
""SID=S-1-5-32-544"": BUILTIN\Administrators group
""SID=S-1-5-32-545"": BUILTIN\Users group

Or through a certificate in your private store:

""CERTIFICATE=HashId:87b8808ecb233e0736b84b60670065b36ca615f1"": CN=youporn.com

The downside of this newer function is that:

it requires Windows 8 or newer
it only works on the domain
or with a certificate

I need it something that works with a password (i.e. a secret).
I don't want to roll my own
Does Windows have an existing high-level function to perform encryption with a password? One major virtue of Windows supporting it, is that they will return an opaque blob that supports versioning. 

If they suddenly decide to change from AES-128 to AES-256
or change the length of the salt
or suddenly decide to completely switch to GCM in CTR mode encryption with the addition of a Carter-Wegman MAC set in a Galois field

Everything is packaged into a versioned structure that contains everything needed to do the decryption, authentication. They can change the algorithm and old encrypted blobs still work, while new blobs will also work. 
Plus, i don't want to roll my own. We all know how to roll your own encryption. It's pretty easy to not screw up encryption:

oops, next version

oops, next version

So rather than me rolling my own, i would love:

something that comes with Windows 
returns an opaque blob
is vetted and tested by people with more time and knowledge than myself

The reason i don't use a libsodium is because it's not available for the language i'm using. (also it wasn't the question)
","","68","<windows><encryption><windows-7><encryption-symmetric><cng>","1","","0","2019-05-05 21:25:00","","2","","12597","","2019-05-05 21:25:00","2019-01-28 21:09:57",""
"57487839","How to determine which of 23 parameters are STATUS_INVALID_PARAMETER?","I'm trying to use BCryptEncrypt to authenticate some AAD but the function is failing with STATUS_INVALID_PARAMETER. BCryptEncrypt takes 10 parameters. One of the parameters is BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO. BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO takes another 13 parameters.
Running my test program results in:
>.\bcrypt-gmac.exe
BCryptEncrypt error, 0xc000000d (STATUS_INVALID_PARAMETER)

STATUS_INVALID_PARAMETER is not very helpful in this case.
My question is, how do I determine which of the 23 parameters is causing the error when using Bcrypt?
Is there a way to get extended error information, like through BcryptPropertyGet (maybe a LAST_ERROR_PARAMETER or something similar)?
Or does Microsoft expect us to guess at the problem? In this case, I guess the answer is, ""you can't"".

The Microsoft docs don't provide examples of using Bcrypt. I also cannot find helpful examples on Stack Overflow or MSDN. Even Writing Secure Code for Windows Vista fails to provide examples.
Here is the treatment in Writing Secure Code for Windows Vista. It amounts to pseudo-code, which is very disappointing:


","","67","<c><windows><cng>","0","","0","2019-08-19 09:44:21","","4","","608639","","2019-08-19 09:44:21","2019-08-14 03:32:24",""
"57517030","Best approach for Id generation and password hashing using DDD for User Domain model","I'm new to DDD and right now I'm in the process of implementing user registration. 
Basically the flow is:  

Controller receives request  
Maps the received data from client to User Domain model.    
Maps the User Domain model to an EF-core entity model.    
Adds user to database using EF-Core.

I'm having some doubts regarding where I place IdGeneratorService class and BCryptService class. Currently both of them have an Interface in Domain layer: src/Domain/Model/Services. Their implementation is residing inside my Infrastructure layer: src/Infrastructure/Services. They are also both being called inside the User domain model:
public class User
{
    private User(
        long id, 
        string name, 
        string lastName, 
        string contactPhone, 
        string contactEmail, 
        string userName, 
        string password)
    {
        Id = id;
        Name = name;
        LastName = lastName;
        ContactPhone = contactPhone;
        ContactEmail = contactEmail;
        UserName = userName;
        Password = password;
    }

    public IEnumerable<Role> Type { get; set; }

    public static async Task<User> ConstructAsync(
        string name, string lastName, 
        string contactPhone, string contactEmail, 
        string userName, string password, 
        IIdGeneratorService<long> idGeneratorService, IBCryptService bCryptService)
    {
        var id = await idGeneratorService.GenerateAsync();

        password = bCryptService.HashPassword(password);

        return new User(id, name, lastName, contactPhone, contactEmail, userName, password); 
    } 

This is being called by my controller: 
[HttpPost(""[Action]"")]
public async Task<IActionResult> Create([FromBody] UserModel userModel)
{
    var user = 
        await DomainUser.ConstructAsync(
            userModel.Name, userModel.LastName,
            userModel.ContactPhone, userModel.ContactEmail,
            userModel.UserName, userModel.Password,
            _idGeneratorService, _bCryptService);

    await _userRepository.AddAsync(user);

    return sampleResponse;
}

I feel like calling the IdGenerator and BCrypt inside domain model is bad practice, because from what I understand the Domain layer cannot know about the Infrastructure layer, so I'm not really sure how I go about this. Any other help/suggestions regarding other implementations based on what you understood here is greatly appreciated.
","It is a good practice to introduce an intermediate ""Application Service"" layer between the Controller and the Domain Layer.
The App Service will be responsible for invoking the (injected) infrastructure services, calling the domain layer and also persisting/loading necessary data. The Controller's responsibility is only to gather the request params, ensure authentication (if needed), and then make the call to the Application Service method.
Application Services are the direct clients of the domain model and act as intermediaries to coordinate between the external world and the domain layer. They are responsible for handling infrastructure concerns like ID Generation, Transaction Management, Encryption, etc. Such responsibilities are not concerns of the Controller layer either.
App services also typically do task coordination for APIs (one service method per API). When using an ACID database, the same Services also control transactions, ensuring that model state transitions are atomically persisted.
In your specific example, the App Service would be responsible for invoking the IdGeneratorService and BCryptService, getting the output and sending them as parameters to the domain layer. As far as the Domain layer is concerned, it does need to know how exactly the ID or the password were generated - those are not domain concerns. So it happily stays oblivious to these infrastructure aspects and only burdens itself with the tasks of User Behavior.
","65","<c#><.net-core><domain-driven-design><cng>","0","2","1","2019-08-19 09:51:05","57517204","0","","608639","","2019-08-19 09:51:05","2019-08-15 22:43:03",""
"55161121","Extract Private Key from ECDSa certificate","I've created a self signed ECDSA certificate using openssl. I need to get it's private key information and it's certificate information as base64 bytes. The latter is easy. The first appears to be very difficult. I know I can't get it right because the private key is of length of 256. I know its length because I've created it, and I verified it using:
openssl ec -in C:\OpenSSLx64\flir\newcerts\ecd.key.pem  -text -noout

All of my attempts yield a different length of bytes. Here they are:
X509Certificate2 certificate = new X509Certificate2(certificateBytes, password, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.EphemeralKeySet);
if (certificate.GetECDsaPrivateKey() is ECDsaCng ecdKeyWrapper)
{
    CngKey key = ecdKeyWrapper.Key;
    key.SetProperty(pty);
    ECParameters parameters = ecdKeyWrapper.ExportParameters(true);
    privateKey = parameters.D;
    byte[] otherPKey = key.Export(CngKeyBlobFormat.GenericPrivateBlob);
    byte[] otherPKey2 = key.Export(CngKeyBlobFormat.EccPrivateBlob);
    byte[] otherPKey3 = key.Export(CngKeyBlobFormat.EccFullPrivateBlob);
    byte[] otherPKey4 = key.Export(CngKeyBlobFormat.Pkcs8PrivateBlob);
}

I know that with RSA and DSA I can use bouncyCastle but it won't work here:
keyPair = DotNetUtilities.GetKeyPair(dsaKeyWrapper);

So I guess I have two problems:

I can't extract the private key properly.
I've read the private key is supposed defined as D. Apparently, it's not (the size doesn't fit). What is D in this context then?

","","64","<c#><ecdsa><cng>","0","","0","2019-03-14 11:17:16","","0","","","","","2019-03-14 11:17:16",""
"44094417","Suppress strong key protection UI","Is it possible to use Microsofts cryptography function CryptUIWizImport without getting a UI to enter the password during sign as well as during importing the pfx file in the local system? How? 

Details: 
I have developed an application to sign the data in c++ using the private key stored on the computer. The private key is protected with Strong key protection.  I am not able to suppress the strong key protection UI. I did try with parameter CRYPTUI_WIZ_NO_UI for CryptUIWizImport, but the UI remains. Is it possible to automate the process in back ground? How? 
","","64","<c++><digital-signature><cng>","1","","0","2017-05-21 11:22:03","","0","1","750378","","2017-05-21 11:22:03","2017-05-21 07:47:12",""
"58419870","How to use BCrypt for RSA (asymmetric encryption)","I'm trying to make simple working example of encryption and decryption with BCrypt but I'm can't get it to work because I don't understand exactly how.
From BCryptEncrypt Function, Microsoft Docs:
NTSTATUS BCryptEncrypt(
  BCRYPT_KEY_HANDLE hKey,
  PUCHAR            pbInput,
  ULONG             cbInput,
  VOID              *pPaddingInfo,
  PUCHAR            pbIV,
  ULONG             cbIV,
  PUCHAR            pbOutput,
  ULONG             cbOutput,
  ULONG             *pcbResult,
  ULONG             dwFlags
);

I generated a simple 512bit key pair on 8gwifi.org:
string Public_Key = ""MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJSNbUhCkU9RuY99L8kC2WRJ8TBES3WX1u9wYlANvUFU/h7lU8VNOWI8dNGCQ6UbK2ypHFom+Zm4BaG1zokwcUkCAwEAAQ=="";
string Private_Key = ""MIIBOgIBAAJBAJSNbUhCkU9RuY99L8kC2WRJ8TBES3WX1u9wYlANvUFU/h7lU8VNOWI8dNGCQ6UbK2ypHFom+Zm4BaG1zokwcUkCAwEAAQJAZ9bwZAl8L5jt//o/E+C0+2Cggt/Ka5nG+bpyTok8GNTyaG+Prmz/QCYdI3VuYdONdfAPm3jLwtbK9wTt1E8HAQIhAM8jg1nwjN9+nhPyFo0F+2o8y47mq1kHnCn+gqAdW8MhAiEAt5gQcCqX2Y5KbmMoqtQ+4RIEHQ8HD+fyGqxWUhVpESkCIEtylQJqgvVZCj0bnakqN6Q/lqlrTZg1FGWbZXrqlqThAiEAilt5v94Jc7Ws2AW4Rw0OmfVGzlNd4hnNNVa88r0Z4gkCIGfFy2H8pGxHxg1GKE2mSZAfpRMyjqeq119S3t/bhqY2"";
string Encrypt_Me = ""Hello World"";

To be honest I don't understand exactly how to use this function for this situation, I tried searching a simple example but couldn't find any.
Thank you.
","There is an sample here: https://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/007a0e26-7fc0-4079-9b63-2ad23f866836/bug-in-rsa-encryptiondecryption-using-cng?forum=windowssdk
Please note that the first byte of encrypted data should not exceed 0xb6. And there is a detailed explanation in the post.
Take encryption as an example,
First, use BCryptOpenAlgorithmProvider to load and initialize a CNG provider that specify RSA.
#define NT_SUCCESS(Status)          (((NTSTATUS)(Status)) >= 0)
status = BCryptOpenAlgorithmProvider(&hAlgorithm,
    BCRYPT_RSA_ALGORITHM,
    NULL,
    0);
if (!NT_SUCCESS(status)) {
    printf(""Failed to get algorithm provider..status : %08x\n"", status);
    goto cleanup;
}

Then, BCryptImportKeyPair
status = BCryptImportKeyPair(hAlgorithm,
    NULL,
    BCRYPT_RSAPUBLIC_BLOB,
    &hKey,
    PublicKey,
    PublicKeySize,
    BCRYPT_NO_KEY_VALIDATION);
if (!NT_SUCCESS(status)) {
    printf(""Failed to import Private key..status : %08x\n"", status);
    goto cleanup;
}

To get Encrypted Buffer Size:
status = BCryptEncrypt(hKey,
    InputData,
    InputDataSize,
    NULL,
    NULL,
    0,
    NULL,
    0,
    &EncryptedBufferSize,
    0
);
if (!NT_SUCCESS(status)) {
    printf(""Failed to get required size of buffer..status : %08x\n"", status);
    goto cleanup;
}

encryptedBuffer = (PUCHAR)HeapAlloc(GetProcessHeap(), 0, encryptedBufferSize);
if (encryptedBuffer == NULL) {
    printf(""failed to allocate memory for blindedFEKBuffer\n"");
    goto cleanup;
}

Encrypte Data:
status = BCryptEncrypt(hKey,
    InputData,
    InputDataSize,
    NULL,
    NULL,
    0,
    encryptedBuffer,
    encryptedBufferSize,
    &encryptedBufferSize,
    0
);

if (!NT_SUCCESS(status)) {
    printf(""Failed encrypt data..status : %08x\n"", status);
    goto cleanup;
}
cleanup:
if (hKey)
    BCryptDestroyKey(hKey);
if (hAlgorithm)
    BCryptCloseAlgorithmProvider(hAlgorithm, 0);

","64","<c++><winapi><rsa><cng>","0","1","1","2019-10-17 06:29:15","","4","","11467293","","2019-10-16 18:54:01","2019-10-16 18:47:06",""
"53376597","Load Private Key Only By Company Signed Application","For my applications, I have a private key stored using the Windows CNG functions, but I don't have a way to ensure when the applications communicate that the messages are from my applications. I need is a way for me to only allow the private key stored in the CNG to be loaded when the applications are signed by me. What are the CNG functions to use for that behaviour?
","There isn't. Windows' security model is based around users and groups being given permission to do things and access to resources, individual applications/processes do not generate security tokens (where identifying information is stored) of their own, they inherit an existing token.
","62","<c++><security><winapi><cng>","0","0","1","2019-03-08 14:06:18","","0","","","","","2018-11-19 14:20:00",""
"51952700","Import key on a given token with CNG","I've recently started fiddling with CNG to manage smartcards in our applications, and something remains quite unclear:
How do you import a key into a given smartcard ? It seems to me that the KSP just creates the key on the first card it sees.
Here's what I did:

2 smartcards are connected to my machine, from the same vendor.
Said vendor implemented his own KSP, which appears when i list KSPs with NCryptEnumStorageProviders.
Listing the keys available through the provider produces the following output:
Got key: p11#958fb9080419db6e //Belongs to 1st smartcard  
Got key: p11#9eaad58f1c3a73e5 //Belongs to 1st smartcard
Got key: b6b99fb4-01c4-fa18-83db-0e2bb1c80476 //Belongs to 2nd smartcard

Now when i called NCryptCreatePersistedKey, the new key was generated on the 2nd card. No popup whatsoever asked me on which card i wanted to create this key.
What did i do wrong ?
Thanks a lot for your time.
","Try to set smartcard reader explicitly in NCryptCreatePersistedKey:
NCryptCreatePersistedKey(hProv, phKey, L""alg_id"", L""\\\\.\\SmartCard Reader 0\\KeyName"", 0, 0);

","61","<smartcard><cng>","0","0","1","2018-08-30 07:01:34","52090989","4","","","","","2018-08-21 16:05:39",""
"49288629","How to reliably arrive at a non negative serial number from a SHA1 hash?","I am using CNG to generate serial numbers for certificates. My algorithm takes the common name of the Certificate Authority, appends 10 random bytes and then computes a SHA1 hash of that. The SHA1 hash is consistently 20 bytes in length and I use that as a serial number.
The problem! I don't get reliably positive numbers from that algorithm as far as OpenSSL is concerned. Negative serial numbers cause issues for OpenSSL. So how do I ensure that my 20 bytes are always considered as a 'positive' serial number by OpenSSL?
For example, these serial numbers:

da7db14cbc79401b642fd77806b54e21b012bbe1
  f67604707a861fac55fbef8a5571ab8284e761bd
  7d8df1b0b62c284ad12fd1eaadfb18dd4c9c91ba
  8588ea1034c6c5a23b1f5cf9689e63baf10775a9
  169ad01b41f6e5108d64d70bb8de25da475e02b5
  89ff69bc06ec5a93c9e11e71a990f7e8ee0a9d3d
  6dbd23a8655c9627a8d241d48a909aec7823dc1c

Produce this output when I put them in a Certificate Revocation List, which is unaccepatble:

Revoked Certificates:
      Serial Number: -25824EB34386BFE49BD02887F94AB1DE4FED441F
          Revocation Date: Mar 14 21:47:02 2018 GMT
      Serial Number: -0989FB8F8579E053AA041075AA8E547D7B189E43
          Revocation Date: Mar 14 21:47:02 2018 GMT
      Serial Number: 00
          Revocation Date: Mar 14 21:47:02 2018 GMT
      Serial Number: -7A7715EFCB393A5DC4E0A30697619C450EF88A57
          Revocation Date: Mar 14 21:47:02 2018 GMT
      Serial Number: 169AD01B41F6E5108D64D70BB8DE25DA475E02B5
          Revocation Date: Mar 14 21:47:02 2018 GMT
      Serial Number: -76009643F913A56C361EE18E566F081711F562C3
          Revocation Date: Mar 14 21:47:02 2018 GMT
      Serial Number: 6DBD23A8655C9627A8D241D48A909AEC7823DC1C
          Revocation Date: Mar 14 21:47:02 2018 GMT

Is there a way to mask off part of one byte to make it always positive? Also, is there a reason why the third serial number is interpreted as zero?
Code sample for generating the serial number:
void CERTSTORE::GetSerialNumber(
eAction eActionTaken,
std::string sCACN, 
std::vector<BYTE> & vSerialNumber
)
{
    NTSTATUS statusBCryptOpenAlgorithmProvider_Hash;
    NTSTATUS statusBCryptOpenAlgorithmProvider_RNG;
    NTSTATUS statusBCryptGenRandom;
    NTSTATUS statusBCryptHash;
    BCRYPT_ALG_HANDLE hRandNumAlg;
    BCRYPT_ALG_HANDLE hHashAlg;
    DWORD dwHash = 20;
    BYTE bRandomBytes[10];
    std::vector<BYTE> vBytesToBeHashed(
        (BYTE)sCACN.c_str(),
        sCACN.length()
    );

    //open algorithm provider to get random number generator
    statusBCryptOpenAlgorithmProvider_RNG = BCryptOpenAlgorithmProvider(
        &hRandNumAlg,
        BCRYPT_RNG_ALGORITHM,
        MS_PRIMITIVE_PROVIDER,
        0
    );

    if (0 != statusBCryptOpenAlgorithmProvider_RNG)
    {
        throw ERRORSTRING(
            eActionTaken,
            eSubAction::eSubAction_OPENALGPROV,
            eMajorErrorCode::eMajorErrorCode_RUNTIMEERROR,
            eMinorErrorCode::eMinorErrorCode_UKNNTSTATUS,
            statusBCryptOpenAlgorithmProvider_RNG
        );
    }

    statusBCryptGenRandom = BCryptGenRandom(
        hRandNumAlg,
        bRandomBytes,
        sizeof(bRandomBytes),
        0
    );

    if (0 != statusBCryptGenRandom)
    {
        BCryptCloseAlgorithmProvider(hRandNumAlg, 0);
        throw ERRORSTRING(
            eActionTaken,
            eSubAction::eSubAction_GENRANDOM,
            eMajorErrorCode::eMajorErrorCode_RUNTIMEERROR,
            eMinorErrorCode::eMinorErrorCode_UKNNTSTATUS,
            statusBCryptGenRandom
        );
    }

    BCryptCloseAlgorithmProvider(hRandNumAlg, 0);

    for (int iRandByteCounter = 0; iRandByteCounter < sizeof(bRandomBytes); iRandByteCounter++)
    {
        vBytesToBeHashed.push_back(
            bRandomBytes[iRandByteCounter]
        );
    }

    statusBCryptOpenAlgorithmProvider_Hash = BCryptOpenAlgorithmProvider(
        &hHashAlg,
        BCRYPT_SHA1_ALGORITHM,
        MS_PRIMITIVE_PROVIDER,
        0
    );

    if (0 != statusBCryptOpenAlgorithmProvider_Hash)
    {
        throw ERRORSTRING(
            eActionTaken,
            eSubAction::eSubAction_OPENALGPROV,
            eMajorErrorCode::eMajorErrorCode_RUNTIMEERROR,
            eMinorErrorCode::eMinorErrorCode_UKNNTSTATUS,
            statusBCryptOpenAlgorithmProvider_Hash
        );
    }

    try
    {
        vSerialNumber.assign(
            dwHash,
            NULL
        );
    }
    catch (std::exception & ex)
    {
        throw ERRORSTRING(
            eActionTaken,
            eSubAction::eSubAction_CRYPTHASH,
            eMajorErrorCode::eMajorErrorCode_RUNTIMEERROR,
            eMinorErrorCode::eMinorErrorCode_MEMORYALLOCATION,
            0
        );
    }

    statusBCryptHash = BCryptHash(
        hHashAlg,
        NULL,
        0,
        &vBytesToBeHashed[0],
        vBytesToBeHashed.size(),
        &vSerialNumber[0],
        dwHash
    );

    if (0 != statusBCryptHash)
    {
        BCryptCloseAlgorithmProvider(hHashAlg, 0);
        throw ERRORSTRING(
            eActionTaken,
            eSubAction::eSubAction_CRYPTHASH,
            eMajorErrorCode::eMajorErrorCode_RUNTIMEERROR,
            eMinorErrorCode::eMinorErrorCode_UKNNTSTATUS,
            statusBCryptHash
        );
    }

    BCryptCloseAlgorithmProvider(hHashAlg, 0);
}

","Depending on what API you're using beyond that point, the 20 bytes are either little-endian or big-endian.  Since you say the 3rd one came out as negative it appears to be little-endian.
Little Endian Fix:
vSerialNumber[19] &= 0x7F

Big Endian Fix:
vSerialNumber[0] &= 0x7F;

""Eh, just work"" Fix:
vSerialNumber[0] &= 0x7F;
vSerialNumber[19] &= 0x7F

You've reduced your entropy by one (or two) bits, but you're still in a safe range.
","61","<certificate><serial-number><cng>","0","2","1","2018-03-15 00:06:02","49289540","0","","","","","2018-03-14 22:28:31",""
"54987255","CNG/BCrypt APIs in Windows IoT?","Does Windows IOT supports CNG/BCrypt APIs?
If possible, I'd like to have some references in case it does support.
","It is supported. You can see that API support desktop apps and UWP apps.

But there seems no such UWP sample. You can reference ""Encrypting Data with CNG"" and ""Typical CNG Programming"" for desktop and create your own C++ UWP application.
Reference ""Developing UWP applications for Windows IoT Core - C++""
Windows IoT Core also supports certain traditional Win32 app types such as Win32 Console Apps. There is an IoT Core C++ Console project template to make it easy to build such apps using Visual Studio.


","58","<c++><windows><encryption><windows-10-iot-core><cng>","0","1","1","2019-08-19 10:33:27","54998183","1","","608639","","2019-08-19 10:33:27","2019-03-04 16:16:38",""
"55077983","CNG Create Shared Secret","The idea is to have two applications have a CNG shared secret.

Applications A and B create (or import) a certificate. If creating, It uses CertCreateSelfSignCertificate() with a NCryptCreatePersistedKey() handle.
Applications serialize their certificate (CertSerializeCertificateStoreElement())  and transmit to the other end.
Application A recreates the B certificate (CertAddSerializedElementToStore()) and vice versa.

Now I'm supposed to use either NCryptSecretAgreement() or BCryptSecretAgreement() to create the shared secret.  The problem is that CryptImportPublicKeyInfoEx2() imports the public key (of the received certificate) into a BCRYPT_KEY_HANDLE, where I would need a NCRYPT_KEY_HANDLE to call NCryptSecretAgreement(). If I want to use BCryptSecretAgreement(), then I would need a BCRYPT_KEY_HANDLE which is not what CryptAcquireCertificatePrivateKey() would return.
How to proceed from here?
shared_ptr<NcryptObject> CreateShared(CertX& priv,CertX& pub)
{
    shared_ptr<NcryptObject> o;

    HCRYPTPROV_OR_NCRYPT_KEY_HANDLE h1 = 0;
    DWORD kt = 0;
    BOOL kb = 0;
    CryptAcquireCertificatePrivateKey(priv.h(), CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG, 0, &h1, &kt, &kb);
    if (!h1)
        return nullptr;
    shared_ptr<NcryptObject> k1;
    if (kb)
        k1 = make_shared<NcryptObject>(h1);

    BCRYPT_KEY_HANDLE bc = 0;
    CryptImportPublicKeyInfoEx2(X509_ASN_ENCODING,&pub.h()->pCertInfo->SubjectPublicKeyInfo, 0, 0, &bc);
    if (!bc)
        return 0;

    // whops.
    NCRYPT_SECRET_HANDLE se = 0;
    auto e1 = NCryptSecretAgreement(h1,(NCRYPT_KEY_HANDLE)bc, &se, 0);
    BCRYPT_SECRET_HANDLE se2 = 0;
    auto e2 = BCryptSecretAgreement((BCRYPT_KEY_HANDLE)h1, bc, &se2, 0);


}

","","42","<winapi><cng>","0","","0","2019-03-09 13:46:42","","0","","","","","2019-03-09 13:46:42",""
"56950124","How to translate CryptoApi to Cryptography API: Next Generation","I am tasked with replacing some old legacy code using CryptoApi, which is deprecated, with the newer Cryptography API: Next Generation from windows. The new encryption method must produce the same result as the old one.
I have simplified the old methods to make it more compact (you could view it as pseudocode):
private UIntPtr mProviderHandle = UIntPtr.Zero;
private UIntPtr mHashHandle = UIntPtr.Zero;
private UIntPtr mKeyHandle = UIntPtr.Zero;
private uint mBlockSize = 0;
private bool m_disposed;

private void Init(string pContextName, string pSharedSecret)
{
    string providerName = = ""Microsoft Base Cryptographic Provider v1.0"";
    var providerType = ProviderType.PROV_RSA_FULL; // 1
    var providerFlags = ContextOperations.CRYPT_DEFAULT; // 0
    var hashAlg = ProviderAlgorithm.CALG_MD5; // 0x8003
    var keyAlg = ProviderAlgorithm.CALG_RC2; // 0x6602
    CryptAcquireContext(ref mProviderHandle, pContextName, providerName, providerType, providerFlags);

    CryptCreateHash(mProviderHandle, hashAlg, UIntPtr.Zero, 0, ref mHashHandle);

    CryptHashData(mHashHandle, Encoding.Default.GetBytes(pSharedSecret), (uint)pSharedSecret.Length, 0))

    CryptDeriveKey(mProviderHandle, keyAlg, mHashHandle, 0, ref mKeyHandle)); 
}

public byte[] Encrypt(byte[] pData, bool pFinal = true)
{
    uint length = (uint)bytes.Length;
    uint m = 0;

    if (0 < BlockSize)
    {
        // one more blocks than the number of blocks touched
        m = (uint)(((((length - 1) / BlockSize) + 1) + 1) * BlockSize);
        Array.Resize(ref bytes, (int)m);
    }
    else
    {
        m = length;
    }
    APIBOOL apiFinal = pFinal ? APIBOOL.TRUE : APIBOOL.FALSE;
    if (APIBOOL.FALSE != NativeMethods.CryptEncrypt(mKeyHandle, UIntPtr.Zero, apiFinal, 0,
            bytes, ref length, m))
    {
        Array.Resize(ref bytes, (int)length);
        encrypted = true;
    }

    return bytes;
}

And here is the new method:
private byte[] EncryptCNG(byte[] data, string pSharedSecret)
{
    using (RC2CryptoServiceProvider rc2 = new RC2CryptoServiceProvider())
    {
        using (MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider())
        {
            rc2.Key = md5.ComputeHash(Encoding.Unicode.GetBytes(pSharedSecret));
            rc2.IV = new byte[rc2.BlockSize/8];
        }
        var encryptor = rc2.CreateEncryptor();
        var result = encryptor.TransformFinalBlock(data, 0, data.Length);
        return result;
    }
}

Both methods Encrypt() and EncryptCNG() produce a byte array with the same length and constant value (depending on the input). But the values/bytes differ. The Desired result is that the same input generates identical output. So that Encrypt can be replaced by EncryptCNG.
My Questions are whether EncryptCNG is the correct way to use the new API and if it is a correct translation of the functionality of Init + Encrypt? And if it is, Why does it generates different results?
Any Help is much appreciated.
","","41","<c#><cryptoapi><cng>","0","","0","2019-07-09 10:24:31","","0","","3006215","","2019-07-09 10:24:31","2019-07-09 10:03:24",""
"53686034","Can/how do microsoft docker containers work with CNG KSPs?","I have some windows c++ code that uses CNG to access the Microsoft Software Key Storage Provider:
https://docs.microsoft.com/en-us/windows/desktop/seccertenroll/cng-key-storage-providers#microsoft-software-key-storage-provider
I would like to containerize my application with Docker using Hyper V or Server Containers. Can I do so any still access that provider? Or any provider?
I haven't found any doc saying whether or how this would work, other than that Server Containers hit the kernel and Hyper V cannot:
https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/index
I would presume that means that if anything only the server containers would work on the Microsoft Software KSP...does anyone know better?
","
Can I do so any still access that provider? O

Yes, you can still access provider, but state would be completely clear(no internal data was shared between host machine and container)

Or any provider
  You can't guarantee it, especially for third-party CSPs, because nanoserver has limited subset of winapi(e.g. no advapi32), some providers will fail to load in this environment

","37","<windows><docker><cng>","0","1","1","2019-01-15 16:06:21","54202607","0","0","","","","2018-12-08 19:16:41",""
"58396684","what is the CngKeyBlobFormat of EccPrivateBlob generated by CngAlgorithm.ECDiffieHellmanP521/P256/P384?","CngKey key = CngKey.Create(CngAlgorithm.ECDiffieHellmanP521, null,
   new CngKeyCreationParameters { ExportPolicy = CngExportPolicies.AllowPlaintextExport });    
byte[] keyBlob= key.Export(CngKeyBlobFormat.EccPrivateBlob);

the length of keyBlob is 206. what is its format? which bytes are the 32 bytes private key and 64 bytes public key?
at Import a Public key from somewhere else to CngKey?, the length is 4+4+64+32=104. 
","The binary structure of the blobs is the same for all three curves:
<magic number, 4 bytes><modulus length in bytes, 4 bytes><x-value of public key><y-value of public key><private key>

In detail applies:

secp256r1 / NIST P-256
Private: 45434B32 20000000 <x-value of public key, 32 bytes><y-value of public key, 32 bytes><private key, 32 bytes>   total length: 104 bytes
Public:  45434B31 20000000 <x-value of public key, 32 bytes><y-value of public key, 32 bytes>                          total length:  72 bytes

secp384r1 / NIST P-384
Private: 45434B34 30000000 <x-value of public key, 48 bytes><y-value of public key, 48 bytes><private key, 48 bytes>   total length: 152 bytes
Public:  45434B33 30000000 <x-value of public key, 48 bytes><y-value of public key, 48 bytes>                          total length: 104 bytes

secp521r1 / NIST P-521
Private: 45434B36 42000000 <x-value of public key, 66 bytes><y-value of public key, 66 bytes><private key, 66 bytes>   total length: 206 bytes
Public:  45434B35 42000000 <x-value of public key, 66 bytes><y-value of public key, 66 bytes>                          total length: 140 bytes


The private key and the x- and y-component of the public key are stored in big-endian format. All three components have the length of the modulus. The different lengths of the blobs are thus caused by the different modulus of the curves.
See also: SECG, SEC2, key blob format, magic numbers, format of ECCPublicBlob and ECCPrivateBlob
","37","<c#><cng><ecdh>","0","0","1","2019-10-16 13:50:15","58414955","3","","12220851","","2019-10-16 03:05:07","2019-10-15 14:10:35",""
"46939941","optimization options and usage of windows dll calls","I am building a dll for windows, using a Makefile, using cl.exe.  I am using VS2015.. this dll uses CNG (bcrypt) for encryption operations, and bcryptr is loaded dynamically using loadlibrary call. 
When i build with /Od option to disable optimization, i have no issues with any functionality. but if i use any optimization option /O1, /O2, /Ox, i see the strangest thing happen.. once i retrieve the address for a bcrypt function, such as BCryptGetFipsAlgorithmMode, using GetProcAddress, and then i make the call to that function ptr, the call stack goes away. This results in exception when the calling function tries to return.. it looks almost like when one calls a callback doesn't have the CALLBACK prefix, but i dont see the connection..
That bcrypt function's prototype looks like this:
NTSTATUS WINAPI BCryptGetFipsAlgorithmMode(  __out  BOOLEAN *pfEnabled)
and WINAPI seems to be defined:
define WINAPI      __stdcall
Is there something I am missing?  what does optimization have to do with this?
Any help would be appreciated.. Thank You!
Heres the code:
NTSTATUS GetFipsAlgorithmMode(BOOLEAN *pfEnabled )
{
   FARPROC pBCryptGetFipsAlgorithmMode = NULL;
   NTSTATUS (*_BCryptGetFipsAlgorithmMode)( __out  BOOLEAN *);
   NTSTATUS status = SPGC_ERR_LIBRARY_ADDRESS_LOOKUP_FAILURE;

   if(g_hBCRYPTDLL != NULL)
   {
      pBCryptGetFipsAlgorithmMode = GetProcAddress(g_hBCRYPTDLL, _T(""BCryptGetFipsAlgorithmMode""));
      if(pBCryptGetFipsAlgorithmMode != NULL)
      {
         _BCryptGetFipsAlgorithmMode = (NTSTATUS (*)( __out  BOOLEAN *)) pBCryptGetFipsAlgorithmMode;

         status = _BCryptGetFipsAlgorithmMode(pfEnabled);
      }
   }
   return status;
}

step over the call to _BCryptGetFipsAlgorithmMode(), and the call stack basically gets cleared. 
","","27","<windows><visual-studio><makefile><cng>","0","","0","2017-10-25 20:14:46","","4","","4912539","","2017-10-25 20:14:46","2017-10-25 18:46:28",""
"58055311","CNG stored certificate signing a hash using c# vs using csp","We have been using a stored certificate with a private key and a token to do some signing of hashes.  The token provider is no longer so we are using a different certificate provider.  They provide an private key encrypted with a password but they are using CNG.  We cannot use CSP to pass the password.  I can't find a way with CNG to pass a password in code.  
Here's what worked before with CSP:
     CspParameters csp = new CspParameters(1, m_TokenCSPName);

     csp.Flags = CspProviderFlags.UseDefaultKeyContainer;
     csp.KeyContainerName = m_CertContainer;
     csp.KeyNumber = (int)KeyNumber.Exchange;
     csp.KeyPassword = spw;

     RSACryptoServiceProvider rsa1 = new RSACryptoServiceProvider(csp);


Using that rsa1 object I can sign the hash.  
Looking at some other postings here I found I can get the private key from the CNG stored certificate as follows - and I can sign the hash using this code:
The key here is the 
rsa2.ImportParameters(privatekeyA.ExportParameters(true));

which is what I found is necessary when using CNG stored certificate.
certificate is the x509 certificate object 
RSACryptoServiceProvider rsa2 = new RSACryptoServiceProvider();

var privatekeyA = certificate.GetRSAPrivateKey();

rsa2.ImportParameters(privatekeyA.ExportParameters(true));


string SignatureString = ""Data that is to be signed"";
byte[] plainTextBytes = Encoding.ASCII.GetBytes(SignatureString);
bool Verified = false;
using (SHA1CryptoServiceProvider shaM = new SHA1CryptoServiceProvider())
{
// hash the data to be signed - you can use signData and avoid the hashing if you like

byte[] hash = shaM.ComputeHash(plainTextBytes);
// sign the hash
byte[] digitalSignature = rsa2.SignHash(hash, CryptoConfig.MapNameToOID(""SHA1""));


etc...  and this works.  But since I cannot use csp - I cannot pass the password in code.  It does encrypt fine but it pops up the prompt to enter the password.
The question is - how do I use this CNG stored certificate to sign the hash and pass the password?
","","20","<c#><encryption><cng>","0","","0","2019-09-23 03:35:20","","1","","2709214","","2019-09-23 03:35:20","2019-09-23 03:32:00",""
"58747521","Different label and MGF1 hash functions using RsaCng with OAEP","We've to decrypt a ciphertext encrypted using RSA OAEP and we're trying to use RsaCng. The ciphertext was produced using Java, and the Java API allows you to specify a different hash function for the label and for the mask generation function (MGF1). In this specific case, SHA-256 was used in the first case and SHA-1 in the second (yes, not a good idea but we have no control over this).
Now, from what I understand using RsaCng I can only specify one hash function (using RSAEncryptionPadding.OaepXXX) and this function will be used in both places. This means that I will always fail to decrypt the ciphertext. Is there any way to work around this using CNG? Looking at the low-level Win API C functions (BCryptDecrypt) it looks the same limitation exists. I believe BouncyCastle allows this flexibility but due to the requirement of integration with an HSM, we cannot use BC.
Thank you for your help,
Dinis
","","18","<c#><.net><hash><rsa><cng>","0","","0","2019-11-07 11:11:23","","1","","","","","2019-11-07 11:11:23",""
"54748344","Custom cng provider not listed under Certificate authority create private key dropdown","I am trying to integrate custom CNG provider with Active directory certificate services. 
This custom cng provider works well with Sql server but not with AD CS. I followed steps to create Root Certificate authority and on create private key window I expected my cng provider will be listed under provider but it is not.
I tried listing provider using ""certutil -csplist"" command and provider is listed there.
OS- Windows Server 2016 (64 bit)
","","16","<windows-server-2016><certificate-authority><cng><root-certificate><key-storage>","0","","0","2019-02-18 13:24:25","","0","","","","","2019-02-18 13:24:25",""

post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"34451214","How to sign and verify signature with ecdsa in python","<p>I need to sign a hash of 256 bits with ECDSA using a private key of 256 bits, just as bitcoin does, and I am reaching desperation because of the lack of documentation of ecdsa in python.</p>

<p>I found a lot of codes on the internet, but there was nothing as easy as just <code>ecdsa.sign(msg, privkey)</code> or similar, everything I found is a lot of code of mathematical stuff I don't understand, but yet they use the ecdsa library (I don't know why they wouldn't add a signing function in a library that is going to be used to sign stuff, instead a page of code is needed when using the library?).</p>

<p>This is the best code I found so far:</p>

<pre><code>def ecdsa_sign(val, secret_exponent):
    """"""Return a signature for the provided hash, using the provided
    random nonce. It is absolutely vital that random_k be an unpredictable
    number in the range [1, self.public_key.point.order()-1].  If
    an attacker can guess random_k, he can compute our private key from a
    single signature. Also, if an attacker knows a few high-order
    bits (or a few low-order bits) of random_k, he can compute our private
    key from many signatures. The generation of nonces with adequate
    cryptographic strength is very difficult and far beyond the scope
    of this comment.

    May raise RuntimeError, in which case retrying with a new
    random value k is in order.
    """"""
    G = ecdsa.SECP256k1
    n = G.order()
    k = deterministic_generate_k(n, secret_exponent, val)
    p1 = k * G
    r = p1.x()
    if r == 0: raise RuntimeError(""amazingly unlucky random number r"")
    s = ( ecdsa.numbertheory.inverse_mod( k, n ) * ( val + ( secret_exponent * r ) % n ) ) % n
    if s == 0: raise RuntimeError(""amazingly unlucky random number s"")

    return signature_to_der(r, s)

def deterministic_generate_k(generator_order, secret_exponent, val, hash_f=hashlib.sha256):
    """"""
    Generate K value according to https://tools.ietf.org/html/rfc6979
    """"""
    n = generator_order
    order_size = (bit_length(n) + 7) // 8
    hash_size = hash_f().digest_size
    v = b'\x01' * hash_size
    k = b'\x00' * hash_size
    priv = intbytes.to_bytes(secret_exponent, length=order_size)
    shift = 8 * hash_size - bit_length(n)
    if shift &gt; 0:
        val &gt;&gt;= shift
    if val &gt; n:
        val -= n
    h1 = intbytes.to_bytes(val, length=order_size)
    k = hmac.new(k, v + b'\x00' + priv + h1, hash_f).digest()
    v = hmac.new(k, v, hash_f).digest()
    k = hmac.new(k, v + b'\x01' + priv + h1, hash_f).digest()
    v = hmac.new(k, v, hash_f).digest()

    while 1:
        t = bytearray()

        while len(t) &lt; order_size:
            v = hmac.new(k, v, hash_f).digest()
            t.extend(v)

        k1 = intbytes.from_bytes(bytes(t))

        k1 &gt;&gt;= (len(t)*8 - bit_length(n))
        if k1 &gt;= 1 and k1 &lt; n:
            return k1

        k = hmac.new(k, v + b'\x00', hash_f).digest()
        v = hmac.new(k, v, hash_f).digest()
</code></pre>

<p>But I just can't trust a code like that because I have no idea what it does. Also, the comments in ecdsa_sign says that returns a signature given the value, the secret exponent, <strong>and a nonce</strong>. It says its very important to have a nonce, but I just can't figure out where that nonce is.</p>

<p>Is there any simple, one-line way to sign and verify ECDSA signatures using whatever trusted library in python on windows?</p>
","<p>You can try using the python ecdsa package, using Python3:</p>

<pre><code>pip3 install ecdsa
</code></pre>

<p>Usage:</p>

<pre><code>import ecdsa

# SECP256k1 is the Bitcoin elliptic curve
sk = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1) 
vk = sk.get_verifying_key()
sig = sk.sign(b""message"")
vk.verify(sig, b""message"") # True
</code></pre>

<p>To verify an existing signature with a public key:</p>

<pre><code>import ecdsa

message = b""message""
public_key = '98cedbb266d9fc38e41a169362708e0509e06b3040a5dfff6e08196f8d9e49cebfb4f4cb12aa7ac34b19f3b29a17f4e5464873f151fd699c2524e0b7843eb383'
sig = '740894121e1c7f33b174153a7349f6899d0a1d2730e9cc59f674921d8aef73532f63edb9c5dba4877074a937448a37c5c485e0d53419297967e95e9b1bef630d'

vk = ecdsa.VerifyingKey.from_string(bytes.fromhex(public_key), curve=ecdsa.SECP256k1)
vk.verify(bytes.fromhex(sig), message) # True
</code></pre>

<p>The package is compatible with Python 2 as well</p>
","17155","<python><ecdsa>","13","25","3","2019-01-31 23:58:42","","4","","","","","2015-12-24 10:20:58",""
"34451214","How to sign and verify signature with ecdsa in python","<p>I need to sign a hash of 256 bits with ECDSA using a private key of 256 bits, just as bitcoin does, and I am reaching desperation because of the lack of documentation of ecdsa in python.</p>

<p>I found a lot of codes on the internet, but there was nothing as easy as just <code>ecdsa.sign(msg, privkey)</code> or similar, everything I found is a lot of code of mathematical stuff I don't understand, but yet they use the ecdsa library (I don't know why they wouldn't add a signing function in a library that is going to be used to sign stuff, instead a page of code is needed when using the library?).</p>

<p>This is the best code I found so far:</p>

<pre><code>def ecdsa_sign(val, secret_exponent):
    """"""Return a signature for the provided hash, using the provided
    random nonce. It is absolutely vital that random_k be an unpredictable
    number in the range [1, self.public_key.point.order()-1].  If
    an attacker can guess random_k, he can compute our private key from a
    single signature. Also, if an attacker knows a few high-order
    bits (or a few low-order bits) of random_k, he can compute our private
    key from many signatures. The generation of nonces with adequate
    cryptographic strength is very difficult and far beyond the scope
    of this comment.

    May raise RuntimeError, in which case retrying with a new
    random value k is in order.
    """"""
    G = ecdsa.SECP256k1
    n = G.order()
    k = deterministic_generate_k(n, secret_exponent, val)
    p1 = k * G
    r = p1.x()
    if r == 0: raise RuntimeError(""amazingly unlucky random number r"")
    s = ( ecdsa.numbertheory.inverse_mod( k, n ) * ( val + ( secret_exponent * r ) % n ) ) % n
    if s == 0: raise RuntimeError(""amazingly unlucky random number s"")

    return signature_to_der(r, s)

def deterministic_generate_k(generator_order, secret_exponent, val, hash_f=hashlib.sha256):
    """"""
    Generate K value according to https://tools.ietf.org/html/rfc6979
    """"""
    n = generator_order
    order_size = (bit_length(n) + 7) // 8
    hash_size = hash_f().digest_size
    v = b'\x01' * hash_size
    k = b'\x00' * hash_size
    priv = intbytes.to_bytes(secret_exponent, length=order_size)
    shift = 8 * hash_size - bit_length(n)
    if shift &gt; 0:
        val &gt;&gt;= shift
    if val &gt; n:
        val -= n
    h1 = intbytes.to_bytes(val, length=order_size)
    k = hmac.new(k, v + b'\x00' + priv + h1, hash_f).digest()
    v = hmac.new(k, v, hash_f).digest()
    k = hmac.new(k, v + b'\x01' + priv + h1, hash_f).digest()
    v = hmac.new(k, v, hash_f).digest()

    while 1:
        t = bytearray()

        while len(t) &lt; order_size:
            v = hmac.new(k, v, hash_f).digest()
            t.extend(v)

        k1 = intbytes.from_bytes(bytes(t))

        k1 &gt;&gt;= (len(t)*8 - bit_length(n))
        if k1 &gt;= 1 and k1 &lt; n:
            return k1

        k = hmac.new(k, v + b'\x00', hash_f).digest()
        v = hmac.new(k, v, hash_f).digest()
</code></pre>

<p>But I just can't trust a code like that because I have no idea what it does. Also, the comments in ecdsa_sign says that returns a signature given the value, the secret exponent, <strong>and a nonce</strong>. It says its very important to have a nonce, but I just can't figure out where that nonce is.</p>

<p>Is there any simple, one-line way to sign and verify ECDSA signatures using whatever trusted library in python on windows?</p>
","<p>you can also use sep256k1 library in Python to ecdsa sign and verify. The public and private keys are the keys generated from Bip32 specifications and seed from Bip39 specifications.</p>

<pre><code> Private key  is  1149ab92fbc40993f21336206ca184a9dc2d5231eb575d2a0a6d56773bf0f356
 Public key  is  03c7ac999403591bceacca3d37598886f7c41943c8045c7e1cb5a9295d0003cc5b


from sawtooth_signing.secp256k1 import Secp256k1PrivateKey
from sawtooth_signing.secp256k1 import Secp256k1PublicKey

def sign_nonce(hex_private_key):
   nonce = random.randint(2**10, 2**32)
   checksum = hashlib.sha3_512(str(nonce).encode()).hexdigest()

   private_key = Secp256k1PrivateKey.from_hex(hex_private_key)
   message = private_key.secp256k1_private_key.ecdsa_sign(str(nonce).encode())
   serialized_message = private_key.secp256k1_private_key.ecdsa_serialize(message)
   hex_message = binascii.hexlify(serialized_message)
   return nonce, checksum, hex_message


def verify_nonce(nonce, checksum, message, hex_public_key):
   ##message is hex encoded
   message = binascii.unhexlify(message)
   public_key = Secp256k1PublicKey.from_hex(hex_public_key)
   unserialized = public_key.secp256k1_public_key.ecdsa_deserialize(message)
   result = public_key.secp256k1_public_key.ecdsa_verify(str(nonce).encode(),    unserialized)
  return result
</code></pre>

<p>The result will be True or False depending upon the verification.
i have used uint32(typings) or int as a nonce, but any byte array or string can be used. strings need to be converted to bytes. </p>
","17155","<python><ecdsa>","13","0","3","2019-01-31 23:58:42","","4","","","","","2015-12-24 10:20:58",""
"34451214","How to sign and verify signature with ecdsa in python","<p>I need to sign a hash of 256 bits with ECDSA using a private key of 256 bits, just as bitcoin does, and I am reaching desperation because of the lack of documentation of ecdsa in python.</p>

<p>I found a lot of codes on the internet, but there was nothing as easy as just <code>ecdsa.sign(msg, privkey)</code> or similar, everything I found is a lot of code of mathematical stuff I don't understand, but yet they use the ecdsa library (I don't know why they wouldn't add a signing function in a library that is going to be used to sign stuff, instead a page of code is needed when using the library?).</p>

<p>This is the best code I found so far:</p>

<pre><code>def ecdsa_sign(val, secret_exponent):
    """"""Return a signature for the provided hash, using the provided
    random nonce. It is absolutely vital that random_k be an unpredictable
    number in the range [1, self.public_key.point.order()-1].  If
    an attacker can guess random_k, he can compute our private key from a
    single signature. Also, if an attacker knows a few high-order
    bits (or a few low-order bits) of random_k, he can compute our private
    key from many signatures. The generation of nonces with adequate
    cryptographic strength is very difficult and far beyond the scope
    of this comment.

    May raise RuntimeError, in which case retrying with a new
    random value k is in order.
    """"""
    G = ecdsa.SECP256k1
    n = G.order()
    k = deterministic_generate_k(n, secret_exponent, val)
    p1 = k * G
    r = p1.x()
    if r == 0: raise RuntimeError(""amazingly unlucky random number r"")
    s = ( ecdsa.numbertheory.inverse_mod( k, n ) * ( val + ( secret_exponent * r ) % n ) ) % n
    if s == 0: raise RuntimeError(""amazingly unlucky random number s"")

    return signature_to_der(r, s)

def deterministic_generate_k(generator_order, secret_exponent, val, hash_f=hashlib.sha256):
    """"""
    Generate K value according to https://tools.ietf.org/html/rfc6979
    """"""
    n = generator_order
    order_size = (bit_length(n) + 7) // 8
    hash_size = hash_f().digest_size
    v = b'\x01' * hash_size
    k = b'\x00' * hash_size
    priv = intbytes.to_bytes(secret_exponent, length=order_size)
    shift = 8 * hash_size - bit_length(n)
    if shift &gt; 0:
        val &gt;&gt;= shift
    if val &gt; n:
        val -= n
    h1 = intbytes.to_bytes(val, length=order_size)
    k = hmac.new(k, v + b'\x00' + priv + h1, hash_f).digest()
    v = hmac.new(k, v, hash_f).digest()
    k = hmac.new(k, v + b'\x01' + priv + h1, hash_f).digest()
    v = hmac.new(k, v, hash_f).digest()

    while 1:
        t = bytearray()

        while len(t) &lt; order_size:
            v = hmac.new(k, v, hash_f).digest()
            t.extend(v)

        k1 = intbytes.from_bytes(bytes(t))

        k1 &gt;&gt;= (len(t)*8 - bit_length(n))
        if k1 &gt;= 1 and k1 &lt; n:
            return k1

        k = hmac.new(k, v + b'\x00', hash_f).digest()
        v = hmac.new(k, v, hash_f).digest()
</code></pre>

<p>But I just can't trust a code like that because I have no idea what it does. Also, the comments in ecdsa_sign says that returns a signature given the value, the secret exponent, <strong>and a nonce</strong>. It says its very important to have a nonce, but I just can't figure out where that nonce is.</p>

<p>Is there any simple, one-line way to sign and verify ECDSA signatures using whatever trusted library in python on windows?</p>
","<p>How to install it:</p>

<p><code>pip install starkbank-ecdsa</code></p>

<p>How to use it:</p>

<pre class=""lang-py prettyprint-override""><code># Generate Keys
privateKey = PrivateKey()
publicKey = privateKey.publicKey()

message = ""My test message""

# Generate Signature
signature = Ecdsa.sign(message, privateKey)

# Verify if signature is valid
print Ecdsa.verify(message, signature, publicKey)
</code></pre>

<p>Full reference: <a href=""https://github.com/starkbank/ecdsa-python"" rel=""nofollow noreferrer"">https://github.com/starkbank/ecdsa-python</a></p>
","17155","<python><ecdsa>","13","2","3","2019-01-31 23:58:42","","4","","","","","2015-12-24 10:20:58",""
"17893579","https with ECDHE-ECDSA-AES256-GCM-SHA384 in windows 2012","<p>I have been a long time reader but this is my first real post on a topic that I couldn't find a solution to.</p>

<p>I am currently hosting a website on Windows 2012 that I would like to get the latest TLS 1.2 ciphersuites running on.</p>

<p>I am aware of how to enable TLS 1.1 and TLS 1.2 in windows and have done so(via registry edits). I have also changed the cipher order to what I would like it to be.</p>

<p>My question is: How do i actually go through and set up my ECDHE / ECDSA portion of the cipher suite after this step?</p>

<p>When i view the site in the latest chrome beta (which supports ECDHE and ECDSA in TLS 1.2 provided you use the supported curves) it seems to skip all of the ECHDE ciphersuites.</p>

<p>Is there something else i need to do to get ECDHE/ECDSA properly enabled?</p>

<p>I have read around on the net trying to solve this myself and they mention making copies of your root cert and then modifying them to somehow support ECDHE. Am i barking up the wrong tree?</p>

<p>Thank you in advance for any and all support with this issue.</p>

<p>Edit: adding clarification/progress</p>

<p>After more research, I have found that in order to get ECDSA to work, you need an ECDSA certificate. The only way to get one at this time is to self-sign, as the cert-cartel has not yet come up with proper cross-licensing agreements and fee structures for Ellipic Curve Certificates yet.</p>

<p>Since self-signing is not an option for this site, I have removed all ECDSA suites from the cipher-order.</p>

<p>Unfortunately, because all of the AES Galois Counter Mode suites were also ECDSA, this rules those out for the time being.</p>

<p>This leaves me with a strongest cipher suite of ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521 which I BELIEVE is supported by the latest version of Chrome beta correct? I can't seem to get Chrome to pick up anything beyond SHA-1. Is there no SHA-2 support? even in the latest beta?</p>
","<p>AES-GCM is about how you encrypt the data in your connexion, EC-DSA or RSA about how the server identifies itself to the client. There is therefore no reason why you couldn't do AES-GCM encryption with a RSA authentication.</p>

<p>RFC 5289 does define the needed suite for that :
<a href=""http://tools.ietf.org/html/rfc5289#section-3.2"" rel=""nofollow"">http://tools.ietf.org/html/rfc5289#section-3.2</a></p>

<blockquote>
<pre><code>CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    = {0xC0,0x2F};
CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384    = {0xC0,0x30};
CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256     = {0xC0,0x31};
CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384     = {0xC0,0x32};
</code></pre>
</blockquote>

<p>It's not however necessarily easy to find both the client and the server that will support them.</p>
","11743","<windows><security><ssl><ssl-certificate><ecdsa>","6","3","2","2014-11-12 14:24:50","","2","1","2555174","","2013-07-29 09:24:20","2013-07-27 02:09:04",""
"17893579","https with ECDHE-ECDSA-AES256-GCM-SHA384 in windows 2012","<p>I have been a long time reader but this is my first real post on a topic that I couldn't find a solution to.</p>

<p>I am currently hosting a website on Windows 2012 that I would like to get the latest TLS 1.2 ciphersuites running on.</p>

<p>I am aware of how to enable TLS 1.1 and TLS 1.2 in windows and have done so(via registry edits). I have also changed the cipher order to what I would like it to be.</p>

<p>My question is: How do i actually go through and set up my ECDHE / ECDSA portion of the cipher suite after this step?</p>

<p>When i view the site in the latest chrome beta (which supports ECDHE and ECDSA in TLS 1.2 provided you use the supported curves) it seems to skip all of the ECHDE ciphersuites.</p>

<p>Is there something else i need to do to get ECDHE/ECDSA properly enabled?</p>

<p>I have read around on the net trying to solve this myself and they mention making copies of your root cert and then modifying them to somehow support ECDHE. Am i barking up the wrong tree?</p>

<p>Thank you in advance for any and all support with this issue.</p>

<p>Edit: adding clarification/progress</p>

<p>After more research, I have found that in order to get ECDSA to work, you need an ECDSA certificate. The only way to get one at this time is to self-sign, as the cert-cartel has not yet come up with proper cross-licensing agreements and fee structures for Ellipic Curve Certificates yet.</p>

<p>Since self-signing is not an option for this site, I have removed all ECDSA suites from the cipher-order.</p>

<p>Unfortunately, because all of the AES Galois Counter Mode suites were also ECDSA, this rules those out for the time being.</p>

<p>This leaves me with a strongest cipher suite of ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521 which I BELIEVE is supported by the latest version of Chrome beta correct? I can't seem to get Chrome to pick up anything beyond SHA-1. Is there no SHA-2 support? even in the latest beta?</p>
","<p>I had similar experiences with Win2008 R2.
Depending on the certificate, GCM cipher is offered by the server or not.</p>

<p>With self-signed ECDSA certificate i got GCM to work but older browsers
or Windows XP can't connect to such a https-site.</p>

<p>Windows doesnt support any TLS_ECDHE_RSA...GCM... ciphers:
<a href=""http://msdn.microsoft.com/en-us/library/aa374757(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/aa374757(v=vs.85).aspx</a>
Thus normal RSA-certificates don't work with GCM under Windows.</p>

<p>Browser compatibility:
<a href=""http://www.g-sec.lu/sslharden/SSL_comp_report2011.pdf"" rel=""nofollow"">http://www.g-sec.lu/sslharden/SSL_comp_report2011.pdf</a></p>
","11743","<windows><security><ssl><ssl-certificate><ecdsa>","6","3","2","2014-11-12 14:24:50","","2","1","2555174","","2013-07-29 09:24:20","2013-07-27 02:09:04",""
"25261823","ECDSA signature generation using secp256r1 curve and SHA256 algorithm - BouncyCastle","<p>I am trying to generate signature using ECDSA with secp256r1 curve (P256) and SHA256 algorithm for message hash. Also i am using Bouncy Castle libraries. 
Code below, </p>

<pre><code>public class MyTest {

    /**
     * @param args
     */
    public static void main(String[] args) {
        new MyTest().getSign();
    }

    void getSign() {
        // Get the instance of the Key Generator with ""EC"" algorithm

        try {
            KeyPairGenerator g = KeyPairGenerator.getInstance(""EC"");
            ECGenParameterSpec kpgparams = new ECGenParameterSpec(""secp256r1"");
            g.initialize(kpgparams);

            KeyPair pair = g.generateKeyPair();
            // Instance of signature class with SHA256withECDSA algorithm
            Signature ecdsaSign = Signature.getInstance(""SHA256withECDSA"");
            ecdsaSign.initSign(pair.getPrivate());

            System.out.println(""Private Keys is::"" + pair.getPrivate());
            System.out.println(""Public Keys is::"" + pair.getPublic());

            String msg = ""text ecdsa with sha256"";//getSHA256(msg)
            ecdsaSign.update((msg + pair.getPrivate().toString())
                    .getBytes(""UTF-8""));

            byte[] signature = ecdsaSign.sign();
            System.out.println(""Signature is::""
                    + new BigInteger(1, signature).toString(16));

            // Validation
            ecdsaSign.initVerify(pair.getPublic());
            ecdsaSign.update(signature);
            if (ecdsaSign.verify(signature))
                System.out.println(""valid"");
            else
                System.out.println(""invalid!!!!"");

        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }

    }

}
</code></pre>

<p>Here key pairs are generated using KeyPair , but for my requirement I will be having a static privateKey and public key. Also, validation of signature is always returning false.</p>

<p>Need help, how can I have static private key and on validation part.</p>
","<p>Jackpot - nothing in your title is a problem!</p>

<p>First, you probably aren't actually using BouncyCastle. Sun/Oracle Java 7 and 8 now includes an EC provider (earlier versions did not) and the one-arg form of <code>getInstance</code> uses the first available provider, which is normally SunEC unless you or someone has altered the provider list.</p>

<p><strong>TO VERIFY A SIGNATURE:</strong> pass the <strong>same</strong> data to the verifying <code>Signature.update()</code> as you passed to the signing <code>Signature.update()</code>. <strong>Exactly</strong> the same, byte for byte. Pass the signature value <strong>only</strong> to <code>Signature.verify()</code>. Putting <code>PrivateKey.toString()</code> in the data is silly; this value is specific to the running Java process, so you'll have to send it to the receiving process (if different, as it normally should be) where it is useless and a waste of space.</p>

<p><strong>TO USE A STATIC KEY:</strong> do just that. Create a keypair and store it someplace, then read it in and use it. The easiest secure (password protected) store is a Java KeyStore (JKS) file, but that requires a certificate chain (perhaps a dummy one) which is a nuisance to code yourself; fortunately the <code>keytool</code> utility with <code>-genkeypair</code> generates a keypair with a dummy selfsigned certificate, and for <code>-keyalg ec -keysize 256</code> it uses the (very popular) secp256r1 curve. Also specify <code>-alias name</code> of your choice, <code>-keystore filename</code>, any names you like for the dummy cert, and passwords. To use a keypair from a JKS file:</p>

<ul>
<li><p>use <code>java.security.KeyStore.getInstance(""JKS"")</code> to create a store object and pass <code>.load(InputStream,char[])</code> a <code>FileInputStream</code> on the file, and the password.</p></li>
<li><p>use <code>.getKey(String alias,char[] password)</code> and cast to get the PrivateKey. Use for signing.</p></li>
<li><p>use <code>.getCertificateChain(String alias)[0].getPublicKey()</code> to get the PublicKey from the first (only) cert. Use for verifying.</p></li>
</ul>
","11708","<java><bouncycastle><sha256><ecdsa>","3","7","1","2014-11-05 05:03:06","25263424","0","3","2432317","","2014-11-05 05:03:06","2014-08-12 10:18:30",""
"23176231","no module named ecdsa with Paramiko","<p>I keep coming up with the error <code>no module named ecdsa</code> when I run a program with Paramiko. I have installed it using pip, and it says that it <em>has</em> installed, but when I run the program again, it comes up with the error again!</p>

<p>What can I do? I'm using Linux, by the way.</p>
","<p>Make sure you have <code>ecdsa</code> module installed in your linux system. Go to prompt, and try running the following commands:</p>

<pre><code>    mamun@bobolink:~$ python
    Python 2.7.5+ (default, Feb 27 2014, 19:37:08)
    [GCC 4.8.1] on linux2
    Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
    &gt;&gt;&gt; from ecdsa import SigningKey
    &gt;&gt;&gt; sk = SigningKey.generate() # uses NIST192p
    &gt;&gt;&gt;
</code></pre>

<p>If you get error, then try installing the <code>ecdsa</code> module by the following command:</p>

<pre><code>    mamun@bobolink:~$ sudo pip install ecdsa
</code></pre>

<p>And you will get the following output that would confirm that the package has been installed.</p>

<pre><code>    Downloading/unpacking ecdsa
      Downloading ecdsa-0.11.tar.gz (45kB): 45kB downloaded
      Running setup.py egg_info for package ecdsa

    Installing collected packages: ecdsa
      Running setup.py install for ecdsa

    Successfully installed ecdsa
    Cleaning up...
</code></pre>
","11549","<python><paramiko><ecdsa>","5","11","2","2016-05-03 15:35:38","23177224","0","","","","","2014-04-19 22:19:08",""
"23176231","no module named ecdsa with Paramiko","<p>I keep coming up with the error <code>no module named ecdsa</code> when I run a program with Paramiko. I have installed it using pip, and it says that it <em>has</em> installed, but when I run the program again, it comes up with the error again!</p>

<p>What can I do? I'm using Linux, by the way.</p>
","<p>If you are on Python 3.x you might have to use pip3 instead of pip:</p>

<pre><code>sudo pip3 install ecdsa
</code></pre>
","11549","<python><paramiko><ecdsa>","5","2","2","2016-05-03 15:35:38","23177224","0","","","","","2014-04-19 22:19:08",""
"13791219","SSH fingerprint verification for Amazon AWS EC2 server with ECDSA?","<p>When I create a new Amazon EC2 server, I connect to it using <code>ssh</code> as usual.</p>

<p>I see the typical warning:</p>

<pre><code>$ ssh myserver  
The authenticity of host 'ec2-12-34-567-890.compute-1.amazonaws.com (12.34.567.890)'     can't be established.
ECDSA key fingerprint is 31:66:15:d2:19:41:2b:09:8a:8f:9f:bd:de:c6:ff:07.
Are you sure you want to continue connecting (yes/no)? 
</code></pre>

<p>How do I verify the fingerprint before I sign in? </p>

<p>Ideally an answer is based on something besides the original creation console log -- because the log may get flushed out after a system restart, or during a large system installation script that generates a lot of output, or the connection is to an older system with keys that weren't tracked at creation time.</p>
","<p>Here are two solutions that worked for me during the creation of the EC2 system. </p>

<p><b>Solution 1: Use the Amazon EC2 dashboard</b></p>

<ul>
<li>Go to <a href=""https://console.aws.amazon.com"" rel=""noreferrer"">https://console.aws.amazon.com</a></li>
<li>Tap ""EC2"" link.</li>
<li>Tap ""Instances"" in the left column</li>
<li>Tap the instance name you want</li>
<li>Tap the select button ""Actions"" and choose ""Get System Log"" (a.k.a. ""Console Output"")</li>
<li>In the console output, you should see the keys being generated</li>
</ul>

<p><b>Solution 2: Use the AWS EC2 command line</b></p>

<p>You can use the <code>aws</code> command or <code>ec2-get-console-output</code> command. Both are available for download from Amazon.</p>

<p>To use your EC2 private key pem file, certificate pem file, region, and instance:</p>

<pre><code>ec2-get-console-output \
  --private-key pk-ABCDEF1234567890.pem \
  --cert cert-ABCDEF1234567890.pem \
  --region us-east-1c \
  i-e706689a   
</code></pre>

<p>The output shows the ssh host key fingerprints like this:</p>

<pre><code>ec2: -----BEGIN SSH HOST KEY FINGERPRINTS-----
ec2: 1024 e0:79:1e:ba:2e:3c:71:87:2c:f5:62:2b:0d:1b:6d:7b  root@ip-10-243-118-182 (DSA)
ec2: 256 31:66:15:d2:19:41:2b:09:8a:8f:9f:bd:de:c6:ff:07  root@ip-10-243-118-182 (ECDSA)
ec2: 2048 ce:ec:3b:d3:34:3f:f3:45:76:81:9e:76:7a:d9:f5:e8  root@ip-10-243-118-182 (RSA)
ec2: -----END SSH HOST KEY FINGERPRINTS-----
</code></pre>

<p>The <code>aws</code> tool works similarly. </p>

<p>Note: these solutions only work during creation time, or when you can get the console logs. For a broader solution that works any time, see Martin's answer.</p>
","11482","<ssh><amazon-web-services><amazon-ec2><fingerprint><ecdsa>","32","18","2","2019-06-27 13:07:31","24773982","1","10","528726","","2014-07-22 17:04:52","2012-12-09 20:02:32",""
"13791219","SSH fingerprint verification for Amazon AWS EC2 server with ECDSA?","<p>When I create a new Amazon EC2 server, I connect to it using <code>ssh</code> as usual.</p>

<p>I see the typical warning:</p>

<pre><code>$ ssh myserver  
The authenticity of host 'ec2-12-34-567-890.compute-1.amazonaws.com (12.34.567.890)'     can't be established.
ECDSA key fingerprint is 31:66:15:d2:19:41:2b:09:8a:8f:9f:bd:de:c6:ff:07.
Are you sure you want to continue connecting (yes/no)? 
</code></pre>

<p>How do I verify the fingerprint before I sign in? </p>

<p>Ideally an answer is based on something besides the original creation console log -- because the log may get flushed out after a system restart, or during a large system installation script that generates a lot of output, or the connection is to an older system with keys that weren't tracked at creation time.</p>
","<p>As @joelparkerhenderson's answer covers, you can collect host key fingerprint from server's initial start log, when host keys are generated (by the <code>cloud-init</code> script):</p>

<p><a href=""https://i.stack.imgur.com/G5Fej.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/G5Fej.png"" alt=""enter image description here""></a></p>

<hr>

<p>If you fail to collect the keys this way, you can get them by connecting to your target instance from another trusted instance within private Amazon network, thus keeping yourself safe from man-in-the-middle attacks. </p>

<p>When on the trusted instance (the one you know fingerprints for) terminal, you can use following commands to collect fingerprints (<code>172.33.31.199</code> is the private IP):</p>

<pre><code>$ ssh-keyscan 172.33.31.199 &gt; ec2key
$ ssh-keygen -l -f ec2key
256 SHA256:oZHeiMEPLKetRgd3M5Itgwaqr2zJJH93EvSdx5UoHbQ &lt;ip&gt; (ED25519)
2048 SHA256:8zg105EUFFrPFpVzdfTGsgXnxuSpTiQd85k0uNapUio &lt;ip&gt; (RSA)
256 SHA256:L7UXLw0djE5B9W7ZhvrkYVSTZyi1MEQ2dBaRtpkkUGY &lt;ip&gt; (ECDSA)
</code></pre>

<hr>

<p>If you do not have another instance, whose fingerprints you know, create new temporary instance, just for the purpose of collecting the keys. First find keys for the new temporary instance, using it's initial start log. Connect to the temporary instance from public network. Then collect keys of the target instance by connecting to it from the temporary instance, over private Amazon network. After that you can discard the temporary instance.</p>

<hr>

<p>I have prepared <a href=""https://winscp.net/eng/docs/guide_amazon_ec2"" rel=""nofollow noreferrer"">Guide for connecting to EC2 instance safely using WinSCP</a>.</p>
","11482","<ssh><amazon-web-services><amazon-ec2><fingerprint><ecdsa>","32","29","2","2019-06-27 13:07:31","24773982","1","10","528726","","2014-07-22 17:04:52","2012-12-09 20:02:32",""
"17269238","ECDSA signature length","<p>What will the signature length for 256 bit EC key in ECDSA algorithm?
I wanted to validated signature length for the same. It will be great if some body can help me with one EC key set.</p>
","<p>It depends on how you encode the signature. This is the code segment from OpenSSL that measures the length of ECDSA signature in DER format. </p>

<pre><code>/** ECDSA_size
 * returns the maximum length of the DER encoded signature
 * \param  eckey pointer to a EC_KEY object
 * \return numbers of bytes required for the DER encoded signature
 */

int ECDSA_size(const EC_KEY *r)
{
    int ret,i;
    ASN1_INTEGER bs;
    BIGNUM  *order=NULL;
    unsigned char buf[4];
    const EC_GROUP *group;

    if (r == NULL)
        return 0;
    group = EC_KEY_get0_group(r);
    if (group == NULL)
        return 0;

    if ((order = BN_new()) == NULL) return 0;
    if (!EC_GROUP_get_order(group,order,NULL))
    {
        BN_clear_free(order);
        return 0;
    } 
    i=BN_num_bits(order);
    bs.length=(i+7)/8;
    bs.data=buf;
    bs.type=V_ASN1_INTEGER;
    /* If the top bit is set the asn1 encoding is 1 larger. */
    buf[0]=0xff;    

    i=i2d_ASN1_INTEGER(&amp;bs,NULL);
    i+=i; /* r and s */
    ret=ASN1_object_size(1,i,V_ASN1_SEQUENCE);
    BN_clear_free(order);
    return(ret);
}
</code></pre>

<p>The result of the above function with an EC_KEY on prime256 curve as parameter is</p>

<pre><code>sig_len = ECDSA_size(eckey);
</code></pre>

<p>where sig_len is <code>72</code>.</p>

<p>You need <code>72</code> bytes for DER encoded ECDSA signature using a 256-bit EC key.</p>
","9562","<elliptic-curve><ecdsa>","2","9","1","2013-06-26 06:19:24","","1","4","","","","2013-06-24 06:30:04",""
"16975842","How to convert an ECDSA key from hex to PEM format","<p>I have a hex string that allegedly contains an EC public key. I need to convert this hex string to PEM format (""key.pem"" in following example) in order to investigate the contents which I plan to do with ""openssl ec -in key.pem -text -noout"". Is this possible? </p>
","<p>I'm assuming by hex, you mean a binary (DER formatted) key?  Or is this hex string in a human readable file with a header beginning with ""-----BEGIN PUBLIC KEY-----""?  If you see that header, it is already in PEM format.</p>

<p>If it's in binary format, try this to convert a binary key to pem:</p>

<pre><code>openssl ec -in key.der -inform DER -pubin -out keyout.pem -outform PEM
</code></pre>

<p>where ""key.der"" is your binary key.</p>

<p>But, you should also be able to investigate the contents without converting to PEM.  Just use:</p>

<pre><code>openssl ec -in key.der -inform DER -pubin -text -noout
</code></pre>
","8601","<openssl><format><public-key><ecdsa>","2","0","2","2013-11-12 04:54:02","","0","1","1883112","","2013-06-07 03:42:23","2013-06-07 03:36:57",""
"16975842","How to convert an ECDSA key from hex to PEM format","<p>I have a hex string that allegedly contains an EC public key. I need to convert this hex string to PEM format (""key.pem"" in following example) in order to investigate the contents which I plan to do with ""openssl ec -in key.pem -text -noout"". Is this possible? </p>
","<p>If you're starting with a hex string, you need to hex decode it to get the DER-encoding first.</p>

<p>The hex string should start with <code>30...</code> which is indicates that it's an ASN.1 sequence.</p>

<p>This shell command will hex decode (using <code>xxd</code>), then use OpenSSL to parse the resulting DER public key:</p>

<pre><code>echo ""30...."" | xxd -r -p - | openssl ec -inform der -pubin -noout -text
</code></pre>

<p>To output a PEM, remove <code>-noout -text</code>, add <code>-pubout -out publickey.pem</code> </p>

<pre><code>echo ""30...."" | xxd -r -p - | openssl ec -inform der -pubin -pubout -out publickey.pem
</code></pre>

<p>If it's actually a private key, just omit <code>-pubin</code> and <code>-pubout</code>.</p>
","8601","<openssl><format><public-key><ecdsa>","2","2","2","2013-11-12 04:54:02","","0","1","1883112","","2013-06-07 03:42:23","2013-06-07 03:36:57",""
"28647272","OpenSSL on Mac OS X for SHA-256 signature algorithm","<p>I want to create a self-signed certificate (root ca) with OpenSSL. The signature algorithm needs to be a ECDSA signature with SHA-256 hash. 
On my Mac OS X (Yosemite), I have OpenSSL version 0.9.8zc (from Oct 15, 2014) installed. When I call <code>openssl ciphers -v</code> on the command line, it seems that my current OpenSSL version does not support SHA2 (with SHA-256 etc.). </p>

<pre><code>DHE-RSA-AES256-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(256)  Mac=SHA1
DHE-DSS-AES256-SHA      SSLv3 Kx=DH       Au=DSS  Enc=AES(256)  Mac=SHA1
AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
EDH-DSS-DES-CBC3-SHA    SSLv3 Kx=DH       Au=DSS  Enc=3DES(168) Mac=SHA1
DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1
DES-CBC3-MD5            SSLv2 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=MD5 
DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
DHE-DSS-AES128-SHA      SSLv3 Kx=DH       Au=DSS  Enc=AES(128)  Mac=SHA1
AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
DHE-RSA-SEED-SHA        SSLv3 Kx=DH       Au=RSA  Enc=SEED(128) Mac=SHA1
DHE-DSS-SEED-SHA        SSLv3 Kx=DH       Au=DSS  Enc=SEED(128) Mac=SHA1
SEED-SHA                SSLv3 Kx=RSA      Au=RSA  Enc=SEED(128) Mac=SHA1
RC2-CBC-MD5             SSLv2 Kx=RSA      Au=RSA  Enc=RC2(128)  Mac=MD5 
RC4-SHA                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=SHA1
RC4-MD5                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5 
RC4-MD5                 SSLv2 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5 
EDH-RSA-DES-CBC-SHA     SSLv3 Kx=DH       Au=RSA  Enc=DES(56)   Mac=SHA1
EDH-DSS-DES-CBC-SHA     SSLv3 Kx=DH       Au=DSS  Enc=DES(56)   Mac=SHA1
DES-CBC-SHA             SSLv3 Kx=RSA      Au=RSA  Enc=DES(56)   Mac=SHA1
DES-CBC-MD5             SSLv2 Kx=RSA      Au=RSA  Enc=DES(56)   Mac=MD5 
EXP-EDH-RSA-DES-CBC-SHA SSLv3 Kx=DH(512)  Au=RSA  Enc=DES(40)   Mac=SHA1 export
EXP-EDH-DSS-DES-CBC-SHA SSLv3 Kx=DH(512)  Au=DSS  Enc=DES(40)   Mac=SHA1 export
EXP-DES-CBC-SHA         SSLv3 Kx=RSA(512) Au=RSA  Enc=DES(40)   Mac=SHA1 export
EXP-RC2-CBC-MD5         SSLv3 Kx=RSA(512) Au=RSA  Enc=RC2(40)   Mac=MD5  export
EXP-RC2-CBC-MD5         SSLv2 Kx=RSA(512) Au=RSA  Enc=RC2(40)   Mac=MD5  export
EXP-RC4-MD5             SSLv3 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export
EXP-RC4-MD5             SSLv2 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export
</code></pre>

<p>The latest version of OpenSSL seems to be 1.0.2, but the source available at <a href=""https://www.openssl.org/source/"" rel=""nofollow"">https://www.openssl.org/source/</a> does not seem to be compilable for OS X, since the file ""Install.MacOS"" says right at the beginning:</p>

<p>""Thanks to Roy Wood  initial support for Mac OS (pre
X) is now provided.""</p>

<p>My try to install it nevertheless resulted in some errors on the command line.</p>

<p>Can anyone tell me if it is somehow possible to use the SHA-256 signature algorithm with an OpenSSL installation on Yosemite? It seems odd to me if this would not be possible, but I am no expert in this field.
Hoping for a good hint!</p>
","<p>Finally found out how to do it:</p>

<ol>
<li>Install homebrew (see <a href=""http://brew.sh/index.html"" rel=""nofollow noreferrer"">http://brew.sh/index.html</a>) with command
<code>ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""</code></li>
<li>Install newest openssl version with command <code>brew install openssl</code></li>
<li>Run <code>brew link --force openssl</code> in terminal, open a new one and run <code>which openssl</code> in it -> will show you <code>/usr/local/bin/openssl</code> </li>
<li>Tada! Now if you run <code>openssl version</code> it will show <code>OpenSSL 1.0.2 22 Jan 2015</code> (if you didn't run <code>brew link --force openssl</code> before it would have shown <code>OpenSSL 0.9.8zc 15 Oct 2014</code>)</li>
</ol>

<p>:)
(Found hints on <a href=""https://stackoverflow.com/questions/15185661/openssl-version-macosx-homebrew"">Update OpenSSL on OS X with Homebrew</a>, didn't know about homebrew before or that I needed it to get the up-to-date openssl running.</p>
","7579","<macos><openssl><sha256><ecdsa>","2","5","3","2017-12-07 17:09:30","","2","","","","","2015-02-21 15:07:11",""
"28647272","OpenSSL on Mac OS X for SHA-256 signature algorithm","<p>I want to create a self-signed certificate (root ca) with OpenSSL. The signature algorithm needs to be a ECDSA signature with SHA-256 hash. 
On my Mac OS X (Yosemite), I have OpenSSL version 0.9.8zc (from Oct 15, 2014) installed. When I call <code>openssl ciphers -v</code> on the command line, it seems that my current OpenSSL version does not support SHA2 (with SHA-256 etc.). </p>

<pre><code>DHE-RSA-AES256-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(256)  Mac=SHA1
DHE-DSS-AES256-SHA      SSLv3 Kx=DH       Au=DSS  Enc=AES(256)  Mac=SHA1
AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
EDH-DSS-DES-CBC3-SHA    SSLv3 Kx=DH       Au=DSS  Enc=3DES(168) Mac=SHA1
DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1
DES-CBC3-MD5            SSLv2 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=MD5 
DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
DHE-DSS-AES128-SHA      SSLv3 Kx=DH       Au=DSS  Enc=AES(128)  Mac=SHA1
AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
DHE-RSA-SEED-SHA        SSLv3 Kx=DH       Au=RSA  Enc=SEED(128) Mac=SHA1
DHE-DSS-SEED-SHA        SSLv3 Kx=DH       Au=DSS  Enc=SEED(128) Mac=SHA1
SEED-SHA                SSLv3 Kx=RSA      Au=RSA  Enc=SEED(128) Mac=SHA1
RC2-CBC-MD5             SSLv2 Kx=RSA      Au=RSA  Enc=RC2(128)  Mac=MD5 
RC4-SHA                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=SHA1
RC4-MD5                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5 
RC4-MD5                 SSLv2 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5 
EDH-RSA-DES-CBC-SHA     SSLv3 Kx=DH       Au=RSA  Enc=DES(56)   Mac=SHA1
EDH-DSS-DES-CBC-SHA     SSLv3 Kx=DH       Au=DSS  Enc=DES(56)   Mac=SHA1
DES-CBC-SHA             SSLv3 Kx=RSA      Au=RSA  Enc=DES(56)   Mac=SHA1
DES-CBC-MD5             SSLv2 Kx=RSA      Au=RSA  Enc=DES(56)   Mac=MD5 
EXP-EDH-RSA-DES-CBC-SHA SSLv3 Kx=DH(512)  Au=RSA  Enc=DES(40)   Mac=SHA1 export
EXP-EDH-DSS-DES-CBC-SHA SSLv3 Kx=DH(512)  Au=DSS  Enc=DES(40)   Mac=SHA1 export
EXP-DES-CBC-SHA         SSLv3 Kx=RSA(512) Au=RSA  Enc=DES(40)   Mac=SHA1 export
EXP-RC2-CBC-MD5         SSLv3 Kx=RSA(512) Au=RSA  Enc=RC2(40)   Mac=MD5  export
EXP-RC2-CBC-MD5         SSLv2 Kx=RSA(512) Au=RSA  Enc=RC2(40)   Mac=MD5  export
EXP-RC4-MD5             SSLv3 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export
EXP-RC4-MD5             SSLv2 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export
</code></pre>

<p>The latest version of OpenSSL seems to be 1.0.2, but the source available at <a href=""https://www.openssl.org/source/"" rel=""nofollow"">https://www.openssl.org/source/</a> does not seem to be compilable for OS X, since the file ""Install.MacOS"" says right at the beginning:</p>

<p>""Thanks to Roy Wood  initial support for Mac OS (pre
X) is now provided.""</p>

<p>My try to install it nevertheless resulted in some errors on the command line.</p>

<p>Can anyone tell me if it is somehow possible to use the SHA-256 signature algorithm with an OpenSSL installation on Yosemite? It seems odd to me if this would not be possible, but I am no expert in this field.
Hoping for a good hint!</p>
","<blockquote>
  <p>Can anyone tell me if it is somehow possible to use the SHA-256 signature algorithm with an OpenSSL installation on Yosemite? </p>
</blockquote>

<p>Yes, but you need to install a more recent version OpenSSL. OS X's 0.9.8 lacks elliptic curve support (among other things).</p>

<hr>

<blockquote>
  <p>The latest version of OpenSSL seems to be 1.0.2, but the source available at <a href=""https://www.openssl.org/source/"" rel=""nofollow noreferrer"">https://www.openssl.org/source/</a> does not seem to be compilable for OS X, since the file ""Install.MacOS"" says right at the beginning:</p>
  
  <p>""Thanks to Roy Wood initial support for Mac OS (pre X) is now provided.""</p>
</blockquote>

<p>Ignore that because its wrong.</p>

<p>See the OpenSSL wiki on <a href=""https://wiki.openssl.org/index.php/Compilation_and_Installation"" rel=""nofollow noreferrer"">Compilation and Installation</a>. The 30 second fly-by on 64-bit OS X:</p>

<pre><code>export KERNEL_BITS=64
cd openssl
./config shared no-ssl2 no-ssl3 no-comp enable-ec_nistp_64_gcc_128 --openssldir=/usr/local
make all
sudo make install
</code></pre>

<p>Ignore the prompt about <code>make depend</code> since you don't need it.</p>

<hr>

<p>Related: if you want to build a fat OpenSSL, then see this question: <a href=""https://stackoverflow.com/q/25530429"">Build Multiarch OpenSSL on OS X</a>. The short answer is, don't try because it won't work due to OpenSSL makefiles.</p>

<p>If you want a fat library, the perform the following steps:</p>

<pre><code>export KERNL_BITS=64
./configure ...
...

mv libcrypto.a libcrypto-x86_64.a 
mv libssl.a libssl-x86_64.a

make clean &amp;&amp; make dclean
export KERNL_BITS=32
./configure ...
...

mv libcrypto.a libcrypto-i386.a 
mv libssl.a libssl-i386.a

lipo -create libcrypto-x86_64.a libcrypto-i386.a -output libcrypto.a
lipo -create libssl-x86_64.a libssl-i386.a -output libssl.a

sudo make install
</code></pre>

<p>Lather, rinse and repeat for the <code>dylibs</code> before running <code>make install</code>. Note: i386 should <em>not</em> use <code>enable-ec_nistp_64_gcc_128</code> (IIRC).</p>

<hr>

<p>When you need to use OpenSSL in your programs, you will use <code>/usr/local/ssl/include</code> as a header path, and <code>/usr/local/ssl/lib</code> as a library path.</p>

<p>As a matter of fact, I don't use library paths because OS X's linker ignores your request for static linking. I use static linking to avoid <code>LD_PRELOAD</code> and <code>DYLD_LIBRARY_PATH</code> problems and tricks (like compiling against 1.0.2 in <code>/usr/local/ssl</code>, but loading 0.9.8 at runtime in <code>/usr/lib</code>). So my compile like looks something like:</p>

<pre><code>gcc foo.c bar.c /usr/local/ssl/lib/libcrypto.a -o foobar.exe
</code></pre>

<p>An archive is a collection of object files (<code>*.o</code>), so you specify them just like any other object file.</p>
","7579","<macos><openssl><sha256><ecdsa>","2","1","3","2017-12-07 17:09:30","","2","","","","","2015-02-21 15:07:11",""
"28647272","OpenSSL on Mac OS X for SHA-256 signature algorithm","<p>I want to create a self-signed certificate (root ca) with OpenSSL. The signature algorithm needs to be a ECDSA signature with SHA-256 hash. 
On my Mac OS X (Yosemite), I have OpenSSL version 0.9.8zc (from Oct 15, 2014) installed. When I call <code>openssl ciphers -v</code> on the command line, it seems that my current OpenSSL version does not support SHA2 (with SHA-256 etc.). </p>

<pre><code>DHE-RSA-AES256-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(256)  Mac=SHA1
DHE-DSS-AES256-SHA      SSLv3 Kx=DH       Au=DSS  Enc=AES(256)  Mac=SHA1
AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
EDH-DSS-DES-CBC3-SHA    SSLv3 Kx=DH       Au=DSS  Enc=3DES(168) Mac=SHA1
DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1
DES-CBC3-MD5            SSLv2 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=MD5 
DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
DHE-DSS-AES128-SHA      SSLv3 Kx=DH       Au=DSS  Enc=AES(128)  Mac=SHA1
AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
DHE-RSA-SEED-SHA        SSLv3 Kx=DH       Au=RSA  Enc=SEED(128) Mac=SHA1
DHE-DSS-SEED-SHA        SSLv3 Kx=DH       Au=DSS  Enc=SEED(128) Mac=SHA1
SEED-SHA                SSLv3 Kx=RSA      Au=RSA  Enc=SEED(128) Mac=SHA1
RC2-CBC-MD5             SSLv2 Kx=RSA      Au=RSA  Enc=RC2(128)  Mac=MD5 
RC4-SHA                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=SHA1
RC4-MD5                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5 
RC4-MD5                 SSLv2 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5 
EDH-RSA-DES-CBC-SHA     SSLv3 Kx=DH       Au=RSA  Enc=DES(56)   Mac=SHA1
EDH-DSS-DES-CBC-SHA     SSLv3 Kx=DH       Au=DSS  Enc=DES(56)   Mac=SHA1
DES-CBC-SHA             SSLv3 Kx=RSA      Au=RSA  Enc=DES(56)   Mac=SHA1
DES-CBC-MD5             SSLv2 Kx=RSA      Au=RSA  Enc=DES(56)   Mac=MD5 
EXP-EDH-RSA-DES-CBC-SHA SSLv3 Kx=DH(512)  Au=RSA  Enc=DES(40)   Mac=SHA1 export
EXP-EDH-DSS-DES-CBC-SHA SSLv3 Kx=DH(512)  Au=DSS  Enc=DES(40)   Mac=SHA1 export
EXP-DES-CBC-SHA         SSLv3 Kx=RSA(512) Au=RSA  Enc=DES(40)   Mac=SHA1 export
EXP-RC2-CBC-MD5         SSLv3 Kx=RSA(512) Au=RSA  Enc=RC2(40)   Mac=MD5  export
EXP-RC2-CBC-MD5         SSLv2 Kx=RSA(512) Au=RSA  Enc=RC2(40)   Mac=MD5  export
EXP-RC4-MD5             SSLv3 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export
EXP-RC4-MD5             SSLv2 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export
</code></pre>

<p>The latest version of OpenSSL seems to be 1.0.2, but the source available at <a href=""https://www.openssl.org/source/"" rel=""nofollow"">https://www.openssl.org/source/</a> does not seem to be compilable for OS X, since the file ""Install.MacOS"" says right at the beginning:</p>

<p>""Thanks to Roy Wood  initial support for Mac OS (pre
X) is now provided.""</p>

<p>My try to install it nevertheless resulted in some errors on the command line.</p>

<p>Can anyone tell me if it is somehow possible to use the SHA-256 signature algorithm with an OpenSSL installation on Yosemite? It seems odd to me if this would not be possible, but I am no expert in this field.
Hoping for a good hint!</p>
","<p>On OSX El Capitan</p>

<ul>
<li>Install homebrew (see <a href=""http://brew.sh/index.html"" rel=""nofollow noreferrer"">http://brew.sh/index.html</a>)</li>
<li>Install newest openssl version with command <code>brew install openssl</code></li>
<li>Run <code>/usr/local/opt/openssl/bin/openssl sha256</code></li>
</ul>

<p>Brew now refuses to link openssh to <code>/usr/local/bin</code> even if you use the <code>--force</code> option so you have to run <code>openssh</code> from the brew install location or link to it yourself.</p>
","7579","<macos><openssl><sha256><ecdsa>","2","0","3","2017-12-07 17:09:30","","2","","","","","2015-02-21 15:07:11",""
"48101258","How to convert an ECDSA key to PEM format","<p>I have a private raw key of <strong>myetherwallet</strong> with a <strong>passphrase</strong> ""testwallet"", now I am trying to convert it to a PEM format using OpenSSL following this answer.</p>

<pre><code>echo ""a140bd507a57360e2fa503298c035854f0dcb248bedabbe7a14db3920aaacf57"" | xxd -r -p - | openssl ec -inform der -pubin -noout -passin pass:testwallet -text
</code></pre>

<p>But this error appears:</p>

<pre><code>read EC key
unable to load Key
140084694296480:error:0D06B08E:asn1 encoding routines:ASN1_D2I_READ_BIO:not enough data:a_d2i_fp.c:247:
</code></pre>

<p><strong>UPDATE:</strong>
I don't have the public key, instead I want to generate it so later I can also generate the Ethereum address corresponds..</p>
","<p>You are claiming your raw key is in OpenSSL's DER format, which it isn't. Also you are claming a private key is a public key, which it isn't, and claiming it's password-encrypted which is wrong either way: public keys are never encrypted and private keys in OpenSSL's 'traditional' aka 'legacy' algorithm-specific DER formats (for ECC, defined by <a href=""https://www.secg.org"" rel=""nofollow noreferrer"">SECG SEC1</a>) cannot be encrypted. (OTOH private keys in PKCS8 format can be password-encrypted in either DER or PEM, although PEM is more convenient. And FWIW PKCS12 format is always password-encrypted, and always DER.) </p>

<p>An ECC (ECDSA, ECDH, ECMQV, etc) key is always <strong>relative to</strong> some 'curve' (more exactly, prime-order subgroup over a curve with an identified generator aka base point). For bitcoin this is <strong>secp256k1</strong>, but your question doesn't say it's limited to bitcoin and this answer would require modification for other applications using other curves.</p>

<p><strong>If you also have the public key</strong> (as an uncompressed point), you can simply use the solution from <a href=""https://bitcoin.stackexchange.com/questions/66594/signing-transaction-with-ssl-private-key-to-pem"">https://bitcoin.stackexchange.com/questions/66594/signing-transaction-with-ssl-private-key-to-pem</a> . Concatenate the hex strings:</p>

<pre><code>  a pre_string : 30740201010420
  the privkey  : (32 bytes as 64 hexits) 
  a mid_string : a00706052b8104000aa144034200 (identifies secp256k1) 
  the pubkey   : (65 bytes as 130 hexits)
</code></pre>

<p>and then either convert the hex to binary and read as DER, or convert the hex (probably via binary) to base64 and wrap with <code>-----BEGIN/END EC PRIVATE KEY-----</code> lines to make it PEM.</p>

<p><strong>If you don't have the public key</strong>, you can modify this slightly. Concatenate the hex strings </p>

<pre><code>302e0201010420 privkey_32bytes_64hexits a00706052b8104000a 
</code></pre>

<p>and convert to binary, then read into <code>openssl ec -inform d</code> . Note OpenSSL will derive the public key from the private key given the curve, but not actually store it in the PEM output, so reading with software other than OpenSSL is not guaranteed. You might need to use <code>openssl ec -text [-noout]</code> (on either PEM or DER input as convenient) to get the public key value, then go back and create the fuller encoding that includes the public key as above.</p>

<hr>

<p><strong>ADDED:</strong> since you seem not to comprehend the words in the answer, I'll lay this out in as much detail as I can.</p>

<p>The value <code>a140bd507a57360e2fa503298c035854f0dcb248bedabbe7a14db3920aaacf57</code> is the raw private key represented in hex. A secp256k1 private value is 32 bytes in binary; when binary is represented in hex each byte takes two hex digits, so 32 bytes takes 64 hex digits. All of this value is the raw private key. There is no part consisting of 25 digits OR 25 bytes that has any useful meaning whatever. Do not take any 25-anything part of this value.</p>

<p>To construct the OpenSSL/SECG representation of a <strong>private key with no public key</strong>, put the hex string representing the private key -- all of it, without modification -- between the two other hex strings I showed as the second option:</p>

<pre><code> 302e0201010420 a140bd507a57360e2fa503298c035854f0dcb248bedabbe7a14db3920aaacf57 a00706052b8104000a 
</code></pre>

<p>Then convert this combined hex string to binary, and read the result into <code>openssl ec -inform d</code>:</p>

<pre><code>$ echo 302e0201010420 a140bd507a57360e2fa503298c035854f0dcb248bedabbe7a14db3920aaacf57 a00706052b8104000a | xxd -r -p &gt;48101258.1
$ openssl ec -inform d &lt;48101258.1
read EC key
writing EC key
-----BEGIN EC PRIVATE KEY-----
MC4CAQEEIKFAvVB6VzYOL6UDKYwDWFTw3LJIvtq756FNs5IKqs9XoAcGBSuBBAAK
-----END EC PRIVATE KEY-----
</code></pre>

<p>The result is PEM format -- but PEM format not including the public key, which you indicate you want. To see the fields including the derived public key, add <code>-text</code>; to see only the fields and not the PEM output, add <code>-noout</code>:</p>

<pre><code>$ openssl ec -inform d &lt;48101258.1 -text -noout
read EC key
Private-Key: (256 bit)
priv:
    a1:40:bd:50:7a:57:36:0e:2f:a5:03:29:8c:03:58:
    54:f0:dc:b2:48:be:da:bb:e7:a1:4d:b3:92:0a:aa:
    cf:57
pub:
    04:20:ea:6d:8c:e7:bc:bb:48:33:69:b2:91:1c:75:
    e5:60:2a:34:28:be:44:96:e9:7f:14:ad:52:fd:4a:
    6a:a0:e3:60:83:9c:6e:db:32:2a:22:55:7c:70:1e:
    d0:fa:1e:06:cf:57:4f:be:17:bd:6a:85:51:69:c5:
    65:96:72:cf:a9
ASN1 OID: secp256k1
</code></pre>

<p>Now if you want a PEM-format key <strong>including the public key</strong>, take <em>both</em> the hex strings for the private key (all 64 digits) AND the newly-shown hex value for the public key, and plug them in to my <em>first</em> option. Also note an ECC public key is a curve point which can be in two forms, compressed or uncompressed; the form generated here is uncompressed. If you need compressed, I'll add that later. A secp256k1 point in uncompressed form is 65 bytes, represented in hex as 130 hex digits. (Which <code>openssl ec</code> formats as 4 lines each of 15 bytes with 5 bytes left over.)</p>

<pre><code>$ echo 30740201010420 a140bd507a57360e2fa503298c035854f0dcb248bedabbe7a14db3920aaacf57 a00706052b8104000aa144034200 \
&gt; 04:20:ea:6d:8c:e7:bc:bb:48:33:69:b2:91:1c:75: e5:60:2a:34:28:be:44:96:e9:7f:14:ad:52:fd:4a: \
&gt; 6a:a0:e3:60:83:9c:6e:db:32:2a:22:55:7c:70:1e: d0:fa:1e:06:cf:57:4f:be:17:bd:6a:85:51:69:c5: \
&gt; 65:96:72:cf:a9 | xxd -r -p &gt;48101258.2
$ # note xxd -r -p ignores the colons; other hex programs may need them removed instead
$ openssl ec -inform d &lt;48101258.2
read EC key
writing EC key
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIKFAvVB6VzYOL6UDKYwDWFTw3LJIvtq756FNs5IKqs9XoAcGBSuBBAAK
oUQDQgAEIOptjOe8u0gzabKRHHXlYCo0KL5Elul/FK1S/UpqoONgg5xu2zIqIlV8
cB7Q+h4Gz1dPvhe9aoVRacVllnLPqQ==
-----END EC PRIVATE KEY-----
</code></pre>

<hr>

<p>ADDED 2019-02 for DavidS: as correctly shown in <a href=""https://stackoverflow.com/a/49213805"">k06a's answer</a></p>

<ul>
<li><p>the first part of my midstring (or the entire suffix for my private-only option) <code>a00706052b8104000a</code> is a context-tag and length <code>a007</code> for an OID tag and length <code>0605</code> containing <code>2b8104000a</code> which is <a href=""http://www.oid-info.com/get/1.3.132.0.10"" rel=""nofollow noreferrer"">1.3.132.0.10 which is secp256k1</a> and </p></li>
<li><p>the remainder of my midstring <code>a144034200</code> is a context tag and length containing the tag length and unused-bits header for a BITSTRING which is the raw publickey as an uncompressed point.</p></li>
</ul>

<p>To do <strong>secp256r1</strong> aka P-256 or prime256v1 instead, you need to change the AlgId.OID to <a href=""http://www.oid-info.com/get/1.2.840.10045.3.1.7"" rel=""nofollow noreferrer"">1.2.840.10045.3.1.7</a> which is encoded as <code>a00a 0608 2a8648ce3d030107</code>. The privatekey and publickey values for p256r1 are the same sizes as for p256k1, but the AlgId is longer, so you also need to change the length of the outer SEQUENCE giving</p>

<pre><code>30770201010420 privatekey32bytes # note 77 
a00a06082a8648ce3d030107 a144034200 publicpoint65bytes 
</code></pre>
","7337","<openssl><ecdsa>","7","12","2","2019-08-29 13:02:33","48102827","0","0","3261332","","2018-01-04 22:02:30","2018-01-04 18:17:01",""
"48101258","How to convert an ECDSA key to PEM format","<p>I have a private raw key of <strong>myetherwallet</strong> with a <strong>passphrase</strong> ""testwallet"", now I am trying to convert it to a PEM format using OpenSSL following this answer.</p>

<pre><code>echo ""a140bd507a57360e2fa503298c035854f0dcb248bedabbe7a14db3920aaacf57"" | xxd -r -p - | openssl ec -inform der -pubin -noout -passin pass:testwallet -text
</code></pre>

<p>But this error appears:</p>

<pre><code>read EC key
unable to load Key
140084694296480:error:0D06B08E:asn1 encoding routines:ASN1_D2I_READ_BIO:not enough data:a_d2i_fp.c:247:
</code></pre>

<p><strong>UPDATE:</strong>
I don't have the public key, instead I want to generate it so later I can also generate the Ethereum address corresponds..</p>
","<p><a href=""https://www.ietf.org/rfc/rfc5915.txt"" rel=""nofollow noreferrer"">Elliptic Curve Private Key Format</a>:</p>

<pre><code>ECPrivateKey ::= SEQUENCE {
 version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
 privateKey     OCTET STRING,
 parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
 publicKey  [1] BIT STRING OPTIONAL
}
</code></pre>

<p>So <code>publicKey</code> is <code>OPTIONAL</code> and theoretically can be missed.</p>

<p>Here is example of my DER secp256k1 private key:</p>

<pre><code>30740201 01042092 E768CB72 0DC16924 27D156DB 39630748 0D1507B9 A4958450
2574B9A0 922F4BA0 0706052B 8104000A A1440342 00041954 9737B704 D1789A57
82E3430E 8259F904 71326081 054854D2 A5D096F9 686D05B0 30D98BA3 C60C056E
204CEF61 C0AC5B53 A9A6B9A0 5AFF9DA2 6CA4B65B 2E84
</code></pre>

<p>Trying to decompose:</p>

<pre><code>$ openssl asn1parse -inform DER -in &lt;(echo ""30740201 01042092 E768CB72 0DC16924 27D156DB 39630748 0D1507B9 A4958450 2574B9A0 922F4BA0 0706052B 8104000A A1440342 00041954 9737B704 D1789A57 82E3430E 8259F904 71326081 054854D2 A5D096F9 686D05B0 30D98BA3 C60C056E 204CEF61 C0AC5B53 A9A6B9A0 5AFF9DA2 6CA4B65B 2E84"" | xxd -r -p)
</code></pre>

<p>ASN.1 parsing result:</p>

<pre><code> 0:d=0  hl=2 l= 116 cons: SEQUENCE          
 2:d=1  hl=2 l=   1 prim: INTEGER           :01
 5:d=1  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:92E768CB720DC1692427D156DB396307480D1507B9A49584502574B9A0922F4B
39:d=1  hl=2 l=   7 cons: cont [ 0 ]        
41:d=2  hl=2 l=   5 prim: OBJECT            :secp256k1
48:d=1  hl=2 l=  68 cons: cont [ 1 ]        
50:d=2  hl=2 l=  66 prim: BIT STRING  
</code></pre>

<p>Detailed (see <a href=""https://bitcoin.stackexchange.com/a/66622/22979"">https://bitcoin.stackexchange.com/a/66622/22979</a>):</p>

<pre><code>30 - ASN.1
74 - Length of all following bytes (116 bytes)

  02 - Type (integer)
  01 - Length of integer (1 byte)
  01 - Value of integer (1)

  04 - Type (octet string)
  20 - Length of string (32 bytes)
  92E768CB720DC1692427D156DB396307480D1507B9A49584502574B9A0922F4B - Private Key

  A0 - Tag 0
  07 - Length of tag (7 bytes)
  06 - Type (Object ID)
  05 - Length of the Object ID (5 bytes)
  2b 81 04 00 0a - The object ID of the curve secp256k1

  A1 - Tag 1
  44 - Length of tag (68 bytes)
  03 - Type  Bit string
  42 - Length of the bit string (66 bytes)
  00 - ???
  04 - Uncompressed Public Key
  19549737B704D1789A5782E3430E8259F90471326081054854D2A5D096F9686D - Public Key X coord
  05B030D98BA3C60C056E204CEF61C0AC5B53A9A6B9A05AFF9DA26CA4B65B2E84 - Public Key Y coord
</code></pre>

<p>I removed Public Key object and fixed ASN.1 length from 116 bytes (0x74) to 46 bytes (0x2e):</p>

<pre><code>$ openssl asn1parse -inform DER -in &lt;(echo ""302E020101042092E768CB720DC1692427D156DB396307480D1507B9A49584502574B9A0922F4BA00706052B8104000A"" | xxd -r -p)
</code></pre>

<p>Got result:</p>

<pre><code> 0:d=0  hl=2 l=  46 cons: SEQUENCE          
 2:d=1  hl=2 l=   1 prim: INTEGER           :01
 5:d=1  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:92E768CB720DC1692427D156DB396307480D1507B9A49584502574B9A0922F4B
39:d=1  hl=2 l=   7 cons: cont [ 0 ]        
41:d=2  hl=2 l=   5 prim: OBJECT            :secp256k1
</code></pre>

<p>Trying to get Public Key:</p>

<pre><code>$ openssl ec -inform DER -in &lt;(echo ""302E020101042092E768CB720DC1692427D156DB396307480D1507B9A49584502574B9A0922F4BA00706052B8104000A"" | xxd -r -p)
</code></pre>

<p>Result:</p>

<pre><code>read EC key
writing EC key
-----BEGIN EC PRIVATE KEY-----
MC4CAQEEIJLnaMtyDcFpJCfRVts5YwdIDRUHuaSVhFAldLmgki9LoAcGBSuBBAAK
-----END EC PRIVATE KEY-----
</code></pre>

<p>One more try:</p>

<pre><code>$ openssl ec -inform DER -text -in &lt;(echo ""302E020101042092E768CB720DC1692427D156DB396307480D1507B9A49584502574B9A0922F4BA00706052B8104000A"" | xxd -r -p)
</code></pre>

<p>Result:</p>

<pre><code>read EC key
Segmentation fault: 11
</code></pre>

<p>I used OSX system <code>openssl</code>  looks like it is <code>LibreSSL 2.2.7</code>.</p>

<p><strong>Added:</strong> Reported a bug to LibreSSL: <a href=""https://github.com/libressl-portable/portable/issues/395"" rel=""nofollow noreferrer"">https://github.com/libressl-portable/portable/issues/395</a></p>

<p>Then I installed latest openssl: <code>brew install openssl</code></p>

<pre><code>/usr/local/Cellar/openssl/1.0.2n/bin/openssl ec -inform DER -text -noout -in &lt;(echo ""302E020101042092E768CB720DC1692427D156DB396307480D1507B9A49584502574B9A0922F4BA00706052B8104000A"" | xxd -r -p)
</code></pre>

<p>And got:</p>

<pre><code>read EC key
Private-Key: (256 bit)
priv:
    00:92:e7:68:cb:72:0d:c1:69:24:27:d1:56:db:39:
    63:07:48:0d:15:07:b9:a4:95:84:50:25:74:b9:a0:
    92:2f:4b
pub: 
    04:19:54:97:37:b7:04:d1:78:9a:57:82:e3:43:0e:
    82:59:f9:04:71:32:60:81:05:48:54:d2:a5:d0:96:
    f9:68:6d:05:b0:30:d9:8b:a3:c6:0c:05:6e:20:4c:
    ef:61:c0:ac:5b:53:a9:a6:b9:a0:5a:ff:9d:a2:6c:
    a4:b6:5b:2e:84
ASN1 OID: secp256k1
</code></pre>

<p>Final solution:</p>

<pre><code>$ /usr/local/Cellar/openssl/1.0.2n/bin/openssl ec -inform DER -text -noout -in &lt;(cat &lt;(echo -n ""302e0201010420"") &lt;(echo -n ""***"") &lt;(echo -n ""a00706052b8104000a"") | xxd -r -p) 2&gt;/dev/null | tail -6 | head -5 | sed 's/[ :]//g' | tr -d '\n' &amp;&amp; echo
</code></pre>

<p>Replace <code>***</code> with a hexademical private key.</p>
","7337","<openssl><ecdsa>","7","2","2","2019-08-29 13:02:33","48102827","0","0","3261332","","2018-01-04 22:02:30","2018-01-04 18:17:01",""
"15269379","C implementation of ECDSA signature and verification with openssl","<p>I am trying to create C program were I can choose from a menu which options I want from Signing a message and Verify a message. I have the code that signs the message and verifies at the same time. What I would like was to be able to parse a message and sign it and this to output the certificate for example. Next when I choose verify I would insert the same message and the certificate, so I could actually verify or not the message.</p>

<p>I am using the code from: 
<a href=""https://stackoverflow.com/questions/2228860/signing-a-message-using-ecdsa-in-openssl/6006898#6006898"">Signing a message using ECDSA in OpenSSL</a></p>

<p>PS: Basically I don't know how to actually print the signature, private and public keys.</p>

<p>Thank you so much.</p>
","<p>I think I found out the way to print the r and s values. The key pair from the signature (r,s)</p>

<p>After we have the signature it self:</p>

<pre><code>ECDSA_SIG *signature = ECDSA_do_sign(hash, strlen(hash), eckey);
</code></pre>

<p>We can print the r and s values this way:</p>

<pre><code>printf(""(sig-&gt;r, sig-&gt;s): (%s,%s)\n"", BN_bn2hex(signature-&gt;r), BN_bn2hex(signature-&gt;s));
</code></pre>

<p>Thanks
Best Regards</p>
","5743","<c><openssl><signature><verification><ecdsa>","0","2","2","2013-03-10 10:00:12","15320998","0","2","-1","","2017-05-23 12:28:22","2013-03-07 10:59:27",""
"15269379","C implementation of ECDSA signature and verification with openssl","<p>I am trying to create C program were I can choose from a menu which options I want from Signing a message and Verify a message. I have the code that signs the message and verifies at the same time. What I would like was to be able to parse a message and sign it and this to output the certificate for example. Next when I choose verify I would insert the same message and the certificate, so I could actually verify or not the message.</p>

<p>I am using the code from: 
<a href=""https://stackoverflow.com/questions/2228860/signing-a-message-using-ecdsa-in-openssl/6006898#6006898"">Signing a message using ECDSA in OpenSSL</a></p>

<p>PS: Basically I don't know how to actually print the signature, private and public keys.</p>

<p>Thank you so much.</p>
","<p>Use those functions:</p>

<pre><code>int i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);

ECDSA_SIG* d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, long len);
</code></pre>

<p>As per OpenSSL docs:</p>

<p>"" i2d_ECDSA_SIG() creates the DER encoding of the ECDSA signature sig and writes the encoded signature to *pp (note: if pp is NULL i2d_ECDSA_SIG returns the expected length in bytes of the DER encoded signature). i2d_ECDSA_SIG returns the length of the DER encoded signature (or 0 on error).</p>

<p>d2i_ECDSA_SIG() decodes a DER encoded ECDSA signature and returns the decoded signature in a newly allocated ECDSA_SIG structure. *sig points to the buffer containing the DER encoded signature of size len. ""</p>

<p>If you want to printout the signature on the screen than you will have to Base64 it :)</p>
","5743","<c><openssl><signature><verification><ecdsa>","0","1","2","2013-03-10 10:00:12","15320998","0","2","-1","","2017-05-23 12:28:22","2013-03-07 10:59:27",""
"21322182","How to store ECDSA private key in Go","<p>I am using the <code>ecdsa.GenerateKey</code> method to generate a private/public key pair in Go. I would like to store the private key in a file on the users computer, and load it whenever the program starts. There is a method <code>elliptic.Marshal</code> that marshals the public key, but nothing for the private key. Should I simply roll my own, or is there a recommended way to store the private key?</p>
","<p>I believe the standard format for those keys is to use the X.509 ASN.1 DER representation. See <a href=""http://golang.org/pkg/crypto/x509/#MarshalECPrivateKey"" rel=""noreferrer"">http://golang.org/pkg/crypto/x509/#MarshalECPrivateKey</a> and <a href=""http://golang.org/pkg/crypto/x509/#ParseECPrivateKey"" rel=""noreferrer"">http://golang.org/pkg/crypto/x509/#ParseECPrivateKey</a>.</p>
","5726","<go><ecdsa>","16","6","3","2018-12-04 22:36:10","41315404","1","5","","","","2014-01-24 00:28:51",""
"21322182","How to store ECDSA private key in Go","<p>I am using the <code>ecdsa.GenerateKey</code> method to generate a private/public key pair in Go. I would like to store the private key in a file on the users computer, and load it whenever the program starts. There is a method <code>elliptic.Marshal</code> that marshals the public key, but nothing for the private key. Should I simply roll my own, or is there a recommended way to store the private key?</p>
","<p>Here is a code sample that demonstrates encoding and decoding of keys in Go. It helps to know that you need to connect couple of steps. Crypto algorithm is the fist step, in this case ECDSA key. Then you need standard encoding, x509 is most commontly used standard. Finally you need a file format, PEM is again commonly used one. This is currently most commonly used combination, but feel free to substitute any other algoriths or encoding.</p>

<pre><code>func encode(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey) (string, string) {
    x509Encoded, _ := x509.MarshalECPrivateKey(privateKey)
    pemEncoded := pem.EncodeToMemory(&amp;pem.Block{Type: ""PRIVATE KEY"", Bytes: x509Encoded})

    x509EncodedPub, _ := x509.MarshalPKIXPublicKey(publicKey)
    pemEncodedPub := pem.EncodeToMemory(&amp;pem.Block{Type: ""PUBLIC KEY"", Bytes: x509EncodedPub})

    return string(pemEncoded), string(pemEncodedPub)
}

func decode(pemEncoded string, pemEncodedPub string) (*ecdsa.PrivateKey, *ecdsa.PublicKey) {
    block, _ := pem.Decode([]byte(pemEncoded))
    x509Encoded := block.Bytes
    privateKey, _ := x509.ParseECPrivateKey(x509Encoded)

    blockPub, _ := pem.Decode([]byte(pemEncodedPub))
    x509EncodedPub := blockPub.Bytes
    genericPublicKey, _ := x509.ParsePKIXPublicKey(x509EncodedPub)
    publicKey := genericPublicKey.(*ecdsa.PublicKey)

    return privateKey, publicKey
}

func test() {
    privateKey, _ := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)
    publicKey := &amp;privateKey.PublicKey

    encPriv, encPub := encode(privateKey, publicKey)

    fmt.Println(encPriv)
    fmt.Println(encPub)

    priv2, pub2 := decode(encPriv, encPub)

    if !reflect.DeepEqual(privateKey, priv2) {
        fmt.Println(""Private keys do not match."")
    }
    if !reflect.DeepEqual(publicKey, pub2) {
        fmt.Println(""Public keys do not match."")
    }
}
</code></pre>
","5726","<go><ecdsa>","16","19","3","2018-12-04 22:36:10","41315404","1","5","","","","2014-01-24 00:28:51",""
"21322182","How to store ECDSA private key in Go","<p>I am using the <code>ecdsa.GenerateKey</code> method to generate a private/public key pair in Go. I would like to store the private key in a file on the users computer, and load it whenever the program starts. There is a method <code>elliptic.Marshal</code> that marshals the public key, but nothing for the private key. Should I simply roll my own, or is there a recommended way to store the private key?</p>
","<p>I adapted a really quick and dirty way to do it, as suggested by one of the geth team in late '15 in my library <a href=""https://github.com/DaveAppleton/ether_go"" rel=""nofollow noreferrer"">https://github.com/DaveAppleton/ether_go</a></p>

<p>it is a far simpler solution (but puts keys in plain sight)</p>
","5726","<go><ecdsa>","16","0","3","2018-12-04 22:36:10","41315404","1","5","","","","2014-01-24 00:28:51",""
"29778852","How to create ECDSA keypair (256bit) for bitcoin curve (secp256k1) using spongy castle?","<p>Currently, I am creating keyPair using this method</p>

<pre><code>private  KeyPair getKeyPair() throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""ECDsA"", ""SC"");
    ECGenParameterSpec ecSpec = new ECGenParameterSpec(""secp256k1"");
    keyGen.initialize(ecSpec, new SecureRandom());
    return keyGen.generateKeyPair();
}
</code></pre>

<p><code>KeyPairGenerator</code> has another method, in which I can specify keySize but I am not sure how I will pass the keySpecs?</p>

<pre><code> public void initialize(int keysize, SecureRandom random)
</code></pre>
","<p>The <a href=""https://docs.oracle.com/javase/7/docs/api/java/security/KeyPairGenerator.html"" rel=""nofollow"">documentation for KeyPairGenerator</a> says that the <code>initialize(int, SecureRandom)</code> does this:</p>

<blockquote>
  <p>Initializes the key pair generator for a certain keysize with the given source of randomness (and a default parameter set).</p>
</blockquote>

<p>KeyPairGenerator is an abstract class, and I assume that this ""default parameter set"" is determined by a specific subclass you are using.  You might try to figure out what class your KeyPairGenerator object really is, and then consult the documentation of that class to learn where you can set its default parameters.</p>
","5515","<java><android><encryption><bouncycastle><ecdsa>","7","0","2","2019-04-21 12:16:15","29790666","2","","546896","","2019-04-21 12:16:15","2015-04-21 17:09:39",""
"29778852","How to create ECDSA keypair (256bit) for bitcoin curve (secp256k1) using spongy castle?","<p>Currently, I am creating keyPair using this method</p>

<pre><code>private  KeyPair getKeyPair() throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""ECDsA"", ""SC"");
    ECGenParameterSpec ecSpec = new ECGenParameterSpec(""secp256k1"");
    keyGen.initialize(ecSpec, new SecureRandom());
    return keyGen.generateKeyPair();
}
</code></pre>

<p><code>KeyPairGenerator</code> has another method, in which I can specify keySize but I am not sure how I will pass the keySpecs?</p>

<pre><code> public void initialize(int keysize, SecureRandom random)
</code></pre>
","<p>Your code is already sufficient, and specifying ""secp256k1"" already sets the correct size. The <code>initialize(int, SecureRandom)</code> method is an <em>alternative</em> to <code>initialize(AlgorithmParameterSpec, SecureRandom)</code>; you call one or the other, not both. If you call the one specifying the keysize (say, 256), the BC provider will try to choose a default curve of the right size (for 256, it will be ""prime256v1"" a.k.a. ""P-256"" or ""secp256r1"").</p>
","5515","<java><android><encryption><bouncycastle><ecdsa>","7","5","2","2019-04-21 12:16:15","29790666","2","","546896","","2019-04-21 12:16:15","2015-04-21 17:09:39",""
"30175149","Error when verifying ECDSA signature in Java with BouncyCastle","<p>I have tested a solution to verify an ECDSA signature (<a href=""https://stackoverflow.com/questions/26159149/how-can-i-get-a-publickey-object-from-ec-public-key-bytes/26159150#26159150"">How can I get a PublicKey object from EC public key bytes?</a>) that works perfect with the given data.</p>

<p>This is the data:</p>

<pre><code>byte[] pubKey = DatatypeConverter.parseHexBinary(""049a55ad1e210cd113457ccd3465b930c9e7ade5e760ef64b63142dad43a308ed08e2d85632e8ff0322d3c7fda14409eafdc4c5b8ee0882fe885c92e3789c36a7a"");
byte[] message = DatatypeConverter.parseHexBinary(""54686973206973206a75737420736f6d6520706f696e746c6573732064756d6d7920737472696e672e205468616e6b7320616e7977617920666f722074616b696e67207468652074696d6520746f206465636f6465206974203b2d29"");
byte[] signature = DatatypeConverter.parseHexBinary(""304402205fef461a4714a18a5ca6dce6d5ab8604f09f3899313a28ab430eb9860f8be9d602203c8d36446be85383af3f2e8630f40c4172543322b5e8973e03fff2309755e654"");
</code></pre>

<p>And this is the code (which prints <em>true</em>):</p>

<pre><code>private static boolean isValidSignature(byte[] pubKey, byte[] message,byte[] signature) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, InvalidKeySpecException {
    Signature ecdsaVerify = Signature.getInstance(""SHA256withECDSA"", new BouncyCastleProvider());
    ecdsaVerify.initVerify(getPublicKeyFromBytes(pubKey));
    ecdsaVerify.update(message);
    return ecdsaVerify.verify(signature);
}

private static PublicKey getPublicKeyFromBytes(byte[] pubKey) throws NoSuchAlgorithmException, InvalidKeySpecException {
    ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
    KeyFactory kf = KeyFactory.getInstance(""ECDSA"", new BouncyCastleProvider());
    ECNamedCurveSpec params = new ECNamedCurveSpec(""prime256v1"", spec.getCurve(), spec.getG(), spec.getN());
    ECPoint point =  ECPointUtil.decodePoint(params.getCurve(), pubKey);
    ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(point, params);
    ECPublicKey pk = (ECPublicKey) kf.generatePublic(pubKeySpec);
    return pk;
}

public static void main (String[] args) {
    System.out.println(isValidSignature(pubKey, message, signature));
}
</code></pre>

<p><strong>My problem comes when I change the signature and data to an example input from an already implemented system:</strong></p>

<pre><code>final static byte[] pubKey = DatatypeConverter.parseHexBinary(""0447303876C6FED5550DF3EE1136989FCD87293D54A5D8E2F2F6D7FBE9A81089B889A5917443AF33E696178CEF4C9D6A4288B2745B29AF6C8BCAD1348F78EB9F9B"");
final static byte[] message = DatatypeConverter.parseHexBinary(""02158001f53611a06e2d1a270000013ed9305dc2780524015110500000002d0100140092569202017aa00c5dd30000000000000000000000000000000007d1000001020001b20788b80059f48d95cdefc8c6000200200030d41e0000012016840310a50733a9870fffd0430100"");
final static byte[] signature = DatatypeConverter.parseHexBinary(""531F8918FF250132959B01F7F56FDFD9E6CA3EC2144E12A6DA37C281489A3D96"");
</code></pre>

<p>New data outputs this error:</p>

<pre><code>java.security.SignatureException: error decoding signature bytes.
    at org.bouncycastle.jcajce.provider.asymmetric.util.DSABase.engineVerify(Unknown Source)
    at java.security.Signature$Delegate.engineVerify(Signature.java:1178)
    at java.security.Signature.verify(Signature.java:612)
    at its.sec.exec.TestProgram.isValidSignature(TestProgram.java:168)
    at its.sec.exec.TestProgram.execution(TestProgram.java:101)
    at its.sec.exec.TestProgram.main(TestProgram.java:55)
</code></pre>

<p>I assume the problem is about the signature that comes with the <em>secured message</em> because:</p>

<ul>
<li>The key pair is the same length and format that the example. And are correct since it comes from the certificate that signs the message.</li>
<li>The message itself (payload) shouldn't affect the security process.</li>
</ul>

<p>Last thing worth mention is that my documentation says that the signature must be preceded by a field called ""R"" which <em>""contains the x coordinate of the elliptic curve point resulting from multiplying the generator element by the ephemeral private key""</em> and its length must be the same as the signature (32 byte).</p>

<p>Can someone point me out what I'm missing here?</p>

<p><strong>EDIT: Solution</strong></p>

<p>As Peter Dettman pointed in his answer, the <code>signature</code> was not correctly formatted (also content was incorrect too) in order to be computed by the <code>verify()</code> method. <a href=""https://crypto.stackexchange.com/questions/1795/how-can-i-convert-a-der-ecdsa-signature-to-asn-1"">Here</a> is a good explanation that mainly says that:</p>

<blockquote>
  <p>When encoded in DER, this (signature) becomes the following sequence of bytes:</p>
  
  <p><code>0x30 b1 0x02 b2 (vr) 0x02 b3 (vs)</code></p>
  
  <p>where:</p>
  
  <ul>
  <li>b1 is a single byte value, equal to the length, in bytes, of the remaining list of bytes (from the first 0x02 to the end of the encoding);</li>
  <li>b2 is a single byte value, equal to the length, in bytes, of (vr);</li>
  <li>b3 is a single byte value, equal to the length, in bytes, of (vs);</li>
  <li>(vr) is the signed big-endian encoding of the value ""r"", of minimal length;</li>
  <li>(vs) is the signed big-endian encoding of the value ""s"", of minimal length.</li>
  </ul>
</blockquote>

<p>Applying that change, <code>signature</code> grows to 70 bytes and the execution outputs no error.</p>
","<p>The expected ECDSA signature format that the BC (and other provider) implementations work with is a DER-encoded ASN.1 sequence containing two integer values <code>r</code> and <code>s</code>. This signature format has been specified in ANSI X9.62. This is the format in the first set of data you give (note that <code>signature</code> is a total of 70 bytes).</p>

<p>In the second set of data, <code>signature</code> is only 32 bytes, and is not an ASN.1 sequence at all. I would guess that this value is only the <code>s</code> value, and it is missing the <code>r</code> value and the ASN.1 INTEGER encoding for them both, instead encoding the values as a unsigned big integer value with the same size as the key.</p>
","5362","<java><bouncycastle><signature><ecdsa>","9","8","2","2018-12-16 10:38:40","30256618","2","3","-1","","2017-05-23 12:02:46","2015-05-11 18:37:03",""
"30175149","Error when verifying ECDSA signature in Java with BouncyCastle","<p>I have tested a solution to verify an ECDSA signature (<a href=""https://stackoverflow.com/questions/26159149/how-can-i-get-a-publickey-object-from-ec-public-key-bytes/26159150#26159150"">How can I get a PublicKey object from EC public key bytes?</a>) that works perfect with the given data.</p>

<p>This is the data:</p>

<pre><code>byte[] pubKey = DatatypeConverter.parseHexBinary(""049a55ad1e210cd113457ccd3465b930c9e7ade5e760ef64b63142dad43a308ed08e2d85632e8ff0322d3c7fda14409eafdc4c5b8ee0882fe885c92e3789c36a7a"");
byte[] message = DatatypeConverter.parseHexBinary(""54686973206973206a75737420736f6d6520706f696e746c6573732064756d6d7920737472696e672e205468616e6b7320616e7977617920666f722074616b696e67207468652074696d6520746f206465636f6465206974203b2d29"");
byte[] signature = DatatypeConverter.parseHexBinary(""304402205fef461a4714a18a5ca6dce6d5ab8604f09f3899313a28ab430eb9860f8be9d602203c8d36446be85383af3f2e8630f40c4172543322b5e8973e03fff2309755e654"");
</code></pre>

<p>And this is the code (which prints <em>true</em>):</p>

<pre><code>private static boolean isValidSignature(byte[] pubKey, byte[] message,byte[] signature) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, InvalidKeySpecException {
    Signature ecdsaVerify = Signature.getInstance(""SHA256withECDSA"", new BouncyCastleProvider());
    ecdsaVerify.initVerify(getPublicKeyFromBytes(pubKey));
    ecdsaVerify.update(message);
    return ecdsaVerify.verify(signature);
}

private static PublicKey getPublicKeyFromBytes(byte[] pubKey) throws NoSuchAlgorithmException, InvalidKeySpecException {
    ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
    KeyFactory kf = KeyFactory.getInstance(""ECDSA"", new BouncyCastleProvider());
    ECNamedCurveSpec params = new ECNamedCurveSpec(""prime256v1"", spec.getCurve(), spec.getG(), spec.getN());
    ECPoint point =  ECPointUtil.decodePoint(params.getCurve(), pubKey);
    ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(point, params);
    ECPublicKey pk = (ECPublicKey) kf.generatePublic(pubKeySpec);
    return pk;
}

public static void main (String[] args) {
    System.out.println(isValidSignature(pubKey, message, signature));
}
</code></pre>

<p><strong>My problem comes when I change the signature and data to an example input from an already implemented system:</strong></p>

<pre><code>final static byte[] pubKey = DatatypeConverter.parseHexBinary(""0447303876C6FED5550DF3EE1136989FCD87293D54A5D8E2F2F6D7FBE9A81089B889A5917443AF33E696178CEF4C9D6A4288B2745B29AF6C8BCAD1348F78EB9F9B"");
final static byte[] message = DatatypeConverter.parseHexBinary(""02158001f53611a06e2d1a270000013ed9305dc2780524015110500000002d0100140092569202017aa00c5dd30000000000000000000000000000000007d1000001020001b20788b80059f48d95cdefc8c6000200200030d41e0000012016840310a50733a9870fffd0430100"");
final static byte[] signature = DatatypeConverter.parseHexBinary(""531F8918FF250132959B01F7F56FDFD9E6CA3EC2144E12A6DA37C281489A3D96"");
</code></pre>

<p>New data outputs this error:</p>

<pre><code>java.security.SignatureException: error decoding signature bytes.
    at org.bouncycastle.jcajce.provider.asymmetric.util.DSABase.engineVerify(Unknown Source)
    at java.security.Signature$Delegate.engineVerify(Signature.java:1178)
    at java.security.Signature.verify(Signature.java:612)
    at its.sec.exec.TestProgram.isValidSignature(TestProgram.java:168)
    at its.sec.exec.TestProgram.execution(TestProgram.java:101)
    at its.sec.exec.TestProgram.main(TestProgram.java:55)
</code></pre>

<p>I assume the problem is about the signature that comes with the <em>secured message</em> because:</p>

<ul>
<li>The key pair is the same length and format that the example. And are correct since it comes from the certificate that signs the message.</li>
<li>The message itself (payload) shouldn't affect the security process.</li>
</ul>

<p>Last thing worth mention is that my documentation says that the signature must be preceded by a field called ""R"" which <em>""contains the x coordinate of the elliptic curve point resulting from multiplying the generator element by the ephemeral private key""</em> and its length must be the same as the signature (32 byte).</p>

<p>Can someone point me out what I'm missing here?</p>

<p><strong>EDIT: Solution</strong></p>

<p>As Peter Dettman pointed in his answer, the <code>signature</code> was not correctly formatted (also content was incorrect too) in order to be computed by the <code>verify()</code> method. <a href=""https://crypto.stackexchange.com/questions/1795/how-can-i-convert-a-der-ecdsa-signature-to-asn-1"">Here</a> is a good explanation that mainly says that:</p>

<blockquote>
  <p>When encoded in DER, this (signature) becomes the following sequence of bytes:</p>
  
  <p><code>0x30 b1 0x02 b2 (vr) 0x02 b3 (vs)</code></p>
  
  <p>where:</p>
  
  <ul>
  <li>b1 is a single byte value, equal to the length, in bytes, of the remaining list of bytes (from the first 0x02 to the end of the encoding);</li>
  <li>b2 is a single byte value, equal to the length, in bytes, of (vr);</li>
  <li>b3 is a single byte value, equal to the length, in bytes, of (vs);</li>
  <li>(vr) is the signed big-endian encoding of the value ""r"", of minimal length;</li>
  <li>(vs) is the signed big-endian encoding of the value ""s"", of minimal length.</li>
  </ul>
</blockquote>

<p>Applying that change, <code>signature</code> grows to 70 bytes and the execution outputs no error.</p>
","<p>this is a sample code to write r and s in ASN1 DER encoded format</p>

<pre><code>    // construct the ASN1Sequence with r and s
    ByteArrayOutputStream outs = new ByteArrayOutputStream();

    byte radd = (byte)(((signed[0] &amp; 0x80) &gt; 0) ? 1 : 0);
    byte sadd = (byte)(((signed[32] &amp; 0x80) &gt; 0) ? 1 : 0);

    byte length = (byte)(0x44 + radd + sadd);

    outs.write(0x30);
    outs.write(length); // length 68 bytes +
    outs.write(0x02); // ASN1Integer
    outs.write(0x20 + radd); // length 32 bytes
    if(radd &gt; 0)
        outs.write(0x00); // positive val
    outs.write(signed, 0, 32);
    outs.write(0x02); // ASN1Integer
    outs.write(0x20 + sadd); // length 32 bytes
    if(sadd &gt; 0)
        outs.write(0x00); // positive val
    outs.write(signed, 32, 32);

    signed = outs.toByteArray();
</code></pre>
","5362","<java><bouncycastle><signature><ecdsa>","9","1","2","2018-12-16 10:38:40","30256618","2","3","-1","","2017-05-23 12:02:46","2015-05-11 18:37:03",""
"20525147","Python module ecdsa errors while running paramiko","<p>I am trying to install paramiko module..it fails with the below error </p>

<pre><code>python ./test.py 
Traceback (most recent call last):
  File ""./test.py"", line 30, in &lt;module&gt;
    import paramiko
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/__init__.py"", line 64, in &lt;module&gt;
    from transport import SecurityOptions, Transport
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/transport.py"", line 45, in &lt;module&gt;
    from paramiko.ecdsakey import ECDSAKey
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/ecdsakey.py"", line 24, in &lt;module&gt;
    from ecdsa import SigningKey, VerifyingKey, der, curves
ImportError: No module named ecdsa
</code></pre>

<p>Any suggestions on how to proceed with the paramiko installation ?</p>
","<p>You can use easy_install to install the lost module ""ecdsa"" ,which like: easy_install ecdsa,
but you have to ready easy_install first! </p>
","5335","<python><paramiko><ecdsa>","6","0","3","2019-10-17 15:35:06","","6","","178163","","2016-11-06 19:49:58","2013-12-11 16:54:05",""
"20525147","Python module ecdsa errors while running paramiko","<p>I am trying to install paramiko module..it fails with the below error </p>

<pre><code>python ./test.py 
Traceback (most recent call last):
  File ""./test.py"", line 30, in &lt;module&gt;
    import paramiko
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/__init__.py"", line 64, in &lt;module&gt;
    from transport import SecurityOptions, Transport
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/transport.py"", line 45, in &lt;module&gt;
    from paramiko.ecdsakey import ECDSAKey
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/ecdsakey.py"", line 24, in &lt;module&gt;
    from ecdsa import SigningKey, VerifyingKey, der, curves
ImportError: No module named ecdsa
</code></pre>

<p>Any suggestions on how to proceed with the paramiko installation ?</p>
","<p>Download the package from '<a href=""https://github.com/warner/python-ecdsa"" rel=""nofollow"">https://github.com/warner/python-ecdsa</a>' and install it using command </p>

<pre><code>python setup.py install
</code></pre>

<p>Your problem will be solved.</p>
","5335","<python><paramiko><ecdsa>","6","2","3","2019-10-17 15:35:06","","6","","178163","","2016-11-06 19:49:58","2013-12-11 16:54:05",""
"20525147","Python module ecdsa errors while running paramiko","<p>I am trying to install paramiko module..it fails with the below error </p>

<pre><code>python ./test.py 
Traceback (most recent call last):
  File ""./test.py"", line 30, in &lt;module&gt;
    import paramiko
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/__init__.py"", line 64, in &lt;module&gt;
    from transport import SecurityOptions, Transport
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/transport.py"", line 45, in &lt;module&gt;
    from paramiko.ecdsakey import ECDSAKey
  File ""/tmp/build-paramiko/paramiko-1.12.0/paramiko/ecdsakey.py"", line 24, in &lt;module&gt;
    from ecdsa import SigningKey, VerifyingKey, der, curves
ImportError: No module named ecdsa
</code></pre>

<p>Any suggestions on how to proceed with the paramiko installation ?</p>
","<p>this:</p>

<pre><code>    from ecdsa import SigningKey, VerifyingKey, der, curves
ImportError: No module named ecdsa
</code></pre>

<p>suggests that the python-ecdsa package is missing, you can install it with</p>

<pre><code>pip install ecdsa
</code></pre>

<p>Though in general, you shouldn't need to install paramiko from sources. You can install it with</p>

<pre><code>pip install paramiko
</code></pre>

<p>that has the benefit of automatically resolving the dependencies of a package</p>
","5335","<python><paramiko><ecdsa>","6","0","3","2019-10-17 15:35:06","","6","","178163","","2016-11-06 19:49:58","2013-12-11 16:54:05",""
"30945722","Converting byte array to publickey ECDSA","<p>I need to use ECDSA algorithm to sign a message and send to receiver in java. Then, receiver should verify sender's signature.</p>

<p>So, for this, receiver has sender's public key but in byte array format after converting <code>java.security.PublicKey</code> to byte array by the command bellow:</p>

<pre><code>byte[] byteArrayPublicKey = publickey.getEncoded();
</code></pre>

<p>The format of public key in ECDSA algorithm (before converting it to byte array) is as follow:</p>

<p>Public Key:</p>

<pre><code>X: 8a83c389e7bb817c17bf2db4ed71055f18342b630221b2a3a1ca752502dc2e21

Y: 3eaf48c9ab1700fe0966a0cde196b85af66bb8f0bacef711c9dca2368f9d8470
</code></pre>

<p>But, the problem is to convert this byte array to usable format to verify the signature that is <code>java.security.PublicKey</code> by receiver. </p>

<p>In general, is there any solution to verify the signature without converting it to byte array? In the other word, the problem is to verify the signature by sender's public key, using any method.</p>
","<blockquote>
  <p>But, the problem is to convert this byte array to usable format to verify the signature that is java.security.PublicKey by receiver.</p>
</blockquote>

<p>You can solve the problem like this way:</p>

<pre><code>public static ECPublicKey genEcPubKey() throws Exception {
    KeyFactory factory = KeyFactory.getInstance(""ECDSA"", ""BC"");
    java.security.PublicKey ecPublicKey = (ECPublicKey) factory
            .generatePublic(new X509EncodedKeySpec(Helper
                    .toByte(ecRemotePubKey))); // Helper.toByte(ecRemotePubKey)) is java.security.PublicKey#getEncoded()
    return (ECPublicKey) ecPublicKey;
}
</code></pre>

<p>Note that, you need <a href=""https://www.bouncycastle.org/latest_releases.html"" rel=""nofollow"">BouncyCastle</a> provider to do that.</p>

<p>But question remains, how you generate the private key?</p>

<pre><code>public KeyPair ecKeyPairGenerator(String curveName) throws Exception {
    KeyPair keyPair;
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
            ""ECDSA"", ""BC"");
    ECGenParameterSpec ecGenParameterSpec = new ECGenParameterSpec(
            curveName);
    keyPairGenerator.initialize(ecGenParameterSpec, new SecureRandom());
    keyPair = keyPairGenerator.generateKeyPair();
    java.security.PublicKey ecPublicKey = (ECPublicKey) keyPair.getPublic();
    System.out.println(""JAVA EC PublicKey: ""
            + Helper.toHex(ecPublicKey.getEncoded()));

    // write private key into a file. Just for testing purpose
    FileOutputStream fileOutputStream = new FileOutputStream(
            ""ECPrivateKey.key"");
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(
            fileOutputStream);
    objectOutputStream.writeObject(keyPair.getPrivate());
    objectOutputStream.close();
    return keyPair;
}
</code></pre>

<p>I have the full running code for EC sign/verify in <a href=""https://github.com/rakeb/ECPSingVerify"" rel=""nofollow"">github</a>. You can take a look for better understanding.</p>
","4753","<java><key><signature><public-key><ecdsa>","2","3","1","2015-06-20 18:06:40","30947243","1","0","5029509","","2015-06-20 18:06:40","2015-06-19 19:16:43",""
"25829939","Specification defining ECDSA signature data","<p>I want to know what specification (or standard) define the data format of the ECDSA signature and public key?</p>

<p>I'm testing the ECDSA signature on java card. I found out that there is a TLV format in the signature and the public key value.</p>

<pre><code>* Public key (TV format)
[Tag=04] [public key value 1] [public key value 2]
04 038A3F59E813995DAB730588CFCBB985F5A1ED90C0D62960AE0B274D 2E6B12672318E0B113DECC0406B62887B6BCB9B1583B1A50779EAB5A

* Signature (TLV format)
[Tag=30] [Length=3C~3E] [Tag=02] [Length=1C~1D] [signature value 1] [Tag=02] [Length=1C~1D] [signature value 2]

303C 021C 7EEB0B2596F74344B3D7B046EA0BD17C4461FC277658CE93509F1674      021C 4F5DBFB30D994664DA80528847A767F0194876B068E5958161797991
303E 021D 0080F20B82D407AE663F010F4990F12073631D653EA1D65DC75EBD4293    021D 00880DB667EF51AEA8E7C9BB012496C7C9ECE3BC5829B82B692B9211C3
303D 021D 00F77447EF326A4A49597D0B839F68F524891F3655DA4561F1AA10EF70    021C 152F7FF18644C5E5C9118736E1F7528F0B10C5FF641C7B7CDF012129
303D 021D 00A2EBCC5C5981341D0726F2E846CC3879C74EFD64D8698589A8CEAB60    021C 6E04FF884A451D7C0737A182BC2DE7F7D3008EE182B46A009BFFC9E8
</code></pre>

<p>I think that the data format is defined in some specification or standard. I just want to know the document name.</p>
","<p>It's in here:<br>
<a href=""https://www.ietf.org/rfc/rfc5480.txt"" rel=""nofollow"">https://www.ietf.org/rfc/rfc5480.txt</a><br>
Also ANDI X9.62 might be important, but not freely available i think
For example:<br></p>

<p>ECDSA-Sig-Value ::= SEQUENCE {
     r  INTEGER,
     s  INTEGER
   }</p>
","4580","<format><specifications><javacard><ecdsa>","4","2","3","2016-07-01 13:44:04","","0","2","4370109","","2015-11-21 17:12:29","2014-09-14 03:59:47",""
"25829939","Specification defining ECDSA signature data","<p>I want to know what specification (or standard) define the data format of the ECDSA signature and public key?</p>

<p>I'm testing the ECDSA signature on java card. I found out that there is a TLV format in the signature and the public key value.</p>

<pre><code>* Public key (TV format)
[Tag=04] [public key value 1] [public key value 2]
04 038A3F59E813995DAB730588CFCBB985F5A1ED90C0D62960AE0B274D 2E6B12672318E0B113DECC0406B62887B6BCB9B1583B1A50779EAB5A

* Signature (TLV format)
[Tag=30] [Length=3C~3E] [Tag=02] [Length=1C~1D] [signature value 1] [Tag=02] [Length=1C~1D] [signature value 2]

303C 021C 7EEB0B2596F74344B3D7B046EA0BD17C4461FC277658CE93509F1674      021C 4F5DBFB30D994664DA80528847A767F0194876B068E5958161797991
303E 021D 0080F20B82D407AE663F010F4990F12073631D653EA1D65DC75EBD4293    021D 00880DB667EF51AEA8E7C9BB012496C7C9ECE3BC5829B82B692B9211C3
303D 021D 00F77447EF326A4A49597D0B839F68F524891F3655DA4561F1AA10EF70    021C 152F7FF18644C5E5C9118736E1F7528F0B10C5FF641C7B7CDF012129
303D 021D 00A2EBCC5C5981341D0726F2E846CC3879C74EFD64D8698589A8CEAB60    021C 6E04FF884A451D7C0737A182BC2DE7F7D3008EE182B46A009BFFC9E8
</code></pre>

<p>I think that the data format is defined in some specification or standard. I just want to know the document name.</p>
","<p>The public key value is  an uncompressed point. It is defined by value <code>04</code>, which is an identifier for an uncompressed point, followed by the X and Y coordinate, where the X and Y are encoded as unsigned big endian octet strings that have the same size as the key size (same as the size of the order of the curve in the parameters). Note that <code>04</code> is also the tag for an OCTET STRING in ASN.1, but that has nothing to do with the uncompressed point indicator.</p>

<p>The format of the domain parameters is unknown to me. It's certainly not encoded as  <a href=""https://www.ietf.org/rfc/rfc5480.txt"" rel=""nofollow"">https://www.ietf.org/rfc/rfc5480.txt</a> as Paul suggests. I presume it is some proprietary DER format, which uses multiple ASN.1 SEQUENCE values filled with two ASN.1 INTEGER values each. These integer values (after the length) are signed, unpadded, big endian encodings, which fortunately are completely compatible with the encoding of Java's <code>BigInteger</code>.</p>

<p>Paul Bastian is correct with regards to the signature generated, it's X9.42 compatible. Plain signatures are not yet supported by Java Card.</p>
","4580","<format><specifications><javacard><ecdsa>","4","1","3","2016-07-01 13:44:04","","0","2","4370109","","2015-11-21 17:12:29","2014-09-14 03:59:47",""
"25829939","Specification defining ECDSA signature data","<p>I want to know what specification (or standard) define the data format of the ECDSA signature and public key?</p>

<p>I'm testing the ECDSA signature on java card. I found out that there is a TLV format in the signature and the public key value.</p>

<pre><code>* Public key (TV format)
[Tag=04] [public key value 1] [public key value 2]
04 038A3F59E813995DAB730588CFCBB985F5A1ED90C0D62960AE0B274D 2E6B12672318E0B113DECC0406B62887B6BCB9B1583B1A50779EAB5A

* Signature (TLV format)
[Tag=30] [Length=3C~3E] [Tag=02] [Length=1C~1D] [signature value 1] [Tag=02] [Length=1C~1D] [signature value 2]

303C 021C 7EEB0B2596F74344B3D7B046EA0BD17C4461FC277658CE93509F1674      021C 4F5DBFB30D994664DA80528847A767F0194876B068E5958161797991
303E 021D 0080F20B82D407AE663F010F4990F12073631D653EA1D65DC75EBD4293    021D 00880DB667EF51AEA8E7C9BB012496C7C9ECE3BC5829B82B692B9211C3
303D 021D 00F77447EF326A4A49597D0B839F68F524891F3655DA4561F1AA10EF70    021C 152F7FF18644C5E5C9118736E1F7528F0B10C5FF641C7B7CDF012129
303D 021D 00A2EBCC5C5981341D0726F2E846CC3879C74EFD64D8698589A8CEAB60    021C 6E04FF884A451D7C0737A182BC2DE7F7D3008EE182B46A009BFFC9E8
</code></pre>

<p>I think that the data format is defined in some specification or standard. I just want to know the document name.</p>
","<p>The ASN.1 structure is defined in <a href=""http://www.secg.org/sec1-v2.pdf"" rel=""nofollow"">SEC 1: Elliptic Curve Cryptography</a> (part C: ASN.1 for Elliptic Curve Cryptography), from the SECG (Standards for Efficient Cryptography Group).</p>
","4580","<format><specifications><javacard><ecdsa>","4","3","3","2016-07-01 13:44:04","","0","2","4370109","","2015-11-21 17:12:29","2014-09-14 03:59:47",""
"17439732","Recreating Keys (ECPublicKeyParameters) in C# with BouncyCastle","<p>I generate an AsymmetricCipherKeyPair as follows:</p>

<pre><code>string curveName = ""P-521"";
X9ECParameters ecP = NistNamedCurves.GetByName(curveName);
ECDomainParameters ecSpec = new ECDomainParameters(ecP.Curve, ecP.G, ecP.N, ecP.H, ecP.GetSeed());
IAsymmetricCipherKeyPairGenerator g = GeneratorUtilities.GetKeyPairGenerator(""ECDH"");
g.Init(new ECKeyGenerationParameters(ecSpec, new SecureRandom()));
AsymmetricCipherKeyPair aKeyPair = g.GenerateKeyPair();
</code></pre>

<p>My intention was to extract the public and private keys and then rebuild the keys later. I first extracted the keys as follows:</p>

<pre><code>byte[] privateKey = ((ECPrivateKeyParameters)aKeyPair.Private).D.ToByteArray();
byte[] publicKey = ((ECPublicKeyParameters)aKeyPair.Public).Q.GetEncoded();
</code></pre>

<p>How do I recreate the public and private key parameters so that I can use them? In this example, I do recreate the private key and then sign the data byte array.</p>

<pre><code>public static byte[] SignData(byte[] data, byte[] privateKey)
{
    string curveName = ""P-521"";
    X9ECParameters ecP = NistNamedCurves.GetByName(curveName);
    ECDomainParameters ecSpec = new ECDomainParameters(ecP.Curve, ecP.G, ecP.N, ecP.H, ecP.GetSeed());
    ISigner signer = SignerUtilities.GetSigner(""SHA-256withECDSA"");
    BigInteger biPrivateKey = new BigInteger(privateKey);
    ECPrivateKeyParameters keyParameters = new ECPrivateKeyParameters(biPrivateKey, ecSpec);
    signer.Init(true, keyParameters);
    signer.BlockUpdate(data, 0, data.Length);
    return signer.GenerateSignature();
}
</code></pre>

<p>Although it feels like a real hack, it works just fine. How can I do this with the Public Key? I set the variable xxx to (ECPublicKeyParameters)aKeyPair.Public and I can use the code below to verify the signature. Note that I could use xxx directly, but the point is to serialize xxx out and then back in, so, this code actually does convert the xxx variable and creates a new one, which is stored in xx. I then use xx to verify (which shows that I can round trip the key). </p>

<pre><code>var xx = PublicKeyFactory.CreateKey(Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(xxx).GetDerEncoded());
ISigner signer = SignerUtilities.GetSigner(""SHA-256withECDSA"");
signer.Init(false, xx);
signer.BlockUpdate(data, 0, data.Length);
return signer.VerifySignature(signature);
</code></pre>

<p>I had hoped that I could create the key (xx) from Q.GetEncoded() similar to how I did it for the private key. </p>

<p>Is there a better way to rebuild the private key? also using an ASN.1 encoding? If so, perhaps I should use that instead.</p>
","<p>I can do this as follows:</p>

<pre><code>string curveName = ""P-521"";
X9ECParameters ecP = NistNamedCurves.GetByName(curveName);
FpCurve c = (FpCurve)ecP.Curve;
ECFieldElement x = new FpFieldElement(c.Q, xxx.Q.X.ToBigInteger());
ECFieldElement y = new FpFieldElement(c.Q, xxx.Q.Y.ToBigInteger());
ECPoint q = new FpPoint(c, x, y);
ECPublicKeyParameters xxpk = new ECPublicKeyParameters(""ECDH"", q, SecObjectIdentifiers.SecP521r1);
</code></pre>

<p>Then, I can use xxpk to verify the signature. </p>

<p>Disclaimer: I do not claim that this is the best way to do this, just that it works!</p>
","4323","<c#><bouncycastle><ecdsa>","5","3","1","2013-07-03 12:43:48","17448345","0","","2544747","","2013-07-03 04:46:41","2013-07-03 04:33:57",""
"40155888","How can I generate a valid ECDSA EC key pair?","<p>I am trying to generate ECDSA key pair using SpongyCastle in Android.
This is the code:</p>

<pre><code>static {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
}

public static KeyPair generate() {
        ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""ECDSA"", ""SC"");
        generator.initialize(ecSpec, new SecureRandom());
        KeyPair keyPair = g.generateKeyPair();
        Log.i(TAG, ""EC Pub Key generated: "" + utils.bytesToHex(keyPair.getPublic().getEncoded()));
        Log.i(TAG, ""EC Private Key generated: "" + utils.bytesToHex(keyPair.getPrivate().getEncoded()));            
       return generator.generateKeyPair();
}
</code></pre>

<p>Something is wrong since I always get something like that example of 
Public Key:</p>

<blockquote>
  <p>3059301306072A8648CE3D020106082A8648CE3D03010703420004483ABA9F322240010ECF00E818C041A60FE71A2BD64C64CD5A60519985F110AEDE6308027D2730303F5E2478F083C7F5BB683DCAC22BFEB62F3A48BD01009F40</p>
</blockquote>

<p>and Private Key: </p>

<blockquote>
  <p>308193020100301306072A8648CE3D020106082A8648CE3D030107047930770201010420219AB4B3701630973A4B2917D53F69A4BE6DAD61F48016BFEF147B2999575CB2A00A06082A8648CE3D030107A14403420004483ABA9F322240010ECF00E818C041A60FE71A2BD64C64CD5A60519985F110AEDE6308027D2730303F5E2478F083C7F5BB683DCAC22BFEB62F3A48BD01009F40</p>
</blockquote>

<p>The site <a href=""https://kjur.github.io/jsrsasign/sample-ecdsa.html"" rel=""nofollow"" title=""https://kjur.github.io/jsrsasign/sample-ecdsa.html"">ECDSA sample</a> give me ""Invalid ECDSA signature message"", and them seems really very different from that smaller Private Key and always starting with ""04"" Public Key generated in the same site.</p>

<p>Also, my backend verification gives me the error ""Invalid point encoding 0x30""</p>

<p>The backend Java method check is:</p>

<pre><code>public ECPublicKey getPublicKeyFromHex(String publicKeyHex)
        throws NoSuchAlgorithmException, DecoderException, ApplicationGenericException {
    byte[] rawPublicKey = Hex.decodeHex(publicKeyHex.toCharArray());
    ECPublicKey ecPublicKey = null;
    KeyFactory kf = null;

    ECNamedCurveParameterSpec ecNamedCurveParameterSpec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
    ECCurve curve = ecNamedCurveParameterSpec.getCurve();
    EllipticCurve ellipticCurve = EC5Util.convertCurve(curve, ecNamedCurveParameterSpec.getSeed());
    java.security.spec.ECPoint ecPoint = ECPointUtil.decodePoint(ellipticCurve, rawPublicKey);
    java.security.spec.ECParameterSpec ecParameterSpec = EC5Util.convertSpec(ellipticCurve,
            ecNamedCurveParameterSpec);
    java.security.spec.ECPublicKeySpec publicKeySpec = new java.security.spec.ECPublicKeySpec(ecPoint,
            ecParameterSpec);

    kf = KeyFactory.getInstance(""ECDSA"", new BouncyCastleProvider());

    try {
        ecPublicKey = (ECPublicKey) kf.generatePublic(publicKeySpec);
    } catch (Exception e) {
        throw new ApplicationGenericException(e.getMessage(), e.getCause());
    }

    return ecPublicKey;
}
</code></pre>
","<p>Java's default encoding for a <code>PublicKey</code> is <code>""X.509""</code> which is not just the EC point; it is an ASN.1 structure identifying the algorithm (EC) and parameters (here prime256v1) PLUS a BIT STRING wrapping the point; see <a href=""https://tools.ietf.org/html/rfc5280#section-4.1.2.7"" rel=""nofollow"">rfc5280 section 4.2.1.7</a> and <a href=""https://tools.ietf.org/html/rfc3279#section-2.3.5"" rel=""nofollow"">rfc3279 section 2.3.5</a>. </p>

<p>Similarly the default encoding for <code>PrivateKey</code> is <code>""PKCS#8""</code> (unencrypted) which is a structure containing an AlgorithmIdentifier plus an OCTET STRING wrapping the data which in this case contains both the private key value and a copy of the public key, see <a href=""https://tools.ietf.org/html/rfc5208#section-5"" rel=""nofollow"">rfc5208 section 5</a> and C.4 of document SEC 1 at <a href=""http://www.secg.org"" rel=""nofollow"">http://www.secg.org</a> with tag <code>[0]</code> omitted but tag <code>[1]</code> present.</p>

<p>To read (either or both of) them back in to Java, get a <code>KeyFactory.getInstance(""EC"")</code> and use <code>generate{Public,Private}</code> on an <code>X509EncodedKeySpec</code> or <code>PKCS8EncodedKeySpec</code> respectively.
ECDSA and ECDH (and ECMQV etc) use the same key structures, unlike classic integer DSA and DH which use the same <em>mathematical</em> structure ($Z_p^*$) but slightly different representations.</p>

<p>PS: the <a href=""https://docs.oracle.com/javase/8/docs/api/java/security/Key.html"" rel=""nofollow"">javadoc for <code>java.security.Key</code></a> tells you most of this.</p>
","4260","<bouncycastle><elliptic-curve><ecdsa><dsa><spongycastle>","2","5","2","2016-10-24 09:42:25","","0","","5962766","","2016-10-24 09:42:25","2016-10-20 03:02:33",""
"40155888","How can I generate a valid ECDSA EC key pair?","<p>I am trying to generate ECDSA key pair using SpongyCastle in Android.
This is the code:</p>

<pre><code>static {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
}

public static KeyPair generate() {
        ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""ECDSA"", ""SC"");
        generator.initialize(ecSpec, new SecureRandom());
        KeyPair keyPair = g.generateKeyPair();
        Log.i(TAG, ""EC Pub Key generated: "" + utils.bytesToHex(keyPair.getPublic().getEncoded()));
        Log.i(TAG, ""EC Private Key generated: "" + utils.bytesToHex(keyPair.getPrivate().getEncoded()));            
       return generator.generateKeyPair();
}
</code></pre>

<p>Something is wrong since I always get something like that example of 
Public Key:</p>

<blockquote>
  <p>3059301306072A8648CE3D020106082A8648CE3D03010703420004483ABA9F322240010ECF00E818C041A60FE71A2BD64C64CD5A60519985F110AEDE6308027D2730303F5E2478F083C7F5BB683DCAC22BFEB62F3A48BD01009F40</p>
</blockquote>

<p>and Private Key: </p>

<blockquote>
  <p>308193020100301306072A8648CE3D020106082A8648CE3D030107047930770201010420219AB4B3701630973A4B2917D53F69A4BE6DAD61F48016BFEF147B2999575CB2A00A06082A8648CE3D030107A14403420004483ABA9F322240010ECF00E818C041A60FE71A2BD64C64CD5A60519985F110AEDE6308027D2730303F5E2478F083C7F5BB683DCAC22BFEB62F3A48BD01009F40</p>
</blockquote>

<p>The site <a href=""https://kjur.github.io/jsrsasign/sample-ecdsa.html"" rel=""nofollow"" title=""https://kjur.github.io/jsrsasign/sample-ecdsa.html"">ECDSA sample</a> give me ""Invalid ECDSA signature message"", and them seems really very different from that smaller Private Key and always starting with ""04"" Public Key generated in the same site.</p>

<p>Also, my backend verification gives me the error ""Invalid point encoding 0x30""</p>

<p>The backend Java method check is:</p>

<pre><code>public ECPublicKey getPublicKeyFromHex(String publicKeyHex)
        throws NoSuchAlgorithmException, DecoderException, ApplicationGenericException {
    byte[] rawPublicKey = Hex.decodeHex(publicKeyHex.toCharArray());
    ECPublicKey ecPublicKey = null;
    KeyFactory kf = null;

    ECNamedCurveParameterSpec ecNamedCurveParameterSpec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
    ECCurve curve = ecNamedCurveParameterSpec.getCurve();
    EllipticCurve ellipticCurve = EC5Util.convertCurve(curve, ecNamedCurveParameterSpec.getSeed());
    java.security.spec.ECPoint ecPoint = ECPointUtil.decodePoint(ellipticCurve, rawPublicKey);
    java.security.spec.ECParameterSpec ecParameterSpec = EC5Util.convertSpec(ellipticCurve,
            ecNamedCurveParameterSpec);
    java.security.spec.ECPublicKeySpec publicKeySpec = new java.security.spec.ECPublicKeySpec(ecPoint,
            ecParameterSpec);

    kf = KeyFactory.getInstance(""ECDSA"", new BouncyCastleProvider());

    try {
        ecPublicKey = (ECPublicKey) kf.generatePublic(publicKeySpec);
    } catch (Exception e) {
        throw new ApplicationGenericException(e.getMessage(), e.getCause());
    }

    return ecPublicKey;
}
</code></pre>
","<p>More practical example. Convert generated public key to decoded bytes array or hex string:  </p>

<pre><code>public String getPublicKeyAsHex(PublicKey publicKey){

    ECPublicKey ecPublicKey = (ECPublicKey)publicKey;
    ECPoint ecPoint = ecPublicKey.getW();

    byte[] publicKeyBytes = new byte[PUBLIC_KEY_LENGTH];
    writeToStream(publicKeyBytes, 0, ecPoint.getAffineX(), PRIVATE_KEY_LENGTH);
    writeToStream(publicKeyBytes, PRIVATE_KEY_LENGTH, ecPoint.getAffineY(), PRIVATE_KEY_LENGTH);

    String hex = Hex.toHexString(publicKeyBytes);

    logger.debug(""Public key bytes: "" + Arrays.toString(publicKeyBytes));
    logger.debug(""Public key hex: "" + hex);

    return hex;
}

private void writeToStream(byte[] stream, int start, BigInteger value, int size) {
    byte[] data = value.toByteArray();
    int length = Math.min(size, data.length);
    int writeStart = start + size - length;
    int readStart = data.length - length;
    System.arraycopy(data, readStart, stream, writeStart, length);
}
</code></pre>

<p>Convert decoded bytes array back to <code>PublicKey</code>:</p>

<pre><code>KeyFactory factory = KeyFactory.getInstance(ALGORITHM, ALGORITHM_PROVIDER);

ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(CURVE);

ECNamedCurveSpec params = new ECNamedCurveSpec(CURVE, spec.getCurve(), spec.getG(), spec.getN());

BigInteger xCoordinate = new BigInteger(1, Arrays.copyOfRange(decodedPublicKey, 0, PRIVATE_KEY_LENGTH));
BigInteger yCoordinate = new BigInteger(1, Arrays.copyOfRange(decodedPublicKey, PRIVATE_KEY_LENGTH, PUBLIC_KEY_LENGTH));
java.security.spec.ECPoint w = new java.security.spec.ECPoint(xCoordinate, yCoordinate);

PublicKey encodedPublicKey = factory.generatePublic(new java.security.spec.ECPublicKeySpec(w, params));
</code></pre>
","4260","<bouncycastle><elliptic-curve><ecdsa><dsa><spongycastle>","2","1","2","2016-10-24 09:42:25","","0","","5962766","","2016-10-24 09:42:25","2016-10-20 03:02:33",""
"36968896","Openssl ECDSA : private key passphrase","<p>I am new with Openssl i have generated a private key myprivatekey.pem and a publickey mypublickey.pem with :</p>

<pre><code>openssl ecparam -genkey -name secp160k1 -noout -out myprivatekey.pem
</code></pre>

<p>and my public key with :</p>

<pre><code>openssl -ec  -in myprivatekey.pem -pubout -out mypublickey.pem
</code></pre>

<p>What i want to do next is to encrypte my ecdsa with a passphrase private key and make a certification request for my public key and thank you for your help.  </p>
","<p>It would seem that <code>ecparam</code> doesn't have a built-in option for encrypting the generated key. Instead, you can simply do the following:</p>

<pre><code>openssl ec -in myprivatekey.pem -out myprivatekey_encrypted.pem -aes256
</code></pre>

<p>Compared to <code>genrsa</code>, an extra step is required, but this basically does the same thing.</p>

<hr>

<p>Now as far as the certificate request, the command is pretty much the same regardless of the type of private key used:</p>

<pre><code>openssl req -new -sha256 -key myprivatekey.pem -out mycertrequest.pem
</code></pre>

<p>You can then take the resulting <code>mycertrequest.pem</code> and send it to a CA for signing.</p>

<hr>

<p><strong>Edit:</strong></p>

<p>If you have concerns about writing the unencrypted private key to disk, you can do both the generation and encryption of the key in one step like so:</p>

<pre><code>openssl ecparam -genkey -name secp256k1 | openssl ec -aes256 -out privatekey.pem
</code></pre>

<p>This generates a P-256 key, then prompts you for a passphrase. The key is then encrypted using AES256 and saved into <code>privatekey.pem</code>.</p>
","4248","<security><encryption><openssl><ecdsa>","4","10","1","2017-07-25 17:39:59","39815131","1","","3337864","","2016-05-01 18:36:36","2016-05-01 16:18:03",""
"22003407","Bouncy Castle ESCDA Create Public Key from Private Key","<p>I am trying to sign a bitcoin transaction in c#.  I have 2 bits of code I am trying to complete.  I can create a set of private and public keys using Bouncy castle.   I can convert this to wallet import format ok.</p>

<p>I can also generate a bitcoin address from the ECDSA public key.</p>

<p>However, I want to sign a transaction and all I have is my private key.  I don't want to have to import into a wallet and sign.  So how can I generate the public key, given only the private key?</p>

<p>I have found a javascript method that does this:</p>

<pre><code>ecparams.getG().multiply(this.priv).getEncoded();
</code></pre>

<p>The only way I've seen in Bouncy Castle is to generate a random pair.</p>

<pre><code>private static AsymmetricCipherKeyPair GenerateKeys(int keySize)
{
  ECKeyPairGenerator gen = new ECKeyPairGenerator();
  SecureRandom secureRandom = new SecureRandom();
  KeyGenerationParameters keyGenParam = new KeyGenerationParameters(secureRandom, keySize);
  gen.Init(keyGenParam);
  return gen.GenerateKeyPair();
}
</code></pre>
","<p>take a look at the following code. the private key is given by as base64 encoded string in this example and also a base64 encoded string is given back. the commented keyParameters are working, so use this one if you want to have key and curve.</p>

<pre><code>private static readonly Org.BouncyCastle.Asn1.X9.X9ECParameters curve = Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByName(""secp256r1"");
private static readonly Org.BouncyCastle.Crypto.Parameters.ECDomainParameters domain = new Org.BouncyCastle.Crypto.Parameters.ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);
public string GetPublicKey(string privKey)
{
      Org.BouncyCastle.Math.BigInteger d = new Org.BouncyCastle.Math.BigInteger(Convert.FromBase64String(privKey));
      //var privKeyParameters = new Org.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters(d, domain);
      Org.BouncyCastle.Math.EC.ECPoint q = domain.G.Multiply(d);
      //var pubKeyParameters = new Org.BouncyCastle.Crypto.Parameters.ECPublicKeyParameters(q, domain);
      return Convert.ToBase64String(q.GetEncoded());
}
</code></pre>
","3905","<c#><bouncycastle><bitcoin><ecdsa>","2","1","3","2018-07-20 06:33:23","","0","","3204","","2014-03-18 10:09:48","2014-02-25 02:27:17",""
"22003407","Bouncy Castle ESCDA Create Public Key from Private Key","<p>I am trying to sign a bitcoin transaction in c#.  I have 2 bits of code I am trying to complete.  I can create a set of private and public keys using Bouncy castle.   I can convert this to wallet import format ok.</p>

<p>I can also generate a bitcoin address from the ECDSA public key.</p>

<p>However, I want to sign a transaction and all I have is my private key.  I don't want to have to import into a wallet and sign.  So how can I generate the public key, given only the private key?</p>

<p>I have found a javascript method that does this:</p>

<pre><code>ecparams.getG().multiply(this.priv).getEncoded();
</code></pre>

<p>The only way I've seen in Bouncy Castle is to generate a random pair.</p>

<pre><code>private static AsymmetricCipherKeyPair GenerateKeys(int keySize)
{
  ECKeyPairGenerator gen = new ECKeyPairGenerator();
  SecureRandom secureRandom = new SecureRandom();
  KeyGenerationParameters keyGenParam = new KeyGenerationParameters(secureRandom, keySize);
  gen.Init(keyGenParam);
  return gen.GenerateKeyPair();
}
</code></pre>
","<p>From steininger's answer, I got the following to work with the sample keys I had.</p>

<pre><code>using Org.BouncyCastle.Asn1.Sec;
using Org.BouncyCastle.Asn1.X9;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.Math.EC;

public static class Example
{
    private static X9ECParameters curve = SecNamedCurves.GetByName(""secp256k1"");
    private static ECDomainParameters domain = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);

    public static byte[] ToPublicKey(byte[] privateKey)
    {
        BigInteger d = new BigInteger(privateKey);
        ECPoint q = domain.G.Multiply(d);

        var publicParams = new ECPublicKeyParameters(q, domain);
        return publicParams.Q.GetEncoded();
    }
}
</code></pre>
","3905","<c#><bouncycastle><bitcoin><ecdsa>","2","3","3","2018-07-20 06:33:23","","0","","3204","","2014-03-18 10:09:48","2014-02-25 02:27:17",""
"22003407","Bouncy Castle ESCDA Create Public Key from Private Key","<p>I am trying to sign a bitcoin transaction in c#.  I have 2 bits of code I am trying to complete.  I can create a set of private and public keys using Bouncy castle.   I can convert this to wallet import format ok.</p>

<p>I can also generate a bitcoin address from the ECDSA public key.</p>

<p>However, I want to sign a transaction and all I have is my private key.  I don't want to have to import into a wallet and sign.  So how can I generate the public key, given only the private key?</p>

<p>I have found a javascript method that does this:</p>

<pre><code>ecparams.getG().multiply(this.priv).getEncoded();
</code></pre>

<p>The only way I've seen in Bouncy Castle is to generate a random pair.</p>

<pre><code>private static AsymmetricCipherKeyPair GenerateKeys(int keySize)
{
  ECKeyPairGenerator gen = new ECKeyPairGenerator();
  SecureRandom secureRandom = new SecureRandom();
  KeyGenerationParameters keyGenParam = new KeyGenerationParameters(secureRandom, keySize);
  gen.Init(keyGenParam);
  return gen.GenerateKeyPair();
}
</code></pre>
","<p>If you're dealing with DER encoded keys, it's even simpler:      </p>

<pre><code>  var privateKey = PrivateKeyFactory.CreateKey(bytes) as ECPrivateKeyParameters;
  if (privateKey == null)
       return null;
  Org.BouncyCastle.Math.EC.ECPoint q = privateKey.Parameters.G.Multiply(privateKey.D);
  var publicParams = new ECPublicKeyParameters(privateKey.AlgorithmName, q, privateKey.PublicKeyParamSet);
  return SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(publicParams).GetDerEncoded();
</code></pre>
","3905","<c#><bouncycastle><bitcoin><ecdsa>","2","1","3","2018-07-20 06:33:23","","0","","3204","","2014-03-18 10:09:48","2014-02-25 02:27:17",""
"20386230","Implementing secp256k1 (ECDSA) in PHP (for Bitcoin)","<p><strong>To keen downvoters and/or closers: If you think this is offtopic for SO, kindly point me out other StackExchange site where this question would be more appropriate.</strong></p>

<hr>

<p>How to implement ECDSA curve <strong>secp256k1</strong> in PHP?</p>

<p>Or rather: Are there any solutions - ie. includable specialized classes - already done?</p>

<p>I can see there are plenty of opensource libraries, classes and stuff available for other languages (JavaScript, Python,...) but I've just spent whole afternoon googling for some/any PHP solution and ... <strong><em>nothing!</em></strong>.</p>

<p>This is for a bitcoin project of mine and <strong>I need a way how to generate public key from private key</strong> ... <strong>and then I want to generate the final bitcoin address</strong>.</p>

<p><strong>I know how to generate private key</strong> (don't worry about it being random or not - not an issue here) and <strong>I have both 256bit hexadecimal and WIF notations</strong>. But the next step: coming up with a <em>public key</em> and then final <em>bitcoin address</em>, is kind of a problem to me, as I have literally zero cryptograph-ish background and I know the solution is to utilize secp256k1 somehow.</p>

<p>This is what I have so far:</p>

<pre><code>// Random bytes
// $private_key = bin2hex(openssl_random_pseudo_bytes(32));
// But using brainwallet.org style to have easy comparison
$passphrase = ""correct horse battery staple"";
$private_key = hash('sha256', $passphrase);
var_dump (""PrivKey: $private_key"");
// Bitcoin::privKeyToWIF from github.com/mikegogulski/bitcoin-php
$wif = Bitcoin::privKeyToWIF($private_key); 
var_dump (""WIF PrivKey: $wif"");
// And now I don't know where to even start ...
</code></pre>

<p><strong>tl;dr How to implement this in PHP?</strong> (..and <em>privKey->pubKey</em> conversion before that)</p>

<h2><a href=""http://i.stack.imgur.com/U2neg.png"" rel=""nofollow"">http://i.stack.imgur.com/U2neg.png</a></h2>

<p>I know about...</p>

<ul>
<li><a href=""http://github.com/mikegogulski/bitcoin-php"" rel=""nofollow"">http://github.com/mikegogulski/bitcoin-php</a> .. Which is pretty neat and has lots of useful methods and ways how to control <em>bitcoind</em> via RPC, but unfortunately pure PHP method that could handle <em>privKey->pubKey</em> mechanism is missing.</li>
<li><a href=""http://bitcoinphp.com/"" rel=""nofollow"">http://bitcoinphp.com/</a> .. I couldn't find it in there.</li>
<li><em>openssl extension in PHP</em>, but unfortunately the only digest method OPENSSL-PHP documentation is mentioning is 'ecdsa-with-SHA1', and correct me if I'm wrong, but I'd need 'ecdsa-with-SHA256', or something like that (?)</li>
<li>I even tried to convert the algorithm from <em>bitcoinjs.js</em>, but with my crypto-knowledge I was unable to extract the gist of anything. I simply don't understand those curves and their bit operations and other spooky stuff.</li>
</ul>

<p><strong>I'm looking for PURE PHP solution.</strong> I'm not looking for using shell running bitcoind and then parse JSON for key pairs and then...</p>

<p>Why there is no piece of code that could handle this entirely in PHP? <strong>OR IS THERE?!</strong> :)</p>
","","3494","<php><bitcoin><ecdsa><php-openssl>","6","","0","2014-06-15 13:48:23","","8","4","1285669","","2014-06-15 13:48:23","2013-12-04 21:21:01","2013-12-04 23:38:14"
"19955541","Generate elliptic curve key pairs (EC_KEY_generate_key) in multiple threads using OpenSSL C library","<p>I want to generate many ec key pairs. Speeding up the process a bit, I rewrote my appication to use multiple threads for this job. Here is a code snippet of the way each thread wants to generate the keys:</p>

<pre><code>(...)
EC_KEY* _ec_key = EC_KEY_new(); 
EC_GROUP* ec_group_new = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1); 
const EC_GROUP* ec_group = ec_group_new; 
if (!EC_KEY_set_group(ec_key,ec_group)) 
  DieWithError(""Error in initializeCrypto, EC_KEY_set_group failed!"");

// Segfault at this position
if(!EC_KEY_generate_key(ec_key))
  DieWithError (""Error in generateKeys, EC_KEY_generate_key failed!"");

(...)
EC_GROUP_free(ec_group_new); 
EC_KEY_free(ec_key);
</code></pre>

<p>Ok at the first glance, everything seemed to work fine. The applications ran twice as fast using four threads on my i5 520m. But then after 3-4 E6 key generations it suddenly segfaults. If I lock the EC_KEY_generate_key operation there is no segfault anymore, but the advantage of using multiple threads is gone. Now my questions. Is it possible split the creation of keys into multiple threads without corrupting memory? I didn't found any information using google. The <a href=""http://www.openssl.org/docs/crypto/EC_KEY_new.html"" rel=""nofollow"">SSL Docu</a> doesn't mention anything about thread-safety, though. Any help is highly appreciated. thx</p>
","<pre><code>// Segfault at this position
if(!EC_KEY_generate_key(ec_key))
  DieWithError (""Error in generateKeys, EC_KEY_generate_key failed!"");
...

... But then after 3-4 E6 key generations it suddenly segfaults.
</code></pre>

<p>You are using OpenSSL's random number generator, and its not thread safe. Below is from <code>cryptlib.c</code> around line 125. Notice the random number generators and the elliptic curve gear make the list.</p>

<pre><code>/* real #defines in crypto.h, keep these upto date */
static const char* const lock_names[CRYPTO_NUM_LOCKS] =
    {
    ""&lt;&lt;ERROR&gt;&gt;"",
    ""err"",
    ""ex_data"",
    ""x509"",
    ""x509_info"",
    ""x509_pkey"",
    ""x509_crl"",
    ""x509_req"",
    ...
    ""ssl_ctx"",
    ""ssl_session"",
    ""ssl"",
    ""ssl_method"",
    ""rand"",
    ""rand2"",
    ...
    ""ecdsa"",
    ""ec"",
    ""ecdh"",
    ""bn"",
    ""ec_pre_comp"",
    ...
    };
</code></pre>

<p>You have to explicitly set the locks. See <a href=""https://www.openssl.org/docs/crypto/threads.html"" rel=""noreferrer"">OpenSSL's threads(3)</a>.</p>

<hr>

<blockquote>
  <p>Is it possible split the creation of keys into multiple threads without corrupting memory?</p>
</blockquote>

<p>Yes, but you have to use OpenSSL's locking mechanism.</p>

<p>Here's what my OpenSSL initialization routine looks like in C++. It initializes the locks and sets the callbacks.</p>

<pre><code>pthread_mutex_t s_locks[CRYPTO_NUM_LOCKS] = { };

void Initialize()
{    
    static once_flag init;
    std::call_once(init, []() {      

        // Standard OpenSSL library init
        OPENSSL_no_config();
        SSL_library_init();

        SSL_load_error_strings();
        OpenSSL_add_ssl_algorithms();

        // Lock setup
        LOCK_setup();
        CALLBACK_setup();
    });
}

void LOCK_setup()
{    
    ASSERT(CRYPTO_NUM_LOCKS == CRYPTO_num_locks());
    if(CRYPTO_NUM_LOCKS != CRYPTO_num_locks())
        throw runtime_error(""CRYPTO_NUM_LOCKS mismatch"");

    for(unsigned i = 0; i &lt; CRYPTO_NUM_LOCKS; ++i)
    {
        int rc = pthread_mutex_init(&amp;s_locks[i], NULL);
        ASSERT(rc == 0);
        if(!(rc == 0))
            throw runtime_error(""pthread_mutex_init"");
    }
}

void CALLBACK_setup()
{    
    CRYPTO_set_id_callback(&amp;ThreadIdFnc);
    CRYPTO_set_locking_callback(&amp;LockingFnc);
}

void LockingFnc(int mode, int idx, const char* file, int line)
{
    ASSERT(mode == CRYPTO_LOCK || mode == CRYPTO_UNLOCK);
    ASSERT(CRYPTO_NUM_LOCKS == CRYPTO_num_locks());
    ASSERT(idx &gt;= 0 &amp;&amp; idx &lt; CRYPTO_NUM_LOCKS);

    if(!(idx &gt;= 0 &amp;&amp; idx &lt; CRYPTO_NUM_LOCKS))
    {    
        ostringstream oss;
        oss &lt;&lt; ""LockingFnc: lock failed with bad index "";
        oss &lt;&lt; idx &lt;&lt; "". File: "" &lt;&lt; (file ? file : ""Unknown"");
        oss &lt;&lt; "", line: "" &lt;&lt; line;

        // Log oss.str()
        return;
    }

    if((mode &amp; CRYPTO_LOCK) == CRYPTO_LOCK)
    {
        int rc = pthread_mutex_lock(&amp;s_locks[idx]);
        int err = errno;
        ASSERT(rc == 0);

        if(!(rc == 0))
        {
            ostringstream oss;
            oss &lt;&lt; ""LockingFnc: lock failed with error "";
            oss &lt;&lt; err &lt;&lt; "". File: "" &lt;&lt; (file ? file : ""Unknown"");
            oss &lt;&lt; "", line: "" &lt;&lt; line;          

            throw runtime_error(oss.str());
        }
    }
    else if((mode &amp; CRYPTO_UNLOCK) == CRYPTO_UNLOCK)
    {
        int rc = pthread_mutex_unlock(&amp;s_locks[idx]);
        int err = errno;
        ASSERT(rc == 0);

        if(!(rc == 0))
        {
            ostringstream oss;
            oss &lt;&lt; ""LockingFnc: unlock failed with error "";
            oss &lt;&lt; err &lt;&lt; "". File: "" &lt;&lt; (file ? file : ""Unknown"");
            oss &lt;&lt; "", line: "" &lt;&lt; line;

            throw runtime_error(oss.str());
        }
    }
}

unsigned long ThreadIdFnc()
{
#if defined(AC_OS_APPLE)
    ASSERT(sizeof(unsigned long) &gt;= sizeof(pid_t));
    return static_cast&lt;unsigned long&gt;(pthread_mach_thread_np(pthread_self()));
#elif defined(AC_OS_STARNIX)
    ASSERT(sizeof(unsigned long) &gt;= sizeof(pid_t));
    return static_cast&lt;unsigned long&gt;(gettid());
#else
# error ""Unsupported platform""
#endif
}
</code></pre>

<p>If you are not using <code>libssl</code>, then forgo the call to <code>SSL_library_init</code>. All <code>libcrypto</code> needs is the call to <code>OpenSSL_add_all_algorithms</code> to initialize.</p>

<hr>

<blockquote>
  <p>The SSL Documentation doesn't mention anything about thread-safety, though.</p>
</blockquote>

<p>Yeah, the docs leave something to be desired at times. I know a bunch of folks are working on improving it through a wiki run by the OpenSSL Foundation. Matt Caswell has done a lot of work in simply documenting the elliptic curve stuff at <a href=""http://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography"" rel=""noreferrer"">http://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography</a>. He's also responsible for the POD files and MAN pages. Keep in mind that Matt did not write any of the code - he's just documenting it for others.</p>

<p>There's a page on initialization, but it does not have the code for the locks. Its on my TODO list. See <a href=""http://wiki.openssl.org/index.php/Library_Initialization"" rel=""noreferrer"">http://wiki.openssl.org/index.php/Library_Initialization</a>.</p>
","3336","<c><multithreading><openssl><ecdsa>","3","5","1","2013-12-04 11:27:48","20318596","0","","","","","2013-11-13 13:50:25",""
"37572306","Verifying ECDSA signature with Bouncy Castle in C#","<p>I have a problem when I try to verify the ECDSA signature in Bouncy Castle in C#. The code is adopted from Java example that I have, so I am 100% sure that the public key and signature are correct. But the C# implementation always returns that the signature is not valid. I checked the curve parameters and they are correct. I tried with DER and ""raw"" signature and again it did not work.</p>

<p>Can anybody spot what I am doing wrong:</p>

<pre><code>namespace TestECDSA
{
    class Program
    {
    static void Main(string[] args)
    {
        byte[] b = new byte[] { 0x2B, 0xA1, 0x41, 0x00 };

        string pubKey = ""044F6D3F294DEA5737F0F46FFEE88A356EED95695DD7E0C27A591E6F6F65962BAF"";
        string signature = ""AAD03D3D38CE53B673CF8F1C016C8D3B67EA98CBCF72627788368C7C54AA2FC4"";

        X9ECParameters curve = SecNamedCurves.GetByName(""secp128r1"");
        ECDomainParameters curveSpec = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H, curve.GetSeed());

        ECPublicKeyParameters key = new ECPublicKeyParameters(""ECDSA"", curve.Curve.DecodePoint(Hex.Decode(pubKey)), curveSpec);

        ISigner signer = SignerUtilities.GetSigner(""NONEwithECDSA"");             

        signer.Init(false, key);

        signer.BlockUpdate(b, 0, b.Length);

        if (signer.VerifySignature(derEncodeSignature(Hex.Decode(signature))))
            System.Console.WriteLine(""Verified Signature"");
        else
            System.Console.WriteLine(""Not Verified Signature"");
    }

    public static byte[] derEncodeSignature(byte[] signature)
    {
        byte[] encoded = new byte[6 + signature.Length];

        byte[] r = RangeSubset(signature, 0, 16);
        byte[] s = RangeSubset(signature, 16, 16);

        encoded[0] = 0x30;
        encoded[1] = 0x24;
        encoded[2] = 0x02;
        encoded[3] = 0x10;

        encoded[4 + r.Length] = 0x02;
        encoded[5 + r.Length] = 0x10;

        Array.Copy(r, 0, encoded, 4, r.Length);
        Array.Copy(s, 0, encoded, 6 + r.Length, r.Length);

        return encoded;
    }

    public static T[] RangeSubset&lt;T&gt;(T[] array, int startIndex, int length)
    {
        T[] subset = new T[length];
        Array.Copy(array, startIndex, subset, 0, length);
        return subset;
    }
}
}
</code></pre>
","<p>dbugger was right. DER encoding is wrong. The code in question should be replaced by:</p>

<pre><code>    private static byte[] derEncodeSignature(byte[] signature)
    {
        byte[] r = signature.RangeSubset(0, (signature.Length / 2));
        byte[] s = signature.RangeSubset((signature.Length / 2), (signature.Length / 2));

        MemoryStream stream = new MemoryStream();
        DerOutputStream der = new DerOutputStream(stream);

        Asn1EncodableVector v = new Asn1EncodableVector();
        v.Add(new DerInteger(new BigInteger(1, r)));
        v.Add(new DerInteger(new BigInteger(1, s)));
        der.WriteObject(new DerSequence(v));

        return stream.ToArray();
    }
</code></pre>
","3282","<c#><encryption><bouncycastle><ecdsa>","2","3","2","2017-09-14 15:09:13","","8","1","","","","2016-06-01 14:59:10",""
"37572306","Verifying ECDSA signature with Bouncy Castle in C#","<p>I have a problem when I try to verify the ECDSA signature in Bouncy Castle in C#. The code is adopted from Java example that I have, so I am 100% sure that the public key and signature are correct. But the C# implementation always returns that the signature is not valid. I checked the curve parameters and they are correct. I tried with DER and ""raw"" signature and again it did not work.</p>

<p>Can anybody spot what I am doing wrong:</p>

<pre><code>namespace TestECDSA
{
    class Program
    {
    static void Main(string[] args)
    {
        byte[] b = new byte[] { 0x2B, 0xA1, 0x41, 0x00 };

        string pubKey = ""044F6D3F294DEA5737F0F46FFEE88A356EED95695DD7E0C27A591E6F6F65962BAF"";
        string signature = ""AAD03D3D38CE53B673CF8F1C016C8D3B67EA98CBCF72627788368C7C54AA2FC4"";

        X9ECParameters curve = SecNamedCurves.GetByName(""secp128r1"");
        ECDomainParameters curveSpec = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H, curve.GetSeed());

        ECPublicKeyParameters key = new ECPublicKeyParameters(""ECDSA"", curve.Curve.DecodePoint(Hex.Decode(pubKey)), curveSpec);

        ISigner signer = SignerUtilities.GetSigner(""NONEwithECDSA"");             

        signer.Init(false, key);

        signer.BlockUpdate(b, 0, b.Length);

        if (signer.VerifySignature(derEncodeSignature(Hex.Decode(signature))))
            System.Console.WriteLine(""Verified Signature"");
        else
            System.Console.WriteLine(""Not Verified Signature"");
    }

    public static byte[] derEncodeSignature(byte[] signature)
    {
        byte[] encoded = new byte[6 + signature.Length];

        byte[] r = RangeSubset(signature, 0, 16);
        byte[] s = RangeSubset(signature, 16, 16);

        encoded[0] = 0x30;
        encoded[1] = 0x24;
        encoded[2] = 0x02;
        encoded[3] = 0x10;

        encoded[4 + r.Length] = 0x02;
        encoded[5 + r.Length] = 0x10;

        Array.Copy(r, 0, encoded, 4, r.Length);
        Array.Copy(s, 0, encoded, 6 + r.Length, r.Length);

        return encoded;
    }

    public static T[] RangeSubset&lt;T&gt;(T[] array, int startIndex, int length)
    {
        T[] subset = new T[length];
        Array.Copy(array, startIndex, subset, 0, length);
        return subset;
    }
}
}
</code></pre>
","<p>Instead of DER-encoding the signature by yourself, you can use signer.GenerateSignature() like so:</p>

<pre><code>        var signerAlgorithm = ""SHA256withECDSA"";

        ISigner signer = SignerUtilities.GetSigner(signerAlgorithm);
        signer.Init(true, privateSigningKey);
        signer.BlockUpdate(data, 0, data.Length);
        byte[] signature = signer.GenerateSignature();

        return signature;
</code></pre>
","3282","<c#><encryption><bouncycastle><ecdsa>","2","4","2","2017-09-14 15:09:13","","8","1","","","","2016-06-01 14:59:10",""
"24467612","ECDSA Signature in Javacard","<p>I'm implementing the signing code using ECDSA in Javacard.</p>

<p>My code outputs 0x0003(NO_SUCH_ALGORITHM) in exception part which means this card does not support the algorithm. I don't understand that because my vendor told me that it supports ECC. I concluded I don't know how to sign with ECDSA and I want to know that.</p>

<p>Here is my full source code</p>

<pre><code>package MyECDSA;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class MyECDSA extends Applet{

private byte[] PLAINTEXT ;
private ECPrivateKey            objECDSAPriKey=null;    // Object for ECDSA Private Key
private ECPublicKey             objECDSAPubKey=null;    // Object for ECDSA Public Key
private KeyPair                 objECDSAKeyPair=null;   // Object for ECDSA Key Pair
private Signature               objECDSASign=null;      // Object for ECDSA Signature

final static short  BAS     =  0;

public static void install(byte[] bArray, short bOffset, byte bLength){
    new MyECDSA(bArray, bOffset, bLength);
}

private MyECDSA(byte bArray[], short bOffset, byte bLength){    

    PLAINTEXT       = new byte[0x100] ;         // Data file

    Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

    register();
}

//======================================================================================
public void process(APDU apdu){
    byte buf[] = apdu.getBuffer();

    switch(buf[1])
    {
        //--------------------------------------------------------
        case (byte)0xA4:                    break;  

        case (byte)0x46:
            // Create ECDSA Keys and Pair
            try {
                // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Here is the problem &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);
                //objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_F2M, KeyBuilder.LENGTH_EC_F2M_193);          
            }
            catch(CryptoException c)
            {    
                short reason = c.getReason();   
                ISOException.throwIt(reason);
            }
            ISOException.throwIt((short)0x9999);        // for check

            // Generate Key pair
            objECDSAKeyPair.genKeyPair();

            // Create Signature Object
            objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

            objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
            objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();  

        break;

        case (byte)0x2E:                        
            short       Le              = apdu.setOutgoing();   
            short   sSignLen=0 ;

            // Init with Private Key
            objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);

            // Sign Data
            sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

            apdu.setOutgoingLength(sSignLen);
            apdu.sendBytes(BAS, sSignLen);

        break;      
        //--------------------------------------------------------
        default:
            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
    }

    return; 
}

}
</code></pre>

<p>And APDU Command is as follows</p>

<pre><code>[  Card  ] &lt;==  00A4040007D4106509900090
[  Card  ] ==&gt;  9000

[  Card  ] &lt;==  0046000000
[  Card  ] ==&gt;  0003
</code></pre>

<p>My Development Environment is as follows.</p>

<ul>
<li>OS : Windows 7</li>
<li>JCDK Ver 2.2.1</li>
<li>JDK Ver 1.4.2</li>
<li>Chip : NXP</li>
<li>Terminal : ACR122 NFC Contactless Smart Card Reader</li>
</ul>

<hr>

<p>I've changed my code to set domain parameters. But the card still outputs the same result(0x0003). Here is my full source code.</p>

<pre><code>package MyECDSA;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class MyECDSA extends Applet{

private byte[] PLAINTEXT ;
private ECPrivateKey            objECDSAPriKey=null;    // Object for ECDSA Private Key
private ECPublicKey             objECDSAPubKey=null;    // Object for ECDSA Public Key
private KeyPair                 objECDSAKeyPair=null;   // Object for ECDSA Key Pair
private Signature               objECDSASign=null;      // Object for ECDSA Signature

final static short  BAS     =  0;

final static byte[] SecP192r1_P = {     // 24
    (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
final static byte[] SecP192r1_A = {     // 24
    (byte)0xFC,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
final static byte[] SecP192r1_B = {     // 24
  (byte)0xB1,(byte)0xB9,(byte)0x46,(byte)0xC1,(byte)0xEC,(byte)0xDE,(byte)0xB8,(byte)0xFE,
  (byte)0x49,(byte)0x30,(byte)0x24,(byte)0x72,(byte)0xAB,(byte)0xE9,(byte)0xA7,(byte)0x0F,
  (byte)0xE7,(byte)0x80,(byte)0x9C,(byte)0xE5,(byte)0x19,(byte)0x05,(byte)0x21,(byte)0x64};
final static byte[] SecP192r1_S = {     // 20
  (byte)0xD5,(byte)0x96,(byte)0x21,(byte)0xE1,(byte)0xEA,(byte)0x20,(byte)0x81,(byte)0xD3,
  (byte)0x28,(byte)0x95,(byte)0x57,(byte)0xED,(byte)0x64,(byte)0x2F,(byte)0x42,(byte)0xC8,
  (byte)0x6F,(byte)0xAE,(byte)0x45,(byte)0x30};
final static byte[] SecP192r1_G = {     // 25
  (byte)0x12,(byte)0x10,(byte)0xFF,(byte)0x82,(byte)0xFD,(byte)0x0A,(byte)0xFF,(byte)0xF4,
  (byte)0x00,(byte)0x88,(byte)0xA1,(byte)0x43,(byte)0xEB,(byte)0x20,(byte)0xBF,(byte)0x7C,
  (byte)0xF6,(byte)0x90,(byte)0x30,(byte)0xB0,(byte)0x0E,(byte)0xA8,(byte)0x8D,(byte)0x18,(byte)0x03};
final static byte[] SecP192r1_N = {     // 24
  (byte)0x31,(byte)0x28,(byte)0xD2,(byte)0xB4,(byte)0xB1,(byte)0xC9,(byte)0x6B,(byte)0x14,
  (byte)0x36,(byte)0xF8,(byte)0xDE,(byte)0x99,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
  (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
final static short  SecP192r1_H =  1;

//======================================================================================
public static void install(byte[] bArray, short bOffset, byte bLength){
    new MyECDSA(bArray, bOffset, bLength);
}

private MyECDSA(byte bArray[], short bOffset, byte bLength){    

    PLAINTEXT       = new byte[0x100] ;         // Data file

    Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

    register();
}

//======================================================================================
public void process(APDU apdu){
    byte buf[] = apdu.getBuffer();

    switch(buf[1])
    {
        //--------------------------------------------------------
        case (byte)0xA4:                    break;  

        case (byte)0x46:

            // Create ECDSA Keys and Pair
            try {
        // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Here is the problem &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                objECDSAPriKey = (ECPrivateKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PRIVATE, KeyBuilder.LENGTH_EC_FP_192, false);
                ISOException.throwIt((short)0x8888);        // for check
                objECDSAPubKey = (ECPublicKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PUBLIC,  KeyBuilder.LENGTH_EC_FP_192, false);

                // set EC Domain Parameters
                objECDSAPubKey.setFieldFP(SecP192r1_P, BAS, (short)24);
                objECDSAPubKey.setA(SecP192r1_A, BAS, (short)24);
                objECDSAPubKey.setB(SecP192r1_B, BAS, (short)24);
                objECDSAPubKey.setG(SecP192r1_G, BAS, (short)25);
                objECDSAPubKey.setK(SecP192r1_H);
                objECDSAPubKey.setR(SecP192r1_N, BAS, (short)24);

                objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);
            }
          catch(CryptoException c)
          {    
            short reason = c.getReason();   
            ISOException.throwIt(reason);       // for check
          }

            // On-Card Key Generation Process
            objECDSAKeyPair.genKeyPair();

            // Obtain Key References
            objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
            objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();  

            // Create Signature Object
            objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

        break;

        case (byte)0x2E:                        
            short       Le              = apdu.setOutgoing();   
            short   sSignLen=0 ;

            // Init with Private Key
            objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);

            // Sign Data
            sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

            apdu.setOutgoingLength(sSignLen);
            apdu.sendBytes(BAS, sSignLen);

        break;      
        //--------------------------------------------------------
        default:
            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
    }

    return; 
}

}
</code></pre>
","<p>There are no default EC domain parameters in Java Card. It is required to create the <code>KeyPair</code> using an <code>ECPublicKey</code> and a <code>ECPrivateKey</code> for which the domain parameters are set (so the point W and secret S may be kept empty). After that it is possible to call <code>genKeyPair()</code>, at least if the card has support for F(2m) or F(p) Elliptic Curve cryptography and the key size that is specified.</p>

<hr>

<p>ADDED</p>

<p>Note that NXP JCOP chips may require these parameters set for the public <em>and the private</em> key. The parameters should have either the key size (for separate values) or an <em>uncompressed</em> Elliptic Curve point. The value of G in the question seems to be a compressed point. Only the cofactor (for <code>setH</code>) should just have the value 1.</p>

<p>Note that only the chips with an asymmetric coprocessor may support elliptic curves; not all cards are created / configured equally. Contact your vendor for details.</p>
","3282","<java><javacard><ecdsa>","3","3","2","2016-04-12 10:54:43","24471491","4","","-1","","2016-04-12 10:54:43","2014-06-28 14:07:22",""
"24467612","ECDSA Signature in Javacard","<p>I'm implementing the signing code using ECDSA in Javacard.</p>

<p>My code outputs 0x0003(NO_SUCH_ALGORITHM) in exception part which means this card does not support the algorithm. I don't understand that because my vendor told me that it supports ECC. I concluded I don't know how to sign with ECDSA and I want to know that.</p>

<p>Here is my full source code</p>

<pre><code>package MyECDSA;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class MyECDSA extends Applet{

private byte[] PLAINTEXT ;
private ECPrivateKey            objECDSAPriKey=null;    // Object for ECDSA Private Key
private ECPublicKey             objECDSAPubKey=null;    // Object for ECDSA Public Key
private KeyPair                 objECDSAKeyPair=null;   // Object for ECDSA Key Pair
private Signature               objECDSASign=null;      // Object for ECDSA Signature

final static short  BAS     =  0;

public static void install(byte[] bArray, short bOffset, byte bLength){
    new MyECDSA(bArray, bOffset, bLength);
}

private MyECDSA(byte bArray[], short bOffset, byte bLength){    

    PLAINTEXT       = new byte[0x100] ;         // Data file

    Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

    register();
}

//======================================================================================
public void process(APDU apdu){
    byte buf[] = apdu.getBuffer();

    switch(buf[1])
    {
        //--------------------------------------------------------
        case (byte)0xA4:                    break;  

        case (byte)0x46:
            // Create ECDSA Keys and Pair
            try {
                // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Here is the problem &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);
                //objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_F2M, KeyBuilder.LENGTH_EC_F2M_193);          
            }
            catch(CryptoException c)
            {    
                short reason = c.getReason();   
                ISOException.throwIt(reason);
            }
            ISOException.throwIt((short)0x9999);        // for check

            // Generate Key pair
            objECDSAKeyPair.genKeyPair();

            // Create Signature Object
            objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

            objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
            objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();  

        break;

        case (byte)0x2E:                        
            short       Le              = apdu.setOutgoing();   
            short   sSignLen=0 ;

            // Init with Private Key
            objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);

            // Sign Data
            sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

            apdu.setOutgoingLength(sSignLen);
            apdu.sendBytes(BAS, sSignLen);

        break;      
        //--------------------------------------------------------
        default:
            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
    }

    return; 
}

}
</code></pre>

<p>And APDU Command is as follows</p>

<pre><code>[  Card  ] &lt;==  00A4040007D4106509900090
[  Card  ] ==&gt;  9000

[  Card  ] &lt;==  0046000000
[  Card  ] ==&gt;  0003
</code></pre>

<p>My Development Environment is as follows.</p>

<ul>
<li>OS : Windows 7</li>
<li>JCDK Ver 2.2.1</li>
<li>JDK Ver 1.4.2</li>
<li>Chip : NXP</li>
<li>Terminal : ACR122 NFC Contactless Smart Card Reader</li>
</ul>

<hr>

<p>I've changed my code to set domain parameters. But the card still outputs the same result(0x0003). Here is my full source code.</p>

<pre><code>package MyECDSA;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class MyECDSA extends Applet{

private byte[] PLAINTEXT ;
private ECPrivateKey            objECDSAPriKey=null;    // Object for ECDSA Private Key
private ECPublicKey             objECDSAPubKey=null;    // Object for ECDSA Public Key
private KeyPair                 objECDSAKeyPair=null;   // Object for ECDSA Key Pair
private Signature               objECDSASign=null;      // Object for ECDSA Signature

final static short  BAS     =  0;

final static byte[] SecP192r1_P = {     // 24
    (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
final static byte[] SecP192r1_A = {     // 24
    (byte)0xFC,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
    (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
final static byte[] SecP192r1_B = {     // 24
  (byte)0xB1,(byte)0xB9,(byte)0x46,(byte)0xC1,(byte)0xEC,(byte)0xDE,(byte)0xB8,(byte)0xFE,
  (byte)0x49,(byte)0x30,(byte)0x24,(byte)0x72,(byte)0xAB,(byte)0xE9,(byte)0xA7,(byte)0x0F,
  (byte)0xE7,(byte)0x80,(byte)0x9C,(byte)0xE5,(byte)0x19,(byte)0x05,(byte)0x21,(byte)0x64};
final static byte[] SecP192r1_S = {     // 20
  (byte)0xD5,(byte)0x96,(byte)0x21,(byte)0xE1,(byte)0xEA,(byte)0x20,(byte)0x81,(byte)0xD3,
  (byte)0x28,(byte)0x95,(byte)0x57,(byte)0xED,(byte)0x64,(byte)0x2F,(byte)0x42,(byte)0xC8,
  (byte)0x6F,(byte)0xAE,(byte)0x45,(byte)0x30};
final static byte[] SecP192r1_G = {     // 25
  (byte)0x12,(byte)0x10,(byte)0xFF,(byte)0x82,(byte)0xFD,(byte)0x0A,(byte)0xFF,(byte)0xF4,
  (byte)0x00,(byte)0x88,(byte)0xA1,(byte)0x43,(byte)0xEB,(byte)0x20,(byte)0xBF,(byte)0x7C,
  (byte)0xF6,(byte)0x90,(byte)0x30,(byte)0xB0,(byte)0x0E,(byte)0xA8,(byte)0x8D,(byte)0x18,(byte)0x03};
final static byte[] SecP192r1_N = {     // 24
  (byte)0x31,(byte)0x28,(byte)0xD2,(byte)0xB4,(byte)0xB1,(byte)0xC9,(byte)0x6B,(byte)0x14,
  (byte)0x36,(byte)0xF8,(byte)0xDE,(byte)0x99,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
  (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
final static short  SecP192r1_H =  1;

//======================================================================================
public static void install(byte[] bArray, short bOffset, byte bLength){
    new MyECDSA(bArray, bOffset, bLength);
}

private MyECDSA(byte bArray[], short bOffset, byte bLength){    

    PLAINTEXT       = new byte[0x100] ;         // Data file

    Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

    register();
}

//======================================================================================
public void process(APDU apdu){
    byte buf[] = apdu.getBuffer();

    switch(buf[1])
    {
        //--------------------------------------------------------
        case (byte)0xA4:                    break;  

        case (byte)0x46:

            // Create ECDSA Keys and Pair
            try {
        // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Here is the problem &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                objECDSAPriKey = (ECPrivateKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PRIVATE, KeyBuilder.LENGTH_EC_FP_192, false);
                ISOException.throwIt((short)0x8888);        // for check
                objECDSAPubKey = (ECPublicKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PUBLIC,  KeyBuilder.LENGTH_EC_FP_192, false);

                // set EC Domain Parameters
                objECDSAPubKey.setFieldFP(SecP192r1_P, BAS, (short)24);
                objECDSAPubKey.setA(SecP192r1_A, BAS, (short)24);
                objECDSAPubKey.setB(SecP192r1_B, BAS, (short)24);
                objECDSAPubKey.setG(SecP192r1_G, BAS, (short)25);
                objECDSAPubKey.setK(SecP192r1_H);
                objECDSAPubKey.setR(SecP192r1_N, BAS, (short)24);

                objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);
            }
          catch(CryptoException c)
          {    
            short reason = c.getReason();   
            ISOException.throwIt(reason);       // for check
          }

            // On-Card Key Generation Process
            objECDSAKeyPair.genKeyPair();

            // Obtain Key References
            objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
            objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();  

            // Create Signature Object
            objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

        break;

        case (byte)0x2E:                        
            short       Le              = apdu.setOutgoing();   
            short   sSignLen=0 ;

            // Init with Private Key
            objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);

            // Sign Data
            sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

            apdu.setOutgoingLength(sSignLen);
            apdu.sendBytes(BAS, sSignLen);

        break;      
        //--------------------------------------------------------
        default:
            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
    }

    return; 
}

}
</code></pre>
","<p>If an attempt to create instance of the particular algorithm (KeyPair.ALG_EC_FP &amp; KeyBuilder.LENGTH_EC_FP_192 in your case) fails with NO_SUCH_ALGORITHM, it is either not supported by your card completely (e.g., old hardware) or disabled. </p>

<p>Project <a href=""http://www.fi.muni.cz/~xsvenda/jcsupport.html"" rel=""nofollow"">JCAlgTester</a> allows you to obtain complete list of the supported algorithms for your particular card. Database of results for multiple different cards is also available (but is better to check your particular card directly by uploading JCAlgTester applet). </p>
","3282","<java><javacard><ecdsa>","3","2","2","2016-04-12 10:54:43","24471491","4","","-1","","2016-04-12 10:54:43","2014-06-28 14:07:22",""
"43629265","Deriving an ECDSA uncompressed public key from a compressed one","<p>I am currently trying to derive a Bitcoin uncompressed ECDSA public key from a compressed one.</p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""noreferrer"">link on the Bitcoin wiki</a>, it is possible to do so... But how?</p>

<p>To give you more details: as of now I have compressed keys (33-bytes-long) gathered on the bitcoin network.</p>

<p>They are of the following format: &lt;1-byte-long prefix>&lt;32-bytes-long X>.
From there, I would like to obtain an uncompressed key (65-bytes-long) whose format is:
&lt;1-byte-long prefix>&lt;32-bytes-long X>&lt;32-bytes-long Y></p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Secp256k1"" rel=""noreferrer"">other link on the Bitcoin wiki</a>, it should be as easy as solving the equation:</p>

<p>Y^2 = X^3 + 7 </p>

<p>However, I cannot seem to get there. My value for Y is simply far-off. Here is my code (the value for the public key come from the <a href=""http://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses"" rel=""noreferrer"">Bitcoin wiki example</a>):</p>

<pre><code>import binascii
from decimal import *

expected_uncompressed_key_hex = '0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
expected_y_hex = expected_uncompressed_key_hex[-64:]
expected_y_dec = int(expected_y_hex, 16)
x_hex = expected_uncompressed_key_hex[2:66]
if expected_y_dec % 2 == 0:
    prefix = ""02""
else:
    prefix = ""03""

artificial_compressed_key = prefix + x_hex

getcontext().prec = 500
test_dec = Decimal(int(x_hex, 16))
y_square_dec = test_dec**3 + 7
if prefix == ""02"":
    y_dec = - Decimal(y_square_dec).sqrt()
else:
    y_dec = Decimal(y_square_dec).sqrt()

computed_y_hex = hex(int(y_dec))
computed_uncompressed_key = ""04"" + x + computed_y_hex
</code></pre>

<p>For information, my outputs are:</p>

<pre><code>computed_y_hex = '0X2D29684BD207BF6D809F7D0EB78E4FD61C3C6700E88AB100D1075EFA8F8FD893080F35E6C7AC2E2214F8F4D088342951'
expected_y_hex = '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
</code></pre>

<p>Thank you for your help!</p>
","<p>The field of the elliptic curve is not over the field of real numbers. It's over a finite field modulo some prime. </p>

<p>For Secp256k1 the prime p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1.</p>

<p>Thus: y^2= (x^3) + 7 (mod p)</p>

<p>There's no direct way to solve the equation, you would need to use Cipolla's algorithm: <a href=""https://en.wikipedia.org/wiki/Cipolla%27s_algorithm"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Cipolla%27s_algorithm</a></p>
","2973","<python><bitcoin><public-key><ecdsa>","9","3","4","2019-03-31 16:39:03","43654055","1","1","","","","2017-04-26 08:49:48",""
"43629265","Deriving an ECDSA uncompressed public key from a compressed one","<p>I am currently trying to derive a Bitcoin uncompressed ECDSA public key from a compressed one.</p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""noreferrer"">link on the Bitcoin wiki</a>, it is possible to do so... But how?</p>

<p>To give you more details: as of now I have compressed keys (33-bytes-long) gathered on the bitcoin network.</p>

<p>They are of the following format: &lt;1-byte-long prefix>&lt;32-bytes-long X>.
From there, I would like to obtain an uncompressed key (65-bytes-long) whose format is:
&lt;1-byte-long prefix>&lt;32-bytes-long X>&lt;32-bytes-long Y></p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Secp256k1"" rel=""noreferrer"">other link on the Bitcoin wiki</a>, it should be as easy as solving the equation:</p>

<p>Y^2 = X^3 + 7 </p>

<p>However, I cannot seem to get there. My value for Y is simply far-off. Here is my code (the value for the public key come from the <a href=""http://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses"" rel=""noreferrer"">Bitcoin wiki example</a>):</p>

<pre><code>import binascii
from decimal import *

expected_uncompressed_key_hex = '0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
expected_y_hex = expected_uncompressed_key_hex[-64:]
expected_y_dec = int(expected_y_hex, 16)
x_hex = expected_uncompressed_key_hex[2:66]
if expected_y_dec % 2 == 0:
    prefix = ""02""
else:
    prefix = ""03""

artificial_compressed_key = prefix + x_hex

getcontext().prec = 500
test_dec = Decimal(int(x_hex, 16))
y_square_dec = test_dec**3 + 7
if prefix == ""02"":
    y_dec = - Decimal(y_square_dec).sqrt()
else:
    y_dec = Decimal(y_square_dec).sqrt()

computed_y_hex = hex(int(y_dec))
computed_uncompressed_key = ""04"" + x + computed_y_hex
</code></pre>

<p>For information, my outputs are:</p>

<pre><code>computed_y_hex = '0X2D29684BD207BF6D809F7D0EB78E4FD61C3C6700E88AB100D1075EFA8F8FD893080F35E6C7AC2E2214F8F4D088342951'
expected_y_hex = '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
</code></pre>

<p>Thank you for your help!</p>
","<p>You need to calculate in the field <img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=%5Cmathbb%7BZ%7D_p"" alt=""Z_p"">, which mostly means that you have to reduce your number to the remainder after dividing with p after each calculation. Calculating this is called taking the modulo and is written as <code>% p</code> in python.</p>

<p>Exponentiating in this field can be done more effectively than the naive way of just multiplying and reducing many times. This is called modular exponentiation.  Python's built-in exponentation function pow(n,e,p) can take care of this.</p>

<p>The remaining problem is to find the square root. Luckily secp256k1 is chosen in a special way (<img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=p%5Cequiv3%5Cpmod+4"" alt=""p%4=3"">), so that taking square roots is easy: A square root of x is <img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=x%5E%7B%5Cfrac%7Bp%2B1%7D%7B4%7D%7D+%5Cpmod+p"" alt=""x^((p+1)/4)%p"">.</p>

<p>So a simplified version of your code becomes:</p>

<pre><code>import binascii

p_hex = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F'
p = int(p_hex, 16)
compressed_key_hex = '0250863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352'
x_hex = compressed_key_hex[2:66]
x = int(x_hex, 16)
prefix = compressed_key_hex[0:2]

y_square = (pow(x, 3, p)  + 7) % p
y_square_square_root = pow(y_square, (p+1)/4, p)
if (prefix == ""02"" and y_square_square_root &amp; 1) or (prefix == ""03"" and not y_square_square_root &amp; 1):
    y = (-y_square_square_root) % p
else:
    y = y_square_square_root

computed_y_hex = format(y, '064x')
computed_uncompressed_key = ""04"" + x_hex + computed_y_hex

print computed_uncompressed_key
</code></pre>
","2973","<python><bitcoin><public-key><ecdsa>","9","6","4","2019-03-31 16:39:03","43654055","1","1","","","","2017-04-26 08:49:48",""
"43629265","Deriving an ECDSA uncompressed public key from a compressed one","<p>I am currently trying to derive a Bitcoin uncompressed ECDSA public key from a compressed one.</p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""noreferrer"">link on the Bitcoin wiki</a>, it is possible to do so... But how?</p>

<p>To give you more details: as of now I have compressed keys (33-bytes-long) gathered on the bitcoin network.</p>

<p>They are of the following format: &lt;1-byte-long prefix>&lt;32-bytes-long X>.
From there, I would like to obtain an uncompressed key (65-bytes-long) whose format is:
&lt;1-byte-long prefix>&lt;32-bytes-long X>&lt;32-bytes-long Y></p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Secp256k1"" rel=""noreferrer"">other link on the Bitcoin wiki</a>, it should be as easy as solving the equation:</p>

<p>Y^2 = X^3 + 7 </p>

<p>However, I cannot seem to get there. My value for Y is simply far-off. Here is my code (the value for the public key come from the <a href=""http://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses"" rel=""noreferrer"">Bitcoin wiki example</a>):</p>

<pre><code>import binascii
from decimal import *

expected_uncompressed_key_hex = '0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
expected_y_hex = expected_uncompressed_key_hex[-64:]
expected_y_dec = int(expected_y_hex, 16)
x_hex = expected_uncompressed_key_hex[2:66]
if expected_y_dec % 2 == 0:
    prefix = ""02""
else:
    prefix = ""03""

artificial_compressed_key = prefix + x_hex

getcontext().prec = 500
test_dec = Decimal(int(x_hex, 16))
y_square_dec = test_dec**3 + 7
if prefix == ""02"":
    y_dec = - Decimal(y_square_dec).sqrt()
else:
    y_dec = Decimal(y_square_dec).sqrt()

computed_y_hex = hex(int(y_dec))
computed_uncompressed_key = ""04"" + x + computed_y_hex
</code></pre>

<p>For information, my outputs are:</p>

<pre><code>computed_y_hex = '0X2D29684BD207BF6D809F7D0EB78E4FD61C3C6700E88AB100D1075EFA8F8FD893080F35E6C7AC2E2214F8F4D088342951'
expected_y_hex = '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
</code></pre>

<p>Thank you for your help!</p>
","<p>Here a sample code without any 3rd party python libs:</p>

<pre><code>def pow_mod(x, y, z):
    ""Calculate (x ** y) % z efficiently.""
    number = 1
    while y:
        if y &amp; 1:
            number = number * x % z
        y &gt;&gt;= 1
        x = x * x % z
    return number

# prime p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f

# bitcoin's compressed public key of private key 55255657523dd1c65a77d3cb53fcd050bf7fc2c11bb0bb6edabdbd41ea51f641
compressed_key = '0314fc03b8df87cd7b872996810db8458d61da8448e531569c8517b469a119d267'

y_parity = int(compressed_key[:2]) - 2
x = int(compressed_key[2:], 16)

a = (pow_mod(x, 3, p) + 7) % p
y = pow_mod(a, (p+1)//4, p)

if y % 2 != y_parity:
    y = -y % p

uncompressed_key = '04{:x}{:x}'.format(x, y)
print(uncompressed_key) 
# should get 0414fc03b8df87cd7b872996810db8458d61da8448e531569c8517b469a119d267be5645686309c6e6736dbd93940707cc9143d3cf29f1b877ff340e2cb2d259cf
</code></pre>

<p>refer to bitcoin talk: <a href=""https://bitcointalk.org/index.php?topic=644919.0"" rel=""nofollow noreferrer"">https://bitcointalk.org/index.php?topic=644919.0</a></p>
","2973","<python><bitcoin><public-key><ecdsa>","9","2","4","2019-03-31 16:39:03","43654055","1","1","","","","2017-04-26 08:49:48",""
"43629265","Deriving an ECDSA uncompressed public key from a compressed one","<p>I am currently trying to derive a Bitcoin uncompressed ECDSA public key from a compressed one.</p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""noreferrer"">link on the Bitcoin wiki</a>, it is possible to do so... But how?</p>

<p>To give you more details: as of now I have compressed keys (33-bytes-long) gathered on the bitcoin network.</p>

<p>They are of the following format: &lt;1-byte-long prefix>&lt;32-bytes-long X>.
From there, I would like to obtain an uncompressed key (65-bytes-long) whose format is:
&lt;1-byte-long prefix>&lt;32-bytes-long X>&lt;32-bytes-long Y></p>

<p>According to this <a href=""http://en.bitcoin.it/wiki/Secp256k1"" rel=""noreferrer"">other link on the Bitcoin wiki</a>, it should be as easy as solving the equation:</p>

<p>Y^2 = X^3 + 7 </p>

<p>However, I cannot seem to get there. My value for Y is simply far-off. Here is my code (the value for the public key come from the <a href=""http://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses"" rel=""noreferrer"">Bitcoin wiki example</a>):</p>

<pre><code>import binascii
from decimal import *

expected_uncompressed_key_hex = '0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
expected_y_hex = expected_uncompressed_key_hex[-64:]
expected_y_dec = int(expected_y_hex, 16)
x_hex = expected_uncompressed_key_hex[2:66]
if expected_y_dec % 2 == 0:
    prefix = ""02""
else:
    prefix = ""03""

artificial_compressed_key = prefix + x_hex

getcontext().prec = 500
test_dec = Decimal(int(x_hex, 16))
y_square_dec = test_dec**3 + 7
if prefix == ""02"":
    y_dec = - Decimal(y_square_dec).sqrt()
else:
    y_dec = Decimal(y_square_dec).sqrt()

computed_y_hex = hex(int(y_dec))
computed_uncompressed_key = ""04"" + x + computed_y_hex
</code></pre>

<p>For information, my outputs are:</p>

<pre><code>computed_y_hex = '0X2D29684BD207BF6D809F7D0EB78E4FD61C3C6700E88AB100D1075EFA8F8FD893080F35E6C7AC2E2214F8F4D088342951'
expected_y_hex = '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'
</code></pre>

<p>Thank you for your help!</p>
","<p>I know that this question has been answered and I actually benefited from this answer, so thank you. The problem is that I found these answers 3 times while looking for the same solution in C# and I don't really code in python :). So for anybody trying to solve this here is a C# solution, have fun! :) (It uses BouncyCastle Library).</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using MoreLinq;
using NBitcoin;
using Org.BouncyCastle.Asn1.X9;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.Math.EC;

namespace BitcoinPublicKeyDecompression
{
    public class Program
    {
        public static void Main()
        {
            const string cPubKey = ""0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352"";
            var uPubKey = cPubKey.ToHexByteArray().BitcoinDecompressPublicKey().ToHexString();
            var expectedUPubKey = new PubKey(cPubKey).Decompress().ToString();

            Console.WriteLine($""Public Key:\n\n{cPubKey}\n\nhas been {(uPubKey == expectedUPubKey ? ""correctly"" : ""incorrectly"")} decompressed to:\n\n{uPubKey}"");

            Console.WriteLine(""\nPress any key to quit..."");
            Console.ReadKey();
        }
    }

    public static class Extensions
    {
        public static readonly byte[] EmptyByteArray = new byte[0];

        public static byte[] BitcoinDecompressPublicKey(this byte[] bPubC)
        {
            var ecPubKey = bPubC.BitcoinCompressedPublicKeyToECPublicKey();
            return ecPubKey.ToBitcoinUncompressedPublicKey();
        }

        public static ECPublicKeyParameters BitcoinCompressedPublicKeyToECPublicKey(this byte[] bPubC)
        {
            var pubKey = bPubC.Skip(1).ToArray();

            var curve = ECNamedCurveTable.GetByName(""secp256k1"");
            var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H, curve.GetSeed());

            var yParity = new BigInteger(bPubC.Take(1).ToArray()).Subtract(BigInteger.Two);
            var x = new BigInteger(1, pubKey);
            var p = ((FpCurve)curve.Curve).Q;
            var a = x.ModPow(new BigInteger(""3""), p).Add(new BigInteger(""7"")).Mod(p);
            var y = a.ModPow(p.Add(BigInteger.One).FloorDivide(new BigInteger(""4"")), p);

            if (!y.Mod(BigInteger.Two).Equals(yParity))
                y = y.Negate().Mod(p);

            var q = curve.Curve.CreatePoint(x, y);
            return new ECPublicKeyParameters(q, domainParams);
        }

        public static byte[] ToBitcoinUncompressedPublicKey(this AsymmetricKeyParameter ecPublicKey)
        {
            var publicKey = ((ECPublicKeyParameters)ecPublicKey).Q;
            var xs = publicKey.AffineXCoord.ToBigInteger().ToByteArrayUnsigned().PadStart(32);
            var ys = publicKey.AffineYCoord.ToBigInteger().ToByteArrayUnsigned().PadStart(32);
            return new byte[] { 0x04 }.ConcatMany(xs, ys).ToArray();
        }

        public static BigInteger FloorDivide(this BigInteger a, BigInteger b)
        {
            if (a.CompareTo(BigInteger.Zero) &gt; 0 ^ b.CompareTo(BigInteger.Zero) &lt; 0 &amp;&amp; !a.Mod(b).Equals(BigInteger.Zero))
                return a.Divide(b).Subtract(BigInteger.One);

            return a.Divide(b);
        }

        public static byte[] ToHexByteArray(this string str)
        {
            byte[] bytes;
            if (string.IsNullOrEmpty(str))
                bytes = EmptyByteArray;
            else
            {
                var string_length = str.Length;
                var character_index = str.StartsWith(""0x"", StringComparison.Ordinal) ? 2 : 0;
                var number_of_characters = string_length - character_index;
                var add_leading_zero = false;

                if (0 != number_of_characters % 2)
                {
                    add_leading_zero = true;
                    number_of_characters += 1;
                }

                bytes = new byte[number_of_characters / 2];

                var write_index = 0;
                if (add_leading_zero)
                {
                    bytes[write_index++] = CharacterToByte(str[character_index], character_index);
                    character_index += 1;
                }

                for (var read_index = character_index; read_index &lt; str.Length; read_index += 2)
                {
                    var upper = CharacterToByte(str[read_index], read_index, 4);
                    var lower = CharacterToByte(str[read_index + 1], read_index + 1);

                    bytes[write_index++] = (byte)(upper | lower);
                }
            }

            return bytes;
        }

        public static byte CharacterToByte(char character, int index, int shift = 0)
        {
            var value = (byte)character;
            if (0x40 &lt; value &amp;&amp; 0x47 &gt; value || 0x60 &lt; value &amp;&amp; 0x67 &gt; value)
            {
                if (0x40 != (0x40 &amp; value))
                    return value;
                if (0x20 == (0x20 &amp; value))
                    value = (byte)((value + 0xA - 0x61) &lt;&lt; shift);
                else
                    value = (byte)((value + 0xA - 0x41) &lt;&lt; shift);
            }
            else if (0x29 &lt; value &amp;&amp; 0x40 &gt; value)
                value = (byte)((value - 0x30) &lt;&lt; shift);
            else
                throw new InvalidOperationException($""Character '{character}' at index '{index}' is not valid alphanumeric character."");

            return value;
        }

        public static string ToHexString(this byte[] value, bool prefix = false)
        {
            var strPrex = prefix ? ""0x"" : """";
            return strPrex + string.Concat(value.Select(b =&gt; b.ToString(""x2"")).ToArray());
        }

        public static IEnumerable&lt;T&gt; ConcatMany&lt;T&gt;(this IEnumerable&lt;T&gt; enumerable, params IEnumerable&lt;T&gt;[] enums)
        {
            return enumerable.Concat(enums.SelectMany(x =&gt; x));
        }
    } 
}
</code></pre>

<p>Result:</p>

<p><a href=""https://i.stack.imgur.com/AEQ0Y.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AEQ0Y.png"" alt=""enter image description here""></a></p>
","2973","<python><bitcoin><public-key><ecdsa>","9","0","4","2019-03-31 16:39:03","43654055","1","1","","","","2017-04-26 08:49:48",""
"36624105","generate certificate using ECDSA in c#","<p>I'm trying to generate (self-signed) certificate with private key using ECDSA.
The goals is to get ""the same"" (pkcs12) certificate as when using openssl:</p>

<pre><code>openssl ecparam -genkey -name secp256r1 -out mykey.key
openssl req -new -key mykey.key -out myreq.csr
openssl req -x509 -days 7 -key mykey.key -in myreq.csr -out mycert.crt
openssl pkcs12 -export -out mycert.pfx -inkey mykey.key -in mycert.crt
</code></pre>

<p>I already use BouncyCastle to help me with creating RSA-based certificate(s), so next steps more or less follow the way I use to create RSA certs.</p>

<p>(note that <code>BC</code> prefix is used for classes from BouncyCastle, <code>MS</code> for .NET classes)</p>

<p><strong>1</strong> generate key pair: private and public keys</p>

<pre><code>BC.IAsymmetricCipherKeyPairGenerator bcKpGen = BC.GeneratorUtilities.GetKeyPairGenerator(""ECDSA"");
bcKpGen.Init(new BC.ECKeyGenerationParameters(BC.SecObjectIdentifiers.SecP256r1, new BC.SecureRandom()));
BC.AsymmetricCipherKeyPair bcSubjKeys = bcKpGen.GenerateKeyPair();
</code></pre>

<p><strong>2</strong> use private key to sign public key with some additional data (subject, validity period etc)</p>

<pre><code>BC.X509V3CertificateGenerator bcXgen = new BC.X509V3CertificateGenerator();
// .. set subject, validity period etc
bcXgen.SetPublicKey(bcSubjKeys.Public);
BC.ISignatureFactory bcSigFac = new BC.Asn1SignatureFactory(""SHA256WITHECDSA"", bcSubjKeys.Private);
BC.X509Certificate bcCert = bcXgen.Generate(bcSigFac);
</code></pre>

<p><strong>3</strong> ""join"" private key from step1 and certificate from step2 to get certificate with private key.</p>

<p>If I'm ok with certificate without private key, I could do something like:</p>

<pre><code>MS.X509Certificate mcCert = new MS.X509Certificate2(bcCert.GetEncoded(), null);
</code></pre>

<p>and I'm done.</p>

<p>The issue(s) come when trying to set private-key:</p>

<pre><code>msCert.PrivateKey = ConvertBouncyToNetSomehow(bcSubjKeys.Private)
</code></pre>

<p>(note that typeof <code>msCert.PrivateKey</code> is <code>MS.AsymmetricAlgorithm</code> and the type of <code>bcSubjKeys.Private</code> is <code>BC.ECPrivateKeyParameters</code>)</p>

<p>It seems that suitable way is using <code>MS.ECDsaCng</code> class (which inherits from <code>MS.AsymmetricAlgorithm</code>), but:</p>

<p><strong>1</strong> The only way I found to convert <code>BC.ECPrivateKeyParameters</code> to <code>MS.CngKey</code> (required by <code>MS.ECDsaCng</code>) is via pkcs8 format:</p>

<pre><code>BC.PrivateKeyInfo bcPKInfo = BC.PrivateKeyInfoFactory.CreatePrivateKeyInfo(bcSubjKeys.Private);
byte[] pkArr = bcPKInfo.GetDerEncoded();
MS.CngKey msPKCng = MS.CngKey.Import(pkArr, MS.CngKeyBlobFormat.Pkcs8PrivateBlob);
</code></pre>

<p>but using this approach some information is lost because value of <code>msPKCng.AlgorithmGroup</code> is <code>""ECDH""</code> while <code>bcSubjKeys.Private.AlgorithmName</code>says <code>""ECDSA""</code>. Also ECDH-key cannot be used with <code>MS.ECDsaCng</code>.</p>

<p>Nevertheless.. I could continue with <code>MS.ECDiffieHellmanCng</code> instead of requested <code>MS.ECDsaCng</code> if..</p>

<p><strong>2</strong> implementation of <code>MS.X509Certificate2.set_PrivateKey</code> requires the object implements interface <code>MS.ICspAsymmetricAlgorithm</code>. But neither one of them (<code>ECDsaCng</code>, <code>ECDiffieHellmanCng</code>) implement it.</p>

<p>At this point it seems different approach must be used (because of <code>MS.ICspAsymmetricAlgorithm</code> condition), e.g. export certificate and private key to pkcs file and use <code>X509Certificate2.Import(..)</code>.</p>

<p>Any hint?
Regards</p>
","<p>Unfortunately, it's not possible to do straight out of the box right now.  You can get the rest of the way with P/Invokes and .NET 4.6.2 (currently in preview). Or, with a detour through .NET Core you can build a PFX that works in .NET 4.6.1.</p>

<h1>""ECDSA"" vs ""ECDH""</h1>

<p>The Windows CNG libraries split ECC into ECDSA and ECDH. ECDSA key objects can only be used for ECDSA; but whenever Windows can't determine the usage during a PFX import (or PKCS#8 import) it calls a private key ECDH.  Why? Because Windows lets ECDH key objects do both key agreement (ECDH) and digital signature (ECDSA), so ECDH is more flexible.</p>

<p>But .NET 4.6.1 didn't know that.</p>

<p>.NET Core doesn't have this limitation (see <a href=""https://github.com/dotnet/corefx/pull/5850"" rel=""nofollow noreferrer"">https://github.com/dotnet/corefx/pull/5850</a>), and .NET 4.6.2 has also removed the restriction (per <a href=""https://github.com/Microsoft/dotnet/blob/master/releases/net462/dotnet462-changes.md#user-content-bcl"" rel=""nofollow noreferrer"">https://github.com/Microsoft/dotnet/blob/master/releases/net462/dotnet462-changes.md#user-content-bcl</a>).</p>

<h1>Generating ""ECDSA"" keys, instead of ""ECDH""</h1>

<p>.NET Core now has an <a href=""https://docs.microsoft.com/en-us/dotnet/core/api/system.security.cryptography.ecdsa#System_Security_Cryptography_ECDsa_ImportParameters_System_Security_Cryptography_ECParameters_"" rel=""nofollow noreferrer"">ImportParameters</a> method on ECDsa. If you can translate the BC.ECPrivateKeyProperty object to an MS.ECParameters structure you can import the blob into an ECDsaCng object. (Be sure to use it as a named curve, instead of explicitly copying all of the curve parameters).</p>

<p>Since it was purposefully imported into an ECDsa object it gets an ECDSA key, and that information will be embedded in the PFX.</p>

<h1>Building the PFX (tying it all together)</h1>

<p>With a bit of P/Invoking you can convince Windows to build a PFX using an ephemeral key. While .NET can't access ephemeral private keys from certificates, it will be able to make use of it if loaded from a PFX:</p>

<pre><code>[DllImport(Libraries.Crypt32, CharSet = CharSet.Unicode, SetLastError = true)]
private static extern unsafe bool CertSetCertificateContextProperty(IntPtr pCertContext, CertContextPropId dwPropId, CertSetPropertyFlags dwFlags, SafeNCryptKeyHandle pvData);

internal enum CertContextPropId : int
{
    CERT_NCRYPT_KEY_HANDLE_PROP_ID = 78,
}

[Flags]
internal enum CertSetPropertyFlags : int
{
    None = 0,
}

private static X509Certificate2 MateECDsaPrivateKey(
    X509Certificate2 cert,
    CngKey privateKey)
{
    // Make a new certificate instance which isn't tied to the current one
    using (var tmpCert = new X509Certificate2(cert.RawData))
    {
        SafeNCryptKeyHandle keyHandle = privateKey.Handle;

        // Set the ephemeral key handle property
        if (!CertSetCertificateContextProperty(
            tmpCert.Handle,
            CertContextPropId.CERT_NCRYPT_KEY_HANDLE_PROP_ID,
            CertSetPropertyFlags.None,
            keyHandle))
        {
            throw new CryptographicException(Marshal.GetLastWin32Error());
        }

        // You could emit this, if you prefer.
        byte[] pfxBytes = tmpCert.Export(X509ContentType.Pkcs12);

        // Clear the key handle out again to prevent double-free
        keyHandle = new SafeNCryptKeyHandle();

        if (!CertSetCertificateContextProperty(
            tmpCert.Handle,
            CertContextPropId.CERT_NCRYPT_KEY_HANDLE_PROP_ID,
            CertSetPropertyFlags.None,
            keyHandle))
        {
            throw new CryptographicException(Marshal.GetLastWin32Error());
        }

        // Now load a new certificate which has a temporary keyfile on disk.
        // Note: If you don't want exportability here, don't request it.
        var matedCert = new X509Certificate2(pfxBytes, (string)null, X509KeyStorageFlags.Exportable);

        using (ECDsa ecdsa = matedCert.GetECDsaPrivateKey())
        {
            if (ecdsa == null)
            {
                throw new InvalidOperationException(""It didn't work"");
            }
        }

        return matedCert;
    }
}
</code></pre>

<p>You'll need .NET 4.6.1 (or newer) to have access to GetECDsaPrivateKey().</p>
","2829","<c#><certificate><ecdsa>","3","5","1","2018-01-30 12:45:05","38165332","0","1","","","","2016-04-14 13:08:15",""
"40115286","Generating valid ECDSA secp256r1/prime256v1 key pair on Android, using Spongy Castle (Bouncy Castle distribution)","<p>I am trying to generate ECDSA key pair using SpongyCastle in Android.
This is the code:</p>

<pre><code>static {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
}

public static KeyPair generate() {
        ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""ECDSA"", ""SC"");
        generator.initialize(ecSpec, new SecureRandom());
        KeyPair keyPair = g.generateKeyPair();
        Log.i(TAG, ""EC Pub Key generated: "" + utils.bytesToHex(keyPair.getPublic().getEncoded()));
        Log.i(TAG, ""EC Private Key generated: "" + utils.bytesToHex(keyPair.getPrivate().getEncoded()));            
       return generator.generateKeyPair();
}
</code></pre>

<p>Something is wrong since I always get something like that example of 
Public Key:</p>

<blockquote>
  <p>3059301306072A8648CE3D020106082A8648CE3D03010703420004483ABA9F322240010ECF00E818C041A60FE71A2BD64C64CD5A60519985F110AEDE6308027D2730303F5E2478F083C7F5BB683DCAC22BFEB62F3A48BD01009F40</p>
</blockquote>

<p>and Private Key: </p>

<blockquote>
  <p>308193020100301306072A8648CE3D020106082A8648CE3D030107047930770201010420219AB4B3701630973A4B2917D53F69A4BE6DAD61F48016BFEF147B2999575CB2A00A06082A8648CE3D030107A14403420004483ABA9F322240010ECF00E818C041A60FE71A2BD64C64CD5A60519985F110AEDE6308027D2730303F5E2478F083C7F5BB683DCAC22BFEB62F3A48BD01009F40</p>
</blockquote>

<p>The site <a href=""https://kjur.github.io/jsrsasign/sample-ecdsa.html"" rel=""nofollow"" title=""https://kjur.github.io/jsrsasign/sample-ecdsa.html"">ECDSA sample</a> give Invalid ECDSA signature, and them seems really very different from that smaller Private Key and always starting with ""04"" Public Key generated in the same site.</p>

<p>Also, my backend verification gives me the error ""Invalid point encoding 0x30""</p>

<p>The backend Java method check is:</p>

<pre><code>public ECPublicKey getPublicKeyFromHex(String publicKeyHex)
        throws NoSuchAlgorithmException, DecoderException, ApplicationGenericException {
    byte[] rawPublicKey = Hex.decodeHex(publicKeyHex.toCharArray());
    ECPublicKey ecPublicKey = null;
    KeyFactory kf = null;

    ECNamedCurveParameterSpec ecNamedCurveParameterSpec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
    ECCurve curve = ecNamedCurveParameterSpec.getCurve();
    EllipticCurve ellipticCurve = EC5Util.convertCurve(curve, ecNamedCurveParameterSpec.getSeed());
    java.security.spec.ECPoint ecPoint = ECPointUtil.decodePoint(ellipticCurve, rawPublicKey);
    java.security.spec.ECParameterSpec ecParameterSpec = EC5Util.convertSpec(ellipticCurve,
            ecNamedCurveParameterSpec);
    java.security.spec.ECPublicKeySpec publicKeySpec = new java.security.spec.ECPublicKeySpec(ecPoint,
            ecParameterSpec);

    kf = KeyFactory.getInstance(""ECDSA"", new BouncyCastleProvider());

    try {
        ecPublicKey = (ECPublicKey) kf.generatePublic(publicKeySpec);
    } catch (Exception e) {
        throw new ApplicationGenericException(e.getMessage(), e.getCause());
    }

    return ecPublicKey;
}
</code></pre>
","<p>Convert generated public key to decoded bytes array or hex string:  </p>

<pre><code>public String getPublicKeyAsHex(PublicKey publicKey){

    ECPublicKey ecPublicKey = (ECPublicKey)publicKey;
    ECPoint ecPoint = ecPublicKey.getW();

    byte[] publicKeyBytes = new byte[PUBLIC_KEY_LENGTH];
    writeToStream(publicKeyBytes, 0, ecPoint.getAffineX(), PRIVATE_KEY_LENGTH);
    writeToStream(publicKeyBytes, PRIVATE_KEY_LENGTH, ecPoint.getAffineY(), PRIVATE_KEY_LENGTH);

    String hex = Hex.toHexString(publicKeyBytes);

    logger.debug(""Public key bytes: "" + Arrays.toString(publicKeyBytes));
    logger.debug(""Public key hex: "" + hex);

    return hex;
}

private void writeToStream(byte[] stream, int start, BigInteger value, int size) {
    byte[] data = value.toByteArray();
    int length = Math.min(size, data.length);
    int writeStart = start + size - length;
    int readStart = data.length - length;
    System.arraycopy(data, readStart, stream, writeStart, length);
}
</code></pre>

<p>Convert decoded bytes array back to <code>PublicKey</code>:</p>

<pre><code>KeyFactory factory = KeyFactory.getInstance(ALGORITHM, ALGORITHM_PROVIDER);

ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(CURVE);

ECNamedCurveSpec params = new ECNamedCurveSpec(CURVE, spec.getCurve(), spec.getG(), spec.getN());

BigInteger xCoordinate = new BigInteger(1, Arrays.copyOfRange(decodedPublicKey, 0, PRIVATE_KEY_LENGTH));
BigInteger yCoordinate = new BigInteger(1, Arrays.copyOfRange(decodedPublicKey, PRIVATE_KEY_LENGTH, PUBLIC_KEY_LENGTH));
java.security.spec.ECPoint w = new java.security.spec.ECPoint(xCoordinate, yCoordinate);

PublicKey encodedPublicKey = factory.generatePublic(new java.security.spec.ECPublicKeySpec(w, params));
</code></pre>
","2792","<android><bouncycastle><elliptic-curve><ecdsa><spongycastle>","1","0","1","2016-10-24 09:00:26","","1","0","5962766","","2016-10-24 09:00:26","2016-10-18 18:17:18",""
"20086121","Convert ECDSA private hex key to public key","<p>I'm using the below two lines to generate a hex of an ECDSA private key:</p>

<pre><code>openssl ecparam -genkey -name secp256k1 -out data.pem

openssl ec -in data.pem -outform DER|tail -c +8|head -c 32|xxd -p -c 32
</code></pre>

<p>Those output something like this:</p>

<pre><code>059f2c8f5b1978bcc02d4b41e75c3aae99f3194fb06b53ffd256178e1367a2a6
</code></pre>

<p>How can I then use that hex key to generate a public ECDSA key, something like this?</p>

<pre><code>043d6fa62769c10ceb28d3c13ae1e2329888e99d9c8bf854cc5bdcea0b7cd3002a0f5d244e35eec297c8eb4098b75295328cdeebe7e39a5ac7539f0fc146fa3c99
</code></pre>

<p>Any help is appreciated.</p>
","<p>Try this one</p>

<pre><code>openssl ec -in data.pem -pubout -out pubkey.pem
</code></pre>
","2652","<openssl><hex><ecdsa>","2","2","2","2014-04-07 19:55:40","","1","","","","","2013-11-20 02:22:42",""
"20086121","Convert ECDSA private hex key to public key","<p>I'm using the below two lines to generate a hex of an ECDSA private key:</p>

<pre><code>openssl ecparam -genkey -name secp256k1 -out data.pem

openssl ec -in data.pem -outform DER|tail -c +8|head -c 32|xxd -p -c 32
</code></pre>

<p>Those output something like this:</p>

<pre><code>059f2c8f5b1978bcc02d4b41e75c3aae99f3194fb06b53ffd256178e1367a2a6
</code></pre>

<p>How can I then use that hex key to generate a public ECDSA key, something like this?</p>

<pre><code>043d6fa62769c10ceb28d3c13ae1e2329888e99d9c8bf854cc5bdcea0b7cd3002a0f5d244e35eec297c8eb4098b75295328cdeebe7e39a5ac7539f0fc146fa3c99
</code></pre>

<p>Any help is appreciated.</p>
","<p>You can take the last 65 bytes of your private key you got from </p>

<pre><code>openssl ecparam -genkey -name secp256k1 -out data.pem
openssl ec -in data.pem -outform DER
</code></pre>

<p>That's your public key too.</p>
","2652","<openssl><hex><ecdsa>","2","0","2","2014-04-07 19:55:40","","1","","","","","2013-11-20 02:22:42",""
"22293864","Ruby/openssl: convert Elliptic Curve point octet string into OpenSSL::PKey::EC::Point","<p>I am trying to write Ruby code to check the Elliptic Curve Digital Signature Algorithm (ECDSA) signature on a particular message that I found <a href=""https://en.bitcoin.it/wiki/Protocol_specification#alert"" rel=""noreferrer"">here</a>.</p>

<p>The problem is that I don't know how to convert the octet string for the public key into an <a href=""http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/PKey/EC/Point.html"" rel=""noreferrer"">OpenSSL::PKey::EC::Point</a> object.  If I were writing this in C, I would just pass the octet string to OpenSSL's <a href=""http://openssl.sourcearchive.com/documentation/1.0.0e-2ubuntu4/crypto_2ec_2ec_8h_a628017a03d4a4600b9f62ccb56699239.html"" rel=""noreferrer""><code>o2i_ECPublicKey</code></a>, which does something close to what I would want and in fact is used by the <a href=""https://github.com/bitcoin/bitcoin/blob/2aed2b30b112aaaf7d46df4fd947648ca8df4e67/src/key.cpp#L199"" rel=""noreferrer"">reference implementation</a>.  However, I searched the <a href=""https://github.com/ruby/ruby/"" rel=""noreferrer"">source code of Ruby (MRI)</a> and it contains no calls to <code>o2i_ECPublicKey</code> so I don't know how I would use that function from Ruby without writing a C extension.</p>

<p>Here is the octet string, in hex.  It is just a 0x04 byte followed by two 32-byte integers that represent the x and y coordinates of the point on the elliptic curve:</p>

<pre><code>04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284
</code></pre>

<p>So does anyone know how to convert that string into an in <code>OpenSSL::PKey::EC::Point</code> in Ruby?  Once I get the point object, I will use it in the following code which I believe will verify the signature:</p>

<pre><code>key = OpenSSL::PKey::EC.new('secp256k1')
key.public_key = point
result = key.dsa_verify_asn1(digest, signature)
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>Thanks to Jay-Ar Polidario I got it to work.  Here is the full code I have that verifies the signature using OpenSSL.  I also wrote a gem called <a href=""http://rubygems.org/gems/ecdsa"" rel=""noreferrer"">ecdsa</a> and I included code showing how to use my gem to do the same thing.</p>

<pre><code># coding: ASCII-8BIT

digest =
  ""\xbf\x91\xfb\x0b\x4f\x63\x33\x77\x4a\x02\x2b\xd3\x07\x8e\xd6\xcc"" \
  ""\xd1\x76\xee\x31\xed\x4f\xb3\xf9\xaf\xce\xb7\x2a\x37\xe7\x87\x86""

signature_der_string =
  ""\x30\x45"" \
  ""\x02\x21\x00"" \
  ""\x83\x89\xdf\x45\xf0\x70\x3f\x39\xec\x8c\x1c\xc4\x2c\x13\x81\x0f"" \
  ""\xfc\xae\x14\x99\x5b\xb6\x48\x34\x02\x19\xe3\x53\xb6\x3b\x53\xeb"" \
  ""\x02\x20"" \
  ""\x09\xec\x65\xe1\xc1\xaa\xee\xc1\xfd\x33\x4c\x6b\x68\x4b\xde\x2b"" \
  ""\x3f\x57\x30\x60\xd5\xb7\x0c\x3a\x46\x72\x33\x26\xe4\xe8\xa4\xf1""

public_key_octet_string =
  ""\x04"" \
  ""\xfc\x97\x02\x84\x78\x40\xaa\xf1\x95\xde\x84\x42\xeb\xec\xed\xf5"" \
  ""\xb0\x95\xcd\xbb\x9b\xc7\x16\xbd\xa9\x11\x09\x71\xb2\x8a\x49\xe0"" \
  ""\xea\xd8\x56\x4f\xf0\xdb\x22\x20\x9e\x03\x74\x78\x2c\x09\x3b\xb8"" \
  ""\x99\x69\x2d\x52\x4e\x9d\x6a\x69\x56\xe7\xc5\xec\xbc\xd6\x82\x84""

# Verifying with openssl.
require 'openssl'
ec = OpenSSL::PKey::EC.new('secp256k1')
key_bn = OpenSSL::BN.new(public_key_octet_string, 2)  # 2 means binary
ec.public_key = OpenSSL::PKey::EC::Point.new(ec.group, key_bn)
result = ec.dsa_verify_asn1(digest, signature_der_string)
puts result  # =&gt; true

# Verifying with the new ECDSA gem I wrote, version 0.1.5
require 'ecdsa'
group = ECDSA::Group::Secp256k1
point = ECDSA::Format::PointOctetString.decode(public_key_octet_string, group)
signature = ECDSA::Format::SignatureDerString.decode(signature_der_string)
result = ECDSA.valid_signature?(point, digest, signature)
puts result  # =&gt; true
</code></pre>

<p>I think it's weird that OpenSSL makes you represent the public key temporarily as a single BN (big number), because it is actually two big numbers.  My gem can directly convert octet strings (as defined in the SEC2 standard) into <code>ECDSA::Point</code> objects.</p>
","<p>OpenSSL allows you to create a <a href=""http://ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL/PKey/EC/Point.html"" rel=""nofollow"">point</a> with a group and a bignum, so I tried this:</p>

<pre><code>require 'openssl'
include OpenSSL
group = PKey::EC::Group.new('secp256k1')
bignum = BN.new('04fc9702847840...')
point = PKey::EC::Point.new(group, bignum)
</code></pre>

<p>But it raises <code>OpenSSL::PKey::EC::Point::Error: invalid encoding</code>.  I'm not quite sure how to troubleshoot it from here, but hopefully this helps you out a little bit.</p>
","2618","<ruby><openssl><elliptic-curve><ecdsa>","9","2","2","2015-08-10 08:43:37","22476010","0","4","28128","","2014-03-21 06:24:12","2014-03-10 06:56:42",""
"22293864","Ruby/openssl: convert Elliptic Curve point octet string into OpenSSL::PKey::EC::Point","<p>I am trying to write Ruby code to check the Elliptic Curve Digital Signature Algorithm (ECDSA) signature on a particular message that I found <a href=""https://en.bitcoin.it/wiki/Protocol_specification#alert"" rel=""noreferrer"">here</a>.</p>

<p>The problem is that I don't know how to convert the octet string for the public key into an <a href=""http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/PKey/EC/Point.html"" rel=""noreferrer"">OpenSSL::PKey::EC::Point</a> object.  If I were writing this in C, I would just pass the octet string to OpenSSL's <a href=""http://openssl.sourcearchive.com/documentation/1.0.0e-2ubuntu4/crypto_2ec_2ec_8h_a628017a03d4a4600b9f62ccb56699239.html"" rel=""noreferrer""><code>o2i_ECPublicKey</code></a>, which does something close to what I would want and in fact is used by the <a href=""https://github.com/bitcoin/bitcoin/blob/2aed2b30b112aaaf7d46df4fd947648ca8df4e67/src/key.cpp#L199"" rel=""noreferrer"">reference implementation</a>.  However, I searched the <a href=""https://github.com/ruby/ruby/"" rel=""noreferrer"">source code of Ruby (MRI)</a> and it contains no calls to <code>o2i_ECPublicKey</code> so I don't know how I would use that function from Ruby without writing a C extension.</p>

<p>Here is the octet string, in hex.  It is just a 0x04 byte followed by two 32-byte integers that represent the x and y coordinates of the point on the elliptic curve:</p>

<pre><code>04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284
</code></pre>

<p>So does anyone know how to convert that string into an in <code>OpenSSL::PKey::EC::Point</code> in Ruby?  Once I get the point object, I will use it in the following code which I believe will verify the signature:</p>

<pre><code>key = OpenSSL::PKey::EC.new('secp256k1')
key.public_key = point
result = key.dsa_verify_asn1(digest, signature)
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>Thanks to Jay-Ar Polidario I got it to work.  Here is the full code I have that verifies the signature using OpenSSL.  I also wrote a gem called <a href=""http://rubygems.org/gems/ecdsa"" rel=""noreferrer"">ecdsa</a> and I included code showing how to use my gem to do the same thing.</p>

<pre><code># coding: ASCII-8BIT

digest =
  ""\xbf\x91\xfb\x0b\x4f\x63\x33\x77\x4a\x02\x2b\xd3\x07\x8e\xd6\xcc"" \
  ""\xd1\x76\xee\x31\xed\x4f\xb3\xf9\xaf\xce\xb7\x2a\x37\xe7\x87\x86""

signature_der_string =
  ""\x30\x45"" \
  ""\x02\x21\x00"" \
  ""\x83\x89\xdf\x45\xf0\x70\x3f\x39\xec\x8c\x1c\xc4\x2c\x13\x81\x0f"" \
  ""\xfc\xae\x14\x99\x5b\xb6\x48\x34\x02\x19\xe3\x53\xb6\x3b\x53\xeb"" \
  ""\x02\x20"" \
  ""\x09\xec\x65\xe1\xc1\xaa\xee\xc1\xfd\x33\x4c\x6b\x68\x4b\xde\x2b"" \
  ""\x3f\x57\x30\x60\xd5\xb7\x0c\x3a\x46\x72\x33\x26\xe4\xe8\xa4\xf1""

public_key_octet_string =
  ""\x04"" \
  ""\xfc\x97\x02\x84\x78\x40\xaa\xf1\x95\xde\x84\x42\xeb\xec\xed\xf5"" \
  ""\xb0\x95\xcd\xbb\x9b\xc7\x16\xbd\xa9\x11\x09\x71\xb2\x8a\x49\xe0"" \
  ""\xea\xd8\x56\x4f\xf0\xdb\x22\x20\x9e\x03\x74\x78\x2c\x09\x3b\xb8"" \
  ""\x99\x69\x2d\x52\x4e\x9d\x6a\x69\x56\xe7\xc5\xec\xbc\xd6\x82\x84""

# Verifying with openssl.
require 'openssl'
ec = OpenSSL::PKey::EC.new('secp256k1')
key_bn = OpenSSL::BN.new(public_key_octet_string, 2)  # 2 means binary
ec.public_key = OpenSSL::PKey::EC::Point.new(ec.group, key_bn)
result = ec.dsa_verify_asn1(digest, signature_der_string)
puts result  # =&gt; true

# Verifying with the new ECDSA gem I wrote, version 0.1.5
require 'ecdsa'
group = ECDSA::Group::Secp256k1
point = ECDSA::Format::PointOctetString.decode(public_key_octet_string, group)
signature = ECDSA::Format::SignatureDerString.decode(signature_der_string)
result = ECDSA.valid_signature?(point, digest, signature)
puts result  # =&gt; true
</code></pre>

<p>I think it's weird that OpenSSL makes you represent the public key temporarily as a single BN (big number), because it is actually two big numbers.  My gem can directly convert octet strings (as defined in the SEC2 standard) into <code>ECDSA::Point</code> objects.</p>
","<p>Try the following (Tested without errors):</p>

<pre><code>key =  '04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284'
key_bn = OpenSSL::BN.new(key, 16) #Input: 16=Hexa, Output: BigNumber
group = OpenSSL::PKey::EC::Group.new('secp256k1')

point = OpenSSL::PKey::EC::Point.new(group, key_bn)
#--&gt; &lt;OpenSSL::PKey::EC::Point:0x5288178&gt;
</code></pre>
","2618","<ruby><openssl><elliptic-curve><ecdsa>","9","7","2","2015-08-10 08:43:37","22476010","0","4","28128","","2014-03-21 06:24:12","2014-03-10 06:56:42",""
"19466907","C# ecdsa signature - Which key specification can i choose?","<p>i need to generate a ECDSA signature on C# side, and after reading and verify the signature on android application using (obviously) the relative public key. 
Well, to get a ECDSA key pair in java (with bouncy castle provider), the code is like that</p>

<pre><code>kpg = KeyPairGenerator.getInstance(""ECDSA"", ""BC"");
            ecSpec = new ECGenParameterSpec(""secp224k1"");
kpg.initialize(ecSpec, new SecureRandom());
</code></pre>

<p>The string <code>""secp224k1""</code>, is the curve name. And i can choose ""secp224k1"",""secp224r1"",""secp256k1"",""secp256r1"" and more others.</p>

<p>My questions is:</p>

<ol>
<li>Which is the equivalent curve name in C# mentioned above?</li>
<li>Could somebody make me an example about how, in C#, i can generate a keyPair like the above java code?</li>
</ol>

<p>Thanks in advance</p>
","<p>I've found something about my first question:</p>

<blockquote>
  <p>Which is the equivalent curve name in C# mentioned above?</p>
</blockquote>

<p>The microsoft libraries support only P-256, P-384 and P-521 ""NIST-recommended elliptic curve ID"", that is the equivalent named curve, rispectively, secp256r1, secp384r1, secp521r1 of ""SEC 2 recommended elliptic curve domain parameters"" that are the equivalent of prime256v1, but not 384 and 521 in ANSI X9.62 ECDSA prime curve ID.
Bouncy castle libraries for C#, support more other curves like the secp224k1 that i was interested.</p>

<p>For the second question </p>

<blockquote>
  <p>Could somebody make me an example about how, in C#, i can generate a keyPair like the above java code?</p>
</blockquote>

<p>i've found an old example <a href=""http://mytenpennies.wikidot.com/blog%3ausing-bouncy-castle"" rel=""nofollow"">here</a>
It says that the keys supported are only 3: 192 bit, 239 bit and 256 bit, but i think is referred to some old version of the library</p>

<p>this code can demonstrate it</p>

<pre><code>ECKeyPairGenerator gen = new ECKeyPairGenerator(""ECDSA"");
        SecureRandom secureRandom = new SecureRandom();
        Org.BouncyCastle.Asn1.X9.X9ECParameters ecp = Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByName(""secp224k1"");
        ECDomainParameters ecSpec = new ECDomainParameters(ecp.Curve, ecp.G, ecp.N, ecp.H, ecp.GetSeed());
        ECKeyGenerationParameters ecgp = new ECKeyGenerationParameters(ecSpec, secureRandom);
        gen.Init(ecgp);
        AsymmetricCipherKeyPair eckp = gen.GenerateKeyPair();
</code></pre>

<p>If somebody wants try to make it better, i think that this thread could be very precious for all. Im only a beginner with C# and this code isn't mine. :)</p>
","2555","<c#><java><android><ecdsa>","2","2","1","2017-04-09 19:44:26","19545708","0","2","","","","2013-10-19 14:05:15",""
"23863299","ECC PHP Library","<p>I've spent days trying to find more information on a specific PHP library with no success:
<a href=""https://github.com/mdanter/phpecc"" rel=""nofollow"">https://github.com/mdanter/phpecc</a></p>

<p>Does anyone have information on how to use this? All I want to do is:</p>

<ol>
<li>Generate a private key and public key pair.</li>
<li>Get the public key from a given private key.</li>
<li>Verify signed messages.</li>
</ol>

<p>Basically, the PHP equivalent of:
<a href=""http://kjur.github.io/jsrsasign/sample-ecdsa.html"" rel=""nofollow"">http://kjur.github.io/jsrsasign/sample-ecdsa.html</a></p>
","<p>After a lot of trial and error (and some help from the Bitcoin community) I was finally able to figure this out.</p>

<p>I've decided to share my work:
<a href=""https://github.com/tuaris/PHPECC"" rel=""nofollow"">https://github.com/tuaris/PHPECC</a></p>
","2535","<php><ecdsa>","1","4","1","2015-02-09 05:34:18","23877576","1","","","","","2014-05-26 05:31:16",""
"23865542","recover private key for bitcoin address","<p>I did two stupid things:</p>

<ol>
<li>I reinstalled Windows, but I missed a few things during backup</li>
<li>I forgot the password to my bitcoin address</li>
</ol>

<p>So basically the wallet.dat is gone, and all I remember of the password are the first two letters and that it was 10 letters long (alphanumeric), generated by random.org.  This was a ""brain wallet"", so the sha256 hash of the password is the private key.  This leaves me with 218 trillion possibilities (62^8).  I've written a C# program that runs through all possible permutations and generates the address to check against.  With 4 cores, this will take tens of thousands of years.  I don't have access to a supercomputer so I was hoping to move to the GPU.</p>

<p>If this was just a simple sha256 hash, my two GPUs could crack this in less than 5 days.  However, the bitcoin security has multiple hashes and ECDSA, which is the slow part.  The Vanitygen program is able to use OpenSSL and OpenCL to run 25 million ECDSA keys/sec with just one of my GPUs, so moving to GPU should speed this up.  </p>

<p>I know what I need to do, but unfortunately, I don't know C++, OpenCL or OpenSSL.  As far as my research has shown, there is no good way to do this in C#, which is my language of choice.  Does anyone have any suggestions (other than forget it, which I'll probably have to do)?</p>
","<p>Nobody is going to help you crack a Bitcoin key, especially not for free. If it were easy to do, Bitcoin would be insecure and nobody would use it. You're better off removing the hard drive and attempting data recovery on the drive.</p>

<p>Start over, and keep your private key encrypted in multiple safe places.</p>
","2445","<passwords><bitcoin><ecdsa>","0","3","1","2014-08-24 12:22:24","","2","","","","","2014-05-26 08:07:10",""
"27453271","Elliptic curve encryption - ECDSA on iOS and Android","<p>I'm putting together an encryption strategy that will encrypt data shared between iOS and Android devices over BTLE. We would like to use a basic elliptic curve cryptography.</p>

<p>We're currently implementing our iOS app and our Android app will kick-off development in the next month or so. So, my question is as follows:</p>

<p>I know on iOS I can use Certificate, Key and Trust Services to generate a key pair of type kSecAttrKeyTypeECDSA. This is cool.</p>

<p>And I see that the go to encryption library for Android, <a href=""https://www.bouncycastle.org/"" rel=""nofollow"">BouncyCastle</a>, also supports ECDSA. </p>

<p>So, my question is.. can I count on key-pairs generated on either platform to operate the same in terms of encryption and decryption on both iOS and Android?</p>

<p>i.e. </p>

<p>iOS User A </p>

<ul>
<li>generated their public/private key pair using iOS ECDSA</li>
<li>holds reference to user B's public key</li>
</ul>

<p>Android User B</p>

<ul>
<li>generated their public/private key pair using BouncyCastle ECDSA</li>
<li>holds reference to user A's public key</li>
</ul>

<p>Can user B encode a message using user A's public key.. send the encoded data to user A and expect user A to be able to decode? </p>
","<p>No, because ECDSA is only used to generate signatures - for instance to authenticate. ECIES should however be available using Bouncy Castle on Android and through CryptoPP on iOS. It's also possible to use ECDH with separate authentication or static-static ECDH but that might require a bit of a learning curve.</p>

<p>Note that ECIES introduces additional overhead, so don't forget to put that into your calculations...</p>
","2428","<android><ios><encryption><ecdsa>","4","4","1","2014-12-13 00:25:08","","0","","","","","2014-12-12 22:43:50",""
"27201847","Error decoding signature bytes : ""java.security.SignatureException: error decoding signature bytes""","<p>I got this error when trying to verify ECDSA Signature in my class. The error code is:</p>

<pre><code>java.security.SignatureException: error decoding signature bytes.
at org.bouncycastle.jcajce.provider.asymmetric.util.DSABase.engineVerify(Unknown Source)
at java.security.Signature$Delegate.engineVerify(Signature.java:1172)
at java.security.Signature.verify(Signature.java:623)
at SDSGeneration.Signing.verify_signature(Signing.java:88)
at com.sdsweb.modele.VerificationBox.checkSignature(VerificationBox.java:121)
at com.sdsweb.modele.VerificationBox.verifieur(VerificationBox.java:84)
at com.sdsweb.servlet.Authentification.doGet(Authentification.java:55)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:620)......
</code></pre>

<p>I'm calling the method as this in the VerificationBox.java Class :</p>

<pre><code>public Map&lt;Integer, String&gt; checkSignature(String data_digest, Signature SignObject, PublicKey publicKey, byte[] Signaturebyte) throws InvalidKeyException, SignatureException, NoSuchProviderException, NoSuchAlgorithmException{

    Map&lt;Integer, String&gt; erreur_signature = new HashMap&lt;Integer, String&gt;();

    Signing SignVerifier = new Signing();

    SignVerifier.setEcdsa_signature();

    SignVerifier.verify_signature(publicKey, SignVerifier.getEcdsa_signature(), data_digest, Signaturebyte);

    if (SignVerifier.getVerify_result()){
        erreur_signature.put(j, ""SIGNATURE RONN, CODE SDS INVALIDE"");
        j++;
    }
    return null;

}
</code></pre>

<p>This is the SDSGeneration.Signing Class:</p>

<pre><code>package SDSGeneration;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PublicKey;
import java.security.Signature;
import java.security.KeyPair;
import java.security.SignatureException;

//This class provide an instance of all object which are needed to sign data
public class Signing {

    public Signing() {

    }

    public Signing(KeyPair keygen) {

    }

    //ECDSA Signature Object
    private Signature ecdsa_signature;
    //KeyPair object
    private KeyPair keygen;
    //Final data signature
    private byte[] signature;
    //Boolean variable telling if the signing proccess was succesfful or not
    private Boolean verify_result;

    public Boolean getVerify_result() {
        return verify_result;
    }

    public byte[] getSignature() {
        return signature;
    }


    public KeyPair getKeygen() {
        return keygen;
    }

    public Signature getEcdsa_signature() {
        return ecdsa_signature;
    }

    public void setEcdsa_signature() throws NoSuchAlgorithmException, NoSuchProviderException {

        this.ecdsa_signature = java.security.Signature.getInstance(""ECDSA"", ""BC"");
    }

    public void setKeygen(KeyPair keygen) {
        this.keygen = keygen;
    }



    //This method is use to sign data. A call to a  sign  method resets the signature object to the state it was in when previously initialized for signing via a call to  initSign. 
    //That is, the object is reset and available to generate another signature with the same private key, if desired, via new calls to  update  and  sign .
    public void generate_signature(KeyPair keygen, Signature ecdsa_signature, String data) throws InvalidKeyException, SignatureException{

        //inserting private key in signature object
        ecdsa_signature.initSign(keygen.getPrivate());

        //inserting data to sign
        ecdsa_signature.update(data.getBytes());

        //signing
        this.signature = ecdsa_signature.sign();
    }

    //This method is use to sign data. A call to the  verify  method resets the signature object to its state when it was initialized for verification via a call to initVerify . 
    //That is, the object is reset and available to verify another signature from the identity whose public key was specified in the call to  initVerify .
    public void verify_signature(PublicKey keygen, Signature ecdsa_signature, String data, byte[] signature) throws InvalidKeyException, SignatureException{

        //generating the signature
        ecdsa_signature.initVerify(keygen);

        //inserting data to verify
        ecdsa_signature.update(data.getBytes());

        //verifying
        this.verify_result = ecdsa_signature.verify(signature);
    }
}
</code></pre>

<p>I wrote a Test class for testing the SDSGeneration.Signing code and everything working well, signing and verifying data, but when importing and using it in my project, the error below occure. This is the Test Class code:</p>

<pre><code>    package SDSGeneration;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SignatureException;

public class TestSigning {

    public TestSigning() {
        // TODO Auto-generated constructor stub
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeyException, SignatureException {
        // TODO Auto-generated method stub
        GenerateKeyPair new_keypair = new GenerateKeyPair();

        Signing testSign = new Signing();
        testSign.setKeygen(new_keypair.getKeygen());

        testSign.setEcdsa_signature();

        testSign.generate_signature(testSign.getKeygen(), testSign.getEcdsa_signature(), ""Fanfe Yvon"");

        testSign.verify_signature(testSign.getKeygen().getPublic(), testSign.getEcdsa_signature(), ""Fanfe Yvon"", testSign.getSignature());

        System.out.println(""Signature result : "" + testSign.getVerify_result() + "" ; signature of data : "" + testSign.getSignature());
    }

}
</code></pre>
","<p>The Problem was that i was using the wrong CHARSET to Encode the signature into the Storage.</p>

<p>I had to encode into convert it to Base64 and encode it in UTF-8 before storing it, like this:</p>

<pre><code>String signTostring = DatatypeConverter.printBase64Binary(signature);
signTostring = URLEncoder.encode(signTostring, ""UTF-8"");
</code></pre>

<p>Whan i want to use it, i do the revrse actions to get the original signature </p>

<pre><code>String st = URLDecoder.decode(code.getSignature(), ""UTF-8"");
byte[] sign_byte = DatatypeConverter.parseBase64Binary(st); 
</code></pre>
","2414","<java><eclipse><security><digital-signature><ecdsa>","0","0","1","2015-01-04 22:10:37","","8","","4173699","","2014-12-01 18:43:24","2014-11-29 11:46:38",""
"16973217","How can I validate an ECDSA signature using the signed data, signature and the signer ECDSA public key?","<p>In theory it should be possible to validate the signature of a piece of data if in possesion of the public key, signature and data that was signed and the hash algorithm is known. </p>

<p>I have all these components in binary format. Does anybody have an idea about the easiest way to validate this signature? OpenSSL? Python? An example would be great. Can it be done without writing code?</p>
","<p>Here's how you can do it in Ruby.</p>

<pre><code>require 'openssl'

signature = File.read('/path/to/sig.der')
data = File.read('/path/to/data')
pub_key = File.read('/path/to/ecdsa_pub_key')
key = OpenSSL::PKey::EC.new(pub_key)
if key.dsa_verify_asn1(data, signature) == true
  puts 'verified'
end
</code></pre>

<p>This code requires that the OpenSSL linked against Ruby be compiled with elliptic curve support. (Red Hat flavored distributions of Linux do not satisfy this requirement)</p>

<p>If you're curious: dsa_verify_asn1 uses the <a href=""http://www.openssl.org/docs/crypto/ecdsa.html"" rel=""nofollow"">ECSDA_verify</a> function in the OpenSSL API.</p>
","2362","<algorithm><openssl><digital-signature><ecdsa>","0","1","2","2015-12-17 02:07:19","","0","","","","","2013-06-06 22:21:56",""
"16973217","How can I validate an ECDSA signature using the signed data, signature and the signer ECDSA public key?","<p>In theory it should be possible to validate the signature of a piece of data if in possesion of the public key, signature and data that was signed and the hash algorithm is known. </p>

<p>I have all these components in binary format. Does anybody have an idea about the easiest way to validate this signature? OpenSSL? Python? An example would be great. Can it be done without writing code?</p>
","<p>You can use openssl to sign a message with a ECDSA signature, and then you can use openssl to verify the signature:</p>

<p>To sign a message (using SHA256 hashing, given the message and the signer's EC private key):</p>

<pre><code>openssl dgst -sha256 -sign ec-privatekey.pem message.txt &gt; signature.der
</code></pre>

<p>Then, to verify the signature (again using SHA256 hashing, given the message, the signer's EC public key, and the signature created above):</p>

<pre><code>openssl dgst -sha256 -verify ec-publickey.pem -signature signature.der message.txt
</code></pre>
","2362","<algorithm><openssl><digital-signature><ecdsa>","0","1","2","2015-12-17 02:07:19","","0","","","","","2013-06-06 22:21:56",""
"22762380","Importing ECC-based certificate from the Windows Certificate Store into CngKey","<p>How can I get the public/private keys from an ECC-based <code>X509Certificate2</code>'s into <code>CngKey</code>'s for use with <code>ECDsaCng</code> and <code>ECDiffieHellmanCng</code>?</p>

<p>I'm currently using RSA 2048 bit key pairs to sign/encrypt stuff.  I'm doing this by pulling the certificates from the <code>X509Store</code> where they are securely stored with private keys marked as non-exportable.  I would like to convert the current implementation to use ECDSA and ECDH so that I can use smaller key sizes for equivalent security.</p>

<p>I've successfully generated ECC certs using openssl:</p>

<ol>
<li><code>openssl ecparam -out private.pem -name prime256v1 -genkey</code></li>
<li><code>openssl req -new -key private.pem -x509 -nodes -days 365 -out public.cer</code></li>
<li><code>openssl pkcs12 -export -in public.cer -inkey private.pem -out export.pfx</code></li>
</ol>

<p>I've successfully installed the above generated certs in to the cert store.  I can retrieve them by thumbprint, but the crypto providers for the private and public keys throw ""Algorithm not supported"" exceptions.  Instead, I understand I'm supposed to use <code>ECDsaCng</code> and <code>ECDiffieHellmanCng</code> to sign/encrypt.  But these deal in <code>CngKey</code>'s.</p>

<p>Bouncy Castle isn't an option because it requires the private keys to be exportable.</p>

<p><a href=""http://clrsecurity.codeplex.com/"">CLR Security</a> will return me a <code>CngKey</code> pair via <code>GetCngPrivateKey</code> but it cannot be used with ECDsa because the key returned by CLRSecurity is an ECDH key.  Furthermore CLR Security doesn't give me a way to get just the public key from an <code>X509Certificate2</code> for signature verification (where I don't even have or need the private key of the signer).</p>

<p>Any ideas?  I'm at my wits end...  Any help would be <em>much</em> appreciated.</p>
","<p>You need to create the CngKey from the public key of the certificate:</p>

<blockquote>
  <p>certificate.PublicKey.EncodedKeyValue.RawData</p>
</blockquote>

<p>The CngKey contains 8 additional bytes, the first 4 bytes are used for the name of the curve used (ECS1, ECS3 or ECS5), the last 4 are the length of the key incl. padding (32, 48 or 66).</p>

<p>The first byte of the public key from the certificate is removed (as it is always 0x04 for ECDSA public key). </p>

<p>So for instance for ECDSA using P-256 curve and SHA-256 hash algorithm, you will get a public key of length 65 bytes. Discard the first byte, leaving 64 bytes, then prefix with 4 bytes for curve and 4 bytes for key length i.e. <em>(Encoding.ASCII)</em>:</p>

<blockquote>
  <p>69 (E) </p>
  
  <p>67 (C) </p>
  
  <p>83 (S) </p>
  
  <p>49 (1) </p>
  
  <p>32 (Key length)</p>
  
  <p>0 </p>
  
  <p>0 </p>
  
  <p>0</p>
</blockquote>

<p>Now you have the public key (72 bytes) to create the CngKey from:</p>

<blockquote>
  <p>var cngKey = CngKey.Import([the byte array], CngKeyBlobFormat.EccPublicBlob);</p>
  
  <p>var ecdsaCng = new ECDsaCng(cngKey);</p>
</blockquote>

<p>And you can verify the signature:</p>

<blockquote>
  <p>return ecdsaCng.VerifyData(encodedBytes, signature);</p>
</blockquote>
","2289","<.net><security><x509certificate2><ecdsa><cng>","15","6","1","2015-06-12 18:16:00","24233060","0","1","464604","","2014-03-31 22:56:28","2014-03-31 13:07:31",""
"37720783","Create and verify signature in code and from the command line using ECDSA","<p><strong>Problem:</strong>
Using the written demo code (given below) I can create and verify without problems.
However, using the openssl command line tool, verifying a signature (created by the demo code)
always seems to fail.</p>

<p><strong>What I have done:</strong>
The demo code creates a defined public/private key pair, then signs a defined hash and verifies it.</p>

<p>This is the program output:</p>

<pre><code>Public key: 04DFEC134530603832A31F8885EF01888884483D611F87A698213F168534EC06D85D21F7C85795435BC9A7F78190126CC6E52E050CBDFD43E27175FB1DF3E3DEF6 
Hash: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
Verified EC Signature
R: 383EB65E4A284CBCBA41A9777CE7C0816C5C23161EA9BC4EF8B1E668C7641A2A 
S: 608F4BAB9DFE6DC8F976C32D72508CD5BD68F9E325ADED69A9883CE487E6698B
</code></pre>

<p>It as well outputs the follwing files:</p>

<ul>
<li><code>privkey.pem</code> (private key in PEM format)</li>
<li><code>pubkey.pem</code> (public Key in PEM format)</li>
<li><code>data.bin</code> (the hash, nothing fancy)</li>
<li><code>data_sig.der</code> (the DER encoded signature: R &amp; S value)</li>
</ul>

<p>All files seem to be created correctly.</p>

<p>Next, I try to verify <code>data_sig.der</code> with the openssl command line tool.</p>

<pre><code>$ openssl dgst -verify pubkey.pem -signature data_sig.der data.bin
Verification Failure
</code></pre>

<p>Why does this fail? </p>

<p>I can only assume, that one of the 4 files has been written incorrectly,
but I double-checked everything and cannot spot my error.</p>

<p>Furthermore, using the PEM files created by the demo program, 
sign &amp; verify works fine from the command line: </p>

<pre><code>$openssl dgst -sign privkey.pem data.bin &gt; data_sig2.der
$openssl dgst -verify pubkey.pem -signature data_sig2.der data.bin
Verified OK
</code></pre>

<p>Here is the demo code (compiles with <code>gcc demo_code.c -lcrypto -lssl -o demo_code</code>):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;openssl/ec.h&gt;
#include &lt;openssl/ecdsa.h&gt;
#include &lt;openssl/obj_mac.h&gt;
#include &lt;openssl/bio.h&gt;
#include &lt;openssl/x509.h&gt;
#include &lt;openssl/ecdsa.h&gt;
#include &lt;openssl/pem.h&gt;
#include &lt;openssl/bn.h&gt;

void createSignature()
{
    EC_KEY* eckey = EC_KEY_new();
    EC_GROUP* ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
    EC_KEY_set_group(eckey,ecgroup);
    EC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);

    /* the private key value */
    const char *p_str = ""7D22AB6A1FD3FC1F5EBEDCA222151375683B733E9DDC9CA5B2485E202C55D25C"";
    BIGNUM* prv = BN_new();
    BN_hex2bn(&amp;prv, p_str);
    EC_POINT* pub = EC_POINT_new(ecgroup);

    /* calculate the public key */
    EC_POINT_mul(ecgroup, pub, prv, NULL, NULL, NULL);

    /* add the private &amp; public key to the EC_KEY structure */
    EC_KEY_set_private_key(eckey, prv);
    EC_KEY_set_public_key(eckey, pub);
    /* output public key in hex format */
    char* hexPKey = EC_POINT_point2hex( ecgroup, pub, POINT_CONVERSION_UNCOMPRESSED, NULL );
    printf(""Public key: %s \n"", hexPKey); 
    /* create hash */
    printf(""Hash: "");
    uint8_t hash[32];
    for(int i=0; i &lt; 32; i++) {
        hash[i] = i;
        printf(""%02x"",hash[i]);
    }
    printf(""\n"");
    /* create and verify signature */
    ECDSA_SIG* signature = ECDSA_do_sign(hash, 32, eckey);
    //hash[0] = 0xff; // Uncomment to test if verification fails with a wrong hash
    if (1 != ECDSA_do_verify(hash, 32, signature, eckey)) {
        printf(""Failed to verify EC Signature\n"");
    } else {
        printf(""Verified EC Signature\n"");
    }
    /*print R &amp; S value in hex format */
    char* hexR = BN_bn2hex(signature-&gt;r);
    char* hexS = BN_bn2hex(signature-&gt;s);
    printf(""R: %s \nS: %s\n"", hexR, hexS);
    /* export raw signature to DER-encoded format */
    int sigSize = i2d_ECDSA_SIG(signature, NULL);
    uint8_t* derSig = (uint8_t*)malloc(sigSize);
    uint8_t* p = derSig;    //memset(sig_bytes, 6, sig_size);
    sigSize= i2d_ECDSA_SIG(signature, &amp;p);

    EVP_PKEY* pkey = EVP_PKEY_new();
    EVP_PKEY_set1_EC_KEY(pkey, eckey);

    /* write files */
    FILE* fp = fopen(""pubkey.pem"", ""w"");
    PEM_write_PUBKEY(fp, pkey);
    fclose(fp);
    fp = fopen(""privkey.pem"", ""w"");
    PEM_write_PrivateKey(fp, pkey, NULL, NULL, 0, 0, NULL);
    fclose(fp);
    fp = fopen(""data.bin"", ""w"");
    fwrite(hash, 1, sizeof(hash), fp);
    fclose(fp);
    fp = fopen(""data_sig.der"", ""w"");
    fwrite(derSig, 1, sigSize, fp);
    fclose(fp);

    /* free runtime allocated res */
    free(derSig);
    OPENSSL_free(hexPKey); OPENSSL_free(hexR); OPENSSL_free(hexS);
    BN_free(prv);
    EC_POINT_free(pub);
    EC_GROUP_free(ecgroup); 
    EC_KEY_free(eckey);
}

int main(int argc, char** argv) {
    createSignature();
    return (EXIT_SUCCESS);
}
</code></pre>
","<p>It seems you sign data rather than result of hashing data. But when you run:</p>

<pre><code>$ openssl dgst -verify pubkey.pem -signature data_sig.der data.bin
</code></pre>

<p>openssl utility calculate sha256 hash from <code>data.bin</code> and try to verify signature on this hash.</p>

<p>So you need to calc sha256 from <code>000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f</code> and sign result:</p>

<pre><code>void createSignature()
{
    EC_KEY* eckey = EC_KEY_new();
    EC_GROUP* ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
    EC_KEY_set_group(eckey,ecgroup);
    EC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);

    /* the private key value */
    const char *p_str = ""7D22AB6A1FD3FC1F5EBEDCA222151375683B733E9DDC9CA5B2485E202C55D25C"";
    BIGNUM* prv = BN_new();
    BN_hex2bn(&amp;prv, p_str);
    EC_POINT* pub = EC_POINT_new(ecgroup);

    /* calculate the public key */
    EC_POINT_mul(ecgroup, pub, prv, NULL, NULL, NULL);

    /* add the private &amp; public key to the EC_KEY structure */
    EC_KEY_set_private_key(eckey, prv);
    EC_KEY_set_public_key(eckey, pub);
    /* output public key in hex format */
    char* hexPKey = EC_POINT_point2hex( ecgroup, pub, POINT_CONVERSION_UNCOMPRESSED, NULL );
    printf(""Public key: %s \n"", hexPKey); 
    /* create hash */
    printf(""Data: "");
    uint8_t data[32];
    for(int i=0; i &lt; 32; i++) {
        data[i] = i;
        printf(""%02x"",data[i]);
    }
    printf(""\n"");

    uint8_t hash[32];
    SHA256_CTX sha256;
    SHA256_Init(&amp;sha256);
    SHA256_Update(&amp;sha256, data, sizeof(data));
    SHA256_Final(hash, &amp;sha256);

    printf(""Hash: "");
    for(int i=0; i &lt; 32; i++) {
        data[i] = i;
        printf(""%02x"",hash[i]);
    }
    printf(""\n"");

    /* create and verify signature */
    ECDSA_SIG* signature = ECDSA_do_sign(hash, 32, eckey);
    /* hash[0] = 0xff; // Uncomment to test if verification fails with a wrong hash */
    if (1 != ECDSA_do_verify(hash, 32, signature, eckey)) {
        printf(""Failed to verify EC Signature\n"");
    } else {
        printf(""Verified EC Signature\n"");
    }
    /*print R &amp; S value in hex format */
    char* hexR = BN_bn2hex(signature-&gt;r);
    char* hexS = BN_bn2hex(signature-&gt;s);
    printf(""R: %s \nS: %s\n"", hexR, hexS);
    /* export raw signature to DER-encoded format */
    int sigSize = i2d_ECDSA_SIG(signature, NULL);
    uint8_t* derSig = (uint8_t*)malloc(sigSize);
    uint8_t* p = derSig;    //memset(sig_bytes, 6, sig_size);
    sigSize= i2d_ECDSA_SIG(signature, &amp;p);

    EVP_PKEY* pkey = EVP_PKEY_new();
    EVP_PKEY_set1_EC_KEY(pkey, eckey);

    /* write files */
    FILE* fp = fopen(""pubkey.pem"", ""w"");
    PEM_write_PUBKEY(fp, pkey);
    fclose(fp);
    fp = fopen(""privkey.pem"", ""w"");
    PEM_write_PrivateKey(fp, pkey, NULL, NULL, 0, 0, NULL);
    fclose(fp);
    fp = fopen(""data.bin"", ""w"");
    fwrite(data, 1, sizeof(data), fp);
    fclose(fp);
    fp = fopen(""data_sig.der"", ""w"");
    fwrite(derSig, 1, sigSize, fp);
    fclose(fp);

    /* free runtime allocated res */
    free(derSig);
    OPENSSL_free(hexPKey);
    OPENSSL_free(hexR); OPENSSL_free(hexS);
    BN_free(prv);
    EC_POINT_free(pub);
    EC_GROUP_free(ecgroup); 
    EC_KEY_free(eckey);
}
</code></pre>

<p>Now openssl check works:</p>

<pre><code>$ openssl dgst -verify pubkey.pem -signature data_sig.der data.bin
Verified OK
</code></pre>
","2043","<c><openssl><pem><ecdsa><der>","2","3","1","2017-01-30 11:54:31","37725832","0","","608639","","2016-06-10 05:24:30","2016-06-09 08:34:59",""
"39385718","DER Decode ECDSA Signature in Java","<p>I have generated an ECDSA signature in Java and I would like to get the R and S values from it. It is my understanding that the signature I have generated is DER encoded. Can someone please provide me with some Java code (maybe using Bouncy Castle) to retrieve the R and S values as BigIntegers?</p>

<p>Note: In case it helps, I generated the signature using a built in provider via the JCE's Signature class and the signature lengths for my P_256 EC key pair hover between 70 and 72 bytes usually.</p>
","<p>I was able to solve this myself. In case it helps anyone here is how I did it (most exception handling has been stripped for readability):</p>

<pre><code>import java.io.ByteArrayInputStream;
import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.Security;
import java.security.Signature;
import java.security.spec.ECGenParameterSpec;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class DecodeEcdsaSignature {

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        byte[] signature = getSignature();      
        ASN1Primitive asn1 = toAsn1Primitive(signature);

        if (asn1 instanceof ASN1Sequence) {
            ASN1Sequence asn1Sequence = (ASN1Sequence) asn1;
            ASN1Encodable[] asn1Encodables = asn1Sequence.toArray();
            for (ASN1Encodable asn1Encodable : asn1Encodables) {
                ASN1Primitive asn1Primitive = asn1Encodable.toASN1Primitive();
                if (asn1Primitive instanceof ASN1Integer) {
                    ASN1Integer asn1Integer = (ASN1Integer) asn1Primitive;
                    BigInteger integer = asn1Integer.getValue();
                    System.out.println(integer.toString());
                }
            }
        }

    }

    private static ASN1Primitive toAsn1Primitive(byte[] data) throws Exception
    {
        try (ByteArrayInputStream inStream = new ByteArrayInputStream(data);
                ASN1InputStream asnInputStream = new ASN1InputStream(inStream);) 
        {
            return asnInputStream.readObject();
        }
    }

    private static byte[] getSignature() throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""ECDSA"");
        ECGenParameterSpec ecParameterSpec = new ECGenParameterSpec(""P-256"");
        keyPairGenerator.initialize(ecParameterSpec);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        Signature signature = Signature.getInstance(""SHA256withECDSA"");
        signature.initSign(keyPair.getPrivate());
        signature.update(""message to sign"".getBytes(""UTF-8""));

        return signature.sign();
    }

}
</code></pre>
","2042","<java><asn.1><ecdsa><der>","2","3","1","2016-09-11 08:34:55","39434271","0","","1596398","","2016-09-08 08:43:07","2016-09-08 08:08:46",""
"18204964","ECDSA for Android using SpongyCastle","<p>I've just added SpongyCastle to Eclipse for my Android Project, however I don't seem to be able to find a single good/complete example of how to use ECDSA for <strong>encryption</strong> &amp; <strong>decryption</strong> of plain texts. I would imagine this should be a 'hello world' for ecnryption libraries.</p>

<p>Can anyone help me with this? or direct me towards some other resource that can help me achieve the same goals?</p>

<p>Thanks.</p>
","<p>Here's the <a href=""http://www.bouncycastle.org/wiki/display/JA1/Elliptic+Curve+Key+Pair+Generation+and+Key+Factories"" rel=""nofollow"">example</a> from bouncycastle.org for generating a key, from there it's just standard use of the KeyPair.  Also @nelenkov wrote a <a href=""http://nelenkov.blogspot.co.uk/2011/12/using-ecdh-on-android.html"" rel=""nofollow"">great article</a> (as usual) on Elliptic curve on Android</p>

<pre><code>ECGenParameterSpec ecGenSpec = new ECGenParameterSpec(""prime192v1"");
//using spongycastle provider
KeyPairGenerator  g = KeyPairGenerator.getInstance(""ECDSA"", ""SC"");

g.initialize(ecGenSpec, new SecureRandom());

KeyPair pair = g.generateKeyPair();
</code></pre>
","1926","<android><encryption-asymmetric><elliptic-curve><ecdsa><spongycastle>","1","0","1","2013-10-21 16:38:06","","1","1","","","","2013-08-13 09:08:21",""
"29303056","Java SSL/TLS Connection with ECC based certificates","<p>I'm trying to build a Server which works with ECC-based certificates. So far I have taken the following steps:</p>

<p>1) creating the signed server-certificate with openssl:</p>

<pre><code>openssl ecparam -param_enc explicit -out server\server.key.pem -name secp256k1 -genkey
openssl req -new -nodes -key server\server.key.pem -outform pem -out server\server.csr -sha256
openssl ca -keyfile CA\private\ca.key.pem -cert CA\ca.cert.pem -in server\server.csr -out server\server-cert.pem -md sha256 -outdir .\server
openssl pkcs12 -export -out server\server-cert.p12 -inkey server\server.key.pem -in server\server-cert.pem -certfile CA\ca.cert.pem
</code></pre>

<p>The ca.sert.pem is a self-signed CA-certificate to sign the server certificate with. It is generated likewise:</p>

<pre><code>openssl ecparam -param_enc explicit -out CA\private\ca.key.pem -name secp256k1 -genkey 
openssl req -new -key CA\private\ca.key.pem -x509 -nodes -days 365 -outform pem -sha256 -out CA\ca.cert.pem
</code></pre>

<p>2) setting up the server</p>

<pre><code>    public void startServer() {
    threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
    threadPool.setCorePoolSize(20);

    try {
        SSLContext sslContext = getSSLContext();
  SSLServerSocketFactory ssf = sslContext.getServerSocketFactory();
  SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket(8888);
        String[] ciphers = {""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256""};
  serverSocket.setEnabledCipherSuites(ciphers);
  serverSocket.setEnabledProtocols(new String[] {""TLSv1.2""});

  while (true) {
    SSLSocket clientSocket = (SSLSocket) serverSocket.accept();
    threadPool.execute(new ClientSession(clientSocket));
  }

    } catch (Exception e) {
        e.printStackTrace();
    }
}

    protected SSLContext getSSLContextForGWA() throws Exception {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    try {
        KeyStore ks = KeyStore.getInstance(""PKCS12"", ""BC"");
        File keyFile = new File(System.getProperty(""user.dir"") + File.separator + ""certs"" + File.separator + ""server"" + File.separator + ""server-cert.p12"");
        FileInputStream keyInput = new FileInputStream(keyFile);
        ks.load(keyInput, keyStorePassword.toCharArray());
        keyInput.close();

        // Set up key manager factory to use our key store
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(ks, keyStorePassword.toCharArray());

        // Initialize the SSLContext to work with our key managers.
        sslContext.init(kmf.getKeyManagers(), null, null);

        return sslContext;

    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
</code></pre>

<p>Remark: I only succeed to load the server certificate into the keystore using BouncyCastle. Otherwise I get ""Only named ECParameters supported"" Error.</p>

<p>3) Setting up the client
The client is set up likewise, except that the server certificate is imported into the truststore.</p>

<pre><code>    SSLContext sslContext = getSSLContextForSMGW();
    SSLSocketFactory sf = sslContext.getSocketFactory();

    SSLSocket clientSocket = (SSLSocket) sf.createSocket(host, port);
    String[] ciphers = {""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256""};
    clientSocket.setEnabledCipherSuites(ciphers);
    clientSocket.setEnabledProtocols(new String[] {""TLSv1.2""});
    printClientSocketInfo(clientSocket);
    BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
    BufferedWriter out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));

String line = null;
while (((line = in.readLine()) != null)) {
  System.out.println(line);
  break;
}
</code></pre>

<p>Now, when the client connects to the server I get the following error stack:</p>

<pre><code>Caused by: java.io.IOException: Only named ECParameters supported
at sun.security.ec.ECParameters.engineInit(ECParameters.java:150)
at java.security.AlgorithmParameters.init(AlgorithmParameters.java:293)
at sun.security.x509.AlgorithmId.decodeParams(AlgorithmId.java:132)
at sun.security.x509.AlgorithmId.&lt;init&gt;(AlgorithmId.java:114)
at sun.security.x509.AlgorithmId.parse(AlgorithmId.java:372)
at sun.security.x509.X509Key.parse(X509Key.java:168)
at sun.security.x509.CertificateX509Key.&lt;init&gt;(CertificateX509Key.java:75)
at sun.security.x509.X509CertInfo.parse(X509CertInfo.java:667)
at sun.security.x509.X509CertInfo.&lt;init&gt;(X509CertInfo.java:167)
... 15 more
</code></pre>

<p>I guess, that the client is not capable to verify the servers certificate (same error as if I import the certificate not using BouncyCastle). </p>

<p>I have printed the named EC-Curves with</p>

<pre><code>        System.out.println(""Named EC-Curves:"");
    String[] curves = Security.getProvider(""SunEC"")
            .getProperty(""AlgorithmParameters.EC SupportedCurves"")
            .split(""\\|"");
    for (String curve : curves) {
        System.out.println(curve.substring(1, curve.indexOf("","")));
    }
</code></pre>

<p>And it clearly outputs the name 'secp256k1' among them. So what am I missing here? Or how can I make the SSLContext to use another implementation of CertificateX509Key?</p>

<p>The debug output at the client side is:</p>

<pre><code>*** ClientHello, TLSv1.2
RandomCookie:  GMT: 1427463640 bytes = { 227, 188, 124, 163, 124, 55, 134, 199, 234, 241, 234, 51, 8, 208, 199, 117, 90, 125, 214, 134, 226, 110, 149, 92, 194, 25, 70, 59 }
Session ID:  {}
Cipher Suites: [TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256]
Compression Methods:  { 0 }
Extension elliptic_curves, curve names: {secp256r1, sect163k1, sect163r2, secp192r1, secp224r1, sect233k1, sect233r1, sect283k1, sect283r1, secp384r1, sect409k1, sect409r1, secp521r1, sect571k1, sect571r1, secp160k1, secp160r1, secp160r2, sect163r1, secp192k1, sect193r1, sect193r2, secp224k1, sect239k1, secp256k1}
Extension ec_point_formats, formats: [uncompressed]
Extension signature_algorithms, signature_algorithms: SHA512withECDSA, SHA512withRSA, SHA384withECDSA, SHA384withRSA, SHA256withECDSA, SHA256withRSA, SHA224withECDSA, SHA224withRSA, SHA1withECDSA, SHA1withRSA, SHA1withDSA, MD5withRSA
Extension renegotiation_info, renegotiated_connection: &lt;empty&gt;
***
main, WRITE: TLSv1.2 Handshake, length = 144
main, READ: TLSv1.2 Handshake, length = 1540
*** ServerHello, TLSv1.2
RandomCookie:  GMT: 1427463640 bytes = { 155, 184, 16, 18, 186, 249, 50, 70, 182, 75, 129, 217, 165, 78, 228, 255, 138, 98, 193, 58, 229, 70, 45, 1, 244, 84, 187, 235 }
Session ID:  {85, 21, 94, 216, 168, 186, 180, 208, 21, 40, 84, 147, 20, 244, 43, 97, 214, 18, 173, 27, 52, 175, 44, 1, 127, 20, 62, 126, 65, 229, 79, 1}
Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
Compression Method: 0
Extension renegotiation_info, renegotiated_connection: &lt;empty&gt;
***
%% Initialized:  [Session-1, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256]
** TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
main, handling exception: javax.net.ssl.SSLProtocolException: java.io.IOException: Only named ECParameters supported
%% Invalidated:  [Session-1, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256]
main, SEND TLSv1.2 ALERT:  fatal, description = unexpected_message
main, WRITE: TLSv1.2 Alert, length = 2
main, called closeSocket()
main, IOException in getSession():  javax.net.ssl.SSLProtocolException: java.io.IOException: Only named ECParameters supported
   Cipher suite = SSL_NULL_WITH_NULL_NULL
   Protocol = NONE
</code></pre>

<p>The curve is listed also among the curve-names. I have tried so many things now, I'm kind of stuck. Any help is highly appreciated.</p>
","","1640","<java><ssl><ecdsa>","1","","0","2015-03-27 14:26:40","","2","2","","","","2015-03-27 14:26:40",""
"38269867","Reading and writing OpenSSL ECDSA keys to PEM file","<p>I want to generate an ecdsa key pair and save it to PEM file. Here's the code that I generate the key.</p>

<pre><code>#include &lt;openssl/ec.h&gt;      // for EC_GROUP_new_by_curve_name, EC_GROUP_free, EC_KEY_new, EC_KEY_set_group, EC_KEY_generate_key, EC_KEY_free
#include &lt;openssl/ecdsa.h&gt;   // for ECDSA_do_sign, ECDSA_do_verify
#include &lt;openssl/obj_mac.h&gt; // for NID_secp256k1

/*
* Function generate_eckey
* -----------------------
*
* This function generates an EC_Key object that stores the ECDSA key pair.
*
* return: ec key pair
*/
EC_KEY * generate_eckey() {
    EC_KEY *eckey=EC_KEY_new();
    EC_GROUP *ecgroup= EC_GROUP_new_by_curve_name(NID_secp256k1);
    EC_KEY_set_group(eckey, ecgroup);
    EC_KEY_generate_key(eckey);

    return eckey;
}


int main() {

    // generate a eckey used to produce signatures
    EC_KEY *eckey = generate_eckey();

    return 0;
}
</code></pre>

<p>Now I have this key pair that can be used to sign and verify messages. What I want to do is save the information to a file so next time I can simply load it and use it.</p>

<p>I want to know how can I write and load the keys to a PEM file? Does openssl have an existing function to do so? I have no preference whether the keys are encoded in any format, as long as after loading I can use it. Any example would be great.</p>
","<blockquote>
  <p>I want to know how can I write and load the keys to a PEM file? Does openssl have an existing function to do so?</p>
</blockquote>

<p>Yes, OpenSSL has existing functions. For ASN.1/DER, use <a href=""http://www.openssl.org/docs/manmaster/crypto/d2i_X509.html"" rel=""nofollow noreferrer""><code>d2i_ECPrivateKey</code></a> and <a href=""http://www.openssl.org/docs/manmaster/crypto/d2i_X509.html"" rel=""nofollow noreferrer""><code>d2i_EC_PUBKEY</code></a>; and for PEM use <a href=""http://www.openssl.org/docs/manmaster/crypto/PEM_read_CMS.html"" rel=""nofollow noreferrer""><code>PEM_read_ECPrivateKey</code></a> and <a href=""http://www.openssl.org/docs/manmaster/crypto/PEM_read_CMS.html"" rel=""nofollow noreferrer""><code>PEM_read_EC_PUBKEY</code></a>. The write functions are similar and documented in the man pages.</p>

<p><code>d2i_*</code> is <em>""DER to internal""</em>, and its used to read ASN.1/DER keys. The write functions use <code>i2d_*</code> and its <em>""internal to DER""</em>. PEM does not use a cryptic prefix.</p>

<p>For an example of using <code>d2i_*</code> and <code>PEM_*</code> with RSA keys in a C++ program with the output, see <a href=""https://stackoverflow.com/q/30475758"">Use OpenSSL RSA key with .Net</a>. You can just swap-in your EC functions in place of the RSA ones.</p>

<hr>

<pre><code>EC_KEY * generate_eckey() {
    EC_KEY *eckey=EC_KEY_new();
    EC_GROUP *ecgroup= EC_GROUP_new_by_curve_name(NID_secp256k1);
    EC_KEY_set_group(eckey, ecgroup);
    EC_KEY_generate_key(eckey);

    return eckey;
}
</code></pre>

<p>Related, when you <em>write</em> your EC keys, be sure to use a named curve by calling<code>EC_KEY_set_asn1_flag(ecKey, OPENSSL_EC_NAMED_CURVE)</code>. If you don't then the keys could be of limited use. Also see <a href=""http://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography#Named_Curves"" rel=""nofollow noreferrer"">Elliptic Curve Cryptography | Named Curves</a> on the OpenSSL wiki.</p>

<p>Also, you are ignoring return values from functions like <code>EC_KEY_new</code> and <code>EC_KEY_generate_key</code>. You might want to rethink that strategy since those function can fail for non-obvious reasons, like a policy setting. Also see <a href=""http://www.openssl.org/docs/manmaster/crypto/EC_KEY_new.html"" rel=""nofollow noreferrer""><code>EC_KEY_new</code></a> man pages.</p>
","1622","<c><openssl><pem><ecdsa>","3","1","1","2016-07-08 19:10:14","","1","","608639","","2016-07-08 17:52:50","2016-07-08 15:03:25",""
"43980660","Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa","<p>I have the following problem, and cant find solution:</p>

<p>While consuming APN (Apple push notifications) API, i implemented tokenized authorization. It's apple's new way of authorization on their push notifications api. </p>

<p>Apple provides me private key, which i use to create c# CngKey object, which then i use to sign data.</p>

<pre><code>    CngKey key = CngKey.Import(
       Convert.FromBase64String(privateKey),
       CngKeyBlobFormat.Pkcs8PrivateBlob);

using (ECDsaCng dsa = new ECDsaCng(key))
{
    dsa.HashAlgorithm = CngAlgorithm.Sha256;
    var unsignedJwtData =
        Url.Base64urlEncode(Encoding.UTF8.GetBytes(header)) + ""."" + Url.Base64urlEncode(Encoding.UTF8.GetBytes(payload));
    var signature =
        dsa.SignData(Encoding.UTF8.GetBytes(unsignedJwtData));
    return unsignedJwtData + ""."" + Url.Base64urlEncode(signature);
}
</code></pre>

<p>The result is signed token, which i then use as authorization header while consuming API and sending push notifications. </p>

<p>It works well on my dev machine, but when i deploy it to Windows Server, when this code runs i get next:</p>

<pre><code>System.ArgumentException: Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa.
Parameter name: key
   at System.Security.Cryptography.ECDsaCng..ctor(CngKey key)
   at OTTCommon.Encryption.ECDSA.SignES256(String privateKey, String header, String payload, ILog log)
</code></pre>

<p>I cant find solution, it is something with windows key storage or something like that....</p>

<p>What should i do?</p>
","<p>This is fixed in the .NET Framework 4.6.2, so the easiest solution would perhaps be to get the server upgraded.</p>

<p>A workaround that works for NIST P-256, NIST P-384, and NIST P-521 is to change the dwMagic value in the blob export.  (It won't work for the Windows 10 Generic ECC, because the dwMagic values aren't aligned the same way).</p>

<pre><code>byte[] blob = key.Export(CngKeyBlobFormat.EccPrivateBlob);
key.Dispose();
</code></pre>

<p>The first 4 bytes of this blob map to the <code>dwMagic</code> value in the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa375520(v=vs.85).aspx"" rel=""noreferrer"">BCRYPT_ECCKEY_BLOB</a> structure.</p>

<p><code>BCRYPT_ECDH_PRIVATE_P256_MAGIC</code> has value <code>0x324B4345</code>, which is the Little-Endian representation of ""ECK2"" (Elliptic Curve Key-exchange 2).  <code>BCRYPT_ECDSA_PRIVATE_P256_MAGIC</code> has value <code>0x32534345</code>, which is the Little-Endian representation of ""ECS2"" (Elliptic Curve Signing 2).</p>

<pre><code>// Change it from Key-exchange (ECDH) to Signing (ECDSA)
blob[1] = 0x53;

key = CngKey.Import(blob, CngKeyBlobFormat.EccPrivateBlob);
</code></pre>

<p>And now it sees that it's an ECDSA key, and everything is happy.</p>
","1618","<c#><apple-push-notifications><ecdsa><apn><cng>","4","5","1","2017-05-15 14:56:41","43982666","0","2","","","","2017-05-15 13:18:11",""
"16617153","ECDSA: How to get y coordinate from uncompressing x using openssl","<p>What I am trying to do with ECDSA is take an x ""compressed"" coordinate and a y ""bit"" from values taken from external ECDSA hardware (it's really a public key) and then trying to recover the y coordinate (uncompressed) with OpenSSL function calls.</p>

<p>I am trying the following code, but it does not work as I expected (my xy[] array does not get populated with correct data).  Can anyone help?</p>

<p>I'm new to ECDSA and even newer to OpenSSL, but I was thinking I could do the following:</p>

<pre><code>enter code here


EC_GROUP *curve_group = EC_GROUP_new_by_curve_name(NID_X9_62_prime192v1);
EC_POINT *point;
BIGNUM *x_compressed = BN_new();
int y_chooser_bit = 1;
int results = 0;
size_t returnsize = 0;

unsigned char x_compressed_byte_array[25] = {0x02, 0x71, 0xc0, 0x73, 0x73, 
                                             0x9b, 0xbf, 0xc2, 0x0a, 
                                             0x81, 0xcd, 0xdd, 0xf4, 
                                             0xcf, 0xca, 0xc7, 0xb5, 
                                             0xa9, 0x99, 0x61, 0x23, 
                                             0x2c, 0x5c, 0x63, 0x7a};

unsigned char xy[49];

// create a big number from the unsigned char array
BN_bin2bn(&amp;x_compressed_byte_array[0],200,NULL); // length is in bits?

point = EC_POINT_new(curve_group);

results = EC_POINT_set_compressed_coordinates_GFp(curve_group, point, 
                                                  x_compressed,                                                               
                                                  y_chooser_bit, NULL);

returnsize = EC_POINT_point2oct(curve_group, point, 
                                POINT_CONVERSION_UNCOMPRESSED, 
                                &amp;xy[0], 49, NULL); // 49

// clean up allocated memory
BN_free(x_compressed);
EC_POINT_free(point);
EC_GROUP_free(curve_group);
</code></pre>
","<p>In this line of your code</p>

<pre><code>BN_bin2bn(&amp;x_compressed_byte_array[0],200,NULL); // length is in bits?
</code></pre>

<p>You should pass bn_compressed, the BIGNUM you created, to hold the converted result. And the length is in bytes.</p>

<pre><code>BN_bin2bn(&amp;x_compressed_byte_array[0],sizeof(x_compressed_byte_array),x_compressed);
</code></pre>

<p>After you set_compressed_coordinates, you can verify if the point you just created locate correctly in the group.</p>

<pre><code>if (!EC_POINT_is_on_curve(curve_group,point,NULL)) return 0;
</code></pre>

<p>To further examine the point coordinates (x,y), you can place this in your code.</p>

<pre><code>if (!EC_POINT_get_affine_coordinates_GFp(curve_group, point, x, y, NULL)) return 0;
fprintf(stdout, ""\point = (x,y)\n"");
fprintf(stdout, ""     x = 0x"");
BN_print_fp(stdout, x);
fprintf(stdout, ""\n     y = 0x"");
BN_print_fp(stdout, y);
fprintf(stdout, ""\n"");
</code></pre>

<p>Just remember to new/free BIGNUM x and y at the first/end of your function.</p>

<pre><code>BIGNUM *x, *y;
x = BN_new();
y = BN_new();

/* your code */

if(x) BN_free(x);
if(y) BN_free(y);
</code></pre>

<p>And it should work. The result xy[49] I have is</p>

<p>0x0471C073739BBFC20A81CDDDF4CFCAC7B7A99961232C5C637C388AB06AA7E43A2B5CFE2D7F3AC2DF910D6F8D8F209CD817</p>
","1549","<openssl><compression><point><ecdsa>","4","2","1","2013-05-20 06:14:58","16643599","0","","","","","2013-05-17 20:13:22",""
"52004341","Create EC private key from hex string","<p>I am wondering if this is a correct way to create PrivateKey object in Java from HEX string from this website: <a href=""https://kjur.github.io/jsrsasign/sample/sample-ecdsa.html"" rel=""nofollow noreferrer"">https://kjur.github.io/jsrsasign/sample/sample-ecdsa.html</a></p>

<p>Create a BigInteger from a HEX String:</p>

<pre><code>BigInteger priv = new BigInteger(privateKeyFromSite, 16);
</code></pre>

<p>And pass to this method:</p>

<pre><code>import java.math.BigInteger;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.spec.InvalidKeySpecException;

import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.jce.spec.ECPrivateKeySpec;


public static PrivateKey getPrivateKeyFromECBigIntAndCurve(BigInteger s, String curveName) {

    ECParameterSpec ecParameterSpec = ECNamedCurveTable.getParameterSpec(curveName);

    ECPrivateKeySpec privateKeySpec = new ECPrivateKeySpec(s, ecParameterSpec);
    try {
        KeyFactory keyFactory = KeyFactory.getInstance(EC);
        return keyFactory.generatePrivate(privateKeySpec);
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        e.printStackTrace();
        return null;
    }
}
</code></pre>
","<p>Yes it's correct, an EC private key is just a number. If you print out your <code>PrivateKey</code>, you'll see the X and Y coordinates of the corresponding public key.</p>

<p>For example, let's say the following key pair was generated (<code>secp256r1</code>):</p>

<ul>
<li><p>EC Private Key:<br>
<code>1b9cdf53588f99cea61c6482c4549b0316bafde19f76851940d71babaec5e569</code></p></li>
<li><p>EC Public Key:<br>
<code>0458ff2cd70c9a0897eb90a7c43d6a656bd76bb8089d52c259db6d9a45bfb37eb9882521c3b1e20a8bae181233b939174ee95e12a47bf62f41a62f1a20381a6f03</code></p></li>
</ul>

<p>We plug the private key bytes into your function:</p>

<pre><code>BigInteger priv = new BigInteger(""1b9cdf53588f99cea61c6482c4549b0316bafde19f76851940d71babaec5e569"", 16);
PrivateKey privateKey = getPrivateKeyFromECBigIntAndCurve(priv, ""secp256r1"");
System.out.println(privateKey);
</code></pre>

<p>And print it:</p>

<pre class=""lang-none prettyprint-override""><code>EC Private Key [91:05:8a:28:94:f9:5c:cb:c4:34:b8:69:e4:39:d4:57:59:c7:51:35]
        X: 58ff2cd70c9a0897eb90a7c43d6a656bd76bb8089d52c259db6d9a45bfb37eb9
        Y: 882521c3b1e20a8bae181233b939174ee95e12a47bf62f41a62f1a20381a6f03
</code></pre>

<p>As you can see, if you concatenate <code>04</code> + X + Y, you'll get the original <strong>public key</strong>, (<code>04</code> is the uncompressed EC point tag).</p>
","1501","<java><bouncycastle><elliptic-curve><ecdsa>","3","3","1","2019-10-03 13:06:00","52006151","1","2","","","","2018-08-24 12:18:49",""
"29924145","How to sign the Certificates with Elliptic curve private keys and ECDSA algorithm?","<p>I am able to sign the certificates using bouncy castle with RSA private Keys and ""SHA256withRSA "" algorithm.  I have used below link for reference to achieve this.
<a href=""https://stackoverflow.com/questions/7230330/sign-csr-using-bouncy-castle"">Sign CSR using Bouncy Castle</a></p>

<p>Now I have my CAs with Elliptic Curve keys signed with ECDSA. Hence I want to sign the certificates with EC key and ""SHA256withECDSA"" algorithm by these CAs. 
However I am stuck at below snippet specific to RSA key, I want to use EC key.</p>

<pre><code>ContentSigner sigGen = new BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(privateKeyParam);
</code></pre>

<p>Please help me how we can achieve Certificate signing with ECDSA and EC keys</p>
","<p>Below code used to sign the certificates with EC private keys </p>

<pre><code>ContentSigner sigGen = new JcaContentSignerBuilder(""SHA256withECDSA"").build(new JcaPEMKeyConverter().getPrivateKey(PrivateKeyInfo));
</code></pre>
","1465","<java><ssl><bouncycastle><elliptic-curve><ecdsa>","3","1","1","2016-05-12 12:27:31","37186879","2","0","-1","","2017-05-23 11:44:10","2015-04-28 15:54:04",""
"27232053","Creation of ECDSA private key given curve and private exponent?","<p>I am new to cryptopp and have been struggling for a while with the creation of  private keys for ECDSA signing.</p>

<p>I have a hex encoded private exponent <code>E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB</code>. This is stored as a string.</p>

<p>I want to use this to sign a text block using ECDSA.  My code looks a bit like this</p>

<pre><code>string Sig::genSignature(const string&amp; privKeyIn, const string&amp; messageIn)
{
   AutoSeededRandomPool prng;
   ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
   privateKey.AccessGroupParameters().Initialize(ASN1::secp256r1());
   privateKey.Load(StringSource(privKeyIn, true, NULL).Ref());
   ECDSA&lt;ECP, SHA256&gt;::Signer signer(privateKey);

   // Determine maximum size, allocate a string with that size
   size_t siglen = signer.MaxSignatureLength();
   string signature(siglen, 0x00);

   // Sign, and trim signature to actual size
   siglen = signer.SignMessage(prng, (const byte *) messageIn.data(), (size_t) messageIn.length(),       (byte*)signature.data());
   signature.resize(siglen);
   cout &lt;&lt; signature.data() &lt;&lt; endl;
   return signature;
}
</code></pre>

<p>This code generates the following error in Visual studio on the when I try to do privateKey.load(...)</p>

<pre><code>First-chance exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
Unhandled exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
</code></pre>

<p>I am guessing I am doing something a bit stupid... any help would be great???</p>

<p>PS I had a similar issue using ECDH for GMAC generation but got round this by saving the key as a SECByteBlock but this 'trick' doesnt seem to work in this case.</p>
","<blockquote>
  <p>DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr ...</p>
</blockquote>

<p>You have a private exponent, and <em>not</em> a private key. So you should <em>not</em> call <code>Load</code> on it. That's causing the Crypto++ <code>BERDecodeErr</code> exception.</p>

<p>The answer is detailed on the <a href=""http://www.cryptopp.com/wiki/Ecdsa#Private_Key_2"" rel=""nofollow"">ECDSA wiki page</a>, but its not readily apparent. You need to perform the following to initialize the <code>privateKey</code> given the curve and exponent::</p>

<pre><code>string exp = ""E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB"";
exp.insert(0, ""0x"");

Integer x(exp.c_str());
privateKey.Initialize(ASN1::secp256r1(), x);
</code></pre>

<p>Prepending the <code>""0x""</code> ensures the <code>Integer</code> class will parse the ASCII string correctly. You can also append a <code>""h""</code> character to the string. You can see the parsing code for <code>Integer</code> class at <a href=""http://www.cryptopp.com/docs/ref/integer_8cpp_source.html"" rel=""nofollow"">Integer.cpp</a> around line 2960 in the <code>StringToInteger</code> function.</p>

<hr>

<p>Here's another way to do the same thing:</p>

<pre><code>string exp = ""E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB"";

HexDecoder decoder;
decoder.Put((byte*)exp.data(), exp.size());
decoder.MessageEnd();

Integer x;
x.Decode(decoder, decoder.MaxRetrievable());

privateKey.Initialize(ASN1::secp256r1(), x);
</code></pre>

<p>The <a href=""http://www.cryptopp.com/wiki/Hexdecoder"" rel=""nofollow""><code>HexDecoder</code></a> will perform the ASCII to binary conversion for you. The buffer held by the <code>HexDecoder</code> will then be consumed by the <code>Integer</code> using its <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow""><code>Decode (BufferedTransformation &amp;bt, size_t inputLen, Signedness=UNSIGNED)</code></a> method.</p>

<hr>

<p>And here is another way using <a href=""http://www.cryptopp.com/wiki/Hexdecoder"" rel=""nofollow""><code>HexDecoder</code></a> (Crypto++ is as bad as scripting languages at times :)...</p>

<pre><code>string exp = ""E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB"";
StringSource ss(exp, true /*punpAll*/, new HexDecoder);

Integer x;
x.Decode(ss, ss.MaxRetrievable());

privateKey.Initialize(ASN1::secp256r1(), x);
</code></pre>

<hr>

<p>After initializing the key, you should validate it:</p>

<pre><code>bool result = privateKey.Validate( prng, 3 );
if( !result ) { /* Handle error */ }
</code></pre>

<hr>

<p>This will output binary data:</p>

<pre><code>cout &lt;&lt; signature.data() &lt;&lt; endl;
</code></pre>

<p>If you want something printable/readable, run it though a Crypto++ <a href=""http://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow"">HexEncoder</a>.</p>
","1447","<c++><private-key><crypto++><ecdsa><signer>","2","2","2","2015-06-16 23:05:21","27232308","2","1","15541","","2014-12-02 05:22:13","2014-12-01 15:50:43",""
"27232053","Creation of ECDSA private key given curve and private exponent?","<p>I am new to cryptopp and have been struggling for a while with the creation of  private keys for ECDSA signing.</p>

<p>I have a hex encoded private exponent <code>E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB</code>. This is stored as a string.</p>

<p>I want to use this to sign a text block using ECDSA.  My code looks a bit like this</p>

<pre><code>string Sig::genSignature(const string&amp; privKeyIn, const string&amp; messageIn)
{
   AutoSeededRandomPool prng;
   ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
   privateKey.AccessGroupParameters().Initialize(ASN1::secp256r1());
   privateKey.Load(StringSource(privKeyIn, true, NULL).Ref());
   ECDSA&lt;ECP, SHA256&gt;::Signer signer(privateKey);

   // Determine maximum size, allocate a string with that size
   size_t siglen = signer.MaxSignatureLength();
   string signature(siglen, 0x00);

   // Sign, and trim signature to actual size
   siglen = signer.SignMessage(prng, (const byte *) messageIn.data(), (size_t) messageIn.length(),       (byte*)signature.data());
   signature.resize(siglen);
   cout &lt;&lt; signature.data() &lt;&lt; endl;
   return signature;
}
</code></pre>

<p>This code generates the following error in Visual studio on the when I try to do privateKey.load(...)</p>

<pre><code>First-chance exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
Unhandled exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
</code></pre>

<p>I am guessing I am doing something a bit stupid... any help would be great???</p>

<p>PS I had a similar issue using ECDH for GMAC generation but got round this by saving the key as a SECByteBlock but this 'trick' doesnt seem to work in this case.</p>
","<p>for others looking for this later </p>

<pre><code>string genSignature(const string&amp; privKeyIn, const string&amp; messageIn)
{
    CryptoPP::Integer secretNumber(genSecretNumber(privKeyIn, messageIn));
    AutoSeededRandomPool secretNumberGenerator;

    if (encryptBase::debug)
    {
        cout &lt;&lt; ""secret number: "" &lt;&lt; secretNumber &lt;&lt; endl;
    }

    SecByteBlock message(convertHexStrToSecByteBlock(messageIn));
    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
    string exp(privKeyIn);
    exp.insert(0, ""0x"");
    Integer x(exp.c_str());
    privateKey.Initialize(ASN1::secp256r1(), x);
    AutoSeededRandomPool prng;
    if (!privateKey.Validate(prng, 3))
    {
        cout &lt;&lt; ""unable to verify key"" &lt;&lt; endl;
        return ""failed to verify key"";
    }

    ECDSA&lt;ECP, SHA256&gt;::Signer signer(privateKey);
    size_t siglen = signer.MaxSignatureLength();
    string signature(siglen, 0x00);
    siglen = signer.SignMessage(secretNumberGenerator, message.BytePtr(), message.size(),     (byte*)signature.data());
    signature.resize(siglen);

    string encoded;
    HexEncoder encoder;
    encoder.Put((byte *) signature.data(), signature.size());
    encoder.MessageEnd();
    word64 size = encoder.MaxRetrievable();
    if (size)
    {
        encoded.resize(size);
        encoder.Get((byte*)encoded.data(), encoded.size());
    }

    return encoded;
}
</code></pre>
","1447","<c++><private-key><crypto++><ecdsa><signer>","2","0","2","2015-06-16 23:05:21","27232308","2","1","15541","","2014-12-02 05:22:13","2014-12-01 15:50:43",""
"36342812","cryptographicexception the parameter is incorrect","<p>I am using ECDSA with SHA1 encryption because I am trying to make a licencing activation for a desktop application. For that I use a PHP server to which I give PC information and the server gives me the public the key and then I want to validate the data in C#.</p>

<p>I generated this public key in PHP:</p>

<pre><code>""-----BEGIN PUBLIC KEY-----
MDIwEAYHKoZIzj0CAQYFK4EEAAYDHgAEKzL3PFVVo3IWftdEYmwiSO/4zULGM/wB
8BrLjQ==
-----END PUBLIC KEY-----"";
</code></pre>

<p>I used the code from here <a href=""http://securitydriven.net/inferno/"" rel=""nofollow"">http://securitydriven.net/inferno/</a> To get to this</p>

<pre><code>byte[] thePublicKeyToBytes = GetBytesFromPEM(thePublicKey2, ""PUBLIC KEY"");
CngKey dsaKeyPublic2 = thePublicKeyToBytes.ToPublicKeyFromBlob();

byte[] theRestToBytes = GetBytes(theRestInBinary);
byte[] meinData = GetBytes(""Blabla"");

using (var ecdsa = new ECDsaCng(dsaKeyPublic2) { HashAlgorithm = CngAlgorithm.Sha1 }) // verify DSA signature with public key
{
    if (ecdsa.VerifyData(meinData, theRestToBytes)) MessageBox.Show(""Signature verified."");
    else MessageBox.Show(""Signature verification failed."");
}
</code></pre>

<p>where the procedure is:</p>

<pre><code>byte[] GetBytesFromPEM(string pemString, string section)
{
    var header = String.Format(""-----BEGIN {0}-----"", section);
    var footer = String.Format(""-----END {0}-----"", section);

    var start = pemString.IndexOf(header, StringComparison.Ordinal) + header.Length;
    var end = pemString.IndexOf(footer, start, StringComparison.Ordinal) - start;

    if (start &lt; 0 || end &lt; 0)
    {
        return null;
    }

    return Convert.FromBase64String(pemString.Substring(start, end));
}
</code></pre>

<p>The problem is that I get this exception ""cryptographicexception the parameter is incorrect"" at this line:</p>

<pre><code>CngKey dsaKeyPublic2 = thePublicKeyToBytes.ToPublicKeyFromBlob();
</code></pre>

<p>I can't show the inferno's public key, but I saw that the length of their key is 384. Is this where I am doing it wrong? The length of the generated public key?</p>
","<p>Your public key is 52 bytes long - it is too short. How are you generating it?<br>
The <code>ToPublicKeyFromBlob()</code> method is a shortcut for <code>return CngKey.Import(byteArray, CngKeyBlobFormat.EccPublicBlob)</code> - it works only on Ecc-based keys, and those generated by .NET. <a href=""http://SecurityDriven.NET/inferno/"" rel=""nofollow noreferrer"">Inferno</a> uses ECC keys over P384 curve, which means that each public key will have 48*2=96 bytes, plus 8 header bytes (as described <a href=""https://stackoverflow.com/questions/22762380/importing-ecc-based-certificate-from-the-windows-certificate-store-into-cngkey"">here</a>), for a total of 104 bytes.</p>
","1411","<c#><php><ecdsa>","0","1","2","2016-04-04 21:30:07","","0","","","","","2016-03-31 20:10:14",""
"36342812","cryptographicexception the parameter is incorrect","<p>I am using ECDSA with SHA1 encryption because I am trying to make a licencing activation for a desktop application. For that I use a PHP server to which I give PC information and the server gives me the public the key and then I want to validate the data in C#.</p>

<p>I generated this public key in PHP:</p>

<pre><code>""-----BEGIN PUBLIC KEY-----
MDIwEAYHKoZIzj0CAQYFK4EEAAYDHgAEKzL3PFVVo3IWftdEYmwiSO/4zULGM/wB
8BrLjQ==
-----END PUBLIC KEY-----"";
</code></pre>

<p>I used the code from here <a href=""http://securitydriven.net/inferno/"" rel=""nofollow"">http://securitydriven.net/inferno/</a> To get to this</p>

<pre><code>byte[] thePublicKeyToBytes = GetBytesFromPEM(thePublicKey2, ""PUBLIC KEY"");
CngKey dsaKeyPublic2 = thePublicKeyToBytes.ToPublicKeyFromBlob();

byte[] theRestToBytes = GetBytes(theRestInBinary);
byte[] meinData = GetBytes(""Blabla"");

using (var ecdsa = new ECDsaCng(dsaKeyPublic2) { HashAlgorithm = CngAlgorithm.Sha1 }) // verify DSA signature with public key
{
    if (ecdsa.VerifyData(meinData, theRestToBytes)) MessageBox.Show(""Signature verified."");
    else MessageBox.Show(""Signature verification failed."");
}
</code></pre>

<p>where the procedure is:</p>

<pre><code>byte[] GetBytesFromPEM(string pemString, string section)
{
    var header = String.Format(""-----BEGIN {0}-----"", section);
    var footer = String.Format(""-----END {0}-----"", section);

    var start = pemString.IndexOf(header, StringComparison.Ordinal) + header.Length;
    var end = pemString.IndexOf(footer, start, StringComparison.Ordinal) - start;

    if (start &lt; 0 || end &lt; 0)
    {
        return null;
    }

    return Convert.FromBase64String(pemString.Substring(start, end));
}
</code></pre>

<p>The problem is that I get this exception ""cryptographicexception the parameter is incorrect"" at this line:</p>

<pre><code>CngKey dsaKeyPublic2 = thePublicKeyToBytes.ToPublicKeyFromBlob();
</code></pre>

<p>I can't show the inferno's public key, but I saw that the length of their key is 384. Is this where I am doing it wrong? The length of the generated public key?</p>
","<p>Andrei, <a href=""http://SecurityDriven.NET/inferno/"" rel=""nofollow"">Inferno</a> uses the NIST P-384 curve only. More importantly, the only curves supported by .NET framework (out-of-the-box) are P-256, P-384, and P-521.</p>
","1411","<c#><php><ecdsa>","0","0","2","2016-04-04 21:30:07","","0","","","","","2016-03-31 20:10:14",""
"32991501","How to verify ecdsa-with-SHA256 signature with PHP?","<p>I have encountered the following issue while developing a secure system:</p>

<p>We receive some data which we have to verify by signature. The signature algorithm is ecdsa-with-SHA256, and <a href=""http://php.net/manual/ru/function.openssl-verify.php"" rel=""nofollow"">openssl_verify()</a> doesn't seem to have an option for that. Already tried searching for standalone PHP libraries like phpseclib - no luck either, ecdsa-with-SHA1 is the best option they seem to offer.</p>

<p>What would be an appropriate solution for that issue? Maybe I've missed some library that implements such functionality?</p>
","<p>PHP's <code>openssl_</code> currently supports ECDSA only with SHA1 digest (reefer to <a href=""http://php.net/manual/en/function.openssl-get-md-methods.php"" rel=""nofollow noreferrer""><code>openssl_get_md_methods()</code></a> output, position <code>[14]</code>). You'll need a workaround for this. From comments of <a href=""https://stackoverflow.com/questions/20386230/implementing-secp256k1-ecdsa-in-php-for-bitcoin"">this question</a> (<em>closed as off topic, by the way)</em>, but it was focused on bitcoin implementations.</p>
","1407","<php><sha><ecdsa>","2","2","1","2015-10-07 12:39:15","32992458","0","1","","","","2015-10-07 11:52:08",""
"21079564","How to verify ECDSA signature with Crypto++ without the verify function?","<p>I made a Signer/Checker mechanisms with ECDSA using Crypto++.</p>

<p>The problem is when I want to check signature it doesn't work with Verify function.</p>

<p>Can you propose me a more manual way to verify signature?</p>
","<blockquote>
  <p>How to verify ECDSA signature with Crypto++ without the verify function?</p>
</blockquote>

<p>I'm not sure how you would verify code without a verify function. I'm probably not understanding the question.</p>

<p>Just in case, here's how Crypto++ implements its verification code.</p>

<p>First, <code>ECDSA</code> is a <code>DL_Algorithm_ECDSA</code> (from <code>eccrypto.h</code>):</p>

<pre><code>//! ECDSA algorithm
template &lt;class EC&gt;
class DL_Algorithm_ECDSA : public DL_Algorithm_GDSA&lt;typename EC::Point&gt;
{
public:
    static const char * CRYPTOPP_API StaticAlgorithmName() {return ""ECDSA"";}
};
...

template &lt;class EC, class H&gt;
struct ECDSA :
    public DL_SS&lt;DL_Keys_ECDSA&lt;EC&gt;, DL_Algorithm_ECDSA&lt;EC&gt;,
               DL_SignatureMessageEncodingMethod_DSA, H&gt;
{
};
</code></pre>

<p>Next, here's verify function from <code>DL_Algorithm_GDSA</code> in <code>gfcrypt.h</code>:</p>

<pre><code>bool Verify(const DL_GroupParameters&lt;T&gt; &amp;params, const DL_PublicKey&lt;T&gt; &amp;publicKey,
                const Integer &amp;e, const Integer &amp;r, const Integer &amp;s) const
{
    const Integer &amp;q = params.GetSubgroupOrder();
    if (r&gt;=q || r&lt;1 || s&gt;=q || s&lt;1)
        return false;

    Integer w = s.InverseMod(q);
    Integer u1 = (e * w) % q;
    Integer u2 = (r * w) % q;

    return r == params.ConvertElementToInteger(
                    publicKey.CascadeExponentiateBaseAndPublicElement(u1, u2)) % q;
}
</code></pre>

<hr>

<p>The code below uses <code>VerifyMessage</code>, and its part of <code>PK_Verifier</code> declared in <code>cryptolib.h</code>:</p>

<pre><code>virtual bool VerifyMessage(const byte *message, size_t messageLen, 
                 const byte *signature, size_t signatureLength) const;
</code></pre>

<p><code>PK_Verifier</code> is the 'master' base class that objects like <code>ECDSA</code>, <code>NR</code>, and <code>RSASS</code> use to expose the consistent interface.</p>

<p>Objects like <code>ECDSA</code>, <code>NR</code>, and <code>RSASS</code> connect to <code>PK_Verifier</code> via the <code>DL_SS</code>:</p>

<pre><code>template &lt;class EC, class H&gt;
struct ECDSA :
    public DL_SS&lt;DL_Keys_ECDSA&lt;EC&gt;, DL_Algorithm_ECDSA&lt;EC&gt;, DL_SignatureMessageEncodingMethod_DSA, H&gt;
{
};
</code></pre>

<p>Finally, here's how <code>DL_SS</code> relates to <code>PK_Verifier</code> (from <code>pubkey.h</code>):</p>

<pre><code>//! Discrete Log Based Signature Scheme
template &lt;class KEYS, class SA, class MEM, class H, class ALG_INFO = DL_SS&lt;KEYS, SA, MEM, H, int&gt; &gt;
class DL_SS : public KEYS
{
    typedef DL_SignatureSchemeOptions&lt;ALG_INFO, KEYS, SA, MEM, H&gt; SchemeOptions;
    ...

    //! implements PK_Signer interface
    typedef PK_FinalTemplate&lt;DL_SignerImpl&lt;SchemeOptions&gt; &gt; Signer;
    //! implements PK_Verifier interface
    typedef PK_FinalTemplate&lt;DL_VerifierImpl&lt;SchemeOptions&gt; &gt; Verifier;
};
</code></pre>

<hr>

<blockquote>
  <p>The problem is when I want to check signature it doesn't work with Verify function.</p>
</blockquote>

<p>There's lots of code available on the Crypto++ wiki. For ECDSA, see <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow"">Elliptic Curve Digital Signature Algorithm</a>. Below is a signing a verification sample taken from the wiki.</p>

<p><strong>Sign</strong></p>

<pre><code>AutoSeededRandomPool prng;

ECDSA&lt;ECP, SHA1&gt;::PrivateKey privateKey;
privateKey.Load(...);
privateKey.Validate(prng, 3);

ECDSA&lt;ECP, SHA1&gt;::Signer signer(privateKey);

string message = ""Do or do not. There is no try."";

// Determine maximum size, allocate a string with the maximum size
size_t siglen = signer.MaxSignatureLength();
string signature(siglen, 0x00);

// Sign, and trim signature to actual size
siglen = signer.SignMessage( prng, message.data(), message.size(), signature.data() );
signature.resize(siglen);
</code></pre>

<p><strong>Verify</strong></p>

<pre><code>AutoSeededRandomPool prng;

ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey;
publicKey.Load(...);
publicKey.Validate(prng, 3);

ECDSA&lt;ECP, SHA1&gt;::Verifier verifier(publicKey);

bool result = verifier.VerifyMessage( message.data(), message.size(), signature.data(), signature.size() );
if(result)
  cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
else
  cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; endl;
</code></pre>
","1358","<digital-signature><crypto++><ecdsa>","0","1","1","2014-01-13 10:26:56","","1","","","","","2014-01-12 19:58:04",""
"15113781","ECDSA Signatures always return false on verification","<p>I have 3 test keys  RSA, DSA and ECDSA. The RSA and DSA key-based signatures return true when verified. But the ECDSA-based signature always returns false (even when the signatures match).</p>

<p>The same code is used to verify all 3 test keys (apart from the differences in the provider object passed to <code>Signature.getInstance()</code>). My code is as follows:</p>

<pre><code>Signature ecdsa = Signature.getInstance(""SHA1withECDSA"");
ecdsa.initSign(pk);
ecdsa.update(rawKeyBytes);
byte[] signatureBytes = ecdsa.sign(); 

Signature ecdsa3 = Signature.getInstance(""SHA1WithECDSA"");
ecdsa3.initVerify(puk);  
ecdsa3.update(rawKeyBytes);
System.out.println(""Verifying: ""+ecdsa3.verify(signatureBytes));
</code></pre>

<p>The output of the program is always <code>Verifying: false</code>. When I change the provider to <code>SHA1WithRSA</code> and use an RSA key (using the same code above), the verification returns true, same with DSA-based keys. Someone mentioned it had something to do with the <code>ECPoint</code> passed to the <code>ECPublicKeySpec()</code> constructor, when trying to create a public key from the private key like this:</p>

<pre><code>ECPrivateKey ec = (ECPrivateKey) privateKey;
ECPublicKeySpec ecKeySpec = new ECPublicKeySpec(
    ec.getParams().getGenerator(),
    ec.getParams()
);
</code></pre>

<p>Someone mentioned that signature verification (using the public key) would fail if a different <code>ECPoint</code> was used from the private key. But I actually get the <code>ECPoint</code> from the <code>PrivateKey</code> object (<code>ec</code>). Any solutions, please?</p>
","","1357","<java><digital-signature><ecdsa>","1","","0","2015-06-18 15:53:35","","7","1","1816580","","2015-06-18 15:53:35","2013-02-26 12:22:52",""
"15966846","InvalidCastException on c# bouncy castle verify signature","<p>I try to verify an ecdsa (256) signature, the only data I have to do it is the public key in the given format below, the original data and the signature:</p>

<pre><code>        string pubKey_ecdsa = ""MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE+noecsW+vdfd8DNo5dsAxU4DOaNt6PGmSCLFo/EvQG4xmVzv464qXvDPIrPN8GtLnubzoa9rtWJD52VlGOpFsA=="";

        string data_ecdsa = "";\""4399901526945\"";\""AAAA-BBBBBBBBB-123456789000\"";\""5010112544615\"";\""20130802063109143\"";"";

        string signature_ecdsa = @""BEcwRQIgJFwnCvm8lRjlRt+G+f4viJktDYVyOiXUd5BJ0V761eECIQDBTHLjJI7KK3FhczEHjunenYWXylDdW91jbS23EmeznA=="";
</code></pre>

<p>When I try to use bouncy castle to verify the signature by calling:</p>

<pre><code>        //Create the public key from string
        AsymmetricKeyParameter pubKey = PublicKeyFactory.CreateKey(Convert.FromBase64String(pubKey_ecdsa));

        // create byte array from string
        byte[] b_signature = Convert.FromBase64String(signature_ecdsa);

        ASCIIEncoding encoder = new ASCIIEncoding();
        byte[] inputData = encoder.GetBytes(data_ecdsa);
        ISigner signer = SignerUtilities.GetSigner(""SHA-256withECDSA"");
        signer.Init(false, pubKey);
        signer.BlockUpdate(inputData, 0, inputData.Length);

        bool valid =  signer.VerifySignature(b_signature);
</code></pre>

<p>I receive an <code>InvalidCastException</code>: </p>

<pre><code>Unable to cast object of type 'Org.BouncyCastle.Asn1.DerOctetString'
to type 'Org.BouncyCastle.Asn1.Asn1Sequence'. 
</code></pre>

<p>at the following line:</p>

<pre><code>bool valid =  signer.VerifySignature(b_signature);
</code></pre>

<p>So, something seems wrong with the signature, but I can not figure out. I hope anybody could help with an good idea.</p>

<p>By the way, the provided data in this example was modified, so the signature would be evaluated to false, if it would work.</p>
","<p>This may be too late to help, but for the benefit of later readers:</p>

<p>A DSA signature is expected to be the ASN.1 encoding of a SEQUENCE containing two INTEGERs. The problem here is that b_signature is actually an OCTET STRING, with the octets inside it being the correct encoding. So there is an extra ""outer"" wrapping around the real signature. You can see this by dumping out the structure:</p>

<pre><code>Asn1OctetString outer =(Asn1OctetString)Asn1Object.FromByteArray(b_signature);
byte[] inner = outer.GetOctets();

Console.WriteLine(Asn1Dump.DumpAsString(outer));
Console.WriteLine(Asn1Dump.DumpAsString(Asn1Object.FromByteArray(inner)));
</code></pre>

<p>For me, this prints:</p>

<blockquote>
  <p>DER Octet String[71]</p>
  
  <p>DER Sequence
      Integer(16446081942964531772961165410855935370418106604815444975891408706004345083361)
      Integer(87431453076334980518600256741994746667679967157867025465393185500427926877084)</p>
</blockquote>

<p>So, the 'inner' octets look to be correctly encoded. Now:</p>

<pre><code>bool valid = signer.VerifySignature(inner);
</code></pre>

<p>For me, this prints 'false', which you say is expected because the data has been modified.</p>
","1354","<c#><bouncycastle><signature><ecdsa>","2","3","1","2013-06-24 12:00:59","17274982","2","","1371805","","2013-04-12 08:48:56","2013-04-12 08:45:04",""
"45107057","Creating X509Certificate2 from ECC X509Certificate throws 'System.NotSupportedException' in C#","<p>I need to import ECC certificates into Windows Key Stores in C#.  As the first step, I am using BouncyCastle to generate an EC key pair, create an X509 certificate with the public key, and sign it with the ECDSA and private key, i.e.,:</p>

<pre><code>            var ecKeyPairGenerator = new ECKeyPairGenerator(""ECDSA"");
            ECKeyGenerationParameters ecKeyGenParams =
                new ECKeyGenerationParameters(SecObjectIdentifiers.SecP384r1, new SecureRandom());
            ecKeyPairGenerator.Init(ecKeyGenParams);
            AsymmetricCipherKeyPair pair = ecKeyPairGenerator.GenerateKeyPair();
            PrivateKeyInfo privKeyInfo = PrivateKeyInfoFactory.CreatePrivateKeyInfo(pair.Private);
            SubjectPublicKeyInfo pubKeyInfo = SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(pair.Public);

            X509V3CertificateGenerator bcX509Gen = new X509V3CertificateGenerator();
// set cert fields
...
            bcX509Gen.SetPublicKey(pair.Public);
            Asn1SignatureFactory bcSigFactory =
                    new Asn1SignatureFactory(X9ObjectIdentifiers.ECDsaWithSha384.Id, pair.Private);
            X509Certificate bcCert = bcX509Gen.Generate(bcSigFactory);
</code></pre>

<p>Then, I create an X509Certificate2 with the certificate created above, i.e.,:</p>

<pre><code>    SystemX509.X509Certificate2 msCert2 = 
        new SystemX509.X509Certificate2(bcCert.GetEncoded(), (string)null);
</code></pre>

<p>However, an exception is raised in creating the X509Certificate2:</p>

<pre><code>'msCert2.PublicKey.Key' threw an exception of type 'System.NotSupportedException'
""The certificate key algorithm is not supported.""
</code></pre>

<p>Using BC's DotNetUtilities.ToX509Certificate() results in the same exception.</p>

<p>I'm aware that the support for ECC certificates on Windows / .NET may not be complete, but my searches on the web seem to suggest that this should be possible?  Any ideas what I'm doing wrong?</p>

<p>FYI, I'm using VS Community 2017, and my project has the target of .NET Framework 4.6.2.</p>

<p>Thanks!</p>
","<p><code>PublicKey.Key</code> is unofficially deprecated (along with <code>PrivateKey</code>).  It doesn't support ECC, and doesn't produce an RSA key that is capable of doing OAEP-SHA-2 encryption or DSA key capable of doing FIPS 186-3 DSA.</p>

<p>Instead you want to use the extension methods which don't require casting:</p>

<pre><code>// GetECDsaPublicKey returns a unique object every call,
// so you're responsible for Disposing it (lest it end up on the Finalizer queue)
using (ECDsa ecdsa = msCert2.GetECDsaPublicKey())
{
    // do stuff with the public key object
}
</code></pre>
","1352","<c#><.net><bouncycastle><x509certificate2><ecdsa>","2","3","1","2017-07-14 16:13:45","45107458","0","","","","","2017-07-14 15:49:02",""
"44808132","Using openssh public key (ecdsa-sha2-nistp256) with Java Security","<p>Is there a Java library/example to read an openssh format ecdsa public key to a JCE <code>PublicKey</code> in Java? I want to use EC for <a href=""https://jwt.io"" rel=""nofollow noreferrer"">JWT</a> .</p>

<p>The format I'm trying to read is as per authorized_keys, or Github API (e.g. <a href=""https://api.github.com/users/davidcarboni/keys"" rel=""nofollow noreferrer"">https://api.github.com/users/davidcarboni/keys</a>):  <code>ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK8hPtB72/sfYgNw1WTska2DNOJFx+QhUxuV6OLINSD2ty+6gxcM8yZrvMqWdMePGRb2cGh8L/0bGOk+64IQ/pM=</code></p>

<p>I've found this answer, which is fine for RSA and DSS:
<a href=""https://stackoverflow.com/questions/3531506/using-public-key-from-authorized-keys-with-java-security"">Using public key from authorized_keys with Java security</a>, and this discussion of the openssh format for ECDSA: <a href=""https://security.stackexchange.com/questions/129910/ecdsa-why-do-ssh-keygen-and-java-generated-public-keys-have-different-sizes"">https://security.stackexchange.com/questions/129910/ecdsa-why-do-ssh-keygen-and-java-generated-public-keys-have-different-sizes</a> </p>

<p>However I'm getting lost trying to adapt the RSS/DSA code for ECDSA - I'm not sure how to set up an <a href=""https://docs.oracle.com/javase/7/docs/api/java/security/spec/ECPublicKeySpec.html"" rel=""nofollow noreferrer""><code>ECPublicKeySpec</code></a>. It needs <code>ECPoint</code>, <code>EllipticCurve</code>, <code>ECParameterSpec</code>, <code>ECField</code>. The openssh format only contains two integers, which makes sense for <code>ECPoint</code>, but I don't know how to set up the rest.</p>

<p>I've been poking around a bunch of libraries, including <a href=""http://www.jcraft.com/jsch/"" rel=""nofollow noreferrer"">jsch</a>, <a href=""https://github.com/hierynomus/sshj"" rel=""nofollow noreferrer"">sshj</a>, <a href=""https://www.sshtools.com/en/products/opensource/"" rel=""nofollow noreferrer"">ssh-tools</a> and good old <a href=""http://www.bouncycastle.org/"" rel=""nofollow noreferrer"">Bouncycastle</a>. The closest I have is:</p>

<p><code>com.jcraft.jsch.KeyPair load = com.jcraft.jsch.KeyPair.load(jsch, null, bytes[openSshKey]);</code></p>

<p>Which loads the key fine, but doesn't get me to a JCE <code>PublicKey</code> - just a <code>byte[] getPublicKeyBlob()</code> method.</p>

<p>Am I missing something obvious?</p>
","<p>I've found a way to do this using Bouncycastle (but would like to find a JCE way).</p>

<p>Adapting the code from <a href=""https://stackoverflow.com/questions/3531506/using-public-key-from-authorized-keys-with-java-security"">Using public key from authorized_keys with Java security</a>, and refering to <a href=""https://tools.ietf.org/html/rfc5656#section-3.1"" rel=""nofollow noreferrer"">RFC 5656, section 3.1</a>, the following block added to <code>decodePublicKey</code> will parse the single BigInt value Q, which is ""the public key encoded from an elliptic curve point"":</p>

<pre><code>if (type.startsWith(""ecdsa-sha2-"") &amp;&amp;
            (type.endsWith(""nistp256"") || type.endsWith(""nistp384"") || type.endsWith(""nistp521""))) {

        // Based on RFC 5656, section 3.1 (https://tools.ietf.org/html/rfc5656#section-3.1)

        // The string [identifier] is the identifier of the elliptic curve
        // domain parameters.  The format of this string is specified in
        // Section 6.1 (https://tools.ietf.org/html/rfc5656#section-6.1).
        // Information on the REQUIRED and RECOMMENDED sets of
        // elliptic curve domain parameters for use with this algorithm can be
        // found in Section 10 (https://tools.ietf.org/html/rfc5656#section-10).
        String identifier = decodeType();
        if (!type.endsWith(identifier)) {
            throw new IllegalArgumentException(""Invalid identifier "" + identifier + "" for key type "" + type + ""."");
        }

        // Q is the public key encoded from an elliptic curve point into an
        // octet string as defined in Section 2.3.3 of [SEC1];
        // (https://tools.ietf.org/html/rfc5656#ref-SEC1)
        // point compression MAY be used.
        BigInteger q = decodeBigInt();

        ECPublicKey keyBC = getKeyBC(q, identifier);
        return keyBC;
    }
</code></pre>

<p>The solution I've found for getting from Q to an <code>ECPublicKey</code> is the following, using the Bouncycastle API (credit to <a href=""https://stackoverflow.com/questions/42639620/generate-ecpublickey-from-ecprivatekey"">Generate ECPublicKey from ECPrivateKey</a> for providing the starting point):</p>

<pre><code>ECPublicKey getKeyBC(BigInteger q, String identifier) {
    // https://stackoverflow.com/questions/42639620/generate-ecpublickey-from-ecprivatekey
    try {
        // This only works with the Bouncycastle library:
        Security.addProvider(new BouncyCastleProvider());
        // http://www.bouncycastle.org/wiki/pages/viewpage.action?pageId=362269#SupportedCurves(ECDSAandECGOST)-NIST(aliasesforSECcurves)
        String name = identifier.replace(""nist"", ""sec"") + ""r1"";
        KeyFactory keyFactory = KeyFactory.getInstance(""ECDSA"", ""BC"");
        ECNamedCurveParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(name);
        ECPoint point = ecSpec.getCurve().decodePoint(q.toByteArray());
        ECPublicKeySpec pubSpec = new ECPublicKeySpec(point, ecSpec);
        ECPublicKey publicKey = (ECPublicKey) keyFactory.generatePublic(pubSpec);
        return publicKey;
    } catch (NoSuchAlgorithmException | InvalidKeySpecException | NoSuchProviderException e) {
        throw new RuntimeException(e);
    }
}
</code></pre>

<p>That gets you from an openssh format elliptic curve public key (<code>ssh-keygen -t ecdsa -b [256|384|521]</code>) to a JCE <code>ECPublicKey</code>.</p>
","1351","<java><openssh><jce><elliptic-curve><ecdsa>","1","0","2","2017-07-06 14:39:45","44907432","2","","723506","","2017-06-29 15:32:28","2017-06-28 16:34:46",""
"44808132","Using openssh public key (ecdsa-sha2-nistp256) with Java Security","<p>Is there a Java library/example to read an openssh format ecdsa public key to a JCE <code>PublicKey</code> in Java? I want to use EC for <a href=""https://jwt.io"" rel=""nofollow noreferrer"">JWT</a> .</p>

<p>The format I'm trying to read is as per authorized_keys, or Github API (e.g. <a href=""https://api.github.com/users/davidcarboni/keys"" rel=""nofollow noreferrer"">https://api.github.com/users/davidcarboni/keys</a>):  <code>ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK8hPtB72/sfYgNw1WTska2DNOJFx+QhUxuV6OLINSD2ty+6gxcM8yZrvMqWdMePGRb2cGh8L/0bGOk+64IQ/pM=</code></p>

<p>I've found this answer, which is fine for RSA and DSS:
<a href=""https://stackoverflow.com/questions/3531506/using-public-key-from-authorized-keys-with-java-security"">Using public key from authorized_keys with Java security</a>, and this discussion of the openssh format for ECDSA: <a href=""https://security.stackexchange.com/questions/129910/ecdsa-why-do-ssh-keygen-and-java-generated-public-keys-have-different-sizes"">https://security.stackexchange.com/questions/129910/ecdsa-why-do-ssh-keygen-and-java-generated-public-keys-have-different-sizes</a> </p>

<p>However I'm getting lost trying to adapt the RSS/DSA code for ECDSA - I'm not sure how to set up an <a href=""https://docs.oracle.com/javase/7/docs/api/java/security/spec/ECPublicKeySpec.html"" rel=""nofollow noreferrer""><code>ECPublicKeySpec</code></a>. It needs <code>ECPoint</code>, <code>EllipticCurve</code>, <code>ECParameterSpec</code>, <code>ECField</code>. The openssh format only contains two integers, which makes sense for <code>ECPoint</code>, but I don't know how to set up the rest.</p>

<p>I've been poking around a bunch of libraries, including <a href=""http://www.jcraft.com/jsch/"" rel=""nofollow noreferrer"">jsch</a>, <a href=""https://github.com/hierynomus/sshj"" rel=""nofollow noreferrer"">sshj</a>, <a href=""https://www.sshtools.com/en/products/opensource/"" rel=""nofollow noreferrer"">ssh-tools</a> and good old <a href=""http://www.bouncycastle.org/"" rel=""nofollow noreferrer"">Bouncycastle</a>. The closest I have is:</p>

<p><code>com.jcraft.jsch.KeyPair load = com.jcraft.jsch.KeyPair.load(jsch, null, bytes[openSshKey]);</code></p>

<p>Which loads the key fine, but doesn't get me to a JCE <code>PublicKey</code> - just a <code>byte[] getPublicKeyBlob()</code> method.</p>

<p>Am I missing something obvious?</p>
","<p>For completeness, here's the code I've gone with. It's nearly-pure JCE, with a sprinkling of Bouncycastle inside helper methods (this updates the example code in <a href=""https://stackoverflow.com/questions/3531506/using-public-key-from-authorized-keys-with-java-security"">Using public key from authorized_keys with Java security</a>):</p>

<pre><code>...
        } else if (type.startsWith(""ecdsa-sha2-"") &amp;&amp;
                (type.endsWith(""nistp256"") || type.endsWith(""nistp384"") || type.endsWith(""nistp521""))) {
            // Based on RFC 5656, section 3.1 (https://tools.ietf.org/html/rfc5656#section-3.1)
            String identifier = decodeType();
            BigInteger q = decodeBigInt();
            ECPoint ecPoint = getECPoint(q, identifier);
            ECParameterSpec ecParameterSpec = getECParameterSpec(identifier);
            ECPublicKeySpec spec = new ECPublicKeySpec(ecPoint, ecParameterSpec);
            return KeyFactory.getInstance(""EC"").generatePublic(spec);
        } ...

/**
 * Provides a means to get from a parsed Q value to the X and Y point values.
 * that can be used to create and ECPoint compatible with ECPublicKeySpec.
 *
 * @param q          According to RFC 5656:
 *                   ""Q is the public key encoded from an elliptic curve point into an octet string""
 * @param identifier According to RFC 5656:
 *                   ""The string [identifier] is the identifier of the elliptic curve domain parameters.""
 * @return An ECPoint suitable for creating a JCE ECPublicKeySpec.
 */
ECPoint getECPoint(BigInteger q, String identifier) {
    String name = identifier.replace(""nist"", ""sec"") + ""r1"";
    ECNamedCurveParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(name);
    org.bouncycastle.math.ec.ECPoint point = ecSpec.getCurve().decodePoint(q.toByteArray());
    BigInteger x = point.getAffineXCoord().toBigInteger();
    BigInteger y = point.getAffineYCoord().toBigInteger();
    System.out.println(""BC x = "" + x);
    System.out.println(""BC y = "" + y);
    return new ECPoint(x, y);
}

/**
 * Gets the curve parameters for the given key type identifier.
 *
 * @param identifier According to RFC 5656:
 *                   ""The string [identifier] is the identifier of the elliptic curve domain parameters.""
 * @return An ECParameterSpec suitable for creating a JCE ECPublicKeySpec.
 */
ECParameterSpec getECParameterSpec(String identifier) {
    try {
        // http://www.bouncycastle.org/wiki/pages/viewpage.action?pageId=362269#SupportedCurves(ECDSAandECGOST)-NIST(aliasesforSECcurves)
        String name = identifier.replace(""nist"", ""sec"") + ""r1"";
        AlgorithmParameters parameters = AlgorithmParameters.getInstance(""EC"");
        parameters.init(new ECGenParameterSpec(name));
        return parameters.getParameterSpec(ECParameterSpec.class);
    } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
        throw new IllegalArgumentException(""Unable to get parameter spec for identifier "" + identifier, e);
    }
}
</code></pre>
","1351","<java><openssh><jce><elliptic-curve><ecdsa>","1","1","2","2017-07-06 14:39:45","44907432","2","","723506","","2017-06-29 15:32:28","2017-06-28 16:34:46",""
"25907802","Use X509Certificate2 to sign and validate ECDSA-SHA256 signatures","<p>I used <code>OpenSSL</code> to create ECC certificates using <code>SHA256</code>. Now I want to use these certificates to sign data and to validate existing signatures.</p>

<p>I tried using the <code>DSACryptoServiceProvider</code>, but it only supports <code>SHA1</code> or <code>MD5</code>. </p>

<p>But it seems that <code>ECDsaCng</code> is able to support <code>ECDSA-with-SHA256</code>. The only problem that I have is that I don't know how to convert the Private and Public Key from my <code>X509Certificate2</code> into the necessary <code>CngKey</code>. I read another question where someone described how to convert the Public Key. But in order to be able to sign data, I need the Private Key, too. </p>

<p><strong>So is there a way to get the <code>CngKey</code> of the Private and Public Key out of the <code>X509Certificate2</code>?</strong> The certificates are available in different formats. I have them as PFX file and separately as CER and PEM files. </p>

<p>I would prefer to stick with the <code>.NET Framework 4</code>, but if it's not possible at all to use it, I would also switch to <code>Bouncy Castle</code>. </p>
","<p>Support for this was added in .NET 4.6.1:</p>

<pre><code>private static byte[] SignWithCert(X509Certificate2 cert, byte[] data)
{
    using (ECDsa ecdsa = cert.GetECDsaPrivateKey())
    {
        if (ecdsa == null)
            throw new ArgumentException(""Cert must have an ECDSA private key"", nameof(cert));

        return ecdsa.SignData(data, HashAlgorithmName.SHA256);
    }
}

private static bool VerifyWithCert(X509Certificate2 cert, byte[] data, byte[] signature)
{
    using (ECDsa ecdsa = cert.GetECDsaPublicKey())
    {
        if (ecdsa == null)
            throw new ArgumentException(""Cert must be an ECDSA cert"", nameof(cert));

        return ecdsa.VerifyData(data, signature, HashAlgorithmName.SHA256);
    }
}
</code></pre>
","1345","<c#><ssl><sha256><x509certificate2><ecdsa>","4","4","1","2016-09-23 13:28:14","","0","2","","","","2014-09-18 08:31:04",""
"26325709","Generating ECDSA SSL wildcard certificate","<p>I'm struggling with generating ECDSA SSL wildcard certificate signed with my own CA.</p>

<p>I'm using these commands:</p>

<pre><code># Generates CA private key
openssl ecparam -name secp521r1 -genkey -param_enc explicit -out server-ca.key

# Generates CA certificate
openssl req -x509 -sha256 -new -nodes -key server-ca.key -days 3650 -out server-ca.crt

# Generates private key
openssl ecparam -name secp521r1 -genkey -param_enc explicit -out server.key

# Generates certificate signing request
openssl req -new -key server.key -out server.csr -config server.conf -reqexts req_ext

# Generates certificate signed with my CA
openssl x509 -req -sha256 -days 3650 -in server.csr -CA server-ca.crt -CAkey server-ca.key -CAcreateserial -out server.crt -extfile server.conf -extensions req_ext
</code></pre>

<p>With this request configuration (server.conf):</p>

<pre><code>[req]
req_extensions = req_ext
distinguished_name = req_dn
default_md = sha256

[req_ext]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[req_dn]
CN=domain.my

[alt_names]
DNS.1 = domain.my
DNS.2 = *.domain.my
</code></pre>

<p>When I configure Apache or nginx with generated server-ca.crt, server.key and server.crt then I'm unable to connect using HTTPS.</p>

<p>This is output of openssl when I try to connect:</p>

<pre><code>CONNECTED(00000003)
140500060243600:error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure:s23_clnt.c:762:
---
no peer certificate available
---
No client certificate CA names sent
---
SSL handshake has read 7 bytes and written 308 bytes
---
New, (NONE), Cipher is (NONE)
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
---
</code></pre>

<p>No matter which curve I'm using, I'm always unable to connect. However, when I use RSA keys instead of ECDSA, everything works.</p>

<p>This is my nginx configuration:</p>

<pre><code>ssl_certificate         server.crt;
ssl_certificate_key     server.key;
ssl_trusted_certificate server-ca.crt;
ssl_session_cache    shared:SSL:1m;
ssl_session_timeout  5m;
ssl_protocols TLSv1.2;
ssl_prefer_server_ciphers  on;
ssl_ciphers ""EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS"";
</code></pre>

<p>What am I doing wrong ?</p>
","<blockquote>
  <p><code>openssl ecparam -name secp521r1 -genkey -param_enc explicit -out server-ca.key</code></p>
</blockquote>

<p>You must create your key pair without ""-param_enc explicit"".
Don't ask me why ;)</p>
","1312","<ssl><nginx><certificate><wildcard><ecdsa>","2","1","1","2014-10-22 13:07:48","","0","","","","","2014-10-12 13:37:56",""
"36433799","PHP: openssl_verify not working with ECDSA keys","<p>I need some help with the following ""pseudo"" code:</p>

<pre><code>&lt;?php

$stringToVerify = '50.009781OK101092014125505';
$ECDSA =     '3045022100b4b4064158cb12f5b3d902e1e4487e0c6dfafd96b5bb5ab9765fc088e054d67e0220153    f9bb5da20441c68ff0c3e8ba28cfe048e5c3152fc8c890def156cf09d5540';
$publicKey = ""-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEaq6djyzkpHdX7kt8DsSt6IuSoXjp
WVlLfnZPoLaGKc/2BSfYQuFIO2hfgueQINJN3ZdujYXfUJ7Who+XkcJqHQ==
-----END PUBLIC KEY-----"";

var_dump(openssl_verify($stringToVerify, pack(""H*"", $ECDSA), $publicKey,     OPENSSL_ALGO_SHA256));
var_dump(openssl_error_string());
</code></pre>

<p>openssl_verify() will always return non-TRUE value and the openssl_error_string() will return error message: 'error:0906D06C:PEM routines:PEM_read_bio:no start line'</p>

<p>Where might be a problem? Why openssl_verify() won't return TRUE?</p>

<p>OpenSSL version is 1.0.1r  28 Jan 2016</p>
","<p>The <code>error:0906D06C:PEM routines:PEM_read_bio:no start line</code> is non-fatal.  That means it didn't find a certificate along with the private key which is okay since there is only a public/private key in this case.</p>

<p><a href=""http://php.net/openssl_verify"" rel=""nofollow""><code>openssl_verify()</code></a> returns <code>-1</code> on failure, <code>1</code> if the signature is correct and <code>0</code> if it is incorrect.  Because of this you should be checking for all 3 values, not just true or false.</p>

<p>You should check the return value of <code>openssl_verify</code> for <code>-1</code> indicating failure.  If it returns <code>0</code>, then the key is valid but either the signature is invalid, the data was tampered with, or the wrong public key was used for verification.</p>

<p>Here's a fully illustrated example:</p>

<pre><code>&lt;?php

$stringToSign = ""hey this is some data I want to sign to confirm I said it and no one else..."";
$privateKey =
""-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEA0PWnPjB5x8Xs+uV0GRCGGE8xlLU67sx6CDdAU7FBsBe8X7pt
065MAUwrtRQvIhyKhd9wRg8LvgWm7vYnYi5tkdodOhRyVw+jd7Id9CsQwUNNG+JZ
vrEmHKCTXvWbv/fmL5DTCkRxoJj3KdNqUYA6M+JcGahgpGnsRmvWQ2mz4IZZi5ur
vjSPPdrBSWgts5uIv5tNfEwuEzbJtIENn0tysoksIiG/n8edBbxlTqCo8OJVfy1n
h21TdBEHsi9V0NyEtqAFKdHaZscA3yj9k2mWuqSg1c0VnGJ/+OmOvgLkDlz3f7vH
t7ULJxV/iyNdugh5XUD1YKRwhMqBqfTNlKyFvwIDAQABAoIBABEsPyRjQ37hi0pL
VTFCJGMXDxITmtZJQ7YtJEI8jRN1v+t2HNSKvIBWzDjDgeQhyFicNlPrpKFnQYLe
A/qTqjmUXVaKm6MADAUoREHu0B+x8kJaZdnAIUu0/qeNM9GhA+/gzRdI7LWwHI/5
agFsslvVPJB3QAoDEoHvFtrPcxL+kY+wZu8RUYG6TCX/QxD45iZhQkWFH6I6tXh+
5wO1Dt0sx1iQJYkaI9/iHGkKS04hnNCQKPSdBLx0p+w87W9aF3+hoafRGMLsHL8S
mzQTFTHryYdrczjFhFypPhgCm+gdm8OlhjpuRHdmEV6jm40snnPyq9w9gm1Etge9
v0otEjECgYEA7z8WOw0NGb+UHx8F+YKyaaVigkN/Pal0tBbBG/XIF2hubbldr3Z8
/XCfmY8sIdQvxOusSfD1aFCxS34t8V6kAerQKZ6p4+W4xb7+dF9/qfCqJXzQttug
M8EujgAdqlS+G/3FKzHBWmfTDlymLsldH2dC2I6U+Jo5kAzPyS5SxLsCgYEA35ef
E79OaCKNFGpK9VgsLnEKd9DtZS3abzOkx5242VRjWIjrsvEgLfuvLSGGYgSaeCMY
edsCQ3mfmS2Yjiov0eZ4b2PcK+16ndaGQceHwuoP/eeH/BGe+eLcDF/xBFx7yRnn
sVgDhePthBCwOOJm7M26cCVdMmO3GMHxopXdNM0CgYEAlfQvxeFfRbU7bOov/3y4
wNjlTopp1UdCG6JrdU/vEyTkmidmHhUhMGUH0+LWIXnyWvXwbgP2fWSeS5gRycis
+Xqo8H0/NNWGo4Mbz+sPhH+Q1aBO3V35IpdBy8Us0tb8tWSw0WsFKtoKgmT10Dtr
/8PkNQHhQ5S+4Zf2IL3FKQMCgYEAy4A0SMTVl/HadbpIfwTBMYOxA1wktPIG3S8j
yorCswsbYHk+DJ9pqnBn/6uDo7KM5MsMe9vZM5B+sevN7ZZ375LUCo3Y1iJOd1nI
2BXCeqSN6YnROprPFqBjpt+rfUyvXVk2hzKUAkhw5MJLoXpuMxkLlwZqzHH1M5NR
WakMrAECgYEA4Ij7J3591daJbS5+pFK7MujrSg6TTi2etyyXcNO6xIkEbiX69MIU
DZh9GfAVkh6k/WaA2MuThI39TZJiF0nBU+irQttK6LeVhZ2MK+dEJh7rTy1b7zv1
WXLfkc1viK7cnC2ROOChmRm64GURupdf7ACsR2r+vbTSEoevWKfXwIk=
-----END RSA PRIVATE KEY-----"";

$publicKey =
""-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0PWnPjB5x8Xs+uV0GRCG
GE8xlLU67sx6CDdAU7FBsBe8X7pt065MAUwrtRQvIhyKhd9wRg8LvgWm7vYnYi5t
kdodOhRyVw+jd7Id9CsQwUNNG+JZvrEmHKCTXvWbv/fmL5DTCkRxoJj3KdNqUYA6
M+JcGahgpGnsRmvWQ2mz4IZZi5urvjSPPdrBSWgts5uIv5tNfEwuEzbJtIENn0ty
soksIiG/n8edBbxlTqCo8OJVfy1nh21TdBEHsi9V0NyEtqAFKdHaZscA3yj9k2mW
uqSg1c0VnGJ/+OmOvgLkDlz3f7vHt7ULJxV/iyNdugh5XUD1YKRwhMqBqfTNlKyF
vwIDAQAB
-----END PUBLIC KEY-----"";

$signature = null;
$alg       = OPENSSL_ALGO_SHA256;

if (openssl_sign($stringToSign, $signature, $privateKey, $alg)) {
    echo ""Successfully signed data.\n"";

    $signature = base64_encode($signature); // as might be done in transport

    // verify which should succeed
    $success = openssl_verify($stringToSign, base64_decode($signature), $publicKey, $alg);

    if ($success === -1) {
        echo ""openssl_verify() failed with error.  "" . openssl_error_string() . ""\n"";
    } elseif ($success === 1) {
        echo ""Signature verification was successful!\n"";
    } else {
        echo ""Signature verification failed.  Incorrect key or data has been tampered with\n"";
    }

    // verify which should fail because data has been tampered with
    $stringToSign .= ""\nI am evil and demand you wire $1,000,000,000 to me."";

    $success = openssl_verify($stringToSign, base64_decode($signature), $publicKey, $alg);

    if ($success === -1) {
        echo ""openssl_verify() failed with error.  "" . openssl_error_string() . ""\n"";
    } elseif ($success === 1) {
        echo ""Signature verification was successful!\n"";
    } else {
        echo ""Signature verification failed.  Incorrect key or data has been tampered with!\n"";
    }
} else {
    echo ""openssl_sign() failed.  "" . openssl_error_string() . ""\n"";
}
</code></pre>
","1272","<php><openssl><sha256><ecdsa>","0","0","1","2016-04-05 18:56:38","36434803","0","","6039389","","2016-04-05 18:11:02","2016-04-05 18:04:35",""
"27315687","Creation of ECDSA public key given curve and public point?","<p>I am struggling with the creation of a ECDSA public key from a string representation of a public key i.e </p>

<pre><code>string     devicePublicKey(""86FB5EB3CA0507226BE7197058B9EC041D3A3758D9D9C91902ACA3391F4E58AEF13AFF63CC4EF68942B9B94904DC1B890EDBEABD16B992110624968E894E560E"");
</code></pre>

<p>previously I found that I had to prefix this key with '04' so not sure if this is require this time?</p>

<p>I am trying to generate it to use in verifying a signature</p>

<pre><code>string ecs04b2ExpSignature(""0199E984CEC75DDCA7F1DDF6E53E2E67352A2BE38A4B66F8ED596606FAB983FF300CAA76DE88CED9D563A5C03E8F3A7C000780F3F2061C611E9AA0B18B460D77"");
</code></pre>

<p>where the data to be signed is</p>

<pre><code>string      ecs04b2SigningData(""020000000000000001FFFFFFFFFFFFFFFE123456789ABCDEF000B3DA2000000100000300000003030003000300"");
</code></pre>

<p>My rough code for now looks like this</p>

<pre><code>SecByteBlock message(convertHexStrToSecByteBlock(messageIn));
SecByteBlock signature(convertHexStrToSecByteBlock(signatureIn));

ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
string inPublicKey(""04"");
inPublicKey.append(pubKeyIn);
SecByteBlock pubKey = encryptBase::convertHexStrToSecByteBlock(inPublicKey);



ECP::Point p;
publicKey.AccessGroupParameters().Initialize(CryptoPP::ASN1::secp256r1());
publicKey.GetGroupParameters().GetCurve().DecodePoint(p, pubKey, publicKey.GetGroupParameters().GetCurve().EncodedPointSize(true));
publicKey.SetPublicElement(p);

//ByteQueue qt;
//qt.Put((byte*)exp.c_str(),(size_t)exp.size());
AutoSeededRandomPool prng;
bool result = publicKey.Validate(prng, 3);
if (result) 
{  
    // Load public key (in ByteQueue, X509 format)
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(publicKey);

    bool result = verifier.VerifyMessage(message.data(), messageIn.size(), signature.data(), signature.size());
    if (result)
        cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
    else
        cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; endl;
}
else
{
    cout &lt;&lt; ""Failed to validate key"" &lt;&lt; endl;
}
</code></pre>

<p>this is chopped together so wont build. Any help would be great</p>

<p>PS I asked a similar question relating to private keys here <a href=""https://stackoverflow.com/questions/27232053/creation-of-ecdsa-private-key-given-curve-and-private-exponent"">Creation of ECDSA private key given curve and private exponent?</a></p>
","<p>The answer is detailed on the <a href=""http://www.cryptopp.com/wiki/Ecdsa#Public_Key_2"" rel=""nofollow noreferrer"">ECDSA wiki page</a>, but its not readily apparent. You need to perform the following to initialize the <code>publicKey</code> given the curve and public point:</p>

<pre><code>string pt = ""2DB45A3F21889438B42C8F464C75292BACF5FDDB5DA0B492501B299CBFE92D8F""
            ""DB90FC8FF4026129838B1BCAD1402CAE47FE7D8084E409A41AFCE16D63579C5F"";

HexDecoder decoder;
decoder.Put((byte*)pt.data(), pt.size());
decoder.MessageEnd();

ECP::Point q;
size_t len = decoder.MaxRetrievable();
// len should be GetField().MaxElementByteLength()

q.identity = false;
q.x.Decode(decoder, len/2);
q.y.Decode(decoder, len/2);

ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
publicKey.Initialize(ASN1::secp256r1(), q);

bool result = publicKey.Validate( prng, 3 );
if( result )
{
    cout &lt;&lt; ""Validated public key"" &lt;&lt; endl;
}
else
{
    cerr &lt;&lt; ""Failed to validate public key"" &lt;&lt; endl;
    exit(1);
}

const ECP::Point&amp; qq = publicKey.GetPublicElement();
cout &lt;&lt; ""Q.x: "" &lt;&lt; std::hex &lt;&lt; qq.x &lt;&lt; endl;
cout &lt;&lt; ""Q.y: "" &lt;&lt; std::hex &lt;&lt; qq.y &lt;&lt; endl;
</code></pre>

<p>The program above produces the following results.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
Validated public key
Q.x: 2db45a3f21889438b42c8f464c75292bacf5fddb5da0b492501b299cbfe92d8fh
Q.y: db90fc8ff4026129838b1bcad1402cae47fe7d8084e409a41afce16d63579c5fh
</code></pre>

<hr>

<p>You can't use <code>GetField().MaxElementByteLength()</code> because the only thing available are the <code>x</code> and <code>y</code> coordinates. Things like field size won't be available until you initialize the underlying <a href=""http://www.cryptopp.com/docs/ref/class_d_l___group_parameters___e_c.html"" rel=""nofollow noreferrer""><code>DL_GroupParameters_EC&lt; EC &gt;</code></a> in the public key.</p>

<p>As an example, the following causes a segmentation fault:</p>

<pre><code>ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
unsigned int u = publicKey.GetGroupParameters().GetCurve().GetField().MaxElementByteLength();
cout &lt;&lt; ""Field element length: "" &lt;&lt; u &lt;&lt; endl;
</code></pre>

<hr>

<p>You can tamper with the public key to ensure a validation failure with:</p>

<pre><code>q.y.Decode(decoder, len/2);
q.y++;
</code></pre>
","1230","<c++><hex><crypto++><ecdsa>","2","2","2","2019-10-22 18:21:14","27339240","0","1","-1","","2017-05-23 12:05:55","2014-12-05 12:15:11",""
"27315687","Creation of ECDSA public key given curve and public point?","<p>I am struggling with the creation of a ECDSA public key from a string representation of a public key i.e </p>

<pre><code>string     devicePublicKey(""86FB5EB3CA0507226BE7197058B9EC041D3A3758D9D9C91902ACA3391F4E58AEF13AFF63CC4EF68942B9B94904DC1B890EDBEABD16B992110624968E894E560E"");
</code></pre>

<p>previously I found that I had to prefix this key with '04' so not sure if this is require this time?</p>

<p>I am trying to generate it to use in verifying a signature</p>

<pre><code>string ecs04b2ExpSignature(""0199E984CEC75DDCA7F1DDF6E53E2E67352A2BE38A4B66F8ED596606FAB983FF300CAA76DE88CED9D563A5C03E8F3A7C000780F3F2061C611E9AA0B18B460D77"");
</code></pre>

<p>where the data to be signed is</p>

<pre><code>string      ecs04b2SigningData(""020000000000000001FFFFFFFFFFFFFFFE123456789ABCDEF000B3DA2000000100000300000003030003000300"");
</code></pre>

<p>My rough code for now looks like this</p>

<pre><code>SecByteBlock message(convertHexStrToSecByteBlock(messageIn));
SecByteBlock signature(convertHexStrToSecByteBlock(signatureIn));

ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
string inPublicKey(""04"");
inPublicKey.append(pubKeyIn);
SecByteBlock pubKey = encryptBase::convertHexStrToSecByteBlock(inPublicKey);



ECP::Point p;
publicKey.AccessGroupParameters().Initialize(CryptoPP::ASN1::secp256r1());
publicKey.GetGroupParameters().GetCurve().DecodePoint(p, pubKey, publicKey.GetGroupParameters().GetCurve().EncodedPointSize(true));
publicKey.SetPublicElement(p);

//ByteQueue qt;
//qt.Put((byte*)exp.c_str(),(size_t)exp.size());
AutoSeededRandomPool prng;
bool result = publicKey.Validate(prng, 3);
if (result) 
{  
    // Load public key (in ByteQueue, X509 format)
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(publicKey);

    bool result = verifier.VerifyMessage(message.data(), messageIn.size(), signature.data(), signature.size());
    if (result)
        cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
    else
        cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; endl;
}
else
{
    cout &lt;&lt; ""Failed to validate key"" &lt;&lt; endl;
}
</code></pre>

<p>this is chopped together so wont build. Any help would be great</p>

<p>PS I asked a similar question relating to private keys here <a href=""https://stackoverflow.com/questions/27232053/creation-of-ecdsa-private-key-given-curve-and-private-exponent"">Creation of ECDSA private key given curve and private exponent?</a></p>
","<p>Here's the answer to your second question on how to use <code>VerifyMessage</code>:</p>

<pre><code>...
publicKey.Initialize(ASN1::secp256r1(), q);

string msg = ""020000000000000001FFFFFFFFFFFFFFFE123456789ABCDEF000B3DA2000000100000300000003030003000300"";
string sig = ""0199E984CEC75DDCA7F1DDF6E53E2E67352A2BE38A4B66F8ED596606FAB983FF300CAA76DE88CED9D563A5C03E8F3A7C000780F3F2061C611E9AA0B18B460D77"";

string mm, ss;

decoder.Detach(new StringSink(mm));
decoder.Put((byte*)msg.data(), msg.size());
decoder.MessageEnd();

decoder.Detach(new StringSink(ss));
decoder.Put((byte*)sig.data(), sig.size());
decoder.MessageEnd();

ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(publicKey);
result = verifier.VerifyMessage((byte*)mm.data(), mm.size(), (byte*)ss.data(), ss.size());

if( result )
{
    cout &lt;&lt; ""Verified message"" &lt;&lt; endl;
}
else
{ 
    cerr &lt;&lt; ""Failed to verify message"" &lt;&lt; endl;
    exit(1);
}
</code></pre>

<p>Calling <code>Detach</code> on the <code>HexDecoder</code> deletes the current filter, and replaces it with the new filter. In the code above, its the <code>StringSink</code>. You have to do it to ensure memory is not leaked.</p>

<p>Your message does not verify under the public key:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
Validated public key
Failed to verify message
</code></pre>

<p>You can also try to verify the ASCII message rather than the binary message, but it fails to verify too:</p>

<pre><code>decoder.Attach(new StringSink(mm));
decoder.Put((byte*)msg.data(), msg.size());
decoder.MessageEnd();

// Swap in the ASCII message for the binary message
mm = msg;
</code></pre>

<p>So someone gave you the wrong message, the wrong signature or the wrong public key (or some combination).</p>
","1230","<c++><hex><crypto++><ecdsa>","2","0","2","2019-10-22 18:21:14","27339240","0","1","-1","","2017-05-23 12:05:55","2014-12-05 12:15:11",""
"21954512","Parse EC Public Key with pyasn1","<p>How to parse ec public with the use of pyasn1?</p>

<pre><code>    from pyasn1.codec.der import decoder
    import base64
    raw2='''
    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE/FU6/Om2m5EnxDwGSVO+YNXorpDtzutLtCAMTZR5
    NIs6pfKx9oyjpS5aURx4BinuW8dr8K7N2oafY1TNvc41oQ==
    '''
    der = decoder.decode(base64.b64decode(raw2))
    print der
    '''
     der:
    (Sequence().setComponentByPosition(0, Sequence().setComponentByPosition(0, ObjectIdentifier(1.2.840.10045.2.1)).setComponentByPosition(1, ObjectIdentifier(1.2.840.10045.3.1.7))).setComponentByPosition(1, BitString(""'0000010011111100010101010011101011111100111010011011011010011011100100010010011111000100001111000000011001001001010100111011111001100000110101011110100010101110100100001110110111001110111010110100101110110100001000000000110001001101100101000111100100110100100010110011101010100101111100101011000111110110100011001010001110100101001011100101101001010001000111000111100000000110001010011110111001011011110001110110101111110000101011101100110111011010100001101001111101100011010101001100110110111101110011100011010110100001'B"")), '')
'''
</code></pre>

<p>Is it possible, to get something like <a href=""http://lapo.it/asn1js/#3059301306072A8648CE3D020106082A8648CE3D0301070342000486B3CA908BD0C530EED8B9E273F48783EC1836E0687EE73EAAF7EDEA60365B6D8A4CC369201E835D78383F298AB5979A59A5C6B207DAB44A25A9083E24C4FC56"" rel=""nofollow"">this</a> with pyasn1.</p>

<p><strong>Edit:</strong>
I base myself on <a href=""http://pydoc.net/Python/pyXMLSecurity/0.4/xmlsec.rsa_x509_pem.x509_pem/"" rel=""nofollow"">this</a> to obtain the following:</p>

<pre><code>class curve(univ.Sequence):

    componentType = namedtype.NamedTypes(
     namedtype.NamedType('public KeyType',univ.ObjectIdentifier()),
     namedtype.NamedType('curveName',univ.ObjectIdentifier())
    )

class EcPublicKey(univ.Sequence):
  componentType = namedtype.NamedTypes(
    namedtype.NamedType('curve', curve()),
    namedtype.NamedType('publicKeyValue', univ.BitString())
    )

pubKey,rest = decoder.decode(base64.b64decode(raw2), asn1Spec = EcPublicKey())

print(pubKey.prettyPrint())
'''
EcPublicKey:
 curve=curve:
  public KeyType=1.2.840.10045.2.1
  curveName=1.2.840.10045.3.1.7

 publicKeyValue=""'0000010011111100010101010011101011111100111010011011011010011011100100010010011111000100001111000000011001001001010100111011111001100000110101011110100010101110100100001110110111001110111010110100101110110100001000000000110001001101100101000111100100110100100010110011101010100101111100101011000111110110100011001010001110100101001011100101101001010001000111000111100000000110001010011110111001011011110001110110101111110000101011101100110111011010100001101001111101100011010101001100110110111101110011100011010110100001'B""

'''
</code></pre>
","<p>It seems that pyasn1 doen't provide better formatting, so you will have to implement it yourself by following the pattern from <code>__repr__</code> method (see <code>AbstractSimpleAsn1Item</code> and <code>AbstractConstructedAsn1Item</code> from <a href=""http://pyasn1.cvs.sourceforge.net/viewvc/pyasn1/pyasn1/pyasn1/type/base.py?revision=1.35&amp;view=markup"" rel=""nofollow"">http://pyasn1.cvs.sourceforge.net/viewvc/pyasn1/pyasn1/pyasn1/type/base.py?revision=1.35&amp;view=markup</a>)</p>
","1180","<python-2.7><asn.1><ecdsa>","1","0","3","2017-04-20 16:03:08","","0","","581084","","2014-02-25 16:02:54","2014-02-22 12:44:31",""
"21954512","Parse EC Public Key with pyasn1","<p>How to parse ec public with the use of pyasn1?</p>

<pre><code>    from pyasn1.codec.der import decoder
    import base64
    raw2='''
    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE/FU6/Om2m5EnxDwGSVO+YNXorpDtzutLtCAMTZR5
    NIs6pfKx9oyjpS5aURx4BinuW8dr8K7N2oafY1TNvc41oQ==
    '''
    der = decoder.decode(base64.b64decode(raw2))
    print der
    '''
     der:
    (Sequence().setComponentByPosition(0, Sequence().setComponentByPosition(0, ObjectIdentifier(1.2.840.10045.2.1)).setComponentByPosition(1, ObjectIdentifier(1.2.840.10045.3.1.7))).setComponentByPosition(1, BitString(""'0000010011111100010101010011101011111100111010011011011010011011100100010010011111000100001111000000011001001001010100111011111001100000110101011110100010101110100100001110110111001110111010110100101110110100001000000000110001001101100101000111100100110100100010110011101010100101111100101011000111110110100011001010001110100101001011100101101001010001000111000111100000000110001010011110111001011011110001110110101111110000101011101100110111011010100001101001111101100011010101001100110110111101110011100011010110100001'B"")), '')
'''
</code></pre>

<p>Is it possible, to get something like <a href=""http://lapo.it/asn1js/#3059301306072A8648CE3D020106082A8648CE3D0301070342000486B3CA908BD0C530EED8B9E273F48783EC1836E0687EE73EAAF7EDEA60365B6D8A4CC369201E835D78383F298AB5979A59A5C6B207DAB44A25A9083E24C4FC56"" rel=""nofollow"">this</a> with pyasn1.</p>

<p><strong>Edit:</strong>
I base myself on <a href=""http://pydoc.net/Python/pyXMLSecurity/0.4/xmlsec.rsa_x509_pem.x509_pem/"" rel=""nofollow"">this</a> to obtain the following:</p>

<pre><code>class curve(univ.Sequence):

    componentType = namedtype.NamedTypes(
     namedtype.NamedType('public KeyType',univ.ObjectIdentifier()),
     namedtype.NamedType('curveName',univ.ObjectIdentifier())
    )

class EcPublicKey(univ.Sequence):
  componentType = namedtype.NamedTypes(
    namedtype.NamedType('curve', curve()),
    namedtype.NamedType('publicKeyValue', univ.BitString())
    )

pubKey,rest = decoder.decode(base64.b64decode(raw2), asn1Spec = EcPublicKey())

print(pubKey.prettyPrint())
'''
EcPublicKey:
 curve=curve:
  public KeyType=1.2.840.10045.2.1
  curveName=1.2.840.10045.3.1.7

 publicKeyValue=""'0000010011111100010101010011101011111100111010011011011010011011100100010010011111000100001111000000011001001001010100111011111001100000110101011110100010101110100100001110110111001110111010110100101110110100001000000000110001001101100101000111100100110100100010110011101010100101111100101011000111110110100011001010001110100101001011100101101001010001000111000111100000000110001010011110111001011011110001110110101111110000101011101100110111011010100001101001111101100011010101001100110110111101110011100011010110100001'B""

'''
</code></pre>
","<p>repr() gives you Python code which would produce the same object(s) once evaluated. For a  human-oriented representation use .prettyPrint() method (of any pyasn1 object):</p>

<pre><code>publicKey, restOfInput = decoder.decode(base64.b64decode(raw2))
print publicKey.prettyPrint()
</code></pre>

<p>Sequence:<br>
 &lt;no-name&gt;=Sequence:<br>
 &lt;no-name&gt;=1.2.840.10045.2.1<br>
 &lt;no-name&gt;=1.2.840.10045.3.1.7<br></p>

<p>&lt;no-name&gt;=""'0000010011111100010101010011101011111100111010011011011010011011100100010010011111000100001111000000011001001001010100111011111001100000110101011110100010101110100100001110110111001110111010110100101110110100001000000000110001001101100101000111100100110100100010110011101010100101111100101011000111110110100011001010001110100101001011100101101001010001000111000111100000000110001010011110111001011011110001110110101111110000101011101100110111011010100001101001111101100011010101001100110110111101110011100011010110100001'B""</p>
","1180","<python-2.7><asn.1><ecdsa>","1","2","3","2017-04-20 16:03:08","","0","","581084","","2014-02-25 16:02:54","2014-02-22 12:44:31",""
"21954512","Parse EC Public Key with pyasn1","<p>How to parse ec public with the use of pyasn1?</p>

<pre><code>    from pyasn1.codec.der import decoder
    import base64
    raw2='''
    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE/FU6/Om2m5EnxDwGSVO+YNXorpDtzutLtCAMTZR5
    NIs6pfKx9oyjpS5aURx4BinuW8dr8K7N2oafY1TNvc41oQ==
    '''
    der = decoder.decode(base64.b64decode(raw2))
    print der
    '''
     der:
    (Sequence().setComponentByPosition(0, Sequence().setComponentByPosition(0, ObjectIdentifier(1.2.840.10045.2.1)).setComponentByPosition(1, ObjectIdentifier(1.2.840.10045.3.1.7))).setComponentByPosition(1, BitString(""'0000010011111100010101010011101011111100111010011011011010011011100100010010011111000100001111000000011001001001010100111011111001100000110101011110100010101110100100001110110111001110111010110100101110110100001000000000110001001101100101000111100100110100100010110011101010100101111100101011000111110110100011001010001110100101001011100101101001010001000111000111100000000110001010011110111001011011110001110110101111110000101011101100110111011010100001101001111101100011010101001100110110111101110011100011010110100001'B"")), '')
'''
</code></pre>

<p>Is it possible, to get something like <a href=""http://lapo.it/asn1js/#3059301306072A8648CE3D020106082A8648CE3D0301070342000486B3CA908BD0C530EED8B9E273F48783EC1836E0687EE73EAAF7EDEA60365B6D8A4CC369201E835D78383F298AB5979A59A5C6B207DAB44A25A9083E24C4FC56"" rel=""nofollow"">this</a> with pyasn1.</p>

<p><strong>Edit:</strong>
I base myself on <a href=""http://pydoc.net/Python/pyXMLSecurity/0.4/xmlsec.rsa_x509_pem.x509_pem/"" rel=""nofollow"">this</a> to obtain the following:</p>

<pre><code>class curve(univ.Sequence):

    componentType = namedtype.NamedTypes(
     namedtype.NamedType('public KeyType',univ.ObjectIdentifier()),
     namedtype.NamedType('curveName',univ.ObjectIdentifier())
    )

class EcPublicKey(univ.Sequence):
  componentType = namedtype.NamedTypes(
    namedtype.NamedType('curve', curve()),
    namedtype.NamedType('publicKeyValue', univ.BitString())
    )

pubKey,rest = decoder.decode(base64.b64decode(raw2), asn1Spec = EcPublicKey())

print(pubKey.prettyPrint())
'''
EcPublicKey:
 curve=curve:
  public KeyType=1.2.840.10045.2.1
  curveName=1.2.840.10045.3.1.7

 publicKeyValue=""'0000010011111100010101010011101011111100111010011011011010011011100100010010011111000100001111000000011001001001010100111011111001100000110101011110100010101110100100001110110111001110111010110100101110110100001000000000110001001101100101000111100100110100100010110011101010100101111100101011000111110110100011001010001110100101001011100101101001010001000111000111100000000110001010011110111001011011110001110110101111110000101011101100110111011010100001101001111101100011010101001100110110111101110011100011010110100001'B""

'''
</code></pre>
","<p>If you want to have access to the value of the public key itself, you can use the <a href=""https://github.com/Legrandin/pycryptodome"" rel=""nofollow noreferrer"">pycryptodome</a> library. Just format your data in the file public.pem:</p>

<pre><code>-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE/FU6/Om2m5EnxDwGSVO+YNXorpDtzutLtCAMTZR5
NIs6pfKx9oyjpS5aURx4BinuW8dr8K7N2oafY1TNvc41oQ==
-----END PUBLIC KEY-----
</code></pre>

<p>And then in Python:</p>

<pre><code>from Crypto.PublicKey import ECC
print(ECC.import_key(open('public.pem').read()))
</code></pre>

<p>EccKey(curve='P-256', x=114133426963296850915436792023241197556938624347236768937730916445384676553867, y=26527350004009046719864726291814153938182054558131723928772218772465776473505)</p>
","1180","<python-2.7><asn.1><ecdsa>","1","0","3","2017-04-20 16:03:08","","0","","581084","","2014-02-25 16:02:54","2014-02-22 12:44:31",""
"35899969","how to use ECDSA to create a self signed digital certificate programatically","<p>I am trying to create a digital certificate which to be self signed with EC keys instead of those from RSA and followed these SO <a href=""https://stackoverflow.com/questions/256405/programmatically-create-x509-certificate-using-openssl"">link1</a> and <a href=""https://stackoverflow.com/questions/2228860/signing-a-message-using-ecdsa-in-openssl"">link2</a>. I replaced the signature algorithm from RSA given in link1 to EC as </p>

<pre><code>EC_KEY *ecc = NULL;
int eccgrp = OBJ_txt2nid(""secp256k1"");
ecc = EC_KEY_new_by_curve_name(eccgrp);
EC_KEY_set_asn1_flag(ecc, OPENSSL_EC_NAMED_CURVE);

if(!(EC_KEY_generate_key(ecc))) {
    BIO_printf(out, ""Error in generating key"");
    printf(""Error 1\n"");
}

if(!EVP_PKEY_assign_EC_KEY(pk, ecc)) {
    BIO_printf(out, ""Error assigning EC_KEY to EVP_PKEY"");
    printf(""Error 2\n"");
}
.
.
X509_set_pubkey(x,pk);
.
.
if (!X509_sign(x,pk,EVP_md5()))
    goto err;
.
.
</code></pre>

<p>Rest of the code is same as given in link1. No error is printed but i get a seg-fault when i try to print the x509 cert <code>X509_print_fp(stdout,x509);</code>. What is correct way of doing this?</p>
","<p>You changed <a href=""https://stackoverflow.com/questions/256405/programmatically-create-x509-certificate-using-openssl"">that code</a> more than you said because it doesn't have variables 'pk' or 'x'.</p>

<p>Anytime you get an error/failure return from a libcrypto routine you should always look at the error queue; see <a href=""https://www.openssl.org/docs/faq.html#PROG6"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/faq.html#PROG6</a> and <a href=""https://www.openssl.org/docs/faq.html#PROG7"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/faq.html#PROG7</a> . (For libssl routines you should do so depending on the return from <a href=""https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html"" rel=""nofollow noreferrer"">SSL_get_error</a>.) If you do so as in my code below for the 'bad' case, you see <code>X509_sign</code> fails with</p>

<pre><code>140018941793960:error:100C508A:elliptic curve routines:PKEY_EC_CTRL:invalid digest type:ec_pmeth.c:388:
</code></pre>

<p>because standard ECDSA signature schemes don't include MD5. <strong>You must use SHA1 or SHA2</strong>, and you <em>should</em> use a hash matched in strength to the ECC key, which in this case is SHA256. Since the signature failed, the <code>x509</code> structure does not contain valid data and can't be successfully printed. </p>

<p>Also note: since 1.0.0 (in 2010) <code>PEM_write_PrivateKey</code> with <code>enc</code> nonnull uses 'new' (ca. 2000!) PKCS#8/PBES2 format, which needs a suitable variant of <code>OpenSSL_add_all_algorithms</code>.</p>

<p><strong>Complete working demo-quality code:</strong></p>

<pre><code>/* SO #35899969 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/pem.h&gt;
#include &lt;openssl/x509.h&gt;
#ifdef _WIN32
#include &lt;openssl/applink.c&gt;
#endif

/* minimal error handling for demo; real code do better */
void err (const char *label)
{
  fprintf (stderr, ""Error in %s:\n"", label);
  ERR_print_errors_fp (stderr);
  exit (1);
}

int main (int argc, char**argv)
{
  int bad = argc&gt;1;
  ERR_load_crypto_strings(); /* or SSL_load_error_strings */
  OPENSSL_add_all_algorithms_noconf(); /* for PKCS8 w PBES2 */

  EVP_PKEY * pkey = EVP_PKEY_new();
  EC_KEY *ecc = EC_KEY_new_by_curve_name(NID_secp256k1);
  /* simpler than going through OBJ_txt2nid */
  if(!ecc) err(""ECCnewbyname"");
  EC_KEY_set_asn1_flag(ecc, OPENSSL_EC_NAMED_CURVE);
  if(!(EC_KEY_generate_key(ecc))) err(""ECCgen"");
  if(!EVP_PKEY_assign_EC_KEY(pkey, ecc)) err(""PKEYassign"");

  X509 * x509 = X509_new();
  /* REALLY shouldn't use fixed serial if DN isn't unique */
  ASN1_INTEGER_set(X509_get_serialNumber(x509), 1);
  X509_gmtime_adj(X509_get_notBefore(x509), 0);
  X509_gmtime_adj(X509_get_notAfter(x509), 365L*86400);
  X509_set_pubkey(x509, pkey);
  X509_NAME * name = X509_get_subject_name(x509);
  X509_NAME_add_entry_by_txt(name, ""C"",  MBSTRING_ASC,
                           (unsigned char *)""CA"", -1, -1, 0);
  X509_NAME_add_entry_by_txt(name, ""O"",  MBSTRING_ASC,
                           (unsigned char *)""MyCompany Inc."", -1, -1, 0);
  X509_NAME_add_entry_by_txt(name, ""CN"", MBSTRING_ASC,
                           (unsigned char *)""localhost"", -1, -1, 0);
  X509_set_issuer_name(x509, name);
  if(!X509_sign(x509, pkey, bad? EVP_md5(): EVP_sha256())) err(""X509sign"");

  /* simplified */
  if(!PEM_write_PrivateKey(stdout, pkey, EVP_des_ede3_cbc(),
                          NULL,0,NULL,""passphrase"")) 
    err(""writeKey"");
  if(!PEM_write_X509(stdout, x509))
    err(""writeCert"");
  /* added */
  X509_print_fp (stdout, x509); 
  return 0;
}
</code></pre>
","1175","<openssl><digital-signature><pki><ecdsa>","0","2","1","2016-03-09 23:53:48","35905028","0","1","-1","","2017-05-23 12:31:11","2016-03-09 18:41:56",""
"30237021","Elliptic curve brute forcing","<p>I have all parameter of elliptic curve. And the coordinate of points <strong>Q</strong> and <strong>P</strong>. I want to solve <strong>Q=k*P</strong> (where <strong>k</strong> is the unknown) by testing all possible <strong>k</strong>.</p>

<p>So i used this <a href=""https://github.com/jschendel/elliptic-curve-steganography/blob/master/ecs/ellipticcurve.py"" rel=""nofollow"">class</a></p>

<p>then:</p>

<pre><code>a=-1
b=0
p=134747661567386867366256408824228742802669457
curve = EllipticCurve(a,b,p)
P=[18185174461194872234733581786593019886770620,74952280828346465277451545812645059041440154]
Q=[76468233972358960368422190121977870066985660, 33884872380845276447083435959215308764231090]
for i in range(2902021510595963727029):
    result = curve.multPoint(i,P)
    if result[0]==Q[0] and result[1]==Q[1]:
        print (i)
        break
</code></pre>

<p>Is this the right approach to solve this problem?</p>
","<p>This is not a good approach because you are trying to do 2902021510595963727029 operations.  Even if you managed to do a billion operations per second, it would take <a href=""https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=2902021510595963727029%2F1000000000%2F60%2F60%2F24%2F365"" rel=""nofollow"">92 thousand years</a> to finish.</p>

<p>You are basically trying to break the security of ECDSA.  If you figure out a way to do this, then it would be possible to figure out an ECDSA private key given the corresponding public key.  It would be a breakthrough in cryptography and you would be famous.  There are many smart people that have thought about this problem before you and failed to find a solution.</p>

<p>The problem you are trying to solve is called the <a href=""http://en.wikipedia.org/wiki/Discrete_logarithm"" rel=""nofollow"">discrete logarithm</a> problem.</p>
","1139","<python><brute-force><elliptic-curve><ecdsa>","1","2","2","2015-05-18 20:16:10","30312076","1","","4237058","","2015-05-14 12:35:25","2015-05-14 12:07:34",""
"30237021","Elliptic curve brute forcing","<p>I have all parameter of elliptic curve. And the coordinate of points <strong>Q</strong> and <strong>P</strong>. I want to solve <strong>Q=k*P</strong> (where <strong>k</strong> is the unknown) by testing all possible <strong>k</strong>.</p>

<p>So i used this <a href=""https://github.com/jschendel/elliptic-curve-steganography/blob/master/ecs/ellipticcurve.py"" rel=""nofollow"">class</a></p>

<p>then:</p>

<pre><code>a=-1
b=0
p=134747661567386867366256408824228742802669457
curve = EllipticCurve(a,b,p)
P=[18185174461194872234733581786593019886770620,74952280828346465277451545812645059041440154]
Q=[76468233972358960368422190121977870066985660, 33884872380845276447083435959215308764231090]
for i in range(2902021510595963727029):
    result = curve.multPoint(i,P)
    if result[0]==Q[0] and result[1]==Q[1]:
        print (i)
        break
</code></pre>

<p>Is this the right approach to solve this problem?</p>
","<p>The curve is vulnerable to both the MOV attack and the older FR attack that works similarly, So we can use Weil or Tate pairings (respectively).</p>

<pre><code>q = 134747661567386867366256408824228742802669457
Zq = Zmod(q)
E = EllipticCurve(Zq, [0,0,0,-1,0])
P = E(18185174461194872234733581786593019886770620, 74952280828346465277451545812645059041440154)
Q = E(76468233972358960368422190121977870066985660, 33884872380845276447083435959215308764231090)
n = P.order()
k = GF(n)(q).multiplicative_order()
R = E.random_element()
w1 = P.tate_pairing(R, n, k)
w2 = Q.tate_pairing(R, n, k)
print w1, w2
</code></pre>

<p>with <strong>w2=w1^k</strong> we need to solve a discrete logarithm problem in a ring of integer mod p. It can take quite a while but is still feasible given the small modulus.</p>

<p>PS: This is eltrai <a href=""https://crypto.stackexchange.com/questions/25644/elliptic-curve-brute-forcing/25729#25729"">answer</a>.</p>
","1139","<python><brute-force><elliptic-curve><ecdsa>","1","0","2","2015-05-18 20:16:10","30312076","1","","4237058","","2015-05-14 12:35:25","2015-05-14 12:07:34",""
"40552688","Generating a ECDSA Private key in bouncy castle returns a PUBLIC key","<p>I am attempting to use bouncy castle to generate ECDSA keys. The code seems to work fine from the Java perspective; but, when I dump the file and try to validate the data, OpenSSL does not like the format of the data.</p>

<p>After some research, I figured that bouncy castle is encoding the private key as public key.</p>

<p>Here is my Java code:</p>

<pre><code>public class Test {
    public static void main(String[] args) {
        Security.addProvider(new BouncyCastleProvider());
        System.out.println(""Starting..."");
        String name = ""prime256v1"";
        try {
            KeyPairGenerator kpg = KeyPairGenerator.getInstance(""ECDSA"", BouncyCastleProvider.PROVIDER_NAME);
            kpg.initialize(new ECGenParameterSpec(name));
            KeyPair keyPair = kpg.generateKeyPair();    
            FileOutputStream writer = new FileOutputStream(""private.key"");
            writer.write(keyPair.getPrivate().getEncoded());
            writer.close();
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>The file <code>private.key</code> is generated in valid DER format; however, when I run the following command to see the ASN.1 structure of the key:</p>

<pre><code>$ openssl asn1parse -inform DER -in /my/path/private.key
    0:d=0  hl=3 l= 147 cons: SEQUENCE          
    3:d=1  hl=2 l=   1 prim: INTEGER           :00
    6:d=1  hl=2 l=  19 cons: SEQUENCE          
    8:d=2  hl=2 l=   7 prim: OBJECT            :id-ecPublicKey
   17:d=2  hl=2 l=   8 prim: OBJECT            :prime256v1
   27:d=1  hl=2 l= 121 prim: OCTET STRING      [HEX DUMP]: &lt;hex data&gt;
</code></pre>

<p>For comparison, if I run the following commands to generate a ECDSA key using OpenSSL, I get  the following ASN.1 structure:</p>

<pre><code> $ openssl ecparam -name prime256v1 -genkey -noout -outform DER -out private.key
 $ openssl asn1parse -inform DER -in private.key
     0:d=0  hl=2 l= 119 cons: SEQUENCE          
     2:d=1  hl=2 l=   1 prim: INTEGER           :01
     5:d=1  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]: &lt;hex data&gt;
    39:d=1  hl=2 l=  10 cons: cont [ 0 ]        
    41:d=2  hl=2 l=   8 prim: OBJECT            :prime256v1
    51:d=1  hl=2 l=  68 cons: cont [ 1 ]        
    53:d=2  hl=2 l=  66 prim: BIT STRING        
</code></pre>

<p>So, I guess my questions are</p>

<ul>
<li>Is there anything I am missing?</li>
<li>Or is this a known bug?</li>
<li>Is there anyway to get around it?</li>
</ul>
","<p>Java outputs key in the encoded format. You should try:</p>

<pre><code>private String getPrivateKeyAsHex(PrivateKey privateKey) {

    ECPrivateKey ecPrivateKey = (ECPrivateKey) privateKey;
    byte[] privateKeyBytes = new byte[PRIVATE_KEY_LENGTH];
    writeToStream(privateKeyBytes, 0, ecPrivateKey.getS(), PRIVATE_KEY_LENGTH);

    String hex = Hex.toHexString(privateKeyBytes);

    logger.debug(""Private key bytes: "" + Arrays.toString(privateKeyBytes));
    logger.debug(""Private key hex: "" + hex);

    return hex;
}

private String getPublicKeyAsHex(PublicKey publicKey) {

    ECPublicKey ecPublicKey = (ECPublicKey) publicKey;
    ECPoint ecPoint = ecPublicKey.getW();

    byte[] publicKeyBytes = new byte[PUBLIC_KEY_LENGTH];
    writeToStream(publicKeyBytes, 0, ecPoint.getAffineX(), PRIVATE_KEY_LENGTH);
    writeToStream(publicKeyBytes, PRIVATE_KEY_LENGTH, ecPoint.getAffineY(), PRIVATE_KEY_LENGTH);

    String hex = Hex.toHexString(publicKeyBytes);

    logger.debug(""Public key bytes: "" + Arrays.toString(publicKeyBytes));
    logger.debug(""Public key hex: "" + hex);

    return hex;
}

private void writeToStream(byte[] stream, int start, BigInteger value, int size) {
    byte[] data = value.toByteArray();
    int length = Math.min(size, data.length);
    int writeStart = start + size - length;
    int readStart = data.length - length;
    System.arraycopy(data, readStart, stream, writeStart, length);
}
</code></pre>
","1138","<java><openssl><bouncycastle><ecdsa>","3","0","1","2016-11-21 08:57:11","","6","1","","","","2016-11-11 16:55:20",""
"33525489","How do I obtain the public key from an ECDSA private key in Java with Bouncy Castle?","<p>I've read <a href=""https://stackoverflow.com/questions/12480776/how-do-i-obtain-the-public-key-from-an-ecdsa-private-key-in-openssl"">How do I obtain the public key from an ECDSA private key in OpenSSL?</a></p>

<p>and want to do the same thing, but in Java with Bouncy Castle.</p>

<p>I've also seen <a href=""https://stackoverflow.com/questions/22003407/bouncy-castle-escda-create-public-key-from-private-key"">Bouncy Castle ESCDA Create Public Key from Private Key</a> but it did not help.</p>
","<p>take a look at the following code, it's c# but in java it is similar. the private key is given by as base64 encoded string in this example and also a base64 encoded string is given back. the commented keyParameters are working, so use this one if you want to have key and curve.</p>

<pre><code>private static readonly Org.BouncyCastle.Asn1.X9.X9ECParameters curve = Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByName(""secp256r1"");
private static readonly Org.BouncyCastle.Crypto.Parameters.ECDomainParameters domain = new Org.BouncyCastle.Crypto.Parameters.ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);
public string GetPublicKey(string privKey)
{
      Org.BouncyCastle.Math.BigInteger d = new Org.BouncyCastle.Math.BigInteger(Convert.FromBase64String(privKey));
      //var privKeyParameters = new Org.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters(d, domain);
      Org.BouncyCastle.Math.EC.ECPoint q = domain.G.Multiply(d);
      //var pubKeyParameters = new Org.BouncyCastle.Crypto.Parameters.ECPublicKeyParameters(q, domain);
      return Convert.ToBase64String(q.GetEncoded());
}
</code></pre>
","1135","<java><elliptic-curve><ecdsa>","0","0","1","2016-06-12 09:42:51","","0","1","","","","2015-11-04 15:20:01",""
"42915997","Import ECC key - CngKey.Import() - Parameter is incorrect","<p><strong>Purpose</strong> : Generate a <strong>ES256</strong> signed <strong>JWT</strong> using <a href=""https://github.com/dvsekhvalnov/jose-jwt"" rel=""nofollow noreferrer"">jose-jwt</a> </p>

<p><strong>Steps:</strong></p>

<p>1.Generate a <strong>private key</strong> and <strong>certificate</strong> using openssl:</p>

<pre><code>openssl ecparam -name prime256v1 -genkey &gt; privateKey.pem
openssl req -new -key privateKey.pem -x509 -nodes -days 365 -out public.cer
</code></pre>

<p>2.Token generation:</p>

<pre><code>var payload = new Dictionary&lt;string, object&gt;()
{
   { ""sub"", ""mr.x@contoso.com"" },
   { ""exp"", 1300819380   }
};
var certificate = X509Certificate.CreateFromCertFile(""public.cer"");
byte[] publicKey = certificate.GetPublicKey(); //public key has 65 bytes

//Below step is throwing an error:
var cng = CngKey.Import(publicKey, CngKeyBlobFormat.EccPublicBlob);
var token = JWT.Encode(claims, cng, JwsAlgorithm.ES256);
</code></pre>

<p><strong>CngKey.Import()</strong> is throwing ""<strong>The parameter is incorrect</strong>"" error while trying to generate a <strong>CngKey</strong> required for the <strong>Jose.JWT.Encode</strong> function. Not sure what step I am missing. Thanks.</p>
","<p>The ""ECCPUBLICBLOB"" format isn't the same as the ""public key"" field from the certificate.</p>

<p>The format of the ECCPUBLICBLOB is explained in <a href=""https://stackoverflow.com/a/42676205/6535399"">another question's answer</a>, but here's a quick summary:</p>

<pre><code>UINT32 Magic
UINT32 cbKey
&lt;cbKey bytes of public key&gt;
</code></pre>

<p>The value for <code>Magic</code> will depend on which curve and algorithm you're trying to import (some hints at <a href=""https://referencesource.microsoft.com/#system.core/System/Security/Cryptography/BCryptNative.cs,fde0749a0a5f70d8,references"" rel=""nofollow noreferrer"">https://referencesource.microsoft.com/#system.core/System/Security/Cryptography/BCryptNative.cs,fde0749a0a5f70d8,references</a>).</p>

<p><code>cbKey</code> is how many bytes are in the public key.</p>

<p>The public key bytes will be a bit different than what you get from <code>GetPublicKey()</code>.  It'll be just the curve X coordinate, which will be (for NIST P-256) bytes 1..33  (the first byte of <code>GetPublicKey()</code> will be 0x04, which says that the payload is uncompressed, then 32 bytes of the X coordinate, then 32 bytes of the Y coordinate).</p>

<pre><code>IEnumerable&lt;byte&gt; blobBytes = BitConverter.GetBytes(0x31534345);
blobBytes = blobBytes.Append(BitConverter.GetBytes(32));
blobBytes = blobBytes.Append(cert.GetPublicKey().Skip(1).Take(32));

byte[] eccblob = blobBytes.ToArray();
</code></pre>

<p>System.Linq extension methods used for brevity.</p>

<p>Though, if you just need an object instance, <code>cert.GetECDsaPublicKey()</code> should do the right thing for you (each call to that returns a new instance, so manage the lifetime appropriately)</p>
","1123","<c#><jwt><x509certificate><ecdsa>","1","1","2","2017-03-23 19:49:20","42932855","0","","823800","","2017-03-21 16:40:50","2017-03-20 23:45:14",""
"42915997","Import ECC key - CngKey.Import() - Parameter is incorrect","<p><strong>Purpose</strong> : Generate a <strong>ES256</strong> signed <strong>JWT</strong> using <a href=""https://github.com/dvsekhvalnov/jose-jwt"" rel=""nofollow noreferrer"">jose-jwt</a> </p>

<p><strong>Steps:</strong></p>

<p>1.Generate a <strong>private key</strong> and <strong>certificate</strong> using openssl:</p>

<pre><code>openssl ecparam -name prime256v1 -genkey &gt; privateKey.pem
openssl req -new -key privateKey.pem -x509 -nodes -days 365 -out public.cer
</code></pre>

<p>2.Token generation:</p>

<pre><code>var payload = new Dictionary&lt;string, object&gt;()
{
   { ""sub"", ""mr.x@contoso.com"" },
   { ""exp"", 1300819380   }
};
var certificate = X509Certificate.CreateFromCertFile(""public.cer"");
byte[] publicKey = certificate.GetPublicKey(); //public key has 65 bytes

//Below step is throwing an error:
var cng = CngKey.Import(publicKey, CngKeyBlobFormat.EccPublicBlob);
var token = JWT.Encode(claims, cng, JwsAlgorithm.ES256);
</code></pre>

<p><strong>CngKey.Import()</strong> is throwing ""<strong>The parameter is incorrect</strong>"" error while trying to generate a <strong>CngKey</strong> required for the <strong>Jose.JWT.Encode</strong> function. Not sure what step I am missing. Thanks.</p>
","<p>I was able to make the <strong>CngKey import</strong> working with help from the <a href=""https://stackoverflow.com/questions/22762380/importing-ecc-based-certificate-from-the-windows-certificate-store-into-cngkey"">following post</a>.</p>

<p>Now <code>Jose.JWT.Encode()</code> was throwing ""Unable to sign"" error at the following line:</p>

<pre><code>return JWT.Encode(claims, cng, JwsAlgorithm.ES256)
</code></pre>

<p>And I ended up writing my own implementation of private key signing using <strong>.NET 4.6</strong> <code>GetECDsaPrivateKey()</code>. </p>

<p>You can see my <strong>final solution</strong> on the <a href=""https://stackoverflow.com/questions/38129214/c-sharp-jwt-load-es256-pem-file-into-cngkey-jose-jwt/42985435#42985435"">following post</a></p>

<p>Public key needs to be modified by <em>discarding the first byte</em>, leaving 64 bytes, then prefix with <em>4 bytes for curve</em> and <em>4 bytes for key length</em>. Here is the complete solution:</p>

<pre><code>var payload = new Dictionary&lt;string, object&gt;()
{
   { ""sub"", ""mr.x@contoso.com"" },
   { ""exp"", 1300819380     }
};
var certificate = X509Certificate.CreateFromCertFile(""public.cer"");
byte[] publicKey = certificate.GetPublicKey(); //public key has 65 bytes

//Discard the first byte (it is always 0X04 for ECDSA public key)
publicKey = publicKey.Skip(1).ToArray();:

//Generate 4 bytes for curve and 4 bytes for key length [ 69(E), 67(C), 83(S), 49(1), 32(Key length), 0, 0, 0 ]
byte[] x = { 69, 67, 83, 49, 32, 0, 0, 0 };    

//Prefix above generated array to existing public key array
publicKey = x.Concat(publicKey).ToArray();

var cng = CngKey.Import(publicKey, CngKeyBlobFormat.EccPublicBlob); //This works
return JWT.Encode(claims, cng, JwsAlgorithm.ES256); //Fixed, see my final solution link above
</code></pre>
","1123","<c#><jwt><x509certificate><ecdsa>","1","0","2","2017-03-23 19:49:20","42932855","0","","823800","","2017-03-21 16:40:50","2017-03-20 23:45:14",""
"45370591","ssh-add error with ECDSA and ED25519 identities","<p>Linux environment: Debian 9.1, with Gnome desktop</p>

<p>I have both ECDSA and ED25519 identities, but from command line, ssh-add command gives error: </p>

<blockquote>
  <p>Could not add identity</p>
</blockquote>

<p>How to solve?</p>
","<p>according to:</p>

<p><a href=""https://bugzilla.gnome.org/show_bug.cgi?id=641082#c22"" rel=""noreferrer"">https://bugzilla.gnome.org/show_bug.cgi?id=641082#c22</a></p>

<p>the bug is relative to gnome-keyring support with ECDSA keys.</p>

<p>The fix which works for me is:</p>

<pre><code>mkdir -p ~/.config/autostart
cp /etc/xdg/autostart/gnome-keyring-ssh.desktop ~/.config/autostart/
echo ""X-GNOME-Autostart-enabled=false"" &gt;&gt; ~/.config/autostart/gnome-
keyring-ssh.desktop
</code></pre>

<p>After reboot, ssh-add works correctly from command line:</p>

<pre><code>marco@cluster:~$ ssh-add
Enter passphrase for /home/marco/.ssh/id_rsa: 
Identity added: /home/marco/.ssh/id_ecdsa (/home/marco/.ssh/id_ecdsa)
Identity added: /home/marco/.ssh/id_ed25519 (marco@cluster)
</code></pre>
","1112","<linux><ssh><ecdsa>","2","5","1","2017-07-28 10:04:52","45370592","0","","","","","2017-07-28 10:04:52",""
"49181750","ECDSA isn't suported in Java 1.8?","<p>I think that on my machine (Debian 10, linux, JAVA 1.8 OpenJDK), ECDSA isn't supported by Java.</p>

<p>Why? Because this line throws exception:</p>

<pre><code>KeyFactory kf = KeyFactory.getInstance(""ECDSA"");
</code></pre>

<p>However, if I change ECDSA to RSA for example, no exception is raised then.</p>

<p>I'm using Debian GNU/Linux as mentioned. Should I install some package or something like that?</p>

<p>Thanks</p>
","<p>As a <code>KeyFactory</code>, it appears that the name is just <code>""EC""</code>, not <code>""ECDSA""</code>.</p>

<hr>

<p>You can list the available key factories using the following code (Java 5+):</p>

<pre><code>for (Provider provider : Security.getProviders()) {
    System.out.println(provider.getName());
    for (Service service : provider.getServices()) {
        if (service.getType().equals(""KeyFactory""))
            System.out.println(""  "" + service.getAlgorithm());
    }
}
</code></pre>

<p>I've run it on various Java versions on my Windows 7 machine. As you can see below, Java for Windows comes with the following Key Factories:</p>

<ul>
<li>DSA</li>
<li>RSA</li>
<li>EC &nbsp; <em>(Java 7+)</em></li>
<li>RSA</li>
<li>DiffieHellman</li>
</ul>

<p><em>Java 9.0.1</em></p>

<pre class=""lang-none prettyprint-override""><code>SUN
  DSA
SunRsaSign
  RSA
SunEC
  EC
SunJSSE
  RSA
SunJCE
  DiffieHellman
SunJGSS
SunSASL
XMLDSig
SunPCSC
JdkLDAP
JdkSASL
SunMSCAPI
SunPKCS11
</code></pre>

<p><em>Java 1.8.0_151</em></p>

<pre class=""lang-none prettyprint-override""><code>SUN
  DSA
SunRsaSign
  RSA
SunEC
  EC
SunJSSE
  RSA
SunJCE
  DiffieHellman
SunJGSS
SunSASL
XMLDSig
SunPCSC
SunMSCAPI
</code></pre>

<p><em>Java 1.7.0_79</em></p>

<pre class=""lang-none prettyprint-override""><code>SUN
  DSA
SunRsaSign
  RSA
SunEC
  EC
SunJSSE
  RSA
SunJCE
  DiffieHellman
SunJGSS
SunSASL
XMLDSig
SunPCSC
SunMSCAPI
</code></pre>

<p><em>Java 1.6.0_45</em></p>

<pre class=""lang-none prettyprint-override""><code>SUN
  DSA
SunRsaSign
  RSA
SunJSSE
  RSA
SunJCE
  DiffieHellman
SunJGSS
SunSASL
XMLDSig
SunPCSC
SunMSCAPI
</code></pre>

<p><em>Java 1.5.0_22</em></p>

<pre class=""lang-none prettyprint-override""><code>SUN
  DSA
SunRsaSign
  RSA
SunJSSE
  RSA
SunJCE
  DiffieHellman
SunJGSS
SunSASL
</code></pre>
","1101","<java><ecdsa>","1","4","1","2018-03-08 20:35:16","","4","","402884","","2018-03-08 20:35:16","2018-03-08 20:17:43",""
"34057395","Android verify CA signature in X.509 Certificate","<p>I have a Root CA certificate and a User certificate that has been signed by the CA.  Under Windows using Certutil or OpenSSL I can verify that the CA's signature on the User certificate signature is OK.  Now I am trying to verify the same signature under Android.</p>

<p>I use Spongy Castle, though I am not sure that it is totally necessary for this step.  I use ECDH 384-bit key pairs.  The signature is ""SHA384WITHECDSA"".  I can generate a self-signed certificate and verify its signature either by the certificate.verify method or by calculating the signature:</p>

<pre><code>public static byte[] GenerateMyClientCertificate()
            throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException
    {
        // Create the keys
        KeyPairGenerator ClientkeyPair = KeyPairGenerator.getInstance(""ECDH"", ""SC"");
        ECGenParameterSpec ecParamSpec2 = new ECGenParameterSpec(""P-384"");
        ClientkeyPair.initialize(ecParamSpec2);
        KeyPair clientKeyPair = ClientkeyPair.generateKeyPair();

        PublicKey publicKey = clientKeyPair.getPublic();
        PrivateKey privateKey = clientKeyPair.getPrivate();

        X509Certificate x509cert = null;
        byte[] derCert = null;
        // generate the certificate
        try {
            x509cert = generateV3Certificate(clientKeyPair);
            derCert = x509cert.getEncoded();

        //Certificate test using verify:
        x509cert.checkValidity(new Date());
        x509cert.verify(x509cert.getPublicKey(), ""SC"");  //This cert is self-signed...
        System.out.println(""valid certificate generated"");

        //Another test: (verify not using cert.verify but rather calculating the signature)
        Signature verifier = Signature.getInstance(""SHA384WITHECDSA"", ""SC"");
        boolean result=false;
        verifier.initVerify(x509cert.getPublicKey()); // This cert is self-signed
        verifier.update(x509cert.getTBSCertificate());  //TBS is to get the ""To Be Signed"" part of the certificate - .getEncoded() gets the whole cert, which includes the signature
        result = verifier.verify(x509cert.getSignature());
        if (result == false)
        {
            System.out.println(""signature validation failed"");
        }
        //end of another verification
    }
    catch (Exception e)
    {
        //
    }
    return derCert;
} //GenerateMyClientCertificate
</code></pre>

<p>In the same way, I can check the CA certificate, which is also a self-signed certificate:</p>

<pre><code>//Certificate validity test using verify: -- This seems to work well for self-signed certificates...
        RootCaX509Cert.checkValidity(new Date());
        RootCaX509Cert.verify(RootCaX509Cert.getPublicKey(), ""SC"");  //This cert is self-signed...
        System.out.println(""valid certificate generated"");

        //Another test: (verify not using cert.verify but rather calculating the signature)
        Signature verifier = Signature.getInstance(""SHA384WITHECDSA"", ""SC"");
        boolean result=false;
        verifier.initVerify(RootCaX509Cert.getPublicKey()); // This cert is self-signed
        verifier.update(RootCaX509Cert.getTBSCertificate());  //TBS is to get the ""To Be Signed"" part of the certificate - .getEncoded() gets the whole cert, which includes the signature
        result = verifier.verify(RootCaX509Cert.getSignature());
        if (result == false)
        {
            System.out.println(""signature validation failed"");
        }
</code></pre>

<p>Now I want to check the User certificate, using the public key of the CA certificate.  But neither of the above verify methods work:</p>

<pre><code>        //Certificate validity test using verify: -- This seems to work well for self-signed certificates...
        ServerX509Cert.checkValidity(new Date());
        ServerX509Cert.verify(RootCaX509Cert.getPublicKey(), ""SC"");  //This cert was signed by CA
        System.out.println(""valid certificate generated"");

        //Another test: (verify not using cert.verify but rather calculating the signature)
        Signature verifier = Signature.getInstance(""SHA384WITHECDSA"", ""SC"");
        boolean result=false;
        verifier.initVerify(RootCaX509Cert.getPublicKey()); // This cert is signed by CA
        verifier.update(ServerX509Cert.getTBSCertificate());  //TBS is to get the ""To Be Signed"" part of the certificate - .getEncoded() gets the whole cert, which includes the signature
        result = verifier.verify(ServerX509Cert.getSignature());
        if (result == false)
        {
            System.out.println(""signature validation failed"");
        }
</code></pre>

<p>So currently I can only check self-signed certificates :( 
I would have thought that using RootCaX509Cert.getPublicKey() as the key here would have worked, but it does not.  Maybe I misunderstand how this CA signature verification should be done?  </p>
","","1098","<java><android><digital-signature><ecdsa><spongycastle>","2","","0","2015-12-07 16:41:24","","0","1","5632644","","2015-12-07 16:41:24","2015-12-03 03:30:42",""
"20205728","Hex encode ECDSA keys in node.js","<p>I'm building a nodejs app that talks to an API server. The API server requires that each request I make to it includes a <code>X-Signature</code> header using the <code>prime256v1</code> ECDSA curve and <code>sha256</code> hash on a particular set of data. </p>

<p>I looked through the <a href=""http://nodejs.org/api/crypto.html"" rel=""nofollow"">crypto</a> and <a href=""http://nodejs.org/api/tls.html"" rel=""nofollow"">tls</a> documentation but didn't find anything suitable. I have successfully generated a private key with <code>openssl ecparam -name prime256v1 -genkey</code> but it is in PEM format. I have also generated a DER format key. Both of these include some extra metadata like the curve used and in the case of PEM, comments. </p>

<p>I can use these keys for signing operations on my side, but the server requires that I upload a public key using hex encoding (so the server can verify the signatures I make on my requests.)</p>

<p>Specifically the server wants something like the output of the following Python code:</p>

<pre><code>from ecdsa import SigningKey
from binascii import hexlify
hexlify(SigningKey.from_pem(content).to_string())
</code></pre>

<p>Sample output for a pubkey (no newlines): <code>c5bd76cd0cd948de17a31261567d219576e992d9066fe1a6bca97496dec634e2c8e06f8949773b300b9f73fabbbc7710d5d6691e96bcf3c9145e15daf6fe07b9</code></p>

<p>I would prefer not adding python as a dependency to my node app... anyone know of a way I can extract the binary data representing my private key from the PEM or DER files, so I can put it in a buffer and call <code>buffer.toString('hex')</code>? Or a way I can use the native <code>crypto</code> library to generate the ECDSA keypair? Or a library that would do the same?</p>
","<p>openssl itself can print out the guts of things, in hex.</p>

<p>Doe the key change? sounds like you can just decode into hex one time, and use that?  No need for dependencies - just paste the hex into your node source?</p>
","1085","<node.js><openssl><public-key-encryption><ecdsa>","0","0","1","2014-01-14 10:33:12","","0","","","","","2013-11-25 23:36:59",""
"48783809","ECDSA sign with BouncyCastle and verify with Crypto++","<p>Here is the Java code:</p>

<p></p>

<pre><code>public static String sign(String data) throws Exception {
    KeyPair keyPair = loadKeyPair(System.getProperty(""user.dir""), ""ECDSA"");
    Signature signature = Signature.getInstance(""SHA256withECDSA"", ""BC"");
    signature.initSign(keyPair.getPrivate(), new SecureRandom());

    byte[] message = data.getBytes();
    signature.update(message);

    byte[] sigBytes = signature.sign();        
    String signatureStr = new BigInteger(1, sigBytes).toString(16);
    return signatureStr;
}
</code></pre>

<p>Then the C++ Code to verify signatures</p>

<p></p>

<pre><code>bool VerifyMessage( const ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; key, const string&amp; message, const string&amp; signature )
{
    bool result = false;

    // Hexa encoding version, more readable
    std::string decodedSignature;
    StringSource(signature, true,
                    new HexDecoder(
                       new StringSink(decodedSignature)));

    StringSource(decodedSignature+message, true,
                    new SignatureVerificationFilter(ECDSA&lt;ECP,SHA256&gt;::Verifier(key),
                       new ArraySink((byte*)&amp;result, sizeof(result))));

    return result;
}
</code></pre>

<p>I was thinking that I need to encode my signature to hexa but it didn't resolve my problem. I've written a c++ version of the sign method using crypto++ and it's verified. so why when I use the java code, the signature is not verified. Thanks</p>
","<blockquote>
  <p>... why when I use the java code, the signature is not verified?</p>
</blockquote>

<p>OpenSSL and Java use an ASN.1/DER encoding for the signature, and Crypto++ uses IEEE P1363's format for the signature.</p>

<ul>
<li>ASN.1: <code>SEQUENCE ::= { r INTEGER, s INTEGER }</code></li>
<li>P1363: <code>[byte array r][byte array s]</code></li>
</ul>

<p>You need to convert between the formats. Crypto++ provides <code>DSAConvertSignatureFormat</code> to convert between formats. There is an example on the Crypto++ wiki at <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm#OpenSSL_and_Java_Interop"" rel=""nofollow noreferrer"">Elliptic Curve Digital Signature Algorithm | OpenSSL and Java Interop</a>.</p>

<p>Here is the Crypto++ code from the wiki. It uses OpenSSL and its command line tools rather than Java. There is no material difference because OpenSSL and Java output signatures in ASN.1/DER format.</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""eccrypto.h""
#include ""files.h""
#include ""dsa.h""
#include ""sha.h""
#include ""hex.h""

#include &lt;iostream&gt;

using namespace CryptoPP;

int main(int argc, char* argv[])
{
    // Load DER encoded public key
    FileSource pubKey(""secp256k1-pub.der"", true /*binary*/);
    ECDSA&lt;ECP, SHA1&gt;::Verifier verifier(pubKey);

    // Java or OpenSSL created signature. It is ANS.1
    //   SEQUENCE ::= { r INTEGER, s INTEGER }.
    const byte derSignature[] = {
        0x30, 0x44, 0x02, 0x20, 0x08, 0x66, 0xc8, 0xf1,
        0x6f, 0x15, 0x00, 0x40, 0x8a, 0xe2, 0x1b, 0x40,
        0x56, 0x28, 0x9c, 0x17, 0x8b, 0xca, 0x64, 0x99,
        0x37, 0xdc, 0x35, 0xad, 0xad, 0x60, 0x18, 0x4d,
        0x63, 0xcf, 0x4a, 0x06, 0x02, 0x20, 0x78, 0x4c,
        0xb7, 0x0b, 0xa3, 0xff, 0x4f, 0xce, 0xd3, 0x01,
        0x27, 0x5c, 0x6c, 0xed, 0x06, 0xf0, 0xd7, 0x63,
        0x6d, 0xc6, 0xbe, 0x06, 0x59, 0xe8, 0xc3, 0xa5,
        0xce, 0x8a, 0xf1, 0xde, 0x01, 0xd5
    };

    // P1363 'r || s' concatenation. The size is 32+32 due to field
    // size for r and s in secp-256. It is not 20+20 due to SHA-1.
    SecByteBlock signature(verifier.SignatureLength());
    DSAConvertSignatureFormat(signature, signature.size(), DSA_P1363,
                              derSignature, sizeof(derSignature), DSA_DER);

    // Message ""Attack at dawn!""
    const byte message[] = {
        0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x20, 0x61,
        0x74, 0x20, 0x64, 0x61, 0x77, 0x6e, 0x21, 0x0a
    };

    // https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm
    bool result = verifier.VerifyMessage(message, sizeof(message), signature, signature.size());
    if (result)
        std::cout &lt;&lt; ""Verified message"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""Failed to verify message"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>And here is the result of running the test program.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Signature (64):
0866C8F16F1500408AE21B4056289C178BCA649937DC35ADAD60184D63CF4A06784CB70BA3FF4FCE
D301275C6CED06F0D7636DC6BE0659E8C3A5CE8AF1DE01D5
Verified message
</code></pre>

<hr>

<p>Here is the setup I used to reproduce <code>cat test.txt | openssl dgst -ecdsa-with-SHA1 -sign sample.key -keyform DER &gt; test.sig</code>. It is from @DivB's question at <a href=""https://stackoverflow.com/q/17316178/608639"">ECDSA sign with OpenSSL, verify with Crypto++</a>.</p>

<pre class=""lang-none prettyprint-override""><code>$ cat test.txt
Attack at dawn!

$ hexdump -C test.txt
00000000  41 74 74 61 63 6b 20 61  74 20 64 61 77 6e 21 0a  |Attack at dawn!.|
00000010

# Create private key in PEM format
$ openssl ecparam -name secp256k1 -genkey -noout -out secp256k1-key.pem

$ cat secp256k1-key.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIO0D5Rjmes/91Nb3dHY9dxmbM7gVfxmB2+OVuLmWMbGXoAcGBSuBBAAK
oUQDQgAEgVNEuirUNCEVdf7nLSBUgU1GXLrtIBeglIbK54s91HlWKOKjk4CkJ3/B
wGAfcYKa+DgJ2IUQSD15K1T/ghM9eQ==
-----END EC PRIVATE KEY-----

# Convert private key to ASN.1/DER format
$ openssl ec -in secp256k1-key.pem -inform PEM -out secp256k1-key.der -outform DER

$ dumpasn1 secp256k1-key.der
  0 116: SEQUENCE {
  2   1:   INTEGER 1
  5  32:   OCTET STRING
       :     ED 03 E5 18 E6 7A CF FD D4 D6 F7 74 76 3D 77 19
       :     9B 33 B8 15 7F 19 81 DB E3 95 B8 B9 96 31 B1 97
 39   7:   [0] {
 41   5:     OBJECT IDENTIFIER secp256k1 (1 3 132 0 10)
       :     }
 48  68:   [1] {
 50  66:     BIT STRING
       :       04 81 53 44 BA 2A D4 34 21 15 75 FE E7 2D 20 54
       :       81 4D 46 5C BA ED 20 17 A0 94 86 CA E7 8B 3D D4
       :       79 56 28 E2 A3 93 80 A4 27 7F C1 C0 60 1F 71 82
       :       9A F8 38 09 D8 85 10 48 3D 79 2B 54 FF 82 13 3D
       :       79
       :     }
       :   }

# Create public key from private key
$ openssl ec -in secp256k1-key.der -inform DER -pubout -out secp256k1-pub.der -outform DER

$ dumpasn1 secp256k1-pub.der
  0  86: SEQUENCE {
  2  16:   SEQUENCE {
  4   7:     OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
 13   5:     OBJECT IDENTIFIER secp256k1 (1 3 132 0 10)
       :     }
 20  66:   BIT STRING
       :     04 81 53 44 BA 2A D4 34 21 15 75 FE E7 2D 20 54
       :     81 4D 46 5C BA ED 20 17 A0 94 86 CA E7 8B 3D D4
       :     79 56 28 E2 A3 93 80 A4 27 7F C1 C0 60 1F 71 82
       :     9A F8 38 09 D8 85 10 48 3D 79 2B 54 FF 82 13 3D
       :     79
       :   }

# Sign the message using the private key
$ cat test.txt | openssl dgst -ecdsa-with-SHA1 -sign secp256k1-key.der -keyform DER &gt; test.sig

# Dump the signature as hex
$ hexdump -C test.sig
00000000  30 44 02 20 08 66 c8 f1  6f 15 00 40 8a e2 1b 40  |0D. .f..o..@...@|
00000010  56 28 9c 17 8b ca 64 99  37 dc 35 ad ad 60 18 4d  |V(....d.7.5..`.M|
00000020  63 cf 4a 06 02 20 78 4c  b7 0b a3 ff 4f ce d3 01  |c.J.. xL....O...|
00000030  27 5c 6c ed 06 f0 d7 63  6d c6 be 06 59 e8 c3 a5  |'\l....cm...Y...|
00000040  ce 8a f1 de 01 d5                                 |......|
00000046

# Dump the signature as ASN.1/DER
$ dumpasn1 test.sig
  0  68: SEQUENCE {
  2  32:   INTEGER
       :     08 66 C8 F1 6F 15 00 40 8A E2 1B 40 56 28 9C 17
       :     8B CA 64 99 37 DC 35 AD AD 60 18 4D 63 CF 4A 06
 36  32:   INTEGER
       :     78 4C B7 0B A3 FF 4F CE D3 01 27 5C 6C ED 06 F0
       :     D7 63 6D C6 BE 06 59 E8 C3 A5 CE 8A F1 DE 01 D5
       :   }
</code></pre>
","1056","<java><c++><bouncycastle><crypto++><ecdsa>","2","2","2","2019-10-07 04:34:06","48784823","1","","608639","","2018-02-16 08:26:31","2018-02-14 09:36:16",""
"48783809","ECDSA sign with BouncyCastle and verify with Crypto++","<p>Here is the Java code:</p>

<p></p>

<pre><code>public static String sign(String data) throws Exception {
    KeyPair keyPair = loadKeyPair(System.getProperty(""user.dir""), ""ECDSA"");
    Signature signature = Signature.getInstance(""SHA256withECDSA"", ""BC"");
    signature.initSign(keyPair.getPrivate(), new SecureRandom());

    byte[] message = data.getBytes();
    signature.update(message);

    byte[] sigBytes = signature.sign();        
    String signatureStr = new BigInteger(1, sigBytes).toString(16);
    return signatureStr;
}
</code></pre>

<p>Then the C++ Code to verify signatures</p>

<p></p>

<pre><code>bool VerifyMessage( const ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; key, const string&amp; message, const string&amp; signature )
{
    bool result = false;

    // Hexa encoding version, more readable
    std::string decodedSignature;
    StringSource(signature, true,
                    new HexDecoder(
                       new StringSink(decodedSignature)));

    StringSource(decodedSignature+message, true,
                    new SignatureVerificationFilter(ECDSA&lt;ECP,SHA256&gt;::Verifier(key),
                       new ArraySink((byte*)&amp;result, sizeof(result))));

    return result;
}
</code></pre>

<p>I was thinking that I need to encode my signature to hexa but it didn't resolve my problem. I've written a c++ version of the sign method using crypto++ and it's verified. so why when I use the java code, the signature is not verified. Thanks</p>
","<p>By the way, another way around your problem (especially allowing you to avoid the command line) would be to modify the Java code in order to have a way to produce the R and S values, as well as to reproduce the DER encoded values.</p>

<p>For example you can extract the R and S values from the Java signature using those:</p>

<pre><code>public static BigInteger extractR(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startR + 2, startR + 2 + lengthR));
}

public static BigInteger extractS(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    int startS = startR + 2 + lengthR;
    int lengthS = signature[startS + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startS + 2, startS + 2 + lengthS));
}
</code></pre>

<p>These methods are notably <a href=""https://github.com/google/wycheproof/blob/9cd6c67936e659f64e451244c98512cf4094e52b/java/com/google/security/wycheproof/testcases/EcdsaTest.java#L572:L588"" rel=""nofollow noreferrer"">used in Wycheproof</a> to play around with the BigIntegers directly.</p>

<p>These can allow you to reconstruct the P1363 encoding used by CryptoPP in Java, but be careful not to forget the left padding with 0s of the bytearrays. (Otherwise you may have problems when the R or S bytearray is smaller than the expected length.)</p>

<p>And you can also reconstruct the DER encoded signature from big integers using:</p>

<pre><code>public static byte[] derSign(BigInteger r, BigInteger s) throws Exception {
    byte[] rb = r.toByteArray();
    byte[] sb = s.toByteArray();
    int off = (2 + 2) + rb.length;
    int tot = off + (2 - 2) + sb.length;
    byte[] der = new byte[tot + 2];
    der[0] = 0x30;
    der[1] = (byte) (tot &amp; 0xff);
    der[2 + 0] = 0x02;
    der[2 + 1] = (byte) (rb.length &amp; 0xff);
    System.arraycopy(rb, 0, der, 2 + 2, rb.length);
    der[off + 0] = 0x02;
    der[off + 1] = (byte) (sb.length &amp; 0xff);
    System.arraycopy(sb, 0, der, off + 2, sb.length);
    return der;
}
</code></pre>

<p>As you can see, these methods might be translated into C++ code, since they are really basic byte manipulations, but that's another story ;)</p>
","1056","<java><c++><bouncycastle><crypto++><ecdsa>","2","1","2","2019-10-07 04:34:06","48784823","1","","608639","","2018-02-16 08:26:31","2018-02-14 09:36:16",""
"48685191","Separating public and private keys of ECDSA keypair","<p>I'm using c++ to try to generate a ECDSA key-pair following <a href=""https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography"" rel=""nofollow noreferrer"">Elliptic_Curve_Cryptography</a> from the OpenSSL wiki.</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;openssl/obj_mac.h&gt;
#include &lt;openssl/ec.h&gt;

int main()
{
    EC_KEY *key;

    if(NULL == (key = EC_KEY_new_by_curve_name(NID_secp224r1)))
        std::cout &lt;&lt; ""error on new_curve_by_name"" &lt;&lt; std::endl;

    if(1 != EC_KEY_generate_key(key)) std::cout &lt;&lt; ""error in generating keys"" &lt;&lt; std::endl;
}
</code></pre>

<p>The key pair is generated without errors, but I don't know how to extract public and private key in two different objects (EC_POINT and BIGNUM), any idea?</p>
","<p>I think you must do the following :</p>

<pre><code>BIGNUM *privateKey;
EC_POINT *publicKey;

privateKey = BN_new();
EC_KEY_set_private_key(key, privateKey);
EC_KEY_set_public_key(key, publicKey);
</code></pre>

<p>EDIT : </p>

<p>These two calls will set the <code>privateKey</code> and the <code>publicKey</code> respectively.
<a href=""https://www.openssl.org/docs/manmaster/man3/BN_dup.html"" rel=""nofollow noreferrer"">Open SSL Documentation</a> claims that ""<strong>destination should be a newly allocated BIGNUM obtained via a call to</strong> <code>BN_new()</code>. <strong>It should not have been used for other purposes or initialised in any way.</strong>"", hence i am adding the <code>BN_new()</code> call.</p>

<p>I don't see anything similar to create an EC_Point object( unless you use an EC_Group to create this way : <code>EC_POINT *EC_POINT_new(const EC_GROUP *group);</code></p>

<p>So try this, if you still don't get it, then maybe you should look into how an EC_Point object is created correctly according to your usage.</p>
","1017","<c++><openssl><ecdsa><key-pair>","2","0","3","2018-02-09 02:06:31","48688270","1","1","608639","","2018-02-09 01:54:27","2018-02-08 12:11:03",""
"48685191","Separating public and private keys of ECDSA keypair","<p>I'm using c++ to try to generate a ECDSA key-pair following <a href=""https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography"" rel=""nofollow noreferrer"">Elliptic_Curve_Cryptography</a> from the OpenSSL wiki.</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;openssl/obj_mac.h&gt;
#include &lt;openssl/ec.h&gt;

int main()
{
    EC_KEY *key;

    if(NULL == (key = EC_KEY_new_by_curve_name(NID_secp224r1)))
        std::cout &lt;&lt; ""error on new_curve_by_name"" &lt;&lt; std::endl;

    if(1 != EC_KEY_generate_key(key)) std::cout &lt;&lt; ""error in generating keys"" &lt;&lt; std::endl;
}
</code></pre>

<p>The key pair is generated without errors, but I don't know how to extract public and private key in two different objects (EC_POINT and BIGNUM), any idea?</p>
","<p>This returns the private key as a BIGNUM</p>

<pre><code>BIGNUM* bn = EC_KEY_get0_private_key(key);
</code></pre>

<p>For the public key not sure how to get an EC_POINT but you can get the raw bytes with something like: </p>

<pre><code>  // first call returns length of key
  int len = i2o_ECPublicKey(key, 0);  
  std::vector&lt;unsigned char&gt; bytes b(len, 0);
  unsigned char* p = &amp;b[0];
  // second call copies key into p (and returns length if successful)
  if (i2o_ECPublicKey(key, &amp;p)) != len)
  {
    // handle error
  }
</code></pre>
","1017","<c++><openssl><ecdsa><key-pair>","2","0","3","2018-02-09 02:06:31","48688270","1","1","608639","","2018-02-09 01:54:27","2018-02-08 12:11:03",""
"48685191","Separating public and private keys of ECDSA keypair","<p>I'm using c++ to try to generate a ECDSA key-pair following <a href=""https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography"" rel=""nofollow noreferrer"">Elliptic_Curve_Cryptography</a> from the OpenSSL wiki.</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;openssl/obj_mac.h&gt;
#include &lt;openssl/ec.h&gt;

int main()
{
    EC_KEY *key;

    if(NULL == (key = EC_KEY_new_by_curve_name(NID_secp224r1)))
        std::cout &lt;&lt; ""error on new_curve_by_name"" &lt;&lt; std::endl;

    if(1 != EC_KEY_generate_key(key)) std::cout &lt;&lt; ""error in generating keys"" &lt;&lt; std::endl;
}
</code></pre>

<p>The key pair is generated without errors, but I don't know how to extract public and private key in two different objects (EC_POINT and BIGNUM), any idea?</p>
","<p>I think the methods you want are:</p>

<p><a href=""https://www.openssl.org/docs/man1.1.0/crypto/EC_KEY_get0_private_key.html"" rel=""nofollow noreferrer"">EC_KEY_get0_private_key</a> and 
<a href=""https://www.openssl.org/docs/man1.1.0/crypto/EC_KEY_get0_public_key.html"" rel=""nofollow noreferrer"">EC_KEY_get0_public_key</a></p>

<p>This works for me:</p>

<pre><code>EC_KEY* key = EC_KEY_new_by_curve_name(NID_secp224r1);

if(!key)
{
    std::cerr &lt;&lt; ""Error creating curve key"" &lt;&lt; '\n';
    return EXIT_FAILURE;
}

if(!EC_KEY_generate_key(key))
{
    std::cerr &lt;&lt; ""Error generating curve key"" &lt;&lt; '\n';
    EC_KEY_free(key);
    return EXIT_FAILURE;
}

BIGNUM const* prv = EC_KEY_get0_private_key(key);
if(!prv)
{
    std::cerr &lt;&lt; ""Error getting private key"" &lt;&lt; '\n';
    EC_KEY_free(key);
    return EXIT_FAILURE;
}

std::cout &lt;&lt; ""Private key: "" &lt;&lt; prv &lt;&lt; '\n';

EC_POINT const* pub = EC_KEY_get0_public_key(key);
if(!pub)
{
    std::cerr &lt;&lt; ""Error getting public key"" &lt;&lt; '\n';
    EC_KEY_free(key);
    return EXIT_FAILURE;
}

std::cout &lt;&lt; ""Public key: "" &lt;&lt; pub &lt;&lt; '\n';

// Use keys here ...

EC_KEY_free(key);
</code></pre>

<p><strong>NOTE:</strong></p>

<p>When using <code>C</code> libraries like this I often define a custom <em>smart pointer</em> to take care if the deletions. This makes the code less prone to memory leaks and ""exception safe"".</p>

<p>For example I would define something like this:</p>

<pre><code>struct ec_key_dter{void operator()(EC_KEY* k)const{if(k) EC_KEY_free(k);}};
using  ec_key_uptr = std::unique_ptr&lt;EC_KEY, ec_key_dter&gt;;
</code></pre>

<p>And use it like this:</p>

<pre><code>auto key = ec_key_uptr(EC_KEY_new_by_curve_name(NID_secp224r1));

if(!key)
    throw std::runtime_error(""Error creating curve key"");

if(!EC_KEY_generate_key(key.get()))
    throw std::runtime_error(""Error generating curve key"");

if(!EC_KEY_check_key(key.get()))
    throw std::runtime_error(""Error checking curve key"");

// ... etc ...

// Do not delete the key manually!!
</code></pre>
","1017","<c++><openssl><ecdsa><key-pair>","2","3","3","2018-02-09 02:06:31","48688270","1","1","608639","","2018-02-09 01:54:27","2018-02-08 12:11:03",""
"44149608","Generate a VAPID keys in Java and pass them to JavaScript PushManager","<p>Im trying to use web push notifications with the web push protocol in my app. In order to use the Push API with VAPID I need an <code>applicationServerKey</code>. </p>

<p>The PushManager <code>subscribe</code> method takes a VAPID key (public key alone) as a parameter and will give a subscription end point and keys to push messages.</p>

<p>To generate VAPID keys, I have been using node.js (google <code>web-push</code> package) and <code>openssl</code> till now. But in my use case VAPID keys should be generated within Java and passed to JavaScript to subscribe from the browser. </p>

<p>I am trying with the code below in Java to generate VAPID keys. I am able to create keys successfully but when I pass the generated public key (base64-encoded string), the <code>subscribe</code> method returns an error saying: </p>

<blockquote>
  <p>Unable to register service worker. DOMException: Failed to execute
  'subscribe' on 'PushManager': The provided applicationServerKey is not
  valid..</p>
</blockquote>

<p>Please help me resolve this issue. Below is my Java code:</p>

<pre class=""lang-java prettyprint-override""><code>ECNamedCurveParameterSpec parameterSpec = 
ECNamedCurveTable.getParameterSpec(""prime256v1"");
KeyPairGenerator keyPairGenerator = 
KeyPairGenerator.getInstance(""ECDH"", ""BC"");
keyPairGenerator.initialize(parameterSpec);
KeyPair serverKey = keyPairGenerator.generateKeyPair();

PrivateKey priv = serverKey.getPrivate();
PublicKey pub = serverKey.getPublic();`
System.out.println(Base64.toBase64String(pub.getEncoded()));
</code></pre>
","<p>Please refer below link for answer from MartijnDwars.
<a href=""https://github.com/web-push-libs/webpush-java/issues/30"" rel=""nofollow noreferrer"">https://github.com/web-push-libs/webpush-java/issues/30</a></p>

<blockquote>
  <p>you can use Utils.savePublicKey to convert your Java-generated
  PublicKey to a byte[]. This byte[] is then passed to the
  PushManager.subscribe method.</p>
  
  <p>It may be more convenient to base64 encode the byte[] in Java and
  base64 decode the string in JavaScript. For example, after generating
  the keypair in Java:</p>

<pre><code>KeyPair keyPair = generateKeyPair();
byte[] publicKey = Utils.savePublicKey((ECPublicKey) keyPair.getPublic());
String publicKeyBase64 = BaseEncoding.base64Url().encode(publicKey);
System.out.println(""PublicKey = "" + publicKeyBase64);
// PublicKey = BPf36QAqZNNvvnl9kkpTDerXUOt6Nm6P4x9GEvmFVFKgVyCVWy24KUTs6wLQtbV2Ug81utbNnx86_vZzXDyrl88=
</code></pre>
  
  <p>Then in JavaScript:</p>

<pre><code>function subscribe() {
    const publicKey = base64UrlToUint8Array('BPf36QAqZNNvvnl9kkpTDerXUOt6Nm6P4x9GEvmFVFKgVyCVWy24KUTs6wLQtbV2Ug81utbNnx86_vZzXDyrl88=');

    navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {
        serviceWorkerRegistration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: publicKey
        })
        .then(function (subscription) {
            return sendSubscriptionToServer(subscription);
        })
        .catch(function (e) {
            if (Notification.permission === 'denied') {
                console.warn('Permission for Notifications was denied');
            } else {
                console.error('Unable to subscribe to push.', e);
            }
        });
    });
}

function base64UrlToUint8Array(base64UrlData) {
    const padding = '='.repeat((4 - base64UrlData.length % 4) % 4);
    const base64 = (base64UrlData + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

    const rawData = atob(base64);
    const buffer = new Uint8Array(rawData.length);

    for (let i = 0; i &lt; rawData.length; ++i) {
        buffer[i] = rawData.charCodeAt(i);
    }

    return buffer;
}
</code></pre>
</blockquote>
","979","<java><bouncycastle><web-push><ecdsa><vapid>","0","2","1","2017-11-06 06:00:47","","1","","441757","","2017-05-24 05:57:16","2017-05-24 05:23:24",""
"39761249","What is the format of this private key?","<p>I got a pem key like this:</p>

<pre><code> -----BEGIN PRIVATE KEY----- 

 MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgDZUgDvKixfLi8cK8
 /TFLY97TDmQV3J2ygPpvuI8jSdihRANCAARRN3xgbPIR83dr27UuDaf2OJezpEJx
 UC3v06+FD8MUNcRAboqt4akehaNNSh7MMZI+HdnsM4RXN2y8NePUQsPL

 -----END PRIVATE KEY-----
</code></pre>

<p>I only know that this key is used for ecdsa signature.</p>

<p>Now I want to know the real value of the key, because I need it to calculate something, and I believe there is some kind of header in front of the real value.</p>

<p>I tried to use python-ecdsa to parse the key, but obviously didn't work. </p>

<p>How can I get the real value?</p>
","<p>It looks like you have an ASN1 structure representing an ECDSA private key for the NIST P-256 curve, and it was encoded as a PEM file.</p>

<p>I was able to get your private and public key and the curve information using the OpenSSL command-line utility:</p>

<pre><code>$ openssl ec -in test.pem -text -noout
read EC key
Private-Key: (256 bit)
priv:
    0d:95:20:0e:f2:a2:c5:f2:e2:f1:c2:bc:fd:31:4b:
    63:de:d3:0e:64:15:dc:9d:b2:80:fa:6f:b8:8f:23:
    49:d8
pub: 
    04:51:37:7c:60:6c:f2:11:f3:77:6b:db:b5:2e:0d:
    a7:f6:38:97:b3:a4:42:71:50:2d:ef:d3:af:85:0f:
    c3:14:35:c4:40:6e:8a:ad:e1:a9:1e:85:a3:4d:4a:
    1e:cc:31:92:3e:1d:d9:ec:33:84:57:37:6c:bc:35:
    e3:d4:42:c3:cb
ASN1 OID: prime256v1
NIST CURVE: P-256
</code></pre>

<p>You can also look at the ASN1 structure itself:</p>

<pre><code>$ openssl asn1parse -in test.pem 
    0:d=0  hl=3 l= 135 cons: SEQUENCE          
    3:d=1  hl=2 l=   1 prim: INTEGER           :00
    6:d=1  hl=2 l=  19 cons: SEQUENCE          
    8:d=2  hl=2 l=   7 prim: OBJECT            :id-ecPublicKey
   17:d=2  hl=2 l=   8 prim: OBJECT            :prime256v1
   27:d=1  hl=2 l= 109 prim: OCTET STRING      [HEX DUMP]:306B02010104200D95200EF2A2C5F2E2F1C2BCFD314B63DED30E6415DC9DB280FA6FB88F2349D8A1440342000451377C606CF211F3776BDBB52E0DA7F63897B3A44271502DEFD3AF850FC31435C4406E8AADE1A91E85A34D4A1ECC31923E1DD9EC338457376CBC35E3D442C3CB
</code></pre>
","923","<ecdsa>","1","1","1","2016-09-30 04:49:03","39783875","0","","1932092","","2016-09-29 05:33:14","2016-09-29 04:08:22",""
"24066444","How to sign using ECDSA in Javacard","<p>I'm trying to implement the signing code using ECDSA.
But I always get a Error SW (6F00) during install phase.
I tried by changing parameters several times. (ex. ALG_EC_FP / ALG_EC_F2M, LENGTH_EC_FP_xxx / LENGTH_EC_F2M_xxx)
Could you tell me my mistake in my code below.
(Ver - JCDK 2.2.1, JDK 1.4.2)</p>

<hr>

<pre><code>package Test;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class Test extends Applet{

private byte[] PLAINTEXT ;
private ECPrivateKey objECDSAPriKey=null;   // Object for ECDSA Private Key
private ECPublicKey objECDSAPubKey=null;    // Object for ECDSA Public Key
private KeyPair objECDSAKeyPair=null;       // Object for ECDSA Key Pair
private Signature objECDSASign=null;        // Object for ECDSA Signature

final static short BAS =  0;

//------------------------------------------------------------------------
public static void install(byte[] bArray, short bOffset, byte bLength){
  new Test(bArray, bOffset, bLength);
}

private Test(byte bArray[], short bOffset, byte bLength){ 
  PLAINTEXT = new byte[0x100] ; // Data file
  Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

  // Error position (6F00)
  objECDSAKeyPair= new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);          // Error position (6F00)

  // Create Signature Object
  objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

  register();
}

//------------------------------------------------------------------------
public void process(APDU apdu){
  byte buf[] = apdu.getBuffer();

  switch(buf[1])
  {
  case (byte)0xA4: break;

  case (byte)0x46:
  objECDSAKeyPair.genKeyPair();
  objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
  objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();
  break;

  case (byte)0x2E:
  short Le = apdu.setOutgoing();
  short sSignLen=0 ;

  // Init with Private Key
  objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);
  //objECDSASign.init(objECDSAKeyPair.getPrivate(), Signature.MODE_SIGN);

  // Sign Data
  sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

  apdu.setOutgoingLength(sSignLen);
  apdu.sendBytes(BAS, sSignLen);
  break;

  default:
  ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
  }

  return;
} }
</code></pre>

<hr>

<p>I got a JCOP card and its specification, and I read that the card support ECC in the spec.
But I doubt that the spec is the card's spec and the card really support ECC.
Is there any way to check that???</p>

<p>Thank you in advance.</p>
","<p>Please modify your code to</p>

<pre><code>try
  {
     // Error position (6F00)
     objECDSAKeyPair= new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192); 
  }
  catch(CryptoException c)
  {    
      //this line will give you the reason of problem ![see image][1]
      byte reason = c.getReason();   
  }
</code></pre>

<p>*image link : <a href=""http://i.stack.imgur.com/dFXVd.png"" rel=""nofollow"">http://i.stack.imgur.com/dFXVd.png</a></p>
","869","<signing><javacard><ecdsa>","1","2","1","2014-07-08 08:38:42","24074978","2","","2642459","","2014-06-06 03:37:39","2014-06-05 17:24:58",""
"39916578","Import an ECDSA public key from CngKey to BouncyCastle","<p>I am trying to generate an x509 certificate from a pair of keys generated with CngKey. 
I create the keys with: </p>

<pre><code>        var parameters = new CngKeyCreationParameters 
        { 
            Provider = CngProvider.MicrosoftSoftwareKeyStorageProvider, 
            ExportPolicy = CngExportPolicies.AllowPlaintextExport, 
            KeyCreationOptions = CngKeyCreationOptions.OverwriteExistingKey, 
            KeyUsage = CngKeyUsages.AllUsages, 
            UIPolicy = new CngUIPolicy(CngUIProtectionLevels.None) 
        }; 
        var key = CngKey.Create(CngAlgorithm.ECDsaP384, container, parameters); 
        byte[] ecPriKey = key.Export(CngKeyBlobFormat.Pkcs8PrivateBlob); 
        byte[] ecPubKey = key.Export(CngKeyBlobFormat.EccPublicBlob); 
</code></pre>

<p>I get a BouncyCastle private key with: </p>

<pre><code>        AsymmetricKeyParameter akPrivate = PrivateKeyFactory.CreateKey(ecPriKey); 
</code></pre>

<p>And I have no trouble in it, so that I can see the proper curve's parameters from the key. </p>

<p>However, when I try to get the public key with: </p>

<pre><code>          string publicKeyBase64 = Convert.ToBase64String(ecPubKey); 
          byte[] ecPubKey2 = Base64.Decode(publicKeyBase64); 
          byte[] ecPublicKey = new byte[ecPubKey.Length -7]; 
          ecPublicKey[0] = 0x04; 
          Array.Copy(ecPubKey, 8, ecPublicKey, 7, ecPublicKey.Length); 
          AsymmetricKeyParameter akPublic = PublicKeyFactory.CreateKey(ecPublicKey - 1); 
</code></pre>

<p>I read I have to erase the 8 first digits from CngKey and add the uncompressed const value 0x04. 
When I execute ""PublicKeyFactory.CreateKey(ecPublicKey)"" I get the exception: </p>

<pre><code>ex  {""extra data found after object""}   System.Exception {System.IO.IOException} 
Data    {System.Collections.ListDictionaryInternal} System.Collections.IDictionary {System.Collections.ListDictionaryInternal} 
            HResult 0x80131620  int 
            HelpLink    null    string 
InnerException  null    System.Exception 
            Message ""extra data found after object"" string 
            Source  ""BouncyCastle.Crypto""   string 
            StackTrace  ""   at Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(Byte[] data)\r\n   at Org.BouncyCastle.Security.PublicKeyFactory.CreateKey(Byte[] keyInfoData)\r\n   at Plpm.Csp.Security.KeyTool.SecurityKeyTool.OpGenEc(String[] args) in ...""  string 
TargetSite  {Org.BouncyCastle.Asn1.Asn1Object FromByteArray(Byte[])}    System.Reflection.MethodBase {System.Reflection.RuntimeMethodInfo} 
Static members  
Non-Public members  
</code></pre>

<p>Anyway, I get the same exception if I do this directly with the key as:</p>

<pre><code>        AsymmetricKeyParameter akPublic = PublicKeyFactory.CreateKey(ecPubKey); 
</code></pre>

<p>Can someone, please, give me some ideas about why is this error with public key? </p>

<p>Thank you so much.</p>
","","864","<c#><bouncycastle><ecdsa><cng>","3","","0","2016-10-07 11:51:22","","0","","","","","2016-10-07 11:51:22",""
"21128386","Is there public key initialization API with point compression?","<p>I am tumbling around with CryptoPP and cannot find answer to this specific question. Here is sample source code (partial)</p>

<pre><code>    AutoSeededRandomPool prng;

//Generate a private key
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
privateKey.Initialize(prng, CryptoPP::ASN1::secp256r1());

// Generate publicKey
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;
privateKey.MakePublicKey(publicKey);

// Extract Component values
Integer p   = privateKey.GetGroupParameters().GetCurve().GetField().GetModulus();
Integer a   = privateKey.GetGroupParameters().GetCurve().GetA();
Integer b   = privateKey.GetGroupParameters().GetCurve().GetB();
Integer Gx  = privateKey.GetGroupParameters().GetSubgroupGenerator().x;
Integer Gy  = privateKey.GetGroupParameters().GetSubgroupGenerator().y;
Integer n   = privateKey.GetGroupParameters().GetSubgroupOrder();
Integer h   = privateKey.GetGroupParameters().GetCofactor();
Integer Qx  = publicKey.GetPublicElement().x;
Integer Qy  = publicKey.GetPublicElement().y;
Integer x   = privateKey.GetPrivateExponent();

// Construct Point elelemt;
ECP curve(p,a,b);
ECP::Point G(Gx,Gy);
ECP::Point Q(Qx,Qy);

//Build publicKey using elements (no point compression)
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey GeneratedPublicKey;
GeneratedPublicKey.Initialize(curve,G,n,Q);
assert(GeneratedPublicKey.Validate(prng, 3));

//Build publicKey using elements (with point compression)?
</code></pre>

<p>With this way, I can generate publicKey using component values. However, I cannot
make it work with point compression-which means I don't have Qy value- Is there a 
way to do it? Initialize method has two overloading but none of them are for point
compression situation.</p>

<p>My question is specific with Crypto++ on ""PublicKey.Initialize(curve,G,n,Q)"". Since I cannot transfer whole publicKey with my current project-which I am force to specify domain
parameter as index value and can only transfer Qx value. So I should initialize publicKey
using something like ""PublicKey.Initialize(curve,G,n,Q)"" However, I cannot find such initialization API concerning point compression. </p>

<p>So, this is not about ""how to do a point compression"" but ""Is there a way to initialize
public key without having Qy value?""</p>
","<blockquote>
  <p>How to Construct ECDSA publicKey using only with x value (Point compression)?</p>
</blockquote>

<p><code>x</code> is the private exponent. The public key is a point on the curve; and it does not use the private exponent.</p>

<p>To get the public key: take the private exponent, and raise your base point to it. That is, <code>Q = G^x</code>.</p>

<p>If you want to set the private exponent on a private key or decryptor, then set the domain parameters (i.e., <code>DL_GroupParameters_EC&lt; ECP &gt;</code> or <code>DL_GroupParameters_EC&lt; EC2M &gt;</code>) and then call <code>SetPrivateExponent(x);</code>.</p>

<hr>

<p>Have you reviewed your previous question at <a href=""https://stackoverflow.com/questions/20781563/crypto-ecsda-compressed-key-how-can-i-recover-compressed-y-value-from-other-e"">How can I recover compressed y value from sender?</a>? The community took the time to provide you with an answer and sample code, but you did not acknowledge or follow up.</p>

<p>I think <a href=""https://stackoverflow.com/users/589259/owlstead"">owlstead</a> said it best <a href=""https://stackoverflow.com/questions/18734616/rsa-encryption-and-decryption"">here</a>: </p>

<blockquote>
  <p>Why would we care answer you if you are not inclined to accept answers
  or even follow up to them? Your questions are all right, but the way
  you treat the community is terrible.</p>
</blockquote>
","861","<crypto++><ecdsa>","1","1","2","2017-08-21 11:58:23","","1","","608639","","2016-04-11 07:42:17","2014-01-15 03:05:12",""
"21128386","Is there public key initialization API with point compression?","<p>I am tumbling around with CryptoPP and cannot find answer to this specific question. Here is sample source code (partial)</p>

<pre><code>    AutoSeededRandomPool prng;

//Generate a private key
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
privateKey.Initialize(prng, CryptoPP::ASN1::secp256r1());

// Generate publicKey
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;
privateKey.MakePublicKey(publicKey);

// Extract Component values
Integer p   = privateKey.GetGroupParameters().GetCurve().GetField().GetModulus();
Integer a   = privateKey.GetGroupParameters().GetCurve().GetA();
Integer b   = privateKey.GetGroupParameters().GetCurve().GetB();
Integer Gx  = privateKey.GetGroupParameters().GetSubgroupGenerator().x;
Integer Gy  = privateKey.GetGroupParameters().GetSubgroupGenerator().y;
Integer n   = privateKey.GetGroupParameters().GetSubgroupOrder();
Integer h   = privateKey.GetGroupParameters().GetCofactor();
Integer Qx  = publicKey.GetPublicElement().x;
Integer Qy  = publicKey.GetPublicElement().y;
Integer x   = privateKey.GetPrivateExponent();

// Construct Point elelemt;
ECP curve(p,a,b);
ECP::Point G(Gx,Gy);
ECP::Point Q(Qx,Qy);

//Build publicKey using elements (no point compression)
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey GeneratedPublicKey;
GeneratedPublicKey.Initialize(curve,G,n,Q);
assert(GeneratedPublicKey.Validate(prng, 3));

//Build publicKey using elements (with point compression)?
</code></pre>

<p>With this way, I can generate publicKey using component values. However, I cannot
make it work with point compression-which means I don't have Qy value- Is there a 
way to do it? Initialize method has two overloading but none of them are for point
compression situation.</p>

<p>My question is specific with Crypto++ on ""PublicKey.Initialize(curve,G,n,Q)"". Since I cannot transfer whole publicKey with my current project-which I am force to specify domain
parameter as index value and can only transfer Qx value. So I should initialize publicKey
using something like ""PublicKey.Initialize(curve,G,n,Q)"" However, I cannot find such initialization API concerning point compression. </p>

<p>So, this is not about ""how to do a point compression"" but ""Is there a way to initialize
public key without having Qy value?""</p>
","<blockquote>
  <p>""Is there a way to initialize public key without having Qy value?""</p>
</blockquote>

<p>Yes, there is. Here is an crypto++ example:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/ecp.h&gt;
#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/osrng.h&gt;

using namespace CryptoPP;
using std::cout;
using std::endl;

int main() 
{
    OID curve = ASN1::secp256r1();
    ECDH&lt;ECP&gt;::Domain domain(curve);  

    SecByteBlock privKey(domain.PrivateKeyLength());
    SecByteBlock pubKey(domain.PublicKeyLength());
    AutoSeededRandomPool prng;
    domain.GenerateKeyPair(prng, privKey, pubKey); 

    // Convert public key to string representation
    std::string pub_str;
    HexEncoder encoder;
    encoder.Attach( new StringSink(pub_str) );
    encoder.Put( pubKey.data(), pubKey.size() );
    encoder.MessageEnd();

    // Uncompressed point - first byte '04' in front of the string. 
    std::cout &lt;&lt; ""Uncompressed public key (point) "" &lt;&lt; pub_str &lt;&lt; endl;

    // Extract x value from the point  
    std::string public_point_x = pub_str.substr(2, 64);

    // Compressed - '02' byte in front of the string. 
    public_point_x = ""02"" + public_point_x;
    std::cout &lt;&lt; ""Compressed public key (point)   "" &lt;&lt; public_point_x &lt;&lt; endl;

    // ----- reconstruct point from compressed point/value.
    StringSource ss(public_point_x, true, new HexDecoder);   
    ECP::Point point;
    domain.GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());

    cout &lt;&lt; ""Result after decompression X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; endl;
    cout &lt;&lt; ""Result after decompression Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>I hope this is the answer to your question. I was using ECDH, but it should work equally well with ECDSA class.</p>
","861","<crypto++><ecdsa>","1","1","2","2017-08-21 11:58:23","","1","","608639","","2016-04-11 07:42:17","2014-01-15 03:05:12",""
"37344128","How to generate same type of ecdsa keypair in java as generated by openssl?","<p>I am executing the following command to generate ecdsa keypair on my machine:
<code>openssl ecparam -genkey -name secp256k1 -noout -outform DER -out private.key</code> and on executing this next command <code>openssl ec -inform DER -in private.key -noout -text</code>, I get the following output:</p>

<pre><code>read EC key
Private-Key: (256 bit)
priv:
    //private key
pub: 
    04:64:0a:f7:e6:e1:a9:7f:d3:b2:ec:ad:f1:41:96:
    ee:c1:c2:e7:02:4a:54:42:ab:e8:da:9f:88:e1:02:
    46:aa:32:91:38:b5:9e:37:fc:96:d9:36:02:07:de:
    74:59:c4:a8:e0:2b:21:3a:d4:70:7d:5e:92:54:22:
    65:80:0f:df:fd
ASN1 OID: secp256k1
</code></pre>

<p>Now what I'm interested in is the above public key without colons i.e. <code>04640af7e6e1a97fd3b2ecadf14196eec1c2e7024a5442abe8da9f88e10246aa329138b59e37fc96d9360207de7459c4a8e02b213ad4707d5e92542265800fdffd</code>. I need to send to this public key to an api call which validates whether the key is valid or not. The key generated by <code>openssl</code> when sent with the api call is accepted by the server as valid.</p>

<p>But the public ecdsa key generated in java when sent with the api call is rejected. I'm using following code to generate keypair</p>

<pre><code>public KeyPair getECDSAKeyPair() throws NoSuchProviderException, NoSuchAlgorithmException,
        InvalidAlgorithmParameterException {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""ECDSA"", ""SC"");
    ECGenParameterSpec spec = new ECGenParameterSpec(""secp256k1"");
    keyPairGenerator.initialize(spec, new SecureRandom());
    return keyPairGenerator.generateKeyPair();
}

public String getHexPublicKeyString(KeyPair keypair) {
    PublicKey publicKey =  keypair.getPublic();
    return Hex.toHexString(publicKey.getEncoded());
}
</code></pre>

<p>My question is how can I generate same type of ECDSA keypair as generated by the OpenSSL? And what is the difference between the keys generated by OpenSSL and the code generated by java such that key generated by OpenSSL is accepted whereas key generated by java is rejected?</p>
","<p>I was able to generate the required public through following method using SpongyCastle:</p>

<pre><code>public static String getHexEncodedPublicKey(PublicKey publicKey) throws IOException, InvalidKeyException {
    ECPublicKeyParameters ecPublicKeyParameters
            = (ECPublicKeyParameters) ECUtil.generatePublicKeyParameter(publicKey);
    byte[] encoded = ecPublicKeyParameters.getQ().getEncoded(false);
    return Hex.toHexString(encoded);
}
</code></pre>
","860","<java><android><openssl><ecdsa><spongycastle>","0","0","1","2016-05-28 10:18:25","37497786","4","","608639","","2016-05-20 14:54:18","2016-05-20 10:20:03",""
"30126646","Sending signature data in response APDU - Java Card","<p>I would like to sign some data (the MESSAGE byte array) on my Java Card and then return the signature in a response APDU. My code works fine (or at least I think it does and it returns 9000) without the line <em>apdu.sendBytes(BAS, sSignLen)</em>, but when I uncomment it I get an unknown error (<em>0xC000002B (Unknown error.)</em>).</p>

<p>When I try to send other data in a response APDU it works flawlessly.</p>

<pre><code>apdu.setIncomingAndReceive();
Util.arrayCopyNonAtomic(MESSAGE, (short) 0, buffer, (short) 0, (short) MESSAGE.length);
apdu.setOutgoingAndSend((short) 0, (short) MESSAGE.length);
</code></pre>

<p>Here is my code. What am I doing wrong or missing? Thank you!</p>

<pre><code>public class TestApplet extends Applet {

    ...

    private final static byte SIGN = (byte) 0x01;

    ...

    private final static byte[] MESSAGE = new byte[] { 'M', 'e', 's', 's', 'a', 'g', 'e' };

    final static short BAS = 0;

    public void process(APDU apdu) {
        if (this.selectingApplet())
            return;

        byte buffer[] = apdu.getBuffer();

        ...

        switch (buffer[ISO7816.OFFSET_INS]) {
        case SIGN:
            try {
                ECDSAKeyPair = Secp256k1Domain.getKeyPairParameter();
                ECDSAKeyPair.genKeyPair();

                ECDSAPublicKey = (ECPublicKey) ECDSAKeyPair.getPublic();
                ECDSAPrivateKey = (ECPrivateKey) ECDSAKeyPair.getPrivate();

                ECDSASignature = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

                short signLen = 0;

                byte[] signatureArray = new byte[70];

                ECDSASignature.init(ECDSAPrivateKey, Signature.MODE_SIGN);
                signLen = ECDSASignature.sign(MESSAGE, BAS, (short) MESSAGE.length, signatureArray, BAS);

                apdu.setIncomingAndReceive();
                Util.arrayCopyNonAtomic(signatureArray, (short) 0, buffer, (short) 0, (short) signatureArray.length);
                apdu.setOutgoingAndSend((short) 0, (short) signatureArray.length);
            } catch (CryptoException c) {
                short reason = c.getReason();
                ISOException.throwIt((short) ((short) (0x9C00) | reason));
            }

            break;

        ...

        return;
    }
}
</code></pre>
","<p>It's probably that <code>signLen</code> is larger than the Ne value (incorrectly called <code>Le</code> in the JavaCard specifications). You are also abusing the <code>Le</code> value to mean <code>(short) MESSAGE.length</code> by the way. Ne indicates the maximum number of bytes that are expected to be send back.</p>
","839","<digital-signature><smartcard><javacard><apdu><ecdsa>","1","2","1","2015-05-09 21:25:49","30129738","0","2","4697483","","2015-05-09 21:25:49","2015-05-08 14:46:26",""
"40679178","ECDSA private and public keys - how to get SecretKey?","<p>I have used <code>generateKeyPair()</code> method to generate 2 different <code>KeyPair</code> using ECDSA algorithm.</p>

<pre><code>public KeyPair generateKeyPair(){           

    ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(""secp192r1"");
    KeyPairGenerator g = KeyPairGenerator.getInstance(""ECDSA"", ""BC"");
    g.initialize(spec, new SecureRandom());

    return g.generateKeyPair(); 
}
</code></pre>

<p>Then I used <code>PrivateKey</code> and <code>PublicKey</code> from separate <code>KeyPair</code> to get combined <code>SecretKey</code>:</p>

<pre><code>private SecretKey generateSecretKey(PrivateKey privateKey, PublicKey publicKey) {

    KeyAgreement ka = KeyAgreement.getInstance(""ECDH"");
    ka.init(privateKey);
    ka.doPhase(publicKey),
            true);

    return ka.generateSecret(""AES"");
}
</code></pre>

<p>But I get at <code>ka.generateSecret(""AES"")</code>:</p>

<pre><code>Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException
    at java.lang.System.arraycopy(Native Method)
    at org.bouncycastle.jcajce.provider.asymmetric.util.BaseAgreementSpi.engineGenerateSecret(Unknown Source)
    at javax.crypto.KeyAgreement.generateSecret(KeyAgreement.java:648)
</code></pre>

<p>If I use ECDSA, I get:</p>

<pre><code>Exception in thread ""main"" java.security.NoSuchAlgorithmException: Algorithm ECDSA not available
   at javax.crypto.KeyAgreement.getInstance(KeyAgreement.java:184)
</code></pre>

<p>Using DH throws:</p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: DHKeyAgreement requires DHPrivateKey
    at org.bouncycastle.jcajce.provider.asymmetric.dh.KeyAgreementSpi.engineInit(Unknown Source)
    at javax.crypto.KeyAgreement.implInit(KeyAgreement.java:346)
    at javax.crypto.KeyAgreement.chooseProvider(KeyAgreement.java:378)
    at javax.crypto.KeyAgreement.init(KeyAgreement.java:470)
</code></pre>

<p>How to get combined <code>SecretKey</code> from <code>PrivateKey</code> and <code>PublicKey</code> which are generated using ECDSA algorithm?</p>
","<p>A key agreement protocol usually works between two parties each of them having an own ECDS public and private key (hence we have four different keys). Are you sure that is what you want?</p>

<p>Therefore when you agree to a key you need the <strong>private key of party A</strong> and the <strong>public key of party B</strong>. And on the other end of the connection you use the private key of party B and the public key of party A.</p>

<p>The ECDH key agreement algorithm you selected is described in <a href=""https://www.ietf.org/rfc/rfc3278.txt"" rel=""nofollow noreferrer"">RFC3278</a> - for details read it.</p>
","838","<encryption><aes><bouncycastle><elliptic-curve><ecdsa>","1","0","2","2016-11-21 14:49:08","40722936","4","","5962766","","2016-11-21 14:42:41","2016-11-18 14:11:41",""
"40679178","ECDSA private and public keys - how to get SecretKey?","<p>I have used <code>generateKeyPair()</code> method to generate 2 different <code>KeyPair</code> using ECDSA algorithm.</p>

<pre><code>public KeyPair generateKeyPair(){           

    ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(""secp192r1"");
    KeyPairGenerator g = KeyPairGenerator.getInstance(""ECDSA"", ""BC"");
    g.initialize(spec, new SecureRandom());

    return g.generateKeyPair(); 
}
</code></pre>

<p>Then I used <code>PrivateKey</code> and <code>PublicKey</code> from separate <code>KeyPair</code> to get combined <code>SecretKey</code>:</p>

<pre><code>private SecretKey generateSecretKey(PrivateKey privateKey, PublicKey publicKey) {

    KeyAgreement ka = KeyAgreement.getInstance(""ECDH"");
    ka.init(privateKey);
    ka.doPhase(publicKey),
            true);

    return ka.generateSecret(""AES"");
}
</code></pre>

<p>But I get at <code>ka.generateSecret(""AES"")</code>:</p>

<pre><code>Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException
    at java.lang.System.arraycopy(Native Method)
    at org.bouncycastle.jcajce.provider.asymmetric.util.BaseAgreementSpi.engineGenerateSecret(Unknown Source)
    at javax.crypto.KeyAgreement.generateSecret(KeyAgreement.java:648)
</code></pre>

<p>If I use ECDSA, I get:</p>

<pre><code>Exception in thread ""main"" java.security.NoSuchAlgorithmException: Algorithm ECDSA not available
   at javax.crypto.KeyAgreement.getInstance(KeyAgreement.java:184)
</code></pre>

<p>Using DH throws:</p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: DHKeyAgreement requires DHPrivateKey
    at org.bouncycastle.jcajce.provider.asymmetric.dh.KeyAgreementSpi.engineInit(Unknown Source)
    at javax.crypto.KeyAgreement.implInit(KeyAgreement.java:346)
    at javax.crypto.KeyAgreement.chooseProvider(KeyAgreement.java:378)
    at javax.crypto.KeyAgreement.init(KeyAgreement.java:470)
</code></pre>

<p>How to get combined <code>SecretKey</code> from <code>PrivateKey</code> and <code>PublicKey</code> which are generated using ECDSA algorithm?</p>
","<p>It works correctly and returns curve size shared secret after removing ""AES"" argument from <code>return ka.generateSecret();</code>:</p>

<pre><code>private SecretKey generateSecretKey(PrivateKey privateKey, PublicKey publicKey) {

    KeyAgreement ka = KeyAgreement.getInstance(""ECDH"");
    ka.init(privateKey);
    ka.doPhase(publicKey, true);

    return ka.generateSecret();
}
</code></pre>
","838","<encryption><aes><bouncycastle><elliptic-curve><ecdsa>","1","1","2","2016-11-21 14:49:08","40722936","4","","5962766","","2016-11-21 14:42:41","2016-11-18 14:11:41",""
"21531014","BouncyCastle ESDSA implementation","<p>I'm implementing ECDSA in C# using the BouncyCastle library and I'm having a hard time understanding TestECDsa192bitPrime() example.</p>

<pre><code>FpCurve curve = new FpCurve(
  new BigInteger(
    ""6277101735386680763835789423207666416083908700390324961279""), // q
  new BigInteger(
    ""fffffffffffffffffffffffffffffffefffffffffffffffc"", 16), // a
  new BigInteger(
    ""64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1"", 16)); // b

ECDomainParameters parameters = new ECDomainParameters(curve,
  curve.DecodePoint(Hex.Decode(
    ""03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012"")), // G
    new BigInteger(
      ""6277101735386680763835789423176059013767194773182842284081"")); // n

ECPrivateKeyParameters priKey = new ECPrivateKeyParameters(
  ""ECDSA"",
  new BigInteger(
    ""651056770906015076056810763456358567190100156695615665659""), // d
  parameters);

ParametersWithRandom param = new ParametersWithRandom(priKey, k);
ECDsaSigner ecdsa = new ECDsaSigner();
ecdsa.Init(true, param);
curve.DecodePoint(Hex.Decode(
  ""0262b12d60690cdcf330babab6e69763b471f994dd702d16a5"")), // Q
  parameters);
</code></pre>

<p>In the above example how BouncyCastle directly calculated G( Basepoint) and Q( public key).</p>
","<p>This is a test to ensure signature process is correct. The values of G and Q were taken from <a href=""http://webstore.ansi.org/RecordDetail.aspx?sku=ANSI+X9.62%3A2005"" rel=""nofollow"">X9.62 standard</a> from 1998, section J.3.1, page 152, ECDSA over the field Fp, an example with 192 bit prime. </p>

<p>This paper is not public, but the same values can be found on page 26 of <a href=""http://www.nsa.gov/ia/_files/nist-routines.pdf"" rel=""nofollow"">Mathematical routines for the NIST prime elliptic curves</a> paper.</p>
","834","<c#><bouncycastle><elliptic-curve><ecdsa>","1","2","1","2014-02-04 19:44:43","21561907","0","","642653","","2014-02-04 19:36:26","2014-02-03 15:20:17",""
"44010018","Signing PDF from Pkcs11Interop for CKM_ECDSA_SHA256 using SoftHSM 2.2.0 (ECDSA with SHA256) C# .net","<p>I am trying to sign Pdf documents using <strong>Pkcs11Interop</strong> .net library.
I need to use <strong>ECDSA encryption</strong> algorithm with <strong>SHA256 hash algorithm</strong>.
And I am using <strong>SoftHSM 2.2.0</strong> for storing private keys.</p>

<p>I found an CKM enum, <strong>CKM_ECDSA_SHA256</strong>, which I am passing while creating an object of class mechanism for calling the Sign method of Session.</p>

<p>I am getting the response from the ""Signdata"" method, however, on opening the Pdf files generated after signing give an error ""Signature Invalid"".
Here is the code snippet for Signdata method call. 
I don't get any error or exception in the code, however, the pdf as I have mentioned are showing signature invalid.</p>

<pre><code>private Pkcs11 _pkcs11;
private Slot _slot;
private Session _session;

try
{
   _pkcs11 = new Pkcs11(hsmCryptoApi, true);
}
catch (Pkcs11Exception ex)
{
   if (ex.RV == CKR.CKR_CANT_LOCK)
      _pkcs11 = new Pkcs11(hsmCryptoApi, false);
   else
       throw ex;
}

_slot = FindSlot(_pkcs11, _certificateInformation.TokenLabel);
_session = _slot.OpenSession(true);

using (Mechanism mechanism = new Mechanism(CKM.CKM_ECDSA_SHA256))
{
  _session.Login(CKU.CKU_USER, passowrd);
  byte[] signedHash = _session.Sign(mechanism, GetPrivateKeyHandle(), message);
  _session.Logout();
  return signedHash;
}

private ObjectHandle GetPrivateKeyHandle()
{
  string keyLabel = _certificateInformation.KeyLabel;
  List&lt;ObjectAttribute&gt; searchTemplate = new List&lt;ObjectAttribute&gt;();
  searchTemplate.Add(new ObjectAttribute(CKA.CKA_CLASS, CKO.CKO_PRIVATE_KEY));
  searchTemplate.Add(new ObjectAttribute(CKA.CKA_LABEL, keyLabel));
  List&lt;ObjectHandle&gt; foundObjects = _session.FindAllObjects(searchTemplate);
  return foundObjects[0]; 
}
</code></pre>

<ul>
<li>Please tell me if SoftHSM 2.2.0 supports ECDSA_P256 with SHA256 or not ?? </li>
<li>If not, then is there any way to enable the support ?? </li>
<li>If it does support, please help me how to fix this ??</li>
<li>It looks like it want me to pass ECDSA_Param, does anybody have any code snippet for passing the ECDSA_Param</li>
</ul>
","<p>I think you need to construct <code>ECDSA-Sig-Value</code> structure and fill it with the data from your <code>signedHash</code> variable.</p>

<p><a href=""https://github.com/Pkcs11Interop/PKCS11-SPECS/tree/master/v2.20"" rel=""nofollow noreferrer"">PKCS#11 v2.20</a> chapter 12.3.1:</p>

<blockquote>
  <p>For the purposes of these mechanisms, an ECDSA signature is an octet
  string of even length which is at most two times nLen octets, where
  nLen is the length in octets of the base point order n. The signature
  octets correspond to the concatenation of the ECDSA values r and s,
  both represented as an octet string of equal length of at most nLen
  with the most significant byte first. If r and s have different octet
  length, the shorter of both must be padded with leading zero octets
  such that both have the same octet length. Loosely spoken, the first
  half of the signature is r and the second half is s. For signatures
  created by a token, the resulting signature is always of length 2nLen.
  For signatures passed to a token for verification, the signature may
  have a shorter length but must be composed as specified before.</p>
</blockquote>

<p><a href=""https://www.ietf.org/rfc/rfc5753.txt"" rel=""nofollow noreferrer"">RFC5753</a> chapter 7.2:</p>

<blockquote>
  <p>When using ECDSA with SignedData, ECDSA signatures are encoded using
  the type:</p>

<pre><code>ECDSA-Sig-Value ::= SEQUENCE {
    r INTEGER,
    s INTEGER }
</code></pre>
  
  <p>ECDSA-Sig-Value is specified in [PKI-ALG].  Within CMS,
  ECDSA-Sig-Value is DER-encoded and placed within a signature field of
  SignedData.</p>
</blockquote>

<p>Following method uses <a href=""http://bouncycastle.org/csharp/index.html"" rel=""nofollow noreferrer"">BouncyCastle</a> library to constructs DER-encoded <code>ECDSA-Sig-Value</code> structure:</p>

<pre><code>public static byte[] ConstructEcdsaSigValue(byte[] rs)
{
    if (rs == null)
        throw new ArgumentNullException(nameof(rs));

    if (rs.Length &lt; 2 || rs.Length % 2 != 0)
        throw new ArgumentException(""Invalid length"", nameof(rs));

    int halfLen = rs.Length / 2;

    byte[] half1 = new byte[halfLen];
    Array.Copy(rs, 0, half1, 0, halfLen);
    var r = new Org.BouncyCastle.Math.BigInteger(1, half1);

    byte[] half2 = new byte[halfLen];
    Array.Copy(rs, halfLen, half2, 0, halfLen);
    var s = new Org.BouncyCastle.Math.BigInteger(1, half2);

    var derSequence = new Org.BouncyCastle.Asn1.DerSequence(
        new Org.BouncyCastle.Asn1.DerInteger(r),
        new Org.BouncyCastle.Asn1.DerInteger(s));

    return derSequence.GetDerEncoded();
}
</code></pre>
","825","<c#><pkcs#11><ecdsa><softhsm><pkcs11interop>","3","2","2","2017-06-26 21:00:43","44018124","1","2","3325704","","2017-06-26 21:00:43","2017-05-16 19:28:42",""
"44010018","Signing PDF from Pkcs11Interop for CKM_ECDSA_SHA256 using SoftHSM 2.2.0 (ECDSA with SHA256) C# .net","<p>I am trying to sign Pdf documents using <strong>Pkcs11Interop</strong> .net library.
I need to use <strong>ECDSA encryption</strong> algorithm with <strong>SHA256 hash algorithm</strong>.
And I am using <strong>SoftHSM 2.2.0</strong> for storing private keys.</p>

<p>I found an CKM enum, <strong>CKM_ECDSA_SHA256</strong>, which I am passing while creating an object of class mechanism for calling the Sign method of Session.</p>

<p>I am getting the response from the ""Signdata"" method, however, on opening the Pdf files generated after signing give an error ""Signature Invalid"".
Here is the code snippet for Signdata method call. 
I don't get any error or exception in the code, however, the pdf as I have mentioned are showing signature invalid.</p>

<pre><code>private Pkcs11 _pkcs11;
private Slot _slot;
private Session _session;

try
{
   _pkcs11 = new Pkcs11(hsmCryptoApi, true);
}
catch (Pkcs11Exception ex)
{
   if (ex.RV == CKR.CKR_CANT_LOCK)
      _pkcs11 = new Pkcs11(hsmCryptoApi, false);
   else
       throw ex;
}

_slot = FindSlot(_pkcs11, _certificateInformation.TokenLabel);
_session = _slot.OpenSession(true);

using (Mechanism mechanism = new Mechanism(CKM.CKM_ECDSA_SHA256))
{
  _session.Login(CKU.CKU_USER, passowrd);
  byte[] signedHash = _session.Sign(mechanism, GetPrivateKeyHandle(), message);
  _session.Logout();
  return signedHash;
}

private ObjectHandle GetPrivateKeyHandle()
{
  string keyLabel = _certificateInformation.KeyLabel;
  List&lt;ObjectAttribute&gt; searchTemplate = new List&lt;ObjectAttribute&gt;();
  searchTemplate.Add(new ObjectAttribute(CKA.CKA_CLASS, CKO.CKO_PRIVATE_KEY));
  searchTemplate.Add(new ObjectAttribute(CKA.CKA_LABEL, keyLabel));
  List&lt;ObjectHandle&gt; foundObjects = _session.FindAllObjects(searchTemplate);
  return foundObjects[0]; 
}
</code></pre>

<ul>
<li>Please tell me if SoftHSM 2.2.0 supports ECDSA_P256 with SHA256 or not ?? </li>
<li>If not, then is there any way to enable the support ?? </li>
<li>If it does support, please help me how to fix this ??</li>
<li>It looks like it want me to pass ECDSA_Param, does anybody have any code snippet for passing the ECDSA_Param</li>
</ul>
","<p>Just thought of sharing the solution which worked for me. In the above mentioned code snippet I added the below things:</p>

<pre><code>   using (Mechanism mechanism = new Mechanism(CKM.CKM_ECDSA))
        {
          _session.Login(CKU.CKU_USER, passowrd);
          byte[] signedHash = _session.Sign(mechanism, GetPrivateKeyHandle(), GetMessageDigest(message));
          _session.Logout();
          return ConstructEcdsaSigValue(signedHash);
        }

    private byte[] GetMessageDigest(byte[] message)
    {
       using (Mechanism mechanism = new Mechanism(CKM_SHA256))
       {
         return _session.Digest(mechanism, message);
        }
    }

    public static byte[] ConstructEcdsaSigValue(byte[] rs)
    {
        if (rs == null)
            throw new ArgumentNullException(nameof(rs));

        if (rs.Length &lt; 2 || rs.Length % 2 != 0)
            throw new ArgumentException(""Invalid length"", nameof(rs));

        int halfLen = rs.Length / 2;

        byte[] half1 = new byte[halfLen];
        Array.Copy(rs, 0, half1, 0, halfLen);
        var r = new Org.BouncyCastle.Math.BigInteger(1, half1);

        byte[] half2 = new byte[halfLen];
        Array.Copy(rs, halfLen, half2, 0, halfLen);
        var s = new Org.BouncyCastle.Math.BigInteger(1, half2);

        var derSequence = new Org.BouncyCastle.Asn1.DerSequence(
            new Org.BouncyCastle.Asn1.DerInteger(r),
            new Org.BouncyCastle.Asn1.DerInteger(s));

        return derSequence.GetDerEncoded();
    }
</code></pre>
","825","<c#><pkcs#11><ecdsa><softhsm><pkcs11interop>","3","0","2","2017-06-26 21:00:43","44018124","1","2","3325704","","2017-06-26 21:00:43","2017-05-16 19:28:42",""
"40331595","ECC key pair - how to print private key?","<p>I implement ""Key Pair Generation"" using secp192r1 curve. But private key did not display in string form like public key.</p>

<p><a href=""https://i.stack.imgur.com/gSxol.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gSxol.jpg"" alt=""enter image description here""></a></p>

<p>Here is my code:</p>

<pre><code>package lam.bk;
import java.security.*;
import java.security.spec.*;

public class ECCKeyGeneration {
    public static void main(String[] args) throws Exception {
        KeyPairGenerator kpg;
        kpg = KeyPairGenerator.getInstance(""EC"",""SunEC"");
        ECGenParameterSpec ecsp;
        ecsp = new ECGenParameterSpec(""secp192r1"");
        kpg.initialize(ecsp);

        KeyPair kp = kpg.genKeyPair();
        PrivateKey privKey = kp.getPrivate();
        PublicKey pubKey = kp.getPublic();

        System.out.println(pubKey.toString());
        System.out.println(privKey.toString()); 
    }
}
</code></pre>
","<p>You will need to convert the Private Key to PEM format before you can get its openssl string representation. In java you can do this in a programmatic manner by using BouncyCastle library's <a href=""http://www.programcreek.com/java-api-examples/index.php?api=org.bouncycastle.openssl.PEMWriter"" rel=""nofollow noreferrer"">PEMWriter</a></p>
","805","<java><private-key><elliptic-curve><ecdsa><key-pair>","0","0","2","2018-07-08 08:21:47","","1","","472495","","2018-07-08 08:21:47","2016-10-30 17:18:07",""
"40331595","ECC key pair - how to print private key?","<p>I implement ""Key Pair Generation"" using secp192r1 curve. But private key did not display in string form like public key.</p>

<p><a href=""https://i.stack.imgur.com/gSxol.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gSxol.jpg"" alt=""enter image description here""></a></p>

<p>Here is my code:</p>

<pre><code>package lam.bk;
import java.security.*;
import java.security.spec.*;

public class ECCKeyGeneration {
    public static void main(String[] args) throws Exception {
        KeyPairGenerator kpg;
        kpg = KeyPairGenerator.getInstance(""EC"",""SunEC"");
        ECGenParameterSpec ecsp;
        ecsp = new ECGenParameterSpec(""secp192r1"");
        kpg.initialize(ecsp);

        KeyPair kp = kpg.genKeyPair();
        PrivateKey privKey = kp.getPrivate();
        PublicKey pubKey = kp.getPublic();

        System.out.println(pubKey.toString());
        System.out.println(privKey.toString()); 
    }
}
</code></pre>
","<p>The code below will output 24 bytes private key for secp192r1 curve:</p>

<pre><code>private String getPrivateKeyAsHex(PrivateKey privateKey) {

    ECPrivateKey ecPrivateKey = (ECPrivateKey) privateKey;
    byte[] privateKeyBytes = new byte[24];
    writeToStream(privateKeyBytes, 0, ecPrivateKey.getS(), 24);

    return Hex.toHexString(privateKeyBytes);
}

private void writeToStream(byte[] stream, int start, BigInteger value, int size) {
    byte[] data = value.toByteArray();
    int length = Math.min(size, data.length);
    int writeStart = start + size - length;
    int readStart = data.length - length;
    System.arraycopy(data, readStart, stream, writeStart, length);
}
</code></pre>
","805","<java><private-key><elliptic-curve><ecdsa><key-pair>","0","0","2","2018-07-08 08:21:47","","1","","472495","","2018-07-08 08:21:47","2016-10-30 17:18:07",""
"20992760","Understanding BCryptSignHash output signature","<p>I have signed a hash value in windows using <em>BCryptSignHash</em> with ECDSA algorithm. The output signature buffer is of length 64 bytes. I also generated the public and private key blobs using <em>BCryptGenerateKeyPair</em> function (BCRYPT_ECDSA_P256_ALGORITHM algorithm) with which i signed the hash.</p>

<p>I have to verify this signature with this key pair in linux. I am able to decipher the public-private key pair that got generated, using the link ""<a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx</a>"" and able to use the same in linux.</p>

<p>The 64-byte signature generated should ideally be signature pair (r,s) (<a href=""http://en.wikipedia.org/wiki/Elliptic_Curve_DSA"" rel=""nofollow"">http://en.wikipedia.org/wiki/Elliptic_Curve_DSA</a>).</p>

<p>Is there a way to understand the 64-bytes signature generated so that i can map the signature blob contents to (r,s) pair in linux and verify it?</p>

<p>Or is there a simpler way to verify the generated signature in linux?</p>

<p>Thanks,
F</p>
","<blockquote>
  <p>Is there a way to understand the 64-bytes signature generated so that I can map the signature blob contents to (r,s) pair in linux and verify it?</p>
</blockquote>

<p>The <code>r</code> and <code>s</code> are in P1363 format, which is simply a concatenation of <code>r</code> and <code>s</code> in a 2's compliment format. That is, the signature is simply <code>r || s</code>.</p>

<p>You need to know the hash to use this format. For example, SHA1 will create a <code>r</code> of 20 bytes and an <code>s</code> of 20 bytes. If <code>r</code> or <code>s</code> is ""too short"", then it is padded on the left with 0's.</p>

<p>Java and OpenPGP are different than P1363. Java and OpenPGP use an ASN.1 encoding:</p>

<pre><code>SEQUENCE ::= {
  r INTEGER,
  s INTEGER
}
</code></pre>

<p>Depending what library you use on Linux, you may have to convert between the formats. <a href=""http://www.codeproject.com/Articles/25590/Cryptographic-Interoperability-Digital-Signatures"" rel=""nofollow"">Cryptographic Interoperability: Digital Signatures</a> gives examples of signing and verifying using a few different libraries.</p>

<hr>

<blockquote>
  <p>Or is there a simpler way to verify the generated signature in linux?</p>
</blockquote>

<p>Try <a href=""http://www.cryptopp.com"" rel=""nofollow"">Crypto++</a>. I believe Microsoft and Crypto++ uses the same signature format, so you won't need to convert. See <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow"">Elliptic Curve Digital Signature Algorithm</a> for details.</p>
","803","<linux><cryptoapi><ecdsa><cng>","1","2","1","2014-06-10 12:18:33","21048027","0","","","","","2014-01-08 10:20:42",""
"48392334","How to sign a message with an ECDSA string privateKey","<p>I'm trying to sign a message with an ECDSA <code>privateKey</code> but with a type string.
The problem is in order to sign the message I need to use the ""Sign"" method from the <code>ecdsa</code> package.</p>

<pre><code>func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error)
</code></pre>

<p>This method can only take a <code>PrivateKey</code> type.
How can I convert my string private key to this type? Or is another method available ?</p>
","<p>You can parse DER-encoded elliptic curve private keys using the standard library's <a href=""https://golang.org/pkg/crypto/x509/#ParseECPrivateKey"" rel=""nofollow noreferrer"">x509.ParseECPrivateKey</a>.</p>

<pre><code>derKey := []byte(keyString)
privKey, err := x509.ParseECPrivateKey(derKey)
if err != nil {
  panic(err)
}
signedMsg, err := privKey.Sign(randReader, msg, otps)
</code></pre>

<p>If your key is in PEM format, you must first decode it using <a href=""https://golang.org/pkg/encoding/pem/#Decode"" rel=""nofollow noreferrer"">pem.Decode</a>:</p>

<pre><code>var block *pem.Block
if block, _ = pem.Decode([]byte(keyString)); block == nil {
    panic(""expected pem block"")
}
privKey, err := x509.ParseECPrivateKey(block.Bytes)
// etc... the rest is the same
</code></pre>
","787","<go><ecdsa>","1","1","1","2018-01-23 10:33:37","","0","","4966953","","2018-01-23 10:19:14","2018-01-23 00:21:35",""
"38934615","Not sure how to generate an ECDSA signature, given a private key and a message","<p>I'm following <a href=""https://developer.apple.com/library/ios/documentation/DataManagement/Conceptual/CloutKitWebServicesReference/SettingUpWebServices/SettingUpWebServices.html#//apple_ref/doc/uid/TP40015240-CH24-SW1"" rel=""noreferrer"">Apple's guide</a> towards composing a CloudKit Web Services request. The bit I'm having trouble with is Step 2, under ""Authenticate Web Service Requests"":</p>

<blockquote>
  <ol start=""2"">
  <li>Compute the ECDSA signature of this message with your private key.</li>
  </ol>
</blockquote>

<p>Before getting to this point, I generated my certificate, a .pem file, which when opening it in a text editor shows me my private key, so I have that in string format too.</p>

<p>I've also followed the steps for generating what it refers to as a message, which I now have as a string.</p>

<p>So given that I have a private key, (or the .pem file if required), and a message as a string, it should in theory be fairly simple for me to get a ECDSA signature of the message, computed with my private key. But here's where I'm struggling. <a href=""https://github.com/DavidEGrayson/ruby_ecdsa"" rel=""noreferrer"">Libraries that I've found online</a> seem to take a far more complicated approach, with different moving parts, no reference to a .pem file and talk of generating new public/private keys.</p>

<p>Any help with this step would be greatly appreciated.</p>
","<p>It appears that the documentation and the actual API for Rubys OpenSSL EC support are both currently rather lacking. In particular, in Ruby &lt;= 2.3.1 the <code>OpenSSL::PKey::EC</code> doesnt follow the same API as RSA and DSA keys for signing and verifying. What you would want to do, but currently cant with EC keys, is this (all the code here assumes you have called <code>require 'openssl'</code> somewhere):</p>

<pre><code># Get the key, here I'm reading the file
priv_key = OpenSSL::PKey.read(File.read('eckey.pem')) 

# This should be the appropriately formatted string
data = ""some data to sign""

# The hash algorithm, I assume SHA256 is being used
digest = OpenSSL::Digest::SHA256.new

# This doesn't work in 2.3.1, but does in 2.4.0-preview1
signature = priv_key.sign(digest, data)
</code></pre>

<p>As I note in the comments, this does work in Ruby 2.4.0-preview1, but thats likely not much use to you.</p>

<p>To get it working with current Ruby, you need to do something like this:</p>

<pre><code># As before:
priv_key = OpenSSL::PKey.read(File.read('eckey.pem'))
data = ""some data to sign""

signature = priv_key.dsa_sign_asn1(OpenSSL::Digest::SHA256.digest(data))
</code></pre>

<p>Both these techniques give you a binary string. I <em>think</em> you will need to base64 encode it before adding it as your request header.</p>

<p>To extract the public key to check the signature verifies is also a bit tricky (although you could just use the <code>openssl</code> command line and read in the file). The <code>public_key</code> methods returns an <code>OpenSSL::PKey::EC::Point</code> object rather than an actual key, so we need to recreate one from the private key. The <code>verify</code> method <em>does</em> work on Ruby 2.3.1:</p>

<pre><code>pub = OpenSSL::PKey::EC.new(priv_key.group)
pub.public_key = priv_key.public_key

data = ""some data to sign""
digest = OpenSSL::Digest::SHA256.new

puts pub.verify(digest, sig, data)
</code></pre>

<p>The Apple page doesnt appear to specify the hash algorithm to use, but from what Ive seen it looks like SHA-256 is right. (Also I could have got this completely wrong and Apple are using a completely different format. Id be keen to know whether or not this code works you you).</p>
","778","<ruby-on-rails><ruby><cloudkit><ecdsa><cloudkit-web-services>","5","4","1","2016-08-13 19:21:42","38936194","0","1","","","","2016-08-13 16:12:04",""
"31427253","ECDSA prime256v1 cross-platform signature verification fail","<p>I need to verify a signature with Java/Android and an ATEC108A Chip which is created in a .Net environment. (Using SunEC and AndroidOpenSSL)</p>

<p>The signature is created in .Net using BCrypt, the keys are also created using BCrypt and stored on the Microsoft key store. The signature and public key can sent to the AT chip and it verifies, however it does not work on Android.</p>

<p>Key / Signature Process:</p>

<ol>
<li><p>The public key is exported from BCrypt in the x.509 key format which includes the identifiers for SHA256-ECDSA and the curve prime256v1 resulting in:</p>

<pre>3059301306072A8648CE3D020106082A
8648CE3D03010703420004368711132B
BDB4C6D03F7DF4F4688F5F4F21A3B30B
EB1016648555A25B27C915CAB5C26B98
0FF792A0090BF1E131C175D9C66C8D79
3476489770869E09273816</pre></li>
<li><p>The signature from BCrypt is in the 64-byte format, but android requires the sequence and length identifiers resulting in the signature as follows:</p>

<pre>304502201
BD91B39A7447724223A4B3E9070A6FD5
33360F96B072998058AA73E572F48D80
22100
ED0BDC731080CFC82C8B8FB37D74CC18
3820343C2756671F0E1D813E469DD3D7</pre></li>
<li><p>The message that has been used to sign and verify is ""Hello World"" which hashed is:</p>

<pre>A591A6D40BF420404A011733CFB7B190
D62C65BF0BCDA32B57B277D9AD9F146E</pre></li>
</ol>

<p>Android Process:</p>

<ol>
<li><p>Create the X509 key spec and public key from the above key byte array:</p>

<pre>X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);
KeyFactory kf = KeyFactory.getInstance(""EC"", ""AndroidOpenSSL"");
pubKey = kf.generatePublic(keySpec);</pre></li>
<li><p>Create signature using the AndroidOpenSSL provider:</p>

<pre>Signature signature;
signature = Signature.getInstance(""SHA256withECDSA"", ""AndroidOpenSSL"");
signature.initVerify(pubKey);</pre></li>
<li><p>Load the above hash array:</p>

<pre>signature.update(hash);</pre></li>
<li><p>Verify the above signature:</p>

<pre>signature.verify(sign);</pre></li>
</ol>

<p>The signature and key above checks out on the AT chip (Also verified on ECDSA Sample which runs JavaScript-OpenSSL) but does not verify with AndroidOpenSSL.
Am I missing something simple or where can the problem be? </p>

<p>The public key structure checks out on ASN.1 decoder and load successfully within the code (extracted and checked from the public key), the signature is in the expected format for Java and the hash values are the same on both sides.</p>
","","777","<android><openssl><bcrypt><ecdsa>","5","","0","2015-07-15 09:59:12","","0","","","","","2015-07-15 09:59:12",""
"18078873","How should I use crypto:sign/4 properly?","<p>I tried to use crypto:sign/4 to sign a message but failed. Could anyone show me how to sign a message using ECDSA in Erlang? Thanks. (I'm using Erlang version R16B01.)</p>

<p>The module code:</p>

<pre><code>-module(message).

-compile(export_all).

go() -&gt;
    {_PubKey, PriKey} = crypto:generate_key(ecdh, secp256k1),
    SigBin = sign_message(PriKey, ""Hello""),
    SigBin.

sign_message(PriKey, Msg) -&gt;
    Algorithm = ecdsa,
    DigestType = sha256,
    MsgBin = list_to_binary(Msg),
    SigBin = crypto:sign(Algorithm, DigestType, MsgBin, PriKey),
    SigBin.
</code></pre>

<p>But it failed on a test run:</p>

<pre><code>1&gt; message:go().
** exception error: no function clause matching crypto:sign(ecdsa,sha256,
                                                        {digest,

        &lt;&lt;24,95,141,179,34,113,254,37,245,97,166,252,147,
        139,46,38,67,6,236,48,78,218,81,128,...&gt;&gt;},
        &lt;&lt;189,38,200,204,95,248,54,69,42,65,216,165,242,228,100,
        54,158,5,61,174,58,198,191,161,9,...&gt;&gt;) (crypto.erl, line 462)
</code></pre>

<hr>

<p>Thanks to Paul, this error can be fixed by making the following change.</p>

<p>change:</p>

<pre><code>SigBin = crypto:sign(Algorithm, DigestType, MsgBin, PriKey),
</code></pre>

<p>to:</p>

<pre><code>SigBin = crypto:sign(Algorithm, DigestType, MsgBin, [PriKey, secp256k1]),
</code></pre>
","<p>The <a href=""http://erlang.org/doc/man/crypto.html#sign-4""><code>crypto:sign/4</code></a> and <a href=""http://erlang.org/doc/man/crypto.html#generate_key-2""><code>crypto:generate_key/2</code></a> functions are <strong>quite confusing</strong> for ECDSA as ECDSA requires domain parameters, unlike the other two supported algorithms.</p>

<p>The error message simply tells you that the parameters you are passing do not match any clause of the <a href=""http://erlang.org/doc/man/crypto.html#sign-4""><code>crypto:sign/4</code></a> function. You are probably passing an argument of the wrong type.</p>

<p>You can look at the source code of the called function to find out why no clause match your parameters. This is typically what you would do for your own functions. Yet here, <a href=""http://erlang.org/doc/man/crypto.html#sign-4""><code>crypto:sign/4</code></a> is a system function which is properly documented.</p>

<p>The documentation reads as follows:</p>

<blockquote>
  <p><strong><code>sign(Algorithm, DigestType, Msg, Key) -&gt; binary()</code></strong></p>
  
  <p>Types:</p>
  
  <p><strong><code>Algorithm = rsa | dss | ecdsa</code></strong></p>
  
  <p><strong><code>Msg = binary() | {digest,binary()}</code></strong></p>
  
  <p>The msg is either the binary ""cleartext"" data to be signed or it is the hashed value of ""cleartext"" i.e. the digest (plaintext).</p>
  
  <p><strong><code>DigestType = digest_type()</code></strong></p>
  
  <p><strong><code>Key = rsa_private() | dss_private() | [ecdh_private(),ecdh_params()]</code></strong></p>
</blockquote>

<p>Your first three arguments are obviously ok. The issue is with the key. Indeed, your code goes like this:</p>

<pre><code>{_PubKey, PriKey} = crypto:generate_key(ecdh, secp256k1)
</code></pre>

<p>Looking at the documentation of <a href=""http://erlang.org/doc/man/crypto.html#generate_key-2""><code>crypto:generate_key/2</code></a>, you'll find out that in the case of ECDH, <code>PrivKey</code> is of type <code>ecdh_private()</code> and not <code>[ecdh_private(),ecdh_params()]</code> as <a href=""http://erlang.org/doc/man/crypto.html#sign-4""><code>crypto:sign/4</code></a> expects.</p>

<p>A fix would be to pass <code>[PrivKey, secp256k1]</code> to your <code>sign_message</code> function, as the sign function requires the identification of the curve domain parameters through the sign key parameter.</p>
","766","<encryption><erlang><sign><ecdsa>","1","6","1","2013-08-06 12:40:44","18080075","0","1","1028974","","2013-08-06 12:40:44","2013-08-06 11:24:52",""
"42608548","Create PrivateKey from base64 string ECDSA private key","<p>I have ECDSA private key string in base64 (i check this string with regexp from this <a href=""https://stackoverflow.com/a/8571649/7661555"">https://stackoverflow.com/a/8571649/7661555</a> answer).</p>

<p>And i try to generate PrivateKey instance from this string.
I include SpongyCastle in my project, and try to generate it with this code:</p>

<pre><code>        PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(encKey);

        KeyFactory keyFactory = KeyFactory.getInstance(""ECDSA"", ""SC"");

        PrivateKey priv = keyFactory.generatePrivate(privKeySpec);
</code></pre>

<p>But when i run this code, i get next Exception:</p>

<p>W/System.err: java.security.spec.InvalidKeySpecException: encoded key spec not recognised</p>

<p>Can you tell me what i do wrong ?</p>

<p>P.S.
After generating PrivateKey, i want sign another string with it.
For this purpose i find next code:</p>

<pre><code>        Signature sig = Signature.getInstance(""SHA256withECDSA"");
        sig.initSign(priv);
        sig.update(token.getBytes());
</code></pre>

<p>Is this right way? Or something in this can lead to another exception ?</p>
","<p>The regex which you have mentioned in your question, just checks whether a string is base64 encoded or not.</p>

<p>Can you share, how you are generating the base64 string from the EC private key?</p>

<pre><code>    private String getBase64Value(PrivateKey privateKey) {
    return Base64.encodeToString(privateKey.getEncoded(), Base64.NO_WRAP);
}

private PrivateKey reconstructPrivateKey(String base64Value) throws InvalidKeySpecException, NoSuchAlgorithmException {
    KeyFactory kf = KeyFactory.getInstance(""EC"");
    byte[] bytes = Base64.decode(base64Value, Base64.NO_WRAP);
    return kf.generatePrivate(new PKCS8EncodedKeySpec(bytes));
}
</code></pre>
","764","<android><ecdsa><spongycastle>","0","0","1","2017-04-11 03:18:51","","0","","-1","","2017-05-23 11:54:06","2017-03-05 12:50:53",""
"46519778","How to generate a Bitcoin address in Python 3.5/6?","<p>I've tried pybitcoin already, but I get a ModuleError for ""services"". I've tried multiple scripts from Google but they are all for Python2.</p>

<p>I tried to use this to get started</p>

<pre><code>import ecdsa
return ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1).to_string()
</code></pre>

<p>but it returns bytes not a string. I assume it's a version issue because it's GitHub only mentions 3.1 and 3.2.</p>

<p><strong>I want the addresses to be completely random.</strong> </p>
","","757","<python><bitcoin><ecdsa>","2","","0","2018-03-01 06:47:17","","1","","","","","2017-10-02 05:05:40",""
"36260869","Creating openssh public keys from private keys with pycrypto","<p>How do I create DSA openssh-formatted public key with a given private key?</p>

<p>The openssh public key format looks like this:</p>

<pre><code>ssh-dss AAAAB3NzaC1kc3MAAACBAKFY7ysDwhMf5j3IOmPg1ztzAodBzQHua5m7/IM8nEYdCDeLzI+Jx24pRDUKseRVC5DUIHU7sRtRpCMDmGBcJwxHF9G4ofrP5hlUaDTHeKHrOKgGdRzPw5xtExImwYfCn97HMc6OpQrsAysL7KCxQHgD41t7IEaSQRjK8zK2IBqJAAAAFQD6Wjepos/lp0Vw8mrRLMIEhocZpQAAAIBXJ+E3J+dMOIHlYpEYm6BmI92/YhAT3+4rfDORQkUtcgmyQiAJ4CWvOBrcwK7zpLZ/pNNujv3cc4whigAqnZm9f+x8LDT7iIZ3FGdvHFDxYiTZVJTv2g1kaS/AABG5KfsVVkV2TP+XO12EjoEjoNvgjA1Z0fSeeKeP8YQNgMNjFgAAAIAobgPabsJCnFuazy+WOoo9SgfqeafXbrsxWPbKV4mjbUKXbOASV4F35Vuk1DAFRRP2/xYxv2QsiW4F2wsGSlsfnvb8bbmhzFHU81BrPRd1R60JUCDnvwVYJlJUqIvgfYbi3AXuxaqK3cLKWIFZGrYGyd2x8DRNpE7SLDMfWY7Jgw== root@Server
</code></pre>

<p>Using pycrypto, same thing with RSA works just fine:</p>

<pre><code>key.publickey().exportKey('OpenSSH')
</code></pre>

<p>Unfortunately, There is no exportKey() func for a DSA object.</p>

<p>I also have a similar issue with an ecdsa key. Bottom line, I need a python equivalent (for both DSA and ecdsa) to:</p>

<pre><code>ssh-keygen -y -f /path/to/private_key &gt; /path/to/public_key
</code></pre>
","<p>The expression:</p>

<pre><code> key.publickey().exportKey('OpenSSH')
</code></pre>

<p>to get the DSA public key in the OpenSSH format is supported by <a href=""https://www.pycryptodome.org"" rel=""nofollow"">PyCryptodome</a>, a PyCrypto fork.</p>
","745","<python><openssh><pycrypto><ecdsa><dsa>","1","0","1","2016-03-30 10:37:53","36306354","0","","6123837","","2016-03-28 14:00:05","2016-03-28 10:56:00",""
"43984535","ECDsa Signing in .Net Core on Linux","<p>I'm trying to create a C# implementation to send Pushes to Apple via their HTTP/2 APNS Endpoint with .Net core in Docker. Part of this requires sending an encrypted JWT Authorization Token along with the payload. With .Net core, I can sign the token when running on Windows, but when running in the Linux Docker image, it tips over loading the Key. </p>

<p>When running in the .net Core Docker Image, I get a platformnotsupported Exception on loading the key.</p>

<pre><code>    public static string SignES256(string privateKey, string header, string payload)
    {

        // This is the failing Call
        CngKey key = CngKey.Import(Convert.FromBase64String(privateKey), CngKeyBlobFormat.Pkcs8PrivateBlob);

        using (ECDsaCng dsa = new ECDsaCng(key))
        {
            var unsignedJwtData =
                System.Convert.ToBase64String(Encoding.UTF8.GetBytes(header)) + ""."" + System.Convert.ToBase64String(Encoding.UTF8.GetBytes(payload));
            var unsignedJwtDataBytes = Encoding.UTF8.GetBytes(unsignedJwtData);

            var signature =
                dsa.SignData(unsignedJwtDataBytes, 0, unsignedJwtDataBytes.Length, HashAlgorithmName.SHA256 );
            return unsignedJwtData + ""."" + System.Convert.ToBase64String(signature);
        }
    }
</code></pre>

<p>How can I do this from .Net Core on Linux?</p>

<p>Thanks.</p>
","<p>ECDsaCng is an ECDSA implementation using Windows CNG.  It's specific to Windows, so not supported on Linux.</p>

<p>The cross-platform way to do this would be</p>

<pre><code>using (ECDsa ecdsa = ECDsa.Create())
{
    ecdsa.ImportParameters(Pkcs8ToParameters(privateKey));

    // the stuff in your current using 
}
</code></pre>

<p>Of course, PKCS#8 to ECParameters isn't the easiest thing in the world.  But we can give it a go.  In <a href=""https://stackoverflow.com/a/43941142/6535399"">another answer</a> there's a breakdown of building a PKCS#8 for RSA.</p>

<p>Let's take this blob:</p>

<pre><code>308187020100301306072A8648CE3D020106082A8648CE3D030107046D306B02
0101042070A12C2DB16845ED56FF68CFC21A472B3F04D7D6851BF6349F2D7D5B
3452B38AA144034200048101ECE47464A6EAD70CF69A6E2BD3D88691A3262D22
CBA4F7635EAFF26680A8D8A12BA61D599235F67D9CB4D58F1783D3CA43E78F0A
5ABAA624079936C0C3A9
</code></pre>

<p>It breaks down like</p>

<pre><code>30 /* SEQUENCE */
   81 87 (payload is 0x87 bytes)

   02 /* INTEGER */ 01 (1 byte) 00 // Integer: 0. // validate this

   30 /* SEQUENCE */ 13 (0x13 bytes)

      06 /* OBJECT IDENTIFIER */ 07 (7 bytes)
         2A8648CE3D0201  (1.2.840.10045.2.1 / ecPublicKey) // validate this

      06 /* OBJECT IDENTIFIER */ 08 (8 bytes)
         2A8648CE3D030107 (1.2.840.10045.3.1.7 / secp256r1) // save this, curveName

   04 /* OCTET STREAM (byte[]) */ 6D (0x6D bytes)
      // Since the constructed (0x20) bit isn't set in the tag normally we stop here,
      // but we know from the ecPublicKey context that this is also DER data.

      30 /* SEQUENCE */ 6B (0x6B bytes)

         02 /* Integer */ 01 (1 byte) 01 // Integer: 1. // validate this.

         04 /* OCTET STREAM (byte[]) */ 20 (0x20 bytes / 256 bits)
            70A12C2DB16845ED56FF68CFC21A472B3F04D7D6851BF6349F2D7D5B3452B38A // save this: D

         A1 /* CONSTRUCTED CONTEXT SPECIFIC 1 */ 44 (0x44 bytes)

            03 /* BIT STRING (byte[] if the first byte is 0x00) */ 66 (0x66 bytes)

               00 // Oh, good, it's a normal byte[]. Validate this.

               // Formatting will become apparent. Save this.
               04
               8101ECE47464A6EAD70CF69A6E2BD3D88691A3262D22CBA4F7635EAFF26680A8
               D8A12BA61D599235F67D9CB4D58F1783D3CA43E78F0A5ABAA624079936C0C3A9
</code></pre>

<p>The BIT STRING at the end is ""the public key"". Since it starts with <code>04</code> (which it usually will, unless the sender is mad at you) it represents an ""uncompressed point"", meaning the first half of what's left is the X coordinate, and the remainder is the Y coordinate.  So from this structure you might get something like</p>

<pre><code>string curveOid;

// You can decode the OID, or special case it.
switch (curveName)
{
    case ""2A8648CE3D030107"":
        // secp256r1
        curveOid = ""1.2.840.10045.3.1.7"";
        break;
    case ""2B81040022""
        // secp384r1
        curveOid = ""1.3.132.0.34"";
        break;
    case ""2B81040023"":
        // secp521r1
        curveOid = ""1.3.132.0.35"";
        break;
    default:
        throw new InvalidOperationException();
 }

 return new ECParameters
 {
     Curve = ECCurve.CreateFromValid(curveOid),

     // We saved this.
     D = d,

     Q = new ECPoint
     {
        X = x,
        Y = y
     },
 }
</code></pre>

<p>This happens to be the key used in section D.1 (NIST P-256 / secp256r1) of <a href=""https://www.iad.gov/iad/library/ia-guidance/ia-solutions-for-classified/algorithm-guidance/suite-b-implementers-guide-to-fips-186-3-ecdsa.cfm"" rel=""nofollow noreferrer"">Suite B Implementers Guide to FIPS 186-3 (ECDSA)</a>.</p>

<p>Since the EC key format is mercifully short on INTEGER values (which can require padding bytes) you can build a manual extractor for each keysize you want to support.  Or you can go the live DER reading route.  Or you can try to get your private key serialized in a more friendly form for your application.</p>
","743","<apple-push-notifications><.net-core><ecdsa>","1","2","2","2019-05-08 13:27:40","","0","","","","","2017-05-15 16:27:46",""
"43984535","ECDsa Signing in .Net Core on Linux","<p>I'm trying to create a C# implementation to send Pushes to Apple via their HTTP/2 APNS Endpoint with .Net core in Docker. Part of this requires sending an encrypted JWT Authorization Token along with the payload. With .Net core, I can sign the token when running on Windows, but when running in the Linux Docker image, it tips over loading the Key. </p>

<p>When running in the .net Core Docker Image, I get a platformnotsupported Exception on loading the key.</p>

<pre><code>    public static string SignES256(string privateKey, string header, string payload)
    {

        // This is the failing Call
        CngKey key = CngKey.Import(Convert.FromBase64String(privateKey), CngKeyBlobFormat.Pkcs8PrivateBlob);

        using (ECDsaCng dsa = new ECDsaCng(key))
        {
            var unsignedJwtData =
                System.Convert.ToBase64String(Encoding.UTF8.GetBytes(header)) + ""."" + System.Convert.ToBase64String(Encoding.UTF8.GetBytes(payload));
            var unsignedJwtDataBytes = Encoding.UTF8.GetBytes(unsignedJwtData);

            var signature =
                dsa.SignData(unsignedJwtDataBytes, 0, unsignedJwtDataBytes.Length, HashAlgorithmName.SHA256 );
            return unsignedJwtData + ""."" + System.Convert.ToBase64String(signature);
        }
    }
</code></pre>

<p>How can I do this from .Net Core on Linux?</p>

<p>Thanks.</p>
","<p>As others have pointed out, BouncyCastle is a cross-platform alternative to Windows CNG. None of the other examples out there were quite working for me, though. Maybe this will help someone:</p>

<pre class=""lang-xml prettyprint-override""><code>&lt;Project Sdk=""Microsoft.NET.Sdk""&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=""Portable.BouncyCastle"" Version=""1.8.5"" /&gt;
    &lt;PackageReference Include=""System.IdentityModel.Tokens.Jwt"" Version=""5.4.0"" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

</code></pre>

<pre class=""lang-cs prettyprint-override""><code>using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Cryptography;
using Microsoft.IdentityModel.Tokens;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;

public class ApnsTokenProvider
{
    private readonly JwtSecurityTokenHandler _tokenHandler = new JwtSecurityTokenHandler();

    public string GetToken(string teamId, string keyId, string privateKey)
    {
        using (var algorithm = GetEllipticCurveAlgorithm(privateKey))
        {
            var credentials = new SigningCredentials(new ECDsaSecurityKey(algorithm)
            {
                KeyId = keyId
            }, SecurityAlgorithms.EcdsaSha256);

            return _tokenHandler.CreateEncodedJwt(new SecurityTokenDescriptor
            {
                Issuer = teamId,
                SigningCredentials = credentials
            });
        }
    }

    private static ECDsa GetEllipticCurveAlgorithm(string privateKey)
    {
        var keyParams = (ECPrivateKeyParameters)PrivateKeyFactory
            .CreateKey(Convert.FromBase64String(privateKey));

        var q = keyParams.Parameters.G.Multiply(keyParams.D).Normalize();

        return ECDsa.Create(new ECParameters
        {
            Curve = ECCurve.CreateFromValue(keyParams.PublicKeyParamSet.Id),
            D = keyParams.D.ToByteArrayUnsigned(),
            Q =
            {
                X = q.XCoord.GetEncoded(),
                Y = q.YCoord.GetEncoded()
            }
        });
    }
}
</code></pre>
","743","<apple-push-notifications><.net-core><ecdsa>","1","0","2","2019-05-08 13:27:40","","0","","","","","2017-05-15 16:27:46",""
"21024399","Get ECDSA signature with Crypto++","<p>I have to get ECDSA signature in variable using Crypto++.<br>
I tried to get it after launching SignMessage but signature is empty.<br>
How could i get it?  </p>
","<p>Have you had a look at the Crypto++ wiki? There's a lot of stuff on <a href=""http://www.cryptopp.com/wiki/Ecdsa"" rel=""nofollow"">Elliptic Curve Digital Signature Algorithm</a>.</p>

<p>Its not really clear what you are doing or where things went wrong, so here's a copy and paste from the wiki:</p>

<p>Signing:</p>

<pre><code>ECDSA&lt;ECP, SHA1&gt;::PrivateKey privateKey;
privateKey.Load(...);

AutoSeededRandomPool prng;
string message = ""Yoda said, Do or do not. There is no try."";
string signature;

StringSource ss1( message, true /*pump all*/,
    new SignerFilter( prng,
        ECDSA&lt;ECP,SHA1&gt;::Signer( privateKey ),
        new StringSink( signature )
    ) // SignerFilter
); // StringSource
</code></pre>

<p>Verification:</p>

<pre><code>ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey;
publicKey.Load(...);

// Result of the verification process
bool result = false;

// Exactly what was signed in the previous step
string message = ...;
// Output from the signing operation in the previous step
string signature = ...;

StringSource ss2( signature+message, true /*pump all*/,
    new SignatureVerificationFilter(
        ECDSA&lt;ECP,SHA1&gt;::Verifier(publicKey),
        new ArraySink( (byte*)&amp;result, sizeof(result) )
    ) // SignatureVerificationFilter
);

// Verification failure?
if( !result ) {...}
</code></pre>

<p>If you would like the verifcation to throw on a failure, then try:</p>

<pre><code>static const int VERIFICATION_FLAGS = SIGNATURE_AT_BEGIN | THROW_EXCEPTION;
StringSource ss3( signature+message, true /*pump all*/,
    new SignatureVerificationFilter(
        ECDSA&lt;ECP,SHA1&gt;::Verifier(publicKey),
        NULL, /* No need for attached filter */
        VERIFICATION_FLAGS
    ) // SignatureVerificationFilter
);
</code></pre>
","742","<c++><crypto++><ecdsa>","0","0","1","2018-10-25 04:42:50","","0","","2509078","","2018-10-25 04:42:50","2014-01-09 15:31:12",""
"46546230","Error incomplete definition of type 'struct ec_key_st' using OpenSSL","<p>I am trying to compute public key from given secret by openssl. I get this error:</p>

<pre><code>main.c:27: error: incomplete definition of type 'struct ec_key_st'
  printf(""d: %s\n"", BN_bn2hex(eckey-&gt;priv_key));
                              ~~~~~^
</code></pre>

<p>Here is my code:</p>

<pre><code>#include &lt;stdio.h&gt;

#include &lt;openssl/ec.h&gt;
#include &lt;openssl/ecdsa.h&gt;
#include &lt;openssl/bn.h&gt;
#include &lt;openssl/obj_mac.h&gt;

int main()
{
  BN_CTX *ctx = BN_CTX_new();

  EC_KEY *eckey = EC_KEY_new();
  EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);
  EC_KEY_set_group(eckey, group);

  BIGNUM *prv = BN_new();
  BN_hex2bn(&amp;prv, ""b14fac12b3fa7dd6f2562a18d554fcd6818137ebb7e0d119ab0776d6407664f9"");
  EC_KEY_set_private_key(eckey, prv);

  EC_POINT *Q = EC_POINT_new(group);
  EC_POINT_mul(group, Q, prv, NULL, NULL, ctx);
  EC_KEY_set_public_key(eckey, Q);

  if (EC_KEY_check_key(eckey))
    printf(""Key succesfully checked.\n"");

  printf(""d: %s\n"", BN_bn2hex(eckey-&gt;priv_key));
  printf(""X: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;X));
  printf(""Y: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;Y));

  EC_GROUP_free (group); group = NULL;
  EC_KEY_free (eckey); eckey = NULL;
  return 0;
}
</code></pre>

<p>What is wrong with the above code? If I remove printf lines, it works fine. I would appreciate if anybody helps me getting rid of this error.</p>
","<p>You need to get ""ec_lcl.h"" header file from openssl libarary, in order to access members of struct ""ec_key_st"". Notice that ""ECKEY"" is defined as:</p>

<pre><code>typedef struct ec_key_st EC_KEY;
</code></pre>

<p>So you put ""ec_lcl.h"" in your project folder and then change your code to this:</p>

<pre><code>#include &lt;stdio.h&gt;

#include &lt;openssl/ec.h&gt;
#include &lt;openssl/ecdsa.h&gt;
#include &lt;openssl/bn.h&gt;
#include &lt;openssl/obj_mac.h&gt;

#include ""ec_lcl.h""

int main()
{
  BN_CTX *ctx = BN_CTX_new();

  struct ec_key_st *eckey = EC_KEY_new();
  EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);
  EC_KEY_set_group(eckey, group);

  BIGNUM *prv = BN_new();
  BN_hex2bn(&amp;prv, ""b14fac12b3fa7dd6f2562a18d554fcd6818137ebb7e0d119ab0776d6407664f9"");
  EC_KEY_set_private_key(eckey, prv);

  EC_POINT *Q = EC_POINT_new(group);
  EC_POINT_mul(group, Q, prv, NULL, NULL, ctx);
  EC_KEY_set_public_key(eckey, Q);

  if (EC_KEY_check_key(eckey))
    printf(""Key succesfully checked.\n"");

  printf(""d: %s\n"", BN_bn2hex(eckey-&gt;priv_key));
  printf(""X: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;X));
  printf(""Y: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;Y));

  EC_GROUP_free (group); group = NULL;
  EC_KEY_free (eckey); eckey = NULL;
  return 0;
}
</code></pre>
","740","<c><openssl><ecdsa>","2","0","2","2018-11-22 08:03:47","","0","","608639","","2018-11-22 08:03:47","2017-10-03 13:49:52",""
"46546230","Error incomplete definition of type 'struct ec_key_st' using OpenSSL","<p>I am trying to compute public key from given secret by openssl. I get this error:</p>

<pre><code>main.c:27: error: incomplete definition of type 'struct ec_key_st'
  printf(""d: %s\n"", BN_bn2hex(eckey-&gt;priv_key));
                              ~~~~~^
</code></pre>

<p>Here is my code:</p>

<pre><code>#include &lt;stdio.h&gt;

#include &lt;openssl/ec.h&gt;
#include &lt;openssl/ecdsa.h&gt;
#include &lt;openssl/bn.h&gt;
#include &lt;openssl/obj_mac.h&gt;

int main()
{
  BN_CTX *ctx = BN_CTX_new();

  EC_KEY *eckey = EC_KEY_new();
  EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);
  EC_KEY_set_group(eckey, group);

  BIGNUM *prv = BN_new();
  BN_hex2bn(&amp;prv, ""b14fac12b3fa7dd6f2562a18d554fcd6818137ebb7e0d119ab0776d6407664f9"");
  EC_KEY_set_private_key(eckey, prv);

  EC_POINT *Q = EC_POINT_new(group);
  EC_POINT_mul(group, Q, prv, NULL, NULL, ctx);
  EC_KEY_set_public_key(eckey, Q);

  if (EC_KEY_check_key(eckey))
    printf(""Key succesfully checked.\n"");

  printf(""d: %s\n"", BN_bn2hex(eckey-&gt;priv_key));
  printf(""X: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;X));
  printf(""Y: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;Y));

  EC_GROUP_free (group); group = NULL;
  EC_KEY_free (eckey); eckey = NULL;
  return 0;
}
</code></pre>

<p>What is wrong with the above code? If I remove printf lines, it works fine. I would appreciate if anybody helps me getting rid of this error.</p>
","<p>You're using OpenSSL 1.1, and they have decided that you shouldn't be poking about at the innards of their structures anymore.</p>

<p><code>eckey-&gt;priv_key</code> was a valid way of accessing the private key in OpenSSL 1.0.x, but now the only correct way is <code>EC_KEY_get0_private_key(eckey)</code></p>

<p>Likewise, for the public key it's <code>EC_KEY_get0_public_key(eckey)</code>.</p>

<p>Both of these functions were declared during OpenSSL 1.0.x, so you can write the code to be the same between them.</p>

<p>So</p>

<pre><code>printf(""d: %s\n"", BN_bn2hex(eckey-&gt;priv_key));
printf(""X: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;X));
printf(""Y: %s\n"", BN_bn2hex(&amp;eckey-&gt;pub_key-&gt;Y));
</code></pre>

<p>would become</p>

<pre><code>{
    const BIGNUM* d = EC_KEY_get0_private_key(eckey);
    const EC_POINT* Q = EC_KEY_get0_public_key(eckey);
    const EC_GROUP* group = EC_KEY_get0_group(eckey);
    BIGNUM* x = BN_new();
    BIGNUM* y = BN_new();

    if (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, null))
    {
        error();
    }

    printf(""d: %s\n"", BN_bn2hex(d));
    printf(""X: %s\n"", BN_bn2hex(x));
    printf(""Y: %s\n"", BN_bn2hex(y));

    BN_free(x);
    BN_free(y);
}
</code></pre>

<p>This keeps your code working, even when OpenSSL 1.1.1 decides to redo the struct layout which was hidden within ec_lcl.h</p>
","740","<c><openssl><ecdsa>","2","5","2","2018-11-22 08:03:47","","0","","608639","","2018-11-22 08:03:47","2017-10-03 13:49:52",""
"52255715","PHP create ECDSA signature and verify with Golang","<p>I try to make the app with PHP that creates ECDSA signature for some document and that signature is verified with Golang app.</p>

<p>I use private keys generated with openssl tool. It is prime256v1 curve key. Created with the command:</p>

<pre><code>openssl ecparam -name prime256v1 -genkey -noout -out prime256v1-key.pem
</code></pre>

<p>In PHP i create signature using openssl_sign function.</p>

<p>And all my attempts to verify the signature with Golang fail. In Golang  use the crypto/ecdsa, crypto/elliptic packages.</p>

<p>There is my code.</p>

<p>PHP  </p>

<pre><code>&lt;?php

$stringtosign = ""my test string to sign"";

// Privcate key was geerated with openssl tool with the command
// openssl ecparam -name prime256v1 -genkey -noout -out prime256v1-key.pem
$cert = file_get_contents('prime256v1-key.pem');

$prkey = openssl_pkey_get_private($cert);

// we sign only hashes, because Golang lib can wok with hashes only
$stringtosign = md5($stringtosign);

// we generate 64 length signature (r and s 32 bytes length)
while(1) {

    openssl_sign($stringtosign, $signature, $prkey, OPENSSL_ALGO_SHA256);

    $rlen = ord(substr($signature,3,1));

    $slen = ord(substr($signature,5+$rlen,1));

    if ($slen != 32 || $rlen != 32) {
        // try other signature if length is not 32 for both parts
        continue;
    }
    $r = substr($signature,4,$rlen);
    $s = substr($signature,6+$rlen,$slen);

    $signature = $r.$s;

    break;
}
openssl_free_key($prkey);

$signature = bin2hex($signature);

echo $signature.""\n"";
</code></pre>

<p>Golang</p>

<pre><code>package main

import (
    ""crypto/ecdsa""
    ""crypto/elliptic""
    ""crypto/md5""
    ""encoding/hex""
    ""fmt""
    ""io""
    ""io/ioutil""
    ""math/big""

    ""crypto/x509""

    ""encoding/pem""
)

func main() {
    stringtosign := ""my test string to sign""

    // This is outpur of PHP app. Signature generated by PHP openssl_sign
    signature := ""18d5c1d044a4a752ad91bc06499c72a590b2842b3d3b4c4b1086bfd0eea3e7eb5c06b77e15542e5ba944f3a1a613c24eabaefa4e2b2251bd8c9355bba4d14640""

    // NOTE . Error verificaion is skipped here

    // Privcate key was geerated with openssl tool with the command
    // openssl ecparam -name prime256v1 -genkey -noout -out prime256v1-key.pem
    prikeybytes, _ := ioutil.ReadFile(""prime256v1-key.pem"")

    p, _ := pem.Decode(prikeybytes)

    prikey, _ := x509.ParseECPrivateKey(p.Bytes)

    signatureBytes, _ := hex.DecodeString(signature)

    // make MD5 hash
    h := md5.New()
    io.WriteString(h, stringtosign)
    data := h.Sum(nil)

    // build key and verify data
    r := big.Int{}
    s := big.Int{}
    // make signature numbers
    sigLen := len(signatureBytes)
    r.SetBytes(signatureBytes[:(sigLen / 2)])
    s.SetBytes(signatureBytes[(sigLen / 2):])

    curve := elliptic.P256()

    // make public key from private key
    x := big.Int{}
    y := big.Int{}
    x.SetBytes(prikey.PublicKey.X.Bytes())
    y.SetBytes(prikey.PublicKey.Y.Bytes())
    rawPubKey := ecdsa.PublicKey{Curve: curve, X: &amp;x, Y: &amp;y}

    v := ecdsa.Verify(&amp;rawPubKey, data, &amp;r, &amp;s)

    if v {
        fmt.Println(""Success verify!"")
        return
    }

    fmt.Println(fmt.Sprintf(""Signatire doed not match""))

}
</code></pre>

<p>What do i do wrong? Can anyone show me working example where Golang verifies signatre created with PHP?</p>

<p>I tried to use different versions in openssl_sign instead of OPENSSL_ALGO_SHA256  . Tried OPENSSL_ALGO_SHA1, OPENSSL_ALGO_SHA512</p>
","<p>The problem with your code seems to be, that you hash the string in PHP using MD5 before signing it using <code>OPENSSL_ALGO_SHA256</code>, which hashes what you sign (the MD5 hash) again, while in your Go program, you only have the first of these 2 hashes. To fix this, I would remove the <code>MD5</code> step in the PHP code and replace the <code>h := md5.New()</code> line in your code with the hash used by your signature algorithm (<code>h := sha256.New()</code> in your example).</p>

<p>To elaborate a bit more on what theses signing functions do, I would first like to break signing and verifying down into the following steps:</p>

<ul>
<li>Signing:

<ol>
<li>Hash the message</li>
<li>Encrypt the message's hash using the private key (this encrypted hash is the signature)</li>
</ol></li>
<li>Verifying:

<ol>
<li>Hash the message</li>
<li>Decrypt the signature using the public key (this yields the hash which was encrypted while signing).</li>
<li>Compare the calculated and decrypted hashes. If they match, then the signature is correct.</li>
</ol></li>
</ul>

<p>Now the call to <a href=""http://php.net/manual/en/function.openssl-sign.php"" rel=""nofollow noreferrer""><code>openssl_sign</code></a> in your PHP code, does all the signing steps, while the call to <a href=""https://golang.org/pkg/crypto/ecdsa/#Verify"" rel=""nofollow noreferrer""><code>ecdsa.Verify</code></a> in Go, only does the second and third step of the verification process. And this is why it takes a hash as the second argument. So to verify a signature, you must implement the first verification step yourself, namely generating the hash. </p>

<p>You must use the same hashing algorithm while signing and verifying, therefore you must use SHA256, not MD5, in your Go code (as you sign using <code>OPENSSL_ALGO_SHA256</code>), otherwise the hashes will (generally) not match.</p>

<p>Also, I would recommend to not use MD5 for signatures, as it is no longer considered collision resistant (a hash collision is, when you have 2 different strings/files/... with the same hash). For more details about that, you can check the <a href=""https://en.wikipedia.org/wiki/MD5#Collision_vulnerabilities"" rel=""nofollow noreferrer"">Wikipedia article on MD5</a>, specifically the section ""Collision vulnerabilities"". This is a problem, as 2 messages with the same MD5 hash, will also have the same signature and an attacker could use the signature generated for one of the strings to trick you into thinking the other was signed (and therefore trust it).</p>

<p>Additionally, <a href=""https://golang.org/pkg/crypto/ecdsa/#PrivateKey"" rel=""nofollow noreferrer""><code>ecdsa.PrivateKey</code></a> can give you the corresponding public key, and you can call <a href=""https://golang.org/pkg/crypto/ecdsa/#Verify"" rel=""nofollow noreferrer""><code>ecdsa.Verify</code></a> like this:</p>

<pre><code>ecdsa.Verify(&amp;prikey.PublicKey, data, &amp;r, &amp;s)
</code></pre>

<p>This saves you the trouble of copying all the data from the private key to a new object.</p>
","730","<php><go><ecdsa>","5","1","1","2018-09-10 12:20:03","52257396","0","","","","","2018-09-10 10:23:30",""
"46182659","How to delay sign the certificate request using Bouncy Castle with ECDSA signature?","<p>I am trying to implement delay signing of a certificate request (CSR) with ECDSA signature algorithm using Bouncy Castle in C#. So far I've managed to implement this with RSA but not ECDSA. I use Pkcs10CertificationRequestDelaySigned class from Bouncy Castle.</p>

<p>A snippet of my test code that fails when verifying signature (full code is available below):</p>

<pre><code>        [TestMethod]
        public void ValidCsrWithoutPassword_Ecdsa_SignatureIsAppended()
        {
            DelayCsrProvider sut = CreateSut();

            const string signAlgorithm = ""ECDSA"";
            var keys = new Keys(signAlgorithm);

            // Create CSR
            var signatureAlgorithm = ""SHA256withECDSA"";
            byte[] octetData = CreateCsr(keys.SignKeyPair, signatureAlgorithm);

            // Append password to CSR
            byte[] csrWithPass = sut.AppendPassword(octetData, ""some-text-1"");

            // Calculate HASH
            var hashAlgorithm = CmsSignedGenerator.DigestSha256;
            byte[] hash = sut.BuildHash(csrWithPass, hashAlgorithm);

            // Sign using HASH
            byte[] signature = Sign(hash, signAlgorithm, hashAlgorithm, keys.SignKeyPair.Private);

            // Add signature to CSR
            byte[] csrSigned = sut.AppendSignature(csrWithPass, signature);

            // Just verify the signature matches CSR's public key + data,
            // public key should match the private key
            // this is where it fails

            Verify(csrSigned);
        }
</code></pre>

<p>The scenario is:
 There are two entities (programs running on separate machines).
One has both private and public key - call it Signer and the other has additional information (like password) for extending certificate request with that information but NO access to private key - call it DelayCsrProvider.</p>

<p>The sequence is: </p>

<ol>
<li><p>Signer creates CSR without password and signs the data, sends it to DelayCsrProvider in PKCS#10 format DER encoded.</p></li>
<li><p>DelayCsrProvider creates new CSR with all the information from received CSR plus adds additional attribute that contains password. 
Now we have to sign this new CSR but we don't have private key. Instead we calculate hash (SHA-256) of data and send the digest to Signer.</p></li>
<li><p>Signer receives the hash and signs the hash, sends the signature back to DelayCsrProvider.</p></li>
<li><p>DelayCsrProvider inserts received signature into CSR thus creating a full CSR that has valid signature.</p></li>
</ol>

<p>I've created DelayCsrProvider class and unit test that is making all the steps described above. One unit-test for RSA works just fine, the other unit test for ECDSA fails when verifying the signature.</p>

<p>What else can be done here to resolve ECDSA hash signing ?</p>

<p>See main part of code below or download the whole example from GIT: <a href=""https://github.com/DmitriNymi/Certificate-Enrollment.git"" rel=""nofollow noreferrer"">https://github.com/DmitriNymi/Certificate-Enrollment.git</a></p>

<p>Note:</p>

<p>.Net Framework 4.6.2
Bouncy Castle nuget 
BouncyCastle.Crypto.dll FileVersion=1.8.15362.1 </p>

<p>This is full code example of test that fails in Assert ValidCsrWithoutPassword_Ecdsa_SignatureIsAppended() :</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Org.BouncyCastle.Asn1;
using Org.BouncyCastle.Asn1.Pkcs;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Pkcs;
using Org.BouncyCastle.Security;

namespace NEnrollment.Services.DelaySigning
{
public class DelayCsrProvider
{
    /// &lt;summary&gt;
    /// append password to CSR: csrWithPassword = (csr, password)
    /// &lt;/summary&gt;
    /// &lt;param name=""csr""&gt;&lt;/param&gt;
    /// &lt;param name=""password""&gt;&lt;/param&gt;
    /// &lt;returns&gt;CSR that  contains password&lt;/returns&gt;
    public byte[] AppendPassword(byte[] csr, string password)
    {
        if (csr == null) throw new ArgumentNullException(nameof(csr));
        if (string.IsNullOrEmpty(password)) throw new ArgumentNullException(nameof(password));

        var originalCsr = new Pkcs10CertificationRequest(csr);

        CertificationRequestInfo cri = originalCsr.GetCertificationRequestInfo();

        DerSet attributesSet = AddPasswordAttribute(password, cri.Attributes);

        AsymmetricKeyParameter publicKey = PublicKeyFactory.CreateKey(cri.SubjectPublicKeyInfo);

        string signatureAlgorithm = originalCsr.SignatureAlgorithm.Algorithm.Id;

        // build new CSR from original + password attribute
        var csrWithPassword =
            new Pkcs10CertificationRequestDelaySigned(signatureAlgorithm, cri.Subject, publicKey, attributesSet);

        // this signing key is not used for signing but here only to suppress exception thrown in ctor
        csrWithPassword.SignRequest(new byte[] { });

        var csrWithPasswordBytes = csrWithPassword.GetDerEncoded();

        return csrWithPasswordBytes;
    }

    private DerSet AddPasswordAttribute(string password, Asn1Set attributes)
    {
        if (attributes == null) attributes = new DerSet();

        List&lt;AttributePkcs&gt; attributesPkcs = attributes
            .OfType&lt;DerSequence&gt;()
            .Select(AttributePkcs.GetInstance)
            .ToList();

        bool hasPassword = attributesPkcs.Any(x =&gt; x.AttrType.Equals(PkcsObjectIdentifiers.Pkcs9AtChallengePassword));
        if (hasPassword) throw new Exception(""Cannot append password, already has password attribute in CSR."");

        AttributePkcs passwordAttribute = ChallengePasswordAttribute(password);

        attributesPkcs.Add(passwordAttribute);

        // ReSharper disable once CoVariantArrayConversion
        DerSet attributesSet = new DerSet(attributesPkcs.ToArray());
        return attributesSet;
    }

    private AttributePkcs ChallengePasswordAttribute(string password)
    {
        if (password == null) return null;

        Asn1EncodableVector attributeValues = new Asn1EncodableVector { new DerPrintableString(password) };

        return new AttributePkcs(PkcsObjectIdentifiers.Pkcs9AtChallengePassword, new DerSet(attributeValues));
    }

    /// &lt;summary&gt;
    /// Calculates hash (digest) of the given CSR using the specified hash algorithm OID
    /// &lt;/summary&gt;
    /// &lt;param name=""csr""&gt;CSR without password&lt;/param&gt;
    /// &lt;param name=""algorithm""&gt;digest algorithm OID, for example for SHA256 use: ""2.16.840.1.101.3.4.2.1""&lt;/param&gt;
    /// &lt;returns&gt;Hash of csr&lt;/returns&gt;
    public byte[] BuildHash(byte[] csr, string algorithm)
    {
        var originalCsr = new Pkcs10CertificationRequestDelaySigned(csr);

        // parse CSR to Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned
        //  requires CSR to have:
        // 1. Subject
        //      a. X509Name
        //      b. subject public key
        //      c. attributes
        //          c1. password - should be empty
        //          c2. extensions - should contain ... doesn't matter - don't touch
        // 2. SignatureAlgorithmId - keep as it is defined by user request
        // 3. SignBits of user for the given CSR

        // hash = function(csrWithPassword without signature/signature algorithm)
        // for some hash algorithms Hash may depend on a random number, 
        // thus giving different Hash every time it is calculated even for the same Data, PrivateKey

        byte[] dataToSign = originalCsr.GetDataToSign();

        //byte[] digest = DigestUtilities.CalculateDigest(CmsSignedGenerator.DigestSha256, dataToSign);
        byte[] digest = DigestUtilities.CalculateDigest(algorithm, dataToSign);

        return digest;
    }

    /// &lt;summary&gt;
    /// Creates new csr from given CSR + signature
    /// &lt;/summary&gt;
    /// &lt;param name=""csr""&gt;CSR to be used for appending signature&lt;/param&gt;
    /// &lt;param name=""signature""&gt;signature to be appended to CSR&lt;/param&gt;
    /// &lt;returns&gt;new CSR with signature appended inside&lt;/returns&gt;
    public byte[] AppendSignature(byte[] csr, byte[] signature)
    {
        if (csr == null) throw new ArgumentNullException(nameof(csr));

        var originalCsr = new Pkcs10CertificationRequestDelaySigned(csr);

        originalCsr.SignRequest(signature);

        byte[] csrBytes = originalCsr.GetDerEncoded();

        return csrBytes;
    }
}
}
</code></pre>

<p>This is the test code that signs the hash and calls DelayCsrProvider.
The test fails when signing with ECDSA, see test method: ValidCsrWithoutPassword_Ecdsa_SignatureIsAppended</p>

<pre><code>    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using NEnrollment.Services.DelaySigning;
    using Org.BouncyCastle.Asn1;
    using Org.BouncyCastle.Asn1.Sec;
    using Org.BouncyCastle.Asn1.X509;
    using Org.BouncyCastle.Cms;
    using Org.BouncyCastle.Crypto;
    using Org.BouncyCastle.Crypto.Operators;
    using Org.BouncyCastle.Crypto.Parameters;
    using Org.BouncyCastle.Math;
    using Org.BouncyCastle.Pkcs;
    using Org.BouncyCastle.Security;

    namespace NEnrollment.Tests
    {
    [TestClass]
    public class DelayCsrProviderTest
    {
        private readonly bool _enableWritingToFile = false;

        DelayCsrProvider CreateSut()
        {
            return new DelayCsrProvider();
        }

        [TestMethod]
        public void ValidCsrWithoutPassword_Rsa_SignatureIsAppended()
        {
            var sut = CreateSut();

            const string signAlgorithm = ""RSA"";
            var keys = new Keys(signAlgorithm);

            // Create CSR
            var signatureAlgorithm = ""SHA256withRSA"";
            byte[] octetData = CreateCsr(keys.SignKeyPair, signatureAlgorithm);
            ByteArrayToFile(@""Rsa\csrWithoutPass.csr"", octetData);

            // Append password to CSR
            byte[] csrWithPass = sut.AppendPassword(octetData, ""some-text-1"");
            ByteArrayToFile(@""Rsa\csrWithPass.csr"", csrWithPass);

            // Calculate HASH
            var hashAlgorithm = CmsSignedGenerator.DigestSha256;
            byte[] hash = sut.BuildHash(csrWithPass, hashAlgorithm);

            // Sign using HASH
            byte[] signature = Sign(hash, signAlgorithm, hashAlgorithm, keys.SignKeyPair.Private);

            // Add signature to CSR
            byte[] csrSigned = sut.AppendSignature(csrWithPass, signature);
            ByteArrayToFile(@""Rsa\csrSigned.csr"", csrSigned);

            // Just verify the signature matches CSR's public key + data,
            // public key should match the private key
            Verify(csrSigned);
            Verify2(csrSigned);
        }

        [TestMethod]
        public void ValidCsrWithoutPassword_Ecdsa_SignatureIsAppended()
        {
            var sut = CreateSut();

            const string signAlgorithm = ""ECDSA"";
            var keys = new Keys(signAlgorithm);

            // Create CSR
            var signatureAlgorithm = ""SHA256withECDSA"";
            byte[] octetData = CreateCsr(keys.SignKeyPair, signatureAlgorithm);
            ByteArrayToFile(@""Ecdsa\csrWithoutPass.csr"", octetData);
            Verify(octetData);

            // Append password to CSR
            byte[] csrWithPass = sut.AppendPassword(octetData, ""some-text-1"");
            ByteArrayToFile(@""Ecdsa\csrWithPass.csr"", csrWithPass);

            // Calculate HASH
            var hashAlgorithm = CmsSignedGenerator.DigestSha256;
            byte[] hash = sut.BuildHash(csrWithPass, hashAlgorithm);

            // Sign using HASH
            byte[] signature = Sign(hash, signAlgorithm, hashAlgorithm, keys.SignKeyPair.Private);

            // Add signature to CSR
            byte[] csrSigned = sut.AppendSignature(csrWithPass, signature);
            ByteArrayToFile(@""Ecdsa\csrSigned.csr"", csrSigned);

            // Just verify the signature matches CSR's public key + data,
            // public key should match the private key

            //Verify2(csrSigned);
            Verify(csrSigned);
        }

        private byte[] CreateCsr(AsymmetricCipherKeyPair signingKeyPair, string signatureAlgorithm)
        {
            var key = signingKeyPair;

            Dictionary&lt;DerObjectIdentifier, string&gt; values = CreateSubjectValues(""my common name"");

            var subject = new X509Name(values.Keys.Reverse().ToList(), values);

            DerSet attributes = null;

            var signatureFactory = new Asn1SignatureFactory(signatureAlgorithm, key.Private);

            var pkcs10Csr = new Pkcs10CertificationRequest(
                signatureFactory,
                subject,
                key.Public,
                attributes,
                key.Private);

            byte[] derEncoded = pkcs10Csr.GetDerEncoded();

            //string stringEncoded = Convert.ToBase64String(derEncoded);
            //return stringEncoded;
            return derEncoded;
        }

        private Dictionary&lt;DerObjectIdentifier, string&gt; CreateSubjectValues(string commonName)
        {
            var values = new Dictionary&lt;DerObjectIdentifier, string&gt;
            {
                {X509Name.CN, commonName}, //domain name inside the quotes
                /*
                {X509Name.CN, csrSubject.CommonName}, //domain name inside the quotes
                {X509Name.OU, csrSubject.OrganizationalUnit},
                {X509Name.O, csrSubject.Organization}, //Organisation's Legal name inside the quotes
                {X509Name.L, csrSubject.City},
                {X509Name.ST, csrSubject.Country},
                {X509Name.C, csrSubject.State},
                */
            };

            // remove empty values
            var emptyKeys = values.Keys.Where(key =&gt; string.IsNullOrEmpty(values[key])).ToList();

            emptyKeys.ForEach(key =&gt; values.Remove(key));

            return values;
        }

        /// &lt;summary&gt;
        /// Calculate signature using signer algorithm for the defined has algorithm
        /// &lt;/summary&gt;
        /// &lt;param name=""hash""&gt;&lt;/param&gt;
        /// &lt;param name=""signerAlgorithm""&gt;&lt;/param&gt;
        /// &lt;param name=""hashAlgorithmOid""&gt;
        /// hash Algorithm Oid, for example:
        /// ""2.16.840.1.101.3.4.2.1""
        /// &lt;/param&gt;
        /// &lt;param name=""privateSigningKey""&gt;private key for signing&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static byte[] Sign(byte[] hash, string signerAlgorithm, string hashAlgorithmOid, AsymmetricKeyParameter privateSigningKey)
        {

            var digestAlgorithm = new AlgorithmIdentifier(new DerObjectIdentifier(hashAlgorithmOid), DerNull.Instance);
            var dInfo = new DigestInfo(digestAlgorithm, hash);
            byte[] digest = dInfo.GetDerEncoded();

            ISigner signer = SignerUtilities.GetSigner(signerAlgorithm);
            signer.Init(true, privateSigningKey);
            signer.BlockUpdate(digest, 0, digest.Length);
            byte[] signature = signer.GenerateSignature();
            return signature;

/*  // Another way of signing
            if (signerAlgorithm == ""RSA"")
            {
                // convert private key from BouncyCastle to System.Security :
                RSA key = DotNetUtilities.ToRSA((RsaPrivateCrtKeyParameters)privateSigningKey);
                using (var cryptoServiceProvider = new RSACryptoServiceProvider())
                {
                    cryptoServiceProvider.ImportParameters(key.ExportParameters(true));

                    //
                    // Hash and sign the data. Pass a new instance of SHA1CryptoServiceProvider
                    // to specify the use of SHA1 for hashing.
                    byte[] signedData = cryptoServiceProvider.SignHash(hash, hashAlgorithmOid);
                    return signedData;
                }
            }

            if (signerAlgorithm == ""ECDSA"")
            {
                // convert private key from BouncyCastle to System.Security :
                var bcKeyInfo = PrivateKeyInfoFactory.CreatePrivateKeyInfo(privateSigningKey);
                var pkcs8Blob = bcKeyInfo.GetDerEncoded();
                var key = CngKey.Import(pkcs8Blob, CngKeyBlobFormat.Pkcs8PrivateBlob);

                using (ECDsaCng cryptoServiceProvider = new ECDsaCng(key))
                {
                    cryptoServiceProvider.HashAlgorithm = CngAlgorithm.Sha256; //, hashAlgorithmOid);

                    byte[] signature = cryptoServiceProvider.SignHash(hash);
                    return signature;
                }
            }

            throw new NotImplementedException(signerAlgorithm);
*/
        }

        /// &lt;summary&gt;
        /// Verify signature using self verification of Pkcs10CertificationRequest
        /// &lt;/summary&gt;
        /// &lt;param name=""csrSigned""&gt;&lt;/param&gt;
        private void Verify(byte[] csrSigned)
        {
            Assert.IsNotNull(csrSigned);

            var csr = new Pkcs10CertificationRequest(csrSigned);

            bool isValid = csr.Verify();

            Assert.IsTrue(isValid, ""Verification failed"");
        }

        /// &lt;summary&gt;
        /// Verify signature using specified signer
        /// &lt;/summary&gt;
        /// &lt;param name=""csrSigned""&gt;&lt;/param&gt;
        private void Verify2(byte[] csrSigned)
        {
            var csr = new Pkcs10CertificationRequestDelaySigned(csrSigned);
            var sigBytes = csr.Signature.GetBytes();//.GetDerEncoded();
            var data = csr.GetDataToSign();
            AsymmetricKeyParameter publicSigningKey = csr.GetPublicKey();
            var signerAlgorithm = csr.SignatureAlgorithm.Algorithm.Id;

            var s = SignerUtilities.GetSigner(signerAlgorithm);
            s.Init(false, publicSigningKey);
            s.BlockUpdate(data, 0, data.Length);
            bool isValidSignature = s.VerifySignature(sigBytes);

            Assert.IsTrue(isValidSignature, ""ECDSA verification failed"");
        }

        private void ByteArrayToFile(string fileName, byte[] byteArray)
        {
            if (!_enableWritingToFile) return;

            try
            {
                fileName = @""C:\temp\delayCsrTest\"" + fileName;
                new FileInfo(fileName).Directory?.Create();
                File.WriteAllBytes(fileName, byteArray);
            }
            catch (Exception ex)
            {
                Console.WriteLine(""Exception caught in process: {0}"", ex);
                throw;
            }
        }
    }

    /// &lt;summary&gt;
    /// Helper that stores private and public key-pair as required for signing and verification of signature
    /// &lt;/summary&gt;
    class Keys
    {
        private static readonly SecureRandom Rand;

        private readonly string _keyAlgorithm;

        private readonly KeyGenerationParameters _keyGenerationParameters;

        private readonly IAsymmetricCipherKeyPairGenerator _keyPairGenerator;

        private AsymmetricCipherKeyPair _signKeyPair;
        public AsymmetricCipherKeyPair SignKeyPair =&gt; _signKeyPair ?? (_signKeyPair = MakeKeyPair());

        static Keys()
        {
            try
            {
                Rand = new SecureRandom();
            }
            catch (Exception ex)
            {
                throw new Exception(ex.ToString());
            }
        }

        public Keys(string keyAlgorithm)
        {
            _keyAlgorithm = keyAlgorithm;
            _keyGenerationParameters = CreateKeyGenerationParameters();
            _keyPairGenerator = CreateKeyPairGenerator();
        }

        private KeyGenerationParameters CreateKeyGenerationParameters()
        {
            SecureRandom random = Rand;
            //SecureRandom random = SecureRandom.GetInstance(""SHA256PRNG"");

            if (_keyAlgorithm == ""RSA"")
            {
                return new RsaKeyGenerationParameters(BigInteger.ValueOf(65537), random, 2048, 25);
            }

            if (_keyAlgorithm == ""ECDSA"")
            {
                return new ECKeyGenerationParameters(SecObjectIdentifiers.SecP256r1, random);
            }

            throw new NotSupportedException(_keyAlgorithm);
        }

        private IAsymmetricCipherKeyPairGenerator CreateKeyPairGenerator()
        {
            var keyPairGenerator = GeneratorUtilities.GetKeyPairGenerator(_keyAlgorithm);
            keyPairGenerator.Init(_keyGenerationParameters);

            return keyPairGenerator;
        }

        public AsymmetricCipherKeyPair MakeKeyPair()
        {
            return _keyPairGenerator.GenerateKeyPair();
        }
    }
    }
</code></pre>
","<p>I found the problem with the way I was calculating the signature. For some reason it doesn't work for ECDSA, so here is the solution that works both for ECDSA and RSA (with SHA-256 hash). 
In short when calculating signature use ""NONEwithECDSA"" or ""NONEwithRSA"" and also RSA requires adding DigestInfo instead of bair signature as in ECDSA (I am still wondering why ?) .</p>

<pre><code> [TestMethod]
 public void TestDelaySigning()
 {
            const string hashAlgorithm = ""SHA256"";
            const string signAlgorithm = ""ECDSA""; // or ""RSA"" 
            bool isRsa =false; // or true for RSA

           // Create CSR
            var signatureAlgorithm = hashAlgorithm + ""with"" + signAlgorithm; // ""SHA256withECDSA"" or ""SHA256withRSA""
            byte[] octetData = CreateCsr(keys.SignKeyPair, signatureAlgorithm);
            byte[] csrWithPass = AppendPassword(octetData, ""some-password"");

            byte[] hash = BuildHash(csrWithPass, hashAlgorithm);

            // Sign the hash
            string singingAlgorithm2 = ""NONEwith"" + signAlgorithm;
            byte[] signature = Sign(hash, singingAlgorithm2, hashAlgorithm, keys.SignKeyPair.Private, isRsa );

            byte[] csrSigned = AppendSignature(csrWithPass, signature);

            Verify(csrSigned);
 }

        public byte[] BuildHash(byte[] csr, string algorithm)
        {
            var originalCsr = new Pkcs10CertificationRequestDelaySigned(csr);
            byte[] dataToSign = originalCsr.GetDataToSign();
            byte[] digest = DigestUtilities.CalculateDigest(algorithm, dataToSign);
            return digest;
        }

        public static byte[] Sign(byte[] hash, string signerAlgorithm, string hashAlgorithm, 
                                                     AsymmetricKeyParameter privateSigningKey, bool isRsa)
        {
            if (isRsa)
        {
            var hashAlgorithmOid = DigestUtilities.GetObjectIdentifier(hashAlgorithm).Id;

            var digestAlgorithm = new AlgorithmIdentifier(new DerObjectIdentifier(hashAlgorithmOid), DerNull.Instance);
            var dInfo = new DigestInfo(digestAlgorithm, hash);
            byte[] digest = dInfo.GetDerEncoded();
            hash = digest;
        }

        ISigner signer = SignerUtilities.GetSigner(signerAlgorithm);
        signer.Init(true, privateSigningKey);
        signer.BlockUpdate(hash, 0, hash.Length);
        byte[] signature = signer.GenerateSignature();
        return signature;
      }
 }
</code></pre>
","721","<c#><bouncycastle><csr><ecdsa><pkcs#10>","2","1","1","2018-04-06 15:38:17","","0","","8598794","","2017-09-14 14:13:51","2017-09-12 17:50:36",""
"48994344","Python ECDSA, sign with private key with curve secp224k1","<p>I'm really having a hard time getting to get to grips with this 3rd party Python module.
I'm trying to <em>sign a 28-byte SHA-224 digest using a 28-byte SHA-224 digest private key under secp224k1</em>.</p>

<p>My attempt:</p>

<pre><code>import ecdsa

private_key = int(""b89ea7fcd22cc059c2673dc24ff40b978307464686560d0ad7561b83"", 16).to_bytes(28, byteorder='big')
digest_msg = int(""d8af940293347bc348df1896b0d93bf3952399702cef4fbf199d1cf4"", 16).to_bytes(28, byteorder='big')

sk = SigningKey.generate(private_key, curve=ecdsa.secp224k1) 
sig = sk.sign_digest(digest_msg)

&gt;&gt; AttributeError: module 'ecdsa' has no attribute 'secp224k1'
</code></pre>

<p>Hopelessly, I can't even google my way out of this error. </p>
","<p>I suggest using the <code>fastecdsa</code> for doing this type of task.</p>

<p>As far as I know, <code>ecdsa</code> does not support <code>secp224k1</code> curve.</p>

<p><code>fastecdsa</code> does not support importing the key from a string, but you can export it to a <code>pem</code> format and import it using <code>keys.import_key()</code>.
Check it <a href=""https://github.com/AntonKueltz/fastecdsa/blob/master/fastecdsa/keys.py"" rel=""nofollow noreferrer"">here</a>.</p>

<pre><code>from fastecdsa import keys, curve, ecdsa

#generating the private key over secp224k1 curve
private_key = keys.gen_private_key(curve=curve.secp224k1)

#get the public key from the corresponding private key
public_key = keys.get_public_key(private_key, curve=curve.secp224k1)

msg = ""Sign this message with secp224k1""

r, s = ecdsa.sign(msg, private_key, curve.secp224k1)

print(ecdsa.verify((r, s), msg, public_key, curve.secp224k1))
</code></pre>

<p>Output:</p>

<pre><code>True
</code></pre>
","715","<python><ecdsa>","1","1","1","2018-02-26 18:58:25","48995287","2","","","","","2018-02-26 17:55:49",""
"45508442","Golang HTTPS with ECDSA certificate from OpenSSL","<p>I don't know if this is the correct place to ask it, but I will try.</p>

<p>I am trying to run <code>http.ListenAndServeTLS</code> with ECDSA certificate generated from OpenSSL.</p>

<p>It fail with this error message: <code>tls: failed to parse private key</code></p>

<p>Go understand <code>elliptic.P256()</code>, in the code it has this comment <code>See FIPS 186-3, section D.2.3</code>.</p>

<p>In this link: <a href=""http://www.ietf.org/rfc/rfc5480.txt"" rel=""nofollow noreferrer"">http://www.ietf.org/rfc/rfc5480.txt</a>, it says it is also called <code>secp256r1</code>.</p>

<p>As you can see below, OpenSSL undestand this as <code>prime256v1</code>.</p>

<pre><code>$ openssl ecparam -name secp256r1 -text -noout
using curve name prime256v1 instead of secp256r1
ASN1 OID: prime256v1
NIST CURVE: P-256
</code></pre>

<p>So what is wrong?
How can I generate ECDSA certificate from OpenSSL and use it on my Go code?</p>

<p>Using <code>generate_cert.go</code> to generate a P256 ECDSA certificate, my code works, but if I try to read the key file with OpenSSL it fail also.</p>

<pre><code>$ openssl ecparam -text -noout -in key.pem 
unable to load elliptic curve parameters
140377431725720:error:0906D06C:PEM routines:PEM_read_bio:no start line:pem_lib.c:701:Expecting: EC PARAMETERS
</code></pre>
","<p>I couldn't figured out what is the problem between OpenSSL and Go.</p>

<p>But my main problem is, how to generate ECDSA certificate to use with Go code!</p>

<p>Using <code>CFSSL</code> (<a href=""https://cfssl.org/"" rel=""nofollow noreferrer"">https://cfssl.org/</a>) I can generate ECDSA certificate and sign it with my internal CA certificate generated from OpenSSL. The certificate generated from <code>CFSSL</code> works fine with my Go code, so for me it solves my main problem!</p>

<p>I don't know if there is a format problem between OpenSSL and Go, but as <code>CFSSL</code> is written in Go, the certificate generated on it works fine in my code and in browser.</p>
","711","<ssl><go><openssl><ecdsa>","1","0","3","2019-06-15 04:28:44","","0","","","","","2017-08-04 13:43:39",""
"45508442","Golang HTTPS with ECDSA certificate from OpenSSL","<p>I don't know if this is the correct place to ask it, but I will try.</p>

<p>I am trying to run <code>http.ListenAndServeTLS</code> with ECDSA certificate generated from OpenSSL.</p>

<p>It fail with this error message: <code>tls: failed to parse private key</code></p>

<p>Go understand <code>elliptic.P256()</code>, in the code it has this comment <code>See FIPS 186-3, section D.2.3</code>.</p>

<p>In this link: <a href=""http://www.ietf.org/rfc/rfc5480.txt"" rel=""nofollow noreferrer"">http://www.ietf.org/rfc/rfc5480.txt</a>, it says it is also called <code>secp256r1</code>.</p>

<p>As you can see below, OpenSSL undestand this as <code>prime256v1</code>.</p>

<pre><code>$ openssl ecparam -name secp256r1 -text -noout
using curve name prime256v1 instead of secp256r1
ASN1 OID: prime256v1
NIST CURVE: P-256
</code></pre>

<p>So what is wrong?
How can I generate ECDSA certificate from OpenSSL and use it on my Go code?</p>

<p>Using <code>generate_cert.go</code> to generate a P256 ECDSA certificate, my code works, but if I try to read the key file with OpenSSL it fail also.</p>

<pre><code>$ openssl ecparam -text -noout -in key.pem 
unable to load elliptic curve parameters
140377431725720:error:0906D06C:PEM routines:PEM_read_bio:no start line:pem_lib.c:701:Expecting: EC PARAMETERS
</code></pre>
","<p>Here is an example of OpenSSL generated ECDSA keys working with Go.</p>

<p><a href=""https://play.golang.org/p/MS_FQ8cqqA8"" rel=""nofollow noreferrer"">https://play.golang.org/p/MS_FQ8cqqA8</a>.</p>

<p>As clarified in this issue - <a href=""https://github.com/golang/go/issues/23591"" rel=""nofollow noreferrer"">https://github.com/golang/go/issues/23591</a>, go does not recognize EC keys that are generated with the <code>-param_enc explicit</code> flag in Openssl.</p>

<p><code># openssl ecparam -name prime256v1 -genkey -noout -out priv2.pem</code></p>

<p><code># openssl req -new -x509 -key priv2.pem -out EC_server2.pem -days 365</code></p>

<p>Hope this solves your problem.</p>
","711","<ssl><go><openssl><ecdsa>","1","0","3","2019-06-15 04:28:44","","0","","","","","2017-08-04 13:43:39",""
"45508442","Golang HTTPS with ECDSA certificate from OpenSSL","<p>I don't know if this is the correct place to ask it, but I will try.</p>

<p>I am trying to run <code>http.ListenAndServeTLS</code> with ECDSA certificate generated from OpenSSL.</p>

<p>It fail with this error message: <code>tls: failed to parse private key</code></p>

<p>Go understand <code>elliptic.P256()</code>, in the code it has this comment <code>See FIPS 186-3, section D.2.3</code>.</p>

<p>In this link: <a href=""http://www.ietf.org/rfc/rfc5480.txt"" rel=""nofollow noreferrer"">http://www.ietf.org/rfc/rfc5480.txt</a>, it says it is also called <code>secp256r1</code>.</p>

<p>As you can see below, OpenSSL undestand this as <code>prime256v1</code>.</p>

<pre><code>$ openssl ecparam -name secp256r1 -text -noout
using curve name prime256v1 instead of secp256r1
ASN1 OID: prime256v1
NIST CURVE: P-256
</code></pre>

<p>So what is wrong?
How can I generate ECDSA certificate from OpenSSL and use it on my Go code?</p>

<p>Using <code>generate_cert.go</code> to generate a P256 ECDSA certificate, my code works, but if I try to read the key file with OpenSSL it fail also.</p>

<pre><code>$ openssl ecparam -text -noout -in key.pem 
unable to load elliptic curve parameters
140377431725720:error:0906D06C:PEM routines:PEM_read_bio:no start line:pem_lib.c:701:Expecting: EC PARAMETERS
</code></pre>
","<p>Run:</p>

<pre><code>go run `go env GOROOT`/src/crypto/tls/generate_cert.go --host=localhost --ecdsa-curve=P256
</code></pre>

<p>This will generate <code>cert.pem</code> and <code>key.pem</code> in the current directory.</p>
","711","<ssl><go><openssl><ecdsa>","1","0","3","2019-06-15 04:28:44","","0","","","","","2017-08-04 13:43:39",""
"34741881","ECDSA algorithm on JCOP 2.4.2 Java Card","<p>I want to implement ECDSA algorithm on Java Card (JCOP 2.4.2). This is my source code:</p>

<pre><code>package hashPack;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class MyECDSA extends Applet{

    private byte[] PLAINTEXT ;

    private ECPrivateKey            objECDSAPriKey=null;    // Object for ECDSA Private Key
    private ECPublicKey             objECDSAPubKey=null;    // Object for ECDSA Public Key
    private KeyPair                 objECDSAKeyPair=null;   // Object for ECDSA Key Pair
    private Signature               objECDSASign=null;      // Object for ECDSA Signature

    final static short  BAS     =  0;

    final static byte[] SecP192r1_P = {     // 24
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static byte[] SecP192r1_A = {     // 24
        (byte)0xFC,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static byte[] SecP192r1_B = {     // 24
      (byte)0xB1,(byte)0xB9,(byte)0x46,(byte)0xC1,(byte)0xEC,(byte)0xDE,(byte)0xB8,(byte)0xFE,
      (byte)0x49,(byte)0x30,(byte)0x24,(byte)0x72,(byte)0xAB,(byte)0xE9,(byte)0xA7,(byte)0x0F,
      (byte)0xE7,(byte)0x80,(byte)0x9C,(byte)0xE5,(byte)0x19,(byte)0x05,(byte)0x21,(byte)0x64};
    final static byte[] SecP192r1_S = {     // 20
      (byte)0xD5,(byte)0x96,(byte)0x21,(byte)0xE1,(byte)0xEA,(byte)0x20,(byte)0x81,(byte)0xD3,
      (byte)0x28,(byte)0x95,(byte)0x57,(byte)0xED,(byte)0x64,(byte)0x2F,(byte)0x42,(byte)0xC8,
      (byte)0x6F,(byte)0xAE,(byte)0x45,(byte)0x30};
    final static byte[] SecP192r1_G = {     // 25
      (byte)0x12,(byte)0x10,(byte)0xFF,(byte)0x82,(byte)0xFD,(byte)0x0A,(byte)0xFF,(byte)0xF4,
      (byte)0x00,(byte)0x88,(byte)0xA1,(byte)0x43,(byte)0xEB,(byte)0x20,(byte)0xBF,(byte)0x7C,
      (byte)0xF6,(byte)0x90,(byte)0x30,(byte)0xB0,(byte)0x0E,(byte)0xA8,(byte)0x8D,(byte)0x18,(byte)0x03};
    final static byte[] SecP192r1_N = {     // 24
      (byte)0x31,(byte)0x28,(byte)0xD2,(byte)0xB4,(byte)0xB1,(byte)0xC9,(byte)0x6B,(byte)0x14,
      (byte)0x36,(byte)0xF8,(byte)0xDE,(byte)0x99,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
      (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static short  SecP192r1_H =  1;

    //======================================================================================
    public static void install(byte[] bArray, short bOffset, byte bLength){
        new MyECDSA(bArray, bOffset, bLength);
    }

    private MyECDSA(byte bArray[], short bOffset, byte bLength){    

        PLAINTEXT       = new byte[0x100] ;         // Data file

        Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

        register();
    }

    //======================================================================================
    public void process(APDU apdu){
        byte buf[] = apdu.getBuffer();

        switch(buf[1])
        {
            //--------------------------------------------------------
            case (byte)0xA4:                    break;  

            case (byte)0x46:

                // Create ECDSA Keys and Pair
             /*   try {
            // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Here is the problem &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                    objECDSAPriKey = (ECPrivateKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PRIVATE,      KeyBuilder.LENGTH_EC_FP_192, true);
                }
            catch(CryptoException c)
            {    
              short reason = c.getReason();   
              ISOException.throwIt(reason);       // for check
            }     // for check*/
                   // objECDSAPubKey = (ECPublicKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PUBLIC,      KeyBuilder.LENGTH_EC_FP_192, true);

                    // set EC Domain Parameters
                    objECDSAPubKey.setFieldFP(SecP192r1_P, BAS, (short)24);
                    objECDSAPubKey.setA(SecP192r1_A, BAS, (short)24);
                    objECDSAPubKey.setB(SecP192r1_B, BAS, (short)24);
                    objECDSAPubKey.setG(SecP192r1_G, BAS, (short)25);
                    objECDSAPubKey.setK(SecP192r1_H);
                    objECDSAPubKey.setR(SecP192r1_N, BAS, (short)24);

                    objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);


                // On-Card Key Generation Process
                objECDSAKeyPair.genKeyPair();

                // Obtain Key References
                objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
                objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();  

                // Create Signature Object
                objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

            break;

            case (byte)0x2E:                        
                short       Le              = apdu.setOutgoing();   
                short   sSignLen=0 ;

                // Init with Private Key
                objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);

                // Sign Data
                sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

                apdu.setOutgoingLength(sSignLen);
                apdu.sendBytes(BAS, sSignLen);

            break;      
            //--------------------------------------------------------
            default:
                ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
        }

        return; 
    }
}
</code></pre>

<p>I am running this source code using this script script code:</p>

<pre><code>#/term SCComm:2
/mode trace=on
/atr
/card
/select |ecdsa
/send 00A4040007D4106509900090
/send 0046000000
/send 002E00000A30313233343031323334
</code></pre>

<p>When I am calling <code>/send 0046000000</code> for signing the plain text message I get the response code <code>6F00</code>.</p>

<p>Could you help me to find out what is wrong with this?</p>

<p>How to properly implement this algorithm on a JCOP card?</p>
","<p>I'm not an expert on JCOP but I have experience with ISO7816:</p>

<p>Statusword 0x6F00 means ""General Error"". I suppose a CryptoException is thrown, but the value of ""reason"" is between 1-5 (according to the <a href=""https://docs.oracle.com/javame/config/cldc/opt-pkgs/api/security/satsa-api/jsr177/constant-values.html#javacard.security.CryptoException.NO_SUCH_ALGORITHM"" rel=""nofollow"">documentation</a>).
It's not possible to return arbitrary values as ISO7816 statusword.</p>

<p>Therefore I would suggest to send the reason using apdu.sendBytes(...), then you know what really is the problem</p>

<p>Best way would be to debug the code</p>
","694","<smartcard><javacard><apdu><ecdsa><jcop>","2","2","3","2016-02-24 09:27:11","","3","","2425802","","2016-01-28 18:58:05","2016-01-12 11:00:54",""
"34741881","ECDSA algorithm on JCOP 2.4.2 Java Card","<p>I want to implement ECDSA algorithm on Java Card (JCOP 2.4.2). This is my source code:</p>

<pre><code>package hashPack;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class MyECDSA extends Applet{

    private byte[] PLAINTEXT ;

    private ECPrivateKey            objECDSAPriKey=null;    // Object for ECDSA Private Key
    private ECPublicKey             objECDSAPubKey=null;    // Object for ECDSA Public Key
    private KeyPair                 objECDSAKeyPair=null;   // Object for ECDSA Key Pair
    private Signature               objECDSASign=null;      // Object for ECDSA Signature

    final static short  BAS     =  0;

    final static byte[] SecP192r1_P = {     // 24
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static byte[] SecP192r1_A = {     // 24
        (byte)0xFC,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static byte[] SecP192r1_B = {     // 24
      (byte)0xB1,(byte)0xB9,(byte)0x46,(byte)0xC1,(byte)0xEC,(byte)0xDE,(byte)0xB8,(byte)0xFE,
      (byte)0x49,(byte)0x30,(byte)0x24,(byte)0x72,(byte)0xAB,(byte)0xE9,(byte)0xA7,(byte)0x0F,
      (byte)0xE7,(byte)0x80,(byte)0x9C,(byte)0xE5,(byte)0x19,(byte)0x05,(byte)0x21,(byte)0x64};
    final static byte[] SecP192r1_S = {     // 20
      (byte)0xD5,(byte)0x96,(byte)0x21,(byte)0xE1,(byte)0xEA,(byte)0x20,(byte)0x81,(byte)0xD3,
      (byte)0x28,(byte)0x95,(byte)0x57,(byte)0xED,(byte)0x64,(byte)0x2F,(byte)0x42,(byte)0xC8,
      (byte)0x6F,(byte)0xAE,(byte)0x45,(byte)0x30};
    final static byte[] SecP192r1_G = {     // 25
      (byte)0x12,(byte)0x10,(byte)0xFF,(byte)0x82,(byte)0xFD,(byte)0x0A,(byte)0xFF,(byte)0xF4,
      (byte)0x00,(byte)0x88,(byte)0xA1,(byte)0x43,(byte)0xEB,(byte)0x20,(byte)0xBF,(byte)0x7C,
      (byte)0xF6,(byte)0x90,(byte)0x30,(byte)0xB0,(byte)0x0E,(byte)0xA8,(byte)0x8D,(byte)0x18,(byte)0x03};
    final static byte[] SecP192r1_N = {     // 24
      (byte)0x31,(byte)0x28,(byte)0xD2,(byte)0xB4,(byte)0xB1,(byte)0xC9,(byte)0x6B,(byte)0x14,
      (byte)0x36,(byte)0xF8,(byte)0xDE,(byte)0x99,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
      (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static short  SecP192r1_H =  1;

    //======================================================================================
    public static void install(byte[] bArray, short bOffset, byte bLength){
        new MyECDSA(bArray, bOffset, bLength);
    }

    private MyECDSA(byte bArray[], short bOffset, byte bLength){    

        PLAINTEXT       = new byte[0x100] ;         // Data file

        Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

        register();
    }

    //======================================================================================
    public void process(APDU apdu){
        byte buf[] = apdu.getBuffer();

        switch(buf[1])
        {
            //--------------------------------------------------------
            case (byte)0xA4:                    break;  

            case (byte)0x46:

                // Create ECDSA Keys and Pair
             /*   try {
            // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Here is the problem &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                    objECDSAPriKey = (ECPrivateKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PRIVATE,      KeyBuilder.LENGTH_EC_FP_192, true);
                }
            catch(CryptoException c)
            {    
              short reason = c.getReason();   
              ISOException.throwIt(reason);       // for check
            }     // for check*/
                   // objECDSAPubKey = (ECPublicKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PUBLIC,      KeyBuilder.LENGTH_EC_FP_192, true);

                    // set EC Domain Parameters
                    objECDSAPubKey.setFieldFP(SecP192r1_P, BAS, (short)24);
                    objECDSAPubKey.setA(SecP192r1_A, BAS, (short)24);
                    objECDSAPubKey.setB(SecP192r1_B, BAS, (short)24);
                    objECDSAPubKey.setG(SecP192r1_G, BAS, (short)25);
                    objECDSAPubKey.setK(SecP192r1_H);
                    objECDSAPubKey.setR(SecP192r1_N, BAS, (short)24);

                    objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);


                // On-Card Key Generation Process
                objECDSAKeyPair.genKeyPair();

                // Obtain Key References
                objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
                objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();  

                // Create Signature Object
                objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

            break;

            case (byte)0x2E:                        
                short       Le              = apdu.setOutgoing();   
                short   sSignLen=0 ;

                // Init with Private Key
                objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);

                // Sign Data
                sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

                apdu.setOutgoingLength(sSignLen);
                apdu.sendBytes(BAS, sSignLen);

            break;      
            //--------------------------------------------------------
            default:
                ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
        }

        return; 
    }
}
</code></pre>

<p>I am running this source code using this script script code:</p>

<pre><code>#/term SCComm:2
/mode trace=on
/atr
/card
/select |ecdsa
/send 00A4040007D4106509900090
/send 0046000000
/send 002E00000A30313233343031323334
</code></pre>

<p>When I am calling <code>/send 0046000000</code> for signing the plain text message I get the response code <code>6F00</code>.</p>

<p>Could you help me to find out what is wrong with this?</p>

<p>How to properly implement this algorithm on a JCOP card?</p>
","<p>Since you indicate that your call to <code>KeyBuilder.buildKey(...)</code> fails, I would assume that this call throws a <code>CryptoException</code> with reason code <code>NO_SUCH_ALGORITHM</code>. As you do not handle that exception in your code, this results in the status word <code>0x6F00</code> being retuned by the card (<code>0x6F00</code> is typically returned in case of unhandled exceptions).</p>

<p>So the <code>CryptoException</code> indicates that the requested key algorithm is not supported. Since you use the following parameters</p>

<pre><code>KeyBuilder.buildKey(
    KeyBuilder.TYPE_EC_FP_PRIVATE,  // key type
    KeyBuilder.LENGTH_EC_FP_192,    // key length
    true);                          // key encryption
</code></pre>

<p>this could mean that</p>

<ul>
<li>the card does not support the EC_FP (elliptic curve over large prime field) key type / algorithm,</li>
<li>the card does not support a key length of 192, or</li>
<li>the card does not support key encryption.</li>
</ul>

<p>As the FIPS 140-2 Cryptographic Module Security Policy for both <a href=""http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp1953.pdf"" rel=""nofollow"">JCOP 2.4.2 R2</a> and <a href=""http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp2247.pdf"" rel=""nofollow"">JCOP 2.4.2 R3</a> indicate that ECDSA key pair generation is supported for P-192 (besides P-224 and P-256), I would assume that your card does not support key encryption. Hence, you could instead try</p>

<pre><code>KeyBuilder.buildKey(
    KeyBuilder.TYPE_EC_FP_PRIVATE,  // key type
    KeyBuilder.LENGTH_EC_FP_192,    // key length
    false);                         // key encryption
</code></pre>
","694","<smartcard><javacard><apdu><ecdsa><jcop>","2","1","3","2016-02-24 09:27:11","","3","","2425802","","2016-01-28 18:58:05","2016-01-12 11:00:54",""
"34741881","ECDSA algorithm on JCOP 2.4.2 Java Card","<p>I want to implement ECDSA algorithm on Java Card (JCOP 2.4.2). This is my source code:</p>

<pre><code>package hashPack;

import javacard.framework.*;
import javacard.security.*;
import javacardx.crypto.*;

public class MyECDSA extends Applet{

    private byte[] PLAINTEXT ;

    private ECPrivateKey            objECDSAPriKey=null;    // Object for ECDSA Private Key
    private ECPublicKey             objECDSAPubKey=null;    // Object for ECDSA Public Key
    private KeyPair                 objECDSAKeyPair=null;   // Object for ECDSA Key Pair
    private Signature               objECDSASign=null;      // Object for ECDSA Signature

    final static short  BAS     =  0;

    final static byte[] SecP192r1_P = {     // 24
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static byte[] SecP192r1_A = {     // 24
        (byte)0xFC,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFE,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
        (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static byte[] SecP192r1_B = {     // 24
      (byte)0xB1,(byte)0xB9,(byte)0x46,(byte)0xC1,(byte)0xEC,(byte)0xDE,(byte)0xB8,(byte)0xFE,
      (byte)0x49,(byte)0x30,(byte)0x24,(byte)0x72,(byte)0xAB,(byte)0xE9,(byte)0xA7,(byte)0x0F,
      (byte)0xE7,(byte)0x80,(byte)0x9C,(byte)0xE5,(byte)0x19,(byte)0x05,(byte)0x21,(byte)0x64};
    final static byte[] SecP192r1_S = {     // 20
      (byte)0xD5,(byte)0x96,(byte)0x21,(byte)0xE1,(byte)0xEA,(byte)0x20,(byte)0x81,(byte)0xD3,
      (byte)0x28,(byte)0x95,(byte)0x57,(byte)0xED,(byte)0x64,(byte)0x2F,(byte)0x42,(byte)0xC8,
      (byte)0x6F,(byte)0xAE,(byte)0x45,(byte)0x30};
    final static byte[] SecP192r1_G = {     // 25
      (byte)0x12,(byte)0x10,(byte)0xFF,(byte)0x82,(byte)0xFD,(byte)0x0A,(byte)0xFF,(byte)0xF4,
      (byte)0x00,(byte)0x88,(byte)0xA1,(byte)0x43,(byte)0xEB,(byte)0x20,(byte)0xBF,(byte)0x7C,
      (byte)0xF6,(byte)0x90,(byte)0x30,(byte)0xB0,(byte)0x0E,(byte)0xA8,(byte)0x8D,(byte)0x18,(byte)0x03};
    final static byte[] SecP192r1_N = {     // 24
      (byte)0x31,(byte)0x28,(byte)0xD2,(byte)0xB4,(byte)0xB1,(byte)0xC9,(byte)0x6B,(byte)0x14,
      (byte)0x36,(byte)0xF8,(byte)0xDE,(byte)0x99,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,
      (byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF};
    final static short  SecP192r1_H =  1;

    //======================================================================================
    public static void install(byte[] bArray, short bOffset, byte bLength){
        new MyECDSA(bArray, bOffset, bLength);
    }

    private MyECDSA(byte bArray[], short bOffset, byte bLength){    

        PLAINTEXT       = new byte[0x100] ;         // Data file

        Util.arrayFillNonAtomic(PLAINTEXT,  BAS, (short)0x100, (byte)0);

        register();
    }

    //======================================================================================
    public void process(APDU apdu){
        byte buf[] = apdu.getBuffer();

        switch(buf[1])
        {
            //--------------------------------------------------------
            case (byte)0xA4:                    break;  

            case (byte)0x46:

                // Create ECDSA Keys and Pair
             /*   try {
            // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Here is the problem &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                    objECDSAPriKey = (ECPrivateKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PRIVATE,      KeyBuilder.LENGTH_EC_FP_192, true);
                }
            catch(CryptoException c)
            {    
              short reason = c.getReason();   
              ISOException.throwIt(reason);       // for check
            }     // for check*/
                   // objECDSAPubKey = (ECPublicKey)KeyBuilder.buildKey(KeyBuilder.TYPE_EC_FP_PUBLIC,      KeyBuilder.LENGTH_EC_FP_192, true);

                    // set EC Domain Parameters
                    objECDSAPubKey.setFieldFP(SecP192r1_P, BAS, (short)24);
                    objECDSAPubKey.setA(SecP192r1_A, BAS, (short)24);
                    objECDSAPubKey.setB(SecP192r1_B, BAS, (short)24);
                    objECDSAPubKey.setG(SecP192r1_G, BAS, (short)25);
                    objECDSAPubKey.setK(SecP192r1_H);
                    objECDSAPubKey.setR(SecP192r1_N, BAS, (short)24);

                    objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);


                // On-Card Key Generation Process
                objECDSAKeyPair.genKeyPair();

                // Obtain Key References
                objECDSAPriKey = (ECPrivateKey)objECDSAKeyPair.getPrivate();
                objECDSAPubKey = (ECPublicKey)objECDSAKeyPair.getPublic();  

                // Create Signature Object
                objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);

            break;

            case (byte)0x2E:                        
                short       Le              = apdu.setOutgoing();   
                short   sSignLen=0 ;

                // Init with Private Key
                objECDSASign.init(objECDSAPriKey, Signature.MODE_SIGN);

                // Sign Data
                sSignLen = objECDSASign.sign(PLAINTEXT, BAS, Le, buf, BAS);

                apdu.setOutgoingLength(sSignLen);
                apdu.sendBytes(BAS, sSignLen);

            break;      
            //--------------------------------------------------------
            default:
                ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
        }

        return; 
    }
}
</code></pre>

<p>I am running this source code using this script script code:</p>

<pre><code>#/term SCComm:2
/mode trace=on
/atr
/card
/select |ecdsa
/send 00A4040007D4106509900090
/send 0046000000
/send 002E00000A30313233343031323334
</code></pre>

<p>When I am calling <code>/send 0046000000</code> for signing the plain text message I get the response code <code>6F00</code>.</p>

<p>Could you help me to find out what is wrong with this?</p>

<p>How to properly implement this algorithm on a JCOP card?</p>
","<p>I can see two different issues:</p>

<ul>
<li>JCOP (mistakenly) requires you to set the private key parameters as well;</li>
<li>base point G seems to be in compressed format, which may not be supported, it is required to convert to a 49 byte uncompressed point instead.</li>
</ul>

<p>Furthermore it should be noted that:</p>

<ul>
<li>you should indeed first build the public key using <code>KeyBuilder</code> (currently commented out);</li>
<li>there is no reason to have a parameter S in there (the seed is of no consequence - at least I presume it's not a private key with that size);</li>
<li>you should really wrap key generation with a try / catch statement and (in the end) convert to an <code>ISOException</code> with a valid status word;</li>
<li>having a debugger available is of vital importance.</li>
</ul>
","694","<smartcard><javacard><apdu><ecdsa><jcop>","2","1","3","2016-02-24 09:27:11","","3","","2425802","","2016-01-28 18:58:05","2016-01-12 11:00:54",""
"40880873","ECIES encryption/decryption Java","<p>I am trying to use ECIES for encryption and decryption. This is what I have done:</p>

<ol>
<li>generated ECC key pair</li>
<li>generated CSR</li>
<li>Generated X509 certificate, signed by intermediate CA</li>
<li><p>Server side, I need to use this certificate to encrypt data. So I have extracted <code>PublicKey</code> (which is showing <code>BCECPublicKey</code> format) from certificate.</p>

<p>I couldn't find a way to convert it into <code>ECPublicKey</code> format so after upgrading to bouncycastle 1.55, I am able to use directly <code>BCECPublicKey</code> for encryption.</p></li>
<li><p>Converted private key into <code>ECPrivateKey</code> and using it for decryption but now it's throwing <code>BadPaddingException: Invalid MAC during decryption</code></p></li>
</ol>

<p>I am new to cryptography, Please help to resolve this. Below is code I am using:</p>

<pre><code>byte[] localcert = Base64.decode(
            ""MIID5TCCAc2gAwIBAgICEAEwDQYJKoZIhvcNAQELBQAwMzELMAkGA1UEBhMCc2cx"" +
                    ""CzAJBgNVBAgMAnNnMRcwFQYDVQQKDA5pbnRlcm1lZGlhdGVDQTAeFw0xNjExMjgw"" +
                    ""NDAzMjdaFw0xNzEyMDgwNDAzMjdaMDsxCzAJBgNVBAYTAnNnMQswCQYDVQQIEwJz"" +
                    ""ZzELMAkGA1UEBxMCc2cxEjAQBgNVBAoTCWxvY2FsaG9zdDBZMBMGByqGSM49AgEG"" +
                    ""CCqGSM49AwEHA0IABDuhAyMw6OilNmfWo1v6b8XwU8xbQm0Sy/I9qpdC4+qDToSl"" +
                    ""EOe+vw7GiVgONTJz2gwMW+VgoGp49aM5GTPo39ujgcUwgcIwCQYDVR0TBAIwADAR"" +
                    ""BglghkgBhvhCAQEEBAMCBaAwMwYJYIZIAYb4QgENBCYWJE9wZW5TU0wgR2VuZXJh"" +
                    ""dGVkIENsaWVudCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnbUGm/qaO1JbhY+qVlXw"" +
                    ""BewUI/swHwYDVR0jBBgwFoAUPSzKlcBTp0pCQ290SlDLmIQS+/0wDgYDVR0PAQH/"" +
                    ""BAQDAgXgMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDBDANBgkqhkiG9w0B"" +
                    ""AQsFAAOCAgEAJj0J2A3AAcrRw02ZzQsEC4nTyd05krF4oRFo0JODlzNiKaOhQt76"" +
                    ""Va427cpVUZwmjb/f1We+AjLJgQiEfnuD7JPSvXHLQTbXNDMgpZ9HXHZoXYfH+2h7"" +
                    ""MGvw6Qkj4lC10q9UC14rDSD/ZsR1J0mQCQuOIBRFNOkSPiSUu4zouCD3xv5uZVXR"" +
                    ""mimhJ1zgqSYF4LHegJAVwrowMsuaeQXybrIQ+/LJ8HXf8McvPZwtQTuoN/q5zHXz"" +
                    ""l+7q4nglyVY+TXPAdwyha0Yq2p0z0jdWm5UpEehmIpXtJghNtcCCRfb48flfZ/B7"" +
                    ""JW9VrlcjScOtQfSOrElYgwJ8MlUTzz7oWgbbVp9uNQZeAQQPeOQYLAvSNchPnLiP"" +
                    ""ftPuICW2siDeFC42lwYsDYR/9sYs7/gzL79i7bHrdMJ07brXw30hb1r6Vu9a+sHF"" +
                    ""D087NxHv33u22+W/2PMLDE89MynTC3H3gWvyzGIky0/kYSpZO/xZuFrg0jIJu0lH"" +
                    ""9b7jw1hQM1nDkTO5Gn2wJuaHaiZ22tMr47e4Xlkctal4hAA4Ya1uBXuMuwy0BC8q"" +
                    ""nLLxCLBcJJPAyIG2LvIT2vdWIP0Gz84mHKDbOPekHmXIF3bHE4pPeyDIJ+w00UoM"" +
                    ""xJdedT5BJarqEpiQtrGn4FBh3fsnHFXyNnNMCIylCvbg0Ij/AsQJCpg="");

    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    X509Certificate x509Certificate= (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(localcert));
    PublicKey publicKey=x509Certificate.getPublicKey();

    byte[] pkey=Base64.decode(""MHcCAQEEINmVG7z3YutAqRYZ5iAaJSXcP+GJWjtmSx3ba6RfKkJQoAoGCCqGSM49"" +
            ""AwEHoUQDQgAEO6EDIzDo6KU2Z9ajW/pvxfBTzFtCbRLL8j2ql0Lj6oNOhKUQ576/"" +
            ""DsaJWA41MnPaDAxb5WCganj1ozkZM+jf2w=="");
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
    KeyFactory kf = KeyFactory.getInstance(""ECDSA"", new BouncyCastleProvider());
    ECPrivateKeySpec ecPrivateKeySpec = new ECPrivateKeySpec(new BigInteger(1, pkey), spec);
    ECPrivateKey privkey= (ECPrivateKey) kf.generatePrivate(ecPrivateKeySpec);

    String name = ""prime256v1"";

    //  generate derivation and encoding vectors
    byte[]  d = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
    byte[]  e = new byte[] { 8, 7, 6, 5, 4, 3, 2, 1 };
    IESParameterSpec param = new IESParameterSpec(d, e, 256);

    Cipher iesCipher = Cipher.getInstance(""ECIES"", BouncyCastleProvider.PROVIDER_NAME);
    //Encrypt
    iesCipher.init(Cipher.ENCRYPT_MODE, publicKey, param);
    byte[] enc= iesCipher.doFinal(""TestECIES"".getBytes());
    System.out.println(new String(enc));
    //Decrypt
    iesCipher.init(Cipher.DECRYPT_MODE, privkey, param);
    byte[] decry=iesCipher.doFinal(enc);
    System.out.println(new String(decry));
</code></pre>
","<p>So finally I have solved it. ECC PrivateKey created by openssl was in this format:</p>

<pre><code>-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEINmVG7z3YutAqRYZ5iAaJSXcP+GJWjtmSx3ba6RfKkJQoAoGCCqGSM49
AwEHoUQDQgAEO6EDIzDo6KU2Z9ajW/pvxfBTzFtCbRLL8j2ql0Lj6oNOhKUQ576/
DsaJWA41MnPaDAxb5WCganj1ozkZM+jf2w==
-----END EC PRIVATE KEY-----
</code></pre>

<p>So I converted it into PKCS8 formate using command:</p>

<pre><code>openssl pkcs8 -topk8 -nocrypt -in localhost.pem -out localhostpkcs8.pem
</code></pre>

<p>and loaded in Java using below code:</p>

<pre><code>    Security.addProvider(new BouncyCastleProvider());
    KeyFactory kf = KeyFactory.getInstance(""EC"",""BC"");
    PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(Base64.decode(localhostpkcs8.getBytes()));
    PrivateKey privateKey=kf.generatePrivate(privateKeySpec);
</code></pre>

<p>Everything worked perfectly.</p>
","690","<java><x509certificate><bouncycastle><ecdsa><ecies>","0","0","1","2016-12-02 10:01:34","40929404","0","3","7208029","","2016-11-30 06:16:06","2016-11-30 05:21:32",""
"49825455","ECDSA signature Java vs Go","<p>I am trying to learn some Go and blockchains.. Starting with ECDSA signatures. Trying to figure out how to test if I had a correctly working Go implementation of ECDSA signatures, I figured I would try to create a similar version in Java and compare the results to see if I can get them to match.</p>

<p>So Java attempt:</p>

<pre><code>public static void main(String[] args) throws Exception {
    //the keys below are previously generated with ""generateKey();"" and base64 encoded
    generateKey();
    String privStr = ""MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCAQ7bMVIcWr9NpSD3hPkns5C0qET87UvyY5WI6UML2p0Q=="";
    String pubStr = ""MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAES8VdACZT/9u1NmaiQk0KIjEXxiaxms74nu/ps6bP0OvYMIlTdIWWU2s35LEKsNJH9u5QM2ocX53BPjwbsENXJw=="";
    PrivateKey privateKey = base64ToPrivateKey(privStr);
    PublicKey publicKey = base64ToPublicKey(pubStr);
    String str = ""This is string to sign"";
    byte[] signature = signMsg(str, privateKey);
    boolean ok = verifySignature(publicKey, str, signature);
    System.out.println(""signature ok:"" + ok);
    String privHex = getPrivateKeyAsHex(privateKey);
}

public static byte[] signMsg(String msg, PrivateKey priv) throws Exception {
    Signature ecdsa = Signature.getInstance(""SHA1withECDSA"");

    ecdsa.initSign(priv);

    byte[] strByte = msg.getBytes(""UTF-8"");
    ecdsa.update(strByte);

    byte[] realSig = ecdsa.sign();
    //the printed signature from here is what is used in the Go version (hex string)
    System.out.println(""Signature: "" + new BigInteger(1, realSig).toString(16));
    return realSig;
}

//https://stackoverflow.com/questions/30175149/error-when-verifying-ecdsa-signature-in-java-with-bouncycastle

private static boolean verifySignature(PublicKey pubKey, String msg, byte[] signature) throws Exception {
    byte[] message = msg.getBytes(""UTF-8"");
    Signature ecdsa = Signature.getInstance(""SHA1withECDSA"");
    ecdsa.initVerify(pubKey);
    ecdsa.update(message);
    return ecdsa.verify(signature);
}

public static String generateKey() throws Exception {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"");

    keyGen.initialize(256, random); //256 bit key size

    KeyPair pair = keyGen.generateKeyPair();
    PrivateKey priv = pair.getPrivate();
    ECPrivateKey ePriv = (ECPrivateKey) priv;
    PublicKey pub = pair.getPublic();

    //https://stackoverflow.com/questions/5355466/converting-secret-key-into-a-string-and-vice-versa
    String encodedPrivateKey = Base64.getEncoder().encodeToString(priv.getEncoded());
    byte[] pubEncoded = pub.getEncoded();
    String encodedPublicKey = Base64.getEncoder().encodeToString(pubEncoded);
    System.out.println(encodedPrivateKey);
    System.out.println(encodedPublicKey);
    return encodedPrivateKey;
}

public static PrivateKey base64ToPrivateKey(String encodedKey) throws Exception {
    byte[] decodedKey = Base64.getDecoder().decode(encodedKey);
    return bytesToPrivateKey(decodedKey);
}

public static PrivateKey bytesToPrivateKey(byte[] pkcs8key) throws GeneralSecurityException {
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(pkcs8key);
    KeyFactory factory = KeyFactory.getInstance(""EC"");
    PrivateKey privateKey = factory.generatePrivate(spec);
    return privateKey;
}

public static PublicKey base64ToPublicKey(String encodedKey) throws Exception {
    byte[] decodedKey = Base64.getDecoder().decode(encodedKey);
    return bytesToPublicKey(decodedKey);
}

public static PublicKey bytesToPublicKey(byte[] x509key) throws GeneralSecurityException {
    X509EncodedKeySpec spec = new X509EncodedKeySpec(x509key);
    KeyFactory factory = KeyFactory.getInstance(""EC"");
    PublicKey publicKey = factory.generatePublic(spec);
    return publicKey;
}

//https://stackoverflow.com/questions/40552688/generating-a-ecdsa-private-key-in-bouncy-castle-returns-a-public-key
private static String getPrivateKeyAsHex(PrivateKey privateKey) {
    ECPrivateKey ecPrivateKey = (ECPrivateKey) privateKey;
    byte[] privateKeyBytes = ecPrivateKey.getS().toByteArray();
    System.out.println(""S:""+ecPrivateKey.getS());

    String hex = bytesToHex(privateKeyBytes);

    System.out.println(""Private key bytes: "" + Arrays.toString(privateKeyBytes));
    System.out.println(""Private key hex: "" + hex);

    return hex;
}

private final static char[] hexArray = ""0123456789ABCDEF"".toCharArray();

public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0 ; j &lt; bytes.length ; j++) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}
</code></pre>

<p>Doing the signing and verification in Java works just fine. Easy to configure of course, since they are all the same libs, parameters, and all.</p>

<p>To verify the same signature in Go, I tried:</p>

<pre><code>func TestSigning(t *testing.T) {
    privKey := hexToPrivateKey(""10EDB31521C5ABF4DA520F784F927B390B4A844FCED4BF2639588E9430BDA9D1"")
    pubKey := privKey.Public()
    sig := ""3045022071f06054f450f808aa53294d34f76afd288a23749628cc58add828e8b8f2b742022100f82dcb51cc63b29f4f8b0b838c6546be228ba11a7c23dc102c6d9dcba11a8ff2""
    sigHex, _ := hex.DecodeString(sig)
    ePubKey := pubKey.(*ecdsa.PublicKey)
    ok := verifyMySig(ePubKey, ""This is string to sign"", sigHex)
    println(ok)
}

func verifyMySig(pub *ecdsa.PublicKey, msg string, sig []byte) bool {
    r := new(big.Int).SetBytes(sig[:len(sig)/2])
    s := new(big.Int).SetBytes(sig[len(sig)/2:])
    return ecdsa.Verify(pub, []byte(msg), r, s)
}

func hexToPrivateKey(hexStr string)  *ecdsa.PrivateKey {
    bytes, _ := hex.DecodeString(hexStr)

    k := new(big.Int)
    k.SetBytes(bytes)
    println(""k:"")
    fmt.Println(k.String())

    priv := new(ecdsa.PrivateKey)
    curve := elliptic.P256()
    priv.PublicKey.Curve = curve
    priv.D = k
    priv.PublicKey.X, priv.PublicKey.Y = curve.ScalarBaseMult(k.Bytes())

    return priv
}
</code></pre>

<p>Initially, I tried to just export the Private key in Java as a base64 encoded string, and import that into Go. But I could not figure out how to get Go to load the key in the format Java stores if (X509EncodedKeySpec). So instead, I tried this way to copy the big integer of the private key only, and generate the public key from that. If I get that to work, then try to copy just the public key..</p>

<p>Anyway, the Go code fails to verify the signature. It is always false. Also, I cannot figure out where to put the SHA function in Go from ""SHA1withECDSA"" part.</p>

<p>I am sure I am missing some basic concepts here. How to do this properly?</p>
","<p>Managed to get this to work. So just to document it for myself and anyone interested..</p>

<p>As pointed by in comments, the signature from Java is in ASN1 format. Found a nice description of the format here: <a href=""https://crypto.stackexchange.com/questions/1795/how-can-i-convert-a-der-ecdsa-signature-to-asn-1"">https://crypto.stackexchange.com/questions/1795/how-can-i-convert-a-der-ecdsa-signature-to-asn-1</a>.</p>

<p>I also found some good examples on how to do SHAxx with ECDSA in Go at <a href=""https://github.com/gtank/cryptopasta"" rel=""nofollow noreferrer"">https://github.com/gtank/cryptopasta</a> (sign.go and sign_test.go). Just need to run the relevant SHA function before the ECDSA code.</p>

<p>Found example code for building the public keys from parameters in Go at <a href=""http://codrspace.com/supcik/golang-jwt-ecdsa/"" rel=""nofollow noreferrer"">http://codrspace.com/supcik/golang-jwt-ecdsa/</a>.</p>

<p>I paste the relevant code below, if someone finds an issue, please let me know..</p>

<p>Relevant Java code:</p>

<pre><code>public static PublicKey bytesToPublicKey(byte[] x509key) throws GeneralSecurityException {
    X509EncodedKeySpec spec = new X509EncodedKeySpec(x509key);
    KeyFactory factory = KeyFactory.getInstance(""EC"");
    ECPublicKey publicKey = (ECPublicKey) factory.generatePublic(spec);
    //We should be able to use these X and Y in Go to build the public key
    BigInteger x = publicKey.getW().getAffineX();
    BigInteger y = publicKey.getW().getAffineY();
    System.out.println(publicKey.toString());
    return publicKey;
}

//we can either use the Java standard signature ANS1 format output, or just take the R and S parameters from it, and pass those to Go
//https://stackoverflow.com/questions/48783809/ecdsa-sign-with-bouncycastle-and-verify-with-crypto
public static BigInteger extractR(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startR + 2, startR + 2 + lengthR));
}

public static BigInteger extractS(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    int startS = startR + 2 + lengthR;
    int lengthS = signature[startS + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startS + 2, startS + 2 + lengthS));
}

public static byte[] signMsg(String msg, PrivateKey priv) throws Exception {
    Signature ecdsa = Signature.getInstance(""SHA1withECDSA"");

    ecdsa.initSign(priv);

    byte[] strByte = msg.getBytes(""UTF-8"");
    ecdsa.update(strByte);

    byte[] realSig = ecdsa.sign();

    //this is the R and S we could also pass as the signature
    System.out.println(""R: ""+extractR(realSig));
    System.out.println(""S: ""+extractS(realSig));

    return realSig;
}
</code></pre>

<p>Relevant Go code:</p>

<pre><code>func verifyMySig(pub *ecdsa.PublicKey, msg string, sig []byte) bool {
    //https://github.com/gtank/cryptopasta
    digest := sha1.Sum([]byte(msg))

    var esig ecdsaSignature
    asn1.Unmarshal(sig, &amp;esig)
    //above is ASN1 decoding from the Java format. Alternatively, we can just transfer R and S parameters and set those
    //  esig.R.SetString(""89498588918986623250776516710529930937349633484023489594523498325650057801271"", 0)
    //  esig.S.SetString(""67852785826834317523806560409094108489491289922250506276160316152060290646810"", 0)
    fmt.Printf(""R: %d , S: %d"", esig.R, esig.S)
    println()
    return ecdsa.Verify(pub, digest[:], esig.R, esig.S)
}

func hexToPrivateKey(hexStr string)  *ecdsa.PrivateKey {
    bytes, err := hex.DecodeString(hexStr)
    print(err)

    k := new(big.Int)
    k.SetBytes(bytes)
    println(""k:"")
    fmt.Println(k.String())

    priv := new(ecdsa.PrivateKey)
    curve := elliptic.P256()
    priv.PublicKey.Curve = curve
    priv.D = k
    priv.PublicKey.X, priv.PublicKey.Y = curve.ScalarBaseMult(k.Bytes())
    //we can check these against the Java implementation to see if it matches to know key was transferred OK
    fmt.Printf(""X: %d, Y: %d"", priv.PublicKey.X, priv.PublicKey.Y)
    println()

    return priv
}
</code></pre>
","683","<java><go><ecdsa>","2","2","1","2018-04-14 12:47:13","","2","1","","","","2018-04-13 21:37:10",""
"36452829","OpenSSL ECDSA signature validity","<p>From <a href=""https://www.openssl.org/docs/manmaster/crypto/ecdsa.html"" rel=""nofollow"">OpenSSL documentation</a></p>

<p>Creating an ECDSA signature of a given SHA-256 hash value using the named curve prime256v1 (aka P-256).</p>

<p>Second step: compute the ECDSA signature of a SHA-256 hash value using ECDSA_do_sign():</p>

<pre><code>sig = ECDSA_do_sign(digest, 32, eckey);
if (sig == NULL) {
   /* error */
}
</code></pre>

<p>or using ECDSA_sign():</p>

<pre><code>unsigned char *buffer, *pp;
int            buf_len;
buf_len = ECDSA_size(eckey);
buffer  = OPENSSL_malloc(buf_len);
pp = buffer;
if (ECDSA_sign(0, dgst, dgstlen, pp, &amp;buf_len, eckey) == 0) {
   /* error */
}
</code></pre>

<p>Third step: verify the created ECDSA signature using ECDSA_do_verify():</p>

<pre><code>ret = ECDSA_do_verify(digest, 32, sig, eckey);
</code></pre>

<p>or using ECDSA_verify():</p>

<pre><code>ret = ECDSA_verify(0, digest, 32, buffer, buf_len, eckey);
</code></pre>

<p>and finally evaluate the return value:</p>

<pre><code>if (ret == 1) {
   /* signature ok */
} else if (ret == 0) {
   /* incorrect signature */
} else {
   /* error */
}
</code></pre>

<p>EOF</p>

<p>This brings me to an understanding that I need to verify every signature I create with <code>ECDSA_do_sign</code> or <code>ECDSA_sign</code>, do I? Can it happen that a created signature is not valid?</p>
","<p>From <a href=""http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf"" rel=""nofollow"">NIST PUB 186-4 - Digital Signature Standard</a> section 4.7:</p>

<blockquote>
  <p>Signature verification may be performed by any party (i.e., the signatory, the intended recipient or any other party) using the signatorys public key. A signatory may wish to verify that the computed signature is correct, perhaps before sending the signed message to the intended recipient. The intended recipient (or any other party) verifies the signature to determine its
  authenticity.</p>
</blockquote>

<p>(where the signatory is the signature creator)</p>
","660","<c><openssl><ecdsa>","0","0","1","2016-08-15 06:43:44","","1","","","","","2016-04-06 13:37:27",""
"47110770","Set ECDSA on Apache and get SSL_ERROR_NO_CYPHER_OVERLAP","<p>thats my first post. </p>

<p>I will set up an Apache with ECDSA.
I generates this keys
secp256k1 : SECG curve over a 256 bit prime field
secp384r1 : NIST/SECG curve over a 384 bit prime field
and generate a self-signed certificate.</p>

<pre><code>openssl ecparam -name secp256k1 -genkey -param_enc explicit -out rootCA.key
openssl req -x509 -new -nodes -key server.key -sha256 -days 1024 -out rootCA.pem
</code></pre>

<p>At the ssl.conf I set</p>

<pre><code>SSLCipherSuite ECDHE-ECDSA-AES128-SHA256:ECDHE-ECDSA-AES256-SHA384
</code></pre>

<p>Wireshark shows me that the client supports the cipher and i looked at firefox config</p>

<p>The same cipher but with RSA cert works without problems. 
I showed enough Tutorials but i cant find the problem.
www.ssllabs.com/ssltest/ this test fails also with ""Assessment failed: Failed to communicate with the secure server"" </p>

<p>Have someone ideas what I can do? </p>
","<p>You cannot use ECDSA ciphers if you don't present an ECDSA certificate.</p>

<pre><code>openssl ecparam -name secp256k1 -genkey -param_enc explicit -out rootCA.key
</code></pre>

<p>Great this should have created an ECDSA private key. Now you need to make it into a certificate (possibly a self-signed certificate).</p>

<p>But in your following commands, you never use <code>rootCA.key</code> to make a certificate. Most probably you have generated an RSA certificate not ECDSA. Try to use <code>-key rootCA.key</code> in your <code>openssl req</code> command.</p>
","644","<apache><ssl><encryption><ecdsa>","1","0","1","2017-11-04 16:43:02","","0","","","","","2017-11-04 12:33:26",""
"38702169","C# ECDsaCng.SignData use signature in OpenSSL?","<p>I need to know what encoding</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/bb347054(v=vs.110).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/bb347054(v=vs.110).aspx</a></p>

<pre><code>ECDsaCng.SignData Method (Byte[])
</code></pre>

<p>is using for it's byte array by default and how to convert it to a DER format accepted by</p>

<p><a href=""https://www.openssl.org/docs/manmaster/crypto/i2d_ECDSA_SIG.html"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/manmaster/crypto/i2d_ECDSA_SIG.html</a></p>

<p>so that I can verify my C# generated ECDSA signature in OpenSSL using the method <code>ECDSA_do_verify</code>.</p>

<p>I know its SHA1 and I know how to load that digest, I just don't know what the byte encoding is for the <code>ECDsaCng.SignData</code> method, nor how to convert it to DER format, if I even need to do that.</p>
","<p>An ECDSA signature is the value-pair <code>(r, s)</code>.</p>

<p>Windows CNG emits this as a concatenation of the two values, and since .NET does not reinterpret the data, this is the de facto .NET format. (<code>r</code> is the first half of the array, <code>s</code> is the second half)</p>

<p>OpenSSL expects a DER encoded structure of SEQUENCE(INTEGER(r), INTEGER(s)).  This loosely means <code>{ 0x30, payload_length, 0x02, r_length, r_bytes[0]...r_bytes[r_length-1], 0x02, s_length, s_bytes[0]...s_bytes[s_length-1] }</code>; though it's slightly trickier than that because padding bytes are required when r_bytes[0] or s_bytes[0] >= 0x80 (since that makes it appear as a negative number).</p>

<p>Unfortunately, there's not a general purpose DER encoder exposed in the framework by default.</p>

<p>If you're trying to run on Linux, you might be better served by using .NET Core, since the ECDSA implementation for Linux <a href=""https://github.com/dotnet/corefx/blob/release/1.0.0/src/Common/src/System/Security/Cryptography/ECDsaOpenSsl.cs#L184-L198"" rel=""nofollow"">already does</a> this data translation.</p>
","643","<c#><c++><openssl><signing><ecdsa>","0","1","2","2019-02-27 08:23:33","38703188","4","","160074","","2019-02-07 11:59:38","2016-08-01 15:03:10",""
"38702169","C# ECDsaCng.SignData use signature in OpenSSL?","<p>I need to know what encoding</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/bb347054(v=vs.110).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/bb347054(v=vs.110).aspx</a></p>

<pre><code>ECDsaCng.SignData Method (Byte[])
</code></pre>

<p>is using for it's byte array by default and how to convert it to a DER format accepted by</p>

<p><a href=""https://www.openssl.org/docs/manmaster/crypto/i2d_ECDSA_SIG.html"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/manmaster/crypto/i2d_ECDSA_SIG.html</a></p>

<p>so that I can verify my C# generated ECDSA signature in OpenSSL using the method <code>ECDSA_do_verify</code>.</p>

<p>I know its SHA1 and I know how to load that digest, I just don't know what the byte encoding is for the <code>ECDsaCng.SignData</code> method, nor how to convert it to DER format, if I even need to do that.</p>
","<p>Here's <a href=""https://github.com/tencentyun/tls-sig-api-cs/blob/master/tls-sig-api-cs/TLSSigAPI.cs"" rel=""nofollow noreferrer"">TLSSigAPI.cs</a> the code of generating sign with .Net and verifying with OpenSSL.</p>

<p>Maybe help you.</p>

<pre><code>byte[] rawDataHash = SHA256(rawData);
byte[] rawSig = ecdsa.SignHash(rawDataHash);
int halfLength = rawSig.Length / 2;
byte[][] rEncoded = SegmentedEncodeUnsignedInteger(rawSig, 0, halfLength);
byte[][] sEncoded = SegmentedEncodeUnsignedInteger(rawSig, halfLength, halfLength);
List&lt;byte[][]&gt; items = new List&lt;byte[][]&gt;() { rEncoded, sEncoded };
byte[] opensslSig = ConstructSequence(items);
</code></pre>
","643","<c#><c++><openssl><signing><ecdsa>","0","0","2","2019-02-27 08:23:33","38703188","4","","160074","","2019-02-07 11:59:38","2016-08-01 15:03:10",""
"39233560","Verify ECDSA signature from PyKCS11","<p>I have a python program which uses PyKCS11, a python wrapper for pkcs11 interface. I can sign data with a ECC private key (Mechanism CKM_ECDSA) that is stored on a HSM and that is accessed by PyKCS11.</p>

<p>What I now want is to verify with openssl the ECDSA signature by the corresponding public key. This public key is contained in a x509 (NewCert.pem) which was created out of the private key in the HSM.</p>

<p>I tested many ways to verify the signature properly, but I didn't succeed.</p>

<pre><code>openssl dgst -ecdsa-with-SHA1 -verify &lt;(openssl x509 -noout -pubkey -in NewCert.pem) -signature &lt;(cat sign | base64 -d) file
</code></pre>

<p>The file 'signature' contains the base64 encoded signature. And the file 'file' the plain data.</p>

<p>Thank you</p>
","<p>Finally I found a solution for my problem.</p>

<p>I)
The signature output of PyKCS11 is the concatenation of the r and s value of the ECDSA signature. It is not formatted in ASN1 style. This was the first problem why verification with openssl is not possible, because the latter requires this format.</p>

<p>II)
So I wrote a function that formats the PyKCS11 output to ASN1 conformity and saves the binary signature output to a file.</p>

<p>III)
In order to use hashing functions you first have to hash the data or the file to be signed. This can be done in Python with the command <em>digest()</em> of hashlib. After this you give this <strong>binary</strong> hash of the data as input to PyKCS11 and create the signature.</p>

<p>IV)
Verification of the hashed ECDSA signature can be done with the following command in openssl:</p>

<pre><code>openssl dgst -sha384 -verify pubkey -signature file.sign file
</code></pre>

<p>Make sure that <em>pubkey</em> is the EC public key from the corresponding x509 certificate (not the x509 itself). And <em>file.sign</em> means to be the binary file which contains the ECDSA signature that represents the binary hash of the original data (see step III).</p>

<p>Hope this helps for somebody else.</p>
","635","<pkcs#11><pyopenssl><ecdsa>","0","1","1","2016-09-06 14:32:22","39351631","1","1","608639","","2016-08-31 01:00:44","2016-08-30 17:22:43",""
"14198775","Why are these Botan public keys so similar?","<p>I am using Botan to create public/private ECDSA keypairs.  The public keys that are generated (even on different machines using this code) are very similar... too similar to consider safe I would think.  Here is an example of two runs:</p>

<pre><code>-----BEGIN PUBLIC KEY-----  
MIIBEzCB7AYHKoZIzj0CATCB4AIBATAsBgcqhkjOPQEBAiEA////////////////
/////////////////////v///C8wRAQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBEEEeb5m
fvncu6xVoGKVzocLBwKb/NstzijZWfKBWxb4F5hIOtp3JqPEZV2k+/wOEQio/Re0
SKaFVBmcR9CP+xDUuAIhAP////////////////////66rtzmr0igO7/SXozQNkFB
AgEBAyIAAneDBKm4ubKbv0hxgzhkh0oAI8WKFTs1Hz/Qqyl6qxzD  
-----END PUBLIC KEY-----

-----BEGIN PUBLIC KEY-----  
MIIBEzCB7AYHKoZIzj0CATCB4AIBATAsBgcqhkjOPQEBAiEA////////////////
/////////////////////v///C8wRAQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBEEEeb5m
fvncu6xVoGKVzocLBwKb/NstzijZWfKBWxb4F5hIOtp3JqPEZV2k+/wOEQio/Re0
SKaFVBmcR9CP+xDUuAIhAP////////////////////66rtzmr0igO7/SXozQNkFB
AgEBAyIAAtQr5BPT04pk/Ror6uIGRqEKeB8dwIteR8p/r+Nl7hql  
-----END PUBLIC KEY-----
</code></pre>

<p>I am using X509 encoding to encode the public key.  Here's the code to generate the ECDSA keys:</p>

<pre><code>LibraryInitializer init;
AutoSeeded_RNG rng;
EC_Group ecGroup(""secp256k1"");
ECDSA_PrivateKey key(rng, ecGroup);
</code></pre>

<p>Why am I generating such similar public keys?  And am I right in assuming that isn't ""safe"" if multiple users were to use this code to generate their own keys?</p>

<hr>

<p>UPDATE:
The answer below seems correct. I emailed the creator of XCA, Christian Hohnstaedt, to probe a little further into how XCA generates this public key and what it is. He replied that it is the EC_POINT and is obtained by using the command </p>

<pre><code>openssl ec -pubin -noout -text
</code></pre>

<p>Plugging in the X509 PEM encoded public keys indeed reveals different public EC Points.  It should be noted (for other newbs like me) that the public EC Points in the answer do no good for another party on their own - the other party needs to know which EC Group is being used, and that's why the X509 PEM encoding is much more helpful than just an EC Point.</p>
","<p>The actual public keys from these are:</p>

<pre><code>02:77:83:04:A9:B8:B9:B2:9B:BF:48:71:83:38:64:87
4A:00:23:C5:8A:15:3B:35:1F:3F:D0:AB:29:7A:AB:1C
C3 
</code></pre>

<p>and</p>

<pre><code>02:D4:2B:E4:13:D3:D3:8A:64:FD:1A:2B:EA:E2:06:46
A1:0A:78:1F:1D:C0:8B:5E:47:CA:7F:AF:E3:65:EE:1A
A5
</code></pre>

<p>These are not the same, so there is no apparent reason to worry on that front. The data that is the same is the key meta-data and encoding bumf (which you would expect to be the same for identical format keys).</p>

<p>Values obtained by importing into xca (linux). There are better tools for inspecting DER encoded data, but I couldn't find any easily.</p>
","626","<security><public-key-encryption><x509><botan><ecdsa>","3","3","1","2013-01-09 21:33:21","14205433","4","","515412","","2013-01-09 21:33:21","2013-01-07 15:22:02",""
"43569748","whose performance is better digital signatures (ECDSA) or Hash based signatures in case of ad-hoc networks","<p>i want to know performance wise which is better to provide message authenticity, ECDSA signatures or hash based signatures, although i have read the comparisons of ECDSA with RSA, but not found with hash based signatures. Can ECDSA signatures replaced  with Hash based signatures improves the message authenticity or not. </p>
","<p>ECDSA <em>is</em> a hash based signature, in that the data gets hashed, then ECDSA is performed on the hash (not the whole data)</p>

<p>When it comes to data verification there are three main approaches:</p>

<ol>
<li><p>Straight hash (e.g. SHA-2-256)</p>

<ul>
<li>The fastest option to verify</li>
<li>If you are only protecting against line corruption this is a valid choice.</li>
<li>Otherwise, requires that the hash/digest value be sent over a secure (from tamper) channel, because the tampered can easily transmit the digest along with the tampered document</li>
<li>Provides no proof of origin</li>
</ul></li>
<li><p>HMAC (e.g. HMACSHA256)</p>

<ul>
<li>Requires that both the sender and receiver share the secret key</li>
<li>Either the sender or receiver having the key stolen puts both sides at risk</li>
<li>Secret key needs to come from key agreement algorithms (ECDH) or be transmitted in secret (encrypted)</li>
<li>Proves the document came from someone with the shared secret.</li>
</ul></li>
<li>Digital Signature (e.g. ECDSA, RSA signature)

<ul>
<li>The sender is the only entity with the private key, receiver needs public key (non-secret)</li>
<li>Public key can be embedded in an X.509 certificate to provide a notarized association of public key to the signer</li>
<li>Or the public key can be transmitted raw over a secure (from tamper) channel.</li>
<li>Provides strong assurances about the document origin, since they shouldn't share their private key.</li>
</ul></li>
</ol>

<p>All three options use a hash algorithm to reduce the original data, the rest of the algorithms are what do you do with that data. There's not really a standard definition of ""secure"", you have to say ""secure against (something)"". ECDSA provides more assurances than HMAC as long as the private key isn't shared. But if HMAC provides enough assurance it is probably faster on average (specialty hardware aside).</p>
","626","<hash><ecdsa>","0","1","1","2017-04-24 01:42:49","","0","","","","","2017-04-23 10:06:19",""
"30102116","How to convert ECDSA SIG signature to array of characters in C","<p>I'm a beginner to cryptography (openssl library) and I wanted help on how to send an ECDSA signature through a C socket communication. My plan is: </p>

<ol>
<li>make socket connection</li>
<li>convert ECDSA SIG object into string</li>
<li>send signature in the form of a string</li>
<li>At the destination, convert the string back to SIG object and verify signing</li>
</ol>

<p>Here is the code.</p>

<pre><code>static ECDSA_SIG* sig = NULL;
static EC_KEY    *eckey = NULL;

 int main(int argc, char *argv[])
{         
    unsigned char* msgDigest = ""6df19ccf6b89397c9a9906bfd0848f061352e9b5"";
    if(ECDSAsign()) 
        printf(""signed successfully\n"");
    else
        printf(""signing failed\n""); 

    ...
}

int ECDSAsign()
{
    int ret;

    eckey = EC_KEY_new_by_curve_name(NID_secp192k1);
    if (eckey == NULL)
    {
        printf("" error "");
        return 0;
    }

    if (!EC_KEY_generate_key(eckey))
    {
        printf("" error "");
        return 0;
    }

     unsigned char *buffer, *pp;
     int bufLen;
     bufLen = ECDSA_size(eckey);
     buffer = OPENSSL_malloc(bufLen);
     pp = buffer;
     unsigned char *dgst = ""5df19ccf6b89397c9a9906bfd0848f061352e9ba"";
     sig = ECDSA_do_sign(dgst, strlen(dgst), eckey);
     if (sig == NULL)
     {
        printf("" Signature NOT generated\n "");
        return 0;
     }

    return 1;
}
</code></pre>
","<blockquote>
  <p>How to convert ECDSA SIG signature to array of characters in C<br>
  ...</p>
</blockquote>

<p>The signature is already an array of bytes. That is what is returned from <code>EVP_DigestSignFinal</code>.</p>

<hr>

<p>In general, you want to use the <code>EVP_*</code> interfaces for signing and verification. Below is from the OpenSSL wiki on <a href=""https://wiki.openssl.org/index.php/EVP_Signing_and_Verifying"" rel=""nofollow"">EVP Signing and Verifying</a>.</p>

<p>Your job below is to get the ECDSA into the <code>EVP_PKEY*</code>. The function will allocate the signature buffer with <code>OPENSSL_malloc</code>. The caller needs to free it with <code>OPENSSL_free</code>. The buffer is an array of bytes.</p>

<pre><code>int sign_it(const byte* msg, size_t mlen, byte** sig, size_t* slen, EVP_PKEY* pkey)
{
    /* Returned to caller */
    int result = -1;

    if(!msg || !mlen || !sig || !pkey) {
        assert(0);
        return -1;
    }

    if(*sig)
        OPENSSL_free(*sig);

    *sig = NULL;
    *slen = 0;

    EVP_MD_CTX* ctx = NULL;

    do
    {
        ctx = EVP_MD_CTX_create();
        assert(ctx != NULL);
        if(ctx == NULL) {
            printf(""EVP_MD_CTX_create failed, error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        const EVP_MD* md = EVP_get_digestbyname(""SHA256"");
        assert(md != NULL);
        if(md == NULL) {
            printf(""EVP_get_digestbyname failed, error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        int rc = EVP_DigestInit_ex(ctx, md, NULL);
        assert(rc == 1);
        if(rc != 1) {
            printf(""EVP_DigestInit_ex failed, error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        rc = EVP_DigestSignInit(ctx, NULL, md, NULL, pkey);
        assert(rc == 1);
        if(rc != 1) {
            printf(""EVP_DigestSignInit failed, error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        rc = EVP_DigestSignUpdate(ctx, msg, mlen);
        assert(rc == 1);
        if(rc != 1) {
            printf(""EVP_DigestSignUpdate failed, error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        size_t req = 0;
        rc = EVP_DigestSignFinal(ctx, NULL, &amp;req);
        assert(rc == 1);
        if(rc != 1) {
            printf(""EVP_DigestSignFinal failed (1), error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        assert(req &gt; 0);
        if(!(req &gt; 0)) {
            printf(""EVP_DigestSignFinal failed (2), error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        *sig = OPENSSL_malloc(req);
        assert(*sig != NULL);
        if(*sig == NULL) {
            printf(""OPENSSL_malloc failed, error 0x%lx\n"", ERR_get_error());
            break; /* failed */
        }

        *slen = req;
        rc = EVP_DigestSignFinal(ctx, *sig, slen);
        assert(rc == 1);
        if(rc != 1) {
            printf(""EVP_DigestSignFinal failed (3), return code %d, error 0x%lx\n"", rc, ERR_get_error());
            break; /* failed */
        }

        assert(req == *slen);
        if(rc != 1) {
            printf(""EVP_DigestSignFinal failed, mismatched signature sizes %ld, %ld"", req, *slen);
            break; /* failed */
        }

        result = 0;

    } while(0);

    if(ctx) {
        EVP_MD_CTX_destroy(ctx);
        ctx = NULL;
    }

    /* Convert to 0/1 result */
    return !!result;
}
</code></pre>
","625","<c><sockets><openssl><sign><ecdsa>","1","0","1","2015-05-07 17:33:40","","0","","608639","","2015-05-07 17:20:21","2015-05-07 13:12:27",""
"34487145","Get list of supported cipher suites (to detect ECDSA support)","<p>I'm considering the possibility of using a content delivery network for my websites. Because I'm such a cheapskate, I am trying to reduce the cost of doing so.</p>

<p>There is a fantastic CDN that is extremely low cost, but only supports browsers and operating systems that support SNI and ECDSA key exchange. (Bonus points for those who guess which one it is!)</p>

<p>I am therefore thinking of using ngx_pagespeed to rewrite resources to the CDN for web browsers that support ECDSA key exchange, and either not use a CDN or use a more expensive (but compatible) CDN for those who don't.</p>

<p>Unfortunately, I could not find a way to have nginx detect ECDSA support of browsers. Here is what I have considered so far:</p>

<ul>
<li><strong>User-agent sniffing</strong> - this is generally a bad idea, and would not be able to detect those behind bad corporate proxies</li>
<li><strong>Use JavaScript to detect support and set a cookie</strong> - this would make the client download resources twice after the first pageview, and would not work if the user has JavaScript or cookies disabled.</li>
<li><strong>Serve a blank interstitial page containing detection JavaScript</strong> - this would again not work without JavaScript or cookies, and would be harmful to SEO. Additionally, this would be slow, and even slower if detection takes a long time behind some strange proxies.</li>
</ul>

<p>I see that it is possible for a server to read the cipher suites, such as in <a href=""https://www.ssllabs.com/ssltest/viewMyClient.html"" rel=""nofollow"">Qualys SSL Labs</a> or <a href=""https://freakattack.com/clienttest.html"" rel=""nofollow"">this FREAK attack testing tool</a>. How could I read the list of client supported cipher suites in nginx?</p>
","","624","<encryption><nginx><https><cdn><ecdsa>","0","","0","2015-12-28 02:53:48","","5","","","","","2015-12-28 02:53:48",""
"39221123","Using ECDSA private key in Java with BouncyCastle","<p>I'm trying to use ECDSA in Java with BouncyCastle library and the private key I get by reading the pkcs12 file in Java is different than what I see in the PEM file (which I got using openssl). I'm unsure if they should be the same but seems logical. Question is how do I get the same private key in Java using BC from a pkcs12 file as using openssl?</p>

<p>The cert and the key was generated with</p>

<pre><code>openssl ecparam -name secp521r1 -genkey -param_enc explicit -out private-key.pem
openssl req -new -x509 -key private-key.pem -out server.pem -days 730              
openssl pkcs12 -export -clcerts -in server.pem -inkey private-key.pem -out ecdsaCertificate.p12
</code></pre>

<p>Java code:</p>

<pre><code> Public static void readCertificateData()
      throws KeyStoreException, NoSuchProviderException, NoSuchAlgorithmException, CertificateException,
      FileNotFoundException, IOException, UnrecoverableKeyException {

System.out.println(""Get KeyStore"");
KeyStore pkcs12Store = KeyStore.getInstance(""pkcs12"", ""BC"");
System.out.println(""Read File"");
pkcs12Store.load(new FileInputStream(CERT), PASSWORD.toCharArray());

Enumeration aliasEnum = pkcs12Store.aliases();
Key key = null;
Certificate cert = null;

while (aliasEnum.hasMoreElements()) {

      String keyName = (String) aliasEnum.nextElement();
      key = pkcs12Store.getKey(keyName, PASSWORD.toCharArray());
      ECPrivateKey ecKey = (ECPrivateKey) key;

      System.out.println(""ecKey : \n"" + ecKey.toString());
      System.out.println(""privKeyToDER:\n"" + privateKeyToDER((PrivateKey) key));
      cert = pkcs12Store.getCertificate(keyName);
      System.out.println(""cert2 :\n"" + Base64.toBase64String((cert.getEncoded())));

      StringToFile(DIR + ""tempCert.pem"", ""-----BEGIN CERTIFICATE-----\n""
              + Base64.toBase64String((cert.getEncoded())) + ""-----END CERTIFICATE-----\n"");
      System.out.println(""privKey Base64 : "" + Base64.toBase64String(key.getEncoded()));
      cert = pkcs12Store.getCertificate(keyName);
}
}
public static String privateKeyToDER(PrivateKey key) throws IOException {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    JcaPEMWriter pemWriter = new JcaPEMWriter(new OutputStreamWriter(bos));

    pemWriter.writeObject(key);
    pemWriter.close();

    return new String(bos.toByteArray());
}
</code></pre>
","","617","<java><bouncycastle><ecdsa>","0","","0","2016-08-30 07:16:11","","2","","","","","2016-08-30 07:16:11",""
"48542233","Translating Elliptic Curve parameters (BC to MS)","<p>I'm trying to generate ECDSA self-signed certificate as described in <a href=""https://stackoverflow.com/questions/36624105/generate-certificate-using-ecdsa-in-c-sharp"">generate certificate using ECDSA</a>. Putting all pieces from bartonjs's answer together and using <code>Net.Framework 4.7</code> (or <code>Net.Core 2.0</code>) following code seems to be working although there are some ambiguities (at least one) left:</p>

<p>I'm not sure how to properly convert private key ('D' parameter) from <code>BC-BigInteger</code> to <code>MS-byte[]</code>. Using <code>BigInteger.ToByteArray()</code> throws exception:</p>

<blockquote>
  <p><strong>CryptographicException</strong>: The specified key parameters are not valid.
  Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If
  D is specified it must be the same length as Q.X and Q.Y for named
  curves or the same length as Order for explicit curves.</p>
</blockquote>

<p>while validating ECParameters (method <code>ECParameters.Validate()</code>). Using <code>BigInteger.ToByteArrayUnsigned()</code> provides much better results (one failure on several hundred generated key-pairs), but still...</p>

<p>When using <code>ToByteArray()</code> converted 'D' is usually one byte longer ('D' has 33 bytes vs D.X and D.Y has 32 bytes). Using <code>ToByteArrayUnsigned()</code> the 'D' is sometimes one byte shorter.</p>

<p>So my question is whether is is ok to use <code>ToByteArrayUnsigned()</code>.</p>

<pre><code>private const string NCryptExportPolicyProperty = ""Export Policy"";
private const string SignatureAlgorithm = ""Sha256WithECDSA"";
private static readonly ECCurve MsCurve = ECCurve.NamedCurves.nistP256;
private static readonly DerObjectIdentifier BcCurve = SecObjectIdentifiers.SecP256r1; // must correspond with MsCurve

public static X509Certificate2 Create()
{    
    // 1. generate keys:
    IAsymmetricCipherKeyPairGenerator bcKeyGen = GeneratorUtilities.GetKeyPairGenerator(""ECDSA"");
    bcKeyGen.Init(new ECKeyGenerationParameters(BcCurve, new SecureRandom()));

    ECPrivateKeyParameters bcPrivKey;
    ECPublicKeyParameters bcPublKey;

    bool validated;
    ECParameters msEcp;
    do
    {
        AsymmetricCipherKeyPair bcKeyPair = bcKeyGen.GenerateKeyPair();
        bcPrivKey = (ECPrivateKeyParameters)bcKeyPair.Private;
        bcPublKey = (ECPublicKeyParameters)bcKeyPair.Public;

        // 2. ensure generated bc-keys can be translated to cng (see exception below)
        msEcp = new ECParameters();
        msEcp.Curve = MsCurve;
        msEcp.D = bcPrivKey.D.ToByteArrayUnsigned(); // or bcPrivKey.D.ToByteArray() ??
        msEcp.Q.X = bcPublKey.Q.XCoord.GetEncoded();
        msEcp.Q.Y = bcPublKey.Q.YCoord.GetEncoded();

        try
        {
            msEcp.Validate();
            validated = true;
        }
        catch (Exception e)
        {
            // Validate() occasionally throws CryptographicException: 
            // The specified key parameters are not valid. Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If D is specified it must be the same length as Q.X and Q.Y for named curves or the same length as Order for explicit curves.
            // e.g.: D = 31, Q.X = 32, Q.Y = 32.
            validated = false;
            Console.WriteLine(""D = {0}, Q.X = {1}, Q.Y = {2}. {3}: {4}"", msEcp.D.Length, msEcp.Q.X.Length, msEcp.Q.Y.Length, e.GetType().Name, e.Message);
        }
    } while (!validated);

    // 3. create x509 certificate:
    X509V3CertificateGenerator bcCertGen = new X509V3CertificateGenerator();
    bcCertGen.SetPublicKey(bcPublKey);
    // .. set subject, validity period etc
    ISignatureFactory sigFac = new Asn1SignatureFactory(SignatureAlgorithm, bcPrivKey);
    Org.BouncyCastle.X509.X509Certificate bcX509Cert = bcCertGen.Generate(sigFac);
    byte[] x509CertEncoded = bcX509Cert.GetEncoded();

    X509Certificate2 msNewCert;

    // 4. use translated (and validated) parameters:
    using (ECDsaCng msEcdsa = new ECDsaCng())
    {
        msEcdsa.ImportParameters(msEcp);

        CngKey msPrivateKey = msEcdsa.Key;

        // 5. make private key exportable:
        byte[] bytes = BitConverter.GetBytes((int)(CngExportPolicies.AllowExport | CngExportPolicies.AllowPlaintextExport));
        CngProperty pty = new CngProperty(NCryptExportPolicyProperty, bytes, CngPropertyOptions.Persist);
        msPrivateKey.SetProperty(pty);

        // 6. tie keys together:
        using (X509Certificate2 msPubCertOnly = new X509Certificate2(x509CertEncoded))
        {
            msNewCert = MateECDsaPrivateKey(msPubCertOnly, msPrivateKey); // method from bartonjs's answer
        }
    }

    return msNewCert;
}
</code></pre>

<p>Thank you in advance</p>
","<p>When you are getting too many bytes (33 in this case) the first byte should be <code>0x00</code>, and you need to remove it.  When you are getting too few (technically speaking D=1 is valid) you need to insert zeros to fill the array out.</p>

<p>The reason is that .NET's structure expects D to look like it does to the underlying Windows CNG import API, which means that D is a fixed-with unsigned big endian big integer.  BouncyCastle is giving you the BER INTEGER encoding, which requires inserting a <code>0x00</code> byte when the high bit of the most significant byte (bytes[0], big endian) is set in a number that should be considered positive.</p>

<p>BER also has a rule that the minimum number of bytes be used, which is why sometimes BouncyCastle gives a number that's too small.</p>

<p>Q.X and Q.Y are okay because the ECPoint encoding rules specify a fixed size big endian integer whose size is determined by the curve; which is why BouncyCastle has the <code>GetEncoded</code> method instead of just <code>ToByteArrayUnsigned</code>.</p>

<pre><code>private static byte[] FixSize(byte[] input, int expectedSize)
{
    if (input.Length == expectedSize)
    {
        return input;
    }

    byte[] tmp;

    if (input.Length &lt; expectedSize)
    {
        tmp = new byte[expectedSize];
        Buffer.BlockCopy(input, 0, tmp, expectedSize - input.Length, input.Length);
        return tmp;
    }

    if (input.Length &gt; expectedSize + 1 || input[0] != 0)
    {
        throw new InvalidOperationException();
    }

    tmp = new byte[expectedSize];
    Buffer.BlockCopy(input, 1, tmp, 0, expectedSize);
    return tmp;
}

...

msEcp = new ECParameters();
msEcp.Curve = MsCurve;
msEcp.Q.X = bcPublKey.Q.XCoord.GetEncoded();
msEcp.Q.Y = bcPublKey.Q.YCoord.GetEncoded();
msEcp.D = FixSize(bcPrivKey.D.ToByteArrayUnsigned(), msEcp.Q.X.Length);
</code></pre>
","605","<c#><certificate><bouncycastle><ecdsa>","0","0","1","2018-01-31 16:42:49","48547186","2","1","","","","2018-01-31 12:28:53",""
"45819620","correct encoding in ecdsa, python","<p>I am following technical instructions how to create a bitcoin wallet.</p>

<p>It says:</p>

<pre><code>private_key = 18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725
</code></pre>

<p>1 - Take the corresponding public key generated with it (65 bytes, 1 byte 0x04, 32 bytes corresponding to X coordinate, 32 bytes corresponding to Y coordinate) </p>

<pre><code>public_key= 0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6
</code></pre>

<p>and my code in python 3.5.2 :</p>

<pre><code>from ecdsa import SigningKey, SECP256k1

private_key = '18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725'

x = SigningKey.from_string(private_key, curve=SECP256k1)
print(x)
</code></pre>

<p>The error: </p>

<pre><code>output = ERROR: assert len(string) == curve.baselen, (len(string), curve.baselen)
builtins.AssertionError: (64, 32)
</code></pre>

<p>I am not really sure what to do, because any manipulation would return different <code>public_key</code>. Any ideas how to solve this?</p>
","<p>The private key you are using in your example above seems to be in hex format. The function,</p>

<pre><code> from_string(private_key, curve=SECP256k1) 
</code></pre>

<p>takes a string private_key. So instead of passing the hex format private key you must pass it a string version</p>

<p>Below is what I tried and it seems to be working just fine,</p>

<pre><code> private_key = SigningKey.generate(curve=SECP256k1)
 string_private_key = private_key.to_string()
 SigningKey.from_string(string_private_key, curve=SECP256k1)
</code></pre>

<p>This successfully returns an ecdsa signing key object </p>

<pre><code>&lt;ecdsa.keys.SigningKey object at 0x103a53f60&gt;
</code></pre>
","603","<python><ecdsa>","1","0","1","2018-03-13 07:08:57","","1","","5007059","","2018-03-13 07:08:57","2017-08-22 13:54:02",""
"56619355","ES256 JWT Signing in PHP for Apple AppStoreConenct API Auth","<p>I'm trying to authenticate to Apple's AppStoreConnect API with an ES256 signed JWT (per their instructions at <a href=""https://developer.apple.com/documentation/appstoreconnectapi"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/appstoreconnectapi</a>) using PHP. </p>

<p>Sending my request always results in a <code>401 NOT_AUTHORIZED</code> error.</p>

<p>I've verified that the the contents of my header and claims are correct - I even found a Ruby script online for generating an ES256 signed JWT and using my Apple provided Issuer, Key ID, Private Key, it works swimmingly - Apple accepts the token. That tells me that my credentials are good and I'm doing something wrong in php.</p>

<p>Unless I've simply stared at this code for too long, the JWT format is correct, base64 encoded correctly, and the bearer token is set correctly in the header.</p>

<p>To rule out an issue with request sending I've tried both GuzzleHTTP and CLI cURL - both a 401.</p>

<hr>

<p>Here's the relevant code. You'll see that the <code>create</code> method is encoding the header and claims, signing the ""payload"", and concatenating all 3.</p>

<pre class=""lang-php prettyprint-override""><code>public function create()
{
    $header = $this-&gt;encode(
        json_encode([
            'kid' =&gt; 'my_key_id',
            'alg' =&gt; 'ES256',
            'typ' =&gt; 'JWT',
        ])
    );

    $claims = $this-&gt;encode(
        json_encode([
            'iss' =&gt; 'my_issuer_uuid',
            'exp' =&gt; time() + (20 * 60),
            'aud' =&gt; 'appstoreconnect-v1',
        ])
    );

    $signature = $this-&gt;encode(
        $this-&gt;sign(""$header.$claims"")
    );

    return $header . '.' . $claims . '.' . $signature;
}
</code></pre>

<p>This code successfully returns an open ssl resource, <code>$data</code> has the expected contents.</p>

<pre class=""lang-php prettyprint-override""><code>public function sign($data)
{
    if (!$key = openssl_pkey_get_private('file://my_key_file.p8')) {
        throw new \Exception('Failed to read PEM');
    }

    if (!openssl_sign($data, $signature, $key, OPENSSL_ALGO_SHA256)) {
        throw new \Exception('Claims signing failed');
    }

    return $signature;
}
</code></pre>

<p>Base64 URL encoding... <code>$data</code> has the expected contents.</p>

<pre class=""lang-php prettyprint-override""><code>public function encode($data)
{
    return str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($data));
}
</code></pre>

<p>At this point I'm stumped to what it is I'm doing wrong or missing. I'm hoping some extra eyes will find something! Using the token that my code dumps out: </p>

<pre class=""lang-sh prettyprint-override""><code>curl  https://api.appstoreconnect.apple.com/v1/users --Header ""Authorization: Bearer &lt;token&gt;
</code></pre>

<p>...always returns a <code>401</code>. I suspect there's something wrong in the signing portion of the code as it's the only part I haven't been able to verify (again, worked in Ruby), though looking at all the docs and examples for <code>openssl_sign</code>, I'm pretty sure it's right.</p>

<p>For reference, this is the Ruby script I mention <a href=""https://shashikantjagtap.net/generating-jwt-tokens-for-app-store-connect-api/"" rel=""nofollow noreferrer"">https://shashikantjagtap.net/generating-jwt-tokens-for-app-store-connect-api/</a></p>
","<p>The signature returned by OpenSSL is an ASN.1 sequence that contains additional information. You have to remove the extra data before concatenation.</p>

<p>You can use that <a href=""https://github.com/web-token/jwt-framework/blob/v1.3/src/Component/Core/Util/ECSignature.php"" rel=""nofollow noreferrer"">simple class I wrote</a> (method <code>fromDER</code>) to convert the OpenSSL signature.</p>
","588","<php><jwt><sha256><ecdsa><appstoreconnect>","1","0","2","2019-07-22 16:19:16","","0","1","","","","2019-06-16 13:37:45",""
"56619355","ES256 JWT Signing in PHP for Apple AppStoreConenct API Auth","<p>I'm trying to authenticate to Apple's AppStoreConnect API with an ES256 signed JWT (per their instructions at <a href=""https://developer.apple.com/documentation/appstoreconnectapi"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/appstoreconnectapi</a>) using PHP. </p>

<p>Sending my request always results in a <code>401 NOT_AUTHORIZED</code> error.</p>

<p>I've verified that the the contents of my header and claims are correct - I even found a Ruby script online for generating an ES256 signed JWT and using my Apple provided Issuer, Key ID, Private Key, it works swimmingly - Apple accepts the token. That tells me that my credentials are good and I'm doing something wrong in php.</p>

<p>Unless I've simply stared at this code for too long, the JWT format is correct, base64 encoded correctly, and the bearer token is set correctly in the header.</p>

<p>To rule out an issue with request sending I've tried both GuzzleHTTP and CLI cURL - both a 401.</p>

<hr>

<p>Here's the relevant code. You'll see that the <code>create</code> method is encoding the header and claims, signing the ""payload"", and concatenating all 3.</p>

<pre class=""lang-php prettyprint-override""><code>public function create()
{
    $header = $this-&gt;encode(
        json_encode([
            'kid' =&gt; 'my_key_id',
            'alg' =&gt; 'ES256',
            'typ' =&gt; 'JWT',
        ])
    );

    $claims = $this-&gt;encode(
        json_encode([
            'iss' =&gt; 'my_issuer_uuid',
            'exp' =&gt; time() + (20 * 60),
            'aud' =&gt; 'appstoreconnect-v1',
        ])
    );

    $signature = $this-&gt;encode(
        $this-&gt;sign(""$header.$claims"")
    );

    return $header . '.' . $claims . '.' . $signature;
}
</code></pre>

<p>This code successfully returns an open ssl resource, <code>$data</code> has the expected contents.</p>

<pre class=""lang-php prettyprint-override""><code>public function sign($data)
{
    if (!$key = openssl_pkey_get_private('file://my_key_file.p8')) {
        throw new \Exception('Failed to read PEM');
    }

    if (!openssl_sign($data, $signature, $key, OPENSSL_ALGO_SHA256)) {
        throw new \Exception('Claims signing failed');
    }

    return $signature;
}
</code></pre>

<p>Base64 URL encoding... <code>$data</code> has the expected contents.</p>

<pre class=""lang-php prettyprint-override""><code>public function encode($data)
{
    return str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($data));
}
</code></pre>

<p>At this point I'm stumped to what it is I'm doing wrong or missing. I'm hoping some extra eyes will find something! Using the token that my code dumps out: </p>

<pre class=""lang-sh prettyprint-override""><code>curl  https://api.appstoreconnect.apple.com/v1/users --Header ""Authorization: Bearer &lt;token&gt;
</code></pre>

<p>...always returns a <code>401</code>. I suspect there's something wrong in the signing portion of the code as it's the only part I haven't been able to verify (again, worked in Ruby), though looking at all the docs and examples for <code>openssl_sign</code>, I'm pretty sure it's right.</p>

<p>For reference, this is the Ruby script I mention <a href=""https://shashikantjagtap.net/generating-jwt-tokens-for-app-store-connect-api/"" rel=""nofollow noreferrer"">https://shashikantjagtap.net/generating-jwt-tokens-for-app-store-connect-api/</a></p>
","<p>After struggling alot, i finally got it working using <a href=""https://github.com/lcobucci/jwt"" rel=""nofollow noreferrer"">https://github.com/lcobucci/jwt</a> </p>

<pre><code>use Curl\Curl;
use Lcobucci\JWT\Builder;
use Lcobucci\JWT\Signer\Key;
use Lcobucci\JWT\Signer\Ecdsa\Sha256;

$signer = new Sha256();
$privateKey = new Key('file://AuthKey_XYZ.p8');
$time = time();

$Issuer_ID = ""FROM_APPLE_PAGE"";
$Key_ID = ""FROM_APPLE_PAGE"";

$token = (new Builder())-&gt;issuedBy($Issuer_ID)// Configures the issuer (iss claim)
-&gt;permittedFor(""appstoreconnect-v1"")// Configures the audience (aud claim)
-&gt;identifiedBy('XXYYZZ', true)// Configures the id (jti claim), replicating as a header item
-&gt;withHeader('kid', $Key_ID)
-&gt;withHeader('type', 'JWT')
    -&gt;withHeader('alg', 'ES256')
    -&gt;issuedAt($time)// Configures the time that the token was issue (iat claim)
    -&gt;expiresAt($time + 1200)// Configures the expiration time of the token (exp claim)
    -&gt;withClaim('uid', 1)// Configures a new claim, called ""uid""
    -&gt;getToken($signer, $privateKey); // Retrieves the generated token


$token-&gt;getHeaders(); // Retrieves the token headers
$token-&gt;getClaims(); // Retrieves the token claims
</code></pre>
","588","<php><jwt><sha256><ecdsa><appstoreconnect>","1","1","2","2019-07-22 16:19:16","","0","1","","","","2019-06-16 13:37:45",""
"45198652","C# - AsymmetricCipherKeyPair to hexadecimal","<p>I would like an ECDSA AsymmetricCipherKeyPair that I generate in hexadecimal format.  Both the public and private keys.</p>

<p>Now I am doing this:</p>

<pre><code>//Generate key pair
ECKeyPairGenerator gen = new ECKeyPairGenerator(""ECDSA"");
SecureRandom secureRandom = new SecureRandom();
KeyGenerationParameters keyGenParam = new KeyGenerationParameters(secureRandom, keySize);
gen.Init(keyGenParam);
AsymmetricCipherKeyPair keys = gen.GenerateKeyPair();

//Create a PEM and then extract the BASE64 part
var key = keys.Private;
TextWriter textWriter = new StringWriter();
PemWriter pemWriter = new PemWriter(textWriter);
pemWriter.WriteObject(key);
pemWriter.Writer.Flush();
string pem = textWriter.ToString();
var pem2 = pem.Split('\r').Skip(1).TakeWhile(i =&gt; !i.Contains(""-----"")).ToArray();
pem = string.Join("""",pem2);

//BASE64 to byte[] to hex
byte[] bytes = Convert.FromBase64String(pem);
string hex = BitConverter.ToString(bytes);
</code></pre>

<p>There must be an easier way to get the hexadecimal output.</p>
","<p>For the private key:</p>

<pre><code>bytes = Org.BouncyCastle.Pkcs.PrivateKeyInfoFactory.CreatePrivateKeyInfo(keys.Private).ParsePrivateKey().GetDerEncoded();
</code></pre>

<p>and the public:</p>

<pre><code>bytes = Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(keys.Public).GetDerEncoded();
</code></pre>
","577","<c#><bouncycastle><ecdsa>","0","3","1","2017-07-20 11:20:02","45213211","0","","","","","2017-07-19 18:43:14",""
"22012391","java.security.SignatureException: error decoding signature bytes","<p>I am getting this exception when trying to verify the signature in an Android KitKat device (Nexus 5).</p>

<p>Using <code>KeyFactory</code> as the EC algorithm and signature instance as <code>NONEwithECDSA</code>.</p>

<p>Exception Log:</p>

<pre><code>java.security.SignatureException: error decoding signature bytes. 
at com.android.org.bouncycastle.jcajce.provider.asymmetric.util.DSABase.engineVerify(DSABase.java:82)
at java.security.Signature$SignatureImpl.engineVerify(Signature.java:617)
    at java.security.Signature.verify(Signature.java:375)
</code></pre>

<p>Can anyone explain how to overcome this error? </p>
","","548","<android><exception><android-4.4-kitkat><ecdsa>","4","","0","2014-02-25 14:30:09","","0","1","752320","","2014-02-25 14:30:09","2014-02-25 11:09:53",""
"45565791","Create ECDSA DER Encoded Signature","<p>I'm trying to create an ECDSA Signature in Java. When i create one in python it can be verified just fine in Java. But vice-versa gives me a BadSignatureException.Python is using the ECDSA library and Java is using SpongyCastle.</p>

<p><strong>Python Implementation of Signing:</strong></p>

<pre><code>private_key = SigningKey.from_der(PRIVATE_KEY.decode('hex'))
private_key.sign(payload, hashfunc=hashlib.sha256, 
sigencode=sigencode_der).encode('hex'),
</code></pre>

<p><strong>Python Implementation of Verifying</strong></p>

<pre><code>verifying_key = VerifyingKey.from_der(public_key.decode('hex'))
return vk.verify(signature.decode('hex'), payload, hashfunc=hashlib.sha256, sigdecode=sigdecode_der)
</code></pre>

<p><strong>Java Implementation of Signing</strong></p>

<pre><code>signature = Signature.getInstance(""SHA256withECDSA"", ""SC"");
signature.initSign(this.privateKey);
signature.update(input.getBytes(""UTF-8""));
return new String(Hex.encode(signature.sign()));
</code></pre>

<p><strong>Java Implementation of Verifying</strong></p>

<pre><code>signature = Signature.getInstance(""SHA256withECDSA"", ""SC"");
signature.initVerify(publicKey);
signature.update(input.getBytes(""UTF-8""));
return signature.verify(Hex.decode(expectedSignature));
</code></pre>
","<p>You can try to use <code>verify_digest()</code> and <code>sign_digest()</code> from python.<br>
For example to verify the signature,</p>

<pre><code>digest = SHA256.new() 
digest.update((message.encode('utf-8')))

verified = vk.verify_digest(bytes.fromhex(signature), digest.digest())
</code></pre>
","534","<java><python><encoding><sign><ecdsa>","5","0","1","2019-09-13 14:12:27","","0","","","","","2017-08-08 10:25:02",""
"44969868","Java Signature.sign() with SHAwithECDSA produces different results on multiple runs","<p>I am trying to sign a byte stream which does not change with a private key that does not change either, using the SHAwithECDSA. This should produce the same result, no matter how often you run the code. 
However, I experience some randomness which I can't explain as the resulting output changes with every run. </p>

<p>Here is what I do (minimal example):</p>

<pre><code>public byte[] sign() {
    Signature ecdsa = Signature.getInstance(""SHA256withECDSA"", ""SunEC"");

    // This is a hexadecimal byte sequence I need to sign
    String dataToBeSigned = ""808112B43A3A381D1797BBBBBB973B99"" + 
                         ""9737B93397AA2917B1B0B737B734B1B0"" + 
                         ""B616B2BC3497A1AB43A3A381D1797BBB"" +
                         ""BBB973B999737B933979918181897981"" +
                         ""A17BC36B63239B4B396B6B7B93291B2B"" +
                         ""1B239B096B9B430991A9B22062349443"" +
                         ""1025687474703A2F2F7777772E77332E"" +
                         ""6F72672F54522F63616E6F6E6963616C"" +
                         ""2D6578692F4852D0E8E8E0745E5EEEEE"" +
                         ""EE5CEE665CDEE4CE5E646060625E6068"" +
                         ""5EF0DAD8CADCC646E6D0C2646A6C841A"" +
                         ""36BC07A00CB7DCAD662F3088A60A3D6A"" +
                         ""99431F81C122C2E9F1678EF531E95523"" +
                         ""70"";

    String hexPrivKey = ""B9134963F51C4414738435057F97BBF1"" +
                        ""010CABCB8DBDE9C5D48138396AA94B9D"";
    byte[] privKey = DatatypeConverter.parseHexBinary(hexPrivKey);

    ecdsa.initSign(getPrivateKey(privKey));
    ecdsa.update(dataToBeSigned);
    byte[] signature = ecdsa.sign();

    System.out.println(""Signature: "" + DatatypeConverter.printHexBinary(signature));
}

public ECPrivateKey getPrivateKey(byte[] privateKeyBytes) {
    try {
        AlgorithmParameters parameters = AlgorithmParameters.getInstance(""EC"");
        parameters.init(new ECGenParameterSpec(""secp256r1""));

        ECParameterSpec ecParameterSpec = parameters.getParameterSpec(ECParameterSpec.class);
        ECPrivateKeySpec ecPrivateKeySpec = new ECPrivateKeySpec(new BigInteger(privateKeyBytes), ecParameterSpec);

        ECPrivateKey privateKey = (ECPrivateKey) KeyFactory.getInstance(""EC"").generatePrivate(ecPrivateKeySpec);

        return privateKey;
    } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidParameterSpecException e) {
        System.out.println(e.getClass().getSimpleName() + "" occurred when trying to get private key from raw bytes"", e);
        return null;
    }
}
</code></pre>

<p>Do you have any hint why this would not result in the same signature output every time I run this code?
A similar question was raised <a href=""https://stackoverflow.com/questions/15866072/java-digital-signatures-inconsistent-signature"">here</a>, but no real answer has been found yet.</p>

<p>Another question related to that: 
I see that there is another initSign method provided by the Signature class:
initSign(PrivateKey privateKey, SecureRandom random)
Why would I wanna insert a random source/seed when creating a signature? How is the receiving side supposed to verify that signature then if the random seed is not known?</p>

<p>Thanks for any valuable input!
Marc</p>
","<p>The <a href=""https://www.ietf.org/rfc/rfc6979.txt"" rel=""nofollow noreferrer"">specification of the algorithm</a> explains it:</p>

<blockquote>
  <p>One characteristic of DSA and ECDSA is that they need to produce, for
     each signature generation, a fresh random value (hereafter designated
     as k).  For effective security, k must be chosen randomly and
     uniformly from a set of modular integers, using a cryptographically
     secure process.  Even slight biases in that process may be turned
     into attacks on the signature schemes.</p>
</blockquote>

<p>So what you're seeing is perfectly normal. Of course, the designers of the algorithms made it possible for the receiver to verify the signature, otherwise it would be pointless. That's what your test should verify.</p>
","524","<java><ecdsa>","2","2","1","2017-07-07 11:49:51","44970067","0","","","","","2017-07-07 11:38:53",""
"48788710","Verify signature using NIST P-256 type key and SHA-256 algorithm","<p>I encounter a problem with validation of signature in Java using SHA-256 algorithm and NIST P-256 type key.</p>

<p>I have a X509 certificate (provided by Certificate Authority) which contains a public key and I should certify authenticity of the message that I receive.</p>

<p>Signature that I receive is encoded in Base32 (on 103 characters) and I decode it to binary. I obtain a bytes array of 64 octets.</p>

<p>Informations on public key :</p>

<pre><code>Sun EC public key, 256 bits
  public x coord: 76693623628200764797317561328856095594448010045454057728566183687964056347177
  public y coord: 111784915166853162657631137717721670318464358783507947441022826650722573271612
  parameters: secp256r1 [NIST P-256, X9.62 prime256v1] (1.2.840.10045.3.1.7)
</code></pre>

<p><strong>(EDIT)</strong> Method that I use to verify authenticity of my message :</p>

<pre><code>public static void verify(String message, String signatureReceived, String pathToCertificate) {

    try {

        final X509Certificate certificat = getCertificate(pathToCertificate);
        final PublicKey publicKey = certificat.getPublicKey();

        final byte[] signatureReceivedInBinary = BaseEncoding.base32().decode(signatureReceived);

        byte[] rBytes = Arrays.copyOfRange(signatureReceivedInBinary, 0, 32);
        byte[] sBytes = Arrays.copyOfRange(signatureReceivedInBinary, 32, 64);

        BigInteger r = new BigInteger(1, rBytes);
        BigInteger s = new BigInteger(1, sBytes);

        ASN1Integer asn1R = new ASN1Integer(r);
        ASN1Integer asn1S = new ASN1Integer(s);

        DERSequence seq = new DERSequence(new ASN1Integer[]{asn1R, asn1S});
        byte[] encoded = seq.getEncoded();

        Signature signature = Signature.getInstance(""SHA256withECDSA"");

        signature.initVerify(publicKey);
        signature.update(message.getBytes(""UTF-8""));

        if (signature.verify(encoded)) {
            System.out.println(""Signature OK"");
        } else {
            System.out.println(""Signature KO"");
        }

    } catch (Exception e) {
        e.printStackTrace();
    }

}
</code></pre>

<p>Main class :</p>

<pre><code>public static void main(String[] args)
        throws NoSuchAlgorithmException, CertificateException, IOException,
        KeyStoreException {

    final String message = ""MessageToValidate"";
    final String certificatPath = ""&lt;PATH_TO_CERTIFICATE&gt;\\public_certificat.crt"";
    final String signature = ""UBFF4NY7MIXQVUZYMRDRGXBTVWIVMCNP76TN7SA24QUJ4AAHG4WTLA2QZ5TSC54F2OQRMWOAKSHLXJLNHXH4GJPBHBWXBO3PMSDOVZI"";

    try {
        Test.verify(message, signature, certificatPath);
    } catch (final Exception e) {
        System.out.println(e.getMessage());
    }

}
</code></pre>

<p>When I execute my application, I obtain this error : </p>

<pre><code>Exception in thread ""main"" java.security.SignatureException: Could not verify signature
    at sun.security.ec.ECDSASignature.engineVerify(ECDSASignature.java:325)
    at java.security.Signature$Delegate.engineVerify(Signature.java:1219)
    at java.security.Signature.verify(Signature.java:652)
    at fr.altes.music.utils.Test.verify(Test.java:56)
    at fr.altes.music.Application.main(Application.java:54)
Caused by: java.security.SignatureException: Invalid encoding for signature
    at sun.security.ec.ECDSASignature.decodeSignature(ECDSASignature.java:400)
    at sun.security.ec.ECDSASignature.engineVerify(ECDSASignature.java:322)
    ... 4 more
Caused by: java.io.IOException: Sequence tag error
    at sun.security.util.DerInputStream.getSequence(DerInputStream.java:330)
    at sun.security.ec.ECDSASignature.decodeSignature(ECDSASignature.java:376)
    ... 5 more
</code></pre>
","","504","<java><x509certificate><signature><sha256><ecdsa>","5","","0","2018-02-16 19:38:45","","1","","9360042","","2018-02-16 19:38:45","2018-02-14 13:44:58",""
"42483560","Determine protocol and cipher compatibility with server certificate","<p>My server may be attached to a RSA or ECDSA certificate.</p>

<p>In my code I set the prtocol method as</p>

<pre><code>sslmethod = SSLv23_server_method();
</code></pre>

<p>and setting the cipher using the SSL_CTX_set_cipher_list() API.</p>

<p>The problem is when the server is attached to ECDSA certificate and if I pass ""RSA"" cipher SSL_CTX_set_cipher_list() does not return any error though ""RSA"" cipher is not compatible with ECDSA certificates.</p>

<p>Is there any openssl API which I can use to find out if the cipher we are going to set is compatible with the certificate or with protocol or not?</p>
","<blockquote>
  <p>Is there any openssl API which I can use to find out if the cipher we are going to set is compatible with the certificate or with protocol or not?</p>
</blockquote>

<p>If you author the app and own the server, then YES, you do know what to expect. But the general case is NO, you don't know in advance and you can't query for it. You try to setup a channel and if it fails, then you try something else.</p>

<p>Generally speaking, there's no way to know in advance what cipher suites a server supports; or what type of public key is bound in the server's certificate. In fact, there's no way to know what protocol versions (SSLv2, SSLv3, TLS 1.0, TLS 1.1, TLS 1.2, etc) a server supports. Its the reason for <a href=""https://tools.ietf.org/html/rfc7507"" rel=""nofollow noreferrer"">RFC 7405, TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks</a>.</p>

<p>In 2016/2017, about the best you can do is assume:</p>

<ul>
<li>No SSLv2, SSLv3; only TLS 1.0 and above</li>
<li>Cipher suites from the collection ""HIGH:!aNULL:!kRSA:!RC4:!MD5""</li>
</ul>

<p>""!kRSA"" is ""no RSA key transport"", and it means you can only use ephemeral key exchanges. If a server has a RSA key, then it will only be used for authentication. That is, the key will be used to sign the server's ephemeral values during key exchange so the client knows they are authentic.</p>
","497","<ssl><openssl><ecdsa>","2","3","1","2017-02-27 11:21:43","","0","","608639","","2017-02-27 11:10:55","2017-02-27 10:38:06",""
"51961749","Java - Create XML Digital Signature using ECDSA (Elliptic Curve)","<p>We can create XML Digital Signature using RSA keys. But how do I use elliptic curve keys to sign xml files ? I get error messages such as -</p>

<pre><code>Exception in thread ""main"" java.security.KeyException: ECKeyValue not supported
    at org.jcp.xml.dsig.internal.dom.DOMKeyValue$EC.&lt;init&gt;(DOMKeyValue.java:350)
    at org.jcp.xml.dsig.internal.dom.DOMKeyInfoFactory.newKeyValue(DOMKeyInfoFactory.java:71)
    at csr.ExtractEC.main(XMLSignatureECTest.java:57)
Caused by: java.lang.ClassNotFoundException: sun/security/ec/ECParameters
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:264)
    at org.jcp.xml.dsig.internal.dom.DOMKeyValue$EC.getMethods(DOMKeyValue.java:367)
    at org.jcp.xml.dsig.internal.dom.DOMKeyValue$EC$1.run(DOMKeyValue.java:343)
    at org.jcp.xml.dsig.internal.dom.DOMKeyValue$EC$1.run(DOMKeyValue.java:339)
    at java.security.AccessController.doPrivileged(Native Method)
    at org.jcp.xml.dsig.internal.dom.DOMKeyValue$EC.&lt;init&gt;(DOMKeyValue.java:338)
    ... 2 more
</code></pre>

<p>I used below code to create SignatureMethod and KeyInfo -</p>

<pre><code>String url = ""http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256"";
        SignatureMethod signatureMethod = factory.newSignatureMethod(url, null);
        SignedInfo signedInfo = factory.newSignedInfo(c14n, signatureMethod, Collections.singletonList(reference));

        PrivateKey privateKey = Utils.generatePrivateEC(""e:\\certs\\ec\\ec.key.p8"");
        Certificate certificate = Utils.generatePublic(""e:\\certs\\ec\\ec.cer"");
        KeyInfoFactory keyInfoFactory = factory.getKeyInfoFactory();
        KeyValue keyValue = keyInfoFactory.newKeyValue(certificate.getPublicKey());
        KeyInfo keyInfo = keyInfoFactory.newKeyInfo(Collections.singletonList(keyValue));
</code></pre>

<p>JDK - Oracle JDK 8
Security Providers - BouncyCastle and Sun.</p>
","<p>It seems in <a href=""https://github.com/mulderbaba/xmlsec/blob/master/src/test/java/org/apache/xml/security/test/signature/ECDSASignatureTest.java"" rel=""nofollow noreferrer"">this</a> junit test someone is make an example for you.</p>
","494","<java><digital-signature><elliptic-curve><ecdsa><xml-dsig>","7","1","1","2018-09-01 07:12:46","52125821","8","","2531191","","2018-08-22 07:47:12","2018-08-22 07:26:15",""
"49889096","C# Sign Data with SHA-256withECDSA using BouncyCastle produce different Signature everytime","<p>I am following this <a href=""https://blog.todotnet.com/2018/02/public-private-keys-and-signing/"" rel=""nofollow noreferrer"">tutorial</a> to sign data with SHA-256withECDSA. </p>

<p>Using the same private key and message, it generated different signature result every time. The only change I made is return Base64 encoded string instead of Base58</p>

<p>Is it supposed to be the same signature every time?</p>

<pre><code>public static string GetSignature(string privateKey, string message)

{

    var curve = SecNamedCurves.GetByName(""secp256k1"");

    var domain = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);
    var keyParameters = new

            BC.Crypto.Parameters.ECPrivateKeyParameters(new BC.Math.BigInteger(privateKey),

            domain);

    ISigner signer = SignerUtilities.GetSigner(""SHA-256withECDSA"");

    signer.Init(true, keyParameters);

    signer.BlockUpdate(Encoding.ASCII.GetBytes(message), 0, Encoding.ASCII.GetBytes(message).Length);

    var signature = signer.GenerateSignature();

    return Convert.ToBase64String(signature);

}
</code></pre>

<p>Example result</p>

<pre><code>MEQCIB0rqb8Dbrh+e2akoCVJaUS4tyJYqfRf8vdz/W2fUOomAiB3D2BaMYjwSgKRQyTd/W+YEn+wT0I4dq1hmgBfe/Sh7g==

MEUCIQDsWxG8Zr7MCemgGylAN+Y32qJYuDmqZMpaPwxTKosJ3AIgE3oSsBjcua/aCvfNXiMfcUM9U92p9aRlAIEopw/wvd0=

MEYCIQCjQ0EDHVFhASuUSPnCGjCb0O1sq3Op+aAl01afjIVviQIhAOnGyGN9cKswFn97de0o/Im9Hswo6AdnLhKIZSUcYbDY

MEYCIQCAqcHyhRcbLtuyimJ4XCHvJcz0p0Wd7FgJ1+07sOsC/gIhAKYwlhRv98C/3XeZE1TujkB9qMn2C99GaguJoWng9+2y

MEUCIQD7ObA0n0JpRNQDe+3udpeKGEk79KsrjHsjv/4Wlj2bigIgZERRSQBEN91HTJHqn+prlwSCKUT4AJx061Gi0tv8Xuw=
</code></pre>
","<p>So the answer is: it should be non deterministic - everytime is different</p>

<p><a href=""https://en.wikipedia.org/wiki/Nondeterministic_algorithm"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Nondeterministic_algorithm</a></p>
","492","<c#><bouncycastle><sha256><ecdsa>","1","2","1","2018-04-23 03:22:41","49972959","2","","2680527","","2018-04-23 03:21:32","2018-04-17 23:52:00",""
"50235113","Generate ECDSA key pair in DER format","<p>I want to generate a <em>secp256r1</em> key pair in DER format using OpenSSL CLI.</p>

<p>I am using the following commands:</p>

<pre><code>$ openssl ecparam -name prime256v1 -outform der -genkey -out privkey.der
$ openssl ec -inform der -in privkey.der -pubout -outform der -out pubkey.der
</code></pre>

<p>However, the second command triggers an <em>unable to load Key</em> error:</p>

<pre><code>read EC key
unable to load Key
139911012984576:error:0D0680A8:asn1 encoding routines:asn1_check_tlen:wrong tag:crypto/asn1/tasn_dec.c:1112:
139911012984576:error:0D07803A:asn1 encoding routines:asn1_item_embed_d2i:nested asn1 error:crypto/asn1/tasn_dec.c:274:Type=EC_PRIVATEKEY
139911012984576:error:10092010:elliptic curve routines:d2i_ECPrivateKey:EC lib:crypto/ec/ec_asn1.c:925:
</code></pre>
","<p><code>ecparam -genkey</code> by default outputs <em>both</em> the params and the key; in PEM the reader can separate these and select the key part, but not in DER. <strong>Add <code>-noout</code></strong> to suppress the params. (Yes you want both <code>-out file -noout</code> even though it looks contradictory.)</p>

<p>(And I reproduced with 1.0.2l and 1.1.0f both built from upstream source.) </p>
","486","<openssl><ecdsa>","0","4","1","2018-05-08 16:20:40","50238164","1","","","","","2018-05-08 13:42:22",""
"15938880","Openssl Generate Public Asymmetric Key","<p>I am trying to output the public EC key parameters Qx and Qy from OpenSSL CLI. Is this possible? </p>
","<p>You can create an elliptic curve key with</p>

<blockquote>
  <p>openssl ecparam -out key.pem -name prime256v1 -genkey</p>
</blockquote>

<p>Output the public and private key with</p>

<blockquote>
  <p>openssl ec -inform PEM -in key.pem -pubout -text -noout</p>
</blockquote>
","482","<ssl><openssl><rsa><dsa><ecdsa>","0","5","1","2013-04-11 01:44:16","","0","0","","","","2013-04-11 00:31:41",""
"47926228","How can I use keys from OpenSSL for ECDSA (prime256v1) with easy-ecc?","<p>I am trying to use OpenSSL generated keys with Kenneth MacKay's <a href=""https://github.com/esxgx/easy-ecc"" rel=""nofollow noreferrer"">easy-ecc</a> library but I am struggling. </p>

<p>To test, I've generated keys and dumped them:</p>

<pre><code>$ openssl ec -in ec_private.pem -text -noout
read EC key
Private-Key: (256 bit)
priv:
    45:b7:1a:09:1c:2a:1c:78:f8:80:da:94:44:0f:0f:
    3f:f6:a8:93:2d:07:43:c8:2a:9c:58:25:49:1e:a5:
    b2:68
pub: 
    04:ae:ef:df:ff:85:ee:59:00:fd:43:52:10:14:77:
    23:c8:e3:ba:00:4d:82:4d:41:15:a4:c5:09:ec:96:
    ef:50:73:79:9d:a7:a6:1a:88:a9:b2:26:ac:1e:03:
    50:02:0d:93:47:83:9d:eb:f9:e7:d3:dd:7d:59:04:
    95:a8:fd:bb:cf
ASN1 OID: prime256v1
NIST CURVE: P-256
</code></pre>

<p>Imported them into a small harness based on a test in the pr using curve secp256r1,</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include ""ecc.h""

int main() {

    uint8_t privatek[] = { 
        0x45, 0xb7, 0x1a, 0x09, 0x1c, 0x2a, 0x1c, 0x78, 
        0xf8, 0x80, 0xda, 0x94, 0x44, 0x0f, 0x0f, 0x3f, 
        0xf6, 0xa8, 0x93, 0x2d, 0x07, 0x43, 0xc8, 0x2a, 
        0x9c, 0x58, 0x25, 0x49, 0x1e, 0xa5, 0xb2, 0x68
    };

    uint8_t publick[] = {
        0xae, 0xef, 0xdf, 0xff, 0x85, 0xee, 0x59, 0x00, 
        0xfd, 0x43, 0x52, 0x10, 0x14, 0x77, 0x23, 0xc8, 
        0xe3, 0xba, 0x00, 0x4d, 0x82, 0x4d, 0x41, 0x15, 
        0xa4, 0xc5, 0x09, 0xec, 0x96, 0xef, 0x50, 0x73, 
        0x79, 0x9d, 0xa7, 0xa6, 0x1a, 0x88, 0xa9, 0xb2, 
        0x26, 0xac, 0x1e, 0x03, 0x50, 0x02, 0x0d, 0x93, 
        0x47, 0x83, 0x9d, 0xeb, 0xf9, 0xe7, 0xd3, 0xdd, 
        0x7d, 0x59, 0x04, 0x95, 0xa8, 0xfd, 0xbb, 0xcf
    };

  uint8_t hash[ECC_BYTES];
  uint8_t sig[ECC_BYTES * 2];

  memcpy(hash, publick, ECC_BYTES);

  if (!ecdsa_sign(privatek, hash, sig)) {
      printf(""ECC_sign() failed\n"");
  }

  if (!ecdsa_verify(publick, hash, sig)) {
      printf(""ECC_verify() failed\n"");
  }  
}
</code></pre>

<p>but this never passes. I am not sure if I am doing something silly while importing the keys, or something else but this is not passing. </p>

<p>Any ideas as to what I am doing wrong?</p>
","<p>I guess I should have waited an hour before posting that question. easy-ecc works with compressed points. I dumped a compressed public key and used that with success. </p>

<p>There is also a <a href=""https://github.com/arekinath/easy-ecc"" rel=""nofollow noreferrer"">fork by arekinath</a> that supports uncompressed points. </p>

<p>Now if only I could get my micro-ecc code working...</p>
","465","<c><openssl><ecdsa>","2","0","1","2018-09-28 14:45:01","47926686","2","","","","","2017-12-21 13:41:43",""
"45161694","No ciphers availlable for specific ECDSA certificate","<p>I'm building a prototype of an IOT device communicating through openssl with an online server.
The software uses  ECDSA certificate signed with my own subca. </p>

<p>The problem seems there isn't a cipher availlable for that certificate.
To test the whole things i used openssl s_server on server side and nmap ssl-enum-ciphers script on client side. nmap returns a void list of ciphers.</p>

<p>The command given for the server is:</p>

<pre><code>openssl s_server -accept 4433 -cert server1.crt -certform PEM -key server1.key
</code></pre>

<p>this is the certificate i use on server side.</p>

<pre><code>Certificate:
Data:
    Version: 3 (0x2)
    Serial Number: 256 (0x100)
Signature Algorithm: ecdsa-with-SHA256
    Issuer: C=IT, O=wwwtech, CN=wwwtech Server CA
    Validity
        Not Before: Jul 17 12:11:31 2017 GMT
        Not After : Jul 17 12:11:31 2019 GMT
    Subject: C=IT, O=wwwtech, CN=server1
    Subject Public Key Info:
        Public Key Algorithm: id-ecPublicKey
            Public-Key: (160 bit)
            pub: 
                04:1c:e3:02:ec:bc:0f:88:7a:58:0b:36:b6:55:2c:
                e5:f1:67:5f:a0:7a:c3:c9:4b:7c:45:02:42:61:20:
                0c:4d:30:22:f6:c7:09:b5:ef:e1:8e
            ASN1 OID: brainpoolP160r1
    X509v3 extensions:
        X509v3 Basic Constraints: 
            CA:FALSE
        X509v3 Key Usage: 
            Key Encipherment
        Netscape Cert Type: 
            SSL Server
        Netscape Comment: 
            AreaWFI Server Certificate
        X509v3 Subject Key Identifier: 
            8D:92:1A:9F:6A:AB:D2:E5:6B:72:CB:25:A9:15:27:38:08:CE:DE:A9
        X509v3 Authority Key Identifier: 
            keyid:E7:2F:0E:A7:39:B4:85:46:FE:2A:EA:9F:0A:FE:54:F4:B9:A5:B6:AC

        X509v3 Subject Alternative Name: 
            IP Address:127.0.0.1
Signature Algorithm: ecdsa-with-SHA256
     30:44:02:20:32:f1:d1:90:08:f1:dc:a5:9d:30:d3:db:4b:05:
     6c:d2:41:cc:ac:6f:01:f8:90:0d:a5:25:27:4d:f9:38:62:14:
     02:20:19:37:c4:7c:07:e9:07:2d:c8:6e:1f:a4:db:4e:44:48:
     68:4a:e9:9d:03:68:b3:b0:c6:31:60:92:ed:54:5c:22
</code></pre>
","<p>Your certificate is using the brainpoolP160r1 curve. This curve is supported by libcrypto but <em>not</em> by libssl. Probably because this is insufficiently secure (it only offers the equivalent of 80 bits of security). Probably if you tried a different (more secure) curve you will get better results.</p>

<p>You don't say what version of OpenSSL you are using. Note that in OpenSSL 1.1.0 the ""default"" curves supported by OpenSSL are X25519, P-256, P-384 and P-512. If you want to use other curves you will probably have to explicitly state them using the ""-curves"" parameter to s_server. The only brainpool curves that libssl supports in OpenSSL 1.1.0 are brainpoolP256r1, brainpoolP384r1 and brainpoolP512r1.</p>

<p><strong>Edit:</strong></p>

<p>I also note that you have an X509v3 Key Usage of ""Key Encipherment"" which doesn't make any sense for an ECDSA cert (ECDSA can't ""encipher"" anything; its a digital signature algorithm). Change the key usage to ""Digital Signature"" (or drop it altogether).</p>
","463","<ssl><openssl><ssl-certificate><ecdsa>","0","2","2","2017-07-18 19:34:43","45164696","0","","6116760","","2017-07-18 09:47:18","2017-07-18 08:42:34",""
"45161694","No ciphers availlable for specific ECDSA certificate","<p>I'm building a prototype of an IOT device communicating through openssl with an online server.
The software uses  ECDSA certificate signed with my own subca. </p>

<p>The problem seems there isn't a cipher availlable for that certificate.
To test the whole things i used openssl s_server on server side and nmap ssl-enum-ciphers script on client side. nmap returns a void list of ciphers.</p>

<p>The command given for the server is:</p>

<pre><code>openssl s_server -accept 4433 -cert server1.crt -certform PEM -key server1.key
</code></pre>

<p>this is the certificate i use on server side.</p>

<pre><code>Certificate:
Data:
    Version: 3 (0x2)
    Serial Number: 256 (0x100)
Signature Algorithm: ecdsa-with-SHA256
    Issuer: C=IT, O=wwwtech, CN=wwwtech Server CA
    Validity
        Not Before: Jul 17 12:11:31 2017 GMT
        Not After : Jul 17 12:11:31 2019 GMT
    Subject: C=IT, O=wwwtech, CN=server1
    Subject Public Key Info:
        Public Key Algorithm: id-ecPublicKey
            Public-Key: (160 bit)
            pub: 
                04:1c:e3:02:ec:bc:0f:88:7a:58:0b:36:b6:55:2c:
                e5:f1:67:5f:a0:7a:c3:c9:4b:7c:45:02:42:61:20:
                0c:4d:30:22:f6:c7:09:b5:ef:e1:8e
            ASN1 OID: brainpoolP160r1
    X509v3 extensions:
        X509v3 Basic Constraints: 
            CA:FALSE
        X509v3 Key Usage: 
            Key Encipherment
        Netscape Cert Type: 
            SSL Server
        Netscape Comment: 
            AreaWFI Server Certificate
        X509v3 Subject Key Identifier: 
            8D:92:1A:9F:6A:AB:D2:E5:6B:72:CB:25:A9:15:27:38:08:CE:DE:A9
        X509v3 Authority Key Identifier: 
            keyid:E7:2F:0E:A7:39:B4:85:46:FE:2A:EA:9F:0A:FE:54:F4:B9:A5:B6:AC

        X509v3 Subject Alternative Name: 
            IP Address:127.0.0.1
Signature Algorithm: ecdsa-with-SHA256
     30:44:02:20:32:f1:d1:90:08:f1:dc:a5:9d:30:d3:db:4b:05:
     6c:d2:41:cc:ac:6f:01:f8:90:0d:a5:25:27:4d:f9:38:62:14:
     02:20:19:37:c4:7c:07:e9:07:2d:c8:6e:1f:a4:db:4e:44:48:
     68:4a:e9:9d:03:68:b3:b0:c6:31:60:92:ed:54:5c:22
</code></pre>
","<p>Problem solved.
I changed brainpoolP160r1 with prime256v1 and removed keyUsage=KeyEncipherment from the openssl.conf of signing CA,
then it start working as espected. Now i guess why?
RFC 5280 section 4.2.1.3 says :</p>

<blockquote>
  <p>The keyEncipherment bit is asserted when the subject public key is
        used for enciphering private or secret keys, i.e., for key
        transport.  For example, this bit shall be set when an RSA public
        key is to be used for encrypting a symmetric content-decryption
        key or an asymmetric private key.</p>
</blockquote>

<p>Is this appening during ssl handshake or not?</p>
","463","<ssl><openssl><ssl-certificate><ecdsa>","0","0","2","2017-07-18 19:34:43","45164696","0","","6116760","","2017-07-18 09:47:18","2017-07-18 08:42:34",""
"42588786","How to Fingerprint a JWK?","<p>Is there a standard, canonical method for creating a fingerprint (aka thumbprint) for a JWK?</p>

<p>From what I was reading it seems that the standard doesn't define how a <code>kid</code> should be specified, which I find odd. To me it makes the most since to have it be a deterministic value rather than one that requires a lookup table such that others could easily recreate the key id in by virtue of possessing the public key.</p>

<p>I am aware that SSH fingerprints and X.509 thumbprints are standardized, but those don't seem like a suitable solution for all environments where JWKs are used (especially browsers) because they are too complex for naive implementations and including the libraries capable of manipulating such (i.e. forge) would waste a lot of memory, bandwidth, and vm compile time.</p>

<h2>Update</h2>

<p>Officially it's called a ""thumbprint"" not a ""fingerprint"".</p>
","<p>I think the <a href=""https://tools.ietf.org/html/rfc7638"" rel=""nofollow noreferrer"">RFC7638</a> will answer your question.</p>

<p>This RFC describes a way to compute a hash value over a JWK.</p>

<p>It is really easy to implement:</p>

<ul>
<li>Keep the required parameters only. For a RSA key: <code>kty</code>, <code>n</code> and <code>e</code> and for an EC key: <code>crv</code>, <code>kty</code>, <code>x</code> and <code>y</code>.</li>
<li>Sort those parameters in lexicographic order: <code>e</code>,<code>kty</code> and <code>n</code></li>
<li>Compute the parameters and values into Json: <code>{""e"":""AQAB"",""kty"":""RSA"",""n"":""0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2
 aiAFbWhM78LhWx4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCi
 FV4n3oknjhMstn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65Y
 GjQR0_FDW2QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n
 91CbOpbISD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_x
 BniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw""}</code></li>
<li>Hash it using SHA-256 and encode it into Base64 Url Safe: <code>NzbLsXh8uDCcd-6MNwXF4W_7noWXFZAfHkxZsRGC9Xs</code></li>
</ul>
","448","<ecdsa><rsa-key-fingerprint><jwk>","1","3","2","2017-03-22 07:55:54","42590106","0","1","151312","","2017-03-10 21:57:53","2017-03-03 21:33:06",""
"42588786","How to Fingerprint a JWK?","<p>Is there a standard, canonical method for creating a fingerprint (aka thumbprint) for a JWK?</p>

<p>From what I was reading it seems that the standard doesn't define how a <code>kid</code> should be specified, which I find odd. To me it makes the most since to have it be a deterministic value rather than one that requires a lookup table such that others could easily recreate the key id in by virtue of possessing the public key.</p>

<p>I am aware that SSH fingerprints and X.509 thumbprints are standardized, but those don't seem like a suitable solution for all environments where JWKs are used (especially browsers) because they are too complex for naive implementations and including the libraries capable of manipulating such (i.e. forge) would waste a lot of memory, bandwidth, and vm compile time.</p>

<h2>Update</h2>

<p>Officially it's called a ""thumbprint"" not a ""fingerprint"".</p>
","<p>I don't believe there is a true standard, but this topic has been discussed in the <a href=""https://www.ietf.org/mail-archive/web/jose/current/msg01577.html"" rel=""nofollow noreferrer"">IETF mailing archives</a>. While the conversation seemed to get a little side-tracked by whether or not canonical JSON was a good idea in general, there was one method that seems reasonable as a standard fingerprinting method.</p>

<ol>
<li>Remove all ""metadata"" fields from the JWK (where in this case ""metadata"" is defined as any non-required key, ie anything but ""kty"" and the parameters for the encryption algorithm defined by the <a href=""https://www.rfc-editor.org/rfc/rfc7518.txt"" rel=""nofollow noreferrer"">JWA RFC-7518</a>).</li>
<li>Convert stripped JWK into ""canonical"" JSON (sort keys lexicographically, no leading or trailing whitespace, and no whitespace between tokens).</li>
<li>Compute digest over created JSON string.</li>
</ol>

<p>There is also no true standard that I am aware of for canonical JSON, but all the sources I've seen agree on at least the rules listed above (which are the only rules that should be relevant for the types of objects used for JWK's).</p>
","448","<ecdsa><rsa-key-fingerprint><jwk>","1","0","2","2017-03-22 07:55:54","42590106","0","1","151312","","2017-03-10 21:57:53","2017-03-03 21:33:06",""
"52299691","Generation ecdsa 32-byte private key in java/scala","<p>is it possible to generate ecdsa 32-byte private key in java using KeyPairGenerator? I mean that keys.getPublic.getEncoded.length will return 32
I've tried to generate private key, but size is 144 bytes</p>

<pre><code>//keys.getPrivate.getEncoded.length - 144 bytes
val ecSpec: ECNamedCurveParameterSpec = ECNamedCurveTable.getParameterSpec(""secp256k1"")
val keyPairGenerator: KeyPairGenerator = KeyPairGenerator.getInstance(""ECDSA"", ""BC"")
val secRandom = new SecureRandom()
keyPairGenerator.initialize(ecSpec, secRandom)
val keys = keyPairGenerator.generateKeyPair

//keys.getPrivate.getEncoded.length - 67 bytes
val keyPairGenerator: KeyPairGenerator = KeyPairGenerator.getInstance(""EC"")
keyPairGenerator.initialize(256)
val keys = keyPairGenerator.generateKeyPair
</code></pre>
","<p>The value returned from Java <code>PrivateKey.getEncoded()</code> is an <em>encoded</em> privatekey, as the name says. Specifically <a href=""https://docs.oracle.com/javase/8/docs/api/java/security/Key.html#getFormat--"" rel=""nofollow noreferrer"">as documented in the superclass <code>Key</code></a> it is an ASN.1 (DER) <strong>encoding of</strong> <a href=""https://tools.ietf.org/html/rfc5208#section-5"" rel=""nofollow noreferrer""><strong>PKCS#8</strong> = Public-Key Cryptography Standard #8, Private Key Information Syntax</a>. PKCS#8 handles privatekeys for a wide variety of different public-key algorithms and contains metadata in addition to the actual key, namely an 'AlgorithmIdentifier' which identifies the algorithm and any parameters of the algorithm; for the ECC algorithm(s) (ECDSA, ECDH, ECMQV and more share one key format) these parameters specify the elliptic curve group used, and although there are several options for this specification, in practice everyone, including here Java, uses the 'namedCurve' option which defines the curve group by an ASN.1 OID aka Object Identifier. </p>

<p>The PKCS#8 structure then contains the actual privatekey data, 'wrapped' in an OCTET STRING, in a format that varies depending on the algorithm. For ECC, this format is defined (AFAICT) in <a href=""http://www.secg.org/"" rel=""nofollow noreferrer"">SEC1 by SECG/Certicom</a> and contains the actual privatekey value (a number, expressed as an OCTET STRING) plus <em>optionally</em> the curve spec and the public key.</p>

<p>Your first code uses BouncyCastle, and Bouncy generates the encoding with the wrapped value including the optional curve spec and public key, making it longer.</p>

<p>Your second code uses by default the Oracle/Sun provider (SunEC), which generates the encoding without those options, but still including the required AlgorithmIdentifier making it longer than the actual privatekey value. It also uses a <strong>different curve</strong>: initializing a SunEC generator with the integer 256 chooses secp256r1 (aka P-256, prime256v1) NOT secp256k1. If you change this to use <code>new ECGenParameterSpec(""secp256k1"")</code> as the parameter then SunEC will also generate secp256k1, but without the options, giving a 64-byte encoding.</p>

<p>In both cases, if you want only the privatekey <em>number</em>, cast to <a href=""https://docs.oracle.com/javase/8/docs/api/java/security/interfaces/ECPrivateKey.html"" rel=""nofollow noreferrer""><code>java.security.interfaces.ECPrivateKey</code></a> and use <code>getS()</code>. If you want the result in a byte/octet array, as is conventional, note <code>BigInteger.toByteArray()</code> returns a variable-length result and you often need to left zero trim or pad it.</p>

<p>And if you <em>did</em> want the publickey, it has a similar scheme using 'X.509' encoding which contains both an AlgorithmIdentifier and a BIT STRING wrapping the actual publickey value, and thus is longer than the raw publickey value. However in this case <code>interfaces.ECPublicKey</code> and <code>spec.ECPoint</code> won't construct the encoding for you; using the Bouncy-only types can be more convenient.</p>
","430","<java><scala><ecdsa>","-3","1","1","2018-09-12 18:33:45","52301461","2","","9508555","","2018-09-12 16:55:10","2018-09-12 16:24:13",""
"50660187","Creating of ECDSA certficate signed by other ECDSA certificate","<p>I need to create ""Client"" ECDSA certificate signed by ""Root"" certificate (self-signed, ECDSA).
""Root"" certificate was created as described in  <a href=""https://stackoverflow.com/questions/48542233/translating-elliptic-curve-parameters-bc-to-ms"">Translating Elliptic Curve parameters (BC to MS)</a>.</p>

<p>To create ""Client"" certificate (signed by ""Root"") slightly modified algorithm can be used.
The difference is that the private key (used to sign public key from keypair generated for ""Client"" certificate) must be supplied from the ""outside"" - it is a private-key of ""Root"" certificate.
But this is the issue. I cannot find a way how to get and translate private key to type <code>Org.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters</code> that could be passed to signature-factory.</p>

<pre><code>// 1. get private-key of ""Root"" certificate from existing certificate:
byte[] msRootCertData = File.ReadAllBytes(@""c:\root_ecdsa_cert.pfx"");
X509Certificate2 msRootCert = new X509Certificate2(msRootCertData);
ECDsaCng msRootPrivateKey = msRootCert.GetECDsaPrivateKey() as ECDsaCng;
ECParameters msRootPrivateKeyParameters = msRootPrivateKey.ExportParameters(true);

// here comes the issue:
ECPrivateKeyParameters bcRootPrivateKeysParameters = TranslateMSKeysToBouncy(msRootPrivateKeyParameters);

// 2. generate ""Client"" key-pair:
AsymmetricCipherKeyPair bcClientKeyPair = bcKeyGen.GenerateKeyPair();
ECPrivateKeyParameters bcClientPrivKey = (ECPrivateKeyParameters)bcClientKeyPair.Private;
ECPrivateKeyParameters bcClientPublKey = (ECPublicKeyParameters)bcClientKeyPair.Public;

// 3. create X509 certificate:
X509V3CertificateGenerator bcCertGen = new X509V3CertificateGenerator();
bcCertGen.SetPublicKey(bcClientPublKey);
// .. set subject, validity period etc
ISignatureFactory sigFac = new Asn1SignatureFactory(""Sha256WithECDSA"", bcRootPrivateKeysParameters);
Org.BouncyCastle.X509.X509Certificate bcClientX509Cert = bcCertGen.Generate(sigFac);
byte[] x509CertEncoded = bcClientX509Cert.GetEncoded();
</code></pre>

<p>// the rest is the same as in the mentioned example.</p>

<p>Any hints? 
Or is there other way? (for example: passing instance of X509Certificate2 directly to BouncyCastle library (avoid to translate private-keys to Cng), or generating ""Client"" certificate without BouncyCastle)
Thanks.</p>
","<p>If you can take a dependency on .NET Framework 4.7.2 (or .NET Core 2.0) you can do it without BouncyCastle, via the new <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.certificaterequest(v=vs.110).aspx"" rel=""nofollow noreferrer"">CertificateRequest</a> class:</p>

<pre><code>X509Certificate2 publicPrivate;

using (ECDsa clientPrivateKey = ECDsa.Create())
{
    var request = new CertificateRequest(
        ""CN=Et. Cetera"",
        clientPrivateKey,
        HashAlgorithmName.SHA256);

    // Assuming this isn't another CA cert:
    request.CertificateExtensions.Add(
        new X509BasicConstraintsExtension(false, false, 0, false));

    // other CertificateExtensions as you desire.

    // Assign, or derive, a serial number.
    // RFC 3280 recommends that it have no more than 20 bytes encoded.
    // 12 random bytes seems long enough.
    byte[] serial = new byte[12];

    using (RandomNumberGenerator rng = RandomNumberGenerator.Create())
    {
        rng.GetBytes(serial);
    }

    DateTimeOffset notBefore = DateTimeOffset.UtcNow;
    DateTimeOffset notAfter = notBefore.AddMonths(15);

    using (X509Certificate2 publicOnly = request.Create(
        msRootCert,
        notBefore,
        notAfter,
        serial))
    {
        publicPrivate = publicOnly.CopyWithPrivateKey(clientPrivateKey);
    }
}

// The original key object was disposed,
// but publicPrivate.GetECDsaPrivateKey() still works.
</code></pre>

<p>If you want to add <code>publicPrivate</code> to an X509Store you need to either 1) export it to a PFX and re-import it, or 2) change the key creation to use a named key.  Otherwise, only the public portion will be saved (on Windows).</p>
","429","<c#><certificate><ecdsa>","1","3","1","2019-05-17 00:08:37","50660387","0","","","","","2018-06-02 18:58:27",""
"45896699","ECDSA Android verify with Public Key always return false","<p>I have some token and I need first to sign it with SHA256 and ECDSA based on private and public key from KeyStore.</p>

<p>Every time when I try to verify value I get false as result. I do not know why. </p>

<p><strong>Does someone have any idea how to solve this?</strong></p>

<p>Here are my functions to generate and load keys:</p>

<pre><code>private void generateKeys(){

    try {

        keyStore = KeyStore.getInstance(KEYSTORE_NAME);
        keyStore.load(null);

        if(!keyStore.containsAlias(KEY_NAME)) {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_EC, KEYSTORE_NAME);
            keyPairGenerator.initialize(
                    new KeyGenParameterSpec.Builder(KEY_NAME,
                            KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY)
                            .setDigests(KeyProperties.DIGEST_SHA256,
                                    KeyProperties.DIGEST_SHA512)
                            .setAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
                            .setUserAuthenticationRequired(false)
                            .build());
            keyPairGenerator.generateKeyPair();

            setRegistred(true);
        }
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchProviderException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    } catch (CertificateException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}



private void loadKeys(){
    try {
        keyStore = KeyStore.getInstance(KEYSTORE_NAME);
        keyStore.load(null);
        if(keyStore.containsAlias(KEY_NAME)) {
            publicKey = keyStore.getCertificate(KEY_NAME).getPublicKey();
            privateKey = (PrivateKey) keyStore.getKey(KEY_NAME, null);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (CertificateException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (UnrecoverableKeyException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>This is how sign value:</p>

<pre><code> public String sign(String inputStr, FingerprintManager.CryptoObject cryptoObject){
    try {
        Signature signature = Signature.getInstance(SecurityConstants.SIGNATURE);
        signature.initSign(privateKey);
        signature.update(inputStr.getBytes());
        byte[] signedBytes = signature.sign();
        String result = Base64.encodeToString(signedBytes, Base64.DEFAULT);
        Log.d(""TAG"", result);
        return result;
    } catch (SignatureException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>Here is my try to verify with Public Key:</p>

<pre><code>public boolean verifyWithPublicKey(String input, FingerprintManager.CryptoObject cryptoObject){
    try {
        Signature signature = Signature.getInstance(SecurityConstants.SIGNATURE);
        keyStore = KeyStore.getInstance(KEYSTORE_NAME);
        keyStore.load(null);
        PublicKey pk  = getPublicKeyForVerification();
        signature.initVerify(pk);
        signature.update(input.getBytes());
        boolean isVerifed = signature.verify(input.getBytes());
        Log.d(""TAG"", String.valueOf(isVerifed));
        return isVerifed;
    } catch (SignatureException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (CertificateException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return false;
}
</code></pre>
","<p>The error is here, when you write the following code to verify the signature:</p>

<pre><code>signature.update(input.getBytes());
boolean isVerifed = signature.verify(input.getBytes());
</code></pre>

<p>With this code, you try to verify that the signature has been signed with itself!</p>

<p>You should have:</p>

<pre><code>signature.update(MY_BYTES_ARRAY_OF_DATA);
boolean isVerifed = signature.verify(MY_SIGNATURE);
</code></pre>

<p><strong>Do not forget that the signature does not encapsulate the signed data by default.</strong></p>

<p>If you want to have a format that includes signed data and associated signature, use S/MIME, OpenPGP, etc.</p>
","424","<android><android-keystore><ecdsa>","0","1","1","2019-05-20 09:13:40","","0","","955836","","2019-05-20 09:13:40","2017-08-26 14:57:47",""
"52499457","Python code to recover private key from public key","<p>Helllo,</p>

<p>I would like to use <a href=""https://bitcoin.stackexchange.com/questions/65652/ecdsa-create-private-key-and-bitcoin-address?answertab=active#tab-top"">this code</a> to generate/recover my private key, I'm using Python 3.6 and installed ecdsa package but how should I edit the code with my public key?</p>

<p>I'm quite new to python, tried some things but I get the following errors..</p>

<p>NameError: name 'addr' is not defined</p>

<p>TypeError: 'NoneType' object is not iterable</p>

<p>IndentationError: unexpected indent          (&lt;-- I have many of this error)</p>

<p>Do I need anything else to download and install?</p>

<p>I'd appreciate for any kind of help!</p>
","<blockquote>
  <p><strong>how should I edit the code with my public key?</strong></p>
</blockquote>

<p>You can't.</p>

<p>Private keys cannot be generated from public keys. This is absolutely fundamental to public key cryptography.</p>

<blockquote>
  <p><strong>I get the following errors..</strong></p>
</blockquote>

<p>...</p>

<blockquote>
  <p><code>NameError: name 'addr' is not defined</code></p>
</blockquote>

<p>You must define or initialize <code>addr</code> <em>before</em> using it.</p>

<blockquote>
  <p><code>TypeError: 'NoneType' object is not iterable</code></p>
</blockquote>

<p>See <a href=""https://stackoverflow.com/q/3887381/477035"">TypeError: &#39;NoneType&#39; object is not iterable in Python</a></p>

<blockquote>
  <p><code>IndentationError: unexpected indent</code></p>
</blockquote>

<p>Python depends on <a href=""https://docs.python.org/2.0/ref/indentation.html"" rel=""nofollow noreferrer"">indentation</a> as part of its syntax, for example indentation is used to define blocks where other languages might use <code>{</code> and <code>}</code> or <code>begin</code> and <code>end</code>.</p>

<p>If you have too much or too little indentation it alters the meaning of the code and may not make any sense. You must pay careful attention to indentation when using Python.</p>

<p>In particular, I suspect that if you set tab-spacing to other than 8 and irregularly mix tabs with spaces in indentation, you will have problems.</p>
","404","<public-key><ecdsa>","0","1","1","2019-01-05 08:53:42","","0","","","","","2018-09-25 12:22:30",""
"51333111","openssl ""no shared cipher"" for ECDSA cert (RSA works fine)","<p>When I try to test my ecdsa cert using openssl it says ""no cipher suite found"".  However, RSA works fine and I have actually used use another ECDSA certificate in my production test (AWS IoT) and it works fine.  I can't figure out why openssl isn't happy???  I have the terminal output from my two sessions including my certificate and key pem output (one client and one server running on the same PC).  Any ideas what could be wrong??? </p>

<p>/////// Server terminal /////////////////////////</p>

<pre><code>$ openssl.exe version
OpenSSL 1.0.2o  27 Mar 2018

$  openssl.exe s_server -key test.key -cert test.crt -verify 0 -accept 443 -WWW verify depth is 0
Using default temp DH parameters
ACCEPT
4294956672:error:1408A0C1:SSL routines:ssl3_get_client_hello:no shared cipher:s3_srvr.c:1427:
ACCEPT

/////// Same system in a second terminal ////////

$ openssl s_client -connect 127.0.0.1:443 -CAfile test.crt
CONNECTED(00000003)
4294956672:error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure:s23_clnt.c:802:
---
no peer certificate available
---
No client certificate CA names sent
---
SSL handshake has read 7 bytes and written 308 bytes
---
New, (NONE), Cipher is (NONE)
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : 0000
    Session-ID:
    Session-ID-ctx:
    Master-Key:
    Key-Arg   : None
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    Start Time: 1531517108
    Timeout   : 300 (sec)
    Verify return code: 0 (ok)
---


$ cat test.crt
-----BEGIN CERTIFICATE-----
MIIBzzCCAXagAwIBAgIJAMuakp0UdYoZMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT
AlVTMQwwCgYDVQQKDANPUkcxDDAKBgNVBAsMA0FGRzEQMA4GA1UEAwwHUm9vdCBD
QTAeFw0xODA3MTMyMTI0MzBaFw0xODA4MTIyMTI0MzBaMDsxCzAJBgNVBAYTAlVT
MQwwCgYDVQQKDANPUkcxDDAKBgNVBAsMA0FGRzEQMA4GA1UEAwwHUm9vdCBDQTBZ
MBMGByqGSM49AgEGCCqGSM49AwEHA0IABFWTAwcN5r6TQEOToRDjES2hKoofyv/w
GFn8qXwQIeRORn2LinquUMH770vt2SejlJR93nyV/XmQVu3aCVxjMvOjYzBhMB0G
A1UdDgQWBBRcUCv8D7HBeEQ7N6jbRCmJFiU4DTAfBgNVHSMEGDAWgBRcUCv8D7HB
eEQ7N6jbRCmJFiU4DTASBgNVHRMBAf8ECDAGAQH/AgEBMAsGA1UdDwQEAwIBBjAK
BggqhkjOPQQDAgNHADBEAiA8tY8ebuAhWSfRGPnd8S0ukMdGULHPP0T7zTfOdnsb
TQIgad3ML+vIa0kt+cdRLKvci0/fGWcQCbTaqgO0chyuT2g=
-----END CERTIFICATE-----

$ cat test.key
-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIMtuI/yMncCnlYB/7ev8NaUWR0WYeeuIX35QVjHtA2vaoAoGCCqGSM49
AwEHoUQDQgAEVZMDBw3mvpNAQ5OhEOMRLaEqih/K//AYWfypfBAh5E5GfYuKeq5Q
wfvvS+3ZJ6OUlH3efJX9eZBW7doJXGMy8w==
-----END EC PRIVATE KEY-----
</code></pre>
","","393","<openssl><certificate><ecdsa>","0","","0","2018-07-14 23:49:42","","4","","10078130","","2018-07-14 23:20:42","2018-07-13 21:37:32",""
"46196312","ecdsa signature verification","<p>next problem:
message is signed in python application and will be verified in erlang with public key</p>

<p>python can sign message in two ways:</p>

<p>1) with muttable length of signature - erlang verifies ok</p>

<p>2) with imuttable length of signatur - erlang cant verify it</p>

<p>some information from python lib:
There are also multiple ways to represent a signature. The default sk.sign() and vk.verify() methods present it as a short string, for simplicity and minimal overhead. To use a different scheme, use the sk.sign(sigencode=) and vk.verify(sigdecode=) arguments. There are helper funcions in the ""ecdsa.util"" module that can be useful here.</p>

<p>Examples:</p>

<pre><code>DataToSign = 
&lt;&lt;96,0,0,0,0,0,253,0,254,128,131,0,33,1,255,255,48,142,92,131,100,75,214,244,255,60,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,16,92,17,66,0,1,0,0,0,0,0,0,3,9,89,185,3,24,89,185,5,112,0,0,123,3,0,3,253,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&gt;&gt;.

PublicKey = {{'ECPoint',&lt;&lt;4,71,71,171,183,56,205,109,58,24,36,197,220,179,74,166,21,145,
              79,209,245,157,150,237,93,96,31,1,248,198,232,97,28,197,90,243,
              89,210,74,169,213,236,46,124,133,31,44,215,222,184,221,251,95,
              40,182,101,193,50,35,62,174,134,178,142,120&gt;&gt;},
 {namedCurve,{1,2,840,10045,3,1,7}}}.



Signature from python (with constant length):

ImmutableSign = 
&lt;&lt;179,160,225,5,1,154,246,29,57,97,160,132,95,35,135,238,69,21,136,152,51,104,224,126,124,226,168,143,253,213,37,233,196,67,254,155,60,218,45,8,60,140,76,44,20,189,213,143,42,231,4,177,62,124,141,95,236,20,59,20,28,10,58,232&gt;&gt;.

signed with sk.sign(data, hashfunc=hashlib.sha256)

MutableSign =



&lt;&lt;48,68,2,32,6,82,67,217,251,248,93,74,223,170,47,192,93,228,218,228,132,4,69,177,57,49,20,161,241,48,52,106,39,130,197,2,2,32,88,35,228,122,252,140,214,
191,187,117,10,187,54,106,16,36,198,155,49,78,198,58,103,57,124,212,244,31,9,242,101,169&gt;&gt;

signed with  sk.sign(data, hashfunc=hashlib.sha256, sigencode=ecdsa.util.sigencode_der)


public_key:verify(DataTosign, sha256, ImmutableSign, PublicKey) -&gt; false

public_key:verify(DataTosign, sha256, MutableSign, PublicKey) -&gt; true
</code></pre>

<p>also interesting thing if verify via openssl</p>

<p>Mutable length sign:</p>

<pre><code>openssl dgst -ecdsa-with-SHA1 -verify ec-pub.pem -signature sig2.bin data
Verification Failure
</code></pre>

<p>fails (because sigh with sha256)</p>

<p>Immutable length sign:</p>

<pre><code>openssl dgst -ecdsa-with-SHA1 -verify ec-pub.pem -signature sig.bin data
Error Verifying Data
33773:error:0D07207B:asn1 encoding routines:ASN1_get_object:header too long:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-64.50.6/src/crypto/asn1/asn1_lib.c:153:
33773:error:0D068066:asn1 encoding routines:ASN1_CHECK_TLEN:bad object header:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-64.50.6/src/crypto/asn1/tasn_dec.c:1331:
33773:error:0D07803A:asn1 encoding routines:ASN1_ITEM_EX_D2I:nested asn1 error:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-64.50.6/src/crypto/asn1/tasn_dec.c:387:Type=ECDSA_SIG
</code></pre>
","<p>so we needed to format short sign to DER which verifies crypto</p>

<pre><code>fix_signed(&lt;&lt;First:8, _/bytes&gt;&gt; = Value) when First &gt;= 16#80 -&gt; &lt;&lt;0:8, Value/bytes&gt;&gt;;
fix_signed(Value) -&gt; Value.

get_signed_big_endian(Value) -&gt;
  Res = binary:encode_unsigned(Value),
  fix_signed(Res).

sign_to_der_format(&lt;&lt;R:256, S:256&gt;&gt;) -&gt;

  RBin = get_signed_big_endian(R),
  SBin = get_signed_big_endian(S),

  RSize = byte_size(RBin),
  SSize = byte_size(SBin),

  Len = 4 + RSize + SSize,

  &lt;&lt;48:8, Len:8, 2:8, RSize:8, RBin/bytes, 2:8, SSize:8, SBin/bytes&gt;&gt;.
</code></pre>
","391","<python><erlang><ecdsa><curves>","0","1","1","2017-09-14 11:12:33","46217575","3","","4460670","","2017-09-13 12:47:39","2017-09-13 11:25:59",""
"16198145","Combining ECDSA keys","<p>How can I combine two ECDSA private/public keypairs into one? I know it's done with modular addition in openssl, I just don't understand how that works. Can anyone explain that to me?</p>
","<p>ECDSA private key - is just a number, order of base point.
You can just add two private keys (i.e. numbers), reducing sum modulo base point order, and exponentiating the base point to this order.
But why should you need this?</p>
","391","<c++><openssl><addition><ecdsa><modular-arithmetic>","0","0","2","2013-07-31 19:40:37","16205796","0","","849891","","2013-07-31 19:40:37","2013-04-24 17:10:45",""
"16198145","Combining ECDSA keys","<p>How can I combine two ECDSA private/public keypairs into one? I know it's done with modular addition in openssl, I just don't understand how that works. Can anyone explain that to me?</p>
","<p>You can do that by adding two private keys</p>

<pre><code>privkey = privateA + privateB (mod order)
</code></pre>

<p>or, in OpenSSL code:</p>

<pre><code>BN_mod_add_quick(privkey, privateA, privateB, order);
</code></pre>

<p>Here <code>order</code> is the smallest number where <code>order = s - j</code>, such that <code>sP = jP</code> for a point P on the elliptic curve. The public key of your new private key is <code>pubkey = privkey * G</code>, or:</p>

<pre><code>EC_POINT_mul(group, pubkey, privkey, NULL, NULL, ctx);
</code></pre>

<p>The values of <code>order</code> and generator point <code>G</code> are curve parameters and are set when creating and setting <code>group</code>(an EC_GROUP object).</p>
","391","<c++><openssl><addition><ecdsa><modular-arithmetic>","0","2","2","2013-07-31 19:40:37","16205796","0","","849891","","2013-07-31 19:40:37","2013-04-24 17:10:45",""
"31017408","Should elliptic curve for public key generation and signature computation be the same?","<p>According to <a href=""https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow"">wiki</a> public key in ECDSA is multiplication of private key (random number) to some base point G on elliptic curve C. And also we have usage of C in both signing and verification. </p>

<p><strong>May I use some G1 and C1 for public key generation and other curve C2 for signing and verification?</strong></p>

<p>I know it sounds strange but <strong>my actual goal is to use GOST private keys in ECDSA</strong> (I already have them and have to use them). Hence, GOST public may be generated from special C1, G1 and Java's <code>SHA256withECDSA</code> probably uses other curve who knows.</p>

<ol>
<li>How detect curve used by <code>Signature ecdsaSign = Signature.getInstance(""SHA256withECDSA"", ""BC"");</code>?</li>
<li><p>If sign and verify returns true, does it mean that GOST keys which I gave to ECDSA are compatible with ECDSA? </p>

<pre><code>  Signature ecdsaSign = Signature.getInstance(""SHA256withECDSA"", ""BC"");
  ecdsaSign.initSign(privateKeyGOST);
  ecdsaSign.update(""aaaa"".getBytes(""UTF-8""));
  byte[] signature = ecdsaSign.sign();

  Signature ecdsaVerify = Signature.getInstance(""SHA256withECDSA"", ""BC"");
  ecdsaVerify.initVerify(publicKeyGOST);
  ecdsaVerify.update(""aaaa"".getBytes(""UTF-8""));
  System.out.println();
  System.out.println(ecdsaVerify.verify(signature));  //TRUE
</code></pre></li>
</ol>

<p>Note, that curve for GOST key generation and internal curve of <code>SHA256withECDSA</code>  may be not equal that's why I'm asking this question.</p>

<p><strong>UPDATE</strong></p>

<p>Answer to </p>

<blockquote>
  <p>May I use some G1 and C1 for public key generation and other curve C2 for signing and verification?</p>
</blockquote>

<p>No, C1 must be equal to C2. </p>

<p>It's possible to detect BC curve - I looked in SignatureSpi sources of BC and saw that curve params taken from key. And discovered C2 equals to known C1. In other words, not <code>SHA256withECDSA</code> but <code>prKey.getAlgorithm()</code> decides. </p>

<p>BUT!! Compability of keys doesn't mean that it's safe to use it. GOST curve has special invariants which may impact at some ECDSA steps - this is interesting but very hard question - is there any weak points of  GOST curves in ECDSA. So, answer is ""compatible but check carefully math staff before using"" </p>

<p><strong>Note, that KBKDF will not save from GOST curve weakness in ECDSA (if it <em>really</em> exists behind the ""math-crypto-scenes""</strong></p>
","<p>I'll answer in order:</p>

<blockquote>
  <ol>
  <li>How detect curve used by Signature ecdsaSign = Signature.getInstance(""SHA256withECDSA"", ""BC"");</li>
  </ol>
</blockquote>

<p>You can't because the public &amp; private keys should contain the parameters, not the algorithm. However, only certain curve parameters will be supported by the underlying library. In the case of Bouncy Castle those are those for the F(p) and F(2^m) curves. These include at least the NIST and Brainpool curves.</p>

<blockquote>
  <ol start=""2"">
  <li>If sign and verify returns true, does it mean that GOST keys which I gave to ECDSA are compatible with ECDSA?</li>
  </ol>
</blockquote>

<p>Yes, you can safely assume that. If that wasn't the case then there would be something seriously wrong with the verification. As you may now understand this is because C1 = C2.</p>

<hr>

<p>Note that you should not use secret keys like this, especially if the secret keys are also used for the GOST algorithm itself. It is good practice to not mix values. You should rather use the (leftmost) bytes of SHA-256 over the secret key value instead (if you <em>have</em> to use it). It would be even better to use a Key Based Key Derivation Function (KBKDF).</p>
","388","<java><digital-signature><bouncycastle><ecdsa><gost3410>","3","3","1","2015-06-26 02:53:12","31031418","0","","2104560","","2015-06-26 02:53:12","2015-06-24 04:03:39",""
"29471315","Get the reason of CryptoException in JavaCard","<p>I am trying to implement ECDSA in JavaCard (Eclipse 4.4.2, JC 2.2.1). My card is a Gemalto IDCore 3010, or at least it is supposed to be (after checking the ATR code it looks like, that it is a WM GX4 72 DHS TSA...).</p>

<p>Anyway, if I don't surround the <em>objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192)</em> line with try and catch I get an unknown error (<em>send_APDU() returns 0x80206F00 (Unknown ISO7816 error: 0x6F00)</em>), but when I do surround it, it returns no error (<em>send_APDU() returns 0x80209000 (9000: Success. No error.)</em>). However it must go to the catch block because the other three lines in the try block don't get executed.</p>

<p><strong>How can I visualize the error message?</strong> If I go with <em>ISOException.throwIt(reason)</em>, I get <em>Communication error with the intelligent card. Please try it again.</em> multiple times.</p>

<p>In <a href=""https://stackoverflow.com/questions/24066444/how-to-sign-using-ecdsa-in-javacard"">this</a> thread it suggests the <em>byte reason = c.getReason()</em> code, but it won't work, not even if I cast the right side to byte.</p>

<p>Thank you!</p>

<p>Here is the relevant part of my code.</p>

<pre><code>public class ECDSATestApplet extends Applet {

    private final static byte CLS = (byte) 0xE0;
    private final static byte NOOP = (byte) 0x00;
    private final static byte GEN = (byte) 0x01;

    ...

    private final static byte[] HELLO_WORLD = new byte[] { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!' };

    private ECPrivateKey objECDSAPriKey = null;
    private ECPublicKey objECDSAPubKey = null;
    private KeyPair objECDSAKeyPair = null;
    private Signature objECDSASign = null;

    final static short BAS = 0;

    private ECDSATestApplet() {
    }

    public static void install(byte[] bArray, short bOffset, byte bLength) {
        new ECDSATestApplet().register();
    }

    public void process(APDU apdu) {
        if (this.selectingApplet())
            return;

        byte buffer[] = apdu.getBuffer();

        if (buffer[ISO7816.OFFSET_CLA] != CLS)
            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);

        switch (buffer[ISO7816.OFFSET_INS]) {
        case NOOP:
            break;

        case GEN:
            try {
                // ------- ERROR LINE -------
                objECDSAKeyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);
//              objECDSASign = Signature.getInstance(Signature.ALG_ECDSA_SHA, false);
//              objECDSAKeyPair.genKeyPair();
//              objECDSAPriKey = (ECPrivateKey) objECDSAKeyPair.getPrivate();
//              objECDSAPubKey = (ECPublicKey) objECDSAKeyPair.getPublic();
                apdu.setIncomingAndReceive();
                Util.arrayCopyNonAtomic(HELLO_WORLD, (short) 0, buffer, (short) 0, (short) HELLO_WORLD.length);
                apdu.setOutgoingAndSend((short) 0, (short) HELLO_WORLD.length);
            } catch (CryptoException c) {
                short reason = c.getReason();
//              ISOException.throwIt(reason);
            }

            break;
        }
        return;
    }
}
</code></pre>
","<p>There are two possible reasons of your troubles:</p>

<ol>
<li><p>Your status word does not follow status words recommended by ISO7816. Try</p>

<pre><code>ISOException.throwIt((short) ((short) (0x9C00) | reason));
</code></pre>

<p>instead of</p>

<pre><code>ISOException.throwIt(reason);
</code></pre></li>
<li><p>You forgot to set parameters of your elliptic curve before generating a new key pair. You should generate your EC key pair this way:</p>

<pre><code>KeyPair keyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_FP_192);
ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
initDomainParams(pubKey);
initDomainParams(privKey);
keyPair.genKeyPair();
</code></pre>

<p>where</p>

<pre><code>private void initDomainParams(ECKey key) {
    key.setFieldFP(F, (short)0, (short)F.length);
    key.setA(A, (short)0, (short)A.length);
    key.setB(B, (short)0, (short)B.length);
    key.setG(G, (short)0, (short)G.length);
    key.setR(R, (short)0, (short)R.length);
}
</code></pre>

<p>with <code>F</code>, <code>A</code>, <code>B</code>, <code>G</code>, <code>R</code> parameters of the elliptic curve you have chosen for your signature. See the list of recommended curves here: <a href=""http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf"" rel=""nofollow"">http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf</a></p></li>
</ol>
","387","<smartcard><javacard><ecdsa>","2","3","1","2015-04-12 18:01:11","29484934","14","3","-1","","2017-05-23 12:14:17","2015-04-06 12:26:37",""
"44829426","Can I create a JCE ECPublicKey from a Q value from an openssh public key and ECParameterSpec","<p>I'm reading openssh format elliptic curve public keys (<a href=""https://tools.ietf.org/html/rfc5656#section-3.1"" rel=""nofollow noreferrer"">RFC 5656, section 3.1</a>) and would like to get from a BigInteger Q value to an <code>ECPublicKey</code> instance using JCE (rather than say BouncyCastle). I want to do this to verify <a href=""https://jwt.io"" rel=""nofollow noreferrer"">JWT</a> signatures.</p>

<p>e.g. <a href=""https://api.github.com/users/davidcarboni/keys"" rel=""nofollow noreferrer"">https://api.github.com/users/davidcarboni/keys</a>: </p>

<pre><code>ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK8hPtB72/sfYgNw1WTska2DNOJFx+QhUxuV6OLINSD2ty+6gxcM8yZrvMqWdMePGRb2cGh8L/0bGOk+64IQ/pM=
</code></pre>

<p>It looks like I can use <code>ECPublicKeySpec</code>. This takes two parameters. An <code>ECPoint</code> and an <code>ECParameterSpec</code>. I'm able to get the parameter spec using the following JCE code (and the openssh identifier from the key data, say ""nistp256""):</p>

<pre><code>ECParameterSpec getECParameterSpec(String identifier) {
    try {
        AlgorithmParameters parameters = AlgorithmParameters.getInstance(""EC"");
        String name = identifier.replace(""nist"", ""sec"") + ""r1"";
        parameters.init(new ECGenParameterSpec(name));
        return parameters.getParameterSpec(ECParameterSpec.class);
    } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
        throw new IllegalArgumentException(""Unable to get parameter spec for identifier "" + identifier, e);
    }
}
</code></pre>

<p>I've successfully parsed the Q value from the key data. RFC 5656 tells me that ""Q is the public key encoded from an elliptic curve point into an octet string"") however the constructor of JCE's <code>ECPoint</code> class takes two parameters, X and Y.</p>

<p>Can I get to X and Y from Q, or do I need to take a different approach? </p>

<p>(NB I quite rightly don't have access to the private key)</p>
","<p>The base64 portion of your input has the equivalent hex of</p>

<pre><code>00 00 00 13 65 63 64 73 61 2D 73 68 61 32 2D 6E 
69 73 74 70 32 35 36 00 00 00 08 6E 69 73 74 70 
32 35 36 00 00 00 41 04 AF 21 3E D0 7B DB FB 1F 
62 03 70 D5 64 EC 91 AD 83 34 E2 45 C7 E4 21 53 
1B 95 E8 E2 C8 35 20 F6 B7 2F BA 83 17 0C F3 26 
6B BC CA 96 74 C7 8F 19 16 F6 70 68 7C 2F FD 1B 
18 E9 3E EB 82 10 FE 93 
</code></pre>

<p>65 63 64 jumped out to me as ""ecd"" (sure enough, ""ecdsa-sha2-nistp256"").</p>

<p>So the blob looks to be</p>

<ul>
<li>Big Endian length of a string/payload (19)</li>
<li>The string ""ecdsa-sha2-nistp256""</li>
<li>Big Endian length of a string/payload (8)</li>
<li>The string ""nistp256""</li>
<li>Big Endian length of a payload (0x41 == 65)</li>
<li>The encoded ECPoint Q (<code>04 AF 21 ... 10 FE 93</code>)</li>
</ul>

<p>The encoded ECPoint starts with <code>04</code> indicating it is an uncompressed point (the most common encoding).  The <code>04</code> encoding rules (from <a href=""http://www.secg.org/sec1-v2.pdf"" rel=""nofollow noreferrer"">http://www.secg.org/sec1-v2.pdf</a>, 2.3.5, step 3) say that the remaining payload is X and Y, each left-padded with zeros to the encoding size of the curve field.</p>

<p>So your ECPoint looks like</p>

<pre><code>04
Qx:
AF 21 3E D0 7B DB FB 1F 62 03 70 D5 64 EC 91 AD
83 34 E2 45 C7 E4 21 53 1B 95 E8 E2 C8 35 20 F6
Qy:
B7 2F BA 83 17 0C F3 26 6B BC CA 96 74 C7 8F 19
16 F6 70 68 7C 2F FD 1B 18 E9 3E EB 82 10 FE 93
</code></pre>

<p>In C# you'd need to a) reverse the bytes of each of Qx and Qy (because the .NET BigInteger expects Little Endian, and these are Big Endian) and b) put a padding 0x00 byte as more significant than the 0xAF and 0xB7 bytes, since they have their high bits set (and would be interpreted as negative numbers).  Don't know if Java has either of those quirks.</p>
","384","<java><openssh><jce><elliptic-curve><ecdsa>","0","0","1","2017-06-30 14:57:18","44849385","0","","","","","2017-06-29 15:32:33",""
"31289849","Generating ECDSA public key at host side from W parameter","<p>I want to send the public key of the private-public key pair (ECDSA) generated in my applet to the host application/terminal. </p>

<p>In RSA normally i would send the modulus and exponent and will generate the public key at the host side.</p>

<p>In ECDSA i read from the link that we can do the same if you take the W parameter bytes outside the card <a href=""https://stackoverflow.com/questions/30356745/encode-publickey-on-java-card"">Click here: Stackoverflow Answer: encode public key on Java</a></p>

<p>I have the W bytes from the card now. can someone suggest how to create the public key from this?</p>
","<p>I wrote this method to convert an EC Public key into <code>java.security.interfaces.ECPublicKey</code> key object. To do this I use Bouncy Castle provider (<code>bcprov-ext-jdk16-1.46.jar</code>). You can download the latest version from <a href=""https://www.bouncycastle.org/latest_releases.html"" rel=""nofollow"">here</a>.</p>

<pre><code>/**
 * This method converts the EC public key (ECPublicKey#getW()) into ECPublicKey
 * @param cardPublicKey as W
 * @param curveName (for example ""P-224"")
 * @return java.security.interfaces.ECPublicKey
 */
public ECPublicKey ucPublicKeyToPublicKey(byte[] cardPublicKey, String curveName) {
    //for example curveName = ""P-224"";
    java.security.interfaces.ECPublicKey ecPublicKey = null; // java.security.interfaces.ECPublicKey
    java.security.KeyFactory kf = null;

    org.bouncycastle.jce.spec.ECNamedCurveParameterSpec ecNamedCurveParameterSpec = ECNamedCurveTable.getParameterSpec(curveName);
    org.bouncycastle.math.ec.ECCurve curve = ecNamedCurveParameterSpec.getCurve();
    java.security.spec.EllipticCurve ellipticCurve = EC5Util.convertCurve(curve, ecNamedCurveParameterSpec.getSeed());
    java.security.spec.ECPoint ecPoint = ECPointUtil.decodePoint(ellipticCurve, cardPublicKey);
    java.security.spec.ECParameterSpec ecParameterSpec = EC5Util.convertSpec(ellipticCurve, ecNamedCurveParameterSpec);
    java.security.spec.ECPublicKeySpec publicKeySpec = new java.security.spec.ECPublicKeySpec(ecPoint, ecParameterSpec);

    try {
        kf = java.security.KeyFactory.getInstance(""EC"", ""BC"");
    } catch (Exception e) {
        System.out.println(""Caught Exception kf : "" + e.toString());
    }

    try {
        ecPublicKey = (ECPublicKey) kf.generatePublic(publicKeySpec);
    } catch (Exception e) {
        System.out.println(""Caught Exception public key: "" + e.toString());
    }

    return ecPublicKey;
}
</code></pre>
","376","<java><javacard><elliptic-curve><ecdsa>","3","2","1","2015-07-11 13:48:16","31301261","0","2","-1","","2017-05-23 12:29:46","2015-07-08 10:22:42",""
"45470941","Create ASN.1 from two big integers","<p>I have a java program using an HSM that with the native API gives me and R and S value of an ECDSA signature which is just the two Big Integers. I need to take those Integers and create ASN.1 encoding. Any idea on how I could do that? I do have BouncyCastle up and running but, I am not familiar with the options available to me.</p>
","<p>A small example to illustrate:</p>

<pre><code>import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.DERSequence;

import javax.xml.bind.DatatypeConverter;
import java.math.BigInteger;

public class Main {

    public static void main(String[] args) throws Exception {
        BigInteger r = new BigInteger(""29128391823901823918293108120938102381912839182390182391829310812093810238199"");
        BigInteger s = new BigInteger(""38663726871681756650018917824777578348866372687168175665001891782477757834811"");

        ASN1Integer asn1R = new ASN1Integer(r);
        ASN1Integer asn1S = new ASN1Integer(s);

        DERSequence seq = new DERSequence(new ASN1Integer[]{asn1R, asn1S});
        byte[] encoded = seq.getEncoded();
        System.out.println(DatatypeConverter.printHexBinary(encoded));
    }
}
</code></pre>
","363","<java><bouncycastle><asn.1><ecdsa>","0","3","1","2017-08-03 00:54:42","45473131","0","","","","","2017-08-02 21:02:12",""
"51951185","Create any PrivateKey instance (RSA or DSA or EC) from PKCS8 encoded data","<p>I have an unencrypted PKCS8 encoded file that represents a Private Key. It can be any of these private key types - RSA, DSA or EC. I viewed these files in an ASN1 decoder (<a href=""https://lapo.it/asn1js/"" rel=""nofollow noreferrer"">https://lapo.it/asn1js/</a>) and I could see the type (RSA, DSA or EC) in the data.</p>

<p>Is there a way to read the PKC8 private key data into the correct Private Key Java object without specifying the key type in code like this - </p>

<pre><code>PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(pkcs8key);
KeyFactory factory = KeyFactory.getInstance(""RSA""); // Avoid ""RSA"" here?
PrivateKey privateKey = factory.generatePrivate(spec);
</code></pre>

<p>Is there a way to avoid specifying the algorithm in <code>KeyFactory.getInstance(""RSA"")</code>? Shouldn't this be determined from the <code>PKCS8EncodedKeySpec</code> since it is available in the PKCS8 data?</p>

<p>Sample unencrypted PKCS8 data and their ASN1 decodings which show the key type - </p>

<p>DSA - <a href=""https://lapo.it/asn1js/#3082025C0201003082023506072A8648CE3804013082022802820101008F7935D9B9AAE9BFABED887ACF4951B6F32EC59E3BAF3718E8EAC4961F3EFD3606E74351A9C4183339B809E7C2AE1C539BA7475B85D011ADB8B47987754984695CAC0E8F14B3360828A22FFA27110A3D62A993453409A0FE696C4658F84BDD20819C3709A01057B195ADCD00233DBA5484B6291F9D648EF883448677979CEC04B434A6AC2E75E9985DE23DB0292FC1118C9FFA9D8181E7338DB792B730D7B9E349592F68099872153915EA3D6B8B4653C633458F803B32A4C2E0F27290256E4E3F8A3B0838A1C450E4E18C1A29A37DDF5EA143DE4B66FF04903ED5CF1623E158D487C608E97F211CD81DCA23CB6E380765F822E342BE484C05763939601CD667021D00BAF696A68578F7DFDEE7FA67C977C785EF32B233BAE580C0BCD5695D0282010016A65C58204850704E7502A39757040D34DA3A3478C154D4E4A5C02D242EE04F96E61E4BD0904ABDAC8F37EEB1E09F3182D23C9043CB642F88004160EDF9CA09B32076A79C32A627F2473E91879BA2C4E744BD2081544CB55B802C368D1FA83ED489E94E0FA0688E32428A5C78C478C68D0527B71C9A3ABB0B0BE12C44689639E7D3CE74DB101A65AA2B87F64C6826DB3EC72F4B5599834BB4EDB02F7C90E9A496D3A55D535BEBFC45D4F619F63F3DEDBB873925C2F224E07731296DA887EC1E4748F87EFB5FDEB75484316B2232DEE553DDAF02112B0D1F02DA30973224FE27AEDA8B9D4B2922D9BA8BE39ED9E103A63C52810BC688B7E2ED4316E1EF17DBDE041E021C720364A41E5FC98E40C2A60C51545DFB3AA9570F491201A0FBCE7084"" rel=""nofollow noreferrer"">link</a></p>

<p>EC - <a href=""https://lapo.it/asn1js/#308193020100301306072A8648CE3D020106082A8648CE3D030107047930770201010420E86CA2FDFBF7680D0D52DBDD45F70D50301AAA8A2776585637AF93F46F96DE1AA00A06082A8648CE3D030107A14403420004EAD0E446F54B2220298FA02F4DCE8FC7FCA87E0B721304752927BCF8AEDECD0E022836343D04BF0DC67BA71094F433B7928B2B325F75B42F3EC7CC3218D0ED2E"" rel=""nofollow noreferrer"">link</a></p>

<p>RSA - <a href=""https://lapo.it/asn1js/#308204BE020100300D06092A864886F70D0101010500048204A8308204A40201000282010100B21DC7FB95A945EA7C543E09CDE48BEE224F677C8EE6DF39B55BFB2CD2FC07B3D00585607C667B9ECA25AB595AD4F52A94C65131C0248CF2E5EB8016D3BABF97BD77866D854B7D59C77627C2930F24F775203082A72797397CBF5D76464A75B3547E86679359080939E5FDF7A203946BF6E241191812A5BF17190AEDDDFEC6351300AB9DAAC4455B7F216527EA9FEB7B06F546E59B49BFDEBCD4A5EFB0742A2CE426F0A0B65984F05EE625A0820F3691EC38090AEEE427F6CE6CCBC7D76CC9C9F275AB44B12E9FA961F2EAF13AA105AA50D495302183AFBB27A40E7B9249F649BBF5B3A0C09686B1294F7EDA08298C4FB5ADF86F5BC05617C5954E5CE09D764D0203010001028201000E479E9E5817D0EAA5301879D9BF6921322FFD2DCFC3C901613DB0169E62FAA2705AD8F56CD3C73514F8CDD2CFEF987E384793FFDC95DC3FA70393EA8096B815E1689691963E55F234DB0F574FF49C0943787805D42D338DB62773709ADF0D03A5125B12826380BB98A0374066054A736E1622939BF4A16ED4AFBB20148C55F5E363B10285889641698441032EDDB936447C783723B48D7E2DA1D10C3855DD2669FAB0063BD9228B20A467B5003E7B14A05D25ADFFB4A8E45535B0AE99A1CFDB49373FA3749B355757C192FC539B0EEBE176776730B2A9D50FCECBBEAB618418F6467BDD85BB789BC635CE825C2C3787E44CE93EB92ACB8687296193534A6C4302818100E0AAFD402788478997CA0E4464FA4DC78ADEE3CE5A55FB9607A57828896CD6ACA82069BF0352CA0C16C5A2FED073BFF6832692C10D0E29E1919C02F0B5B267A75313A674BD66AED6C7990D26C8FF223F0625984FD69048D0158B39A95B1BF406A06647336185B1EF602592950A57701AD71E2FB79D6A9CDAECADC9DAEAA15B3F02818100CAF4D300BDD1992C8C516D1E245BFBB89D88531CC790ADAA4943383C43B2BA239D096084136204AFBFC1D71B259E41D7BB84DA5183502F856AF8BA03AC8115DAAFF48962EC0EFB5401D1A1EE571FDA53BB4842EA9186810E2F6934B3B99413B2B0A7EEBECEB7219909A30BDBBFA1415621970ECEC4FE2896471CD569206D477302818051D27441352490C92F9ACAEF65C733248512FFEC5B420D4A6AA67CC866A458DAB0B07D52AFA72B2693F48E9436DEB0FEDA6CE5EDA10F93792F4A9E578414E163330269110319AE7B525E0F481CD3AE693D97DB8CD81BDC28CC6FD42435A64C8D4D457290E7E7851224F60A187597BAA04BD01698CC9FD35877F2231DB36DE88902818100A69196574672AE4F047E939AA866A1CA5BE815A64A1770A0906E4DCA1019B071282219076CCD0661A37498715C476D6C7C2745F29E5E021272BFDE12C3D251B860AEC6CEDC44537B17DF10128788C9EBEC8A1AF95F244FE8EF7A5DD99F566B703D52263C8D75796A9BA1284B5B142286691D0BF7217022A96B85BB95031B0D0702818100CB235A026986530EE7F4E015E565AB90A3493F2109D7F968A3341B8E652AA8BE8E0CACFC905D2EC24B750241AF30640023477A25E28AEA4873AC1EF082C698053E24B4059D2BEC75EFDF1A100ED4B0EC4D31CDC35AF2357063A8C67025D1D577D773B7B0B27C2FF69367F11D2238E36D20693273682A1F0B7009C8DB0F3008EB"" rel=""nofollow noreferrer"">link</a></p>
","<p>This can be achieved with the help of BouncyCastle APIs - </p>

<pre><code>/** Read a PKCS#8 format private key. */
private static PrivateKey readPrivateKey(InputStream input)
throws IOException, GeneralSecurityException {
    try {
        byte[] buffer = new byte[4096];
        int size = input.read(buffer);
        byte[] bytes = Arrays.copyOf(buffer, size);
        /* Check to see if this is in an EncryptedPrivateKeyInfo structure. */
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(bytes);
        /*
         * Now it's in a PKCS#8 PrivateKeyInfo structure. Read its Algorithm
         * OID and use that to construct a KeyFactory.
         */
        ASN1InputStream bIn = new ASN1InputStream(new ByteArrayInputStream(spec.getEncoded()));
        PrivateKeyInfo pki = PrivateKeyInfo.getInstance(bIn.readObject());
        String algOid = pki.getPrivateKeyAlgorithm().getAlgorithm().getId();
        return KeyFactory.getInstance(algOid).generatePrivate(spec);
    } finally {
        input.close();
    }
}
</code></pre>
","355","<java><rsa><ecdsa><java-security><pkcs#8>","1","2","1","2018-08-29 10:01:50","52074721","6","","255872","","2018-08-22 09:10:09","2018-08-21 14:41:22",""
"51685529","Generating the 256bit ECDSA private key","<p>I want to make an 256 bit <code>ECDSA</code> private key with <code>secp256k1</code> curve by php.</p>

<p>I used this snippet:</p>

<pre><code>$pk_Generate = openssl_pkey_new(array(
    'private_key_bits' =&gt; 256,
    'private_key_type' =&gt; OPENSSL_KEYTYPE_EC,
    'curve_name' =&gt; 'secp256k1'
));

while ($msg = openssl_error_string())
    echo $msg . ""&lt;br /&gt;\n"";

openssl_pkey_export($pk_Generate, $pk_Generate_Private);
var_dump($pk_Generate_Private); // show me NULL
</code></pre>

<p>but it give me this error:</p>

<pre><code>error:0E06D06C:configuration file routines:NCONF_get_string:no value
error:0E06D06C:configuration file routines:NCONF_get_string:no value
error:0E06D06C:configuration file routines:NCONF_get_string:no value
error:0E06D06C:configuration file routines:NCONF_get_string:no value
</code></pre>

<p>also if this code works fine, it shows me private key in <code>PEM</code> format but I want it in hex string format.</p>

<p>please guide me.</p>
","<p>Try this</p>

<pre><code>$config = [
    ""config"" =&gt; getenv('OPENSSL_CONF'),
    'private_key_type' =&gt; OPENSSL_KEYTYPE_EC,
    'curve_name' =&gt; 'secp256k1'
];
$res = openssl_pkey_new($config);
if (!$res) {
    echo 'ERROR: Fail to generate private key. -&gt; ' . openssl_error_string();
    exit;
}
// Generate Private Key
openssl_pkey_export($res, $priv_key, NULL, $config);
// Get The Public Key
$key_detail = openssl_pkey_get_details($res);
$pub_key = $key_detail[""key""];

echo ""priv_key:&lt;br&gt;"".$priv_key;
echo ""&lt;br&gt;&lt;br&gt;pub_key:&lt;br&gt;"".$pub_key;
</code></pre>
","351","<php><private-key><ecdsa>","0","0","1","2018-11-19 18:40:19","","0","","","","","2018-08-04 12:25:26",""
"27160792","openssh ecdsa sign verify but is wrong","<p>I've written some C code witch should sign an hash.
It seems to work fine; sign, generate public key and verify correctly.
but then using the sign result into another know-working code give me a key verification error (the sign is used over a bitcoin transaction)</p>

<p>Testing code is working fine, it can sign and verify, also used a third library (bitcoin's own implementation) and again it works fine.</p>

<p>So there is a bug in how I use OpenSSH but I can't find it. Any help appreciated, thanks.</p>

<p>Here the sign generator compiled with <code>gcc -g -lssl -lcrypto</code></p>

<pre><code>#include &lt;openssl/ec.h&gt; // for EC_GROUP_new_by_curve_name, EC_GROUP_free, EC_KEY_new, EC_KEY_set_group, EC_KEY_generate_key, EC_KEY_free
#include &lt;openssl/ecdsa.h&gt;  // for ECDSA_do_sign, ECDSA_do_verify
#include &lt;openssl/obj_mac.h&gt;    // for NID_secp192k1
#include &lt;openssl/sha.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
int create_signature (uint8_t * hash, int len)
{
    /*
    / */ convert priv key from hexadecimal to BIGNUM
    uint8_t hex[] =
    { 0x0C, 0xAE, 0xCF, 0x01, 0xD7, 0x41, 0x02, 0xA2, 0x8A, 0xED, 0x6A, 0x64,
    0xDC, 0xF1, 0xCF, 0x7B, 0x0E, 0x41, 0xC4, 0xDD, 0x6C, 0x62, 0xF7, 0x0F, 0x46, 0xFE,
    0xBD, 0xC3, 0x25, 0x14, 0xF0, 0xBD };*/
    EC_KEY *eckey = NULL;
    EC_POINT *pub_key = NULL;
    const EC_GROUP *group = NULL;
    BIGNUM start;
    BIGNUM *res;
    BN_CTX *ctx;
    BN_init(&amp;start);
    ctx = BN_CTX_new(); // ctx is an optional buffer to save time from allocating and deallocating memory whenever required
    res = &amp;start;
    BN_hex2bn(&amp;res,""0caecf01d74102a28aed6a64dcf1cf7b0e41c4dd6c62f70f46febdc32514f0bd"");
    eckey = EC_KEY_new_by_curve_name(NID_secp256k1);
    group = EC_KEY_get0_group(eckey);
    EC_KEY_set_private_key(eckey, res);
    int function_status = -1;
    if (NULL == eckey)
    {
        printf (""\nFailed to create new EC Key\n"");
        function_status = -1;
    } else {
        unsigned int nSize = ECDSA_size(eckey);
        uint8_t ris[nSize];
        if (!ECDSA_sign(0, hash, sizeof(hash), ris, &amp;nSize, eckey)){
            printf (""\nFailed to generate EC Signature\n"");
        } else {
            printf (""\nOK to generate EC Signature len: %d \n"", nSize);
            for (int i=0;i&lt;nSize; i++) {
                printf (""%02X"", ris[i]);
            }
            {
                pub_key = EC_POINT_new(group);
                if (!EC_POINT_mul(group, pub_key, res, NULL, NULL, ctx))
                    printf(""Error at EC_POINT_mul.\n"");
                EC_KEY_set_public_key(eckey, pub_key);
                char *cc = EC_POINT_point2hex(group, pub_key, 4, ctx);
                char *c=cc;
                int i;
                printf(""\npublic key:"");
                for (i=0; i&lt;130; i++) // 1 byte 0x42, 32 bytes for X coordinate, 32 bytes for Y coordinate
                {
                    printf(""%c"", *c++);
                }
                free(cc);
            }
            int verify_status = ECDSA_verify(0, hash, sizeof(hash), ris, nSize, eckey);
            const int verify_success = 1;
            if (verify_success != verify_status)
            {
                printf(""\nFailed to verify EC Signature\n"");
                function_status = -1;
            } else {
                printf(""\nVerifed EC Signature\n"");
                function_status = 1;
            }
        }
        EC_KEY_free (eckey);
    }
    return function_status;
}

int main() {
    uint8_t double_hash[] = { 0x5f,0xda,0x68,0x72,0x9a,0x63,0x12,0xe1,0x7e,0x64,0x1e,0x9a,0x49,0xfa,0xc2,0xa4,0xa6,0xa6,0x80,0x12,0x66,0x10,0xaf,0x57,0x3c,0xaa,0xb2,0x70,0xd2,0x32,0xf8,0x50 };
    printf (""\nhash len: %d \n"", sizeof(double_hash));
    create_signature( double_hash, sizeof(double_hash) );
}
</code></pre>
","","341","<c><openssl><bitcoin><ecdsa>","0","","0","2014-11-27 00:44:32","","8","","589259","","2014-11-27 00:44:32","2014-11-26 23:40:58",""
"43307000","ECDSA signature - Is a conclusion to the used key possible?","<p>I noticed that if I used the <code>ECDsa.SignData</code> Method I always get different ECDSA signature.</p>

<p><strong>So I wonder if it is possible to conclude from the ECDSA signature to the used key?</strong></p>

<p>If Alice sends a message to Bob1 and Bob2, can Eve determine without the public from Alice that the signatures are from the same sender?</p>

<pre><code>public static byte[] SignData(KeyPair privateKeyPair, byte[] data)
{
    var ecDsa = ECDsa.Create(ECCurve.NamedCurves.brainpoolP320r1);
    ecDsa.ImportParameters(privateKeyPair.CreateECParameters());
    return ecDsa.SignData(data, HashAlgorithmName.SHA512);
}

public static bool VerifyData(KeyPair signedKeyPair, byte[] data, byte[] signature)
{
    var ecDsa = ECDsa.Create(ECCurve.NamedCurves.brainpoolP320r1);
    ecDsa.ImportParameters(signedKeyPair.CreateECParameters());
    return ecDsa.VerifyData(data,signature, HashAlgorithmName.SHA512);
}

var plainMsg = Encoding.UTF8.GetBytes(""Hello World"");
var keyPair = BrainpoolKeyGenerator.CreateKeyPair(true);

var signature1 = SignData(keyPair, plainMsg);
var signature2 = SignData(keyPair, plainMsg);

Assert.That(signature1,Is.Not.EquivalentTo(signature2), ""Signature #1 and #2 are NOT equal"");

Assert.That(VerifyData(keyPair.ExportPublicKey(), plainMsg, signature1), ""Signature of #1 is valid"");
Assert.That(VerifyData(keyPair.ExportPublicKey(), plainMsg, signature2), ""Signature of #2 is valid"");
</code></pre>
","<p>No, having two ECDSA signatures over the same data doesn't reveal if it was signed by the same party twice or two different parties.</p>

<p>In order to talk about how ECDSA works we need some quick (loosely defined) terms:</p>

<ul>
<li><code>G</code>, the Generator, is a point on the curve.

<ul>
<li>The public key associated with a private key (<code>d</code>) for a curve is <code>d * G</code>, using curve math we won't talk about here.</li>
<li>For brainpoolP320r1 the G value is broken down as <code>x</code> and <code>y</code> in <a href=""https://tools.ietf.org/html/rfc5639#section-3.5"" rel=""nofollow noreferrer"">RFC5639, section 3.5</a>.</li>
</ul></li>
<li><code>n</code>, the curve Order, is the biggest legal value for <code>d</code> given <code>G</code>.

<ul>
<li>RFC5639 calls this value <code>q</code>, but most everything else calls it <code>n</code>.</li>
</ul></li>
</ul>

<p>There's a breakdown of ECDSA on <a href=""https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">Wikipedia</a>, but the gist of the formula is:</p>

<ul>
<li>Create a random number <code>k</code> such that <code>0 &lt; k &lt; n</code></li>
<li><code>r</code> is an integer equal to the X coordinate of the EC Point <code>k * G</code></li>
<li>Let <code>z</code> be the message digest interpreted as a number (with some trimming/extension)</li>
<li>Let <code>kInv</code> be the inverse of <code>k</code> modulo <code>n</code> (see also the <a href=""https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_integers"" rel=""nofollow noreferrer"">Extended Euclidean Algorithm</a>).</li>
<li>Let <code>s</code> be <code>kInv * (z + (r * d)) mod n</code></li>
<li>The signature is (<code>r</code>, <code>s</code>).

<ul>
<li>In .NET the (r, s) value is represented in the IEEE P1363 format, which means the first half is <code>r</code> and the second half is <code>s</code>, their lengths determined by the curve.</li>
</ul></li>
</ul>

<p>So, the first half of the signature is effectively a random number. Elliptic Curve Cryptography is based on the fact that it's hard to compute <code>Q / G</code> (where Q is the public key, aka a point on the curve), so recovering <code>k</code> from <code>r</code> is hard.</p>

<p>The second half of the signature (<code>s</code>) is the only part where the signer key is involved, but it gets beat up a lot by <code>k</code>.</p>

<p>The signature verification algorithm then checks if <code>Q</code> and <code>z'</code> (the verifier's version of <code>z</code>), combined with <code>r</code> and <code>s</code> make a formula balance.  If it doesn't, there's no indication of whether it was because the hash/digest was wrong or the public key was wrong.</p>
","336","<c#><.net><ecdsa><.net-standard-1.6><.net-4.7>","0","1","1","2017-04-10 15:06:24","43326727","0","","","","","2017-04-09 13:04:14",""
"20815035","How to verify a ECC signature with OpenSSL command?","<p>I have a public key, a 192 bit hash, and a 384 bit signature, all as .txt hex files, and the curve is prime192v1.</p>

<p>What command lines can I use to verify the message with OpenSSL?</p>
","","332","<command-line><openssl><ecdsa>","1","","0","2013-12-28 13:20:48","","0","","","","","2013-12-28 13:20:48",""
"30356745","Encode publicKey on Java Card","<p>How to encode an ECDSA PublicKey on Java Card so that after I can decode it on another platform (e.g. sending the encoded key in a response APDU and processing it in a standard Java application)? <code>keyPair.getPublic().getEncoded()</code> on Java would do the trick with PKCS#8 encoding, but as far as I know <code>getEncoded()</code> is not available on the Java Card platform.</p>
","<p><code>getEncoded()</code> method returns the key in its primary encoding format, or null if the key does not support encoding. So you don't need to use it for your goal. you simply can use down-casting to <code>ECPublicKey</code>:</p>

<pre><code>ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic()
</code></pre>

<p>The <code>pubKey</code> in the above line, is equal with output of <code>getEncoded()</code> method in Java applications.</p>
","327","<java><encoding><javacard><ecdsa><pkcs#8>","2","1","2","2016-01-08 15:58:25","30367105","0","2","288456","","2016-01-08 15:58:25","2015-05-20 17:41:20",""
"30356745","Encode publicKey on Java Card","<p>How to encode an ECDSA PublicKey on Java Card so that after I can decode it on another platform (e.g. sending the encoded key in a response APDU and processing it in a standard Java application)? <code>keyPair.getPublic().getEncoded()</code> on Java would do the trick with PKCS#8 encoding, but as far as I know <code>getEncoded()</code> is not available on the Java Card platform.</p>
","<p>You can implement this function like this:</p>

<p><strong>Card side:</strong></p>

<ul>
<li>1 KeyPair.getPublicKey() --> publicKey;</li>
<li>2 publicKey.getW() --> W;</li>
<li>3 Send W to outside;</li>
</ul>

<p><strong>Standard java application side:</strong></p>

<ul>
<li>1 get W data bytes;</li>
<li>2 W data bytes --> ECPoint;</li>
<li>3 Build PublicKey with the ECPoint generated in step 2 use the class ECPublicKeySpec;</li>
<li>4 Use the public key in your application;  </li>
</ul>
","327","<java><encoding><javacard><ecdsa><pkcs#8>","2","4","2","2016-01-08 15:58:25","30367105","0","2","288456","","2016-01-08 15:58:25","2015-05-20 17:41:20",""
"50685865","In C# How to verify JWT using ECDSA public key which was signed with ECDSA private key","<p>I want to verify jwt which was signed through ECDSA SHA256 algorithm. Dot net library I am using is System.IdentityModel.Tokens.Jwt .
I have access to public key. </p>
","<p>If you have the access to the public key, one way of doing it is to utilise <code>JwtSecurityTokenHandler</code> class which is also used to generate the Jwt. It is under the same namespace (<code>System.IdentityModel.Tokens</code>).</p>

<p>Sample code: </p>

<pre><code>bool ValidateEcdsa384JwtToken(string tokenString, ECDsa pubKey) 
{
    try
    {
        var securityToken = new JwtSecurityToken(tokenString);
        var securityTokenHandler = new JwtSecurityTokenHandler();
        var validationParameters = new TokenValidationParameters() {
            ValidIssuer = securityToken.Issuer,
            ValidAudience = securityToken.Audiences.First(),
            IssuerSigningKey = new ECDsaSecurityKey(pubKey)
        };

        SecurityToken stoken;
        var claims = securityTokenHandler.ValidateToken(tokenString, validationParameters, out stoken);
        return true;
    }
    catch (System.Exception e)
    {
        return false;
    }
}
</code></pre>
","326","<c#><validation><jwt><ecdsa>","1","1","1","2018-08-17 01:14:07","","2","","","","","2018-06-04 17:30:30",""
"51932108","Failing to verify ECDSA signature","<p>I have a signature:</p>

<blockquote>
  <p>3044022014d647cd08f1ea5b31d1e6539b6cbceb9182f6e7b2e29fb969354ef7e3434923022028bb4eda36af410149baa936322e7c0e46cc5540a3aa89c811bc3c360028bfd301</p>
</blockquote>

<p>a hash</p>

<blockquote>
  <p>f27c6c3aa42563c958292922be1e53fe107f4db0dfadba11122f0b12bf77f3ab</p>
</blockquote>

<p>and a pubkey</p>

<blockquote>
  <p>04b0bd634234abbb1ba1e986e884185c61cf43e001f9137f23c2c409273eb16e6537a576782eba668a7ef8bd3b3cfb1edb7117ab65129b8a2e681f3c1e0908ef7b</p>
</blockquote>

<p>Below is my Go code to verify the signature but it fails! I have information that the three pieces should validate OK and some other person has verified them in other ways. So I want to kown what mistake in this Go code make me get the false result.</p>

<p>if you want more informationthis link is about how i build my signature and how someone say he success verify in other ways. I feel helpless now:
<a href=""https://bitcointalk.org/index.php?topic=4879014.msg43992837#msg43992837"" rel=""nofollow noreferrer"">https://bitcointalk.org/index.php?topic=4879014.msg43992837#msg43992837</a></p>

<pre><code>package main

import (
    ""crypto/ecdsa""
    ""crypto/elliptic""
    ""encoding/hex""
    ""fmt""
    ""math/big""
)

func main() {
    pubkey, err := hex.DecodeString(""b0bd634234abbb1ba1e986e884185c61cf43e001f9137f23c2c409273eb16e6537a576782eba668a7ef8bd3b3cfb1edb7117ab65129b8a2e681f3c1e0908ef7b"")
    if err != nil {
        panic(err)
    }
    curve := elliptic.P256()
    // length
    keyLen := len(pubkey)

    x := big.Int{}
    y := big.Int{}
    x.SetBytes(pubkey[:(keyLen / 2)])
    y.SetBytes(pubkey[(keyLen / 2):])

    rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y}

    // hash
    hash, err := hex.DecodeString(""f27c6c3aa42563c958292922be1e53fe107f4db0dfadba11122f0b12bf77f3ab"")
    if err != nil {
        panic(err)
    }

    r := big.Int{}
    s := big.Int{}
    rr, err := hex.DecodeString(""14d647cd08f1ea5b31d1e6539b6cbceb9182f6e7b2e29fb969354ef7e3434923"")
    if err != nil {
        panic(err)
    }

    ss, err := hex.DecodeString(""28bb4eda36af410149baa936322e7c0e46cc5540a3aa89c811bc3c360028bfd3"")
    if err != nil {
        panic(err)
    }

    r.SetBytes(rr)
    s.SetBytes(ss)

    fmt.Printf(""%v\n"", ecdsa.Verify(&amp;rawPubKey, hash[:], &amp;r, &amp;s))    
}
</code></pre>
","<p>You are trying to use the wrong curve. P-256, also known as secp256r1, is <em>not</em> the same as the curve used in Bitcoin, which is secp256k1. Your public key doesnt correspond to a point on P-256 (you can check with <code>curve.IsOnCurve(&amp;x, &amp;y)</code>), but it <em>is</em> a point on secp256k1.</p>

<p>Golang doesnt include support for the Bitcoin curve, so you will need to find a library that does ECDSA using it.</p>

<p>I can confirm that signature does verify that data for that key if you use the correct curve.</p>
","325","<go><verify><ecdsa>","2","1","1","2019-01-28 12:47:08","","2","","7827687","","2019-01-28 12:47:08","2018-08-20 13:44:12",""
"49271512","PKCS#11 - creating ECDSA key","<p>Consider i have sample sample ECDSA public key with the following parameters:</p>

<pre><code>Point Value
03 42
00 04  C9 A3 63 92 24 9C 7C 3B
CD 6B 3D 89 F6 16 13 21  B9 AC 99 42 60 C7 4A E2
7D 4A 03 80 BE 80 47 C1  3D FA 08 70 F9 8F 9F 65
BB 81 A5 5B 7C 6B 21 ED  7F 18 82 D2 07 7A 89 5E
56 10 F6 EC AC 39 14 B5
</code></pre>

<p>and</p>

<pre><code>secp256k1
30 81 A2 02 01 01 30 2C  06 07 2A 86 48 CE 3D 01
01 02 21 00 FF FF FF FF  FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FE
FF FF FC 2F 30 06 04 01  00 04 01 07 04 41 04 79
BE 66 7E F9 DC BB AC 55  A0 62 95 CE 87 0B 07 02
9B FC DB 2D CE 28 D9 59  F2 81 5B 16 F8 17 98 48
3A DA 77 26 A3 C4 65 5D  A4 FB FC 0E 11 08 A8 FD
17 B4 48 A6 85 54 19 9C  47 D0 8F FB 10 D4 B8 02
21 00 FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
FF FE BA AE DC E6 AF 48  A0 3B BF D2 5E 8C D0 36
41 41 02 01 01 
</code></pre>

<p>These values are extracted directly private key with openssl and I belieive are ASN.1 encoded.</p>

<p>What values should I put in <strong>CKA_EC_POINT</strong> and <strong>CKA_EC_PARAMS</strong> when creating ECDSA public key on HSM? If I put these values directly to attribute is not working (I cannot f.e. validate signature).</p>
","","322","<pkcs#11><ecdsa><hsm><softhsm>","2","","0","2018-03-14 07:02:11","","0","1","","","","2018-03-14 07:02:11",""
"49045873","C# - ecc-certificate requested with BouncyCastle seems to be invalid in .NET","<p>As it turned out in the comments to <a href=""https://stackoverflow.com/questions/49024466/authenticatasclient-fails-with-crypt-e-asn1-badtag"">this SO-question</a> the source of the problem lies elsewhere so I decided to ask a new question.</p>

<p>I request a certificate from our PKI for a ecc keypair (curve is brainpoolP384r1).
This is done via registration authority that does the proof of possession. After that I attach the private key to the issued certificate using some of the code in this helpful questions/answers: <a href=""https://stackoverflow.com/questions/36624105/generate-certificate-using-ecdsa-in-c-sharp"">generate-certificate-using-ecdsa-in-c-sharp</a> and <a href=""https://stackoverflow.com/questions/48542233/translating-elliptic-curve-parameters-bc-to-ms"">translating-elliptic-curve-parameters-bc-to-ms</a>.</p>

<p>After that I store the certificate with the private key in the MY-Store. So far everything works and the certificate is shown as valid in the MMC console.
But if I look at it with <code>certutil -user -store my</code> it results in the following error (unfortunately it is in german but I will explain the errors below):</p>

<pre><code>Seriennummer: 4cce6787580be9db
Aussteller: C=DE, O=TestIt, CN=ManagementCA
 Nicht vor: 01.03.2018 08:30
 Nicht nach: 29.02.2020 08:30
Antragsteller: CN=test@my.domain
Kein Stammzertifikat
Zertifikathash(sha1): 3cd94f55fa6d1c66eff9ed1cc45649006ac12616
  Schlsselcontainer = {5C4E984A-D2DB-4BE5-BD82-7A6826C4A389}
  Eindeutiger Containername: 28083d7c2cef0143c31de128e470b486_6097f4ab-4eeb-4550-91e6-2c748bfb85d3
  Anbieter = Microsoft Software Key Storage Provider
Der private Schlssel eignet sich nicht zum Nur-Text-Export.

ffentlicher Schlssel des Zertifikats:
Version: 3
ffentlicher Schlssel-Algorithmus:
    Algorithmus Objekt-ID: 1.2.840.10045.2.1 ECC
    Algorithmusparameter:
    0000  30 82 01 40 02 01 01 30  3c 06 07 2a 86 48 ce 3d
    0010  01 01 02 31 00 8c b9 1e  82 a3 38 6d 28 0f 5d 6f
    0020  7e 50 e6 41 df 15 2f 71  09 ed 54 56 b4 12 b1 da
    0030  19 7f b7 11 23 ac d3 a7  29 90 1d 1a 71 87 47 00
    0040  13 31 07 ec 53 30 64 04  30 7b c3 82 c6 3d 8c 15
    0050  0c 3c 72 08 0a ce 05 af  a0 c2 be a2 8e 4f b2 27
    0060  87 13 91 65 ef ba 91 f9  0f 8a a5 81 4a 50 3a d4
    0070  eb 04 a8 c7 dd 22 ce 28  26 04 30 04 a8 c7 dd 22
    0080  ce 28 26 8b 39 b5 54 16  f0 44 7c 2f b7 7d e1 07
    0090  dc d2 a6 2e 88 0e a5 3e  eb 62 d5 7c b4 39 02 95
    00a0  db c9 94 3a b7 86 96 fa  50 4c 11 04 61 04 1d 1c
    00b0  64 f0 68 cf 45 ff a2 a6  3a 81 b7 c1 3f 6b 88 47
    00c0  a3 e7 7e f1 4f e3 db 7f  ca fe 0c bd 10 e8 e8 26
    00d0  e0 34 36 d6 46 aa ef 87  b2 e2 47 d4 af 1e 8a be
    00e0  1d 75 20 f9 c2 a4 5c b1  eb 8e 95 cf d5 52 62 b7
    00f0  0b 29 fe ec 58 64 e1 9c  05 4f f9 91 29 28 0e 46
    0100  46 21 77 91 81 11 42 82  03 41 26 3c 53 15 02 31
    0110  00 8c b9 1e 82 a3 38 6d  28 0f 5d 6f 7e 50 e6 41
    0120  df 15 2f 71 09 ed 54 56  b3 1f 16 6e 6c ac 04 25
    0130  a7 cf 3a b6 af 6b 7f c3  10 3b 88 32 02 e9 04 65
    0140  65 02 01 01
Lnge des ffentlichen Schlssels: 384 Bits
ffentlicher Schlssel: Nicht verwendete Bits = 0
    0000  04 0e e2 21 a3 24 11 58  28 f9 12 fe 7a 2d 26 5f
    0010  ad 90 cc 79 1c b6 68 3a  b0 ff f2 df 68 17 84 cd
    0020  5f a7 9e 27 10 00 ea 6a  47 d2 74 9f c4 15 36 d1
    0030  98 5e 65 5b 2e 7e 61 d4  16 85 ed 3f 24 6b c1 2c
    0040  ef 48 b2 26 77 2b c3 61  05 44 e3 1c 2a 31 cb c1
    0050  f6 e1 cc a2 d6 3e d8 ac  36 8f ea e7 df 7d b0 9d
    0060  9d
Schlssel-ID-Hash(rfc-sha1): e90f7f6c93e660db6742585d6dd5327f08e2469b
Schlssel-ID-Hash(sha1): 1a0440ec89a6b951169c97d7d766c477c5a9128d
Schlssel-ID-Hash(bcrypt-sha1): 66a3af2d30d59c36337fcf153693e6bc0111c14b
Schlssel-ID-Hash(bcrypt-sha256): cfdf5d9b466f595f9c23dec4430a19b5134f41c882bea709ab120ed1c2496ce9

Container des ffentlichen Schlssels:
ffentlicher Schlssel-Algorithmus:
    Algorithmus Objekt-ID: 1.2.840.10045.2.1 ECC
    Algorithmusparameter:
    06 09 2b 24 03 03 02 08  01 01 0b
        1.3.36.3.3.2.8.1.1.11 brainpoolP384r1
Lnge des ffentlichen Schlssels: 384 Bits
ffentlicher Schlssel: Nicht verwendete Bits = 0
    0000  04 0e e2 21 a3 24 11 58  28 f9 12 fe 7a 2d 26 5f
    0010  ad 90 cc 79 1c b6 68 3a  b0 ff f2 df 68 17 84 cd
    0020  5f a7 9e 27 10 00 ea 6a  47 d2 74 9f c4 15 36 d1
    0030  98 5e 65 5b 2e 7e 61 d4  16 85 ed 3f 24 6b c1 2c
    0040  ef 48 b2 26 77 2b c3 61  05 44 e3 1c 2a 31 cb c1
    0050  f6 e1 cc a2 d6 3e d8 ac  36 8f ea e7 df 7d b0 9d
    0060  9d
Schlssel-ID-Hash(rfc-sha1): e90f7f6c93e660db6742585d6dd5327f08e2469b
Schlssel-ID-Hash(sha1): 79d60ac0a75a30e1ba3f07ccc4dbace00610696c
Schlssel-ID-Hash(bcrypt-sha1): 66a3af2d30d59c36337fcf153693e6bc0111c14b
Schlssel-ID-Hash(bcrypt-sha256): cfdf5d9b466f595f9c23dec4430a19b5134f41c882bea709ab120ed1c2496ce9

FEHLER: ffentlicher Schlssel stimmt nicht mit gespeichertem Schlsselsatz berein.
Das Testen der Signatur ist fehlgeschlagen.
</code></pre>

<p>The last part translates as:</p>

<pre><code>ERROR: Certificate public key does NOT match stored keyset
Signature test FAILED 
</code></pre>

<p>You can see that the public key itself is identical, just the AlgorithmIdentifier is different. I do not know where the container public key comes from, the certification request matches the AlgorithmIdentifier from the certificate public key shown above.</p>

<p>If I try to create the csr with the AlgorithmIdentifier of the container public key shown above, I get an error in the PKI ""encoded key spec not recognized"".</p>

<p>All this leeds me to the conclusion that I am doing something wrong with the csr.</p>

<p>I will not post the whole code as it spawns mutliple classes just the part wher the SubjectPublicKeyInfo is constructed as this seems to be the part where things go wrong:</p>

<p>Code  that creates valid ASN1 but results in the error above (Signature test failed)</p>

<pre><code>byte[] publicKey = ecPublicKeyParameters.Q.GetEncoded();
string base64PublicKey = Convert.ToBase64String(publicKey);
// This base64PublicKey is send to the server, that handles it with the code below:

var ecPars = TeleTrusTNamedCurves.GetByName(""brainpoolP384r1"");
ECDomainParameters ecDomPars = new ECDomainParameters(
    ecPars.Curve,
    ecPars.G,
    ecPars.N,
    ecPars.H,
    ecPars.GetSeed());
var curve = ecDomPars.Curve;
byte[] data = Convert.FromBase64String(base64PublicKey);
var ecPoint = curve.DecodePoint(data);
ECPublicKeyParameters publicKey = new ECPublicKeyParameters(ecPoint, ecDomPars);
SubjectPublicKeyInfo publicKeyInfo = SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(ecPublicKeyParameters);
</code></pre>

<p>Code that creates valid ASN1 that makes the PKI complain:</p>

<pre><code>// Using ECDsaCng directly in the hope that the certificate will be valid for windows:
 ECParameters ecParams = ecdsaPair.ExportParameters(false);
 ECPoint ecPoint = ecParams.Q;
 IEnumerable&lt;byte&gt; blobBytes = ecPoint.X.Concat(ecPoint.Y);
 byte[] eccblob = blobBytes.ToArray();
 // Sending this to the server where it will be used for SubjectPublicKeyInfo

AlgorithmIdentifier algorithmIdentifier = new AlgorithmIdentifier(new DerObjectIdentifier(""1.2.840.10045.2.1""), new DerObjectIdentifier(""1.3.36.3.3.2.8.1.1.11""));
SubjectPublicKeyInfo publicKeyInfo = new SubjectPublicKeyInfo(algorithmIdentifier, new DerBitString(eccblob));
</code></pre>

<p>How can I create a valid SubjectPublicKeyInfo that satisfies the PKI and the certutil validation?</p>
","<p>The problem with the cert-as-created seems to be that the certificate uses explicit curve domain parameters (which the RFCs frown on), and the private key did curve normalization to get back to a named curve, which you seem to have identified given the second approach.</p>

<p>In your ""more manual"" approach you didn't encode the public key correctly, you need a leading <code>04</code> to indicate that you're sending an uncompressed coordinate pair.  (<code>04 [x coordinate] [y coordinate]</code>).  The CA likely rejected your request because it didn't understand it.</p>

<pre><code>04 0e e2 21 a3 24 11 58 28 f9 12 fe 7a 2d 26 5f
ad 90 cc 79 1c b6 68 3a b0 ff f2 df 68 17 84 cd
5f a7 9e 27 10 00 ea 6a 47 d2 74 9f c4 15 36 d1
98 5e 65 5b 2e 7e 61 d4 16 85 ed 3f 24 6b c1 2c
ef 48 b2 26 77 2b c3 61 05 44 e3 1c 2a 31 cb c1
f6 e1 cc a2 d6 3e d8 ac 36 8f ea e7 df 7d b0 9d
9d
</code></pre>

<p><sub>Note the leading <code>04</code>, and how it has odd length</sub></p>

<p>FWIW: If you're on .NET Core 2.0 you can do this without BouncyCastle via <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.certificaterequest?view=netcore-2.0"" rel=""nofollow noreferrer"">System.Security.Cryptography.X509Certificates.CertificateRequest</a>. That class is also available in <a href=""https://blogs.msdn.microsoft.com/dotnet/2018/02/05/announcing-net-framework-4-7-2-early-access-build-3052/"" rel=""nofollow noreferrer"">the 4.7.2 early access</a> release.</p>
","316","<c#><certificate><bouncycastle><pki><ecdsa>","0","1","1","2018-03-01 14:33:04","49051933","0","","","","","2018-03-01 08:51:07",""
"40735653","Create PKCS 10 with Eliptic Curve in iOS","<p>I'm on R&amp;D to create PKCS 10 CSR, I googled and found very good help on github of <a href=""https://github.com/ateska/ios-csr/blob/master/SCCSR.m"" rel=""nofollow noreferrer"">this man done</a>, I've done with RSA <code>kSecAttrKeyTypeRSA</code>, Now I want to done same with Eliptic Curve <code>kSecAttrKeyTypeEC</code> but I'm not able to find that need help on this.</p>

<p><strong>EDITED:</strong>
I tried to convert <code>SCCR.m</code>from RSA to ECDSAwithSHA256</p>

<ul>
<li>I get OID of <a href=""http://www.oid-info.com/get/1.2.840.10045.4.3.2"" rel=""nofollow noreferrer"">ECDSAWithSHA256</a> and convert into <a href=""https://www.viathinksoft.com/~daniel-marschall/asn.1/oid-converter/online.php"" rel=""nofollow noreferrer"">hex</a>.</li>
<li>Change SHA1 with 256 in whole class like <code>CC_SHA256_CTX</code>.</li>
<li>Created keypair with <code>kSecAttrKeyTypeEC</code> instead of <code>kSecAttrKeyTypeRSA</code>.</li>
</ul>

<p>After all this i am getting PEM file in which signature isn't valid. 
Here below is my whole class.</p>

<p><strong>SCCR.m</strong></p>

<pre><code>/*
This file is part of ios-csr.
Copyright (C) 2013-14 Ales Teska

ios-csr is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ios-csr is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ios-csr.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

#import ""SCCSR.h""
#include &lt;CommonCrypto/CommonDigest.h&gt;

/*

Certification Request Syntax Specification: http://www.ietf.org/rfc/rfc2986.txt

*/




static uint8_t OBJECT_commonName[5] = {0x06, 0x03, 0x55, 0x04, 0x03};
static uint8_t OBJECT_countryName[5] = {0x06, 0x03, 0x55, 0x04, 0x06};
static uint8_t OBJECT_organizationName[5] = {0x06, 0x03, 0x55, 0x04, 0x0A};
static uint8_t OBJECT_organizationalUnitName[5] = {0x06, 0x03, 0x55, 0x04, 0x0B};

//1.2.840.10045.4.3.2
//\x06\x08\x2A\x86\x48\xCE\x3D\x04\x03\x02
//http://www.oid-info.com/get/1.2.840.10045.4.3.2


static uint8_t OBJECT_ECEncryptionNULL[11] = {0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x00};

static uint8_t SEQUENCE_OBJECT_sha256WithECEncryption[] = {0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x00};

//static uint8_t OBJECT_rsaEncryptionNULL[13] = {0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00};

// See: http://oid-info.com/get/1.2.840.113549.1.1.5
//static uint8_t SEQUENCE_OBJECT_SHA256WithRSAEncryption[] = {0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 1, 1, 5, 0x05, 0x00};

static uint8_t SEQUENCE_tag = 0x30;
static uint8_t SET_tag = 0x31;

///

@implementation SCCSR

@synthesize countryName;
@synthesize organizationName;
@synthesize organizationalUnitName;
@synthesize commonName;
@synthesize subjectDER;

-(SCCSR *)init
{
    self = [super init];
    if (!self) return self;

    countryName = nil;
    organizationName = nil;
    organizationalUnitName = nil;
    commonName = nil;

    subjectDER = nil;

    return self;
}

-(NSData *) build:(NSData *)publicKeyBits privateKey:(SecKeyRef)privateKey
{
    NSMutableData * CertificationRequestInfo = [self buildCertificationRequestInfo:publicKeyBits];

    // Build signature - step 1: SHA256 hash
    CC_SHA256_CTX SHA256;
    CC_SHA256_Init(&amp;SHA256);
    CC_SHA256_Update(&amp;SHA256, [CertificationRequestInfo mutableBytes], (unsigned int)[CertificationRequestInfo length]);
    unsigned char digest[CC_SHA256_DIGEST_LENGTH];
    CC_SHA256_Final(digest, &amp;SHA256);

    // Build signature - step 2: Sign hash
    uint8_t signature[256];
    size_t signature_len = sizeof(signature);
    OSStatus osrc = SecKeyRawSign(
        privateKey,
        kSecPaddingPKCS1SHA256,
        digest, sizeof(digest),
        signature, &amp;signature_len
    );
    assert(osrc == noErr);

    NSMutableData * CertificationRequest = [[NSMutableData alloc] initWithCapacity:1024];
    [CertificationRequest appendData:CertificationRequestInfo];
    [CertificationRequest appendBytes:SEQUENCE_OBJECT_sha256WithECEncryption length:sizeof(SEQUENCE_OBJECT_sha256WithECEncryption)];

    NSMutableData * signdata = [NSMutableData dataWithCapacity:257];
    uint8_t zero = 0;
    [signdata appendBytes:&amp;zero length:1]; // Prepend zero
    [signdata appendBytes:signature length:signature_len];
    [SCCSR appendBITSTRING:signdata into:CertificationRequest];

    [SCCSR enclose:CertificationRequest by:SEQUENCE_tag]; // Enclose into SEQUENCE

    return CertificationRequest;
}


-(NSMutableData *)buildCertificationRequestInfo:(NSData *)publicKeyBits
{
    NSMutableData * CertificationRequestInfo = [[NSMutableData alloc] initWithCapacity:512];

    // Add version
    uint8_t version[3] = {0x02, 0x01, 0x00}; // ASN.1 Representation of integer with value 1
    [CertificationRequestInfo appendBytes:version length:sizeof(version)];


    // Add subject
    NSMutableData * Subject = [[NSMutableData alloc] initWithCapacity:256];
    if (countryName != nil) [SCCSR appendSubjectItem:OBJECT_countryName value:countryName into:Subject];
    if (organizationName != nil) [SCCSR appendSubjectItem:OBJECT_organizationName value:organizationName into:Subject];
    if (organizationalUnitName != nil) [SCCSR appendSubjectItem:OBJECT_organizationalUnitName value:organizationalUnitName into:Subject];
    if (commonName != nil) [SCCSR appendSubjectItem:OBJECT_commonName value:commonName into:Subject];
    [SCCSR enclose:Subject by:SEQUENCE_tag]; // Enclose into SEQUENCE

    subjectDER = [NSData dataWithData:Subject];

    [CertificationRequestInfo appendData:Subject];


    //Add public key info
    NSData * publicKeyInfo = [SCCSR buildPublicKeyInfo:publicKeyBits];
    [CertificationRequestInfo appendData:publicKeyInfo];

    // Add attributes
    uint8_t attributes[2] = {0xA0, 0x00};
    [CertificationRequestInfo appendBytes:attributes length:sizeof(attributes)];


    [SCCSR enclose:CertificationRequestInfo by:SEQUENCE_tag]; // Enclose into SEQUENCE

    return CertificationRequestInfo;
}

/// Utility class methods ...
+(NSData *)buildPublicKeyInfo:(NSData *)publicKeyBits
{
    NSMutableData * publicKeyInfo = [[NSMutableData alloc] initWithCapacity:390];

    [publicKeyInfo appendBytes:OBJECT_ECEncryptionNULL length:sizeof(OBJECT_ECEncryptionNULL)];
    [SCCSR enclose:publicKeyInfo by:SEQUENCE_tag]; // Enclose into SEQUENCE

    NSMutableData * publicKeyASN = [[NSMutableData alloc] initWithCapacity:260];

    NSData * mod = [SCCSR getPublicKeyMod:publicKeyBits];
    char Integer = 0x02; // Integer
    [publicKeyASN appendBytes:&amp;Integer length:1];
    [SCCSR appendDERLength:[mod length] into:publicKeyASN];
    [publicKeyASN appendData:mod];

    NSData * exp = [SCCSR getPublicKeyExp:publicKeyBits];
    [publicKeyASN appendBytes:&amp;Integer length:1];
    [SCCSR appendDERLength:[exp length] into:publicKeyASN];
    [publicKeyASN appendData:exp];

    [SCCSR enclose:publicKeyASN by:SEQUENCE_tag]; // Enclose into ??
    [SCCSR prependByte:0x00 into:publicKeyASN]; // Prepend 0 (?)

    [SCCSR appendBITSTRING:publicKeyASN into:publicKeyInfo];

    [SCCSR enclose:publicKeyInfo by:SEQUENCE_tag]; // Enclose into SEQUENCE

    return publicKeyInfo;
}

+(void)appendSubjectItem:(const uint8_t[5])what value:(NSString *)value into:(NSMutableData *)into
{
    NSMutableData * SubjectItem = [[NSMutableData alloc] initWithCapacity:128];
    [SubjectItem appendBytes:what length:5];
    [SCCSR appendUTF8String:value into:SubjectItem];
    [SCCSR enclose:SubjectItem by:SEQUENCE_tag]; // Enclose into SEQUENCE
    [SCCSR enclose:SubjectItem by:SET_tag]; // Enclose into SET

    [into appendData:SubjectItem];
}

+(void)appendUTF8String:(NSString *)string into:(NSMutableData *)into
{
    char strtype = 0x0C; //UTF8STRING
    [into appendBytes:&amp;strtype length:1];
    [SCCSR appendDERLength:[string lengthOfBytesUsingEncoding:NSUTF8StringEncoding] into:into];
    [into appendData:[string dataUsingEncoding:NSUTF8StringEncoding]];
}

+(void)appendDERLength:(size_t)length into:(NSMutableData *)into
{
    assert(length &lt; 0x8000);

    if (length &lt; 128)
    {
        uint8_t d = length;
        [into appendBytes:&amp;d length:1];
    }
    else if (length &lt; 0x100)
    {
        uint8_t d[2] = {0x81, length &amp; 0xFF};
        [into appendBytes:&amp;d length:2];
    }
    else if (length &lt; 0x8000)
    {
        uint8_t d[3] = {0x82, (length &amp; 0xFF00) &gt;&gt; 8, length &amp; 0xFF};
        [into appendBytes:&amp;d length:3];
    }
}

+(void)appendBITSTRING:(NSData *)data into:(NSMutableData *)into
{
    char strtype = 0x03; //BIT STRING
    [into appendBytes:&amp;strtype length:1];
    [SCCSR appendDERLength:[data length] into:into];
    [into appendData:data];
}


+(void)enclose:(NSMutableData *)data by:(uint8_t)by
{
    NSMutableData* newdata = [[NSMutableData alloc]initWithCapacity:[data length]+4];

    [newdata appendBytes:&amp;by length:1];
    [SCCSR appendDERLength:[data length] into:newdata];
    [newdata appendData:data];

    [data setData:newdata];
}

+(void)prependByte:(uint8_t)byte into:(NSMutableData *)into
{
    NSMutableData* newdata = [[NSMutableData alloc]initWithCapacity:[into length]+1];

    [newdata appendBytes:&amp;byte length:1];
    [newdata appendData:into];

    [into setData:newdata];
}

///

// From http://stackoverflow.com/questions/3840005/how-to-find-out-the-modulus-and-exponent-of-rsa-public-key-on-iphone-objective-c

+ (NSData *)getPublicKeyExp:(NSData *)publicKeyBits
{
    int iterator = 0;

    iterator++; // TYPE - bit stream - mod + exp
    [SCCSR derEncodingGetSizeFrom:publicKeyBits at:&amp;iterator]; // Total size

    iterator++; // TYPE - bit stream mod
    int mod_size = [SCCSR derEncodingGetSizeFrom:publicKeyBits at:&amp;iterator];
    iterator += mod_size;

    iterator++; // TYPE - bit stream exp
    int exp_size = [SCCSR derEncodingGetSizeFrom:publicKeyBits at:&amp;iterator];
//  return publicKeyBits;
    return [publicKeyBits subdataWithRange:NSMakeRange(iterator, exp_size)];
}

+(NSData *)getPublicKeyMod:(NSData *)publicKeyBits
{
    int iterator = 0;

    iterator++; // TYPE - bit stream - mod + exp
    [SCCSR derEncodingGetSizeFrom:publicKeyBits at:&amp;iterator]; // Total size

    iterator++; // TYPE - bit stream mod
    int mod_size = [SCCSR derEncodingGetSizeFrom:publicKeyBits at:&amp;iterator];
//    return publicKeyBits;
    //TODO: Changed in Code
    return [publicKeyBits subdataWithRange:NSMakeRange(iterator, mod_size)];
}

+(int)derEncodingGetSizeFrom:(NSData*)buf at:(int*)iterator
{
    const uint8_t* data = [buf bytes];
    int itr = *iterator;
    int num_bytes = 1;
    int ret = 0;

    if (data[itr] &gt; 0x80) {
        num_bytes = data[itr] - 0x80;
        itr++;
    }

    for (int i = 0 ; i &lt; num_bytes; i++) ret = (ret * 0x100) + data[itr + i];

    *iterator = itr + num_bytes;
    return ret;
}

@end
</code></pre>

<p><strong>Questions</strong></p>

<ul>
<li>When this OID <code>1.2.840.113549.1.1.5</code> convert into hex this become <code>{0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00}</code> which is defined in as <code>static uint8_t OBJECT_rsaEncryptionNULL[13] = {0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00};</code> then what is <code>SEQUENCE_OBJECT_RSAEncryption</code> which is defined <code>static uint8_t SEQUENCE_OBJECT_RSAEncryption[] = {0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 1, 1, 5, 0x05, 0x00};</code> ?</li>
<li>What will be <code>SEQUENCE_OBJECT_sha256WithECEncryption</code> if it is SHA256withEC</li>
</ul>

<p><strong>CSR generated from OPENSSL</strong></p>

<p>-----BEGIN CERTIFICATE REQUEST-----
MIIC8jCCAdoCAQAwfDELMAkGA1UEBhMCYXMxCzAJBgNVBAgTAnB1MQwwCgYDVQQH
EwNsaHIxDDAKBgNVBAoTA3BhazERMA8GA1UECxMIYXNjZXJ0aWExDjAMBgNVBAMT
BWFsZWVtMSEwHwYJKoZIhvcNAQkBFhJhbGVlbS5yekBnbWFpbC5jb20wggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCzvlvXGw4/YPYbiiCQE2pmqu0x9Ib3
nHk3yMy8ewJIXWOuewVmB7ISBoiAaJ01ON9H/szYUvCGoU5fzz7UFgxCI7biypuy
ixo74w7Bd2jRMsH7baZ2W0bhvGoBxN1IMJZHI53J2KF9P5tayLz7OyGQ4Qz8p63A
A6Ag3rblIDEBiDr6Xkyxd2atUf4EwB4JcrsLx66RyGDWadXcyO8P39Jg6bgauBMh
OW2tq3Y7WsnOnYrYj4m1r9Z1ZFZEIHtHJX9u0qtuHH8yZD/saP5RkUcjIZPHU6Yh
gNByRAXCl5YAMTV9yah/AGq6SMwvSRbhX6zgCpI0/eIhvyuzFW/poRlvAgMBAAGg
MTAWBgkqhkiG9w0BCQIxCRMHYXNjdGVzdDAXBgkqhkiG9w0BCQcxChMIODc2NTQz
MjEwDQYJKoZIhvcNAQELBQADggEBADdv9TOQAV7hEtFsviyp9G08BJgSDBjdP63I
Efplt2B1POGvdOKvR1OI5r/qgZZ8E7BTBaFyArUT4+sEdybpmXV9PdO8R7zawD/j
7vmKShYThlPxi/UDrZT8kAwrnBAKgChJ/KMSB6LGdM2wvZKvoN14LFj/KUHtTI97
LYRfhIKFk28yyeSQxK8a3zkPawiTWBYYay9GU13NiKXedps00eV14S7/jAzhL/bk
e94LfFybyDcOa2zDWKZOwOGAEStCq4O+7A+t8wrA=
-----END CERTIFICATE REQUEST-----</p>
","","310","<ios><csr><ecdsa><key-pair>","0","","0","2017-10-20 12:27:04","","8","","671060","","2016-11-28 18:58:41","2016-11-22 07:03:12",""
"54548803","Retrieve ECDSA public key from only x-compressed coordinate using Crypto++ library","<p>I'm implementing a security daemon on the vehicular communication scope.</p>

<p>I could receive a message with a signature and the compressed X coordinate of a point to verify that signature. The elliptic curve can be either the secp256 or the brainpoolp256r1 and the algorithm is ECDSA.</p>

<p>My question is: how can I recover the ECC Point (and so the public key) given only the compressed X coordinate with the Crypto++ library?</p>

<p>I followed some links which explain it (and many others) <a href=""https://www.cryptopp.com/wiki/Point_Compression"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/Point_Compression</a> <a href=""https://stackoverflow.com/questions/16576434/crypto-and-compressed-ec-keys"">Crypto++ and Compressed EC keys</a> but they don't fit my problem.</p>

<p>I tried to produce code to resolve the problem, but it won't work:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/ecp.h&gt;
#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/osrng.h&gt;

using namespace CryptoPP;
using std::cout;
using std::endl;
using std::string;

int main() 
{
    string compactPoint = ""937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3"";

    AutoSeededRandomPool generator;
    ECDSA&lt;ECP, SHA256&gt;::PublicKey pubKey;
    OID curve       = ASN1::secp256r1();


    StringSource ss (compactPoint, true, new CryptoPP::HexDecoder);
    ECP::Point point;

    pubKey.GetGroupParameters().GetCurve().DecodePoint (point, ss, ss.MaxRetrievable());

    std::cout &lt;&lt; ""Result after decompression X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Result after decompression Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Can you help me please?</p>
","<p>The easiest solution is probably to prepend <code>""02""</code> oe <code>""03""</code> to the <a href=""https://tools.ietf.org/id/draft-jivsov-ecc-compact-00.xml#NIST-SP800-133"" rel=""nofollow noreferrer"">compact representation</a>. Crypto++ will then decode it as a compressed public key.</p>

<pre><code>$ cat test.cxx

#include ""cryptlib.h""
#include ""eccrypto.h""
#include ""ecp.h""
#include ""hex.h""
#include ""oids.h""

#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    ECDSA&lt;ECP, SHA256&gt;::PublicKey pubKey;
    pubKey.AccessGroupParameters().Initialize(ASN1::secp256r1());

    std::string compactPoint = ""02"" /* compressed */
        ""937120662418500f3ad7c892b1db7e7c""
        ""2d85ec48c74e99d64dcb7083082bb4f3"";

    StringSource ss (compactPoint, true, new HexDecoder);
    ECP::Point point;

    pubKey.GetGroupParameters().GetCurve().DecodePoint (point, ss, ss.MaxRetrievable());

    std::cout &lt;&lt; ""Result after decompression X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Result after decompression Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>And then building and running the program. Notice the library solves for the <code>y</code> portion of the coordinate.</p>

<pre class=""lang-none prettyprint-override""><code>cryptopp$ g++ test.cxx ./libcryptopp.a -o test.exe
cryptopp$ ./test.exe
Result after decompression X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Result after decompression Y: cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h
</code></pre>

<hr>

<p>And to save you the trouble of looking it up, you can set the public element for <code>publicKey</code> using:</p>

<pre><code>pubKey.SetPublicElement(point);

std::cout &lt;&lt; ""X: "" &lt;&lt; std::hex &lt;&lt; pubKey.GetPublicElement().x &lt;&lt; std::endl;
std::cout &lt;&lt; ""Y: "" &lt;&lt; std::hex &lt;&lt; pubKey.GetPublicElement().y &lt;&lt; std::endl;
</code></pre>

<p>Running with the additional code produces the expected result:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Result after decompression X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Result after decompression Y: cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h
X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Y: cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h
</code></pre>

<hr>

<p>If interested, here is the code you are using to decode the point from <a href=""https://github.com/weidai11/cryptopp/blob/master/ecp.cpp"" rel=""nofollow noreferrer""><code>ecp.cpp</code></a>:</p>

<pre><code>bool ECP::DecodePoint(ECP::Point &amp;P, BufferedTransformation &amp;bt, size_t encodedPointLen) const
{
    byte type;
    if (encodedPointLen &lt; 1 || !bt.Get(type))
        return false;

    switch (type)
    {
    case 0:
        P.identity = true;
        return true;
    case 2:
    case 3:
    {
        if (encodedPointLen != EncodedPointSize(true))
            return false;

        Integer p = FieldSize();

        P.identity = false;
        P.x.Decode(bt, GetField().MaxElementByteLength());
        P.y = ((P.x*P.x+m_a)*P.x+m_b) % p;

        if (Jacobi(P.y, p) !=1)
            return false;

        P.y = ModularSquareRoot(P.y, p);

        if ((type &amp; 1) != P.y.GetBit(0))
            P.y = p-P.y;

        return true;
    }
    case 4:
    {
        if (encodedPointLen != EncodedPointSize(false))
            return false;

        unsigned int len = GetField().MaxElementByteLength();
        P.identity = false;
        P.x.Decode(bt, len);
        P.y.Decode(bt, len);
        return true;
    }
    default:
        return false;
    }
}
</code></pre>

<p>I mention it in case you want to solve for the <code>y</code> coordinate yourself, populate the <code>point</code>, and then call <code>SetPublicElement</code> directly.</p>

<hr>

<p>You can also prepend <code>03</code> instead of <code>02</code>. The difference is, the decoding returns either <code>y</code> or <code>p-y</code>. The variability is introduced due to the modular square root shown above. We need to see the generation algorithm to determine what the value should be.</p>

<p>Here is the difference when using <code>03</code> instead of <code>02</code>:</p>

<pre><code>$ ./test.exe
X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Y: 303508b051c3113b66c6d70fb68f3010cbc46595dd8d8057e6d942de0da913a9h
</code></pre>

<p>Notice <code>03</code> produces the <code>y</code> coordinate <code>303508b051c3113b66c6d70fb68f3010cbc46595dd8d8057e6d942de0da913a9h</code> instead of <code>02</code> and <code>cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h</code>.</p>
","310","<c++><compression><public-key><crypto++><ecdsa>","1","0","1","2019-02-07 17:44:58","54550787","2","1","4359602","","2019-02-06 08:59:53","2019-02-06 07:47:47",""
"50410102","Implemented Finger Print Authentication in Application with signature","<p>I am getting the issue when running the application below android 6.0</p>

<pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
    KeyguardManager keyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
    FingerprintManager fingerprintManager = (FingerprintManager) getSystemService(FINGERPRINT_SERVICE);


    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
        if (!fingerprintManager.isHardwareDetected()) {
            /**
             * An error message will be displayed if the device does not contain the fin.gerprint hardware.
             * However if you plan to implement a default authentication method,
             * you can redirect the user to a default authentication ctivity from here.
             * Example:
             * 
             */

        } else {


            // Checks whether fingerprint permission is set on manifest
            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.USE_FINGERPRINT) != PackageManager.PERMISSION_GRANTED) {

               // permission not granted
            } else {

                // Check whether at least one fingerprint is registered
                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {

                    // Checks whether lock screen security is enabled or not
                    if (!keyguardManager.isKeyguardSecure()) {
                        // finger print not support

                    } else {

                        if (!fingerprintManager.hasEnrolledFingerprints()) {
                        // finger print not enrolled

                        } else {

                            /*Amit Verma  EC signature*/
                            createKeyPair();
                            if (initSignature()) {
                                ConstantDeclaration.mCryptoObject = new FingerprintManager.CryptoObject(mSignature);
                            }
                        }
                    }
                }
            }
        }
    }
}
</code></pre>

<p>Here is code for key-pair Generation</p>

<pre><code>@TargetApi(Build.VERSION_CODES.M)
    private void createKeyPair() {
        // The enrolling flow for fingerprint. This is where you ask the user to set up fingerprint
        // for your flow. Use of keys is necessary if you need to know if the set of
        // enrolled fingerprints has changed.

        try {
            // Set the alias of the entry in Android KeyStore where the key will appear
            // and the constrains (purposes) in the constructor of the Builder

            KeyPairGenerator mKeyPairGenerator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_EC, ""AndroidKeyStore"");
            mKeyPairGenerator.initialize(
                    new KeyGenParameterSpec.Builder(KEY_NAME,
                            KeyProperties.PURPOSE_SIGN)
                            .setDigests(KeyProperties.DIGEST_SHA1)
                            .setAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
                            // Require the user to authenticate with a fingerprint to authorize
                            // every use of the private key
//                            .setUserAuthenticationRequired(true)
                            .setUserAuthenticationRequired(false)
                            .build());
            mKeyPairGenerator.generateKeyPair();
        } catch (InvalidAlgorithmParameterException e) {
            throw new RuntimeException(e);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }

    }
</code></pre>

<p>here is the code for signature initiate. </p>

<pre><code> @TargetApi(Build.VERSION_CODES.M)
    private boolean initSignature() {
        try {
            mKeyStore = KeyStore.getInstance(""AndroidKeyStore"");
            mKeyStore.load(null);
            PrivateKey key = (PrivateKey) mKeyStore.getKey(KEY_NAME, null);
//            String strKey = Base64.encodeToString(key.getEncoded(),Base64.DEFAULT);

//            System.out.println(""PrivateKey::""+strKey);
            mSignature = Signature.getInstance(""SHA1withECDSA"");
            mSignature.initSign(key);

            PublicKey publicKey = mKeyStore.getCertificate(KEY_NAME).getPublicKey();
            String strPublicKey = Base64.encodeToString(publicKey.getEncoded(), Base64.DEFAULT);
            Singleton.getInstance().public_key_fp = strPublicKey;

            return true;
        } catch (KeyPermanentlyInvalidatedException e) {
            return false;
        } catch (Exception e) {
            throw new RuntimeException(""Failed to init Cipher"", e);
        }/*catch (KeyStoreException | CertificateException | UnrecoverableKeyException | IOException
                | NoSuchAlgorithmException | InvalidKeyException e) {
            throw new RuntimeException(""Failed to init Cipher"", e);
        }*/
    }
</code></pre>

<p>This code is working fine but when I am running my application in below Android 6.0  getting the exception on the launching the app.</p>

<pre><code>Android version: 19
Device: samsung SM-J100ML
App version: 7
Line Number1: java.lang.Class.newInstanceImpl(Native Method)
Description : java.lang.VerifyError: launcherActivity
    at java.lang.Class.newInstanceImpl(Native Method)
    at java.lang.Class.newInstance(Class.java:1208)
    at android.app.Instrumentation.newActivity(Instrumentation.java:1068)
    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2288)
    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2493)
    at android.app.ActivityThread.access$800(ActivityThread.java:166)
    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1283)
    at android.os.Handler.dispatchMessage(Handler.java:102)
    at android.os.Looper.loop(Looper.java:136)
    at android.app.ActivityThread.main(ActivityThread.java:5584)
    at java.lang.reflect.Method.invokeNative(Native Method)
    at java.lang.reflect.Method.invoke(Method.java:515)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1268)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1084)
    at dalvik.system.NativeStart.main(Native Method)
</code></pre>

<p>I think the problem with Signature import is import java.security.Signature;</p>
","<p>I figured out the problem by reading logcat as said above in comment,</p>

<pre><code>Could not find class 'android.security.keystore.KeyGenParameterSpec$Builder'
</code></pre>

<p>and </p>

<pre><code>Could not find class 'android.hardware.fingerprint.FingerprintManager'
</code></pre>

<p>I googled above classes and found this link <a href=""https://stackoverflow.com/q/37553650/6869491"">here</a></p>

<p>So I <strong>removed</strong> catch block <code>InvalidAlgorithmParameterException</code> ,<code>**KeyPermanentlyInvalidatedException**</code> and replaced with <strong>parent class ""Exception"" only</strong>.</p>
","304","<android><ecdsa><android-fingerprint-api>","1","2","1","2018-05-19 15:25:29","50412776","11","","6296561","","2018-05-19 15:25:29","2018-05-18 11:15:18",""
"29987302","Creating a private/public key with 64 characters that are already known using bitcoinjs","<p>So I'm trying to create a private/public key from 64 characters that I already know using bitcoinjs with the code below:</p>

<pre><code>key = Bitcoin.ECKey.makeRandom();

// Print your private key (in WIF format)
document.write(key.toWIF());
// =&gt; Kxr9tQED9H44gCmp6HAdmemAzU3n84H3dGkuWTKvE23JgHMW8gct

// Print your public key (toString defaults to a Bitcoin address)
document.write(key.pub.getAddress().toString());
// =&gt; 14bZ7YWde4KdRb5YN7GYkToz3EHVCvRxkF
</code></pre>

<p>If I try to set ""key"" to my 64 characters instead of ""Bitcoin.ECKey.makeRandom();"" it fails. Is there a method or library that I overlooked that would allow me to use the known 64 characters in order to generate the private key in wif format and the public address?
Thanks in advance to anyone that may be able to offer some help.</p>
","<p>You should use fromWIF method to pass your own data.</p>

<p>from source code of eckey.js</p>

<pre><code>// Static constructors
ECKey.fromWIF = function(string) {
  var payload = base58check.decode(string)
  var compressed = false

  // Ignore the version byte
  payload = payload.slice(1)

  if (payload.length === 33) {
    assert.strictEqual(payload[32], 0x01, 'Invalid compression flag')

    // Truncate the compression flag
    payload = payload.slice(0, -1)
    compressed = true
  }
</code></pre>

<p>To create WIF from your key please follow <a href=""https://en.bitcoin.it/wiki/Wallet_import_format"" rel=""nofollow"">https://en.bitcoin.it/wiki/Wallet_import_format</a>
Here is interactive tool <a href=""http://gobittest.appspot.com/PrivateKey"" rel=""nofollow"">http://gobittest.appspot.com/PrivateKey</a></p>
","301","<bitcoin><ecdsa>","0","0","2","2015-05-15 22:06:22","","0","","","","","2015-05-01 13:00:25",""
"29987302","Creating a private/public key with 64 characters that are already known using bitcoinjs","<p>So I'm trying to create a private/public key from 64 characters that I already know using bitcoinjs with the code below:</p>

<pre><code>key = Bitcoin.ECKey.makeRandom();

// Print your private key (in WIF format)
document.write(key.toWIF());
// =&gt; Kxr9tQED9H44gCmp6HAdmemAzU3n84H3dGkuWTKvE23JgHMW8gct

// Print your public key (toString defaults to a Bitcoin address)
document.write(key.pub.getAddress().toString());
// =&gt; 14bZ7YWde4KdRb5YN7GYkToz3EHVCvRxkF
</code></pre>

<p>If I try to set ""key"" to my 64 characters instead of ""Bitcoin.ECKey.makeRandom();"" it fails. Is there a method or library that I overlooked that would allow me to use the known 64 characters in order to generate the private key in wif format and the public address?
Thanks in advance to anyone that may be able to offer some help.</p>
","<p>The solution to generate private and public key:</p>

<pre><code>//public-key
var address = eckey.getBitcoinAddress().toString();

var privateKeyBytesCompressed = privateKeyBytes.slice(0); 
privateKeyBytesCompressed.push(0x01);
var privateKeyWIFCompressed = new Bitcoin.Address(privateKeyBytesCompressed);
privateKeyWIFCompressed.version = 0x80;


//private-key
privateKeyWIFCompressed = privateKeyWIFCompressed.toString();
</code></pre>

<p>Take a look at moneyart.info for beautifully designed paperwallets.</p>
","301","<bitcoin><ecdsa>","0","0","2","2015-05-15 22:06:22","","0","","","","","2015-05-01 13:00:25",""
"47138729","openSSL: Import ECDSA signature from raw data with compressed CurvePoint R instead of r","<p>I want to verify some data packets which contain an ECDSA signature that is not ASN.1 DER encoded.</p>

<p>I am trying to perform the task with openSSL (version 1.1.0) as it seems to bring all the required functionality.</p>

<p>Currently I am stuck with importing the signature from the data packet.
The signature looks like this:</p>

<p><a href=""https://i.stack.imgur.com/vgpH7.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vgpH7.jpg"" alt=""signature shown in Wireshark""></a></p>

<p>(The last 4 bytes should not be marked as part of the signature)</p>

<p>TShark shows the relevant part like this:</p>

<blockquote>
<pre><code>    ""gn.sh.sig"": {
      ""gn.st.pka"": ""0"",
      ""gn.st.eccpointtype"": ""3"",
      ""gn.st.opaque"": ""1f:f8:ad:a7:fd:99:b2:a8:a2:69:d4:d6:67:e5:ee:5b:3f:8b:e8:7f:49:fc:b4:79:95:98:15:0d:cb:bd:06:3c"",
      ""gn.st.opaque"": ""61:a4:6a:c9:a7:dd:bd:0d:9c:0a:0e:73:db:52:06:bb:79:53:99:51:16:45:45:81:4e:df:94:5c:58:59:40:14""
    }
</code></pre>
</blockquote>

<p>The encoding is according ETSI TS 103 097 v1.2.1</p>

<p>The first entry <code>opaque</code> together with the <code>ECC Point type</code> form an EccPoint named <code>R</code> while the second field <code>opaque</code> is named <code>s</code>.</p>

<p>My first step is to create a signature in openSSL and import the data into it. </p>

<p>My code (error handling removed to reduce size) looks like this:</p>

<pre><code>#include &lt;openssl/conf.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/ec.h&gt;
#include &lt;openssl/ecdsa.h&gt;
#include &lt;openssl/bn.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

void verify_signature(void)
{
  int res;

  // Which value is correct for r-part?
  static const char sig_r_hex[] = ""1ff8ada7fd99b2a8a269d4d667e5ee5b3f8be87f49fcb4799598150dcbbd063c"";
  static const char sig_s_hex[] = ""61a46ac9a7ddbd0d9c0a0e73db5206bb79539951164545814edf945c58594014"";

  BN_CTX *bn_ctx = BN_CTX_new();
  BN_CTX_start(bn_ctx);

  // Create signature and import from packet.
  BIGNUM *bn_r = BN_CTX_get(bn_ctx);
  BIGNUM *bn_s = BN_CTX_get(bn_ctx);

  res = BN_hex2bn(&amp;bn_r, sig_r_hex);
  res = BN_hex2bn(&amp;bn_s, sig_s_hex);

  ECDSA_SIG *signature = ECDSA_SIG_new();
  res = ECDSA_SIG_set0(signature, bn_r, bn_s);
  printf(""ECDSA_SIG_set0(): %d\n"", res);

  // ...
  // Create hash of message and verify signature with public key
  //...
}

int main(int arc, char *argv[])
{ 
  ERR_load_crypto_strings();
  OpenSSL_add_all_algorithms();
  OPENSSL_config(NULL);

  verify_signature();

  EVP_cleanup();
  CRYPTO_cleanup_all_ex_data();
  ERR_free_strings();
  return 0;
}
</code></pre>

<p>What I am currently missing is how I should handle the value <code>R</code> properly. 
Which parts of the compressed CurvePoint should be used as <code>r</code> to initialize the signature?
Do I need to uncompress <code>y</code> part?
Do I have to add some indication for the compressed <code>y</code> value?</p>

<p>Any hints are welcome.</p>

<p>Edit:</p>

<p>From what I read in IEEE1609.2 and SEC-1 it is possible to add additional information to allow for faster computation of <code>R</code> from <code>r</code>. This may the the point <code>R</code> itself.
As <code>r = xR mod n</code> it should be possible to calculate <code>r</code> from the EccPoint.</p>

<p>Does openSSL support this mechanism to speed up verification or do I really have to remove the extra information (and find out how to do it) to feed <code>r</code> into openSSL?</p>
","<p>Sections 4.2.5 -- 4.2.8 in <a href=""http://www.etsi.org/deliver/etsi_ts/103000_103099/103097/01.02.01_60/ts_103097v010201p.pdf"" rel=""nofollow noreferrer"">http://www.etsi.org/deliver/etsi_ts/103000_103099/103097/01.02.01_60/ts_103097v010201p.pdf</a>, give the following structures (where <code>extern</code> means not literally represented in the data'):</p>

<pre><code>enum {
     x_coordinate_only(0),
     compressed_lsb_y_0(2),
     compressed_lsb_y_1(3),
     uncompressed(4),
     (2^8-1)
} EccPointType;

struct {
 extern PublicKeyAlgorithm algorithm;
 extern uint8 field_size;
 EccPointType type;
 opaque x[field_size];
 select(type) {
     case x_coordinate_only:
     case compressed_lsb_y_0:
     case compressed_lsb_y_1:
         ;
     case uncompressed:
         opaque y[field_size];
     unknown:
         opaque data&lt;var&gt;;
     }
} EccPoint;

struct {  
    extern PublicKeyAlgorithm algorithm;  
    extern uint8 field_size;  
    EccPoint R;  
    opaque s[field_size]; 
} EcdsaSignature;

struct {
    PublicKeyAlgorithm algorithm;
    select(algorithm) {
        case ecdsa_nistp256_with_sha256:
            EcdsaSignature ecdsa_signature;
        unknown:
            opaque signature&lt;var&gt;;
    }
} Signature;
</code></pre>

<p>You know that it's ECDSA on P-256, using SHA256, and that we've got a ""compressed y-1"" point.  Lets first resolve all of the 'select' portions of these structs using what we know, and eliminate all of the 'extern' fields:</p>

<pre><code>struct {
    PublicKeyAlgorithm algorithm; // 1 byte = 0x00 (""ecdsa, P-256, sha256"")
    {                             //EcdsaSignature ecdsa_signature
        {                         //EccPoint R
            EccPointType type;        //1 byte = 0x03 (""compressed lsb y-1"")
            opaque x[field_size];     //these are the first 32 opaque bytes
            ;                         // select(type) resolves to nothing.
        }  
        opaque s[field_size];     //these are the second 32 opaque bytes
    }
} Signature;
</code></pre>

<p>Okay. That's simpler.  Now we know what all of the bytes are.  So what's all this business about ""compressed points""?  At its heart, point-compression is really about minimizing the amount of data that has to be sent over the network.  It turns out that, given the X coordinate of a point on a NIST curve, you can solve for the Y coordinate, but there are 2 possible answers.  Some clever people at Certicom noticed that the two possible Y coordinates that go with a given X coordinate always differ in their least-significant bit---thus while they have to send all of X, they could get away with only sending the LSb of Y (i.e., just enough info so you know which of the two solutions for Y is correct).  So that EccPointType of ""compressed lsb y-1"" tells you that for your X coordinate, the correct Y coordinate is the one that has a 1 in the LSb. </p>

<p>The best news about this is that you don't have to care.  ECDSA only uses the X coordinate of R, which is sitting there in the first opaque blob labeled 'x'.</p>

<p>So this was a long-winded explanation to say ""you don't have to do anything.  You're already holding the right <code>r</code> (= X coord of R) and <code>s</code> to feed into OpenSSL's ECDSA_do_verify.</p>
","300","<c><openssl><ecdsa>","0","0","1","2017-11-22 05:09:07","","0","","6782754","","2017-11-08 15:40:40","2017-11-06 14:03:55",""
"45426149","Erroring out creating an ECDSA Key pair with pkcs11interop","<p>I am connecting to Gemalto HSM which supports secp256r1. I have the following code to create an ECDSA key pair using Pkcs11interop. I am getting the paramsBytes using BouncyCastle NistNamedCurves and X962Parameters. </p>

<p>The HSM keeps comming back with CKR_ATTRIBUTE_TYPE_INVALID. I am new to ECDSA so I may have missed something. Any ideas?</p>

<pre><code>                X9ECParameters x9Ec = NistNamedCurves.GetByName(""P-256"");
                X962Parameters x962 = new X962Parameters(x9Ec);
                byte[] paramsBytes =  x962.GetDerEncoded();

                // The CKA_ID attribute is intended as a means of distinguishing multiple key pairs held by the same subject
                byte[] ckaId = session.GenerateRandom(20);

                // Prepare attribute template of new public key
                List&lt;ObjectAttribute&gt; publicKeyAttributes = new List&lt;ObjectAttribute&gt;();
                publicKeyAttributes.Add(new ObjectAttribute(CKA.CKA_PRIVATE, false));
                publicKeyAttributes.Add(new ObjectAttribute(CKA.CKA_LABEL, keyName));
                publicKeyAttributes.Add(new ObjectAttribute(CKA.CKA_ID, ckaId));
                publicKeyAttributes.Add(new ObjectAttribute(CKA.CKA_VERIFY, true));
                publicKeyAttributes.Add(new ObjectAttribute(CKA.CKA_ECDSA_PARAMS, paramsBytes));

                // Prepare attribute template of new private key
                List&lt;ObjectAttribute&gt; privateKeyAttributes = new List&lt;ObjectAttribute&gt;();
                privateKeyAttributes.Add(new ObjectAttribute(CKA.CKA_PRIVATE, true));
                privateKeyAttributes.Add(new ObjectAttribute(CKA.CKA_LABEL, keyName));
                privateKeyAttributes.Add(new ObjectAttribute(CKA.CKA_ID, ckaId));
                privateKeyAttributes.Add(new ObjectAttribute(CKA.CKA_SENSITIVE, true));
                privateKeyAttributes.Add(new ObjectAttribute(CKA.CKA_SIGN, true));
                privateKeyAttributes.Add(new ObjectAttribute(CKA.CKA_ECDSA_PARAMS, paramsBytes));

                // Generate key pair
                Mechanism mechanism = new Mechanism(CKM.CKM_ECDSA_KEY_PAIR_GEN);
                ObjectHandle publicKeyHandle = null;
                ObjectHandle privateKeyHandle = null;
                session.GenerateKeyPair(mechanism, publicKeyAttributes, privateKeyAttributes, out publicKeyHandle,
                    out privateKeyHandle);
</code></pre>
","<p>Found out what was going on. The HSM did not like the </p>

<pre><code>privateKeyAttributes.Add(new ObjectAttribute(CKA.CKA_ECDSA_PARAMS, paramsBytes));
</code></pre>

<p>on the private key. PKCS states that the ECDSA params need to be on the public key and can't be on the private key and this implementation enforced that.</p>
","300","<pkcs#11><ecdsa><hsm><gemalto><pkcs11interop>","1","2","1","2017-08-01 18:23:07","45443263","0","0","","","","2017-07-31 22:20:04",""
"46198335","How to extract ephemeral and static private keys from ecc private key using openssl","<p>I am using the following openssl command to generate an ECC key for SECp384:</p>

<pre><code>openssl ecparam -genkey -name secp384r1 -out private.pem
</code></pre>

<p>Can someone please let me know how to extract ephemeral(k) and static(k) private keys from generated ecc private key using openssl?</p>

<p>In the link <a href=""https://www.ietf.org/rfc/rfc4754.txt"" rel=""nofollow noreferrer"">https://www.ietf.org/rfc/rfc4754.txt</a> these are mentioned as <code>w</code> and <code>k</code>.</p>
","<p>An ephemeral key is a key you generate, use, then throw away.</p>

<p>A static key is a key you use for a long time, perhaps by putting it into an X.509 Public Key Certificate.</p>

<p>Each of those are concept words, and behind the concept would be an ECC key like the one you generated.</p>

<pre><code>        key
       /   \
static       ephemeral
   |             |
 cert          keyGenerator
   |
 getAssociatedKey
</code></pre>
","299","<openssl><ecdsa>","0","0","1","2017-09-13 16:05:54","","0","","2810305","","2017-09-13 13:34:11","2017-09-13 13:02:12",""
"20781563","How can I recover compressed y value from sender?","<p>I am working on following scenario:</p>

<ol>
<li>Generate private and public key</li>
<li><p>Generate compressed public key with:</p>

<p><code>PublicKey.AccessGroupParameters().SetPointCompression(true)</code></p></li>
<li><p>Sign some data and send to other end with compressed public key.</p></li>
<li><p>[At other end] verify signature using public key</p></li>
</ol>

<p>For step 4, I need recover y value. Is there some API I can use among Crypto++?</p>
","<blockquote>
  <p>For step 4, I need recover y value. Is there some API I can use among Crypto++?</p>
</blockquote>

<p>During verification, you will load the persisted or serialized key after setting point compression to <code>true</code>.</p>

<hr>

<p>Below is a little program to experiment with point compression. You can find it on the Crypto++ wiki under <a href=""http://www.cryptopp.com/wiki/Point_Compression"" rel=""nofollow"">Point Compression</a>.</p>

<p>It generates a random key, then creates two public key - one with and and without compression. They two public keys are serialized. Then, it loads two new public keys with the serialized values.</p>

<p>Key 1 (no compress) and Key 2 (compress) and saved, then Key 3 (no compress) and Key 4 (no compress) are loaded from saved values. The keys are the same, and the output is:</p>

<pre><code>$ ./cryptopp-test.exe
Key 1 size (no compression): 214
  3081D33081A406072A8648CE3D0201308198020101302006072A8648CE3D0101021500FFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFF7FFFFFFF302C0414FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC0414
1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA450429044A96B5688EF573284664698968C38BB913CB
FC8223A628553168947D59DCC912042351377AC5FB3202150100000000000000000001F4C8F927AED3
CA752257020101032A0004CBFD13CEB20D677D9D3781AFA2E66B7BD5BC0E3C4EB8702144AA62BE5235
DFC691567AA2A7101AB1

Key 2 size (compression): 174
  3081AB30819006072A8648CE3D0201308184020101302006072A8648CE3D0101021500FFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFF7FFFFFFF302C0414FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC0414
1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA450415024A96B5688EF573284664698968C38BB913CB
FC8202150100000000000000000001F4C8F927AED3CA75225702010103160003CBFD13CEB20D677D9D
3781AFA2E66B7BD5BC0E3C

Key 3 (after deserialization of Key 1):
  y3.x: cbfd13ceb20d677d9d3781afa2e66b7bd5bc0e3ch
  y3.y: 4eb8702144aa62be5235dfc691567aa2a7101ab1h
Key 4 (after deserialization of Key 2):
  y4.x: cbfd13ceb20d677d9d3781afa2e66b7bd5bc0e3ch
  y4.y: 4eb8702144aa62be5235dfc691567aa2a7101ab1h
</code></pre>

<p>Here's the program to create, copy, save, load, compress, uncompress and serialize the keys and points.</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include &lt;string&gt;
using std::string;

#include &lt;cryptopp/osrng.h&gt;
using CryptoPP::AutoSeededRandomPool;

#include &lt;cryptopp/secblock.h&gt;
using CryptoPP::SecByteBlock;

#include &lt;cryptopp/filters.h&gt;
using CryptoPP::StringSource;
using CryptoPP::StringSink;

#include &lt;cryptopp/hex.h&gt;
using CryptoPP::HexEncoder;

#include &lt;cryptopp/sha.h&gt;
using CryptoPP::SHA1;

#include &lt;cryptopp/integer.h&gt;
using CryptoPP::Integer;

#include &lt;cryptopp/eccrypto.h&gt;
using CryptoPP::ECP;
using CryptoPP::ECDSA;

#include &lt;cryptopp/oids.h&gt;
using CryptoPP::ASN1::secp160r1;

int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    // Generate a private key, and two public keys.
    //   One with and one without compression
    ECDSA&lt;ECP, SHA1&gt;::PrivateKey privateKey;
    privateKey.Initialize(prng, secp160r1());

    ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey1;
    privateKey.MakePublicKey(publicKey1);

    ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey2;
    privateKey.MakePublicKey(publicKey2);
    publicKey2.AccessGroupParameters().SetPointCompression(true);

    // Save the public keys
    string p1, p2;
    publicKey1.Save(StringSink(p1).Ref());
    publicKey2.Save(StringSink(p2).Ref());

    // Print some stuff about them
    string s3, s4;
    StringSource ss3(p1, true, new HexEncoder(new StringSink(s3)));
    StringSource ss4(p2, true, new HexEncoder(new StringSink(s4)));

    cout &lt;&lt; ""Key 1 (not compressed): "" &lt;&lt; p1.size() &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""  "" &lt;&lt; s3 &lt;&lt; endl;
    cout &lt;&lt; ""Key 2 (compressed): "" &lt;&lt; p2.size() &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""  "" &lt;&lt; s4 &lt;&lt; endl;
    cout &lt;&lt; endl;

    // Two new keys to load up the persisted keys
    ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey3, publicKey4;
    publicKey4.AccessGroupParameters().SetPointCompression(true);

    publicKey3.Load(StringSource(p1, true).Ref());
    publicKey4.Load(StringSource(p2, true).Ref());

    // And validate them
    publicKey3.Validate(prng, 3);
    publicKey4.Validate(prng, 3);

    // Get the public elements of the loaded keys
    const ECP::Point&amp; y3 = publicKey3.GetPublicElement();
    const Integer&amp; y3_x = y3.x;
    const Integer&amp; y3_y = y3.y;

    const ECP::Point&amp; y4 = publicKey4.GetPublicElement();
    const Integer&amp; y4_x = y4.x;
    const Integer&amp; y4_y = y4.y;

    // Print some stuff about them
    cout &lt;&lt; ""Key 3 (after deserialization of Key 1):"" &lt;&lt; endl;
    cout &lt;&lt; ""  y3.x: "" &lt;&lt; std::hex &lt;&lt; y3_x &lt;&lt; endl;
    cout &lt;&lt; ""  y3.y: "" &lt;&lt; std::hex &lt;&lt; y3_y &lt;&lt; endl;
    cout &lt;&lt; ""Key 4 (after deserialization of Key 2):"" &lt;&lt; endl;
    cout &lt;&lt; ""  y4.x: "" &lt;&lt; std::hex &lt;&lt; y4_x &lt;&lt; endl;
    cout &lt;&lt; ""  y4.y: "" &lt;&lt; std::hex &lt;&lt; y4_y &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>

<hr>

<p>You can even cross wires when loading the serialized keys and it just works. Below, the compressed key was loaded from a non-compressed serialization (and vice-versa):</p>

<pre><code>//////////////////////////////////////////////////////////////////////
// Two new keys to load up the persisted keys, but crossing wires
//   so so there's a compress/uncompressed mismatch
ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey5, publicKey6;
publicKey6.AccessGroupParameters().SetPointCompression(true);

// This should be `p1`
publicKey5.Load(StringSource(p2, true).Ref());
// This should be `p2`
publicKey6.Load(StringSource(p1, true).Ref());

// Get the public elemnts of the loaded keys
const ECP::Point&amp; y5 = publicKey5.GetPublicElement();
const Integer&amp; y5_x = y5.x;
const Integer&amp; y5_y = y5.y;

const ECP::Point&amp; y6 = publicKey6.GetPublicElement();
const Integer&amp; y6_x = y6.x;
const Integer&amp; y6_y = y6.y;

// Print some stuff about them
cout &lt;&lt; ""Key 5 (after deserialization of Key 1):"" &lt;&lt; endl;
cout &lt;&lt; ""  y5.x: "" &lt;&lt; std::hex &lt;&lt; y5_x &lt;&lt; endl;
cout &lt;&lt; ""  y5.y: "" &lt;&lt; std::hex &lt;&lt; y5_y &lt;&lt; endl;
cout &lt;&lt; ""Key 6 (after deserialization of Key 2):"" &lt;&lt; endl;
cout &lt;&lt; ""  y6.x: "" &lt;&lt; std::hex &lt;&lt; y6_x &lt;&lt; endl;
cout &lt;&lt; ""  y6.y: "" &lt;&lt; std::hex &lt;&lt; y6_y &lt;&lt; endl;
cout &lt;&lt; endl;
</code></pre>

<hr>

<p>If you want to get at the underlying domain parameters (like the base point), use:</p>

<pre><code>const DL_GroupParameters_EC&lt; ECP &gt;&amp; params = publicKey.GetGroupParameters()
</code></pre>
","297","<signing><elliptic-curve><crypto++><ecdsa><compression>","1","3","1","2019-02-01 11:30:57","21036981","0","","608639","","2015-10-19 17:42:13","2013-12-26 08:23:25",""
"41046577","ECIES with Inferno: Signing with ECDSA","<p>I'm trying to sign a text file encrypted with ECIES, using Inferno. The encryption and key exchange parts work well but I'm left with a few questions regarding ECDSA.</p>

<p>1- I guess that the ECDSA signature must be stored in the sent file, so that receiver can use it to verify data integrity, right?</p>

<p>2- I have read many times that signing should be performed on hashed data, yet the data sent with ECIES is encrypted, not hashed else how can receiver retrieve it?</p>

<p>3- Where in the following code example should the signing take place? The current attempt does not work since although the signature is accepted upon decryption, an empty string is returned(instead of decrypted text).</p>

<pre><code>    internal static void EncryptText(string text, Keyring k, string file, bool forSender)
    {
        // never mind the Keyring class, it has no methods and only exposes
        // a few properties to store the session keys conveniently

        SharedEphemeralBundle ephemeralBundle;
        if (forSender) ephemeralBundle = k.SenderDHM.GetSharedEphemeralDhmSecret();
        else ephemeralBundle = k.ReceiverDHM.GetSharedEphemeralDhmSecret();

        var ephemeralPublic = ephemeralBundle.EphemeralDhmPublicKeyBlob;
        var ephemeralSymmetric = ephemeralBundle.SharedSecret;
        var textBytes = Utils.SafeUTF8.GetBytes(text);

        byte[] signature;            
        using (var ecdsa = new ECDsaCng(k.SenderDSA) { HashAlgorithm = CngAlgorithm.Sha384 })
            signature = ecdsa.SignData(textBytes);

        using (FileStream fs = new FileStream(file, FileMode.Create, FileAccess.Write))
        {
            fs.Write(signature, 0, signature.Length);
            fs.Write(ephemeralPublic, 0, ephemeralPublic.Length);

            EtM_EncryptTransform etm = new EtM_EncryptTransform(ephemeralSymmetric);
            using (CryptoStream cs = new CryptoStream(fs, etm, CryptoStreamMode.Write))                
                cs.Write(textBytes, 0, textBytes.Length);                                   
        }            
    }

    internal static string DecryptText(string file, Keyring k)
    {
        string decrypted = null;            
        var ephemeralPublic = new byte[104];
        var signature = new byte[96];            

        using (FileStream fs = new FileStream(file, FileMode.Open, FileAccess.Read))
        {
            fs.Read(signature, 0, 96);
            fs.Read(ephemeralPublic, 0, 104);

            var ephemeralSymmetric = k.SenderDHM.GetSharedDhmSecret(ephemeralPublic.ToPublicKeyFromBlob());
            EtM_DecryptTransform etm = new EtM_DecryptTransform(ephemeralSymmetric);
            using (CryptoStream cs = new CryptoStream(fs, etm, CryptoStreamMode.Read))
            {
                byte[] decrypt = new byte[fs.Length - 200];
                cs.Read(decrypt, 0, decrypt.Length);
                using (var ecdsa = new ECDsaCng(k.SenderDSA))
                {
                    // signature is accepted but returns an empty string!?
                    if (ecdsa.VerifyData(decrypt, signature))
                        decrypted = Utils.SafeUTF8.GetString(decrypt);                        
                }                        
            }                                                                                       
        }
        return decrypted;
    }
</code></pre>
","<p>Okay never mind, after closer inspection it looks like in my scenario, I can fortunately go with HMAC alone:</p>

<pre><code>    private static bool Authenticate(string file, byte[] key, bool masterKey = false)
    {
        int position = 104;
        if (masterKey) position = 48; 
        using (var fs = new FileStream(file, FileMode.Open, FileAccess.Read))
        using (var etm = new EtM_DecryptTransform(key, authenticateOnly: true))
        {
            fs.Position = position;
            using (var cs = new CryptoStream(fs, etm, CryptoStreamMode.Read))
                cs.CopyTo(Stream.Null);

            if (!etm.IsComplete) throw new Exception(""Some blocks were not authenticated"");
        }
        return true;
    }        

    internal static void EncryptText(string text, Keyring k, string file, bool forSender)
    {
        SharedEphemeralBundle ephemeralBundle;
        if (forSender) ephemeralBundle = k.SenderDHM.GetSharedEphemeralDhmSecret();
        else ephemeralBundle = k.ReceiverDHM.GetSharedEphemeralDhmSecret();

        var ephemeralPublic = ephemeralBundle.EphemeralDhmPublicKeyBlob;
        var ephemeralSymmetric = ephemeralBundle.SharedSecret;
        var textBytes = text.ToBytes();                       

        using (var fs = new FileStream(file, FileMode.Create, FileAccess.Write))
        {                
            fs.Write(ephemeralPublic, 0, ephemeralPublic.Length);
            using (var etm = new EtM_EncryptTransform(ephemeralSymmetric))
            using (var cs = new CryptoStream(fs, etm, CryptoStreamMode.Write))
                cs.Write(textBytes, 0, textBytes.Length);                                                                                       
        }            
    }

    internal static string DecryptText(string file, Keyring k)
    {
        string decrypted = null;            
        var ephemeralPublic = new byte[104];

        using (var fs = new FileStream(file, FileMode.Open, FileAccess.Read))
        {                
            fs.Read(ephemeralPublic, 0, 104);
            var ephemeralSymmetric = k.SenderDHM.GetSharedDhmSecret(ephemeralPublic.ToPublicKeyFromBlob());
            if (Authenticate(file, ephemeralSymmetric))
            {
                using (var etm = new EtM_DecryptTransform(ephemeralSymmetric))
                using (var cs = new CryptoStream(fs, etm, CryptoStreamMode.Read))
                {
                    var decrypt = new byte[fs.Length - 104];
                    cs.Read(decrypt, 0, decrypt.Length);
                    decrypted = decrypt.FromBytes();
                }
            }                                                                                                          
        }
        return decrypted;
    }
</code></pre>
","292","<c#><ecdsa><ecies>","0","0","1","2016-12-09 05:49:04","","0","","5795643","","2016-12-08 18:56:27","2016-12-08 18:39:48",""
"55710561","Validate JWT signature with ECDSA public key - Error decoding signature bytes","<p>i need some help to validate a jwt signature with a ECDSA public key. I'm reading the key from a .pem file with bouncy castle and using jjwt to do the validation. I'm getting an error while validating the signature.</p>

<pre><code>Security.addProvider(new BouncyCastleProvider());
String jwt = ""eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJtc2kiOiI5NzE1NTA5ODc2NTUiLCJmZWEiOiJzaWdudXAtZGF0YSIsImlzcyI6IkNEUCIsImV4cCI6MTU1NDU2NjMzNiwiaWF0IjoxNTU0MzkzNTM2LCJzaWQiOiIwNDI0MDMwMDg5NzI4MTg3QG5haS5lcGMubW5jMTMwLm1jYzMxMC4zZ3BwbmV0d29yay5vcmcifQ.RwxoGmFd1_dQPeGN-0gnWIW79xXvGHoyJKBbCKajgO75UooceS6tskxwqViEuP1gZD66UE8Bd2L0FaeI2aS_IA"";
PemReader pemReader = new PemReader(new FileReader(""/publickey.pem""));
X509EncodedKeySpec spec = new X509EncodedKeySpec(pemReader.readPemObject().getContent());
KeyFactory kf = KeyFactory.getInstance(""ECDSA"",""BC"");
PublicKey publicKey = kf.generatePublic(spec);
Jws&lt;Claims&gt; claims = Jwts.parser().setSigningKey(publicKey).parseClaimsJws(jwt);
</code></pre>

<p>I'm getting a Signature Exception with: Unable to verify Elliptic Curve signature using configured ECPublicKey. error decoding signature bytes.</p>
","<p>Problem found, i was using an old jjwt lib (0.6). Changed to 0.9 with the same code and it works as expected.</p>

<p>Thanks</p>
","285","<java><jwt><bouncycastle><ecdsa>","2","1","2","2019-05-01 03:39:40","","4","","","","","2019-04-16 14:28:12",""
"55710561","Validate JWT signature with ECDSA public key - Error decoding signature bytes","<p>i need some help to validate a jwt signature with a ECDSA public key. I'm reading the key from a .pem file with bouncy castle and using jjwt to do the validation. I'm getting an error while validating the signature.</p>

<pre><code>Security.addProvider(new BouncyCastleProvider());
String jwt = ""eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJtc2kiOiI5NzE1NTA5ODc2NTUiLCJmZWEiOiJzaWdudXAtZGF0YSIsImlzcyI6IkNEUCIsImV4cCI6MTU1NDU2NjMzNiwiaWF0IjoxNTU0MzkzNTM2LCJzaWQiOiIwNDI0MDMwMDg5NzI4MTg3QG5haS5lcGMubW5jMTMwLm1jYzMxMC4zZ3BwbmV0d29yay5vcmcifQ.RwxoGmFd1_dQPeGN-0gnWIW79xXvGHoyJKBbCKajgO75UooceS6tskxwqViEuP1gZD66UE8Bd2L0FaeI2aS_IA"";
PemReader pemReader = new PemReader(new FileReader(""/publickey.pem""));
X509EncodedKeySpec spec = new X509EncodedKeySpec(pemReader.readPemObject().getContent());
KeyFactory kf = KeyFactory.getInstance(""ECDSA"",""BC"");
PublicKey publicKey = kf.generatePublic(spec);
Jws&lt;Claims&gt; claims = Jwts.parser().setSigningKey(publicKey).parseClaimsJws(jwt);
</code></pre>

<p>I'm getting a Signature Exception with: Unable to verify Elliptic Curve signature using configured ECPublicKey. error decoding signature bytes.</p>
","<p>This will work as well without mentioning any algorithm.</p>

<pre><code>public boolean isTokenValid(String token) {
    try {
        String certificate = ""GET_YOUR_PUBLIC_CERTIFICATE_HERE""; //Either from REST call or reading from a cert file.
        getPublicKeyAndParseToken(token, certificate);
        return true;
    } catch (IOException e) {
        log.error("""", e);
    } catch (Exception e) {
        log.error("""", e);
        log.error(""JWT Not-Verified"");
    }
    return false;
}

private void getPublicKeyAndParseToken(String token, String certificate) throws IOException, CertificateException {
    log.debug(""Certificate:: "" + certificate); //Only for debugging purpose
    InputStream is = new ByteArrayInputStream(certificate.getBytes(StandardCharsets.UTF_8));
    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    Certificate cert = cf.generateCertificate(is);
    PublicKey publicKey = cert.getPublicKey();

    Jws parsedClaimsJws = Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token);
    log.debug(""Header:: "" + parsedClaimsJws.getHeader()); //Only for debugging purpose
    log.debug(""Body:: "" + parsedClaimsJws.getBody()); //Only for debugging purpose
}
</code></pre>

<p>Don't forget to use version '0.9.x' of jjwt library. I've below dependency in my build.gradle:</p>

<pre><code>compile('io.jsonwebtoken:jjwt:0.9.1')
</code></pre>
","285","<java><jwt><bouncycastle><ecdsa>","2","4","2","2019-05-01 03:39:40","","4","","","","","2019-04-16 14:28:12",""
"53813353","Javascript: Generating ECDSA public key from private key","<p>Is there any library that supports deriving the ecdsa public key from the private key for javascript (frontend)?  (With the private key, we can generate the corresponding public key)</p>

<p>I studied the <a href=""https://whitepaper.localethereum.com/#sec-undefined.Cryptography-layer"" rel=""nofollow noreferrer"">localethereum white paper</a>, and I would like to implement the crypto layer.</p>

<p>It says: </p>

<blockquote>
  <p>AccountKeyIdentityPublic  Using the SECP256k1 curve, an ECDSA public key that corresponds to AccountKeyIdentityPrivate.</p>
</blockquote>

<p>However, it seems that lots of libraries 
(<a href=""https://github.com/bitwiseshiftleft/sjcl/issues/322"" rel=""nofollow noreferrer"">1</a>,
<a href=""https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API"" rel=""nofollow noreferrer"">2</a>)  do not support this function.</p>

<p>Anyone can provide me some advise? Thanks!</p>
","<p>You can do such thing with a library that support point multiplication.
To get your public key, you just have to multiply a generation point G by your private key.  </p>

<p>For example with <strong>elliptic</strong> package : </p>

<pre><code>var EC = require('elliptic').ec;

// Create and initialize EC context
// (better do it once and reuse it)
var ec = new EC('secp256k1');

// Then generate the public point/key corresponding to your secret key.
var pubPoint = ec.keyFromSecret(secret).getPublic();
</code></pre>
","283","<javascript><frontend><ecdsa>","0","2","1","2018-12-17 11:09:02","53813990","2","","4225449","","2018-12-17 10:58:07","2018-12-17 10:33:31",""
"30950856","BAD_ACCESS (code=EXC_I386_GPFLT) when signing with ECDSA","<p>I am trying to use Crypto++ on iOS. I downloaded a prebuilt version of the library from <a href=""https://github.com/debris/cryptopp-ios"" rel=""nofollow noreferrer"">Marek Kotewicz's GitHub</a>.</p>

<p>I am struggling hard to run <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">this sample code</a> from the Crypto++ wiki.</p>

<pre><code>ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;

AutoSeededRandomPool prng, rrng;

privateKey.Initialize(prng, CryptoPP::ASN1::secp256k1());    
privateKey.MakePublicKey(publicKey);

string signature;       
string message = ""Do or do not. There is no try."";

StringSource s(message, true,
             new SignerFilter(rrng,
                              ECDSA&lt;ECP, CryptoPP::SHA256&gt;::Signer(privateKey),
                              new StringSink(signature)));
</code></pre>

<p>Its crashing with the following. Its showing up in Xcode output window:</p>

<pre><code>BAD_ACCESS (code=EXC_I386_GPFLT)  
</code></pre>

<p>This is the code snippet from memory.h of c++ file where it is pointing the BAD_ACCESS</p>

<pre><code> _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}
</code></pre>

<p>I am getting BAD_ACCESS(code=1 , address=0x0) error
pointing to this line of code of library</p>

<pre><code> -&gt;  0x1065dfa8d &lt;+85&gt;:  movq   -0x58(%rbp), %rdi
</code></pre>

<p><img src=""https://i.stack.imgur.com/Vm1D9.png"" alt=""This is the debugger output""></p>
","<blockquote>
  <p>Its crashing with the following. Its showing up in Xcode output window:</p>

<pre><code>BAD_ACCESS(code=EXC_I386_GPFLT)  
</code></pre>
</blockquote>

<p>The code looks OK to me.</p>

<hr>

<blockquote>
  <p>I am trying to use Crypto++ on iOS. I downloaded a prebuilt version of the library from Marek Kotewicz's GitHub.</p>
</blockquote>

<p>I'm just taking a stab in the dark. It presumes the code you showed above is <em>really</em> all you are doing in, say, a test <code>ViewController</code>.</p>

<p>The precompiled library appears to be using GNU's Standard C++ library. I would switch to LLVM's Standard C++ library by building Crypto++ with <code>-stdlib=c++</code> (and not GNU's <code>-stdlib=stdc++</code>). Apple switched to it years ago, and Xcode uses it by default.</p>

<p>You can find a GitHub with the fat library using LLVM Standard C++ at <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow"">noloader/cryptopp-5.6.2-ios</a>.</p>

<p>Or, you can build the fat library yourself. For that, see <a href=""http://www.cryptopp.com/wiki/IOS_%28Command_Line%29"" rel=""nofollow"">iOS (Command Line)</a> on the Crypto++ wiki. The prebuilt library at <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow"">cryptopp-5.6.2-ios</a> uses those instructions.</p>

<hr>

<blockquote>
<pre><code>AutoSeededRandomPool prng, rrng;
</code></pre>
</blockquote>

<p>You only need one of these.</p>

<hr>

<blockquote>
<pre><code>StringSource s(message, true,
               new SignerFilter(rrng,
                   ECDSA&lt;ECP, CryptoPP::SHA256&gt;::Signer(privateKey),
                       new StringSink(signature)));
</code></pre>
</blockquote>

<p>Over the years, I've come to wonder about the temporary signer created for the pipeline. I've changed the Crypto++ wiki to stop using them. Use this code instead:</p>

<pre><code>ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
...
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::Signer signer(privateKey);
...

StringSource s(message, true,
               new SignerFilter(prng, signer,
                   new StringSink(signature)));
</code></pre>
","277","<c++><ios><crypto++><ecdsa>","0","0","1","2019-10-11 09:34:25","","10","","3632958","","2015-06-21 09:05:58","2015-06-20 06:04:37",""
"49647305","Signature Algorithm sha256RSA with ECC Pubkey","<p>Quite by chance, I ran into Google certificate. Now questions come to my mind which I haven't find answers yet:</p>

<p>From the certificate, it seems RSA signature algorithm is used, but the public key is an ECC key. Can we possibly do RSA encryption/decryption with an ECC key? How can we make a certificate like this using openssl? (I've created certificates of RSA SA/RSA key, ECDSA SA/ECC key, but not like this one.)</p>

<p>Any answer is appreciated!</p>

<p>Screenshot of Google certificate
<a href=""https://i.stack.imgur.com/OsoG5.jpg"" rel=""nofollow noreferrer"">Google Certificate</a></p>
","<p>RSA signrature in the certificate means that Issuing CA (i.e. Google Internet Authority G3) used this algorithm to sign the End Entity certificate (google.com). It does not matter if the key pair was RSA or ECC.</p>

<p>You can not use RSA encryption with this End Entity certificate because it has ECC public key in it and AFAIK it is not possible to do encryption with ECC keys. Well, according to <a href=""https://en.wikipedia.org/wiki/Elliptic-curve_cryptography"" rel=""nofollow noreferrer"">this wiki link</a> you can.</p>

<p>If you want to make similar End entity certificate then make RSA CA then make ECC keypair and PKCS#10 request and issue the certificate using this request.</p>
","276","<openssl><certificate><rsa><x509><ecdsa>","1","2","1","2018-04-04 11:10:15","49649491","2","","","","","2018-04-04 09:23:14",""
"49102277","Extract ECPublicKey from a X509 certicate","<p>I'm having trouble extracting an ECPublicKey from an X509 certifcate using Java.</p>

<p>The keys and certificate were created as follows</p>

<pre><code>ssh-keygen -t ecdsa -f id_ecdsa
openssl pkcs8 -topk8 -in id_ecdsa -out id_ecdsa.p8
openssl req -new x509 -key id_ecdsa.p8 -out id_ecdsa.crt.der -outform der
</code></pre>

<p>The code used to extract the public key from the certificate is</p>

<pre><code>FileInputStream fin = new FileInputStream(""&lt;path to id_ecdsa.crt.der&gt;"");
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
X509Certificate cert = (X509Certificate) cf.generateCertificate(fin);
PublicKey pk = cert.getPublicKey();

if (pk instanceof ECPublicKey) {
  ECPublicKey key = (ECPublicKey) pk;
  ...
} else if (pk instanceof RSAPublicKey) {
  RSAPublicKey key = (RSAPublicKey) pk;
  ...
}
</code></pre>

<p>For a certificate containing an RSA key all is ok. However if an ECDSA key is used the if(pk instanceof ECPublicKey) block is ignored.</p>

<p>A call to pk.getAlgorithm() yields ""EC"" which suggests the key is an ECDSA key.</p>

<p>Examination of pk with a debugger yields a type X509Key for ECDSA. For an RSA key the debugger yields RSAPublicKeyImpl.</p>

<p>N.B. java.security.* is used as the library.</p>

<p>Any help solving my problem would be greatly appreciated.</p>
","<p>I found that adding Bouncy Castle as a provider appears to have fixed my issue. It appears JDK is not fitted with EC support by default.</p>

<pre><code>Security.addProvider(new BouncyCastleProvider());
CertificateFactory cf = CertificateFactory.getInstance(""X.509"", ""BC"");
</code></pre>
","273","<java><public-key><ecdsa>","0","-1","1","2018-03-11 14:23:03","","0","","238704","","2018-03-11 14:23:03","2018-03-05 01:26:09",""
"19853372","What will be the behaviour if chosen cipher suite is ECDSA but the chosen client certificate is RSA","<p>In case of TLS1.1 and TLS 1.0, what will be the behavior in the following scenario ?</p>

<p>Suppose the server and client both are capable of handling RSA and ECDSA, the client sends a list of cipher suites and server chooses ECDSA for authentication. Then the server requests for client certificate. The client has both RSA and ECDSA certificates for client authentication. If the client chooses an RSA certificate now. What will happen in this case.</p>
","<p>The client has to supply a certificate that matches the server-specified certificate type and accepted issuers. ""The certificate type must be appropriate for the selected cipher suite's key exchange algorithm"". <a href=""http://www.ietf.org/rfc/rfc2246.txt"" rel=""nofollow"">RFC 2246</a>.</p>
","270","<ssl><encryption><rsa><ecdsa>","0","2","1","2013-11-08 11:22:58","","0","","238704","","2013-11-08 11:22:58","2013-11-08 07:06:36",""
"52134521","Java's BouncyCastle doesn't always verify OpenSSL ECDSA signature","<p>I sign text using OpenSSL (in C++) however my Java program doesn't always validate signed messages (only ~1 out of 5 gets verified). Interestingly <a href=""https://kjur.github.io/jsrsasign/sample/sample-ecdsa.html"" rel=""nofollow noreferrer"">https://kjur.github.io/jsrsasign/sample/sample-ecdsa.html</a> doesn't verify any of them:</p>

<p>Curve name: <strong>secp256k1</strong>
Signature algorithm: <strong>SHA256withECDSA</strong></p>

<p><strong>privateKey</strong></p>

<pre><code>431313701ec60d303fa7d027d5f1579eaa57f0e870b23e3a25876e61bed2caa3
</code></pre>

<p><strong>publicKey</strong></p>

<pre><code>035bcefc4a6ca257e394e82c20027db2af368474afb8917273713644f11a7cecb3
</code></pre>

<p><strong>Failed</strong>:</p>

<pre class=""lang-none prettyprint-override""><code>text to sign=
    pcax2727gRo8M6vf9Vjhr1JDrQ3rdPYu6xx81000pcax273z8kaV5Ugsiqz3tvWGo8Gg6sch6V4912341535867163229

signature=
    3044022061dff8e39f9324b0794ec2c58abda971898f694ca980baf3c2a4045a9048b441022054a2fb8ef3d383fd7eeb31425dba440e2fd2053778d4ab3725046385c7845cff0000
</code></pre>

<p><strong>Successful</strong>:</p>

<pre class=""lang-none prettyprint-override""><code>text to sign=
    pcax2727gRo8M6vf9Vjhr1JDrQ3rdPYu6xx81000pcax273z8kaV5Ugsiqz3tvWGo8Gg6sch6V4912341535867122614

signature=
    3046022100f200d0fb9e86a16bd46ee2dd11f1840a436d0a5c6823001a516e975a44906fcf022100d062a60611fc0f21d81fa3140741c8b6e650fff33d2c48aef69a3a40d7c7b3ca
</code></pre>

<p><strong>Java</strong></p>

<pre class=""lang-java prettyprint-override""><code>private static final String SHA256WITH_ECDSA = ""SHA256withECDSA"";

public static boolean isValidSignature(PublicKey pub, byte[] dataToVerify, byte[] signature) {

    try {

        Signature sign = Signature.getInstance(SHA256WITH_ECDSA, BouncyCastleProvider.PROVIDER_NAME);

        sign.initVerify(pub);

        sign.update(dataToVerify);

        return sign.verify(signature);

    } catch (Exception e) {
        log.error(""Error: "" + e.getMessage());
    }

    return false;

}
</code></pre>

<p><strong>C++</strong></p>

<pre class=""lang-cpp prettyprint-override""><code>std::vector&lt;unsigned char&gt; utils::crypto::sign(std::string&amp; private_key_58, std::string&amp; message) {

    auto priv_bytes = utils::base58::decode_base(private_key_58);

    auto digest = utils::crypto::sha256(message);

    auto key = utils::crypto::ec_new_keypair(priv_bytes);

    auto signature = ECDSA_do_sign(digest.data(), digest.size(), key);

    auto der_len = ECDSA_size(key);
    auto der = (uint8_t*) calloc(der_len, sizeof(uint8_t));
    auto der_copy = der;
    i2d_ECDSA_SIG(signature, &amp;der_copy);

    std::vector&lt;unsigned char&gt; s (der, der+der_len);

    return s;

}

std::vector&lt;unsigned char&gt; utils::crypto::sha256(std::string&amp; str) {

    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&amp;sha256);
    SHA256_Update(&amp;sha256, str.c_str(), str.size());
    SHA256_Final(hash, &amp;sha256);

    std::vector&lt;unsigned char&gt; data(hash, hash + SHA256_DIGEST_LENGTH);

    return data;

}

EC_KEY *utils::crypto::ec_new_keypair(std::vector&lt;unsigned char&gt;&amp; priv_bytes) {

    EC_KEY *key = nullptr;
    BIGNUM *priv = nullptr;
    BN_CTX *ctx = nullptr;
    const EC_GROUP *group = nullptr;
    EC_POINT *pub = nullptr;

    key = EC_KEY_new_by_curve_name(NID_secp256k1);

    if (!key) {
        std::cerr &lt;&lt; ""Can't generate curve secp256k1\n"";
        std::abort();
    }

    priv = BN_new();
    BN_bin2bn(priv_bytes.data(), 32, priv);
    EC_KEY_set_private_key(key, priv);

    ctx = BN_CTX_new();
    BN_CTX_start(ctx);

    group = EC_KEY_get0_group(key);
    pub = EC_POINT_new(group);
    EC_POINT_mul(group, pub, priv, NULL, NULL, ctx);
    EC_KEY_set_public_key(key, pub);

    EC_POINT_free(pub);
    BN_CTX_end(ctx);
    BN_CTX_free(ctx);
    BN_clear_free(priv);

    return key;
}
</code></pre>
","<p>Neardupes <a href=""https://stackoverflow.com/questions/17269238/ecdsa"">ECDSA signature length</a> and <a href=""https://stackoverflow.com/questions/48177791/how-to-specify-signature-length-for-java-security-signature-sign-method"">how to specify signature length for java.security.Signature sign method</a> (and more links there) </p>

<p><strong>ASN.1 DER encoding is variable size</strong> for all but certain very limited data, and in particular for ECDSA (or DSA) signatures. <code>ECDSA_size</code> returns the <strong>maximum</strong> length possible for the given key, but each actual signature may be either that length or shorter, depending on the binary representations of the values r and s in the signature, which for your purposes can be treated essentially as random numbers.</p>

<p>In cases where an actual signature is shorter than <code>ECDSA_size</code> you still encode the entire buffer and pass it to your Java; notice the two bytes of zero (<code>0000</code> in hex) at the end of your 'failed' example? A DER decoder <em>can</em> ignore trailing garbage, and when I test such a case on older BouncyCastle and SunEC providers it actually works okay, but it fails for me starting at BouncyCastle 1.54 -- with a rather clear exception, 
<code>java.security.SignatureException: error decoding signature bytes.</code>
-- and SunEC starting at 8u121 with cause or exception similar to <code>java.security.SignatureException: Invalid encoding for signature</code>. </p>

<p>Many implementations have recently made DER decoding stricter, after some successful attacks on 'lax' encodings, including the secp256k1 signatures in Bitcoin -- see <a href=""https://bitcoin.stackexchange.com/questions/51706/what-can-be-changed-in-signed-bitcoin-transaction"">https://bitcoin.stackexchange.com/questions/51706/what-can-be-changed-in-signed-bitcoin-transaction</a> and <a href=""https://en.bitcoin.it/wiki/Transaction_malleability"" rel=""nofollow noreferrer"">https://en.bitcoin.it/wiki/Transaction_malleability</a> . This is mentioned in <a href=""http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html"" rel=""nofollow noreferrer"">the Oracle Java 8u121 release notes</a> item ""More checks added to DER encoding parsing code"" although I don't see anything similar for Bouncy.</p>

<p>Since secp256k1 is a Certicom/X9 'prime' (Fp) curve group, its cofactor is 1 and its order is very close to the underlying field size which in turn is very close to 256 bits which is a multiple of 8, so signatures in this group will DER-encode to the maximum length (and work) almost exactly 1/4 (25%) of the time; the rest of the time they will fail.</p>

<p>The official and best solution is to use the updated value in the pointer, here <code>der_copy</code>, output by (any) <code>i2d*</code> routine, to determine the length of the encoding, and use that length. If you can't handle variable length for some reason, you can transmit the whole buffer but then truncate it before passing to BouncyCastle (or SunEC) by using <code>2+signature[1]</code> as the valid length -- but not if you change to a curve larger than about 480 bits; above that it is different and more complicated.</p>
","265","<java><openssl><bouncycastle><ecdsa>","1","3","1","2018-09-02 14:18:47","52135544","0","0","238704","","2018-09-02 14:18:47","2018-09-02 06:24:20",""
"53924783","How to use ECDSA function in the medtls library","<p>I am using the mbedtls library (<a href=""https://github.com/ARMmbed/mbedtls"" rel=""nofollow noreferrer"">https://github.com/ARMmbed/mbedtls</a>) on an ARM micro-controller (Ambiq).</p>

<p>I need to use the function mbedtls_ecdsa_sign_det() to sign a bitcoin transaction.</p>

<p>Actually, I am not sure if this is the right function.</p>

<p>Here is the documentation of the function:</p>

<pre><code>Compute ECDSA signature of a previously hashed message, deterministic version (RFC 6979).

Parameters:
grp ECP group
r   First output integer
s   Second output integer
d   Private signing key
buf Message hash
blen    Length of buf
md_alg  MD algorithm used to hash the message
Returns:
0 if successful, or a MBEDTLS_ERR_ECP_XXX or MBEDTLS_MPI_XXX error code

The header file includes the following description:
/**
 * \brief           This function computes the ECDSA signature of a
 *                  previously-hashed message, deterministic version.
 *
 *                  For more information, see &lt;em&gt;RFC-6979: Deterministic
 *                  Usage of the Digital Signature Algorithm (DSA) and Elliptic
 *                  Curve Digital Signature Algorithm (ECDSA)&lt;/em&gt;.
 *
 * \note            If the bitlength of the message hash is larger than the
 *                  bitlength of the group order, then the hash is truncated as
 *                  defined in &lt;em&gt;Standards for Efficient Cryptography Group
 *                  (SECG): SEC1 Elliptic Curve Cryptography&lt;/em&gt;, section
 *                  4.1.3, step 5.
 *
 * \see             ecp.h
 *
 * \param grp       The context for the elliptic curve to use.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param r         The MPI context in which to store the first part
 *                  the signature. This must be initialized.
 * \param s         The MPI context in which to store the second part
 *                  the signature. This must be initialized.
 * \param d         The private signing key. This must be initialized
 *                  and setup, for example through mbedtls_ecp_gen_privkey().
 * \param buf       The hashed content to be signed. This must be a readable
 *                  buffer of length \p blen Bytes. It may be \c NULL if
 *                  \p blen is zero.
 * \param blen      The length of \p buf in Bytes.
 * \param md_alg    The hash algorithm used to hash the original data.
 *
 * \return          \c 0 on success.
 * \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
 *                  error code on failure.
 */
int mbedtls_ecdsa_sign_det( mbedtls_ecp_group *grp, mbedtls_mpi *r,
                            mbedtls_mpi *s, const mbedtls_mpi *d,
                            const unsigned char *buf, size_t blen,
                            mbedtls_md_type_t md_alg );
</code></pre>

<p>Besides, I do not find any example how to use this function.</p>

<p>I do not know how to initialize the passed pointers, grp, r, s and d.</p>
","<p>Mathematically speaking, an <a href=""https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">ECDSA signature</a> is a pair of two integers (<em>r</em>, <em>s</em>). The function <code>mbedtls_ecdsa_sign_det</code> gives you the two integers <code>r</code> and <code>s</code> as outputs and it's up to you to decide how you want to output those integers. There are two common representations of ECDSA signatures: take a fixed-size representation of <em>r</em> and <em>s</em> and put those two together, or assemble them in an <a href=""https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One"" rel=""nofollow noreferrer"">ASN.1</a> sequence, generally in <a href=""https://en.wikipedia.org/wiki/X.690#DER_encoding"" rel=""nofollow noreferrer"">DER</a> form (ASN.1 admits multiple representations, e.g. with or without leading zeros, and DER is a specific ASN.1 representation, without leading zeros). <a href=""https://bitcoin.stackexchange.com/questions/12554/why-the-signature-is-always-65-13232-bytes-long"">Bitcoin uses the DER representation</a>. Fortunately for you, Mbed TLS has a function that directly outputs this DER representation: <a href=""https://tls.mbed.org/api/ecdsa_8h.html#a76da70289de1f746ad9cce1eadf7b135"" rel=""nofollow noreferrer""><code>mbedtls_ecdsa_write_signature</code></a>.</p>

<p>There are two variants of ECDSA: randomized and deterministic. They produce compatible signatures anyway (the deterministic variant uses a specific choice for the random parameter). <code>mbedtls_ecdsa_write_signature</code> uses the deterministic variant if your build supports it and the randomized variant otherwise.</p>

<p>Here's how a call to this function looks like. It takes the following inputs:</p>

<ul>
<li>An ECDSA private key <code>key</code>.</li>
<li>A SHA-256 hash to sign <code>hash</code>.</li>
<li>The random number generator which you must initialize at the start of your program (not at each signature generation!). See <a href=""https://tls.mbed.org/kb/how-to/generate-an-aes-key"" rel=""nofollow noreferrer"">https://tls.mbed.org/kb/how-to/generate-an-aes-key</a> for an example.</li>
</ul>



<pre><code>unsigned char signature[2 * 32 + 9]; // ""at least twice as large as the size of the curve used, plus 9""
size_t signature_length;
ret = mbedtls_ecdsa_write_signature(key, MBEDTLS_MD_SHA256, hash, 32,
                                    signature, &amp;signature_length,
                                    mbedtls_ctr_drbg_random, &amp;ctr_drbg);
if (ret == 0) {
    // The signature is in the signature array. It is signature_length bytes long. 
} else ERROR();
</code></pre>
","262","<bitcoin><ecdsa><mbedtls>","0","1","1","2018-12-25 20:48:02","","0","","1068283","","2018-12-25 20:22:19","2018-12-25 18:42:13",""
"30170929","Segmentation fault when signing a message using OpenSSL, SWIG, and Perl","<p>We were using SWIG to make a C cryptographic utility library available to Perl. We are able to generate keys, create digests, but the signing code causes a segmentation fault, which we believe may be in the OpenSSL code itself but it's difficult to be sure.</p>

<p>This problem only comes up when running the code with SWIG, the native C code works.</p>

<p>In Perl, we call this: </p>

<pre><code>$signature = key_utils::mysignMessageWithPem($pem, $message);
</code></pre>

<p>Which calls this code in the .i file:</p>

<pre><code>%newobject mysignMessageWithPem;                                                                                                                                                                                                                                                                                              

%inline %{                                                                                                                                                                                                                                                                                                                    
  char *mysignMessageWithPem(char *pem, char *message) {                                                                                                                                                                                                                                                                      
    char *ret = malloc(145);                                                                                                                                                                                                                                                                                                  
    char *err = malloc(5);                                                                                                                                                                                                                                                                                                    
    int errorCode;                                                                                                                                                                                                                                                                                                            

    memcpy(err, ""ERROR"", 5);                                                                                                                                                                                                                                                                                                  

    errorCode = signMessageWithPem(pem, message, &amp;ret);                                                                                                                                                                                                                                                                       
    char *signature = ret;                                                                                                                                                                                                                                                                                                    

    if (errorCode == NOERROR) {                                                                                                                                                                                                                                                                                               
      return signature;                                                                                                                                                                                                                                                                                                       
    } else {                                                                                                                                                                                                                                                                                                                  
      return err;                                                                                                                                                                                                                                                                                                             
    }                                                                                                                                                                                                                                                                                                                         

  }                                                                                                                                                                                                                                                                                                                           
%}                     
</code></pre>

<p>Which calls this C code:</p>

<pre><code>int signMessageWithPem(char *message, char *pem, char **signature) {                                                                                                                                                                                                                                                          

unsigned int meslen = strlen(message);                                                                                                                                                                                                                                                                                    
unsigned char *messagebytes = calloc(meslen, sizeof(unsigned char));                                                                                                                                                                                                                                                      
ECDSA_SIG *sig = NULL;                                                                                                                                                                                                                                                                                                    
memcpy(messagebytes, message, meslen);                                                                                                                                                                                                                                                                                    

EC_KEY *key = NULL;                                                                                                                                                                                                                                                                                                       
BIO *in = NULL;                                                                                                                                                                                                                                                                                                           
unsigned char *buffer = NULL;                                                                                                                                                                                                                                                                                             

char *sha256ofMsg = calloc(SHA256_HEX_STRING, sizeof(char));                                                                                                                                                                                                                                                              
unsigned char *outBytesOfsha256ofMsg = calloc(SHA256_STRING, sizeof(unsigned char));                                                                                                                                                                                                                                      

digestOfBytes(messagebytes, &amp;sha256ofMsg, ""sha256"", meslen);                                                                                                                                                                                                                                                              
sha256ofMsg[64] = '\0';                                                                                                                                                                                                                                                                                                   
createDataWithHexString(sha256ofMsg, &amp;outBytesOfsha256ofMsg);                                                                                                                                                                                                                                                             

in = BIO_new(BIO_s_mem());                                                                                                                                                                                                                                                                                                
BIO_puts(in, pem);                                                                                                                                                                                                                                                                                                        
PEM_read_bio_ECPrivateKey(in, &amp;key, NULL, NULL);                                                                                                                                                                                                                                                                          

sig = ECDSA_do_sign((const unsigned char*)outBytesOfsha256ofMsg, SHA256_DIGEST_LENGTH, key);                                                                                                                                                                                                                              
int verify = ECDSA_do_verify((const unsigned char*)outBytesOfsha256ofMsg, SHA256_DIGEST_LENGTH, sig, key);                                                                                                                                                                                                                

if(verify != 1) {                                                                                                                                                                                                                                                                                                         
    return ERROR;                                                                                                                                                                                                                                                                                                         
}                                                                                                                                                                                                                                                                                                                         

int buflen = ECDSA_size(key);                                                                                                                                                                                                                                                                                             
buffer = OPENSSL_malloc(buflen);                                                                                                                                                                                                                                                                                          

int derSigLen = i2d_ECDSA_SIG(sig, &amp;buffer);                                                                                                                                                                                                                                                                              

char *hexData = calloc(derSigLen, sizeof(char));                                                                                                                                                                                                                                                                          
memcpy(hexData, buffer-derSigLen, derSigLen);                                                                                                                                                                                                                                                                             

char *hexString = calloc(derSigLen*2+1, sizeof(char));                                                                                                                                                                                                                                                                    

hexString[derSigLen * 2] = '\0';                                                                                                                                                                                                                                                                                          
toHexString(hexData, derSigLen, hexString);                                                                                                                                                                                                                                                                               

memcpy(*signature, hexString, derSigLen*2);                                                                                                                                                                                                                                                                               
signature[derSigLen * 2] = '\0';                                                                                                                                                                                                                                                                                          

EC_KEY_free(key);                                                                                                                                                                                                                                                                                                         

BIO_free_all(in);                                                                                                                                                                                                                                                                                                         
free(sha256ofMsg);                                                                                                                                                                                                                                                                                                        
free(outBytesOfsha256ofMsg);                                                                                                                                                                                                                                                                                              
free(hexData);                                                                                                                                                                                                                                                                                                            
free(hexString);                                                                                                                                                                                                                                                                                                          

return NOERROR;
}                  
</code></pre>

<p>And returns <code>Segmentation Fault</code>. The most informative error we have gotten is <code>perl crashed with SIGSEGV in EC_KEY_get_key_method_data()</code></p>

<p>The full code is here: <a href=""https://github.com/aleitner/bitpay-perl/tree/stack-overflow-question"" rel=""nofollow"">https://github.com/aleitner/bitpay-perl/tree/stack-overflow-question</a></p>

<p>Is this a bug with SSL, or are we doing this wrong?</p>
","<p>The answer to this question is: we were calling the arguments in the wrong order.</p>

<p>Seriously. The line: </p>

<p><code>$signature = key_utils::mysignMessageWithPem($pem, $message);</code></p>

<p>needed to be:</p>

<p><code>$signature = key_utils::mysignMessageWithPem($message, $pem);</code></p>

<p>We were in fact doing something wrong. I was tempted to remove the question, but maybe the answer can serve as a cautionary tale or something.</p>
","246","<c><perl><openssl><swig><ecdsa>","2","2","1","2015-05-11 17:33:32","30174049","0","1","","","","2015-05-11 14:52:28",""
"29170086","Create keys with python and use it in .net","<p>I try to create keys with the python package <a href=""https://pypi.python.org/pypi/ecdsa"" rel=""nofollow"">ecdsa</a>, export it to der and use them with BouncyCastle under .Net (and vice versa).</p>

<p>This is my code in Python:</p>

<pre><code>import base64
from ecdsa.keys import SigningKey
from ecdsa.curves import NIST521p, NIST384p, NIST256p

@classmethod
def CreateKey(self) -&gt; SigningKey:
    privateKey = SigningKey.generate(NIST256p) 
    return privateKey

@classmethod     
def GetPublicKey(self, privateKey: SigningKey) -&gt; str:
    publicKey = privateKey.get_verifying_key()
    der = publicKey.to_der()
    return base64.b64encode(der)
</code></pre>

<p>I get two strings that I want to import in .Net:</p>

<pre><code>        Const plainDerBase64Pub = ""MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyJW32bO4wswhE9ZC5klCjRNDJQSB0lIBphe9wIa/W2n3fBJ0cDpSpy9qlq2L6sa4W5lgRHYD9IyfETom6YOH/g==""
    Const plainDerBase64Priv = ""MHcCAQEEIKjIPCG9CGMunu34jXnDZg1LmNYrcJo8EqzKbRu2E24MoAoGCCqGSM49AwEHoUQDQgAEyJW32bO4wswhE9ZC5klCjRNDJQSB0lIBphe9wIa/W2n3fBJ0cDpSpy9qlq2L6sa4W5lgRHYD9IyfETom6YOH/g==""

    Dim keyPriv = PrivateKeyFactory.DecryptKey({}, Base64.Decode(plainDerBase64Priv))
    Dim keyPub = PrivateKeyFactory.DecryptKey({}, Base64.Decode(plainDerBase64Pub))
</code></pre>

<p>But I get an exception:</p>

<pre><code>Test method LicenseProtectorTest.KeyManagementTest.ImportKeyFromPythonTest threw exception: 
System.ArgumentException: Wrong number of elements in sequence
Parametername: seq
Result StackTrace:  
bei Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo..ctor(Asn1Sequence seq) in C:\BouncyCastle\crypto\src\asn1\pkcs\EncryptedPrivateKeyInfo.cs:Zeile 18.
   bei Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo.GetInstance(Object obj) in C:\BouncyCastle\crypto\src\asn1\pkcs\EncryptedPrivateKeyInfo.cs:Zeile 42.
   bei Org.BouncyCastle.Security.PrivateKeyFactory.DecryptKey(Char[] passPhrase, Asn1Object asn1Object) in C:\BouncyCastle\crypto\src\security\PrivateKeyFactory.cs:Zeile 196.
   bei Org.BouncyCastle.Security.PrivateKeyFactory.DecryptKey(Char[] passPhrase, Byte[] encryptedPrivateKeyInfoData) in C:\BouncyCastle\crypto\src\security\PrivateKeyFactory.cs:Zeile 182.
   bei LicenseProtectorTest.KeyManagementTest.ImportKeyFromPythonTest() in ...
</code></pre>

<p>Any idea what I'm doing wrong here?</p>
","<p>I'm not familiar with the python library, but I was able to guess at the formats and the following code will parse the example data:</p>

<pre><code>using System;

using Org.BouncyCastle.Asn1.Sec;
using Org.BouncyCastle.Asn1.X9;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Utilities.Encoders;

namespace BCTests
{
    class MainClass
    {
        public static void Main(string[] args)
        {
            var plainDerBase64Pub = ""MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyJW32bO4wswhE9ZC5klCjRNDJQSB0lIBphe9wIa/W2n3fBJ0cDpSpy9qlq2L6sa4W5lgRHYD9IyfETom6YOH/g=="";
            var plainDerBase64Priv = ""MHcCAQEEIKjIPCG9CGMunu34jXnDZg1LmNYrcJo8EqzKbRu2E24MoAoGCCqGSM49AwEHoUQDQgAEyJW32bO4wswhE9ZC5klCjRNDJQSB0lIBphe9wIa/W2n3fBJ0cDpSpy9qlq2L6sa4W5lgRHYD9IyfETom6YOH/g=="";

            var pubKeyBytes = Base64.Decode(plainDerBase64Pub);
            var privKeyBytes = Base64.Decode(plainDerBase64Priv);

            var pubKey = PublicKeyFactory.CreateKey(pubKeyBytes);

            var privKeyStruct = ECPrivateKeyStructure.GetInstance(privKeyBytes);
            var x9 = ECNamedCurveTable.GetByName(""P-256"");
            var ec = new ECDomainParameters(x9.Curve, x9.G, x9.N, x9.H, x9.GetSeed());
            var privKey = new ECPrivateKeyParameters(privKeyStruct.GetKey(), ec);
        }
    }
}
</code></pre>

<p>pubKey and privKey are then ECPublicKeyParameters and ECPrivateKeyParameters that you can use with various algorithms.</p>

<p>Note that DER is an encoding, not really a format. For the public key, the python code is producing a SubjectPublicKeyInfo, which is the standard X.509 format for public keys.</p>

<p>There ought to be an option with the private key of generating a PrivateKeyInfo (or EncryptedPrivateKeyInfo using a password), both of these are formats from the PKCS#8 standard. If the python code can output one of these, then decoding the private key would be easier as just PrivateKeyFactory.CreateKey(bytes) or .DecryptKey(password, bytes).</p>
","240","<python><.net><python-3.x><bouncycastle><ecdsa>","0","1","1","2015-04-16 08:28:05","29669297","0","","","","","2015-03-20 15:23:36",""
"33977131","How to do ECDHE handshake without exportable private key","<p>I'm building an OpenSSL engine that implements ECDSA_METHOD, which includes signature creation and signature verification functions. Since the only usage of ECDHE private key is related to signature creation, having the key exported from the engine and presenting it anywhere else is not required.</p>

<p>However, if I don't supply the private key to SSL_Context through SSL_set_private_key function SSL handshake fails with the error below:</p>

<pre><code>error:14094410:SSL routines:ssl3_read_bytes:sslv3 alert handshake failure
</code></pre>

<p>I've also tried to provide a mock key (one that is not related to a public key in the cert) to SSL_set_private_key function, but this function does verify if private/public keys match and throws an error about bad certificate if they don't.</p>

<p>It looks like openssl allows by-passing this validation in some cases, e.g. this is what I found in ssl/ssl_rsa.c</p>

<pre><code>#ifndef OPENSSL_NO_RSA
    /*
     * Don't check the public/private key, this is mostly for smart
     * cards.
     */
    if ((pkey-&gt;type == EVP_PKEY_RSA) &amp;&amp;
        (RSA_flags(pkey-&gt;pkey.rsa) &amp; RSA_METHOD_FLAG_NO_CHECK)) ;
    else
#endif
    if (!X509_check_private_key(c-&gt;pkeys[i].x509, pkey)) {
        X509_free(c-&gt;pkeys[i].x509);
        c-&gt;pkeys[i].x509 = NULL;
        return 0;
    }
</code></pre>

<p>I think, I need something similar for an EC key, but I didn't find it anywhere. Any other solutions are appreciated as well.</p>
","<blockquote>
  <p>Any other solutions are appreciated as well.</p>
</blockquote>

<p>This might not be the only option you have, but I think that you can achieve what you are looking for by creating your own <code>EVP_PKEY_METHOD</code> and implementing its functions as required. That way, you can store a handle to your own, for example, smart card based key and then invoke the proper sign methods at the right moment. You have to set the proper methods with the <code>EVP_PKEY_meth_set_Xyz()</code> functions, like <code>EVP_PKEY_meth_set_sign(&lt;yourSigningFunction&gt;)</code>. For example, if you were using the Windows crypto API, you would have to invoke <code>NCryptSignHash()</code> from your signing function. That way, you do not have to export the private key from the Windows key store to obtain a signature.</p>

<p>I have done this before and the only big thing I ran into (apart from lack of documentation and examples) was a missing key store functionality at the <code>EVP</code> level. There seems to be some work in progress as you can see <a href=""https://github.com/openssl/openssl/tree/master/crypto/store"" rel=""nofollow"">here</a>. As a work around, I had to select keys/certificates from the a store as part of the key generation mechanism and it is not really intended for that.</p>

<p>If you decide to go this route, then be prepared for a few weeks of trial and error.</p>
","230","<ssl><openssl><ecdsa><openssl-engine><ecdhe>","1","1","2","2015-12-07 21:39:41","","0","","1152643","","2015-11-30 19:46:32","2015-11-28 22:26:06",""
"33977131","How to do ECDHE handshake without exportable private key","<p>I'm building an OpenSSL engine that implements ECDSA_METHOD, which includes signature creation and signature verification functions. Since the only usage of ECDHE private key is related to signature creation, having the key exported from the engine and presenting it anywhere else is not required.</p>

<p>However, if I don't supply the private key to SSL_Context through SSL_set_private_key function SSL handshake fails with the error below:</p>

<pre><code>error:14094410:SSL routines:ssl3_read_bytes:sslv3 alert handshake failure
</code></pre>

<p>I've also tried to provide a mock key (one that is not related to a public key in the cert) to SSL_set_private_key function, but this function does verify if private/public keys match and throws an error about bad certificate if they don't.</p>

<p>It looks like openssl allows by-passing this validation in some cases, e.g. this is what I found in ssl/ssl_rsa.c</p>

<pre><code>#ifndef OPENSSL_NO_RSA
    /*
     * Don't check the public/private key, this is mostly for smart
     * cards.
     */
    if ((pkey-&gt;type == EVP_PKEY_RSA) &amp;&amp;
        (RSA_flags(pkey-&gt;pkey.rsa) &amp; RSA_METHOD_FLAG_NO_CHECK)) ;
    else
#endif
    if (!X509_check_private_key(c-&gt;pkeys[i].x509, pkey)) {
        X509_free(c-&gt;pkeys[i].x509);
        c-&gt;pkeys[i].x509 = NULL;
        return 0;
    }
</code></pre>

<p>I think, I need something similar for an EC key, but I didn't find it anywhere. Any other solutions are appreciated as well.</p>
","<p>Here is how you can by-pass openssl validation rules by providing an EC_KEY with a public key set equal to that of public cert and the private key set to any non-zero value (in my example I've just set it equal to the X coordinate of the public key). After the key is created and stored in a file, it can be passed as a regular private key to SSL_Context. </p>

<p>I think, idealistically openssl should address this issue in a more systematic and transparent way, but until it's done, the suggested solution can be used as a work around:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/x509v3.h&gt;


static char * my_prog = ""dummykey"";
static char * key_file = NULL;
static char * cert_file = NULL;
int verbose = 0;

static void print_help() {

    fprintf(stderr,""Version: %s\nUSAGE: %s -cert in_cert_file -key out_key_file\n"",
             VERSION, my_prog);
}

static void parse_args(int argc, char** argv) {

    argc--;
    argv++;

    while (argc &gt;= 1) {
        if (!strcmp(*argv,""-key"")) {
            key_file = *++argv;
            argc--;
        }
        else if (!strcmp(*argv,""-cert"")) {
            cert_file = *++argv;
            argc--;
        }
        else if (!strcmp(*argv,""-v"")) {
            verbose = 1;
        }
        else {
            fprintf(stderr, ""%s: Invalid param: %s\n"", my_prog, *argv);
            print_help();
            exit(1);
        }
        argc--;
        argv++;
    }

    if (key_file == NULL || cert_file == NULL ) {
        print_help();
        exit(1);
    }
}

int get_curve_nid(X509 *c) {
    int ret = 0;

    if (c-&gt;cert_info-&gt;key-&gt;algor-&gt;parameter) {
        ASN1_TYPE *p = c-&gt;cert_info-&gt;key-&gt;algor-&gt;parameter;
        if (p &amp;&amp; p-&gt;type == V_ASN1_OBJECT) {
            ret = OBJ_obj2nid(c-&gt;cert_info-&gt;key-&gt;algor-&gt;parameter-&gt;value.object);
        }
    }
    return ret;
}

int main(int argc, char** argv) {
    X509 *c=NULL;
    FILE *fp=NULL;
    FILE *ofp=NULL;
    EC_POINT *ec_point = NULL;
    BIGNUM *x = NULL;
    BIGNUM *y = NULL;
    EC_KEY *ec_key = NULL;
    EC_GROUP *grp = NULL;

    parse_args(argc, argv);

    fp = fopen(cert_file, ""r"");
    if (!fp) {
        fprintf(stderr,""%s: Can't open %s\n"", my_prog, cert_file);
        return 1;
    }
    c = PEM_read_X509 (fp, NULL, (int (*) ()) 0, (void *) 0);
    if (c) {
        x = BN_new();
        y = BN_new();
        int len = c-&gt;cert_info-&gt;key-&gt;public_key-&gt;length-1;
        BN_bin2bn(c-&gt;cert_info-&gt;key-&gt;public_key-&gt;data+1, len/2, x);
        BN_bin2bn(c-&gt;cert_info-&gt;key-&gt;public_key-&gt;data+1+len/2, len/2, y);

        EC_GROUP *grp = EC_GROUP_new_by_curve_name(get_curve_nid(c));

        ec_key = EC_KEY_new();
        int sgrp = EC_KEY_set_group(ec_key, grp);
        int sprk = EC_KEY_set_private_key(ec_key, x);
        if (sgrp &amp;&amp; sprk) {
           ec_point = EC_POINT_new(grp);
            int ac = EC_POINT_set_affine_coordinates_GFp(grp, ec_point, x, y, BN_CTX_new());
            int spub =EC_KEY_set_public_key(ec_key, ec_point);

            ofp = fopen(key_file, ""w"");
            int r = 0;
            if (ofp) {
                r = PEM_write_ECPrivateKey(ofp, ec_key, NULL, NULL, 0, NULL, NULL);
                if (!r)
                        fprintf(stderr,""%s: Can't write EC key %p to %s\n"", my_prog, ec_key, key_file);
            }
            else {
                        fprintf(stderr,""%s: Can't open %s\n"", my_prog, key_file);
            }
        }
    }
    if (ec_key)
        EC_KEY_free(ec_key);
    if (grp)
        EC_GROUP_free(grp);
    if (x)
        BN_free(x);
    if (y)
        BN_free(y);
    if (c)
        X509_free (c);
    if (fp)
        fclose(fp);
    if (ofp)
        fclose(ofp);
    return 0;
}
</code></pre>
","230","<ssl><openssl><ecdsa><openssl-engine><ecdhe>","1","0","2","2015-12-07 21:39:41","","0","","1152643","","2015-11-30 19:46:32","2015-11-28 22:26:06",""
"41447919","OpenSSL ECDSA verification performance issue","<p>I'm working on a project where I use ECDSA cryptography. For signature and key generation I use a hardware module, and I do the verification stuff using openssl.</p>

<p>My problem is that a single verification take 12 milliseconds. This is an ARM device (i.MX6 Quad, 4x1Ghz, 2Gb ram), but still, it looks very slow.</p>

<p>I compile using ""arm-poky-linux-gnueabi-g++"", provided by the hardware provider. Using -O3 vs -O0 does not radically change the time needed to verify.</p>

<pre><code>std::vector&lt;unsigned char&gt; digest = sha256(content);
ECDSA_SIG* sig = ...
EC_KEY* ec_key = ...

auto tref = getTimeInMillis();
int result = ECDSA_do_verify(&amp;(digest[0]),digest.size(), sig , ec_key);
auto duration = getTimeInMillis() - tref;
LOG(""call to ECDSA_do_verify "" + std::to_string(duration)+ ""ms"");
</code></pre>

<p>This line ECDSA_do_verify take 12ms (the test is done in a batch, this is stable). Do you think this is a reasonable time ?</p>
","","228","<c++><performance><openssl><ecdsa>","0","","0","2017-01-03 16:25:14","","2","","","","","2017-01-03 16:25:14",""
"55742269","Java Exception during signature verification (error decoding signature bytes)","<p>I have to verify a certificate. I'm not an expert of cryptography, so probably I did something (or everything :) ) wrong.
When the code reach the last step (<code>boolean b = sig.verify(CertSign);</code>), it fires an exception: <em>java.security.SignatureException: error decoding signature bytes</em>.
Could someone help me to figure out what I'm doing wrong?</p>

<p>The following is a test code that shows the problem:</p>

<pre class=""lang-java prettyprint-override""><code>    private void test() {
        byte [] CertBody = new byte[]{(byte)0x7F,(byte)0x4E,(byte)0x81,(byte)0x82,
                               (byte)0x5F,(byte)0x29,(byte)0x01,(byte)0x00,
                               (byte)0x42,(byte)0x08,(byte)0xFB,(byte)0x55,
                               (byte)0x54,(byte)0x4F,(byte)0x02,(byte)0xFF,
                               (byte)0xFF,(byte)0x01,(byte)0x5F,(byte)0x4C,
                               (byte)0x07,(byte)0xFF,(byte)0x53,(byte)0x4D,
                               (byte)0x52,(byte)0x44,(byte)0x54,(byte)0x02,
                               (byte)0x7F,(byte)0x49,(byte)0x4E,(byte)0x06,
                               (byte)0x09,(byte)0x2B,(byte)0x24,(byte)0x03,
                               (byte)0x03,(byte)0x02,(byte)0x08,(byte)0x01,
                               (byte)0x01,(byte)0x07,(byte)0x86,(byte)0x41,
                               (byte)0x04,(byte)0x6C,(byte)0x17,(byte)0x5B,
                               (byte)0xB9,(byte)0xEF,(byte)0x5D,(byte)0x02,
                               (byte)0x20,(byte)0x51,(byte)0xCC,(byte)0xB2,
                               (byte)0x89,(byte)0x09,(byte)0x42,(byte)0x15,
                               (byte)0x85,(byte)0xD3,(byte)0x1A,(byte)0xCD,
                               (byte)0xA7,(byte)0x1B,(byte)0x08,(byte)0x4A,
                               (byte)0x48,(byte)0x8F,(byte)0x7B,(byte)0x77,
                               (byte)0x5B,(byte)0x57,(byte)0x9B,(byte)0xB7,
                               (byte)0x41,(byte)0x3B,(byte)0xDA,(byte)0x4C,
                               (byte)0xDE,(byte)0x70,(byte)0x11,(byte)0x17,
                               (byte)0xE0,(byte)0xD9,(byte)0xD1,(byte)0x0F,
                               (byte)0x74,(byte)0xD6,(byte)0x25,(byte)0xB2,
                               (byte)0x86,(byte)0xCA,(byte)0x04,(byte)0x64,
                               (byte)0x54,(byte)0x4F,(byte)0x1B,(byte)0x53,
                               (byte)0xF3,(byte)0x24,(byte)0x02,(byte)0xD3,
                               (byte)0xB3,(byte)0x74,(byte)0xEF,(byte)0xA6,
                               (byte)0xC7,(byte)0x5F,(byte)0x20,(byte)0x08,
                               (byte)0xEA,(byte)0xF4,(byte)0xBE,(byte)0xCC,
                               (byte)0x03,(byte)0x18,(byte)0x02,(byte)0xA3,
                               (byte)0x5F,(byte)0x25,(byte)0x04,(byte)0x5A,
                               (byte)0xAF,(byte)0xA9,(byte)0xDF,(byte)0x5F,
                               (byte)0x24,(byte)0x04,(byte)0x5C,(byte)0x90,
                               (byte)0xDD,(byte)0x5F};

        byte [] CertSign = new byte[]{(byte)0x3D,(byte)0x61,(byte)0x23,
                                      (byte)0xBE,(byte)0x6C,(byte)0x0B,
                                      (byte)0xC1,(byte)0x3E,(byte)0x7A,
                                      (byte)0x2D,(byte)0x60,(byte)0x3D,
                                      (byte)0x28,(byte)0xF0,(byte)0x29,
                                      (byte)0xCC,(byte)0x8C,(byte)0x55,
                                      (byte)0xF1,(byte)0x9A,(byte)0x5C,
                                      (byte)0x7E,(byte)0xBE,(byte)0xFD,
                                      (byte)0x43,(byte)0x27,(byte)0x1A,
                                      (byte)0x9D,(byte)0xA1,(byte)0x7C,
                                      (byte)0x81,(byte)0x09,(byte)0x5C,
                                      (byte)0x1D,(byte)0x26,(byte)0x27,
                                      (byte)0x76,(byte)0x73,(byte)0x74,
                                      (byte)0x87,(byte)0xF9,(byte)0x6C,
                                      (byte)0x2A,(byte)0xC9,(byte)0xA3,
                                      (byte)0x32,(byte)0x3C,(byte)0x60,
                                      (byte)0x51,(byte)0x71,(byte)0x6D,
                                      (byte)0x2F,(byte)0xC0,(byte)0xF6,
                                      (byte)0x89,(byte)0x14,(byte)0x93,
                                      (byte)0xB2,(byte)0xB6,(byte)0x87,
                                      (byte)0x21,(byte)0xAF,(byte)0x01,
                                      (byte)0x42};


        String Algorithm = ""brainpoolP256r1"";

        byte [] PublicPoint = new byte[]{(byte)0x04,(byte)0x68,(byte)0xF8,
                                         (byte)0xD6,(byte)0xB3,(byte)0x94,
                                         (byte)0xD2,(byte)0x8E,(byte)0x2B,
                                         (byte)0x4D,(byte)0xFA,(byte)0x36,
                                         (byte)0x52,(byte)0xAE,(byte)0xAC,
                                         (byte)0xDA,(byte)0xD3,(byte)0x19,
                                         (byte)0x21,(byte)0xC2,(byte)0x12,
                                         (byte)0x8D,(byte)0x58,(byte)0x9F,
                                         (byte)0x4E,(byte)0xF1,(byte)0xB1,
                                         (byte)0xC4,(byte)0x10,(byte)0x97,
                                         (byte)0x29,(byte)0xDC,(byte)0xA8,
                                         (byte)0xA1,(byte)0xC9,(byte)0x53,
                                         (byte)0x04,(byte)0xC8,(byte)0x77,
                                         (byte)0x4F,(byte)0x57,(byte)0xFA,
                                         (byte)0xFB,(byte)0x15,(byte)0x59,
                                         (byte)0xB9,(byte)0x2F,(byte)0x72,
                                         (byte)0x6A,(byte)0xE4,(byte)0x22,
                                         (byte)0x64,(byte)0x3E,(byte)0x1B,
                                         (byte)0x11,(byte)0x8D,(byte)0x69,
                                         (byte)0xAC,(byte)0x36,(byte)0x25,
                                         (byte)0xAD,(byte)0x1C,(byte)0x30,
                                         (byte)0x04,(byte)0xA9};

        if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
           Security.addProvider(new BouncyCastleProvider());
        }

        ECNamedCurveParameterSpec params1 = ECNamedCurveTable.getParameterSpec(Algorithm);
        try {
            KeyFactory fact = KeyFactory.getInstance(""ECDSA"", ""BC"");
            ECCurve curve = params1.getCurve();
            java.security.spec.EllipticCurve ellipticCurve = EC5Util.convertCurve(curve, params1.getSeed());
            java.security.spec.ECPoint point=ECPointUtil.decodePoint(ellipticCurve, PublicPoint);
            java.security.spec.ECParameterSpec params2=EC5Util.convertSpec(ellipticCurve, params1);
            java.security.spec.ECPublicKeySpec keySpec = new java.security.spec.ECPublicKeySpec(point,params2);
            ECPublicKey PK = (ECPublicKey)fact.generatePublic(keySpec);
            Signature sig;
            sig = Signature.getInstance(""ECDSA"", ""BC"");
            sig.initVerify(PK);
            sig.update(CertBody);
            boolean b = sig.verify(CertSign);
            if (b)
            {
                Logger.getLogger(CardManager.class.getName()).log(Level.INFO, ""verificato"");
            }
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeySpecException | InvalidKeyException | SignatureException ex) {
            Logger.getLogger(""test"").log(Level.SEVERE, null, ex);
        }
    } 
</code></pre>

<p>I Expected to have the b equals true (or false) but instead I get the following exception:</p>

<pre class=""lang-java prettyprint-override""><code>_java.security.SignatureException: error decoding signature bytes.
    at org.bouncycastle.jcajce.provider.asymmetric.util.DSABase.engineVerify(DSABase.java:80)
    at java.security.Signature$Delegate.engineVerify(Signature.java:1223)
    at java.security.Signature.verify(Signature.java:656)_
</code></pre>
","<p><strong>Reason for the Exception</strong></p>

<p>As already mentioned in the comments to the question, the length of the signature differs from the expected length.</p>

<p>The exception happens, since a DER encoded signature with 70 bytes is expected, but your CertSign contains only 64 bytes. </p>

<p><strong>Assumptions</strong></p>

<p>Since it is 64 bytes, one could assume that it is an ECDSA signature consisting of two concatenated BigInteger numbers with 32 bytes each.  </p>

<p><strong>Conversion of ECDSA signature to DER encoded signature</strong></p>

<p>To convert that to a DER encoded signature one can use sth like:</p>

<pre><code>private byte[] DEREncodeSignature(byte [] signature) throws IOException {
    BigInteger r = new BigInteger(1, Arrays.copyOfRange(signature, 0, 32));
    BigInteger s = new BigInteger(1, Arrays.copyOfRange(signature, 32, 64));
    ASN1EncodableVector v = new ASN1EncodableVector();
    v.add(new ASN1Integer(r));
    v.add(new ASN1Integer(s));
    return new DERSequence(v).getEncoded(ASN1Encoding.DER);
}
</code></pre>

<p>Then the lines in your code where you use the signature needs to be adjusted, e.g. to sth like this:</p>

<pre><code>    boolean b = sig.verify(DEREncodeSignature(CertSign));
    if (b) {
        Logger.getLogger(CardManager.class.getName()).log(Level.INFO, ""verificato"");
    }
    else {
        Logger.getLogger(CardManager.class.getName()).log(Level.INFO, ""controllo fallito"");
    }
</code></pre>

<p><strong>Quick Test</strong></p>

<p>The exception is then gone, the output in the debug console looks like this:</p>

<pre><code>May 11, 2019 5:09:48 PM CardManager test
INFO: controllo fallito
</code></pre>

<p>So the verification actually fails, but you mention that you expect b to be either true or false, so maybe it's the right result. But without having more data this is not possible to validate. </p>

<p><strong>Further Tests</strong></p>

<p>I also quickly tried different signature algorithms with your code. For each of them one gets a false. </p>

<pre><code>String[] signatureAlgorithms = new String[] {""RIPEMD160withECDSA"", ""SHA224withECDDSA"", ""SHA256withECDDSA"", ""SHA384withECDDSA"", ""SHA512withECDDSA"", ""SHA1withECDSA"", ""NONEwithECDSA"", ""SHA224withECDSA"", ""SHA256withECDSA"", ""SHA384withECDSA"", ""SHA512withECDSA"", ""SHA3-224withECDSA"", ""SHA3-256withECDSA"", ""SHA3-384withECDSA"", ""SHA3-512withECDSA""};
for(String algorithm : signatureAlgorithms) {
    Signature sig;
    Logger.getLogger(CardManager.class.getName()).log(Level.INFO, ""trying aloorithm "" + algorithm + "": "");
    sig = Signature.getInstance(algorithm, ""BC"");
    ...
</code></pre>

<p>Still - without further data (e.g. used signature algorithm etc.) it is difficult to say what the reason for the mismatch is. </p>

<p><strong>Use Different Test Data</strong></p>

<p>To verify that the routines including the new DEREncodeSignature is working correctly I signed the message 'Hello world!' with <code>ECDSA</code> generator using the <code>brainpoolP256r1</code> parameter spec and <code>SHA256withECDDSA</code> signature algorithm, then the data looks like this: </p>

<pre><code>byte[] CertBody = new byte[]{(byte) 0x48,
        (byte) 0x65, (byte) 0x6C, (byte) 0x6C,
        (byte) 0x6F, (byte) 0x20, (byte) 0x77,
        (byte) 0x6F, (byte) 0x72, (byte) 0x6C,
        (byte) 0x64, (byte) 0x21};

byte[] CertSign = new byte[]{
        (byte)0x0C,(byte)0x5B,(byte)0xE9,
        (byte)0xA4,(byte)0xF7,(byte)0xC9,
        (byte)0x5A,(byte)0x69,(byte)0x8E,
        (byte)0x91,(byte)0x50,(byte)0xB4,
        (byte)0x4E,(byte)0x33,(byte)0x14,
        (byte)0x7C,(byte)0x2F,(byte)0x15,
        (byte)0x93,(byte)0x97,(byte)0x8B,
        (byte)0xD8,(byte)0x65,(byte)0x20,
        (byte)0x1B,(byte)0x1D,(byte)0xF4,
        (byte)0x8A,(byte)0xB3,(byte)0x81,
        (byte)0x55,(byte)0x6A,

        (byte)0x96,
        (byte)0xE4,(byte)0x89,(byte)0x05,
        (byte)0x80,(byte)0xAA,(byte)0x34,
        (byte)0x3A,(byte)0x86,(byte)0x11,
        (byte)0x5F,(byte)0x0B,(byte)0x8F,
        (byte)0xF7,(byte)0xE7,(byte)0xA6,
        (byte)0x7D,(byte)0xCC,(byte)0x9C,
        (byte)0xD0,(byte)0xC8,(byte)0x94,
        (byte)0xCA,(byte)0x78,(byte)0x9C,
        (byte)0xFE,(byte)0x41,(byte)0x2A,
        (byte)0xB0,(byte)0xE1,(byte)0x7E,
        (byte)0x29,
};

byte[] PublicPoint = new byte[]{
        (byte) 0x04,
        (byte) 0x1E, (byte) 0xC8, (byte) 0xB7,
        (byte) 0x00, (byte) 0xF1, (byte) 0xFD,
        (byte) 0x06, (byte) 0x97, (byte) 0x73,
        (byte) 0x71, (byte) 0x09, (byte) 0x12,
        (byte) 0xF2, (byte) 0xB7, (byte) 0xEF,
        (byte) 0xA5, (byte) 0x23, (byte) 0xA1,
        (byte) 0xC1, (byte) 0x6C, (byte) 0xA7,
        (byte) 0xD1, (byte) 0x0C, (byte) 0x25,
        (byte) 0x6E, (byte) 0x04, (byte) 0x09,
        (byte) 0x7A, (byte) 0x62, (byte) 0xC3,
        (byte) 0x0E, (byte) 0x93, (byte) 0x54,
        (byte) 0x7F, (byte) 0x0C, (byte) 0xE4,
        (byte) 0x0F, (byte) 0xF8, (byte) 0x63,
        (byte) 0x82, (byte) 0x6D, (byte) 0x0B,
        (byte) 0x50, (byte) 0xC0, (byte) 0x59,
        (byte) 0x1F, (byte) 0xFC, (byte) 0x36,
        (byte) 0x1B, (byte) 0x0E, (byte) 0x2A,
        (byte) 0xA3, (byte) 0xD4, (byte) 0x29,
        (byte) 0x4E, (byte) 0x30, (byte) 0x91,
        (byte) 0x44, (byte) 0x28, (byte) 0x2E,
        (byte) 0x15, (byte) 0x76, (byte) 0x48,
        (byte) 0xE7
};
</code></pre>

<p>If that data is taken and run through the routines incl. DEREncodeSignature then the following output is shown in the debug console:</p>

<pre><code>May 12, 2019 12:13:42 AM CardManager test
INFO: verificato
</code></pre>

<p>(using <code>sig = Signature.getInstance(""SHA256withECDDSA"", ""BC"");</code> of course)</p>

<p>This means that for <code>ECDSA</code> generated data with <code>brainpoolP256r1</code> parameter spec and <code>SHA256withECDDSA</code> it would work with the alternative test data. </p>
","226","<java><security><digital-signature><ecdsa><der>","0","2","1","2019-05-11 22:32:55","56091579","4","","2855231","","2019-04-19 12:03:41","2019-04-18 08:42:20",""
"48933231","Is there any ECDSA Attack if I have millions of signatures?","<p>I have been given the task to test the security of our company software. Our company software generates ecdsa signed supply order files. One can generate as many files as he wants.</p>

<p>so my question is <strong>Is there any ECDSA Attack if I have millions of signatures?</strong></p>

<p>we are using 112bit prime curve order: 4451685225093714776491891542548933</p>

<p>I have calculated 1 million signatures using the following method:</p>

<pre><code>public void GenerateSignature()
{
    //curve order
    BigInteger n = ec.N;

    Ramdom rand = new Random();

    //private key
    BigInteger d = ((ECPrivateKeyParameters)key).D;

    //loop for 1 million signatures
    for (int i = 1; i &lt;= 1000000; i++)
    {
        //random k and e
        BigInteger e = new BigInteger(112, rand).Mod(n);        //new biginteger by giving bitlength and random
        BigInteger k = new BigInteger(112, rand).Mod(n);

        //calculate r
        BigInteger r = key.Parameters.G.Multiply(k).X.ToBigInteger().Mod(n);

        //calculate s
        BigInteger s = k.ModInverse(n).Multiply(e.Add(d.Multiply(r))).Mod(n);

        //save generated signatures to database
        new DBCon().ExecuteNonQuery(""Insert into signatures values ('"" + e.ToString() + ""', '"" + r.ToString() + ""', '"" + s.ToString() + ""')"");
    }   
}
</code></pre>

<p>I am using BouncyCastle crypto library with C#.</p>

<p>I know private key can be calculated if k values is known by <strong>d = (sk - e) / r</strong></p>

<p>I also know private key can be calculated if two signatures have identical r value then we can calculate k by <strong>k = (e1 - e2) / (s1 - s2)</strong> and then d by using above formula.</p>

<p>I also know that private key can be calculated if some bits of <strong>k</strong> are known using <strong>about 100 signatures</strong> with <strong>lattice attacks</strong>, but in this case bits of <strong>k</strong> are unknown.</p>

<p>any help will be appreciated.
Thanks.</p>
","","225","<c#><bouncycastle><ecdsa><signatures>","1","","0","2018-03-25 22:40:05","","2","","2679518","","2018-03-25 22:40:05","2018-02-22 17:02:40",""
"51700529","BouncyCastle implematetion on iOS","<p>I have implemented ECDSA on android using bouncyCastle with the help of this link: <a href=""https://snipplr.com/view/18368/"" rel=""nofollow noreferrer"">https://snipplr.com/view/18368/</a><br>
Now I am stuck in iOS implementation as bouncyCastle doesn't support on iOS and I want to develop similar input and output relationship for digital verification module for SHA256 and particular curve. 
please help.</p>
","","224","<ios><swift><ecdsa>","0","","0","2018-08-06 04:24:12","","2","1","","","","2018-08-06 04:24:12",""
"32151835","How to create ECDSA key pair without openssl","<p>I am writing a cross-platform application in c++. I would like to know if it is possible to create an ECDSA key pair (public key and private key) without using any external library, just pure c++. Any answer leading me to the right path would be much appreciated.</p>
","","222","<c++><public-key-encryption><ecdsa>","1","","0","2015-08-22 03:01:42","","2","","","","","2015-08-22 03:01:42",""
"50874497","SSH Server sending different Keys for authentication (RSA & ECDSA) & in RSA mode unable to login","<p>Came across an SSH key based issue : </p>

<p>SSH Client : HALP-GRDB</p>

<p>SSH Server (has 2 IPs for management &amp; service) : 10.100.113.55 and 
                                                  10.100.114.55</p>

<p><strong>SSH to the Server IP 10.100.113.55</strong></p>

<pre><code>[root@HALP-GRDB .ssh]# ssh rapid@10.100.113.55
The authenticity of host '10.100.113.55 (10.100.113.55)' can't be established.
ECDSA key fingerprint is c8:d7:70:6c:1b:13:99:d8:76:0b:dc:25:84:a1:e7:86.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '10.100.113.55' (ECDSA) to the list of known hosts.
rapid@10.100.113.55's password:
[rapid@HALP-MSERV1 ~]$
</code></pre>

<p>All is good and am able to login via ECDSA Key</p>

<p><strong>Now SSH to the alternate IP 10.100.114.55</strong></p>

<p>Things get weirder ,</p>

<p>And RSA key has been asked for auth </p>

<pre><code>&gt; [root@HALP-GRDB .ssh]# ssh rapid@10.100.114.55 The authenticity of
&gt; host '10.100.114.55 (10.100.114.55)' can't be established. RSA key
&gt; fingerprint is c8:b7:31:02:75:b5:48:12:ef:9a:d7:95:91:0d:c0:f5. Are
&gt; you sure you want to continue connecting (yes/no)? yes Warning:
&gt; Permanently added '10.100.114.55' (RSA) to the list of known hosts.
&gt; ################################################################################
&gt;                                 !!!!! WARNING !!!!!
&gt;                               For authorized use only!
&gt;                    Any unauthorized use of this system is unlawful.
&gt;     Any use of this system may be logged or monitored without further notice.
&gt;                                 !!!!! WARNING !!!!!
&gt; ################################################################################                            User Authentication Password:  User Authentication Password: User
&gt; Authentication Password:
  Authentication Password:
  Authentication Password:
Received disconnect from 10.100.114.55: 2:
&gt; The connection is closed by SSH server
</code></pre>

<p>And even after entering the correct password , am kicked out</p>

<p>Server side sshd_config file :</p>

<pre><code>cat /etc/ssh/sshd_config
#       $OpenBSD: sshd_config,v 1.100 2016/08/15 12:32:04 naddy Exp $

# This is the sshd server system-wide configuration file.  See
# sshd_config(5) for more information.

# This sshd was compiled with PATH=/usr/local/bin:/usr/bin

# The strategy used for options in the default sshd_config shipped with
# OpenSSH is to specify options with their default value where
# possible, but leave them commented.  Uncommented options override the
# default value.

# If you want to change the port on a SELinux system, you have to tell
# SELinux about this change.
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
#
#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_dsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key

# Ciphers and keying
#RekeyLimit default none

# Logging
#SyslogFacility AUTH
SyslogFacility AUTHPRIV
#LogLevel INFO

# Authentication:

#LoginGraceTime 2m
PermitRootLogin no
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

#PubkeyAuthentication yes

# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
# but this is overridden so installations will only check .ssh/authorized_keys
AuthorizedKeysFile      .ssh/authorized_keys

#AuthorizedPrincipalsFile none

#AuthorizedKeysCommand none
#AuthorizedKeysCommandUser nobody

# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
#HostbasedAuthentication no
# Change to yes if you don't trust ~/.ssh/known_hosts for
# HostbasedAuthentication
#IgnoreUserKnownHosts no
# Don't read the user's ~/.rhosts and ~/.shosts files
#IgnoreRhosts yes

# To disable tunneled clear text passwords, change to no here!
#PasswordAuthentication yes
#PermitEmptyPasswords no
PasswordAuthentication yes

# Change to no to disable s/key passwords
#ChallengeResponseAuthentication yes
ChallengeResponseAuthentication no

# Kerberos options
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosGetAFSToken no
#KerberosUseKuserok yes

# GSSAPI options
GSSAPIAuthentication yes
GSSAPICleanupCredentials no
#GSSAPIStrictAcceptorCheck yes
#GSSAPIKeyExchange no
#GSSAPIEnablek5users no

# Set this to 'yes' to enable PAM authentication, account processing,
# and session processing. If this is enabled, PAM authentication will
# be allowed through the ChallengeResponseAuthentication and
# PasswordAuthentication.  Depending on your PAM configuration,
# PAM authentication via ChallengeResponseAuthentication may bypass
PermitRootLogin no
# If you just want the PAM account and session checks to run without
# PAM authentication, then enable this but set PasswordAuthentication
# and ChallengeResponseAuthentication to 'no'.
# WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several
# problems.
UsePAM yes

#AllowAgentForwarding yes
#AllowTcpForwarding yes
#GatewayPorts no
X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes
#PermitTTY yes
#PrintMotd yes
#PrintLastLog yes
#TCPKeepAlive yes
#UseLogin no
#UsePrivilegeSeparation sandbox
#PermitUserEnvironment no
#Compression delayed
ClientAliveInterval 600
#ClientAliveCountMax 3
#ShowPatchLevel no
#UseDNS yes
#PidFile /var/run/sshd.pid
#MaxStartups 10:30:100
#PermitTunnel no
#ChrootDirectory none
#VersionAddendum none

# no default banner path
#Banner none

# Accept locale-related environment variables
AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE
AcceptEnv XMODIFIERS

# override default of no subsystems
Subsystem       sftp    /usr/libexec/openssh/sftp-server

# Example of overriding settings on a per-user basis
#Match User anoncvs
#       X11Forwarding no
#       AllowTcpForwarding no
#       PermitTTY no
#       ForceCommand cvs server
</code></pre>

<p>Server side ssh_config file :</p>

<pre><code>[root@HALP-MSERV1 .ssh]# cat /etc/ssh/ssh_config
#       $OpenBSD: ssh_config,v 1.30 2016/02/20 23:06:23 sobrado Exp $

# This is the ssh client system-wide configuration file.  See
# ssh_config(5) for more information.  This file provides defaults for
# users, and the values can be changed in per-user configuration files
# or on the command line.

# Configuration data is parsed as follows:
#  1. command line options
#  2. user-specific file
#  3. system-wide file
# Any configuration value is only changed the first time it is set.
# Thus, host-specific definitions should be at the beginning of the
# configuration file, and defaults at the end.

# Site-wide defaults for some commonly used options.  For a comprehensive
# list of available options, their meanings and defaults, please see the
# ssh_config(5) man page.

# Host *
#   ForwardAgent no
#   ForwardX11 no
#   RhostsRSAAuthentication yes
#   RSAAuthentication yes
#   PasswordAuthentication yes
#   HostbasedAuthentication no
#   GSSAPIAuthentication no
#   GSSAPIDelegateCredentials no
#   GSSAPIKeyExchange no
#   GSSAPITrustDNS no
#   BatchMode no
#   CheckHostIP yes
#   AddressFamily any
#   ConnectTimeout 0
#   StrictHostKeyChecking ask
#   IdentityFile ~/.ssh/identity
#   IdentityFile ~/.ssh/id_rsa
#   IdentityFile ~/.ssh/id_dsa
#   IdentityFile ~/.ssh/id_ecdsa
#   IdentityFile ~/.ssh/id_ed25519
#   Port 22
#   Protocol 2
#   Cipher 3des
#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
#   MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160
#   EscapeChar ~
#   Tunnel no
#   TunnelDevice any:any
#   PermitLocalCommand no
#   VisualHostKey no
#   ProxyCommand ssh -q -W %h:%p gateway.example.com
#   RekeyLimit 1G 1h
#
# Uncomment this if you want to use .local domain
# Host *.local
#   CheckHostIP no

Host *
        GSSAPIAuthentication yes
# If this option is set to yes then remote X11 clients will have full access
# to the original X11 display. As virtually no X11 client supports the untrusted
# mode correctly we set this to yes.
        ForwardX11Trusted yes
# Send locale-related environment variables
        SendEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
        SendEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
        SendEnv LC_IDENTIFICATION LC_ALL LANGUAGE
        SendEnv XMODIFIERS
</code></pre>

<p>Appreciate your expert opinions for the rectification of the same .</p>

<p>Thanks !! </p>
","","220","<ssh><rsa><ecdsa>","0","","0","2018-06-15 11:34:37","","2","","9730164","","2018-06-15 11:34:37","2018-06-15 11:17:17",""
"53734440","How to sign ECDSA with pem private key?","<p>I have private key with pem format.</p>

<pre><code>-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIBAFWFAlCWPb8IvM4yHLLKBIN/mEJU9cZnM5JD2U2EmAoAcGBSuBBAAK
oUQDQgAErMGUjbHcEf7Gk9gVOOlWdqSaGc0YhE5HBPqhoniBUG8MTx5AT7mxtuyn
QkydMeOciHyvvyU0gf81UW9udef2nA==
-----END EC PRIVATE KEY-----
</code></pre>

<p>I want to sign with ruby code like following.</p>

<pre><code>require 'ecdsa'
def sign(str)
    digest = Digest::SHA256.digest(str) 
    temp_key = str.size 
    signature = ECDSA.sign($group, $private_key, digest, temp_key)
end
</code></pre>

<p>I want to know how to code for reading PEM private key file and using to sign.</p>
","<p>To parse your key stored in PEM format, you can use the openssl module: <code>sudo gem install openssl</code></p>

<p>Using this module, you will extract the private key this way: <code>OpenSSL::PKey::EC.new(pemcontent).private_key</code></p>

<p>Note that your private key is based on the <strong>secp256k1</strong> elliptic curve:</p>

<pre><code>% openssl ec -text 2&gt;&amp;1 &lt;&lt; EOF | grep OID
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIBAFWFAlCWPb8IvM4yHLLKBIN/mEJU9cZnM5JD2U2EmAoAcGBSuBBAAK
oUQDQgAErMGUjbHcEf7Gk9gVOOlWdqSaGc0YhE5HBPqhoniBUG8MTx5AT7mxtuyn
QkydMeOciHyvvyU0gf81UW9udef2nA==
-----END EC PRIVATE KEY-----
EOF
ASN1 OID: secp256k1
</code></pre>

<p>Therefore, the first parameter to give to <code>EDSA.sign()</code> must be <code>ECDSA::Group::Secp256k1</code>. This is an object that contains the parameters that define this curve.</p>

<p>Finally, here is your code, on which I've made the changes needed to make it work:</p>

<pre><code>require 'ecdsa'
require 'openssl'

def sign(str)
  pemcontent = ""-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIBAFWFAlCWPb8IvM4yHLLKBIN/mEJU9cZnM5JD2U2EmAoAcGBSuBBAAK
oUQDQgAErMGUjbHcEf7Gk9gVOOlWdqSaGc0YhE5HBPqhoniBUG8MTx5AT7mxtuyn
QkydMeOciHyvvyU0gf81UW9udef2nA==
-----END EC PRIVATE KEY-----""
  digest = Digest::SHA256.digest(str)
  temp_key = str.size
  signature = ECDSA.sign(ECDSA::Group::Secp256k1, OpenSSL::PKey::EC.new(pemcontent).private_key, digest, temp_key)
  return signature
end
</code></pre>

<p>Note: the value of temp_key should be generated with a more random way than using the length of the message to sign, like you did in your example code (it is a <strong>very</strong> <strong>very</strong> bad idea since soon or later, you will sign two messages with the same length, and this could let your private key been discovered).</p>
","216","<digital-signature><ruby><ecdsa>","0","0","1","2018-12-19 23:09:22","","1","","","","","2018-12-09 15:10:49",""
"46730753","How to change the key length of ECDSA?","<p>Recently, I was trying to do something with the code of ECDSA.  I want to change the key length of it but in vain. I checked the internet and found some source code of ECDSA, but somehow it only allows 32 bytes.</p>

<p>For example, I found this:</p>

<pre><code>varcrypto=require(""crypto"");
vareccrypto=require(""eccrypto"");    

//Anewrandom32-byteprivatekey.
varprivateKey=crypto.randomBytes(32);

//Correspondinguncompressed(65-byte)publickey.
varpublicKey=eccrypto.getPublic(privateKey);

varstr=""messagetosign"";

//Alwayshashyoumessagetosign!    
varmsg=crypto.createHash(""sha256"").update(str).digest();

eccrypto.sign(privateKey,msg).then(function(sig){
   console.log(""SignatureinDERformat:"",sig);
   eccrypto.verify(publicKey,msg,sig).then(function(){    
    console.log(""SignatureisOK"");
   }).catch(function(){    
      console.log(""SignatureisBAD"");
   });
});
</code></pre>

<p>from <a href=""https://www.npmjs.com/package/eccrypto"" rel=""nofollow noreferrer"">this</a> website. I tried to change the privateKey from 32 bytes to 16 bytes and other values. It ended up giving me errors.</p>

<p>Recently I discovered that to have different key length you need different curves. Does anybody know how to change the curve in the above code? If not, would someone provide source code that can use different key lengths of ECDSA?</p>

<p>(I'm quite new to ECC, so if I used wrong terms or I completely misunderstood the concept of it, please forgive).</p>
","<p>According to <a href=""https://github.com/bitchan/eccrypto#implementation-details"" rel=""nofollow noreferrer"">https://github.com/bitchan/eccrypto#implementation-details</a> (which looks like the right library for your code) the library only supports the <code>secp256k1</code> curve.</p>

<p>Most other libraries, if given no context other than the curve being a 256-bit curvespace, will assume it is <code>secp256r1</code> (r instead of k), meaning that the library you chose doesn't interoperate with a lot of libraries.  (For example, Windows 7, 8, and 8.1 cannot do <code>secp256k1</code> using the OS-provided cryptographic libraries)</p>

<p>So for ""how do I use a different sized key with this library?"" the answer is ""you can't, sorry"".  And for ""what library can I use, then?"" the answer is ""sorry, that's outside the scope of StackOverflow"".</p>
","210","<javascript><digital-signature><elliptic-curve><ecdsa>","-1","1","1","2017-10-13 16:30:02","","1","","472495","","2017-10-13 16:30:02","2017-10-13 13:09:24",""
"43213932","Different output while using openssl_sign() in PHP","<p>I recent tried to use PHP openssl extension with an ecdsa self signed certificate that i've issued using this tutorial <a href=""https://msol.io/blog/tech/create-a-self-signed-ecc-certificate/"" rel=""nofollow noreferrer"">create-a-self-signed-ecc-certificate</a>. I have used function openssl_sign() as described in PHP manual. I've notice every time i refresh the web page , i got different signature output. Can anyone explain what happen? And is there any manner to get the same signature output every time with ecdsa certificate?</p>
","<p>A component of generating an ECDSA signature is generating a random number (k).</p>

<p>Since each call to sign will generate a distinct random number, there's no way to produce a deterministic certificate with ECDSA (aside from doing all of the ECC math yourself, and choosing k; or finding a library somewhere which lets k be specified).</p>
","210","<php><openssl><ecdsa>","0","0","1","2017-04-06 15:47:47","43259952","0","","","","","2017-04-04 17:31:23",""
"50115208","Verify SHA1withECDSA signature on Scala","<p>I am trying to write simple code for creating public/private keys, signing and verifying ECDSA signature. I have no idea why verification returns false. Please help me.</p>

<p>** I also tried to set provider to ""SunEC"" but it still doesn't work</p>

<pre><code>val signatureECDSA = ""SHA1withECDSA""

val signatureInstance = Signature.getInstance(signatureECDSA)

def sign(text: String, privateKey: PrivateKey): Array[Byte] = {

  signatureInstance.initSign(privateKey)
  signatureInstance.update(text.getBytes(""UTF-8""))
  signatureInstance.sign
}

def verify(signature: Array[Byte], publicKey: PublicKey): Boolean = {

  signatureInstance.initVerify(publicKey)
  signatureInstance.verify(signature)
}

def createPrivatePublicKeyPair(): Unit = {

  val keyGen = KeyPairGenerator.getInstance(""EC"")
  val ecSpec = new ECGenParameterSpec(""secp256k1"")
  keyGen.initialize(ecSpec)

  val keyPair = keyGen.generateKeyPair
  val publicKey = keyPair.getPublic
  val privateKey = keyPair.getPrivate

  val ecPrivateKey = privateKey.asInstanceOf[ECPrivateKey]
  val ecPublicKey = publicKey.asInstanceOf[ECPublicKey]

  val msg = ""This is a message""

  val signature = sign(msg, ecPrivateKey)

  System.out.println(""Signature: "" + new BigInteger(1, signature).toString(16))

  val result = verify(signature, ecPublicKey)
  System.out.println(""public key matched with signature "" + result)
}
</code></pre>
","<p>The signature does encapsulate the <strong>hash over the data</strong> in some way or other. In the case of RSA signatures the hash is simply contained in the signature. In the case of ECDSA the hash is used within the signature calculation and cannot be retrieved, but it can of course still be used to verify the signature.</p>

<p>What is not included in the signature is the data over which the signature is calculated. Instead you need to provide the data using <code>signatureInstance.update(text.getBytes(""UTF-8""))</code> in the verification method, just as in the method that generates the signature.</p>
","208","<java><scala><digital-signature><ecdsa><key-pair>","1","1","1","2018-05-11 19:15:07","50298874","2","","2332830","","2018-05-01 14:43:00","2018-05-01 10:49:44",""
"47145179","how I can make public key from private (ecdsa) in java without Bouncy Castle?","<p>I have private key (ecdsa,secp256r1).  </p>

<pre><code>private final static String SHA = ""SHA-256"";
        private final static String MODE = ""EC"";
        private final static String PROV = ""SunEC"";
        private final static String ECC_ALGO = ""secp256r1"";

public static KeyPair eccKeyGen() {


                KeyPairGenerator kpg;
                KeyPair kp = null;
                try {
                        kpg = KeyPairGenerator.getInstance(MODE, PROV);
                        ECGenParameterSpec ecsp;
                        ecsp = new ECGenParameterSpec(ECC_ALGO);
                        kpg.initialize(ecsp);
                        kp = kpg.genKeyPair();
                        return kp;
                } catch (Exception e) {
                        System.out.println(""Key generation error."");
                        e.printStackTrace();
                }
                return kp;
</code></pre>

<p>How I can make public key from it in java without Bouncy Castle?</p>
","<p>Assuming your private key is in an OpenSSH format, you can use the <code>-y</code> option for <code>ssh-keygen</code>. For example, if your private is contained in <code>mykey</code>the following command will generate its public key</p>

<pre><code>ssh-keygen -y -f mykey &gt; mykey.pub
</code></pre>
","205","<java><ecdsa>","-1","0","1","2017-11-06 20:42:35","","1","","8896360","","2017-11-06 20:42:35","2017-11-06 20:26:55",""
"51970086","Android Java Spongycastle ECDSA Signature to subtle.crypto Javascript","<p>I'm importing a set of values from my website which is writen in Javascript using subtle.crypto for signing messages. In the QR Code I put the X, Y and D values of the key from Javascript, this is my code to replicate the key:</p>

<pre><code>public static KeyPair GenerateExistingKeyPair(String d, String x, String y) throws NoSuchProviderException, NoSuchAlgorithmException, InvalidKeySpecException {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
    Log.d(TAG, ""GenerateExistingKeyPair: PrivateKey D: "" + d);
    Log.d(TAG, ""GenerateExistingKeyPair: PublicKey X: "" + x);
    Log.d(TAG, ""GenerateExistingKeyPair: PublicKey Y: "" + y);

    BigInteger privateD = decode(d);
    BigInteger publicX = decode(x);
    BigInteger publicY = decode(y);

    KeyFactory keyFactory = KeyFactory.getInstance(""ECDSA"", BouncyCastleProvider.PROVIDER_NAME);;
    ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""P-256"");
    ECPoint Q = ecSpec.getG().multiply(privateD);

    ECPrivateKeySpec privSpec = new ECPrivateKeySpec(privateD, ecSpec);
    ECPublicKeySpec pubSpec = new ECPublicKeySpec(Q, ecSpec);

    PrivateKey privKey = keyFactory.generatePrivate(privSpec);
    PublicKey pubKey = keyFactory.generatePublic(pubSpec);

    KeyPair keyPair = new KeyPair(pubKey, privKey);
    Log.d(TAG, ""GenerateExistingKeyPair: KeyPair: "" + keyPair.getPrivate().toString());
    Log.d(TAG, ""GenerateExistingKeyPair: "" + Hex.toHexString(privKey.getEncoded()));
    return keyPair;

}
</code></pre>

<p>The ""decode"" I use because those values are stored in Base64 within Javascript.</p>

<pre><code>public static BigInteger decode(String value) {
    byte[] decoded = android.util.Base64.decode(value, android.util.Base64.URL_SAFE);
    BigInteger bigInteger = new BigInteger(Hex.toHexString(decoded), 16);
    return bigInteger;
}
</code></pre>

<p>Now here is the output from that.</p>

<pre><code>    D/ECDSA:: GenerateExistingKeyPair: PrivateKey D: m-lI_bV8YoNgAgNGpccXPdNtRJ4I6k0hdMdKD7NDYlI
          GenerateExistingKeyPair: PublicKey X: BadCycqeFycXoL4ONkATL7vu1ZxlF66JmrSgbE2A4eY
          GenerateExistingKeyPair: PublicKey Y: obTA6W6xluIdXcqRjnvq0Nh-_IfiWKV4FWziJFxXHUo
D/ECDSA:: GenerateExistingKeyPair: KeyPair: EC Private Key [ed:66:72:8b:8c:1d:97:b9:82:0b:11:c8:1f:6e:db:aa:0e:bd:67:43]
                      X: 5a742c9ca9e172717a0be0e3640132fbbeed59c6517ae899ab4a06c4d80e1e6
                      Y: a1b4c0e96eb196e21d5dca918e7bead0d87efc87e258a578156ce2245c571d4a
</code></pre>

<p>As far as I can tell, the X and Y are correct, converting them back using Base64 gives me the exact same value as those I received. Now I get to the part to Hash a message and send the transaction thruough JSON using WebRTC.</p>

<pre><code>public static byte[] signTransaction(Wallet wallet, byte[] msgHash) throws Exception {

    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
    Signature ecdsaSign = Signature.getInstance(""SHA256withECDSA"", BouncyCastleProvider.PROVIDER_NAME);
    ecdsaSign.initSign(wallet.getKeyPair().getPrivate());
    ecdsaSign.update(msgHash);
    byte[] signature = ecdsaSign.sign();
    Log.d(TAG, ""signTransaction: "" + new BigInteger(1, signature).toString(16));

    return signature;

}
</code></pre>

<p>This is the signature I receive:</p>

<pre><code>3045022026728f6d621689955126e52ca04e5ad7d3f5633111c32ca79979022fc48f7155022100ed94989a8f9fb6bb804ee041cb2923b6ecc17876fbc55c559c93ab9becac415f
</code></pre>

<p>After a bit of research I found out that ECDSA signatures in Java are ANS1 DER encoded and signatures in javascript uses P1363 format which are just the R and S of the signature.</p>

<p>So after some research I found out how to extract those values from the signature.</p>

<pre><code>public static BigInteger extractR(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startR + 2, startR + 2 + lengthR));
}

public static BigInteger extractS(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    int startS = startR + 2 + lengthR;
    int lengthS = signature[startS + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startS + 2, startS + 2 + lengthS));
}
</code></pre>

<p>Which gave me the following values:</p>

<pre><code>26728f6d621689955126e52ca04e5ad7d3f5633111c32ca79979022fc48f7155
ed94989a8f9fb6bb804ee041cb2923b6ecc17876fbc55c559c93ab9becac415f
</code></pre>

<p>In a last attempt I tried to put those two strings togheter and send them to the Javascript side, but it couldnt validate, these two values side by side are the same size in characters as the signatures generated in Javascript, but the method </p>

<pre><code>await window.crypto.subtle.verify({name: ""ECDSA"", hash: {name: ""SHA-256""},}, publicKey, signature, data)
</code></pre>

<p>In javascript still returns false.</p>

<p>My question is, how can I make the signatures compatible between Java and Javascript? Can I convert it from ASN1 DER to P1363 within Javascript? Or can I convert the other way around in Java?</p>

<p>Any help would be appreciated...</p>
","<p>You're performing the hashing twice, as you perform:</p>

<pre><code>ecdsaSign.update(msgHash);
</code></pre>

<p>while the <code>ecdsaSign</code> object already performs the SHA-256 hashing.</p>
","204","<java><encryption><bouncycastle><ecdsa>","0","0","2","2018-08-24 16:45:06","52008698","2","","","","","2018-08-22 15:19:40",""
"51970086","Android Java Spongycastle ECDSA Signature to subtle.crypto Javascript","<p>I'm importing a set of values from my website which is writen in Javascript using subtle.crypto for signing messages. In the QR Code I put the X, Y and D values of the key from Javascript, this is my code to replicate the key:</p>

<pre><code>public static KeyPair GenerateExistingKeyPair(String d, String x, String y) throws NoSuchProviderException, NoSuchAlgorithmException, InvalidKeySpecException {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
    Log.d(TAG, ""GenerateExistingKeyPair: PrivateKey D: "" + d);
    Log.d(TAG, ""GenerateExistingKeyPair: PublicKey X: "" + x);
    Log.d(TAG, ""GenerateExistingKeyPair: PublicKey Y: "" + y);

    BigInteger privateD = decode(d);
    BigInteger publicX = decode(x);
    BigInteger publicY = decode(y);

    KeyFactory keyFactory = KeyFactory.getInstance(""ECDSA"", BouncyCastleProvider.PROVIDER_NAME);;
    ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""P-256"");
    ECPoint Q = ecSpec.getG().multiply(privateD);

    ECPrivateKeySpec privSpec = new ECPrivateKeySpec(privateD, ecSpec);
    ECPublicKeySpec pubSpec = new ECPublicKeySpec(Q, ecSpec);

    PrivateKey privKey = keyFactory.generatePrivate(privSpec);
    PublicKey pubKey = keyFactory.generatePublic(pubSpec);

    KeyPair keyPair = new KeyPair(pubKey, privKey);
    Log.d(TAG, ""GenerateExistingKeyPair: KeyPair: "" + keyPair.getPrivate().toString());
    Log.d(TAG, ""GenerateExistingKeyPair: "" + Hex.toHexString(privKey.getEncoded()));
    return keyPair;

}
</code></pre>

<p>The ""decode"" I use because those values are stored in Base64 within Javascript.</p>

<pre><code>public static BigInteger decode(String value) {
    byte[] decoded = android.util.Base64.decode(value, android.util.Base64.URL_SAFE);
    BigInteger bigInteger = new BigInteger(Hex.toHexString(decoded), 16);
    return bigInteger;
}
</code></pre>

<p>Now here is the output from that.</p>

<pre><code>    D/ECDSA:: GenerateExistingKeyPair: PrivateKey D: m-lI_bV8YoNgAgNGpccXPdNtRJ4I6k0hdMdKD7NDYlI
          GenerateExistingKeyPair: PublicKey X: BadCycqeFycXoL4ONkATL7vu1ZxlF66JmrSgbE2A4eY
          GenerateExistingKeyPair: PublicKey Y: obTA6W6xluIdXcqRjnvq0Nh-_IfiWKV4FWziJFxXHUo
D/ECDSA:: GenerateExistingKeyPair: KeyPair: EC Private Key [ed:66:72:8b:8c:1d:97:b9:82:0b:11:c8:1f:6e:db:aa:0e:bd:67:43]
                      X: 5a742c9ca9e172717a0be0e3640132fbbeed59c6517ae899ab4a06c4d80e1e6
                      Y: a1b4c0e96eb196e21d5dca918e7bead0d87efc87e258a578156ce2245c571d4a
</code></pre>

<p>As far as I can tell, the X and Y are correct, converting them back using Base64 gives me the exact same value as those I received. Now I get to the part to Hash a message and send the transaction thruough JSON using WebRTC.</p>

<pre><code>public static byte[] signTransaction(Wallet wallet, byte[] msgHash) throws Exception {

    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
    Signature ecdsaSign = Signature.getInstance(""SHA256withECDSA"", BouncyCastleProvider.PROVIDER_NAME);
    ecdsaSign.initSign(wallet.getKeyPair().getPrivate());
    ecdsaSign.update(msgHash);
    byte[] signature = ecdsaSign.sign();
    Log.d(TAG, ""signTransaction: "" + new BigInteger(1, signature).toString(16));

    return signature;

}
</code></pre>

<p>This is the signature I receive:</p>

<pre><code>3045022026728f6d621689955126e52ca04e5ad7d3f5633111c32ca79979022fc48f7155022100ed94989a8f9fb6bb804ee041cb2923b6ecc17876fbc55c559c93ab9becac415f
</code></pre>

<p>After a bit of research I found out that ECDSA signatures in Java are ANS1 DER encoded and signatures in javascript uses P1363 format which are just the R and S of the signature.</p>

<p>So after some research I found out how to extract those values from the signature.</p>

<pre><code>public static BigInteger extractR(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startR + 2, startR + 2 + lengthR));
}

public static BigInteger extractS(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    int startS = startR + 2 + lengthR;
    int lengthS = signature[startS + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startS + 2, startS + 2 + lengthS));
}
</code></pre>

<p>Which gave me the following values:</p>

<pre><code>26728f6d621689955126e52ca04e5ad7d3f5633111c32ca79979022fc48f7155
ed94989a8f9fb6bb804ee041cb2923b6ecc17876fbc55c559c93ab9becac415f
</code></pre>

<p>In a last attempt I tried to put those two strings togheter and send them to the Javascript side, but it couldnt validate, these two values side by side are the same size in characters as the signatures generated in Javascript, but the method </p>

<pre><code>await window.crypto.subtle.verify({name: ""ECDSA"", hash: {name: ""SHA-256""},}, publicKey, signature, data)
</code></pre>

<p>In javascript still returns false.</p>

<p>My question is, how can I make the signatures compatible between Java and Javascript? Can I convert it from ASN1 DER to P1363 within Javascript? Or can I convert the other way around in Java?</p>

<p>Any help would be appreciated...</p>
","<p>Answering my own question just to close it, I found the reason why I was not being authenticated by the JS side. All my methods to create and replicate the Public/Private keys are working. My code for transforming ASN1 DER signature to R||S value are working aswell.</p>

<p>I was signing transactions on top of the Hash String, like I tought the browser did. It turns out the browser were not signing the raw hash string, but he did this with the hash string before signing:</p>

<pre><code>async sign(msg) {
    const encoder = new TextEncoder('utf-8');
    const msgBuffer = encoder.encode(msg.toString());
    const signedBuffer = await ECDSA.sign(this.keys.privateKey, msgBuffer);
    const signedArray = Array.from(new Uint8Array(signedBuffer));
    return Encryption.byteToHexString(signedArray);
}
</code></pre>

<p>note the lines:</p>

<p>As it turns out, the browser was encoding the hash string to UTF-8 and signing that byte array of size 64 and not the string which would have 20 or so bytes. So before when the browser tried to verify my signature, it actually did the same thing with my hash string, converted to UTF-8 and thats why my signature was failing, because I was not signing the same message as the browser was trying to verify.</p>

<p>If I did this dive into the JS cove more carefully it could have saved me like 2 days.</p>

<p>Thanks Maarten Bodewes for trying to help me, you actually pointed out a few flaws in my code and sorry for my lack of JS-side code that I presented to you, you could probably spot this issue and helped me 2 days ago.</p>
","204","<java><encryption><bouncycastle><ecdsa>","0","0","2","2018-08-24 16:45:06","52008698","2","","","","","2018-08-22 15:19:40",""
"30249086","elliptic curve discrete logarithm","<p>I am trying to Solve elliptic curve discrete logarithm using  Pollard rho (find <strong>k</strong> where <strong>G=kp</strong>), So i searched for implementation in c and i found one after adding problem specific data in the <code>main</code> function i got  <code>segmentation fault (core dumped)</code></p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;gmp.h&gt;
#include &lt;limits.h&gt;
#include &lt;sys/time.h&gt;

#include &lt;openssl/ec.h&gt;
#include &lt;openssl/bn.h&gt;
#include &lt;openssl/obj_mac.h&gt; // for NID_secp256k1

#define POLLARD_SET_COUNT 16

#if defined(WIN32) || defined(_WIN32)
#define EXPORT __declspec(dllexport)
#else
#define EXPORT
#endif

#define MAX_RESTART 100

int ec_point_partition(const EC_GROUP *ecgrp, const EC_POINT *x) {  

    size_t len = EC_POINT_point2oct( ecgrp, x, POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL );
    unsigned char ret[len]; 
    EC_POINT_point2oct( ecgrp, x, POINT_CONVERSION_UNCOMPRESSED, ret, len, NULL );

    int id = ( ret[len - 1] &amp; 0xFF ) % POLLARD_SET_COUNT;

    return id;
}

// P generator 
// Q result*P
// order of the curve
// result
//Reference: J. Sattler and C. P. Schnorr, ""Generating random walks in groups""

int elliptic_pollard_rho_dlog(const EC_GROUP *group, const EC_POINT *P, const EC_POINT *Q, const BIGNUM *order, BIGNUM *res) {

    printf(""Pollard rho discrete log algorithm... \n"");

    BN_CTX* ctx;
    ctx = BN_CTX_new();

    int i, j;
    int iterations = 0;

    if ( !EC_POINT_is_on_curve(group, P, ctx ) || !EC_POINT_is_on_curve(group, Q, ctx ) ) return 1;

    EC_POINT *X1 = EC_POINT_new(group);
    EC_POINT *X2 = EC_POINT_new(group);

    BIGNUM *c1 = BN_new();
    BIGNUM *d1 = BN_new();
    BIGNUM *c2 = BN_new();
    BIGNUM *d2 = BN_new();

    BIGNUM* a[POLLARD_SET_COUNT];
    BIGNUM* b[POLLARD_SET_COUNT];
    EC_POINT* R[POLLARD_SET_COUNT];

    BN_zero(c1); BN_zero(d1);
    BN_zero(c2); BN_zero(d2);


    for (i = 0; i &lt; POLLARD_SET_COUNT; i++) {   

        a[i] = BN_new();
        b[i] = BN_new();
        R[i] = EC_POINT_new(group);

        BN_rand_range(a[i], order);     
        BN_rand_range(b[i], order);

        // R = aP + bQ

        EC_POINT_mul(group, R[i], a[i], Q, b[i], ctx);
        //ep_norm(R[i], R[i]);
    }

    BN_rand_range(c1, order);       
    BN_rand_range(d1, order);       


    // X1 = c1*P + d1*Q
    EC_POINT_mul(group, X1, c1, Q, d1,  ctx);  
    //ep_norm(X1, X1);

    BN_copy(c2, c1);
    BN_copy(d2, d1);
    EC_POINT_copy(X2, X1);


    double work_time = (double) clock();
    do {
        j = ec_point_partition(group, X1);
        EC_POINT_add(group, X1, X1, R[j], ctx);

        BN_mod_add(c1, c1, a[j], order, ctx); 

        BN_mod_add(d1, d1, b[j], order, ctx); 

        for (i = 0; i &lt; 2; i++) {
            j = ec_point_partition(group, X2);

            EC_POINT_add(group, X2, X2, R[j], ctx);

            BN_mod_add(c2, c2, a[j], order, ctx); 

            BN_mod_add(d2, d2, b[j], order, ctx);
        }

        iterations++;
        printf(""Iteration %d \r"",iterations );
    } while ( EC_POINT_cmp(group, X1, X2, ctx) != 0 ) ;


    printf(""\n "");

    work_time = ( (double) clock() - work_time ) / (double)CLOCKS_PER_SEC;

    printf(""Number of iterations %d %f\n"",iterations, work_time );

    BN_mod_sub(c1, c1, c2, order, ctx);
    BN_mod_sub(d2, d2, d1, order, ctx);

    if (BN_is_zero(d2) == 1) return 1;


    //d1 = d2^-1 mod order  
    BN_mod_inverse(d1, d2, order, ctx);

    BN_mod_mul(res, c1, d1, order, ctx);

    for (int k = 0; k &lt; POLLARD_SET_COUNT; ++k) {
        BN_free(a[k]); 
        BN_free(b[k]);
        EC_POINT_free(R[k]);
    }
    BN_free(c1); BN_free(d1);
    BN_free(c2); BN_free(d2);
    EC_POINT_free(X1); EC_POINT_free(X2);

    BN_CTX_free(ctx);
    return 0;
}


int main(int argc, char *argv[])
{
    unsigned char *p_str=""134747661567386867366256408824228742802669457"";
    unsigned char *a_str=""-1"";
    unsigned char *b_str=""0"";
    BIGNUM *p = BN_bin2bn(p_str, sizeof(p_str), NULL);
    BIGNUM *a = BN_bin2bn(a_str, sizeof(a_str), NULL);
    BIGNUM *b = BN_bin2bn(b_str, sizeof(b_str), NULL);
    BN_CTX* ctx;
    ctx = BN_CTX_new();
    EC_GROUP* g = EC_GROUP_new(EC_GFp_simple_method());
    EC_GROUP_set_curve_GFp(g,p,a,b,ctx);    
    unsigned char *XP_str=""18185174461194872234733581786593019886770620"";
    unsigned char *YP_str=""74952280828346465277451545812645059041440154"";

    BN_CTX* ctx1;
    ctx1 = BN_CTX_new();
    BIGNUM *XP = BN_bin2bn(XP_str, sizeof(XP_str), NULL);
    BIGNUM *YP = BN_bin2bn(YP_str, sizeof(YP_str), NULL);
    EC_POINT* P = EC_POINT_new(g);
    EC_POINT_set_affine_coordinates_GFp(g,P,XP,YP,ctx1);

    unsigned char *XQ_str=""76468233972358960368422190121977870066985660"";
    unsigned char *YQ_str=""33884872380845276447083435959215308764231090"";
    BIGNUM* XQ = BN_bin2bn(XQ_str, sizeof(XQ_str), NULL);
    BIGNUM* YQ = BN_bin2bn(YQ_str, sizeof(YQ_str), NULL);
    EC_POINT *Q = EC_POINT_new(g);
    BN_CTX* ctx2;
    ctx2 = BN_CTX_new();
    EC_POINT_set_affine_coordinates_GFp(g,Q,XQ,YQ,ctx2);
    char * str;


    unsigned char *N_str=""2902021510595963727029"";
    BIGNUM *N = BN_bin2bn(N_str, sizeof(N_str), NULL);
    BIGNUM *res;
    elliptic_pollard_rho_dlog (g,P,Q,N,res);
    BN_bn2mpi(res,str); 
    printf(""%s\n"", str);


  return 0;
}
</code></pre>

<p>This is the statement that cause <code>segmentation fault</code></p>

<pre><code>    BN_bn2mpi(res,str); 
</code></pre>
","","202","<c><segmentation-fault><elliptic-curve><ecdsa>","1","","0","2015-05-14 23:24:04","","1","","","","","2015-05-14 23:24:04",""
"34309528","KeyPair size is wrong for ECDSA using BouncyCastle's API","<p>Am using BouncyCastle API to generate a signing Keypair which normally should be 32 bytes for privateKey size and 64 bytes for publicKey  size, but actually am getting 150 bytes privateKey size and 91 bytes for publicKey size ,the source code is like bellow : </p>

<pre><code>KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""ECDSA"", ""BC""); 
org.bouncycastle.jce.spec.ECParameterSpec ecSpec=ECNamedCurveTable.getParameterSpec(""secp256r1""); keyPairGenerator.initialize(ecSpec, new SecureRandom());
KeyPair keyPair = keyPairGenerator.generateKeyPair();
</code></pre>

<p>And even if I specify the domain params ( the recommended ones for NIST P-256 Curve ) the given result is also wrong, am I missing something ?</p>
","","200","<bouncycastle><ecdsa>","2","","0","2015-12-16 10:27:27","","3","0","","","","2015-12-16 10:27:27",""
"55369670","ECDSA signature generation and verification implementation using Javascript","<p>I have some code below that will be used to verify the authenticity of a message using javascript. The key pair generation using the elliptic curve secp256k1 is pretty straight forward however I am failing to understand why my signature implementation is not working (why the message is not being successfully verified). Here is my code:</p>

<p><a href=""https://pastebin.com/k1WT6apV"" rel=""nofollow noreferrer"">https://pastebin.com/k1WT6apV</a></p>

<pre><code>/**
* Signature Generation
*/
var g = bigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240');
var n = bigInt('115792089237316195423570985008687907852837564279074904382605163141518161494337');
var p = bigInt('115792089237316195423570985008687907853269984665640564039457584007908834671663');      
var k = bigInt.randBetween(""1"", n.subtract(1));
var r = bigInt(""0"");
var s = bigInt(""0"");
var privateKey = bigInt('5943918703142138746985297990399309008462887494775678462183405629775262082646');
var publicKey = bigInt(privateKey.multiply(g)).mod(p); 


while(s.equals(""0"")){
    while(r.equals(""0"")){
        k = bigInt.randBetween(""1"", n.subtract(1));
        while(bigInt(k).isPrime() == false){
            k = bigInt.randBetween(""1"", n.subtract(1));
        }
        var xCoord = bigInt(k.multiply(g)).mod(p);
        r = xCoord.mod(n);
    }
    var kInverse = k.modInv(n);
    var hashedMessage = bigInt(sha1('hello'),16); 
    s = bigInt(kInverse*(hashedMessage.add(privateKey.multiply(r)))).mod(n)        
}
var signatureParams = {
    ""publicKey"": publicKey.toString(),
    ""r"": r.toString(),
    ""sign"": s.toString()
}

/**
* Signature Verification
*/
var sInverse = bigInt(signatureParams.sign).modInv(n);
var publicKey = bigInt(signatureParams.publicKey);
var w = sInverse.mod(n);
var hashedMessage = bigInt(sha1('hello'),16);
var u1 = bigInt(hashedMessage.multiply(w)).mod(n);
var u2 = bigInt(bigInt(r).multiply(w)).mod(n);
var P = bigInt(u1.multiply(g)).add(u2.multiply(publicKey));
P == r
</code></pre>

<p>It can be tested easily using the browser console.
I have used an amalgamation of information from the following guides:</p>

<p><a href=""https://www.maximintegrated.com/en/app-notes/index.mvp/id/5767"" rel=""nofollow noreferrer"">https://www.maximintegrated.com/en/app-notes/index.mvp/id/5767</a></p>

<p><a href=""http://www.cs.miami.edu/home/burt/learning/Csc609.142/ecdsa-cert.pdf"" rel=""nofollow noreferrer"">http://www.cs.miami.edu/home/burt/learning/Csc609.142/ecdsa-cert.pdf</a></p>

<p><a href=""https://pdfs.semanticscholar.org/c06a/d6512775be1076e4abd43e3f2928729da776.pdf"" rel=""nofollow noreferrer"">https://pdfs.semanticscholar.org/c06a/d6512775be1076e4abd43e3f2928729da776.pdf</a></p>

<p>What is wrong with my implementation? Am I missing something? Did I do something wrong?</p>

<p>EDIT:</p>

<p>After doing some revision I came up with the following:</p>

<pre><code>var g = bigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240');
var n = bigInt('115792089237316195423570985008687907852837564279074904382605163141518161494337');
var p = bigInt('115792089237316195423570985008687907853269984665640564039457584007908834671663'); 
var privateKey = bigInt('90436540941140970165633788406609967146985661161263948799654498545867952662296');
var publicKey = bigInt(privateKey.multiply(g)).mod(p);

var generateSignature = function(hashedMessage){
    hashedMessage = bigInt(hashedMessage,16);
    var k = bigInt.randBetween(""1"", n.subtract(1));
    var r = bigInt(""0"");
    var s = bigInt(""0"");
    while(s.equals(""0"")){
        r = bigInt(""0"");
        while(r.equals(""0"")){
            k = bigInt.randBetween(""1"", n.subtract(1));
            r = bigInt(bigInt(k.multiply(g)).mod(p)).mod(n);
        }
        var kInverse = k.modInv(n); 
        var pr = privateKey.multiply(r);
        hashedMessage = hashedMessage.add(pr);
        kInverse = kInverse.multiply(hashedMessage);
        s = kInverse.mod(n);
    }  
    return [r.toString(),s.toString()];
}

var validateSignature = function(hashedMessage, signature){
    hashedMessage = bigInt(hashedMessage,16);
    var r = bigInt(signature[0]);
    var s = bigInt(signature[1]);
    var w = s.modInv(n);
    var u1 = bigInt(hashedMessage.multiply(w)).mod(n);
    var u2 = bigInt(r.multiply(w)).mod(n);
    var u1g = u1.multiply(g);
    var u2pu = u2.multiply(publicKey);
    var xCoord =u1g.add(u2pu);
    var v = xCoord.mod(n);   
    if(v.equals(r))
        return true;
    return false;
}
</code></pre>

<p>However it still fails to validate the signature. Hope it makes it a bit clearer.</p>
","<p>part of your problem is that g is actually not a number but a point</p>

<p>this is a rough translation of what you wrote:</p>

<pre><code>g = 55066263022277343669578718895168534326250603453777594175500187360389116729240
privateKey = 90436540941140970165633788406609967146985661161263948799654498545867952662296
k = &lt;random number&gt;
r = k*g%p%n
e = sha(m)

ki = k^-1%n
pr = privateKey*r
ki*e
s = ki%n
</code></pre>

<p>i wrote an implmentation of this however over the last few weeks something like this:</p>

<pre><code>g = {
    x: 55066263022277343669578718895168534326250603453777594175500187360389116729240,
    y: 32670510020758816978083085130507043184471273380659243275938904335757337482424
}
k = &lt;random number&gt;
r = &lt;random number&gt;
e = sha(m)

privateKey = 90436540941140970165633788406609967146985661161263948799654498545867952662296
r = g * k
s = ((privateKey * r.x + e) * (k^-1%n)) % n
r = r.x
</code></pre>

<p>it might help you to understand how the point multiplication works check out these links:
<a href=""https://github.com/Azero123/simple-js-ec-math"" rel=""nofollow noreferrer"">https://github.com/Azero123/simple-js-ec-math</a></p>

<p><a href=""https://www.npmjs.com/package/simple-js-ec-math"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/simple-js-ec-math</a></p>

<p><a href=""https://eng.paxos.com/blockchain-101-foundational-math"" rel=""nofollow noreferrer"">https://eng.paxos.com/blockchain-101-foundational-math</a></p>

<p>also perhaps take a look at my simple-js-ecdsa implementation as well</p>

<p>just another note, you likely should not use sha1 as it is consider ""officially insecure"" and there are formulas for collisions using it. perhaps try sha2 or sha3</p>
","188","<javascript><digital-signature><verification><elliptic-curve><ecdsa>","2","0","1","2019-03-29 19:44:09","","2","1","4500996","","2019-03-27 20:40:40","2019-03-27 04:08:51",""
"54945941","Exporting EC_POINT using point2hex in ASN1.DER and recreate with Java as an X.509","<p>I am generating ECDSA Prime256 keypair using OpenSSL with C++ and trying to import the hex version of the public key using Java. I pass the byte array I obtain from C++ to the following function in java which expects the byte array to be in an X.509 encoded format.</p>

<pre><code>public static PublicKey getPublicKey(byte[] pk) throws NoSuchAlgorithmException, InvalidKeySpecException {
    EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(pk);
    KeyFactory kf = KeyFactory.getInstance(Constant.KEY_FACTORY_TYPE);
    PublicKey pub = kf.generatePublic(publicKeySpec);
    return pub;
}
</code></pre>

<p>I create an elliptic curve key pair using the following function which retuns an <code>EC_KEY*</code></p>

<pre><code>EC_KEY* generate_keypair() {
    EC_KEY *eckey = EC_KEY_new();
    EC_GROUP *ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
    EC_KEY_set_group(eckey, ecgroup);
    EC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);
    int kpGenerationStatus = EC_KEY_generate_key(eckey);
    if (kpGenerationStatus) {
        return eckey;
    }
    return nullptr;
}
</code></pre>

<p>Given the keypair returned by the function above, I want to export the public key to an ASN1.DER format which can be imported using the java method above.</p>

<p>I convert the public key which is of type <code>EC_POINT*</code> to its hex form using <code>EC_POINT_point2hex()</code> by doing the following:</p>

<pre><code>EC_GROUP *ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
EC_KEY *keypair = generate_keypair();
char *result = NULL;
BN_CTX *ctx;
ctx = BN_CTX_new();
const EC_POINT *pub = EC_KEY_get0_public_key(keypair);
result = EC_POINT_point2hex(ecgroup, pub, POINT_CONVERSION_UNCOMPRESSED, ctx);
printf(""%s\n"", result);
</code></pre>

<p>Which return the following:
<code>04F588CD1D7103A993D47E53D58C3F40BE8F570604CF2EA01A7657C1423EB19C51BC379F0BEE1FAA60BB9A07DE73EA9BEF7709C1C6429D4051B44F73A458FFB80D</code></p>

<p>When I inspect this with the <a href=""https://lapo.it/asn1js/"" rel=""nofollow noreferrer"">ASN.1 decoder</a> I see a message which says <code>Length over 48 bits not supported at position 1</code> and trying to import it using the java method I receive an error as follows:</p>

<pre><code>java.security.spec.InvalidKeySpecException: java.security.InvalidKeyException: IOException: DerInputStream.getLength(): Should use short form for length
</code></pre>

<p>Is there something I am missing while exporting the public key from EC_POINT* to a X.509 Encoded hex string that I can import for validating any signatures?</p>
","<p>You are going in the incorrect direction as you want ASN1 base64 value.  </p>

<p><a href=""https://www.openssl.org/docs/man1.1.1/man3/EC_POINT_point2hex.html"" rel=""nofollow noreferrer"">EC_POINT_point2hex</a> is converting the internal public key value to hex.  It's not in ASN1 format.</p>

<p>You can produce what you want from the command line like so:</p>

<ol>
<li>Generate EC private key:
openssl ecparam -name prime256v1 -genkey -noout -out key.pem</li>
<li>Extra public key in DER(ASN1) format:
openssl ec -in key.pem -pubout -outform der -out public.cer</li>
<li>Convert to base64
openssl base64 -in .\public.cer</li>
</ol>

<p>If you take that output and paste it into ASN.1 decoder link it works fine.</p>

<p>Now to turn this into code, you have the EC key generation, but what you want is the steps to:</p>

<ol>
<li>Generate ASN1 formatted public key</li>
<li>Convert it to base64</li>
</ol>

<p>To generate the ASN1 formatted public key you want to use the <a href=""https://www.openssl.org/docs/man1.1.1/man3/i2d_EC_PUBKEY.html"" rel=""nofollow noreferrer"">i2d_EC_PUBKEY</a> set of methods and then convert to base64 using <a href=""https://www.openssl.org/docs/man1.0.2/man3/BIO_f_base64.html"" rel=""nofollow noreferrer"">BIO_f_base64</a> filter.</p>

<p>So here is an example problem that when I copy the output to ASN.1 decoder link it works fine.</p>

<pre><code>#include &lt;openssl/bio.h&gt;
#include &lt;openssl/ec.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/x509.h&gt;

EC_KEY* generate_keypair() {
    EC_KEY *eckey = EC_KEY_new();
    EC_GROUP *ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
    EC_KEY_set_group(eckey, ecgroup);
    EC_KEY_set_asn1_flag(eckey, OPENSSL_EC_NAMED_CURVE);
    int kpGenerationStatus = EC_KEY_generate_key(eckey);
    if (kpGenerationStatus) {
        return eckey;
    }
    return nullptr;
}

int main()
{
    EC_GROUP *ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
    EC_KEY *keypair = generate_keypair();
    BIO* out = BIO_new(BIO_s_mem());
    BIO* b64 = BIO_new(BIO_f_base64());
    BIO_push(b64, out);

    i2d_EC_PUBKEY_bio(b64, keypair);

    BIO_flush(b64);


    // do what you want this the output in out memory BIO

    char* p;
    long length = BIO_get_mem_data(out, &amp;p);

    // ensure null terminated but copying the buffer into a string to output...
    puts(std::string(p, length).c_str());

    BIO_free_all(out);
}
</code></pre>

<p>I can't complete on the Java side, but if it works with the manual openssl generated base64 string then it will work with the sample application.</p>
","184","<c++><openssl><x509><ecdsa><asn1>","2","0","1","2019-03-08 01:07:03","","0","","7255359","","2019-03-01 16:48:44","2019-03-01 13:46:16",""
"20268653","How to handle short hash with longer order of base point in ECDSA","<p>I am using CVC certificates (If you haven't heard about them, pretend they are X509) with Elliptic curve signature with brainpool256r1 curve and SHA1 hash. In java with bouncycastle, I simply verify them like this:</p>

<pre><code>Signature sign = Signature.getInstance(""SHA1withECDSA"", ""BC"");
sign.initVerify(key);
sign.update(certificate_data_to_be_verified);
sign.verify(signature);
</code></pre>

<p>And everything works fine. However, I need to verify them also in an embedded device, and I have encountered a problem, because I am supposed to use leftmost 256bits of hash to get the value of <code>z</code>  at least according to <a href=""https://en.wikipedia.org/wiki/Elliptic_Curve_DSA"" rel=""nofollow"">wikipedia ECDSA article</a>. But SHA1 has only 160bits.</p>

<p>How is this solved by bouncycastle, and is there some general theory on how to handle this?</p>
","<p>You are confusing an order of base point with a key length.</p>

<p>Here is how <a href=""https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/crypto/signers/ECDSASigner.java#L139"" rel=""nofollow"">Bouncy Castle code</a> performs ECDSA digital signature verification.</p>

<pre><code>private BigInteger calculateE(BigInteger n, byte[] message)
{
    /* n is curve order value */
    int log2n = n.bitLength();
    /* and message is a hash */
    int messageBitLength = message.length * 8;

    BigInteger e = new BigInteger(1, message);
    /* If message is longer than curve order */
    if (log2n &lt; messageBitLength)
    {
        /* only log2n bits are taken from the left */
        e = e.shiftRight(messageBitLength - log2n);
    }
    return e;
}
</code></pre>
","183","<java><security><bouncycastle><elliptic-curve><ecdsa>","1","2","1","2014-01-29 17:44:25","20273488","0","","642653","","2014-01-29 17:44:25","2013-11-28 14:29:42",""
"50592110","Converting a hex String to x509 encoding","<p>I'm working with some Android Java code that uses ECDSA keys. The code compiles and runs fine, but has some logic errors during the verification process. I want to try using a constant key pair (that's known to be valid) to troubleshoot the program.</p>

<p>Using an <a href=""https://kjur.github.io/jsrsasign/sample/sample-ecdsa.html"" rel=""nofollow noreferrer"">online generator</a>, I got an EC public key in hex,</p>

<blockquote>
  <p>0x044fb7cebbb1f4a1e0412c8e0b6f2d675ebfee000c5e860a81ffd795b5743033dec0e114abfba3de8db8705fc8ed985c5550c66a6ee9fdd258d058a2ef749eba78</p>
</blockquote>

<p>As well as a valid private key to complete the pair,</p>

<blockquote>
  <p>0x0c84e7e707b31ecf0254e8cb3040513883d92d81e977ad4754a409a6ab18ee51</p>
</blockquote>

<p>I can convert the hex string to a primitive byte array, but that byte array appears to be invalid. I cannot figure out how to convert a hex representation of my keys to a X509 representation so that I can make a Java key object.</p>

<pre><code>KeyFactory mFactory = KeyFactory.getInstance(""EC"");
X509EncodedKeySpec mPublicKey = new X509EncodedKeySpec(publicKeyBytes);
PublicKey publicKey = mFactory.generatePublic(mPublicKey);
</code></pre>

<p>That code results in:</p>

<pre><code>java.security.spec.InvalidKeySpecException: com.android.org.conscrypt.OpenSSLX509CertificateFactory$ParsingException: Error parsing public key
</code></pre>

<p>I am reasonably sure that my conversion from hex string to byte array is working, but I'll include that method as well for a sanity check.</p>

<pre><code>private static byte[] hexStringToByteArray(String s) throws IllegalArgumentException {
    int len = s.length();
    if (len % 2 == 1) {
        throw new IllegalArgumentException(""Hex string must have even number of characters"");
    }
    byte[] data = new byte[len / 2]; // Allocate 1 byte per 2 hex characters
    for (int i = 0; i &lt; len; i += 2) {
        // Convert each character into a integer (base-16), then bit-shift into place
        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                + Character.digit(s.charAt(i+1), 16));
    }
    return data;
}
</code></pre>

<p>The end goal is to have a constant, valid PublicKey/PrivateKey object for testing. Any advice about how to generate those objects would be greatly appreciated. </p>
","","175","<java><android><public-key-encryption><ecdsa>","0","","0","2018-05-29 20:02:40","","2","","","","","2018-05-29 20:02:40",""
"53711729","How to generate an Ethereum public key from a private key using rust-secp256k1?","<p>I found <a href=""https://github.com/paritytech/rust-secp256k1"" rel=""nofollow noreferrer"">rust-secp256k1</a> and it seems to be what I need, but there are no examples in the documentation.</p>

<p>I tried to use this crate in my code:</p>

<pre><code>extern crate secp256k1;

use secp256k1::key::SecretKey;

fn main() {
    let context = secp256k1::Secp256k1::without_caps();

    let private_key: String = String::from(""d500266f7d37f0957564e4ce1a1dcc8bb3408383634774a2f4a94a35f4bc53e0"");

    let secret_key = SecretKey::new(&amp;context, &amp;mut private_key);

    println!(""{:?}"", secret_key);
}
</code></pre>

<p>I got an error:</p>

<pre class=""lang-none prettyprint-override""><code>error[E0277]: the trait bound `std::string::String: secp256k1::rand::Rng` is not satisfied
  --&gt; src/main.rs:10:22
   |
10 |     let secret_key = SecretKey::new(&amp;context, &amp;mut private_key);
   |                      ^^^^^^^^^^^^^^ the trait `secp256k1::rand::Rng` is not implemented for `std::string::String`
   |
   = note: required by `secp256k1::key::SecretKey::new`
</code></pre>
","<p>The following code generates a public key from a private key:</p>

<pre><code>extern crate secp256k1;
extern crate hex;

use secp256k1::key::{SecretKey, PublicKey};

fn main() {
    let context = secp256k1::Secp256k1::new();

    let private_key: &amp;[u8] = ""d500266f7d37f0957564e4ce1a1dcc8bb3408383634774a2f4a94a35f4bc53e0"".as_bytes();

    let secret_key = SecretKey::from_slice(&amp;hex::decode(private_key).unwrap());

    let public_key = PublicKey::from_secret_key(&amp;context, &amp;secret_key.unwrap());

    println!(""{:?}"", public_key.unwrap()); // PublicKey(a423c05d32e3385bb2930e42ebbf104567215761e166c3ae3dd91d9c8bee0adcfc4f9e4ec43998eae8000de6b166014c5921c6d4545675f4f9205e7bc3d4401e)
}
</code></pre>

<p>Instead of using <code>SecretKey::new</code>, which expects a random number generator as the second parameter, I needed to use <a href=""https://github.com/rust-bitcoin/rust-secp256k1/blob/0fbc0f99ab4f9e94f83629e3bc2a0e04a3ee5086/src/key.rs#L119"" rel=""nofollow noreferrer""><code>SecretKey::from_slice</code></a>. <code>from_slice</code> takes a 32-byte key, which I can <a href=""https://stackoverflow.com/q/52987181/155423"">parse from my string</a> into a compatible slice of bytes.</p>
","173","<rust><ecdsa>","0","1","1","2019-06-20 19:36:38","53713063","1","","155423","","2018-12-10 20:27:32","2018-12-10 18:40:01",""
"50971023","ECDSA key size difference between OpenSSL and BouncyCastle","<p>I am implementing a 192 bit ECDSA signature in C# using BouncyCastle.  It was specified in text by my customer.  They sent me a spec in OpenSSL after I started implementing in BouncyCastle.  Now I'm having trouble moving keys between OpenSSL and BouncyCastle.  I think I must be missing the point of something, and am asking your help to understand how ECDSA 192 works across the two libraries.</p>

<p>The first line of the spec is:</p>

<blockquote>
  <p>openssl ecparam -name secp192r1 -genkey -noout -out priv.pem</p>
</blockquote>

<p>The resulting priv.pem contains a Base64 string that decodes to 97 bytes.  When I feed that key to BouncyCastle using a 192 bit curve, I get exceptions.</p>

<pre><code>ECDomainParameters spec = GetEcdsaCurveParamsForInit();
// D is the Private Key
BigInteger d = new BigInteger(tbSigKeyHex.Text, 16);
ECPrivateKeyParameters sKey = new ECPrivateKeyParameters(""ECDSA"", d, spec);
ECPublicKeyParameters vKey = GL_ECKeyPairGenerator.GetCorrespondingPublicKey(sKey); // EXCEPT on d &gt; 24byte max value
</code></pre>

<p>The specific exception is System.InvalidOperationException on this line of EcKeyPairGenerator.cs:</p>

<blockquote>
  <p>ECPoint q = new FixedPointCombMultiplier().Multiply(ec.G, privKey.D);</p>
</blockquote>

<p>If I truncate the Ascii-hex input string to 48 bytes, so privKey.D is never more than the max value of 24 bytes, everything runs ok.  But now my code differs from spec.</p>

<p>I also notice that BouncyCastle makes 24 byte keys with 192 bit curves:</p>

<pre><code>AsymmetricCipherKeyPair keyPair = GenerateKeys(192); // bit length selects curve in GL_ECKeyPairGenerator
ECPrivateKeyParameters sKey = (ECPrivateKeyParameters)keyPair.Private;
string szD = sKey.D.ToString(16);
PrintToFeedback(string.Format(""Generated Private D Key {0} bytes: {1}"", szD.Length/2, szD));
ECPublicKeyParameters vKey = (ECPublicKeyParameters)keyPair.Public;
</code></pre>

<p>prints out:</p>

<blockquote>
  <p>Generated Private D Key 24 bytes: 92e67f4a42c3031349f7e88d082a8e1f122eaee8d8b0823d</p>
</blockquote>

<p>When I break and inspect sKey, I don't see anything that looks like a 97 byte number.  I see how 24 bytes maps to 192 bits, but not 97.  Since my customer says OpenSSL is the spec, I have to assume that's correct.  But I'm a little lost.  Before they sent me the OpenSSL spec, I had convinced myself that ECDSA192 uses 24 byte private keys (and 48 byte public keys, more or less), but this 97 byte OpenSSL key throws everything into doubt again.  My expertise is in realtime and RFID, not so much crypto.</p>

<p>Can someone help me understand how to use the OpenSSL 97 byte key with BouncyCastle?  Or should I just rip up BouncyCastle and rewrite with OpenSSL.Net?</p>

<p>I am running in a Cygwin bash window under Win10, openssl version is:</p>

<blockquote>
  <p>OpenSSL 1.0.2o  27 Mar 2018</p>
</blockquote>

<p>Thank you.</p>
","<p>The file <code>priv.pem</code> that results from your <code>openssl ecparam</code> command contains more than just the bytes that make up the private part of the key. In particular, it also includes the public part of the key pair, and some information about what kind of curve the key is on. You can see this when you do</p>

<pre><code>$ openssl ec -in priv.pem -noout -text

read EC key
Private-Key: (192 bit)
priv:
    74:6b:13:17:a5:6e:bb:8e:76:b1:65:a2:c2:59:16:
    72:36:56:ee:42:b9:91:26:53
pub: 
    04:9b:d5:f3:61:6b:06:86:c2:d2:1b:c8:1f:86:ae:
    ee:58:8a:ac:b3:04:2b:93:c5:8c:1b:24:6e:90:2d:
    9c:aa:69:7e:30:15:86:48:06:97:b6:78:35:a6:48:
    46:1a:2c:4e
ASN1 OID: prime192v1
</code></pre>

<p>So to use the private part separately, you will have to extract it first.</p>

<p>To get a lower level understanding about what is exactly stored in <code>priv.pem</code>, you can use the <code>asn1parse</code> application:</p>

<pre><code>$ openssl asn1parse -in priv.pem -dump
    0:d=0  hl=2 l=  95 cons: SEQUENCE          
    2:d=1  hl=2 l=   1 prim: INTEGER           :01
    5:d=1  hl=2 l=  24 prim: OCTET STRING      
      0000 - 74 6b 13 17 a5 6e bb 8e-76 b1 65 a2 c2 59 16 72   tk...n..v.e..Y.r
      0010 - 36 56 ee 42 b9 91 26 53-                          6V.B..&amp;S
   31:d=1  hl=2 l=  10 cons: cont [ 0 ]        
   33:d=2  hl=2 l=   8 prim: OBJECT            :prime192v1
   43:d=1  hl=2 l=  52 cons: cont [ 1 ]        
   45:d=2  hl=2 l=  50 prim: BIT STRING        
      0000 - 00 04 9b d5 f3 61 6b 06-86 c2 d2 1b c8 1f 86 ae   .....ak.........
      0010 - ee 58 8a ac b3 04 2b 93-c5 8c 1b 24 6e 90 2d 9c   .X....+....$n.-.
      0020 - aa 69 7e 30 15 86 48 06-97 b6 78 35 a6 48 46 1a   .i~0..H...x5.HF.
      0030 - 2c 4e                                             ,N
</code></pre>

<p>Or if you are on Windows, try this excellent <a href=""https://www.sysadmins.lv/projects/asn1editor/default.aspx"" rel=""nofollow noreferrer"">ASN.1 Editor</a> tool.</p>
","172","<openssl><bouncycastle><ecdsa>","1","1","1","2018-06-22 15:18:26","50990951","0","","","","","2018-06-21 14:28:34",""
"34706822","Why can't python ECDSA support negative numbers yet?","<p>I am trying to write a python script that verifies an ECDSA signature and I am having a terrible time trying to do it.</p>

<p>This is the code I use:</p>

<pre><code>public_key = ecdsa.VerifyingKey.from_string(pubkey, curve=ecdsa.SECP256k1)
verified = public_key.verify_digest(signature, val, sigdecode=ecdsa.util.sigdecode_der)
</code></pre>

<p>If the signature <strong>r</strong> and <strong>s</strong> are positive, it works well, but if either of them is negative, an assertion error raises. I have checked the ecdsa sourcecode, and I saw this line:</p>

<pre><code>nbytes = numberbytes[0] if isinstance(numberbytes[0], integer_types) else ord(numberbytes[0])
assert nbytes &lt; 0x80 # can't support negative numbers yet
</code></pre>

<p><a href=""https://github.com/warner/python-ecdsa/blob/master/ecdsa/der.py#L105"" rel=""nofollow"">https://github.com/warner/python-ecdsa/blob/master/ecdsa/der.py#L105</a></p>

<p>Why does this happen? Isn't this library something ""oficial""? What alternatives do I have? Is it safe to just remove that assertion line?</p>
","<p>ECDSA itself does not use negative numbers, so I would not expect a Python implementation of it to support negative numbers.  The types of numbers used by ECDSA are between 0 and some large prime number, and they obey the laws of modular arithmetic.</p>
","165","<python><openssl><ecdsa>","0","2","1","2016-01-10 19:34:41","34709900","2","1","","","","2016-01-10 14:56:00",""
"35687711","(Erlang) Got error while parsing ecsda public key pem file","<p>I made private and public keys files as</p>

<pre><code>openssl ecparam -name secp256k1 -genkey -out gen.pem

openssl ec -in gen.pem -pubout -out gen.pub
</code></pre>

<p>then I checked .pub file</p>

<pre><code>openssl pkey -in gen.pub  -pubin -text -noout

Public-Key: (256 bit)
pub: 
    04:fc:de:4f:2a:77:bd:c4:f2:74:2b:ba:b5:fc:85:
    e4:aa:96:a7:8e:86:14:bc:0d:fa:8e:d2:dd:50:3c:
    5d:fa:f4:07:f4:17:80:49:06:19:0c:72:03:63:4e:
    07:37:e9:10:64:c8:33:a4:a3:7e:26:d8:df:79:21:
    d7:2d:a6:01:80
ASN1 OID: secp256k1
</code></pre>

<p>After that start erl</p>

<pre><code>erl
Erlang/OTP 18 [erts-7.2] [source-e6dd627] [64-bit] [smp:3:3] [async-threads:10] [hipe] [kernel-poll:false]
</code></pre>

<p>After execution of commands</p>

<pre><code>1&gt;rr(public_key),
  {ok,RawData} = file:read_file(""gen.pub""),
  Decoded = public_key:pem_decode(RawData),
  [public_key:pem_entry_decode(X) || X &lt;- Decoded ].
</code></pre>

<p>I got exception</p>

<pre><code>** exception error: no match of right hand side value 
                    {error,{asn1,{invalid_length,1}}}
     in function  public_key:der_decode/2 (public_key.erl, line 229)
</code></pre>

<p>I know that there are workarounds, but I'm wondering if I do something wrong or there are errors in public key modules ?</p>

<p><strong>UPD 1.</strong></p>

<p>When we look at result </p>

<pre><code>{ok,#'SubjectPublicKeyInfo'{algorithm = #'AlgorithmIdentifier'{algorithm = {1,2,840,10045,2,1},
                                                           parameters = &lt;&lt;6,5,43,129,4,0,10&gt;&gt;},
                        subjectPublicKey = &lt;&lt;4,241,200,19,168,25,25,81,43,216,
                                             89,201,37,62,66,39,166,231,161,98,
                                             223,133,119,12,...&gt;&gt;}}
</code></pre>

<p>we can see next :</p>

<p>{1,2,840,10045,2,1} is oid of ecPublicKey <a href=""http://oid-info.com/get/1.2.840.10045.2.1"" rel=""nofollow"">http://oid-info.com/get/1.2.840.10045.2.1</a></p>

<p>parameters = &lt;&lt;6,5,43,129,4,0,10>></p>

<pre><code>'OTP-PUB-KEY':decode('EcpkParameters',&lt;&lt;6,5,43,129,4,0,10&gt;&gt;).
</code></pre>

<p>gives us</p>

<pre><code>{ok,{namedCurve,{1,3,132,0,10}}}
</code></pre>

<p>and</p>

<pre><code>pubkey_cert_records:namedCurves({1,3,132,0,10}).
</code></pre>

<p>gives us our source curve  - secp256k1, and </p>

<pre><code> subjectPublicKey = &lt;&lt;4,241,200,19,168,25,25,81,43,216,
                    89,201,37,62,66,39,166,231,161,98,
                    223,133,119,12,...&gt;&gt;
</code></pre>

<p>is public key itself. But this is workaround how I said before. </p>
","<p>I tried your steps and it worked for me straight away:</p>

<pre><code>g@crayon2:~/test % openssl ecparam -name secp256k1 -genkey -out gen.pem

g@crayon2:~/test % openssl ec -in gen.pem -pubout -out gen.pub
read EC key
writing EC key

g@crayon2:~/test % openssl pkey -in gen.pub -pubin -text -noout
Public-Key: (256 bit)
pub: 
    04:f1:c8:13:a8:19:19:51:2b:d8:59:c9:25:3e:42:
    27:a6:e7:a1:62:df:85:77:0c:ef:f7:0e:0e:19:93:
    df:e6:f5:42:66:7e:ee:02:07:76:85:19:a4:a8:2d:
    03:11:73:0c:b2:d4:4c:c7:0e:42:d3:30:b5:51:e3:
    97:45:f8:b5:6a
ASN1 OID: secp256k1

g@crayon2:~/test % erl
Erlang/OTP 18 [erts-7.2.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V7.2.1  (abort with ^G)

1&gt; rr(public_key).
['AAControls','ACClearAttrs','AccessDescription',
 'Algorithm','AlgorithmIdentifier',
 'AlgorithmIdentifierPKCS-10','AlgorithmIdentifierPKCS-8',
 'AlgorithmIdentifierPKCS5v2-0','AlgorithmIdentifierPKSC-7',
 'AlgorithmNull','AnotherName','AttCertValidityPeriod',
 'Attribute','AttributeCertificate',
 'AttributeCertificateInfo','AttributePKCS-10',
 'AttributePKCS-7','AttributeTypeAndValue',
 'Attributes_SETOF',
 'Attributes_SETOF_valuesWithContext_SETOF',
 'AuthorityKeyIdentifier','BasicConstraints',
 'BuiltInDomainDefinedAttribute','BuiltInStandardAttributes',
 'Certificate','CertificateList','CertificationRequest',
 'CertificationRequestInfo',
 'CertificationRequestInfo_attributes_SETOF'|...]

2&gt; {ok,Data}=file:read_file(""gen.pub"").
{ok,&lt;&lt;""-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE8cgTqBkZUSvYWcklPkInpuehYt+Fdwzv\n9w4OGZPf5vVCZn7u""...&gt;&gt;}

3&gt; Dec=public_key:pem_decode(Data).
[#'SubjectPublicKeyInfo'{algorithm = &lt;&lt;48,86,48,16,6,7,42,
                                       134,72,206,61,2,1,
                                       6,5,43,129,4,0,10,
                                       3,66,0,4,241,200,
                                       ...&gt;&gt;,
                         subjectPublicKey = not_encrypted}]
</code></pre>

<p>My OpenSSL version:</p>

<pre><code>g@crayon2:~/test % openssl version
OpenSSL 1.0.1p-freebsd 9 Jul 2015
</code></pre>

<p>System is <code>FreeBSD 10.2-RELEASE</code>. Erlang version is in the shell output above. The <code>gen.pub</code> key that it generated for me (if you want to try to load it) is:</p>

<pre><code>g@crayon2:~/test % cat gen.pub
-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE8cgTqBkZUSvYWcklPkInpuehYt+Fdwzv
9w4OGZPf5vVCZn7uAgd2hRmkqC0DEXMMstRMxw5C0zC1UeOXRfi1ag==
-----END PUBLIC KEY-----
</code></pre>

<p>Do you maybe want to paste your key so that I can try to load it?</p>

<p><strong>Edit:</strong></p>

<p>Sorry, I missed the last step. This seems to be a bug in the OTP code. The <code>der_decode/2</code> function is called with <code>KeyType</code> set to <code>ECPoint</code>, see the <a href=""https://github.com/erlang/otp/blob/OTP-18.2.4/lib/public_key/src/public_key.erl#L136"" rel=""nofollow""><code>pem_entry_decode/1</code> function</a>. But <a href=""https://github.com/erlang/otp/blob/OTP-18.2.4/lib/public_key/src/public_key.erl#L223"" rel=""nofollow""><code>der_decode/2</code> expects <code>Asn1Type</code></a>. Calling the <code>'OTP-PUB-KEY'</code> module directly seems to be working:</p>

<pre><code>8&gt; Bin = hd(Dec)#'SubjectPublicKeyInfo'.algorithm.
32&gt; 'OTP-PUB-KEY':decode('SubjectPublicKeyInfo', Bin).
{ok,#'SubjectPublicKeyInfo'{algorithm = #'AlgorithmIdentifier'{algorithm = {1,
                                                                            2,840,10045,2,1},
                                                               parameters = &lt;&lt;6,5,43,129,4,0,10&gt;&gt;},
                            subjectPublicKey = &lt;&lt;4,241,200,19,168,25,25,81,43,216,
                                                 89,201,37,62,66,39,166,231,161,98,
                                                 223,133,119,12,...&gt;&gt;}}
</code></pre>

<p>However I am not sure if it returns anything sensible. Maybe worth raising a bug in OTP with the code that you posted in this question as steps to reproduce. Then at least someone competent would verify why it doesn't work. I am sure the steps you followed are fine and the types returned and passed to further functions are OK as far as <a href=""http://erlang.org/doc/man/public_key.html#pem_entry_decode-1"" rel=""nofollow"">the documentation</a> is concerned.</p>
","165","<erlang><public-key><pem><ecdsa>","1","1","2","2016-03-01 20:54:11","35698900","0","0","3182373","","2016-02-29 19:27:26","2016-02-28 20:14:39",""
"35687711","(Erlang) Got error while parsing ecsda public key pem file","<p>I made private and public keys files as</p>

<pre><code>openssl ecparam -name secp256k1 -genkey -out gen.pem

openssl ec -in gen.pem -pubout -out gen.pub
</code></pre>

<p>then I checked .pub file</p>

<pre><code>openssl pkey -in gen.pub  -pubin -text -noout

Public-Key: (256 bit)
pub: 
    04:fc:de:4f:2a:77:bd:c4:f2:74:2b:ba:b5:fc:85:
    e4:aa:96:a7:8e:86:14:bc:0d:fa:8e:d2:dd:50:3c:
    5d:fa:f4:07:f4:17:80:49:06:19:0c:72:03:63:4e:
    07:37:e9:10:64:c8:33:a4:a3:7e:26:d8:df:79:21:
    d7:2d:a6:01:80
ASN1 OID: secp256k1
</code></pre>

<p>After that start erl</p>

<pre><code>erl
Erlang/OTP 18 [erts-7.2] [source-e6dd627] [64-bit] [smp:3:3] [async-threads:10] [hipe] [kernel-poll:false]
</code></pre>

<p>After execution of commands</p>

<pre><code>1&gt;rr(public_key),
  {ok,RawData} = file:read_file(""gen.pub""),
  Decoded = public_key:pem_decode(RawData),
  [public_key:pem_entry_decode(X) || X &lt;- Decoded ].
</code></pre>

<p>I got exception</p>

<pre><code>** exception error: no match of right hand side value 
                    {error,{asn1,{invalid_length,1}}}
     in function  public_key:der_decode/2 (public_key.erl, line 229)
</code></pre>

<p>I know that there are workarounds, but I'm wondering if I do something wrong or there are errors in public key modules ?</p>

<p><strong>UPD 1.</strong></p>

<p>When we look at result </p>

<pre><code>{ok,#'SubjectPublicKeyInfo'{algorithm = #'AlgorithmIdentifier'{algorithm = {1,2,840,10045,2,1},
                                                           parameters = &lt;&lt;6,5,43,129,4,0,10&gt;&gt;},
                        subjectPublicKey = &lt;&lt;4,241,200,19,168,25,25,81,43,216,
                                             89,201,37,62,66,39,166,231,161,98,
                                             223,133,119,12,...&gt;&gt;}}
</code></pre>

<p>we can see next :</p>

<p>{1,2,840,10045,2,1} is oid of ecPublicKey <a href=""http://oid-info.com/get/1.2.840.10045.2.1"" rel=""nofollow"">http://oid-info.com/get/1.2.840.10045.2.1</a></p>

<p>parameters = &lt;&lt;6,5,43,129,4,0,10>></p>

<pre><code>'OTP-PUB-KEY':decode('EcpkParameters',&lt;&lt;6,5,43,129,4,0,10&gt;&gt;).
</code></pre>

<p>gives us</p>

<pre><code>{ok,{namedCurve,{1,3,132,0,10}}}
</code></pre>

<p>and</p>

<pre><code>pubkey_cert_records:namedCurves({1,3,132,0,10}).
</code></pre>

<p>gives us our source curve  - secp256k1, and </p>

<pre><code> subjectPublicKey = &lt;&lt;4,241,200,19,168,25,25,81,43,216,
                    89,201,37,62,66,39,166,231,161,98,
                    223,133,119,12,...&gt;&gt;
</code></pre>

<p>is public key itself. But this is workaround how I said before. </p>
","<p>I found that lines in public_key.erl ( lines 136-137 )</p>

<pre><code>'ECPoint' -&gt;
     der_decode(KeyType, Key0)
</code></pre>

<p>have to be replaced with</p>

<pre><code>'ECPoint' -&gt;
     {{KeyType,Key0},der_decode('EcpkParameters', Params)}
</code></pre>
","165","<erlang><public-key><pem><ecdsa>","1","0","2","2016-03-01 20:54:11","35698900","0","0","3182373","","2016-02-29 19:27:26","2016-02-28 20:14:39",""
"45037979","Matching sec256k1 keys in JS and PHP","<p>I'm having trouble with uniting the <a href=""https://github.com/ionux/phactor"" rel=""nofollow noreferrer"">ionux/phactor</a> PHP library, and the <a href=""https://github.com/indutny/elliptic"" rel=""nofollow noreferrer"">indutny/elliptic</a> JS library.</p>

<p>One library is being used at a LAMP server, the other via Nodejs at Amazon Lambda.</p>

<p>I generate one key pair with the PHP library; sign sha256 hash data and save results as JSON output.</p>

<pre><code>$ec = KeyManager::instance()-&gt;getECKeysByHash($k = '122e43fd75dd0492a259146ab5dfd5c6');

return $response = [
    'source' =&gt; [
        'message' =&gt; $m = 'asd',
        'hash' =&gt; $h = hash('sha256', $m),
        'hash_signed' =&gt; $ec-&gt;sign($h),
     ],
     'ec' =&gt; [
        'key' =&gt; $k,
        'keys' =&gt; config(KeyManager::EC_DIR_NAME.'.'.$k)
     ]

];
</code></pre>

<p>Outputs:</p>

<pre><code>{  
   ""source"":{  
      ""message"":""asd"",
      ""hash"":""688787d8ff144c502c7f5cffaafe2cc588d86079f9de88304c26b0cb99ce91c6"",
      ""hash_signed"":""30460221009a8c0c55ddc3ab3dc3b1e944a92c94fb215b7ed8ac332d398a6acb9d543a5d06022100e87f295c537fb2d14a52476e56b4c3a214be97e421510cbb46cb2059bed342bf""
   },
   ""ec"":{  
      ""key"":""122e43fd75dd0492a259146ab5dfd5c6"",
      ""keys"":{  
         ""private_key_hex"":""0xde1a1c2734cc1e65b46946cfeb7cad28e48e8efbce5e36d859a4aa06ca9bb3f8"",
         ""private_key_dec"":""100459584715065215111848758376288522810407133161466091883119287856242863354872"",
         ""public_key"":""043876c88178bb7e386bbdb6325e201ec8e0e1ab75fc6c7713ed04051e029cb94b9d01c3b6aee0e6c5c92d7456f16667b08b4121526e97f5c704a19f7e9b3cd6c"",
         ""public_key_compressed"":""023876c88178bb7e386bbdb6325e201ec8e0e1ab75fc6c7713ed04051e029cb94b"",
         ""public_key_x"":""3876c88178bb7e386bbdb6325e201ec8e0e1ab75fc6c7713ed04051e029cb94b"",
         ""public_key_y"":""9d01c3b6aee0e6c5c92d7456f16667b08b4121526e97f5c704a19f7e9b3cd6c""
      }
   }
};
</code></pre>

<p>I saved the output to a JS variable <code>tests</code>, and trying to check if the hash generated on the PHP side, equals the JS algorithm in this way:</p>

<pre><code>var ecc = new EC('secp256k1');
var my_hash_word_array = CryptoJS.SHA256(tests.source.message);
var my_hash = my_hash_word_array.toString();

console.log('hash equals:',tests.source.hash == my_hash);
</code></pre>

<p>I can that in this case it's equal!</p>

<p>Now, I want to check if the generated PHP side signature <code>tests.source.hash_signed</code> (from tests.source.hash) relates to the known public key using JS:</p>

<pre><code>var key = ecc.keyFromPublic(tests.ec.keys.public_key_compressed, 'hex'); // &lt;&lt;&lt; problem line
console.log('signOk:', key.verify(my_hash, tests.source.hash_signed));
</code></pre>

<p>The result is ""signOk: false"", why? What am I doing wrong? </p>
","<p>I've spent quite some time trying to track this down, and I'm pretty sure your issue has to do with the key encoding:</p>

<pre><code>var key = ecc.keyFromPublic(tests.ec.keys.public_key_compressed, 'hex');
</code></pre>

<p>This line is apparently looking for a Hexadecimal encoded key.</p>

<p>Looking at your loaded values:</p>

<pre><code>""public_key_compressed"":""023876c88178bb7e386bbdb6325e201ec8e0e1ab75fc6c7713ed04051e029cb94b"",
</code></pre>

<p>public_key_compressed is not in Hexadecimal encoding (hint: doesn't start with ""0x"")</p>

<p>You should make sure to encode this value as Hexadecimal and try again.</p>
","164","<javascript><php><sign><ecdsa>","6","1","1","2017-07-29 01:57:09","45384464","2","","23200","","2017-07-29 01:57:09","2017-07-11 14:52:14",""
"53456433","Python Script for Extracting R & S Values from Scriptsig","<p>I have read a few posts and I am familiar with how scriptsig is formatted and how to extract relevant information from it. The problem I am having is putting it into code.  I have read these posts:
<a href=""https://bitcoin.stackexchange.com/questions/58853/how-do-you-figure-out-the-r-and-s-out-of-a-signature-using-python"">https://bitcoin.stackexchange.com/questions/58853/how-do-you-figure-out-the-r-and-s-out-of-a-signature-using-python</a>
<a href=""https://bitcoin.stackexchange.com/questions/2376/ecdsa-r-s-encoding-as-a-signature"">https://bitcoin.stackexchange.com/questions/2376/ecdsa-r-s-encoding-as-a-signature</a></p>

<p>I have a list of scriptsigs and I have a function (so far) that uses slicing on the scriptsig string:</p>

<pre><code>def scriptsig_to_ecdsa_sig(asn_sig):
        strip1 = asn_sig[6:] #Remove first 6 characters
                if strip1[:2] == ""20"" #Read next two characters to determine length of r

    return { 
        'r': some list,
        's': some list}
</code></pre>

<p>Would this be the best route? If so, how would the best way to finish it be?</p>
","<p>Figured it out:</p>

<pre><code>from pyasn1.codec.der import decoder as asn1der
int_value = asn1der.decode(asn_sig.decode('hex')[1:]) #asn_sig is the scriptsig hex
long(int_value[0][0]) #R Value in int form
long(int_value[0][1]) #S Value in int form
</code></pre>
","161","<python><transactions><ecdsa><bitcoind>","0","0","1","2018-11-26 02:52:06","53474194","0","","2525781","","2018-11-24 20:38:34","2018-11-24 08:20:57",""
"46236765","Which order is correct? ECDSA runs before ECDH or after ECDH?","<p>I am confused about the execution order of ECDSA and ECDH, which one runs first ?</p>

<p>Since ECDH can not avoid MITM attach, therefore ECDSA is used to verify the entity. So ECDSA should run before ECDH ?</p>

<p>Or it doens't matter at all?</p>
","<blockquote>
  <p>Since ECDH can not avoid MITM attack</p>
</blockquote>

<p>First, here is one of the many ways you could solve this difficulty using RSA instead of DSA (or ECDSA): the client, before sending its ECDH (or DH) public key on the wire, could encrypt this ECDH (or DH) public key with the public RSA key of the server. And this way, the server is the only peer that knows the client ECDH key. Therefore, both sides are protected against man in the middle attacks. Of course, using RSA to encrypt another key may need OAEP.</p>

<blockquote>
  <p>Or it doens't matter at all?</p>
</blockquote>

<p>In your case, using ECDSA instead of RSA, you can not encrypt anything. So you need to have mutual authentication in the protocol you will design: your server and your client must have previously exchanged their public ECDSA keys or must have some kind of PKI with some kind of root certificate to authenticate the remote public ECDSA key. Finally, the client and the server just need to follow those steps, in this order:</p>

<ul>
<li>sign their ECDH public key with their ECDSA private key,</li>
<li>send this information to the other host,</li>
<li>receive this information from the other host,</li>
<li>check the signature,</li>
<li>if the check failed, stop talking,</li>
<li>if the signature is correctly checked, perform the end of the DH algorithm.</li>
</ul>
","159","<ecdsa><ecdh>","0","0","1","2018-08-20 22:40:46","46238109","0","","","","","2017-09-15 09:54:22",""
"22902823","I need some help against the money mis in sha256","<p>Having a private ECDSA key 18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725</p>

<p>1 - Take the corresponding public key generated with it 0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6</p>

<p>2 - Perform SHA-256 hashing on the public key 600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408</p>

<p>but when I run a sha256 on 0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6</p>

<p>I don't get</p>

<p>600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408</p>

<p>What I get is</p>

<p>32511e82d56dcea68eb774094e25bab0f8bdd9bc1eca1ceeda38c7a43aceddce</p>

<p>what am I doing wrong?   </p>
","<p>You have to:</p>

<ul>
<li><p>Hash with <code>SHA-256</code> the public key: <code>0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6</code></p></li>
<li><p>Hash with <code>RIPEMD-160</code> the key: <code>600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408</code></p></li>
</ul>

<p>Which should result in <code>010966776006953D5567439E5E39F86A0D273BEE</code>.</p>

<p><img src=""https://i.stack.imgur.com/DvBJ4.jpg"" alt=""enter image description here""></p>
","156","<key><sha256><bitcoin><ecdsa>","0","0","1","2014-04-09 15:52:28","22925519","0","","1413338","","2014-04-09 15:52:28","2014-04-07 02:50:13",""
"45046140","In the pkcs11interop project code, I see CKM_ECDSA_SHA256, but in the nuget package I added to my solution its not there","<p>I need to use ECDSA with sha256 with a hsm and I am using c# with the <a href=""http://www.pkcs11interop.net/"" rel=""nofollow noreferrer"">http://www.pkcs11interop.net/</a> wrapper. The Github code has CKM_ECDSA_SHA256, but not the 3.3.0 release even though the release is the latest as of Jan 24 and the enum was added much earlier.</p>

<p>Why cannot I access the enum? I could use CKM_ECDSA and hash before signing, but that would defeat the purpose of using the hsm for its speed.</p>
","<p>CKM_ECDSA_SHA256 enum member was added on 1 March 2017 as a part of <a href=""https://github.com/Pkcs11Interop/Pkcs11Interop/commit/1d442cae3a1470cdc28c0df806c628d36d59007d"" rel=""nofollow noreferrer"">larger patch</a> that added support for PKCS#11 v2.40. It was not present in Pkcs11Interop v3.3.0 but it is present in <a href=""https://github.com/Pkcs11Interop/Pkcs11Interop/blob/master/src/Pkcs11Interop/Pkcs11Interop/Common/CKM.cs#L1352"" rel=""nofollow noreferrer"">master branch</a> on GitHub which is yet to be released as Pkcs11Interop v4.0.0.</p>

<p>Meanwhile you can use overloaded method which accepts ulong instead of CKM and define missing constant in your code:</p>

<pre><code>const ulong CKM_ECDSA_SHA256 = 0x00001044;
</code></pre>
","155","<c#><sha256><pkcs#11><ecdsa><pkcs11interop>","1","1","1","2017-07-12 17:10:34","45051663","0","","","","","2017-07-11 23:45:53",""
"50408019","Crypto++ Ed448 unknown oid","<p>I have been trying to generate an Ed448 ECDSA key using crypto++ 7 from debian experimental. My code is as follows:</p>

<pre><code>AutoSeededRandomPool rng;
ECIES&lt;ECP&gt;::Decryptor d(rng, ASN1::curve448());
</code></pre>

<p>I can compile this code without errors, but when it runs, I get the following exception:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::UnknownOID'
  what():  BER decode error: unknown object identifier
</code></pre>

<p>Looking through the interwebs, It appears that curve448 was implemented last version. How can I fix this?</p>
","<blockquote>
  <p>I have been trying to generate an Ed448 ECDSA key... It appears that curve448 was implemented last version.</p>
</blockquote>

<p>We added the OIDs for the 25519 and 448 curves some time ago. They were added to ease testing of curve25519 and ed25519. You can see the OIDs at <a href=""https://github.com/weidai11/cryptopp/blob/master/oids.h"" rel=""nofollow noreferrer""><code>oids.h</code></a>.</p>

<p>They OIDs were added at <a href=""https://github.com/weidai11/cryptopp/commit/7ca5f7d3b53f"" rel=""nofollow noreferrer"">Commit 7ca5f7d3b53f</a> on on Apr 11, 2016, and then subsequently fixed on the same day at <a href=""https://github.com/weidai11/cryptopp/commit/29e9bd2b27a9"" rel=""nofollow noreferrer"">Commit 29e9bd2b27a9</a>. Apr 11, 2016 made them available to Crypto++ 5.6.4.</p>

<hr>

<blockquote>
  <p>I can compile this code without errors, but when it runs, I get the following exception</p>
</blockquote>

<p>You are getting the exception because there are no domain parameters for curve448 in <a href=""https://github.com/weidai11/cryptopp/blob/master/eccrypto.cpp#L457"" rel=""nofollow noreferrer""><code>eccrypto.cpp</code></a>. You are hitting the exception below because <code>it == end</code>.</p>

<pre><code>template &lt;class EC&gt; void DL_GroupParameters_EC&lt;EC&gt;::Initialize(const OID &amp;oid)
{
    const EcRecommendedParameters&lt;EllipticCurve&gt; *begin, *end;
    GetRecommendedParameters(begin, end);
    const EcRecommendedParameters&lt;EllipticCurve&gt; *it = std::lower_bound(begin, end, oid, OIDLessThan());
    if (it == end || it-&gt;oid != oid)
        throw UnknownOID();

    const EcRecommendedParameters&lt;EllipticCurve&gt; &amp;param = *it;
    m_oid = oid;
    ...
}
</code></pre>

<hr>

<p>Here's the back story...</p>

<p>According to curve25519's <a href=""https://cr.yp.to/ecdh.html"" rel=""nofollow noreferrer"">A state-of-the-art Diffie-Hellman function</a>, the source code for the curve is at <a href=""https://bench.cr.yp.to/supercop.html"" rel=""nofollow noreferrer"">SUPERCOP</a>. SUPERCOP is a benchmarking program for cryptographic algorithms.</p>

<p>We have curve25519 and ed25519 on a testing fork. We ripped the implementation from SUPERCOP. SUPERCOP has the optimized reference implementations of curve25519, curve448, and lots of other stuff. Once curve25519 and ed25519 were added we planned on curve448.</p>

<p>We added curve25519 based on Andrew Moon's implementation. That provides <code>x25519</code> and <code>ed25519</code>. Also see <a href=""https://github.com/weidai11/cryptopp/issues/761"" rel=""nofollow noreferrer"">Issue 761</a> (x25519) and <a href=""https://github.com/weidai11/cryptopp/issues/764"" rel=""nofollow noreferrer"">Issue 764</a> (ed25519).</p>

<p>At this point the Crypto++ implementations of curve448 are stalled. I think your options are roll your own based on SUPERCOP, or use a library like <code>libsodium</code>, Botan or OpenSSL.</p>
","152","<crypto++><ecdsa>","1","2","1","2019-02-19 17:10:59","50429065","0","","2670194","","2018-05-18 11:15:47","2018-05-18 09:24:26",""
"53669673","Diffie Hellman Key Exchange using ECDSA x509 certificates","<p>I am trying to perform a Diffie-Hellman key exchange using 2 ECDSA x509 certificates.</p>

<p>Here is the method where I extract the keys from the certificates for computation of the derived key.</p>

<pre><code>private byte[] GetDerivedKey(X509Certificate2 publicCertificate, X509Certificate2 privateCertificate)
    {
        byte[] derivedKey;

        using (var privateKey = privateCertificate.GetECDsaPrivateKey())
        using (var publicKey = publicCertificate.GetECDsaPublicKey())
        {
            var privateParams = privateKey.ExportParameters(true);  //This line is failing
            var publicParams = publicKey.ExportParameters(false);

            using (var privateCng = ECDiffieHellmanCng.Create(privateParams))
            using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
            {
                derivedKey = privateCng.DeriveKeyMaterial(publicCng.PublicKey);
            }
        }


        return derivedKey;
    }
</code></pre>

<p>I've commented on the line that is failing <code>privateKey.ExportParameters(true)</code> with the error:</p>

<blockquote>
  <p>System.Security.Cryptography.CryptographicException : The requested operation is not supported.  </p>
  
  <p>at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)<br>
     at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)<br>
     at System.Security.Cryptography.ECCng.ExportParameters(CngKey key, Boolean includePrivateParameters, ECParameters&amp; ecparams)<br>
     at System.Security.Cryptography.ECDsaCng.ExportParameters(Boolean includePrivateParameters)</p>
</blockquote>

<p>Because this is a self signed certificate that I am generating, I assume I am doing something wrong.</p>

<p>I first create a root CA certificate and pass in the private key to sign my certificate.</p>

<pre><code>private X509Certificate2 CreateECSDACertificate(string certificateName,
        string issuerCertificateName,
        TimeSpan lifetime,
        AsymmetricKeyParameter issuerPrivateKey,
        string certificateFriendlyName = null)
    {
        // Generating Random Numbers
        var randomGenerator = new CryptoApiRandomGenerator();
        var random = new SecureRandom(randomGenerator);

        var signatureFactory = new Asn1SignatureFactory(""SHA256WithECDSA"", issuerPrivateKey, random);

        // The Certificate Generator
        var certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        var serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Issuer and Subject Name
        var subjectDistinguishedName = new X509Name($""CN={certificateName}"");
        var issuerDistinguishedName = new X509Name($""CN={issuerCertificateName}"");
        certificateGenerator.SetSubjectDN(subjectDistinguishedName);
        certificateGenerator.SetIssuerDN(issuerDistinguishedName);

        // Valid For
        var notBefore = DateTime.UtcNow.Date;
        var notAfter = notBefore.Add(lifetime);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        //key generation
        var keyGenerationParameters = new KeyGenerationParameters(random, _keyStrength);
        var keyPairGenerator = new ECKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        var subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        var certificate = certificateGenerator.Generate(signatureFactory);

        var store = new Pkcs12Store();
        var certificateEntry = new X509CertificateEntry(certificate);
        store.SetCertificateEntry(certificateName, certificateEntry);
        store.SetKeyEntry(certificateName, new AsymmetricKeyEntry(subjectKeyPair.Private), new[] { certificateEntry });

        X509Certificate2 x509;

        using (var pfxStream = new MemoryStream())
        {
            store.Save(pfxStream, null, new SecureRandom());
            pfxStream.Seek(0, SeekOrigin.Begin);
            x509 = new X509Certificate2(pfxStream.ToArray());
        }

        x509.FriendlyName = certificateFriendlyName;

        return x509;
    }
</code></pre>

<p>The <code>.HasPrivateKey()</code> method returns true, which I've read can return a false positive.  </p>

<p>When I add my certificates to the store, I can verify the cert chain.</p>

<pre><code>    [Test]
    public void CreateSelfSignedCertificate_AfterAddingToStore_CanBuildChain()
    {
        var result = _target.CreateSelfSignedCertificate(_subject, _issuer, TimeSpan.FromDays(356), _certificateFriendlyName, _issuerFriendlyName);

        _store.TryAddCertificateToStore(result.CertificateAuthority, _caStoreName, _location);
        _store.TryAddCertificateToStore(result.Certificate, _certStoreName, _location);

        var chain = new X509Chain
        {
            ChainPolicy =
            {
                RevocationMode = X509RevocationMode.NoCheck
            }
        };

        var chainBuilt = chain.Build(result.Certificate);

        if (!chainBuilt)
        {
            foreach (var status in chain.ChainStatus)
            {
                Assert.Warn(string.Format(""Chain error: {0} {1}"", status.Status, status.StatusInformation));
            }
        }

        Assert.IsTrue(chainBuilt, ""Chain"");
    }
</code></pre>

<p>I thought at first that maybe the private cert had to come from the cert store, so I imported it and then pulled it back out, but I get the same error, which is another reason I believe I'm not doing something quite right.</p>

<p><strong>EDIT:</strong></p>

<p>I have another class generating RSA x509's using the same code for putting the private key into the certificate.  It allows me to export the RSA private key.  </p>

<p>The variable <code>_keyStrength</code> is 384 and my signature factory is using <code>""SHA256withECDSA""</code>.  I have also tried using <code>""SHA384withECDSA""</code> but I get the same error.</p>
","<p>OK. It's a blind shot but after looking at your code I noticed two things:</p>

<ul>
<li>When you create PFX you set null password. But when you load the PFX into <code>X509Certificate2</code> class you are using wrong constructor. You should use one with a password parameter and give a null into it</li>
<li>When you load PFX into <code>X509Certificate2</code> class you do not specify, if the private key should be exportable. I think that this is the reason why <code>privateKey.ExportParameters(true)</code> gives you an exception. You should use <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509certificate2.-ctor?view=netframework-4.7.2#System_Security_Cryptography_X509Certificates_X509Certificate2__ctor_System_Byte___System_Security_SecureString_System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_"" rel=""nofollow noreferrer"">this</a> constructor and specify <code>null</code> as password</li>
</ul>

<hr>

<h1>Made it working</h1>

<p>I thought it was a bug. It's possible that it is. We clearly stated in X509Constructor that the private key should be exportable. I used <code>X509KeyStorageFlags.EphemeralKeySet | X509KeyStorageFlags.Exportable</code> flags too. But when I looked at the CngKey it had ExportPolicy set to <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.cngexportpolicies?view=netframework-4.7.2"" rel=""nofollow noreferrer""><code>AllowExport</code></a> but not <code>AllowPlaintextExport</code>. </p>

<p>It was exportable in some way. <code>privateKey.Key.Export(CngKeyBlobFormat.OpaqueTransportBlob)</code> worked. But <code>privateKey.ExportParameters(true)</code> did not.</p>

<p>I've searched for a solution how to change ExportPolicy of CngKey. I found <a href=""https://stackoverflow.com/q/48542233/3245057"">this SO question</a> that helped me to change it. After that the <code>ExportParameters</code> worked.</p>

<p>The fixed version of your <code>GetDerivedKey</code> method is</p>

<pre><code>private byte[] GetDerivedKey(X509Certificate2 publicCertificate, X509Certificate2 privateCertificate)
{
    byte[] derivedKey;

    using (var privateKey = privateCertificate.GetECDsaPrivateKey())
    using (var publicKey = privateCertificate.GetECDsaPublicKey())
    {
        var myPrivateKeyToMessWith = privateKey as ECDsaCng;

        // start - taken from https://stackoverflow.com/q/48542233/3245057 
        // make private key exportable:
        byte[] bytes = BitConverter.GetBytes((int)(CngExportPolicies.AllowExport | CngExportPolicies.AllowPlaintextExport));
        CngProperty pty = new CngProperty(NCryptExportPolicyProperty, bytes, CngPropertyOptions.Persist);
        myPrivateKeyToMessWith.Key.SetProperty(pty);
        // end - taken from https://stackoverflow.com/q/48542233/3245057

        var privateParams = myPrivateKeyToMessWith.ExportParameters(true);  //This line is NOT failing anymore
        var publicParams = publicKey.ExportParameters(false);

        using (var privateCng = ECDiffieHellmanCng.Create(privateParams))
        using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
        {
            derivedKey = privateCng.DeriveKeyMaterial(publicCng.PublicKey);
        }
    }

    return derivedKey;
}
</code></pre>
","146","<c#><bouncycastle><x509certificate2><ecdsa><diffie-hellman>","1","2","2","2018-12-07 16:34:19","53670577","0","","107455","","2018-12-07 14:27:20","2018-12-07 12:35:42",""
"53669673","Diffie Hellman Key Exchange using ECDSA x509 certificates","<p>I am trying to perform a Diffie-Hellman key exchange using 2 ECDSA x509 certificates.</p>

<p>Here is the method where I extract the keys from the certificates for computation of the derived key.</p>

<pre><code>private byte[] GetDerivedKey(X509Certificate2 publicCertificate, X509Certificate2 privateCertificate)
    {
        byte[] derivedKey;

        using (var privateKey = privateCertificate.GetECDsaPrivateKey())
        using (var publicKey = publicCertificate.GetECDsaPublicKey())
        {
            var privateParams = privateKey.ExportParameters(true);  //This line is failing
            var publicParams = publicKey.ExportParameters(false);

            using (var privateCng = ECDiffieHellmanCng.Create(privateParams))
            using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
            {
                derivedKey = privateCng.DeriveKeyMaterial(publicCng.PublicKey);
            }
        }


        return derivedKey;
    }
</code></pre>

<p>I've commented on the line that is failing <code>privateKey.ExportParameters(true)</code> with the error:</p>

<blockquote>
  <p>System.Security.Cryptography.CryptographicException : The requested operation is not supported.  </p>
  
  <p>at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)<br>
     at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)<br>
     at System.Security.Cryptography.ECCng.ExportParameters(CngKey key, Boolean includePrivateParameters, ECParameters&amp; ecparams)<br>
     at System.Security.Cryptography.ECDsaCng.ExportParameters(Boolean includePrivateParameters)</p>
</blockquote>

<p>Because this is a self signed certificate that I am generating, I assume I am doing something wrong.</p>

<p>I first create a root CA certificate and pass in the private key to sign my certificate.</p>

<pre><code>private X509Certificate2 CreateECSDACertificate(string certificateName,
        string issuerCertificateName,
        TimeSpan lifetime,
        AsymmetricKeyParameter issuerPrivateKey,
        string certificateFriendlyName = null)
    {
        // Generating Random Numbers
        var randomGenerator = new CryptoApiRandomGenerator();
        var random = new SecureRandom(randomGenerator);

        var signatureFactory = new Asn1SignatureFactory(""SHA256WithECDSA"", issuerPrivateKey, random);

        // The Certificate Generator
        var certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        var serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Issuer and Subject Name
        var subjectDistinguishedName = new X509Name($""CN={certificateName}"");
        var issuerDistinguishedName = new X509Name($""CN={issuerCertificateName}"");
        certificateGenerator.SetSubjectDN(subjectDistinguishedName);
        certificateGenerator.SetIssuerDN(issuerDistinguishedName);

        // Valid For
        var notBefore = DateTime.UtcNow.Date;
        var notAfter = notBefore.Add(lifetime);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        //key generation
        var keyGenerationParameters = new KeyGenerationParameters(random, _keyStrength);
        var keyPairGenerator = new ECKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        var subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        var certificate = certificateGenerator.Generate(signatureFactory);

        var store = new Pkcs12Store();
        var certificateEntry = new X509CertificateEntry(certificate);
        store.SetCertificateEntry(certificateName, certificateEntry);
        store.SetKeyEntry(certificateName, new AsymmetricKeyEntry(subjectKeyPair.Private), new[] { certificateEntry });

        X509Certificate2 x509;

        using (var pfxStream = new MemoryStream())
        {
            store.Save(pfxStream, null, new SecureRandom());
            pfxStream.Seek(0, SeekOrigin.Begin);
            x509 = new X509Certificate2(pfxStream.ToArray());
        }

        x509.FriendlyName = certificateFriendlyName;

        return x509;
    }
</code></pre>

<p>The <code>.HasPrivateKey()</code> method returns true, which I've read can return a false positive.  </p>

<p>When I add my certificates to the store, I can verify the cert chain.</p>

<pre><code>    [Test]
    public void CreateSelfSignedCertificate_AfterAddingToStore_CanBuildChain()
    {
        var result = _target.CreateSelfSignedCertificate(_subject, _issuer, TimeSpan.FromDays(356), _certificateFriendlyName, _issuerFriendlyName);

        _store.TryAddCertificateToStore(result.CertificateAuthority, _caStoreName, _location);
        _store.TryAddCertificateToStore(result.Certificate, _certStoreName, _location);

        var chain = new X509Chain
        {
            ChainPolicy =
            {
                RevocationMode = X509RevocationMode.NoCheck
            }
        };

        var chainBuilt = chain.Build(result.Certificate);

        if (!chainBuilt)
        {
            foreach (var status in chain.ChainStatus)
            {
                Assert.Warn(string.Format(""Chain error: {0} {1}"", status.Status, status.StatusInformation));
            }
        }

        Assert.IsTrue(chainBuilt, ""Chain"");
    }
</code></pre>

<p>I thought at first that maybe the private cert had to come from the cert store, so I imported it and then pulled it back out, but I get the same error, which is another reason I believe I'm not doing something quite right.</p>

<p><strong>EDIT:</strong></p>

<p>I have another class generating RSA x509's using the same code for putting the private key into the certificate.  It allows me to export the RSA private key.  </p>

<p>The variable <code>_keyStrength</code> is 384 and my signature factory is using <code>""SHA256withECDSA""</code>.  I have also tried using <code>""SHA384withECDSA""</code> but I get the same error.</p>
","<p>I started using the solution @pepo posted which lead me to discover 'GetECDsaPrivateKey' does not return an <code>ECDsa</code> object but an <code>ECDsaCng</code>.  I simplified the key derivation to this.</p>

<pre><code>byte[] derivedKey;

using (var privateKey = (ECDsaCng)certificate.GetECDsaPrivateKey())
using (var publicKey = (ECDsaCng)certificate.GetECDsaPublicKey())
{
    var publicParams = publicKey.ExportParameters(false);

    using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
    using (var diffieHellman = new ECDiffieHellmanCng(privateKey.Key))
    {
        derivedKey = diffieHellman.DeriveKeyMaterial(publicCng.PublicKey);
    }
}

return derivedKey;
</code></pre>
","146","<c#><bouncycastle><x509certificate2><ecdsa><diffie-hellman>","1","0","2","2018-12-07 16:34:19","53670577","0","","107455","","2018-12-07 14:27:20","2018-12-07 12:35:42",""
"49024466","AuthenticatAsClient fails with CRYPT_E_ASN1_BADTAG","<p>I have written a .NET application that tries to do mutual authentication with an ECC client certificate (curve is brainpoolP384r1).
The certificate is signed by a PKI and when I look at it in an ASN1 viewer it seems to be perfectly valid. 
I get the certificate byte data for this the following way:</p>

<pre><code>Console.WriteLine($""Certificate:{BitConverter.ToString(cert.RawData).Replace(""-"","""")}"");
</code></pre>

<p>Looking at the certificate in the MMC console it also appears to be valid.</p>

<p>However, when I try to use it to authenticate as a client it fails with <code>CRYPT_E_ASN1_BADTAG</code>.</p>

<p>The code-snippet where I try to authenticate:</p>

<pre><code>TcpClient client = new TcpClient(serverName, 9909);
Console.WriteLine(""Client connected."");
SslStream sslStream = new SslStream(
    client.GetStream(),
    false,
    new RemoteCertificateValidationCallback(ValidateServerCertificate),
    null
);

try
{
    var certificates = new X509CertificateCollection();
    certificates.Add(cert);
    sslStream.AuthenticateAsClient(serverName, certificates, SslProtocols.Tls12, false);
}
catch (Exception e)
{
    Console.WriteLine(""Exception: {0} \n{1}"", e.Message, e.StackTrace);
    if (e.InnerException != null)
    {
        Console.WriteLine(""Inner exception: {0}"", e.InnerException.Message);
    }

    Console.WriteLine(""Authentication failed - closing the connection."");
    client.Close();
    return;
}
</code></pre>

<p>The exception:</p>

<blockquote>
  <p>Exception: ASN1 Ungltiger Kennzeichenwert
         at System.Net.SSPIWrapper.AcquireCredentialsHandle(SSPIInterface
  secModule, String package, CredentialUse intent, SCHANNEL_CRED scc)
         at System.Net.Security.SslStreamPal.AcquireCredentialsHandle(CredentialUse
  credUsage, SCHANNEL_CRED secureCredential)
         at System.Net.Security.SslStreamPal.AcquireCredentialsHandle(X509Certificate
  certificate, SslProtocols protocols, EncryptionPolicy policy, Boolean
  isServer)
         at System.Net.Security.SecureChannel.AcquireClientCredentials(Byte[]&amp;
  thumbPrint)
         at System.Net.Security.SecureChannel.GenerateToken(Byte[] input, Int32 offset, Int32 count, Byte[]&amp; output)
         at System.Net.Security.SecureChannel.NextMessage(Byte[] incoming, Int32 offset, Int32 count)
         at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)
         at System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
         at System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
         at System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
         at System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken
  message, AsyncProtocolRequest asyncRequest)
         at System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)
         at System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest)
         at System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult
  lazyResult)
         at System.Net.Security.SslStream.AuthenticateAsClient(String targetHost, X509CertificateCollection clientCertificates, SslProtocols
  enabledSslProtocols, Boolean checkCertificateRevocation)</p>
</blockquote>

<p>As usual for MS the reason for the failure is not detailed enough to fix the issue. Is there any way to find out which of the approximately 70 tags in the certificate is invalid?</p>

<p>One more piece of information: The keypair and the csr are created using bouncycastle as I did not find a way to do a cmp-request with .NET only. Could this be the reason? But why is the certificate displayed as valid in the mmc console?</p>

<p>Sorry for not providing a complete verifiable example but even the stripped down code for creating the csr, sending it, attaching the private key to the certificate and storing it in the MYStore is way to long and without a PKI absolutely useless.</p>

<p><strong>UPDATE</strong></p>

<p>The code to load the certificate from the store is as follows:</p>

<pre><code>static X509Certificate2 LoadFromStore(string commonName)
{
    var distinguishedName = ""CN="" + commonName;
    var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    store.Open(OpenFlags.ReadOnly);

    X509Certificate2 result = null;

    foreach (var cert in store.Certificates)
    {
        if (cert.SubjectName.Name != null &amp;&amp; cert.SubjectName.Name.Equals(distinguishedName))
        {
           Console.WriteLine(""Found certificate in local store: "" + cert.SubjectName.Name);

            result = cert;
            break;
        }
    }

    store.Close();
    return result;
}
</code></pre>
","<p>As usual when working with microsoft APIs the error has nothing to do with the real reason... :-(</p>

<p>The cause of all this was a wrong csr that made the received certificate have valid ASN1 structure (verified with <a href=""http://lapo.it/asn1js/"" rel=""nofollow noreferrer"">http://lapo.it/asn1js/</a>) with invalid content. How to do it right can be found in the answer to <a href=""https://stackoverflow.com/questions/49045873/c-sharp-ecc-certificate-requested-with-bouncycastle-seems-to-be-invalid-in-ne/"">this SO question</a>. </p>

<p>User pepo helped me a lot to get on the right track (Thank you once again!). 
His comment suggesting to use <code>certutil -user -store my</code> instead of looking at the MMC console was the hint I needed to sort this out.</p>
","145","<c#><.net><bouncycastle><x509certificate2><ecdsa>","0","0","1","2018-03-02 08:00:09","49064935","12","","5841337","","2018-02-28 08:36:15","2018-02-28 07:51:58",""
"48636004","Get ECDSA key by id for openssl_verify function","<p>I need a little help.
I have a txt file with ecdsa public keys:</p>

<pre><code>KEY_ID: 1
STATUS: VALID
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE+Y5mYZL/EEY9zGji+hrgGkeoyccK
D0/oBoSDALHc9+LXHKsxXiEV7/h6d6+fKRDb6Wtx5cMzXT9HyY+TjPeuTg==
-----END PUBLIC KEY-----

KEY_ID: 2
STATUS: VALID
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEaq6djyzkpHdX7kt8DsSt6IuSoXjp
WVlLfnZPoLaGKc/2BSfYQuFIO2hfgueQINJN3ZdujYXfUJ7Who+XkcJqHQ==
-----END PUBLIC KEY-----

KEY_ID: 3
STATUS: VALID
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEkvgJ6sc2MM0AAFUJbVOD/i34YJJ8
ineqTN+DMjpI5q7fQNPEv9y2z/ecPl8qPus8flS4iLOOxdwGoF1mU9lwfA==
-----END PUBLIC KEY-----
</code></pre>

<p>Now I need use key by ID in <code>openssl_verify</code> function.</p>

<p>My code:</p>

<pre><code>$ecdsa_url_string = 'ECDSA_URL_STRING';
$stringToVerify = 'MY_STRING';
$ecdsa_keys = openssl_pkey_get_public(file_get_contents(PATH . '/ecdsa_keys.txt'));

$verified = openssl_verify($stringToVerify,pack(""H*"",$ecdsa_url_string ),$ecdsa_keys,""sha256"");

if($verified === 1){
.....
}
</code></pre>

<p>Now my question/problem:
I also have the KEY_ID parameter in the return URL. When ID is 1, everything is OK because <code>openssl_pkey_get_public</code> function always returns only the ID 1 key. </p>

<p>Q1: I can not retrieve the other keys.
Q2: How do I specify which ID I want use for <code>openssl_pkey_get_public</code>?</p>

<p>I am ashamed of my ignorance and my stupidity.
Can anyone please help me with this?
thx</p>
","<p>@Lawrence Cherone answer work for me.
<a href=""https://stackoverflow.com/questions/35138710/parse-public-keys-from-txt-file-by-php"">Parse public keys from .txt file by php</a></p>

<p>my code:</p>

<pre><code>$ecdsa_keys = file_get_contents(PATH . '/ecdsa_keys.txt');
$ecdsa_key_id = 'KEY_FROM_URL';

function getKeyById($id, $ecdsa_keys){
    if(preg_match(""~KEY_ID: $id\s+STATUS: VALID\s+(-{5}BEGIN PUBLIC KEY-{5}.+?-{5}END PUBLIC KEY-{5})~s"", $ecdsa_keys, $match)){
        $result = $match[1];
        return $result;
    }
    return null;
}

if(($ecdsa_key = getKeyById($ecdsa_key_id, $ecdsa_keys)) !== null){
    echo ""&lt;pre&gt;"".$ecdsa_key.""&lt;/pre&gt;"";
} else {
    echo ""not found"";
}
</code></pre>

<p>thx for help</p>
","137","<php><verify><php-openssl><ecdsa>","1","0","1","2018-02-08 10:23:36","","5","1","608639","","2018-02-06 05:34:11","2018-02-06 05:24:33",""
"57225736","Unknown 116-byte ECDSA private key format","<p>iOS 13's CryptoKit framework provides a <code>.rawRepresentation</code> value for ECDSA public and private keys. I've been trying to reverse-engineer the <code>rawRepresentation</code> data type to convert between it and JWK. Judging by the 64-byte length of the public key representation, it seems to be a simple <code>x || y</code> concatenation. I would guess that the private key would then be <code>x || y || d</code>, but this doesn't seem to be the case, as doing so should yield a 96-byte string, while the actual <code>rawRepresentation</code> is <strong>144 bytes</strong>. It also doesn't seem to be a valid DER/ASN.1 string either. I haven't managed to find a spec that lines up with the actual values I'm getting.</p>

<p>As you could guess, Apple's docs are very descriptive.</p>

<blockquote>
  <p><code>rawRepresentation</code>: A representation of the private key as a collection of bytes.</p>
</blockquote>

<p>An example key pair in hex is provided.</p>

<pre><code>Private: 988f8187ff7f00007466815b0d6b02ae1a063198fd1e4923fb1e413195126cc00d30483284186b435726c0c69cc774274ea32eb6a17cbaf2ea88dd7f3a5a2a3ce637bc4b96523c2795035bd2fbeb093b010000000000000000000000000000000000000000000000000000000000000012b2b61abe8beae5aeb6d0bda739235364de96c7f498813cfb0336198dcf9063
Public:  2774c79cc6c02657436b18843248300dc06c129531411efb23491efd9831061a3b09ebfbd25b0395273c52964bbc37e63c2a5a3a7fdd88eaf2ba7ca1b62ea34e
</code></pre>

<p>What format could this be?</p>
","<p>I was unable to figure out <code>rawRepresentation</code>, so I ended up using <code>x963Representation</code>, which is <code>0x04 + x + y + d</code> for the private key (97 bytes), and <code>04 + x + y</code> for the public key (65 bytes).</p>
","137","<swift><binary-data><ecdsa><key-pair><apple-cryptokit>","9","0","1","2019-08-13 16:24:11","","5","1","2694431","","2019-07-31 19:02:10","2019-07-26 19:02:52",""
"52951136","ECDSA verification with BouncyCastle: SignatureException: error decoding signature bytes","<p>While trying to verify a signature persisted on a database as a String i get this exception:</p>

<pre><code>java.security.SignatureException: error decoding signature bytes.
at org.bouncycastle.jcajce.provider.asymmetric.util.DSABase.engineVerify(Unknown Source)
at java.base/java.security.Signature$Delegate.engineVerify(Signature.java:1245)
at java.base/java.security.Signature.verify(Signature.java:674)
at SignCheck.ValidateSignature(SignCheck.java:65)
at SignCheck.main(SignCheck.java:26)
</code></pre>

<p>What I am making wrong?
This is the simplified application:</p>

<pre><code>String signature = ""308194024802ce15a95958817cf7ac8086332d0eb7e5a7faed71c225845251514ddf3ca56246498169a27a814f62f457a4336338e9931e4b12dda0e8cf221f83c4a33c31c907a4b3520d0c3c3b0248012801b7f51e810165762ff2848752cefb4dcef1e862d9783740d40d6436e7b45c151bce9ea19c2dce205351115cb3b753af611fdc8dfc19ac11e49f29d81c1699e9f38cdb1ba45d"";
String stringToCheck = ""CCCCBBBBTue Oct 23 15:26:02 CEST 2018"";
String publicKey = ""3081a7301006072a8648ce3d020106052b81040027038192000406dbfdc0ccf5cc8230b773b4c21059c3c47e2e832a962a0015f9f440cccc80ca1d4af9f3e39f96dffcd09f6015373e4373a764c2aadac8db8db62e28196a7f7a6cacb971f0cfee570292eb0c8c78b14054ce5b7e85f616b10571044dcfad51c271f09746577aa6068f94d395533f2a8f723a112e72962117fef2e5c6ce4b32d8217a86e96ddec7f8241d4b30941b8f78"";

try {
        Security.addProvider(new BouncyCastleProvider());
        Signature ecdsaVerify = Signature.getInstance(""SHA256withECDSA"", ""BC"");

        KeyFactory fact = KeyFactory.getInstance(""ECDSA"", ""BC"");
        PublicKey pub= fact.generatePublic(new X509EncodedKeySpec(Hex.decode(publicKey)));
        ecdsaVerify.initVerify(pub);


        ecdsaVerify.update(stringToCheck.getBytes(""UTF-8""));
        boolean result = ecdsaVerify.verify(signature.getBytes());

       return result;
    } catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | UnsupportedEncodingException | SignatureException e) {
        e.printStackTrace();
        System.out.println(""FALSIFICATION DETECTED!"");
    }
</code></pre>
","<p>The signature that you're trying to verify is in <code>hex</code> format and the <code>.getBytes()</code> doesn't do what you expect it to do. You need to convert the signature hex string into a <code>byte[]</code> and then validate with this result in the <code>ecdsaVerify.verify(signatureBytes)</code> where <code>signatureBytes</code> is the <code>Hex.decode(signature)</code>.</p>
","134","<java><bouncycastle><signature><ecdsa>","0","0","1","2019-04-05 05:48:21","","0","","","","","2018-10-23 14:08:24",""
"40103133","JSch Exception while using ecdh as kex algorithm","<p>I am working on FIPS requirement for which i have to use ecdh-sha2-nistp384 as kex algorithm. I changed the config by using </p>

<pre><code>        session.setConfig(""StrictHostKeyChecking"", ""no"");
        session.setConfig(""CheckKexes"", """");
        session.setConfig(""kex"", ""ecdh-sha2-nistp384"");
        session.setConfig(""ssh-rsa"", ""ecdsa-sha2-nistp384"");
</code></pre>

<p>When I am putting this in the code the issue is I am getting the following exception.</p>

<pre><code>com.jcraft.jsch.JSchException: verify: false
</code></pre>

<p>which seems like too generic to me. I serached a lot but did not find any person using ecdh for kex using JSch any help will be appreciated.</p>
","","133","<java><ssh><jsch><ecdsa>","0","","0","2016-11-03 14:51:56","","4","1","3180409","","2016-11-03 14:51:56","2016-10-18 08:22:13",""
"55519943","Parse CMS base64 encrypted signature into PKCS7 file and get certs using nodejs","<p>I'm working with apple pay token decryption and am having some difficulties with the signature verification part. Step 1 is to take the CMS base64 encoded signature, parse it to a PEM file and get the attached certificates. I saw some examples on github in other languages and it seems like I should be able to base64 decode the signature and parse it to a PKCS7 file and it should have a certificates property to get the certificates from, but I can't seem to figure out how to do that with javscript/nodejs. I've tried using node-forge and calling  forge.pkcs7.createSignedData() and then setting the content to the base64 decoded signature string, and while that does create a PKCS7 file, I can't seem to figure out how to get the certs from it. What I'm trying to do is essentially the openssl command 'openssl pkcs7 -in test.pem -inform -print_certs -out test.crt', where test.pem is the PEM file containing the PKCS7 content and test.crt is the newly created file containing the attached certificates. I think part of the reason node-forge isn't helping me too much is because from my understanding, node-forge doesn't support ECDSA, but I'm not an expert in cryptography so I may be mistaken. Can anyone help point me in the right direction or to a different npm package that can help me accomplish this? Thanks!</p>
","","130","<javascript><node.js><ssl-certificate><digital-signature><ecdsa>","0","","0","2019-04-08 21:32:28","","0","","4086990","","2019-04-08 21:32:28","2019-04-04 15:38:34",""
"29520209","How do I check if a server is using an ECDSA fingerprint in SSH otherwise quit?","<p>How do I make my expect script check if a server is using an ECDSA key and if it is continue with the script otherwise if it's something like RSA quit immediately?</p>

<pre><code>#!/usr/bin/expect

#Usage sshsudologin.expect &lt;host&gt; &lt;ssh user&gt; &lt;ssh password&gt;

set timeout 60

spawn ssh [lindex $argv 1]@[lindex $argv 0]

 expect ""yes/no"" {
     send ""yes\r""
     expect ""*?assword"" { send ""[lindex $argv 2]\r"" }
    } ""*?assword"" { send ""[lindex $argv 2]\r"" }

 expect "" "" { send ""sudo su -\r"" }
 expect "" "" { send ""commands\r"" }
 expect "" "" { send ""exit\r"" }
 expect "" "" { send ""exit\r"" }
 interact
</code></pre>
","<p>To elaborate on the Donal's comment, you seem to want to override the <code>HostKeyAlgorithms</code> client's configuration variable on the command line (or by other means) when connecting as described <a href=""https://askubuntu.com/a/217066"">here</a>.  If you only specify ECDSA mechanisms, the connection will supposedly fail, if the server only will only offer you an RSA-, DSA- or FIPS-based key.</p>
","128","<ssh><tcl><expect><ecdsa>","0","0","1","2015-04-09 13:36:28","","1","","301832","","2015-04-08 22:09:03","2015-04-08 16:24:39",""
"50347455","OpenSSL DER ECDSA encoding error","<p>I am trying to encode ECDSA Curve448 key into a small and portable byte array. I am trying to use DER to accomplish this, as the low-level APIs do not work with Curve448. However, when I use the following code:</p>

<pre><code>std::vector&lt;std::vector&lt;uint8_t&gt;&gt; vecs;
uint8_t* buf = nullptr;

EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_ED448, NULL);
EVP_PKEY_keygen_init(pctx);
EVP_PKEY* pkey;
EVP_PKEY_keygen(pctx, &amp;pkey);
EVP_PKEY_CTX_free(pctx);

size_t n = i2d_PublicKey(pkey, &amp;buf);

ERR_print_errors_fp(stderr);

vecs.emplace_back(buf, buf + n);
</code></pre>

<p><code>n</code> is set to -1, and so <code>vecs.emplace_back</code> fails. ERR_print_errors_fp prints:</p>

<pre><code>140691149055104:error:0D0A40A7:asn1 encoding routines:i2d_PublicKey:unsupported public key type:../crypto/asn1/i2d_pu.c:35
</code></pre>

<p>How do I solve this problem, or is there a better way I should go about this?</p>

<p>I am using openssl v1.1.1 from debian experimental.</p>
","<p>Are you trying to write out a private key or a public key? I ask because your code above has <code>size_t n = i2d_PrivateKey(pkey, &amp;buf);</code>, i.e. attempting to encode a private key, but the error message says <code>i2d_PublicKey:unsupported public key type</code>.</p>

<p>Anyway <code>i2d_PublicKey</code> is for writing out public keys in old-style ""traditional"" format. Since ED448 is a new algorithm, there is no such format defined for it. Instead you must use SubjectPublicKeyInfo format. The OpenSSL function for that is the (confusingly similar) <code>i2d_PUBKEY()</code>. The man page is here:</p>

<p><a href=""https://www.openssl.org/docs/man1.1.1/man3/i2d_PUBKEY.html"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/man1.1.1/man3/i2d_PUBKEY.html</a></p>
","128","<c++><openssl><ecdsa><der>","0","1","1","2018-05-15 11:58:42","50348955","1","","2670194","","2018-05-15 11:58:42","2018-05-15 10:04:48",""
"50550697","SHA256withECDSA Signature not Verifying, Android","<p><strong>Update:</strong> The critical aspect is that <code>kp</code> (keypair) is generated ""outside"" this code. This code is an onclick function whereas <code>kp</code> is defined in the code that sets up the onclick. Shouldn't matter but that's what seems to be the problem and that's inexplicable.</p>

<p>What's wrong with the following code? It always prints (logs) false for the verification <code>b</code> even though the data is the same string <code>""foo""</code> and the signature is the same one that was generateded earlier in the code <code>sig</code></p>

<pre><code>val sig = Signature.getInstance(""SHA256withECDSA"").run {
    initSign(kp.private)
    update(""foo"".toByteArray())
    sign()
}
Log.d(tag, ""sig: "" + sig.toString())
val o = Signature.getInstance(""SHA256withECDSA"")
o.initVerify(kp.public)
o.update(""foo"".toByteArray())
val b = o.verify(sig)
Log.d(tag, b.toString())
</code></pre>
","","123","<java><android><kotlin><digital-signature><ecdsa>","0","","0","2018-05-27 17:54:08","","3","","2297550","","2018-05-27 17:54:08","2018-05-27 09:17:32",""
"51760361","ECDSA How to convert the private and public byte to single Shared key in c#","<p>I am trying to implement the ecdsa in C#. I am able to generate the key from
ECKeyPairGenerator but I need to do in reverse. I already have the keys need to make a single key.</p>

<p>Can anyone help me out in this? I write code in c#.</p>

<pre><code>public static AsymmetricCipherKeyPair LoadPublicKey(byte[] publickey)
        {
            string curveName = ""prime192v1"";
            //Here I m generating the key I need to replace but load the public key of byte
            var gen = new ECKeyPairGenerator();
            X9ECParameters ecP = X962NamedCurves.GetByOid(X9ObjectIdentifiers.Prime192v1);
            // var ecP21 = TeleTrusTNamedCurves.GetByName(""brainpoolp512t1"");
            //  X9ECParameters ecP = NistNamedCurves.GetByName(curveName);

            ECDomainParameters keyGenParam = new ECDomainParameters(ecP.Curve, ecP.G, ecP.N, ecP.H, ecP.GetSeed());
            var secureRandom = new SecureRandom();
            ECKeyGenerationParameters genParam = new ECKeyGenerationParameters(keyGenParam, secureRandom);
            gen.Init(genParam);
            return gen.GenerateKeyPair();//only want to return public key
        }
</code></pre>
","<p>You can try this</p>

<pre><code>    var keyParams = new ECParameters
    {
        Curve = jwk.Curve.ToECCurve(), #your curve name
        Q = new ECPoint #Define X and Y
        {
            X = jwk.X.FromBase64UrlSafe(),
            Y = jwk.Y.FromBase64UrlSafe()
        }
    };

ECDsa.Create(keyParams);
</code></pre>
","122","<c#><bouncycastle><ecdsa>","0","1","1","2019-02-25 08:41:13","","0","","6326344","","2018-08-09 06:44:10","2018-08-09 06:40:45",""
"52081185","ECDSA byte array into Private Key Error","<p>I want to save my private key in json file ( hex format ) then read it as PrivateKey.</p>

<p>Here Keys generate function</p>

<pre><code>public void generateKeyPair() {
    try {
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""ECDSA"", ""BC"");
        SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"");
        ECGenParameterSpec ecSpec = new ECGenParameterSpec(""secp256k1"");
        keyGen.initialize(ecSpec,random);
        KeyPair keyPair = keyGen.generateKeyPair();
        privateKey = keyPair.getPrivate();
        publicKey = keyPair.getPublic();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
</code></pre>

<p>This is how i save it into json file</p>

<pre><code>        a.generateKeyPair();
        byte[] enc_key = a.privateKey.getEncoded();

        StringBuilder key_builder = new StringBuilder();
        for(byte b : enc_key){
            key_builder.append(String.format( ""%02X"",b));
        }

        String serialized_key = key_builder.toString();
        account.privateKey=serialized_key;
        try (Writer writer = new FileWriter(""Output.json"")) {
            Gson gson = new GsonBuilder().create();
            gson.toJson(account, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
</code></pre>

<p>And read it from file</p>

<pre><code>        Gson gson = new GsonBuilder().create();
        try (Reader read1 = new FileReader(""Output.json"")) {
            account=gson.fromJson(read1,account.getClass());
            byte[] encoded_key=account.privateKey.getBytes();
            a.privateKey = getPrivateKey(encoded_key);

    public static PrivateKey getPrivateKey(byte[] privkey) throws NoSuchAlgorithmException, InvalidKeySpecException {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privkey);
    KeyFactory kf = null;
    try {
        kf = KeyFactory.getInstance(""ECDSA"", ""BC"");
    } catch (NoSuchProviderException e) {
        e.printStackTrace();
    }
    PrivateKey privateKey = kf.generatePrivate(privateKeySpec);
    return privateKey;
}
</code></pre>

<p>Function fail and i get error</p>

<pre><code>java.security.spec.InvalidKeySpecException: encoded key spec not recognized: failed to construct sequence from byte[]: unknown tag 19 encountered
</code></pre>
","<p>You are forgetting to hex decode the private key. Just performing <code>getBytes</code> won't do that.</p>

<p>The encoded byte starts with a SEQUENCE, tag <code>0x30</code>. This in hex will of course be <code>""30""</code> or, in ASCII: <code>0x33, 0x30</code>: these are the two first bytes returned by <code>getBytes</code>. Now the decoder looks at the first byte with bit value <code>0b001_10011</code>. The last 5 bits encode the tag value, which is 16 + 2 + 1 = 19. Hence the specific error.</p>
","122","<java><encryption><ecdsa>","0","0","1","2018-08-30 01:42:07","52088129","0","0","","","","2018-08-29 15:29:18",""
"47598339","U2F register signature verification fails","<p>With one of my U2F tokens, NIST P-256 ECDSA signature verification fails on the U2F_REGISTER response.</p>

<p>I'm working according to this protocol description: <a href=""https://fidoalliance.org/specs/fido-u2f-v1.0-nfc-bt-amendment-20150514/fido-u2f-raw-message-formats.html"" rel=""nofollow noreferrer"">https://fidoalliance.org/specs/fido-u2f-v1.0-nfc-bt-amendment-20150514/fido-u2f-raw-message-formats.html</a></p>

<pre><code>U2F_REGISTER request:
  b852c99d386769a3289d45708680efcc2350c0a7c152adb93c708b22a55c5d11: challenge
  8adb4559abbea4a68754314e64aa6785901b6a236db5a14d040916799865e290: application
U2F_REGISTER response:
  05: reserved byte
  user_public_key (NIST P-256):
    04: key format (uncompressed)
    db3ca8b3863f2fed19dada227aa8a51dba9bd0ecafcb5313225c04618c9329df: x
    e540eb5c58d24704e899eaa72feef06722ad4669c5a3d5537ab88dc6a712f96d: y
  keyhandle
    40: length (64 bytes)
    96e7d09341237e1c306a71ed9d59eeb16be621dbb34eb346ca999301ad0bee28f62876fced320734b4f139b89b8608bb4b4cef0f864064c2b3af1966167c4278
  attestation certificate in X.509 DER format
    30: sequence
    82: length (130 bytes) ??
      01433081ea...
  ECDSA signature in X.509 DER format
    30: sequence
    44: length (68 bytes)
      02: integer
      20: length (32 bytes)
        6d090eefac83a67f9361adcd391395ab3636470e1eb479dc94e1194dc1f25259: r
      02: integer
      20: length (32 bytes)
        660f7d23cd6b1c74e8499503fd21f6662a3270e916a57096037001baad5c7064: s
</code></pre>

<p>I compute the SHA-256 hash of <code>00 (1 byte) + application (32 bytes) + challenge (32 bytes) + keyhandle (64 bytes this time) + user_public_key (1 + 32 + 32 bytes)</code>.</p>

<p>Then I call <code>ecdsa.Verify(user_public_key, hash, r, s)</code>.</p>

<p>For one of the U2F tokens I have, ecdsa.Verify returns true (good), but for another one (see the bytes above), it returns false. What am I doing wrong in the example above?</p>
","<p>I was using the wrong public key for verifying the signature. I should have been using the public key within the attestation certificate (rather than the public key directly in the response). By doing so the signature verified correctly.</p>

<p>Here is a code example in Python which does the signature verification: <a href=""https://github.com/concise/lightu2f.py/blob/20540f75ee5f86a4b2ad4bffe34074760978cbf9/lightu2f.py#L100"" rel=""nofollow noreferrer"">https://github.com/concise/lightu2f.py/blob/20540f75ee5f86a4b2ad4bffe34074760978cbf9/lightu2f.py#L100</a> . It runs correctly on the data in the question.</p>
","120","<digital-signature><ecdsa><fido-u2f>","0","1","1","2017-12-02 00:59:58","47603504","0","","","","","2017-12-01 17:17:03",""
"54412567","How to verify ECDSA signature in ASN.1 format and public key in DER using BouncyCastle?","<p>I have a byte array that contains the public key, and a byte array that contains the ASN.1 formatted signature. Using ECDSA P-256.</p>

<p>The following code loads the public key:</p>

<pre><code>var publicKey = PublicKeyFactory.CreateKey(publicKeyDERBytes);
</code></pre>

<p>And the following code verifies the signature:</p>

<pre><code>var signer = SignerUtilities.GetSigner(""ECDSA"");

signer.Init(false, publicKey);
signer.BlockUpdate(signatureASN1Bytes, 0, signatureASN1Bytes.Length);
Console.WriteLine(signer.VerifySignature(signature));
</code></pre>

<p>But it always writes false. What could be wrong?</p>

<p>Using BouncyCastle.NetCore 1.8.3 on .NET Core.</p>
","<p>Turns out I was not getting the correct signer.</p>

<p>Instaead of:</p>

<pre><code>var signer = SignerUtilities.GetSigner(""ECDSA"");
</code></pre>

<p>It should be:</p>

<pre><code>var signer = SignerUtilities.GetSigner(""SHA256withECDSA"");
</code></pre>
","119","<c#><.net-core><bouncycastle><ecdsa>","0","0","1","2019-01-29 14:40:00","","0","","","","","2019-01-29 01:18:50",""
"55699933","ImportError: cannot import name 'SECP256kl' from 'ecdsa'","<p>I'm trying to use this code:</p>

<pre><code>from ecdsa import SigningKey, SECP256kl
</code></pre>

<p>But I got this error:</p>

<pre><code>ImportError: cannot import name 'SECP256kl' from 'ecdsa' (C:\Python\Python37\lib\site-packages\ecdsa\__init__.py)
</code></pre>
","<p>The correct name is <code>SECP256k1</code> (the number ""<strong>1</strong>"", not the letters ""<strong>l</strong>"" or ""<strong>I</strong>"").</p>

<pre><code>&gt;&gt;&gt; import ecdsa
&gt;&gt;&gt; dir(ecdsa)
[...,'SECP256k1',...]
</code></pre>

<p>You can also check it from the docs and codes in <a href=""https://github.com/warner/python-ecdsa"" rel=""nofollow noreferrer"">ecdsa github page</a>:</p>

<pre><code> # python-ecdsa/src/ecdsa/__init__.py
...
from .curves import NIST192p, NIST224p, NIST256p, NIST384p, NIST521p, SECP256k1
...
</code></pre>
","107","<python><ecdsa>","0","0","1","2019-04-16 06:48:45","","0","","2745495","","2019-04-16 05:39:17","2019-04-16 02:59:50",""
"57067241","C# bouncycastle AsymmetricCipherKeyPair to byte array ECDSA","<p>I generate key pair like this.</p>

<pre><code>ECKeyPairGenerator gen = new ECKeyPairGenerator(""ECDSA"");
SecureRandom secureRandom = new SecureRandom();
Org.BouncyCastle.Asn1.X9.X9ECParameters ecp = Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByName(""P-256"");
ECDomainParameters ecSpec = new ECDomainParameters(ecp.Curve, ecp.G, ecp.N, ecp.H, ecp.GetSeed());
ECKeyGenerationParameters ecgp = new ECKeyGenerationParameters(ecSpec, secureRandom);
gen.Init(ecgp);
AsymmetricCipherKeyPair eckp = gen.GenerateKeyPair();
</code></pre>

<p>and I want to convert AsymmetricCipherKeyPair to byte array.</p>

<p>so I add code.</p>

<pre><code>ECPublicKeyParameters ecPub = (ECPublicKeyParameters)eckp.Public;
ECPrivateKeyParameters ecPri = (ECPrivateKeyParameters)eckp.Private;
</code></pre>

<p>But I know there were two ways for convert AsymmetricCipherKeyPair to byte array.</p>

<p>first,</p>

<pre><code>byte[] pubs = ecPub.Q.GetEncoded();
</code></pre>

<p>Second,</p>

<pre><code>byte[] pubX = ecPub.Q.XCoord.ToBigInteger().ToByteArray();
byte[] pubY = ecPub.Q.YCoord.ToBigInteger().ToByteArray();
</code></pre>

<p>The results of both methods are slightly different.</p>

<p>first way, pubs[0] is always 0x04, and it make array length to 65 bytes.
like this</p>

<pre><code>04 F0 9E 70 EB ED 52 4B 56 E8 64 9C 9A D9 1C 97 6F F1 92 86 BA 87 FC F5 AB E4 CC 72 C6 EA 77 FA 0D 30 4C 39 0F 38 BE E3 C7 3E 8B 4D 2F 05 C3 55 3F 78 DB 8E DD 77 DF 24 D4 3B 56 88 33 D7 CB 0B 9E 
</code></pre>

<p>seconde way, pubX[0] is sometimes 0x00, and it make array length to 65 bytes.</p>

<p>like this</p>

<pre><code>pubX = 00 F0 9E 70 EB ED 52 4B 56 E8 64 9C 9A D9 1C 97 6F F1 92 86 BA 87 FC F5 AB E4 CC 72 C6 EA 77 FA 0D
pubY = 30 4C 39 0F 38 BE E3 C7 3E 8B 4D 2F 05 C3 55 3F 78 DB 8E DD 77 DF 24 D4 3B 56 88 33 D7 CB 0B 9E
</code></pre>

<p>Except for the value of index 0, the rest are the same.</p>

<p>Why does this difference occur?</p>

<p>What value do I actually use?</p>

<p>p.s.</p>

<p>I convert private key like this</p>

<pre><code>byte[] pri = ecPri.D.ToByteArray();
</code></pre>

<p>Is this the right way?</p>

<p>And private key also has 0x00 on index 0. Why?</p>
","","105","<c#><bouncycastle><ecdsa>","0","","0","2019-07-17 14:17:04","","2","1","238704","","2019-07-17 14:17:04","2019-07-17 01:09:42",""
"56685916","How to put this in python so it can loop random with the mask?","<p>How would I put this in python so it can loop generate random with mask leading zeros?   </p>

<pre><code>std::string min = ""000000000000000000000000000000000000000000000000000000000000000F"";
std::string max = ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140"";
std::string get_random_ecdsa_key() {
   while (true) { 
     std::string s = get_random_hex(64);
     if (s &gt;= min &amp;&amp; s &lt; max) {
        return s;
    }
  }
}        



import random

while True: 

   x = random.randint(0xF,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140)
   print hex (x) [2:66].lower()
</code></pre>
","<p>The code you've shared is pretty trivial to convert into Python. The logic structure is the same, you just have to port the syntax. The only challenge is implementing <code>get_random_hex</code>. I don't know what it actually does since you didn't include that part in your question, but I assume it randomly generates a string that is a certain length and contains hex digits.</p>

<pre><code>import random

def get_random_hex(n):
    chars = ""0123456789ABCDEF""
    return """".join(random.choice(chars) for _ in range(n))

def get_random_ecdsa_key():
    min = ""000000000000000000000000000000000000000000000000000000000000000F""
    max = ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140""
    while True:
        s = get_random_hex(64)
        if min &lt;= s &lt; max:
            return s

print(get_random_ecdsa_key())
</code></pre>
","100","<python><hex><ecdsa>","0","1","2","2019-07-15 17:42:58","","0","","11673327","","2019-07-15 17:42:58","2019-06-20 12:22:39",""
"56685916","How to put this in python so it can loop random with the mask?","<p>How would I put this in python so it can loop generate random with mask leading zeros?   </p>

<pre><code>std::string min = ""000000000000000000000000000000000000000000000000000000000000000F"";
std::string max = ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140"";
std::string get_random_ecdsa_key() {
   while (true) { 
     std::string s = get_random_hex(64);
     if (s &gt;= min &amp;&amp; s &lt; max) {
        return s;
    }
  }
}        



import random

while True: 

   x = random.randint(0xF,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140)
   print hex (x) [2:66].lower()
</code></pre>
","<pre><code>import random
min_bound = 0x000000000000000000000000000000000000000000000000000000000000000F
max_bound = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140

def get_random_ecdsa_key():
    r = random.randint(min_bound,max_bound)
    return ""{:X}"".format(r)
</code></pre>

<p>Here you go! The interesting parts are </p>

<ul>
<li><code>random.randint(min, max)</code> - returns an integer between min and max</li>
<li><code>return ""{:X}"".format(r)</code> - just converts r from an integer to a hex string. The format string is equivalent to something like  <code>printf(""%X"", r)</code> in C++</li>
</ul>
","100","<python><hex><ecdsa>","0","0","2","2019-07-15 17:42:58","","0","","11673327","","2019-07-15 17:42:58","2019-06-20 12:22:39",""
"53451378","Need help reading/writing ECDSA Keys in GoLang","<p>Currently, I have:</p>

<pre><code>// generate keys
priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
// get public key
pub := priv.Public()
</code></pre>

<p>I, however, need help on getting the raw byte data and using the correct encoding to read/write these public and private keys to files.</p>
","<p>Just marshal them to a <code>[]byte</code> using <code>x509.MarshalECPrivateKey</code>.  You can just read and write the binary to a file.</p>

<p>You might find in future you want to store the keys in PEM format, as is common.  You can do that with the <code>encoding/pem</code> package.</p>
","99","<go><encryption><ecdsa>","1","1","1","2018-11-23 19:45:49","","2","","","","","2018-11-23 18:18:10",""
"50234953","Own random (not the private key) in the ECDSA","<p>I'm trying to debug my own implementation of the ECDSA signature. To compare the intermediate results I would like to force the OpenSSL, Crypto++ or whatever else package to use a known ""random"" number instead of generating it each time the signature is created. Is there a way to do so? </p>

<p>Since I'm working with the brainpool curves I can't use the microsoft crypto API. This doesn't support the brainpool curves in the Crypto API until Windows 10.</p>

<p>Another way could to be retrieve the random used after the ECDSA signature creation from one of the popular packages.</p>

<p>I appreciate any help</p>
","<p>Yes, this is possible with OpenSSL. OpenSSL provides the ability to override the default source of random numbers. To do this use the <code>RAND_set_rand_method()</code> function documented here:</p>

<p><a href=""https://www.openssl.org/docs/man1.1.0/crypto/RAND_set_rand_method.html"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/man1.1.0/crypto/RAND_set_rand_method.html</a></p>

<p>This function takes as an argument a <code>RAND_METHOD</code> structure which contains function pointers to the implementations of the OpenSSL random capabilities. Replace the <code>bytes</code> element with your own implementation.</p>

<p>For example</p>

<pre><code>RAND_METHOD myrand, *oldrand;

oldrand = RAND_get_rand_method();
myrand = *oldrand;
myrand.bytes = mybytes;
RAND_set_rand_method(myrand);
</code></pre>

<p>Where <code>mybytes</code> is defined like this:</p>

<pre><code>static int mybytes(unsigned char *buf, int num)
{
    /* Replace with however you want the random function to work */
    memset(buf, 0, num);
    return 1;
}
</code></pre>

<p>OpenSSL's own ecdsatest code does exactly this. For example see:</p>

<p><a href=""https://github.com/openssl/openssl/blob/OpenSSL_1_1_0-stable/test/ecdsatest.c#L65"" rel=""nofollow noreferrer"">https://github.com/openssl/openssl/blob/OpenSSL_1_1_0-stable/test/ecdsatest.c#L65</a></p>
","96","<openssl><bouncycastle><elliptic-curve><ecdsa>","-1","3","1","2018-05-09 06:41:25","50235200","5","","608639","","2018-05-09 01:08:49","2018-05-08 13:35:52",""
"45616506","What object same as Signature (java.security.signature) on Python?","<p>I want to verify ECDSA signature generate on android by using python.</p>

<p>But I can't found object or any thing same as Signature object in Python.</p>

<p>Here is my verify code if using Java</p>

<pre><code>String origin = txtOrigin.getText().toString();
try {
    sig = Signature.getInstance(""NONEwithECDSA"",""SC"");
    sig.initVerify(publicKey);
    byte[] stringInput = origin.getBytes(""UTF-8"");
    sig.update(stringInput);
    txtVerify.setText(sig.verify(signatureBytes)+"""");
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre>
","","95","<java><python><python-2.7><m2crypto><ecdsa>","0","","0","2018-04-21 21:44:12","","2","","1602555","user8332899","2018-04-21 21:44:12","2017-08-10 14:27:44",""
"56206075","How to validate a certificate chain of certificates using SHA256 ECDSA algorithm using JDK 11","<p>I am trying to validate a certificate chain of certificates based on <code>SHA256withECDSA</code> algorithm.
I am using Java JDK 11.</p>

<p>When running the <code>CertPathValidator.getInstance(""PKIX"").validate</code> method, I get a crash <code>Unrecognized algorithm for signature parameters SHA256withECDSA</code>.</p>

<p>The root cause seems to be the following:</p>

<pre><code>// null
providerSunEC.getService(""AlgorithmParameters"", ""SHA256withECDSA"");
</code></pre>

<p>There is no such signature parameters, though: the <code>X509CertImpl</code> instance contains an <code>AlgorithmId</code> with <code>algid</code> <code>1.2.840.10045.4.3.2</code> and params <code>OID.1.2.840.10045.3.1.7</code> (DER Encoded, it should be <code>prime256v1</code>), which should be the default and only supported one.</p>

<p>My feeling, which may be highly wrong, is that the redundant <code>prime256v1</code> could and should be omitted but I do not know how to implement it, as it is inside the Java code.</p>

<p>This is the stacktrace:</p>

<pre><code>Caused by: java.security.cert.CertPathValidatorException: signature check failed
    at java.base/sun.security.provider.certpath.PKIXMasterCertPathValidator.validate(PKIXMasterCertPathValidator.java:135)
    at java.base/sun.security.provider.certpath.PKIXCertPathValidator.validate(PKIXCertPathValidator.java:233)
    at java.base/sun.security.provider.certpath.PKIXCertPathValidator.validate(PKIXCertPathValidator.java:141)
    at java.base/sun.security.provider.certpath.PKIXCertPathValidator.engineValidate(PKIXCertPathValidator.java:80)
    at java.base/java.security.cert.CertPathValidator.validate(CertPathValidator.java:309)
    at net.corda.core.internal.InternalUtils.validate(InternalUtils.kt:469)
    ... 64 more
Caused by: java.security.cert.CertificateException: Unrecognized algorithm for signature parameters SHA256withECDSA
    at java.base/sun.security.x509.X509CertImpl.verify(X509CertImpl.java:445)
    at java.base/sun.security.provider.certpath.BasicChecker.verifySignature(BasicChecker.java:166)
    at java.base/sun.security.provider.certpath.BasicChecker.check(BasicChecker.java:147)
    at java.base/sun.security.provider.certpath.PKIXMasterCertPathValidator.validate(PKIXMasterCertPathValidator.java:125)
    ... 69 more
</code></pre>

<p>This is the certificate chain:</p>

<pre><code>-----BEGIN CERTIFICATE-----
MIICDjCCAaugAwIBAgIIL8JlejRD9+AwFAYIKoZIzj0EAwIGCCqGSM49AwEHMDcx
CzAJBgNVBAYTAkNIMQ8wDQYDVQQHDAZadXJpY2gxFzAVBgNVBAoMDk5vdGFyeSBT
ZXJ2aWNlMB4XDTE5MDUxODAwMDAwMFoXDTI3MDUyMDAwMDAwMFowNzELMAkGA1UE
BhMCQ0gxDzANBgNVBAcMBlp1cmljaDEXMBUGA1UECgwOTm90YXJ5IFNlcnZpY2Uw
WTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATQ5/8MzkZLIrlCmJwW36VFYN8qs/Qh
O4VVdsU54u/NvXr4ZHdvuhUshPusxger2tmTQ1G74JeHasiYuXRK7w5+o4GWMIGT
MB0GA1UdDgQWBBQU0zTXsjkN2A97z/YWgIat6XynDDAMBgNVHRMBAf8EAjAAMAsG
A1UdDwQEAwIDqDAjBgNVHSUEHDAaBggrBgEFBQcDAQYIKwYBBQUHAwIGBFUdJQAw
HwYDVR0jBBgwFoAU93fYF/b7cP07vc/w+joyfiG/AR0wEQYKKwYBBAGDimIBAQQD
AgEFMBQGCCqGSM49BAMCBggqhkjOPQMBBwNHADBEAiBwb2uZZjD8qAoxHOxpbajB
RQ6LCIjkbUN2f8my0X00lAIge/qClByuVWeAkibOLM0rxs9tdpU8JMBKlFCQltXj
iBM=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICjTCCAimgAwIBAgIIfN0wQLUbHR8wFAYIKoZIzj0EAwIGCCqGSM49AwEHMGMx
CzAJBgNVBAYTAlVTMREwDwYDVQQHEwhOZXcgWW9yazEOMAwGA1UECxMFQ29yZGEx
FjAUBgNVBAoTDVIzIEhvbGRDbyBMTEMxGTAXBgNVBAMTEENvcmRhIERvb3JtYW4g
Q0EwHhcNMTkwNTE4MDAwMDAwWhcNMjcwNTIwMDAwMDAwWjA3MQswCQYDVQQGEwJD
SDEPMA0GA1UEBwwGWnVyaWNoMRcwFQYDVQQKDA5Ob3RhcnkgU2VydmljZTBZMBMG
ByqGSM49AgEGCCqGSM49AwEHA0IABNrSB6SrX1F//yNl58QWH14ittAcPs0KIcGg
2KFzF6Y1aHzHdZPvE9M1ErJW3A/ElrfXBtYeVqUch9155ZvL0gyjgegwgeUwHQYD
VR0OBBYEFPd32Bf2+3D9O73P8Po6Mn4hvwEdMA8GA1UdEwEB/wQFMAMBAf8wCwYD
VR0PBAQDAgGGMCMGA1UdJQQcMBoGCCsGAQUFBwMBBggrBgEFBQcDAgYEVR0lADAf
BgNVHSMEGDAWgBTr7i4wFSlArhmYHthv431/B6LCEzARBgorBgEEAYOKYgEBBAMC
AQQwTQYDVR0eAQH/BEMwQaA9MDukOTA3MQswCQYDVQQGEwJDSDEPMA0GA1UEBwwG
WnVyaWNoMRcwFQYDVQQKDA5Ob3RhcnkgU2VydmljZaEAMBQGCCqGSM49BAMCBggq
hkjOPQMBBwNIADBFAiEA7RJ9ofluL3ainww+zUbKBpAMgbdjE/54EkCy2wZJVRQC
IBq7Hb1jUa5VlpMWiB1LjkzUX7Zyovv3i14d+iRkjIIW
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICXjCCAfugAwIBAgIIHVb6wd3RHhIwFAYIKoZIzj0EAwIGCCqGSM49AwEHMFgx
GzAZBgNVBAMMEkNvcmRhIE5vZGUgUm9vdCBDQTELMAkGA1UECgwCUjMxDjAMBgNV
BAsMBWNvcmRhMQ8wDQYDVQQHDAZMb25kb24xCzAJBgNVBAYTAlVLMB4XDTE4MDcx
MDAwMDAwMFoXDTI3MDUyMDAwMDAwMFowYzELMAkGA1UEBhMCVVMxETAPBgNVBAcT
CE5ldyBZb3JrMQ4wDAYDVQQLEwVDb3JkYTEWMBQGA1UEChMNUjMgSG9sZENvIExM
QzEZMBcGA1UEAxMQQ29yZGEgRG9vcm1hbiBDQTBZMBMGByqGSM49AgEGCCqGSM49
AwEHA0IABAPL3qAm4WZms5ciBVoxMQXfK7uTmHRVvWfWQ+QVYP3bMHSguHZRzB3v
7EOE8RZpGDan+w007Xj7XR0+xG9SxmCjgZkwgZYwHQYDVR0OBBYEFOvuLjAVKUCu
GZge2G/jfX8HosITMA8GA1UdEwEB/wQFMAMBAf8wCwYDVR0PBAQDAgGGMCMGA1Ud
JQQcMBoGCCsGAQUFBwMBBggrBgEFBQcDAgYEVR0lADAfBgNVHSMEGDAWgBR8rqnf
uUgBKxOJC5rmRYUcORcHczARBgorBgEEAYOKYgEBBAMCAQEwFAYIKoZIzj0EAwIG
CCqGSM49AwEHA0cAMEQCIBmzQXpnCo9eAxkhwMt0bBr1Q0APJXF0KuBRsFBWAa6S
AiBgx6G8G9Ij7B8+y65ItLKVcs7Kh6Rdnr5/1zB/yPwfrg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICCTCCAbCgAwIBAgIIcFe0qctqSucwCgYIKoZIzj0EAwIwWDEbMBkGA1UEAwwS
Q29yZGEgTm9kZSBSb290IENBMQswCQYDVQQKDAJSMzEOMAwGA1UECwwFY29yZGEx
DzANBgNVBAcMBkxvbmRvbjELMAkGA1UEBhMCVUswHhcNMTcwNTIyMDAwMDAwWhcN
MjcwNTIwMDAwMDAwWjBYMRswGQYDVQQDDBJDb3JkYSBOb2RlIFJvb3QgQ0ExCzAJ
BgNVBAoMAlIzMQ4wDAYDVQQLDAVjb3JkYTEPMA0GA1UEBwwGTG9uZG9uMQswCQYD
VQQGEwJVSzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGlm6LFHrVkzfuUHin36
Jrm1aUMarX/NUZXw8n8gSiJmsZPlUEplJ+f/lzZMky5EZPTtCciG34pnOP0eiMd/
JTCjZDBiMB0GA1UdDgQWBBR8rqnfuUgBKxOJC5rmRYUcORcHczALBgNVHQ8EBAMC
AYYwIwYDVR0lBBwwGgYIKwYBBQUHAwEGCCsGAQUFBwMCBgRVHSUAMA8GA1UdEwEB
/wQFMAMBAf8wCgYIKoZIzj0EAwIDRwAwRAIgDaL4SguKsNeTT7SeUkFdoCBACeG8
GqO4M1KlfimphQwCICiq00hDanT5W8bTLqE7GIGuplf/O8AABlpWrUg6uiUB
-----END CERTIFICATE-----
</code></pre>
","","93","<java><ssl><java-11><ecdsa><pkix>","1","","0","2019-05-19 08:43:02","","2","","3127812","","2019-05-19 08:43:02","2019-05-19 08:34:06",""
"55976645","ECDSA Signature Verification Failed on Javascript(Elliptic)","<p>I have an issue with verification of a ECDSA Signature made on javacard. I am trying to verify the signature in Javascript(Elliptic) but the verification always fails.</p>

<p>My applet(<em>javacard</em>) looks like:</p>

<pre><code>//initialization
ecdsa = Signature.getInstance(Signature.ALG_ECDSA_SHA_256, false);
eccKey=SecP256k1.newKeyPair(); //in SecP256k1 the p,a,b,g,r,k are set
eccKey.genKeyPair();

//singing method
ecdsa.init(eccKey.getPrivate(), Signature.MODE_SIGN);

//Generates the signature of all input data.
short lenTmp = ecdsa.sign(buffer, ISO7816.OFFSET_CDATA, (short)1, buffer, 
(short)0);
//I tried also to sigh precomputed hash - same result
/*short lenTmp = ecdsa.signPreComputedHash(buffer, ISO7816.OFFSET_CDATA, 
len, buffer, (short)0); */

apdu.setOutgoingAndSend((short)0, lenTmp);
</code></pre>

<p>I get a private key 
<code>(e.g. : 3E05E289911E66A8153EE9C15A0AFC109C49207DB9DC4656CC4D092323EA65BC)</code></p>

<p>When I sign a message <code>(e.g : 0x01)</code></p>

<p>I get the signature in DER format:
<code>304402205F376BB2B2D48BBB0275099C3B9591F18ECA424DD953EB27FDE37BA819B98F980220539A85B91491E977F6B31B5A76BEF6805BBC3B6481A51C23B9E7C6F39FB70569</code></p>

<p>Also its verification is successful on javacard..
But when I try to verify it on nodejs, it always fails.
My code looks like:</p>

<pre><code>let elliptic = require('elliptic');
let ec = new elliptic.ec('secp256k1');
let keyPair = ec.keyFromPrivate(""3E05E289911E66A8153EE9C15A0AFC109C49207DB9DC4656CC4D092323EA65BC"");
let privKey = keyPair.getPrivate(""hex"");
let pubKey = keyPair.getPublic();
let signature = ""304402205F376BB2B2D48BBB0275099C3B9591F18ECA424DD953EB27FDE37BA819B98F980220539A85B91491E977F6B31B5A76BEF6805BBC3B6481A51C23B9E7C6F39FB70569"";
let msg = 0x01;
let validSig = ec.verify(msg, signature, pubKey);
console.log(""Signature valid?"", validSig);//returns always false
</code></pre>

<p>Also, if I sign the same message with the same key on nodejs, the verification is successful.</p>

<p>Moreover, I noticed that the signature is always different in javacard, while the signature on elliptic is always the same, maybe it always chosses the same random k.</p>
","<p>This is most likely caused due to the fact that standard ecdsa libraries in java/go/python/etc. generate the signature der encoded where as the javascript library simply concatenates the R and S values of the signature. Here is how I deal with this issue in my own library <a href=""https://github.com/syncaide/flats/blob/master/src/message_test.go#L132"" rel=""nofollow noreferrer"">HERE</a>. Sorry the example is golang to typescript, but hopefully you can reverse engineer this to java/javascript. Event within Node.js this issue exists. Here is a <a href=""https://stackoverflow.com/questions/39554165/ecdsa-signatures-between-node-js-and-webcrypto-appear-to-be-incompatible"">LINK</a> to a discussion that ultimately helped me figure out how to breach the gap between the implementations within my own work.</p>
","93","<javascript><signature><javacard><ecdsa>","1","1","1","2019-05-03 23:20:51","","2","","5953575","","2019-05-03 23:20:51","2019-05-03 20:24:35","2019-05-07 08:58:44"
"54274765","Load public key with openssl - invalid encoding","<p>I start using openssl.
I want to use a public key to check a signature. But for now, I can not read my public key with openssl.</p>

<p>Here is my source code:</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;openssl/ec.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/err.h&gt;

bool verifyPublicKey(const std::string &amp;sRawPublicKey);
void printAllError();


int main(int argc, char* argv[])
{
    if (argc &lt; 2) {
        std::cerr &lt;&lt; ""Usage: "" &lt;&lt; argv[0] &lt;&lt; "" PUBLIC KEY"" &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }

    std::string sPublicKey = argv[1];

    std::cout &lt;&lt; ""Key: "" &lt;&lt; sPublicKey &lt;&lt; std::endl;

    bool bRes = verifyPublicKey(sPublicKey);

    if (!bRes)
    {
        std::cerr &lt;&lt; ""verifyPublicKey failled"" &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

bool verifyPublicKey(const std::string &amp;sRawPublicKey)
{
    bool bRes = false;

    EC_KEY *eckey = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
    EC_KEY_set_conv_form(eckey, POINT_CONVERSION_UNCOMPRESSED);

    unsigned char *p_RawPublicKey = new unsigned char[sRawPublicKey.length() + 1];
    std::copy(sRawPublicKey.begin(), sRawPublicKey.end(), p_RawPublicKey);
    const unsigned char *pubkey_raw_p = p_RawPublicKey;

    o2i_ECPublicKey(&amp;eckey, &amp;pubkey_raw_p, sRawPublicKey.size());

    if (!EC_KEY_check_key(eckey))
    {
        EC_KEY_free(eckey);
        bRes = false;
        printAllError();
    }
    else
    {
        EC_KEY_free(eckey);
        bRes = true;
    }

    return bRes;
}

void printAllError()
{
    while (ERR_peek_last_error() != 0)
    {
        std::cerr &lt;&lt; ERR_error_string(ERR_get_error(), nullptr) &lt;&lt; std::endl;
    }
}
</code></pre>

<p>I run it with the following public key:</p>

<blockquote>
  <p>3059301306072A8648CE3D020106082A8648CE3D03010703420004E297417036EB4C6404CC9C2AC4F28468DD0A92F2C9496D187D2BCA784DB49AB540B9FD9ACE0BA49C8532825954755EC10246A71AF2AEE9AEC34BE683CDDFD212</p>
</blockquote>

<p>ASN.1 Decoder:</p>

<pre><code>SEQUENCE {    
    SEQUENCE {
        OBJECTIDENTIFIER 1.2.840.10045.2.1 (ecPublicKey)
        OBJECTIDENTIFIER 1.2.840.10045.3.1.7 (P-256)    
    }
    BITSTRING 0x04E297417036EB4C6404CC9C2AC4F28468DD0A92F2C9496D187D2BCA784DB49AB540B9FD9ACE0BA49C8532825954755EC10246A71AF2AEE9AEC34BE683CDDFD212
    : 0 unused bit(s) 
}
</code></pre>

<p>With the ASN.1, I notice that the key I use is in the correct format: <strong>0x04 || HEX(x) || HEX(y)</strong> with z = 0x04.</p>

<p>The output of the program is as follows:</p>

<blockquote>
  <p>Key: 3059301306072A8648CE3D020106082A8648CE3D03010703420004E297417036EB4C6404CC9C2AC4F28468DD0A92F2C9496D187D2BCA784DB49AB540B9FD9ACE0BA49C8532825954755EC10246A71AF2AEE9AEC34BE683CDDFD212</p>
  
  <p>error:10067066:elliptic curve routines:ec_GFp_simple_oct2point:invalid encoding</p>
  
  <p>error:10098010:elliptic curve routines:o2i_ECPublicKey:EC lib</p>
  
  <p>error:1010206A:elliptic curve routines:ec_key_simple_check_key:point at infinity verifyPublicKey failed</p>
</blockquote>

<p>I'm lost. Do you have explanations? 
Moreover, is it possible to go further by giving only x and y (without ASN.1 header).</p>

<p>Thank you</p>
","<p>Looks like you should feed the raw point to function <code>o2i_ECPublicKey()</code>, without the ASN.1 framing.</p>
","91","<c++11><openssl><public-key><ecdsa>","1","0","1","2019-01-20 11:01:38","54275800","0","","","","","2019-01-20 08:29:41",""
"44812974","Create authorized keys from ECDSA public key","<p>I'm using Bouncy Castle API and I have ECPublicKey object but I'm not sure exactly how to construct a OpenSSH authorized key from there. I don't know what the format looks like. I'm thinking my solution would be similar to how it's done for RSA and DSA.. <a href=""https://stackoverflow.com/a/5402769/8227972"">Decoding RSA/DSA Public Key</a></p>

<p>Does anyone have any suggestions?</p>
","<p>The format of ECDSA keys is described in the <a href=""https://tools.ietf.org/html/rfc5656#section-3.1"" rel=""nofollow noreferrer"">RFC5656</a>:</p>

<p>In short:</p>

<blockquote>
  <p>The ""ecdsa-sha2-*"" key formats all have the following encoding:</p>

<pre><code>string   ""ecdsa-sha2-[identifier]""
byte[n]  ecc_key_blob
</code></pre>
  
  <p>The ecc_key_blob value has the following specific encoding:</p>

<pre><code>string   [identifier]
string   Q
</code></pre>
</blockquote>
","90","<bouncycastle><public-key-encryption><openssh><ecdsa>","0","0","1","2017-06-29 07:06:29","","0","","","","","2017-06-28 21:39:54",""
"56366726","AWS cloudHSM ECDSA-SHA256 signature output to DER","<p>I am attempting to use an AWS cloudHSM to sign a message that needs to be converted to DER to be verified by another application. The output signature file from AWS is binary and I am struggling to convert to DER.</p>

<p>I can verify the signature is correct in OpenSSL as it will accept the signature as binary</p>

<pre><code>$ openssl dgst -sha256 -verify public.pem -signature signedMessage message
Verified OK
</code></pre>

<p>Struggling to find the correct procedure to convert to DER. I tried</p>

<pre><code>openssl enc -base64 -in signedMessage
</code></pre>

<p>But verification fails.</p>

<p>Thanks</p>
","","89","<openssl><asn.1><ecdsa><der>","0","","0","2019-05-30 03:01:11","","6","","481815","","2019-05-30 03:01:11","2019-05-29 18:38:36",""
"58076132","Encryption in swift using Diffie Hellman key exchange and an elliptic curve encryption","<p>I've been trying to encrypt and decrypt a string in swift using a Diffie Hellman key exchange and an elliptic curve encryption. </p>

<p>Following is the code that I followed.</p>

<p>SWIFT Code :</p>

<pre><code> let attributes: [String: Any] = [kSecAttrKeySizeInBits as String: 256,
                                     kSecAttrKeyType as String: kSecAttrKeyTypeEC,
                                     kSecPrivateKeyAttrs as String: [kSecAttrIsPermanent as String: false]]
 var error: Unmanaged&lt;CFError&gt;?
 if #available(iOS 10.0, *) {
 **// Step 1:  Generating the Public &amp; Private Key**
        guard let privateKey1 = SecKeyCreateRandomKey(attributes as CFDictionary, &amp;error) else {return false}

        let publicKey1 = SecKeyCopyPublicKey(privateKey1)
        guard let privateKey2 = SecKeyCreateRandomKey(attributes as CFDictionary, &amp;error) else {return false}

        let publicKey2 = SecKeyCopyPublicKey(privateKey2)

        let dict: [String: Any] = [:]
 **// Step 2:  Generating Shared Key**   
        guard let shared1 = SecKeyCopyKeyExchangeResult(privateKey1, SecKeyAlgorithm.ecdhKeyExchangeStandardX963SHA256, publicKey2!, dict as CFDictionary, &amp;error) else {return false}

**// Step 3:  Encrypt string using Sharedkey**
        let options: [String: Any] = [kSecAttrKeyType as String: kSecAttrKeyTypeEC,
                                      kSecAttrKeyClass as String: kSecAttrKeyClassPrivate,
                                      kSecAttrKeySizeInBits as String : 256]
        // Stuck from this line on
        guard let key = SecKeyCreateWithData(shared1 ,
                                             options as CFDictionary,
                                             &amp;error) else {return false}
        print(key)


        let str = ""Hello""
        let byteStr: [UInt8] = Array(str.utf8)
        let cfData = CFDataCreate(nil, byteStr, byteStr.count)


        guard let encrypted = SecKeyCreateEncryptedData(publicKey1!,
                                                        SecKeyAlgorithm.ecdsaSignatureDigestX962SHA256,
                                                        cfData!,
                                                        &amp;error) else {return false}
        print(encrypted)

    } else {
        print(""unsupported"")
    }
</code></pre>

<p>JAVA Code :</p>

<pre><code>public static Map&lt;String, Object&gt; ecEncrypt(String deviceData, String serverPubKey, String dsTranID)
throws DataEncryptionException {
provider = new BouncyCastleProvider();
HashMap&lt;String, Object&gt; result = null;
JWEObject jweObject = null;
JWK jwk = null;
SecretKey Z = null;
JWEHeader header = null;
ECPublicKey ecpubkey = null;
byte[] byte_pubkey = null;

try {

result = new HashMap&lt;String, Object&gt;();
/*
 * Generate Ephemeral keypair for SDk which constitute Public and
 * Private key of SDK
 */
STEP 1:
sdkKeyPair = Crypto.generateEphemeralKeyPair();

/*
 * Compute Secrete Key Z from SDKs Private Key(pSDK),DS Public
 * key(serverPubKey) and DS ID
 */
//converting string to Bytes
STEP 2:
byte_pubkey = Base64.decode(serverPubKey, android.util.Base64.DEFAULT);

//converting it back to EC public key
STEP 3:
KeyFactory factory = KeyFactory.getInstance(""ECDSA"", provider);
ecpubkey = (ECPublicKey) factory.generatePublic(new X509EncodedKeySpec(byte_pubkey));
System.out.println(""FINAL OUTPUT"" + ecpubkey);

STEP 4:
Z = Crypto.generateECDHSecret(ecpubkey,
(ECPrivateKey) sdkKeyPair.getPrivate(), dsTranID,
""A128CBC_HS256"");

System.out.println(""****Secrete key Z for SDK Computed succesfully *****"");
/*
 * Build JWK to construct header
 */
STEP 5:
jwk = new ECKey.Builder(Curve.P_256,
(ECPublicKey) sdkKeyPair.getPublic()).build();

STEP 6:
header = new JWEHeader.Builder(JWEAlgorithm.ECDH_ES,
EncryptionMethod.A128CBC_HS256).ephemeralPublicKey(
ECKey.parse(jwk.toJSONString())).build();

System.out.println(""****Header for SDK Computed  succesfully*****"");

/*
 * Add Header and payload before encrypting payload using secret key
 * Z
 */

STEP 7:
jweObject = new JWEObject(header, new Payload(deviceData));
jweObject.encrypt(new DirectEncrypter(Z));
/*
 * serialize JWEobject which contains
 * [header-base64url].[encryptedKey
 * -base64url].[iv-base64url].[cipherText
 * -base64url].[authTag-base64url]
 */
System.out
.println(""****Payload of SDK encrypted succesfully *****"");

return result;
} catch (Exception e) {
e.printStackTrace();
throw new DataEncryptionException();
} finally {
sdkKeyPair = null;
jweObject = null;
jwk = null;
Z = null;
header = null;
}
}
</code></pre>

<p>I included Java code as well. I have to do the same in Swift. How to do EC Encryption using the Shared key(Shared1) to encrypt the string? I need to do Step 3. Anyone please help on this?</p>
","<p>First of all, you're trying to implement ECIES. Knowing the actual name is important if you want to look up information about the scheme.</p>

<p>So lets assume that key pair 1 is from the sender of the ciphertext and key pair 2 is then from the receiver of the ciphertext. In that case key pair 1 should be ephemeral (created on the spot, tied to one encrypted message) and key pair 2 is static (created beforehand and kept). Furthermore, public key 2 is trusted to be from the receiving party. This is all not clear from your simplified code, and in your code you could still switch around the sender and receiver.</p>

<p>So with the public key (2) of the receiver the sender can use their private key to create a shared secret, called <code>shared1</code> in your code. You can now use <code>shared1</code> to perform symmetric encryption of the data. Then you just have to send the ephemeral public key of the sender and the ciphertext to the receiver. The receiver uses the public key of the sender (1) and their static private key (2) to create <code>shared2</code>. This is identical to <code>shared1</code> and can thus be used as a key to decrypt the data.</p>

<p>So that's it, other than to note that since the private key (1) of the sender is tied to the data, it isn't needed anymore once <code>shared1</code> is calculated, and may be discarded even before the message is encrypted.</p>

<hr>

<p>If you read above then you can see that having all of this in one method is not a good idea:</p>

<ol>
<li>create the static key pair of the receiver;</li>
<li>send the public key of the receiver to the sender and make sure that the sender can trust the public key to be from the receiver (e.g. using certificate infrastructure);</li>
</ol>

<p>Now for the encryption and sending:</p>

<ol start=""3"">
<li>create the key pair of the sender;</li>
<li>derive the symmetric key;</li>
<li>throw away the private key;</li>
<li>encrypt the data;</li>
<li>send the public key and the data;</li>
</ol>

<p>and for the receiving:</p>

<ol start=""8"">
<li>use the private key to derive the symmetric key;</li>
<li>decrypt the data.</li>
</ol>

<p>And that's it. You probably want to have these steps made <em>explicit</em> in your code.</p>
","89","<ios><swift><encryption><ecdsa><ecdh>","1","1","1","2019-11-03 20:21:44","58089797","0","","13302","","2019-11-03 20:21:44","2019-09-24 08:30:51",""
"27144097","Which elliptic curves does jarsigner support?","<p>I will be signing JARs with an ECDSA key, and I can choose now which elliptic curve I will use. I at least need to be able to generate the signature with <code>jarsigner</code>. Where can I see, what elliptic curves <code>jarsigner</code> supports?</p>

<p>I tested that out of 65 elliptic curves supported by my OpenSSL installation, my jarsigner supports 46. <a href=""https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html"" rel=""nofollow"">Oracle documentation on jarsigner</a> does not say anything about what is supported. Is it documented anywhere at all?</p>
","<p>Here is an answer: ""<a href=""http://securitypad.blogspot.com/2014/12/support-for-elliptic-curves-by-jarsigner.html"" rel=""nofollow"">Support for elliptic curves by jarsigner</a>"". To quote the conclusion:</p>

<p><em>Support of elliptic curves by jarsigner depends on jarsigner itself and on the JRE configuration. There is no command-line option to list all supported curves.</em></p>
","89","<elliptic-curve><jarsigner><jar-signing><ecdsa>","1","0","1","2015-01-02 19:51:11","27747754","0","","3608247","","2014-11-26 09:41:15","2014-11-26 08:12:05",""
"52836472","OpenSSL occasionally generates wrong signature","<p>I have a C++ programme, ECDSA key pair and some string to sign. The programme generates signature and saves it into a file (<code>signature.bin</code>). Then I check the validity of the signature via the following command:</p>

<pre><code>openssl dgst -verify ec_public.pem -signature signature.bin ToSign.txt
</code></pre>

<p>the problem is that the programme <strong>sometimes generates wrong signature</strong>. 16 times out of 21 the above command outputs:</p>

<pre><code>Error Verifying Data
</code></pre>

<p>while in the remaining 5 occurrences it outputs:</p>

<pre><code>Verified OK
</code></pre>

<p>How can it be possible?</p>

<p>Here is the programme:</p>

<pre><code>SSL_library_init();
OPENSSL_config(nullptr);
SSL_load_error_strings();
OpenSSL_add_all_algorithms();
ERR_load_BIO_strings();
CRYPTO_set_id_callback(ThreadIdFunction);
CRYPTO_set_locking_callback(LockingFunction);

const TString pk = ""-----BEGIN EC PRIVATE KEY-----\n""
                       ""MHcCAQEEIG90zmo1o3NWNFa8wp2z4rdQXGSN8xAP/OATLpwlgi+1oAoGCCqGSM49\n""
                       ""AwEHoUQDQgAE5TwpzBhjUWZoOf629GfwGG5WlRJD7TSuz+ZTHUaiK5mj2qgxBOPk\n""
                       ""eqOrTYXsiPwnaWe23zHjIM8NOhAm1BiGgA==\n""
                       ""-----END EC PRIVATE KEY-----\n"";

const TString ToSign = ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhc2RmIn0"";

EVP_MD_CTX *Ctx    = EVP_MD_CTX_create();
BIO *       Bio    = BIO_new_mem_buf(pk.data(), pk.size());
EVP_PKEY *  EVPKey = PEM_read_bio_PrivateKey(Bio, nullptr, nullptr, nullptr);

EVP_DigestSignInit(Ctx, nullptr, EVP_sha256(), nullptr, EVPKey);
EVP_DigestSignUpdate(Ctx, ToSign.data(), ToSign.size());
size_t SignatureLength;
EVP_DigestSignFinal(Ctx, nullptr, &amp;SignatureLength);

TString Result;
Result.resize(SignatureLength);
EVP_DigestSignFinal(Ctx, reinterpret_cast&lt;unsigned char *&gt;(const_cast&lt;char *&gt;(Result.data())), &amp;SignatureLength);

// Saving to file...
</code></pre>
","<p>You are invoking the right OpenSSL methods. However, you did not explain in detail how you save the <code>Result</code> to file. Based on its name, <code>TString</code> probably behaves as a 0-terminated string. If so, then the signature will not be written to the file correctly but truncated too early whenever the it contains a 0-byte. Note that the ECDSA signing steps include a random component so the signature is different every time you run your code.</p>

<p>The following reasoning supports this guess and roughly explains why your code fails and succeeds as often as it does. If you read <a href=""https://crypto.stackexchange.com/a/1797/18307"">this explanation about the format of the ECDSA signature</a>, you will see that the 0-byte is very common in such signatures. The probability is about 3/4 for the first bytes of the <code>r</code> and <code>s</code> components combined. Then there is an additional probability of 1-(255/256)^64, about 1/4, that the remaining 64 bytes will contain a 0. So the probability of failure is roughly 3/4 + 1/4*1/4, about 80%.</p>

<p>Your sample space is small, but with that string-mistake taken into account, 5 successes out of 21 attempts is a likely result.</p>
","86","<openssl><sign><ecdsa>","2","1","1","2018-10-17 05:43:01","","0","","","","","2018-10-16 13:22:22",""
"53456211","How to separate marshalled ecdsa public and private keys in GoLang","<p>So far, I have:</p>

<pre><code>key, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
if err != nil {
    os.Exit(-1)
}
marshalled, err := x509.MarshalECPrivateKey(key) // marshalls data to byte stream
if err != nil {
    os.Exit(-1)
}
</code></pre>

<p>Basically, what I am having trouble with has to do with the fact that when a key pair is generated, it is stored in an <code>*ecdsa.PrivateKey</code>, in which the public key is stored in the <code>*ecdsa.PrivateKey.PublicKey</code>, and when I marshall the key pair data (stored in the <code>*ecdsa.PrivateKey</code>) using <code>x509.MarshalECPrivateKey(key)</code>, a single byte slice is returned. I am therefore having trouble determining which are the public and private keys in the byte slice itself.</p>
","<p>The private key is a superset of the public key.  It always contains the public key.  Usually a public key is stored as part of a certificate.</p>

<p>If you really want to get the public key by itself, you can grab the <code>X</code> and <code>Y</code> big integers from the ecdsa public key struct and store the binary representation of them.</p>

<p>You might benefit from a bit of retrospect on your design here.  There aren't too many situations where you need to communicate a public key alone.</p>
","83","<go><encryption><public-key-encryption><ecdsa>","0","0","1","2018-11-24 07:55:33","","0","","10033867","","2018-11-24 07:50:57","2018-11-24 07:45:40",""
"55330120","How to sign SAML 2.0 AuthnRequest with ECDSA (NIST Curve P-256/ SHA-256) in PHP","<p>I need to sign SAML 2.0 AuthnRequest with ECDSA (NIST Curve P-256/ SHA-256) in PHP.</p>

<p>To create SAML 2.0 AuthnRequest I'm using <a href=""https://github.com/simplesamlphp/simplesamlphp"" rel=""nofollow noreferrer"">https://github.com/simplesamlphp/simplesamlphp</a></p>

<p>I have a private key</p>

<pre><code>Private-Key: (256 bit)
priv:
    0d:.....
pub:
    04:....
ASN1 OID: prime256v1
NIST CURVE: P-256
</code></pre>

<p>To create signature, I'm using <a href=""https://github.com/phpecc/phpecc"" rel=""nofollow noreferrer"">https://github.com/phpecc/phpecc</a> because <a href=""https://github.com/robrichards/xmlseclibs"" rel=""nofollow noreferrer"">https://github.com/robrichards/xmlseclibs</a> does not seem to support NIST Curve P-256/ SHA-256</p>

<p>I've implemented this example exactly how it is <a href=""https://github.com/phpecc/phpecc/blob/HEAD/examples/creating_signature.php"" rel=""nofollow noreferrer"">https://github.com/phpecc/phpecc/blob/HEAD/examples/creating_signature.php</a> but I'm getting error from request reciver. </p>

<p>Where do I get from or how can I create <code>&lt;ds:DigestValue&gt;...&lt;/ds:DigestValue&gt;</code></p>

<p>What am I doing this wrong?
Am I using wrong libraries?
Is there one vendor to support this case?</p>
","","83","<php><saml-2.0><elliptic-curve><ecdsa><xml-dsig>","1","","0","2019-03-25 01:07:36","","0","","","","","2019-03-25 01:07:36",""
"55886692","bouncycsatle ecdsa verify signature failed though passing on openssl","<p>I have generated EC curve keys using openssl and generated the signature using sha256 digest  </p>

<p>The <strong>data:</strong> <code>265a33bf7a514b6671e6e02aaee2383759348d9f</code></p>

<pre><code>openssl dgst -sha256 -sign key1.pem data &gt; sig1
</code></pre>

<p>The public key file <strong>pubkey1.pem</strong></p>

<pre><code>   -----BEGIN PUBLIC KEY-----
    MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE/2CznS1gXRaO6z8UvF1SOs97Dwp5HUdo
    1Y9OW91lfLl1NA8uXUFY7wJYvTl2dbnuZ1muh7htsxMVgEEbn+XCdQ==
    -----END PUBLIC KEY-----
</code></pre>

<p>The signature file base64 encoded</p>

<pre><code>MEUCIQDqUv33+c3svyYOXPVZCYx49TE2Vxq4uP5kSV2ZJ4o/JwIgEqWkxdSMNuQNuzL4KXTEeH/O
ZBFjyErxvHgdHTCjeh0=
</code></pre>

<p>Singature verification passed </p>

<pre><code>[bash]$ base64 -d sig1b64  &gt; sig1d
[bash]$ openssl dgst -sha256 -verify pubkey1.pem -signature sig1d 
data
Verified OK
</code></pre>

<p>When i verify this using the Java Bouncycastle library it fails to verify the signature, here is the code snippet, </p>

<pre><code>    public boolean verifyMessage (final String param,final String message , final String signature , final String algo ) throws Exception
{

    byte[] content = param.getBytes();
    InputStream is = new ByteArrayInputStream(content);
    InputStreamReader isr = new InputStreamReader(is);

    Reader br = new BufferedReader(isr);
    PEMParser parser = new PEMParser(br);

    Object obj = parser.readObject();
    PublicKey thepubKeyofA = null;

    if (obj instanceof org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) {
        SubjectPublicKeyInfo eckey = (SubjectPublicKeyInfo) obj;
        thepubKeyofA = new JcaPEMKeyConverter().setProvider(""BC"").getPublicKey(eckey);
        Signature ecdsaVerify = Signature.getInstance(""SHA256withECDSA"", ""BC"");
        ecdsaVerify.initVerify(thepubKeyofA);
        ecdsaVerify.update(message.getBytes());
        boolean result = ecdsaVerify.verify(Utils.decodeBASE64(signature));
        return result;

    }
</code></pre>
","","83","<java><openssl><bouncycastle><ecdsa>","1","","0","2019-04-28 13:04:36","","5","1","911576","","2019-04-28 13:04:36","2019-04-28 03:09:01",""
"44545281","ECDSA_do_verify is throwing error","<p>ECDSA verify signature failed </p>

<pre><code> if (ECDSA_do_verify(digest.data, digest.len, sig, ec_key)) {
      printf(""successful"");
    } else {
         printf(""Error in signing"");
        while ((l=ERR_get_error_line_data(&amp;file,&amp;line,&amp;data,&amp;flags)) != 0) { 
            syslog(LOG_ERR, ""ECDSA_do_verify Error %x : %s : %s : %d"",
                    l, ERR_error_string(l,buf), file,line);
        }
}    
</code></pre>

<p>Error:-</p>

<blockquote>
  <p>ECDSA_do_verify Error 3208408d :
  error:3208408D:lib(50):func(132):reason(141) : fec_crypto_api.c : 249 </p>
  
  <p>ECDSA_do_verify Error 320c308d :
  error:320C308D:lib(50):func(195):reason(141) : fec_key.c : 111 </p>
  
  <p>ECDSA_do_verify Error 320af066 :
  error:320AF066:lib(50):func(175):reason(102) : fec_crypto.c : 2090 </p>
  
  <p>ECDSA_do_verify Error 3206807b :
  error:3206807B:lib(50):func(104):reason(123) : fec_crypto_api.c : 587</p>
</blockquote>

<p>How to fix this?</p>
","","80","<openssl><ecdsa>","0","","0","2017-06-14 14:39:53","","3","","6535399","","2017-06-14 14:39:53","2017-06-14 12:48:18",""
"35301483","CloudKit Server-to-Server authentication with delphi?","<p>I saw the article yesterday on Apple CloudKit and the new server to server solution. See link <a href=""https://stackoverflow.com/questions/35247436/cloudkit-server-to-server-authentication"">here</a>.</p>

<p>Is there anyone who knows an up-to-date way how to calculate ECDSA in Delphi 10 Seattle ?</p>

<p>I did not find yet any particular unit to do so.</p>
","","78","<delphi><cloudkit><ecdsa><server-to-server>","1","","0","2016-02-09 22:57:17","","1","","-1","","2017-05-23 10:28:24","2016-02-09 20:25:19",""
"49495570","Cannot verify signature using C-style function calls","<p>The following prints FAIL and I cannot understand why:</p>

<pre><code>#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/osrng.h&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace CryptoPP;
int main() {
    AutoSeededRandomPool prng;
    ECDSA&lt;ECP, SHA256&gt;::PrivateKey private_key;
    ECDSA&lt;ECP, SHA256&gt;::PublicKey public_key;
    private_key.Initialize( prng, ASN1::secp160r1() );
    private_key.MakePublicKey(public_key);
    ECDSA&lt;ECP, SHA256&gt;::Signer signer(private_key);
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(public_key);
    signer.AccessKey().Initialize(prng, ASN1::secp160r1());
    string signature(signer.MaxSignatureLength(), 0);
    string message = ""asdf"";
    auto signature_length = signer.SignMessage(
        prng, (const byte*)message.data(),
        message.size(), (byte*)signature.data());
    signature.resize(signature_length);
    bool verified = verifier.VerifyMessage(
        (const byte*)message.data(), message.size(),
        (const byte*)signature.data(), signature.size());
    if (verified)
        cout &lt;&lt; ""PASS"" &lt;&lt; endl;
    else
        cout &lt;&lt; ""FAIL"" &lt;&lt; endl;
}
</code></pre>

<p>It follows the instructions in crypto++ wiki: <a href=""https://www.cryptopp.com/wiki/ECDSA#Message_Signing"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/ECDSA#Message_Signing</a> and verifies with a public key derived from the private used to sign the same message. Should I switch to filters?</p>
","<blockquote>
  <p>The following prints FAIL and I cannot understand why:</p>
</blockquote>

<p>You are close. Looking at the wiki page there are a few problems. First, this is undefined behavior (it has been fixed on the wiki):</p>

<pre><code>auto signature_length = signer.SignMessage(
    prng, (const byte*)message.data(),
    message.size(), (byte*)signature.data());
</code></pre>

<p>To get the non-const pointer you need this instead (but it is not the cause of your issue):</p>

<pre><code>auto signature_length = signer.SignMessage(
    prng, (const byte*)&amp;message[0],
    message.size(), (byte*)&amp;signature[0]);
</code></pre>

<p>Second, when you call <code>Initialize</code> twice you whack the old configuration. ""Whack"" means you generate new parameters. Effectively you overwrote the other private key:</p>

<pre><code>private_key.Initialize( prng, ASN1::secp160r1() );
...
signer.AccessKey().Initialize(prng, ASN1::secp160r1());
</code></pre>

<p>It is not readily apparent, but the <code>Initialize</code> that takes a <code>prng</code> generates a new key. You want an <code>Initialize</code> that <em>does not</em> take a <code>prng</code>:</p>

<pre><code>private_key.Initialize( prng, ASN1::secp160r1() );
...
signer.AccessKey().Initialize(private_key);
</code></pre>

<p>Third, the page is not clear how to move between Signers/Verifiers and PublicKey/PrivateKey. Here are some other ways to do it for illustration purposes:</p>

<pre><code>cryptopp $ cat test.cxx
#include ""eccrypto.h""
#include ""oids.h""
#include ""osrng.h""
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    ECDSA&lt;ECP, SHA256&gt;::Signer signer;
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier;

    signer.AccessKey().Initialize(prng, ASN1::secp160r1());
    signer.AccessKey().MakePublicKey(verifier.AccessKey());

    std::string signature(signer.MaxSignatureLength(), 0);
    std::string message = ""asdf"";

    auto signature_length = signer.SignMessage(
        prng, (const byte*)&amp;message[0],
        message.size(), (byte*)&amp;signature[0]);
    signature.resize(signature_length);

    bool verified = verifier.VerifyMessage(
        (const byte*)&amp;message[0], message.size(),
        (const byte*)&amp;signature[0], signature.size());

    if (verified)
        std::cout &lt;&lt; ""PASS"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""FAIL"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>I'm working from Crypto++ directory so the includes and command line are a little different:</p>

<pre class=""lang-none prettyprint-override""><code>cryptopp$ g++ -I . test.cxx ./libcryptopp.a -o test.exe
cryptopp$ ./test.exe
PASS
</code></pre>

<hr>

<p>If you want to use both Signers/Verifiers and PublicKey/PrivateKey then try something like:</p>

<pre><code>cryptopp$ cat test.cxx
#include ""eccrypto.h""
#include ""oids.h""
#include ""osrng.h""
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    ECDSA&lt;ECP, SHA256&gt;::Signer signer;
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier;

    ECDSA&lt;ECP, SHA256&gt;::PrivateKey&amp; sKey = signer.AccessKey();
    sKey.Initialize(prng, ASN1::secp160r1());
    ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; pKey = verifier.AccessKey();
    sKey.MakePublicKey(pKey);

    std::string signature(signer.MaxSignatureLength(), 0);
    std::string message = ""asdf"";

    auto signature_length = signer.SignMessage(
        prng, (const byte*)&amp;message[0],
        message.size(), (byte*)&amp;signature[0]);
    signature.resize(signature_length);

    bool verified = verifier.VerifyMessage(
        (const byte*)&amp;message[0], message.size(),
        (const byte*)&amp;signature[0], signature.size());

    if (verified)
        std::cout &lt;&lt; ""PASS"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""FAIL"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<hr>

<p>This looks a little unusual:</p>

<pre><code>ECDSA&lt;ECP, SHA256&gt;::Signer signer;
...
signer.AccessKey().Initialize(prng, ASN1::secp160r1());
</code></pre>

<p>Typically you use <code>{secp160r1, SHA1}</code> or <code>{secp256k1, SHA256}</code>. That maintains the <a href=""https://www.cryptopp.com/wiki/Security_Level"" rel=""nofollow noreferrer"">Security Levels</a> of the system as a whole. When you use <code>{secp160r1, SHA256}</code> you are reducing the security level to about 80-bits because of <code>secp160r1</code>.</p>
","76","<c++><crypto++><ecdsa>","-1","0","1","2018-03-27 16:29:08","49498017","4","","","","","2018-03-26 15:48:30",""
"55691841","Convert from plain signature to der encoded signature","<p>I don't know how to encode my raw ecdsa signature to der encoded signature to verify it in EVP_DigestVerifyFinal. I receive the signature from the client in what I believe are raw bytes because doing d2i_ECDSA_SIG returns NULL. 
I've seen this solution <a href=""https://stackoverflow.com/questions/31390784/creating-a-der-formatted-ecdsa-signature-from-raw-r-and-s"">Creating a DER formatted ECDSA signature from raw r and s</a>
and this one 
<a href=""https://security.stackexchange.com/questions/174095/convert-ecdsa-signature-from-plain-to-der-format"">https://security.stackexchange.com/questions/174095/convert-ecdsa-signature-from-plain-to-der-format</a>
but  neither worked for me. 
The first one because I cant get the ECDSA_SIG structure and the second one I dont understand.</p>
","","75","<c><digital-signature><ecdsa><der>","0","","0","2019-04-15 18:10:40","","0","","8239061","","2019-04-15 18:10:40","2019-04-15 14:52:25",""
"56316652","Converting an ECDSA private key into PEM format","<p>I haven't tested enough to know if it's sure, but <a href=""https://stackoverflow.com/questions/23734792/c-sharp-export-private-public-rsa-key-from-rsacryptoserviceprovider-to-pem-strin"">C# Export Private/Public RSA key from RSACryptoServiceProvider to PEM string</a> </p>

<p>Seems to get me an RSA key into PEM format. </p>

<p>Looking to do similar for an ECDSA ( private key for an ECC certificate ) - Does that answer have most of what I need or would this be very different? I'm using as much default .net as possible - I know chillkat or bouncy castle might have something but was not able to infer how to do this without including them as dependencies.</p>

<p>Tried the same function by passing different cryptographic objects able to hold the ecdsa key ( and changing the parameters/arguments ) but the parameters aren't nearly the same for this type of key - Not sure which order to put these in, wouldn't know if the encoder function would work for this either.</p>
","","74","<c#><x509certificate2><ecdsa>","0","","0","2019-05-26 19:55:32","","1","","6512996","","2019-05-26 19:55:32","2019-05-26 19:18:09",""
"57385412","ECDSA_do_verify fails to verify for some hash only","<p>I have a device for which I know its public key. The device is capable to signing a random number with its private key and returning the signature. In my workflow, I take a random number and give the device to sign this number. The device calculates the SHA256 hash of this random number and signs it with its private key. I have to verify this signature with the random number and device's public key. I am using openssl to achieve this. I also calculate the hash of the random number and use ECDSA_do_verify function to verify the signature. The problem is that, I can verify this signature most of the time.. But sometimes ECDSA_do_verify fails to verify the signature. I tried generating 100 random numbers and verify their signature. I could verify the signature 86 times and other 14 times the verification failed. Any idea what could be missing. </p>

<pre><code>bool verify_signature(const unsigned char* hash, const ECDSA_SIG* signature, EC_KEY* eckey)
{
    int verify_status = ECDSA_do_verify(hash, strlen((const char*)hash), signature, eckey);
    if (1 != verify_status)
    {
        printf(""Failed to verify EC Signature\n"");
        return false;
    }

    printf(""Verifed EC Signature\n"");

    return true;
}



void SetOpensslSignature(const std::string&amp; sSignatureInHex, ECDSA_SIG* pSign)
{
    std::unique_ptr&lt; BIGNUM, std::function&lt;void(BIGNUM*)&gt;&gt; rr(NULL, [](BIGNUM* b) { BN_free(b); });
    BIGNUM* r_ptr = rr.get();
    std::unique_ptr&lt; BIGNUM, std::function&lt;void(BIGNUM*)&gt;&gt; ss(NULL, [](BIGNUM* b) { BN_free(b); });
    BIGNUM* s_ptr = ss.get();

    std::string sSignatureR = sSignatureInHex.substr(0, sSignatureInHex.size() / 2);
    std::string sSignatureS = sSignatureInHex.substr(sSignatureInHex.size() / 2);

    BN_hex2bn(&amp;r_ptr, sSignatureR.c_str());
    BN_hex2bn(&amp;s_ptr, sSignatureS.c_str());

    ECDSA_SIG_set0(pSign, r_ptr, s_ptr);

    return;
}

bool SetOpensslPublicKey(const std::string&amp; sPublicKeyInHex, EC_KEY* pKey)
{
    const char* sPubKeyString = sPublicKeyInHex.c_str();

    char cx[65];

    std::unique_ptr&lt; BIGNUM, std::function&lt;void(BIGNUM*)&gt;&gt; gx(NULL, [](BIGNUM* b) { BN_free(b); });
    std::unique_ptr&lt; BIGNUM, std::function&lt;void(BIGNUM*)&gt;&gt; gy(NULL, [](BIGNUM* b) { BN_free(b); });

    BIGNUM* gx_ptr = gx.get();
    BIGNUM* gy_ptr = gy.get();

    EC_KEY_set_asn1_flag(pKey, OPENSSL_EC_NAMED_CURVE);
    memcpy(cx, sPubKeyString, 64);
    cx[64] = 0;

    if (!BN_hex2bn(&amp;gx_ptr, cx)) {
        std::cout &lt;&lt; ""Error getting to binary format"" &lt;&lt; std::endl;
    }

    if (!BN_hex2bn(&amp;gy_ptr, &amp;sPubKeyString[64])) {
        std::cout &lt;&lt; ""Error getting to binary format"" &lt;&lt; std::endl;
    }

    if (!EC_KEY_set_public_key_affine_coordinates(pKey, gx_ptr, gy_ptr)) {
        std::cout &lt;&lt; ""setting public key attributes"" &lt;&lt; std::endl;
    }

    if (EC_KEY_check_key(pKey) == 1)
    {
        printf(""EC Key valid.\n"");
        return true;
    }
    else {
        printf(""EC Key Invalid!\n"");
        return false;
    }
}

std::string sha256(const std::string str)
{
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&amp;sha256);
    SHA256_Update(&amp;sha256, str.c_str(), str.size());
    SHA256_Final(hash, &amp;sha256);
    std::stringstream ss;
    for (int i = 0; i &lt; SHA256_DIGEST_LENGTH; i++)
    {
        ss &lt;&lt; hash[i];
    }
    return ss.str();
}


bool Verify(const std::string&amp; sRandomNumber, const std::string&amp; sSignature, const std::string&amp; sDevicePubKeyInHex)
{
    std::unique_ptr&lt; ECDSA_SIG, std::function&lt;void(ECDSA_SIG*)&gt;&gt; zSignature(ECDSA_SIG_new(), [](ECDSA_SIG* b) { ECDSA_SIG_free(b); });
    // Set up the signature... 
    SetOpensslSignature(sSignature, zSignature.get());

    std::unique_ptr&lt; EC_KEY, std::function&lt;void(EC_KEY*)&gt;&gt; zPublicKey(EC_KEY_new_by_curve_name(NID_X9_62_prime256v1), [](EC_KEY* b) { EC_KEY_free(b); });
    if (!SetOpensslPublicKey(sDevicePubKeyInHex, zPublicKey.get()))
        std::cout &lt;&lt; ""Failed to get the public key from the hex input"" &lt;&lt; std::endl;

    std::string sHash = sha256(sRandomNumber);

    return verify_signature((const unsigned char*)sHash.c_str(), zSignature.get(), zPublicKey.get());
}


int main(int argc, char* argv[])
{
    std::string sSignatureInHex = ""228B756444CFF74453ABA22BF1FD052965682FDFDC915647F8B07068636BE6827938ED61B6C388551A6D4CCF3397858E14F5EA648FE13454C13292364BB40C1C"";
    std::string sPublicKeyInHex = ""94E62E0C77A2955B1FB3EE98AEAA99AACAD742F20E45B727EACDD10487C2F7D0D8257C6102921880ABE953245D573D7E33EC88A67E2BA930980CB9C3D6722F8A"";
    std::string sRandomNumber = ""65560886818773090201885807838738706912015073749623293202319529"";

    if (!Verify(sRandomNumber, sSignatureInHex, sPublicKeyInHex))
        std::cout &lt;&lt; ""Verification failed."" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""Verification succeeded"" &lt;&lt; std::endl;
}
</code></pre>

<p>These are some of the sets which verify correctly.  <br/>
random number: 65560886818773090201885807838738706912015073749623293202319529 <br/>
Signature: D506D976EC17DD3717C40329E28FD8DB4F32D6A3773454A6427FD12E69728157508086B661D91E07ADF5B57E787EA1EEA526A84500436E430E89B1C1F8532A41</p>

<p>random number: 99740602803090660927832030976281034564516575306436870967722262 <br/>
Signature: C46E17807113A4000E703FA96266CF3A00765BB8AC207C9A4D424AAF1AB8ABF9BA2B4972D72DA1457953B1C44E16DED1C363AEFBC28DCE1D4A498972C41AB922</p>

<p>random number: 72678600666159100061395904673222749914485786786827057090965704 <br/>
Signature: 539D94A976B417E1577581B73E2C0926BAE1D4DFE120CC2BD04405D6AE16E9CBD2E50343A69881A9AC13C23E5E68A9ECCA8F2CF41FC3AEC219B03F948482121B</p>

<p>============================================================================================================================================
These are some of the sets which fails verification. <br/>
random number: 71953998552024151452665049464440435681055869491222530611033199 <br/>
Signature: CDD5274A1CB429FD3F78095B0262973ACDEAD85338F46E772F3095C816ADF4D25F8EDC7C916E91EFF753ABE6DE0287878E4CBD6E1B59F7D5D122C8B85D20CF1C</p>

<p>random number: 58079150817698947252033239072161198505487375300964223454033169 <br/>
Signature: D3C90D47D15DF8E066CDB09F7B218A24D69066E8B896F3013DFB4B6A9CBBA555AB2A0F07BDE9915DD48A42BCB2164CB969045C31D2035FC0DB8B4FA9877C2FFD</p>

<p>random number: 53433823585580925787026650456476141879880067601547801597683336 <br/>
Signature: 6EFD052EB961D089B4CA16CAF0818711F02500CD0540B2BE1A7426B5126E1C45D200E3C61970D49508173C7024A729A53ADF87CD2A6AF26A2D0CD3BF9EB2C0C1</p>
","<p>The SHA256 hashes of all signatures whose verification fails contain one or more <code>0x00</code> values.</p>

<p><em>Example:</em></p>

<pre><code>Random number: 71953998552024151452665049464440435681055869491222530611033199
SHA256 Hash:   63 dd ae d4 11 be a8 b6 9c 00 75 5c 8d 90 bc e0 11 b0 50 16 7f 94 fd fc ac e5 ed 00 68 34 0b b6
</code></pre>

<p><code>0x00</code> values occur at index positions 9 and 27.</p>

<p>When <code>ECDSA_do_verify</code> is called in the <code>verify_signature</code>-method, <code>strlen((const char*)hash)</code> is passed as 2nd parameter. This expression calculates the length up to the first <code>0x00</code> value (exclusive). Therefore, only part of the hash is used for verification and verification fails.</p>

<p>The problem can easily be solved by replacing <code>strlen((const char*)hash)</code> with <code>SHA256_DIGEST_LENGTH</code> because a SHA256 hash has a fixed length (of 32 bytes). </p>
","74","<c++><openssl><ecdsa>","1","2","1","2019-08-07 13:35:56","57394918","3","","","","","2019-08-07 00:11:51",""
"50742676","Why do not use ECDSA with PSK in TLS?","<p>I noticed that there are cipher suits,such as ""RSA-PSK-AES256-GCM-SHA384"",""RSA-PSK-AES128-GCM-SHA256"", in OpenSSL. But there is no cipher suits,such as ""ECDSA-PSK-AES256-GCM-SHA384"",""ECDSA-PSK-AES128-GCM-SHA256"". Both RSA and ECDSA can be used to make a certificate. Why cannot use ECDSA with PSK in TLS? Is it for a cryptographic reason? </p>
","<p>The way TLS is designed is there is only a single method for server authentication within a TLS handshake. This is just because of protocol design and not because of cryptographic reasons. ECDSA is one way to authenticate the server (using certificates with ECC key), RSA is another (using certificates with RSA key) and PSK is yet another one. The same way you cannot combine ECDSA and RSA based authentication you cannot combine ECDSA and PSK.</p>
","73","<ssl><ecdsa>","-2","0","1","2018-06-07 13:51:35","","0","","","","","2018-06-07 13:35:46",""
"53364096","iCloud Web Service Server-to-Server Authentication in PHP","<p>Was it just me, or is there a wider need for a PHP implementation of Apple's iCloud JS library? Specifically the parts needed for server-to-server integration with iCloud not relying on Javascript on the server.</p>

<p>As my recent research and experiences have shown, it has become impossible to do a third party implementation of the server-to-server iCloud web-service based on Apple's documentation, examples and most of what had been written about it at (<a href=""https://stackoverflow.com/questions/35247436/cloudkit-server-to-server-authentication?lq=1"">CloudKit Server-to-Server authentication</a> and not in the most upvoted answers either, shockingly).</p>

<p>Despite being a raw PHP noob (C and Erlang are my languages,) I have managed to put together a few classes that successfully authenticates with an iCloud container using server-to-server keys registered in that container through the iCloud dashboard.</p>

<p>If anyone wants to use the code, or preferably take it a bit further into an actual library that brings the server-to-server parts of iCloud JS to the PHP server environment, I'd be happy to share. I'm just a little shy about my ineptitude with the new language, so you'd need to work around that. </p>
","","71","<php><icloud><restful-authentication><ecdsa><icloud-api>","0","","0","2018-11-18 18:20:09","","4","","","","","2018-11-18 18:20:09",""
"57872901","How to get signature length from signature body in Crypto++ ECDSA","<p>I use Crypto++ (libcrypto++ 1.11) to embed JWT in my application. I made methods to sign and verify messages with <code>CryptoPP::ECDSA&lt;CryptoPP::ECP, CryptoPP::SHA256&gt;</code> algorithm (with <code>secp256r1</code> curve). Tokens for verification can come from the outer world, so I need to verify token contents (textual data) signature knowing the public key.</p>

<p>The problem is that Crypto++ can cause SegFault on invalid signatures, which gives me a lot of pain in my web server.</p>

<p>I hoped that signatures in BER format (default serialization format in the library) have fixed length, so all I need is to compare the length of signature with some constant. However, I found out larger contents enables larger signatures, so a deeper approach is needed.</p>

<pre><code>bool ES256Verifier::Verify(const std::string&amp; data,
                           const std::string&amp; signature) {
    bool result = false;
    try {
      CryptoPP::StringSource ss(
          signature + data, true,
          new CryptoPP::SignatureVerificationFilter(
              verifier_,
              new CryptoPP::ArraySink((byte*)&amp;result, sizeof(result))));
    } catch (const CryptoPP::BERDecodeErr&amp; err) {
      LOG_WARNING() &lt;&lt; ""Signature `"" &lt;&lt; signature &lt;&lt; ""` has invalid (non-BER) format"";
    } catch (const CryptoPP::Exception&amp; ex) {
      LOG_WARNING() &lt;&lt; ""Signature verification has failed: "" &lt;&lt; ex.what();
    }
    return result;
}
</code></pre>

<p>Verifier <code>verifier_</code> is initialized correctly (and verifies tokens successfully apart from SegFaults), but given <code>data = """"</code> and <code>signature = """"</code>, for example, I always get SegFault:</p>

<pre><code>__memmove_avx_unaligned_erms 0x00007fb4b9da6b38
CryptoPP::ArraySink::Put2(unsigned char const*, unsigned long, int, bool) 0x00007fb4ba414fb2
CryptoPP::BufferedTransformation::ChannelPut2(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool) 0x00007fb4ba3acedc
CryptoPP::StringStore::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool) const 0x00007fb4ba414e02
CryptoPP::BufferedTransformation::Peek(unsigned char*, unsigned long) const 0x00007fb4ba3ad74a
CryptoPP::Integer::Decode(CryptoPP::BufferedTransformation&amp;, unsigned long, CryptoPP::Integer::Signedness) 0x00007fb4ba45885c
CryptoPP::Integer::Decode(unsigned char const*, unsigned long, CryptoPP::Integer::Signedness) 0x00007fb4ba458c16
CryptoPP::DL_VerifierBase&lt;CryptoPP::ECPPoint&gt;::InputSignature pubkey.h:1560
CryptoPP::SignatureVerificationFilter::LastPut(unsigned char const*, unsigned long) 0x00007fb4ba4159a0
CryptoPP::FilterWithBufferedInput::PutMaybeModifiable(unsigned char*, unsigned long, int, bool, bool) 0x00007fb4ba418107
CryptoPP::BufferedTransformation::ChannelPut2(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool) 0x00007fb4ba3acedc
CryptoPP::BufferedTransformation::TransferMessagesTo2(CryptoPP::BufferedTransformation&amp;, unsigned int&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool) 0x00007fb4ba3ad8fa
CryptoPP::BufferedTransformation::TransferAllTo2(CryptoPP::BufferedTransformation&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool) 0x00007fb4ba3adb21
CryptoPP::SourceTemplate&lt;CryptoPP::StringStore&gt;::PumpAll2 filters.h:1238
CryptoPP::Source::PumpAll filters.h:1182
CryptoPP::Source::SourceInitialize filters.h:1215
CryptoPP::StringSource::StringSource filters.h:1271
jwt::signature::algorithm::ES256Verifier::Verify es256_verifier.cpp:40
ES256_SignatureTest_Test::TestBody es256_test.cpp:29
...
</code></pre>

<p>So, is there a way to look at the data and signature and decide if this particular combination is going to cause SegFault due to invalid signature length?</p>
","<p>Here's some sample code to determine the signature length using the Field Element, Signer and Verifier. The first output prints the element length and <code>r||s</code> length because <code>r||s</code> is the signature in P1363 format.</p>

<p>The second and third output just print the result of <code>SignatureLength()</code>. Your program should reject a signature shorter than <code>SignatureLength()</code>. There is no sense in even trying to verify a short signature since it is no good.</p>

<p><em>Note well</em>: this only work for the <code>DL_*</code> signature schemes (based on discrete logs). It does not apply to <code>TF_*</code> signature schemes (based on trapdoor functions).</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""eccrypto.h""
#include ""osrng.h""
#include ""oids.h""

#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    ///// Element
    DL_GroupParameters_EC&lt;ECP&gt; params(ASN1::secp256r1());

    unsigned int elemLength = params.GetCurve().GetField().MaxElementByteLength();
    std::cout &lt;&lt; ""Element length: "" &lt;&lt; elemLength &lt;&lt; std::endl;
    std::cout &lt;&lt; ""r||s length: "" &lt;&lt; 2*elemLength &lt;&lt; std::endl;

    ///// Signer
    ECDSA&lt;ECP, SHA256&gt;::Signer signer;
    signer.AccessKey().Initialize(prng, params);

    unsigned int signerLength = signer.SignatureLength();
    std::cout &lt;&lt; ""Signer signature length: "" &lt;&lt; signerLength &lt;&lt; std::endl;

    ///// Verifier
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(signer);

    unsigned int verifierLength = verifier.SignatureLength();
    std::cout &lt;&lt; ""Verifier signature length: "" &lt;&lt; verifierLength &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Running the program results in the following.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Element length: 32
r||s length: 64
Signer signature length: 64
Verifier signature length: 64
</code></pre>

<p>And if you switch curves to <code>ASN1::secp521r1()</code>, then running the program results in the following.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Element length: 66
r||s length: 132
Signer signature length: 132
Verifier signature length: 132
</code></pre>
","69","<c++><crypto++><ecdsa>","1","1","1","2019-10-07 02:52:16","57949305","5","","3995009","","2019-09-10 14:46:33","2019-09-10 14:24:31",""
"50375930","Session.GetOperationState() method is throwing exception ""Method C_GetOperationState returned CKR_FUNCTION_NOT_SUPPORTED in SoftHSM""","<p>We are using <strong>SoftHSM</strong> in our application. We have generated tokens and imported keys in it. Now we have created one job which monitors if our SoftHSM is Up and running.</p>

<p>For that, It seems that the Session.GetOperationState() method should be able to work. However I am getting an error message as below:</p>

<p>Method C_GetOperationState returned CKR_FUNCTION_NOT_SUPPORTED.</p>

<p>Please help, if this method is suitable for my need or should I usew some other function.
Thanks in advance.</p>
","<p>Method <code>Session::GetOperationState</code> freezes cryptographic operation (e.g. after computation of hash for the first half of file) and method <code>Session::SetOperationState</code> resumes cryptographic operation (e.g. for the computation of hash for the second half of the file).</p>

<p>If you want to perform health check of your HSM it should be enough to open new session with <code>Slot::OpenSession</code> method, check its state with <code>Session::GetSessionInfo</code> method and close the session afterwards.</p>
","66","<c#><pkcs#11><ecdsa><pkcs11interop><softhsm>","1","2","1","2018-05-16 19:36:52","50378717","0","1","","","","2018-05-16 16:33:05",""
"53948137","Crypto NFC microchip: JavaCard or dedicated firmware?","<p>I would like to implement some ECDSA functionalities into an NFC microchip (generating keypairs, signing, etc.), with NDEF communication.</p>

<p>I am wondering if JavaCards suits that need (size, power, protocol, performances, ECDSA acceleration, etc.), or if I'd rather use more dedicated hardware (e.g. banking secure element) with lower level software layer such as a dedicated firmware (the one I'm targeting is <a href=""http://www.tiempo-secure.com/product/dual-interface-secure-chips/"" rel=""nofollow noreferrer"">http://www.tiempo-secure.com/product/dual-interface-secure-chips/</a>).</p>

<p>Thank you very much!</p>

<p>Mario.</p>
","","65","<nfc><javacard><ndef><ecdsa>","1","","0","2018-12-27 16:36:16","","5","1","","","","2018-12-27 16:36:16",""
"55161121","Extract Private Key from ECDSa certificate","<p>I've created a self signed ECDSA certificate using openssl. I need to get it's private key information and it's certificate information as base64 bytes. The latter is easy. The first appears to be very difficult. I know I can't get it right because the private key is of length of 256. I know its length because I've created it, and I verified it using:</p>

<pre><code>openssl ec -in C:\OpenSSLx64\flir\newcerts\ecd.key.pem  -text -noout
</code></pre>

<p>All of my attempts yield a different length of bytes. Here they are:</p>

<pre><code>X509Certificate2 certificate = new X509Certificate2(certificateBytes, password, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.EphemeralKeySet);
if (certificate.GetECDsaPrivateKey() is ECDsaCng ecdKeyWrapper)
{
    CngKey key = ecdKeyWrapper.Key;
    key.SetProperty(pty);
    ECParameters parameters = ecdKeyWrapper.ExportParameters(true);
    privateKey = parameters.D;
    byte[] otherPKey = key.Export(CngKeyBlobFormat.GenericPrivateBlob);
    byte[] otherPKey2 = key.Export(CngKeyBlobFormat.EccPrivateBlob);
    byte[] otherPKey3 = key.Export(CngKeyBlobFormat.EccFullPrivateBlob);
    byte[] otherPKey4 = key.Export(CngKeyBlobFormat.Pkcs8PrivateBlob);
}
</code></pre>

<p>I know that with RSA and DSA I can use bouncyCastle but it won't work here:</p>

<pre><code>keyPair = DotNetUtilities.GetKeyPair(dsaKeyWrapper);
</code></pre>

<p>So I guess I have two problems:</p>

<ol>
<li>I can't extract the private key properly.</li>
<li>I've read the private key is supposed defined as D. Apparently, it's not (the size doesn't fit). What is D in this context then?</li>
</ol>
","","64","<c#><ecdsa><cng>","0","","0","2019-03-14 11:17:16","","0","","","","","2019-03-14 11:17:16",""
"50416655","python ECDSA implementation miscalculation on big integers","<p>I'm trying to implement ECDSA using python as part of my homework, I have a function named <code>multiplication</code> which takes two arguments Point P and t calculates <code>B= tP</code>.I have implemented this algorith based on iterative double and add algorithm on <a href=""https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication"" rel=""nofollow noreferrer"">this wikipedia page</a> the problem is when p coordination is small(one or two digits), the algorithm works fine but when coordination is large (about 70 digits) the result is different than what it supposed to be. here is the part of my code which calculates <code>multiplication</code>:</p>

<pre><code>def addition(self, p, q):
    if p.is_infinite:
        return q
    elif q.is_infinite:
        return p
    else :
        if (q.x - p.x) == 0:
            point = Point.Point(0, 0)
            point.is_infinite = True
            return point
        s = int(((q.y - p.y) * Utils.Utils.mode_inverse(q.x - p.x, self.prime)) % self.prime)
    xr = int((math.pow(s, 2) - p.x - q.x) % self.prime)
    yr = int(((s * (p.x - xr)) - p.y) % self.prime)
    r = Point.Point(xr, yr)
    return r

def double(self, p):
    if p.is_infinite:
        return p
    if p.y == 0:
        point = Point.Point(0, 0)
        point.is_infinite = True
        return point
    s = int((((3 * math.pow(p.x, 2)) + self.a) * Utils.Utils.mode_inverse(2 * p.y, self.prime)) % self.prime)
    xr = int((math.pow(s, 2) - p.x - p.x) % self.prime)
    yr = int(((s * (p.x - xr)) - p.y) % self.prime)
    r = Point.Point(xr, yr)
    return r

def multiplication(self, p, t):
    bin_t = bin(t)[2:]
    Q = Point.Point(p.x, p.y)
    Q.is_infinite = True
    for i, digit in enumerate(bin_t):
        Q = self.double(Q)
        if digit == '1':
            Q = self.addition(Q, p)
    return Q
</code></pre>

<p>Here is my Util class:</p>

<pre><code>class Utils(object):
    @staticmethod
    def mode_inverse(a, m):
        return pow(a, m - 2, m)
</code></pre>

<p>Here is my Point class:</p>

<pre><code>class Point(object):

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.is_infinite = False
</code></pre>

<p>I use <code>Curve P-224</code> parameters which are:</p>

<p><code>p = 26959946667150639794667015087019630673557916260026308143510066298881</code></p>

<p><code>a = -3</code></p>

<p><code>b = 18958286285566608000408668544493926415504680968679321075787234672564</code></p>

<p><code>Gx = 19277929113566293071110308034699488026831934219452440156649784352033</code></p>

<p><code>Gy = 19926808758034470970197974370888749184205991990603949537637343198772</code></p>

<p>according to calculator <a href=""http://www.christelbach.com/eccalculator.aspx"" rel=""nofollow noreferrer"">http://www.christelbach.com/eccalculator.aspx</a> I should get this result for calculating 2G:</p>

<p><code>Px = 11838696407187388799350957250141035264678915751356546206913969278886</code></p>

<p><code>Py = 2966624012289393637077209076615926844583158638456025172915528198331</code></p>

<p>but what I actually get is:</p>

<p><code>Px = 15364035107168693070617763393106849380516103015030577748254379737088</code></p>

<p><code>Py = 7033137909116168824469040716130881489351924269422358605872723100109</code></p>

<p>Is there any way to fix this?</p>
","<p>This was just a guess: </p>

<p><code>math.pow</code> returns a floating point number (which has finite precision).  I'd suggest using e.g. <code>s.x * s.x</code> instead of <code>math.pow(s.x,2)</code> in case the issue is hitting precision issues with bigger numbers.</p>
","63","<python><algorithm><ecdsa>","1","2","1","2018-05-18 18:30:48","50417314","2","","","","","2018-05-18 17:38:18",""
"57421392","Using Google Cloud Key Management Service to sign an Ethereum transaction","<p>I've been working on writing a signer service for an Ethereum transaction manager and I need to sign Ethereum transactions using <a href=""https://godoc.org/cloud.google.com/go/kms/apiv1"" rel=""nofollow noreferrer"">Google KMS Golang APIs</a>. I'll try and summarise the problems I'm facing below.</p>

<p>Ethereum requires compact RLP encoded 65-byte ECDSA signatures in R || S || V format. ECDSA signatures by Google KMS on the other hand have extra header components (R length, S length, etc) along with variable length R and S components. This makes these signatures incompatible for use with Ethereum transaction signing.</p>

<p>A way to get around this is parsing the R and S bytes from the ecdsa signature obtained from Google KMS, compute and add the V byte to the end and use this signature to get a signed Ethereum transaction. Something like this:</p>

<pre><code>var parsedSig struct{ R, S *big.Int }
_, err = asn1.Unmarshal(body, &amp;parsedSig)
if err != nil {
    logger.WithError(err).Error(""failed to parse signature bytes"")
    return err
}
</code></pre>

<p>However this would possibly fail due to one or more of the following reasons:</p>

<ul>
<li>Creating compact ECDSA signatures of 65-byte length by parsing out the R and S components and adding the V component is possibly as distrustful as it sounds. R and S components as mentioned above are not always of 32 byte length for standard ECDSA signatures, which means that the ECDSA signature created by concatenating the components might not always result in 64 bytes.</li>
<li>Currently signed transactions in Ethereum are created from Keccak-256 digest hashes after RLP encoding transactions as shown below:

<pre><code>// from go-ethereum
func rlpHash(x interface{}) (h common.Hash) {
    hw := sha3.NewLegacyKeccak256()
    rlp.Encode(hw, x)
    hw.Sum(h[:0])
    return h
}
</code></pre>

<a href=""https://cloud.google.com/kms/docs/algorithms#elliptic_curve_signing_algorithms"" rel=""nofollow noreferrer"">Asymmetric ECDSA</a> key signing in Google KMS doesnt have support for Keccak-256 SHA3 message digests. Would using a SHA-256 digest for ethereum transactions work? IMO this would fail since all transaction signature verification happens on RLP encoded Keccak hashes.</li>
<li>At this point I am not very sure how to compute the V component of the ECDSA signature after having checked the <a href=""https://github.com/bitcoin-core/secp256k1/blob/e541a90ef6461007d9c6a74b9f9a7fb8aa34aaa8/src/modules/recovery/main_impl.h#L123"" rel=""nofollow noreferrer"">secp256k1 implementation</a> of the <code>secp256k1_ecdsa_sign_recoverable()</code> function.</li>
</ul>

<p>How do I go about solving these above issues to be able to create verifiable signed Ethereum transactions using asymmetric elliptic curve signing algorithm by Google KMS?</p>
","","63","<ecdsa><go-ethereum><google-cloud-kms><sha-3><keccak>","1","","0","2019-08-08 22:27:34","","0","","","","","2019-08-08 22:27:34",""
"58499196","ECDSA: Convert a binary public key of 60 bytes into PEM format for using it with PHP openssl_verify()","<p>I want to proof a Wii signature in PHP. I have 60 bytes of the public key as binary data plus 4 additional bytes. And I know that it is ECDSA (most likely B-233). I already implement it in C, but the PHP interpreter is too slow for my implementation. So I call the external C tool to confirm the signature.</p>

<p>But I want to use <code>openssl_verify($data,$sig,$pubkey)</code>. My problem is the third parameter (public key). So I have to convert ECDSA info plus the public key into an accepted format. </p>

<p>Any ideas?</p>

<h1>Progress</h1>

<p>I tried more and created keys with different algorithms (e.g. sect233k1, sect233r1). My plan is to inject a so generated public key with my key. Now I get the error message:</p>

<pre><code>error:0906D06C:PEM routines:PEM_read_bio:no start line
</code></pre>

<p>The public key looks like this:</p>

<pre><code>-----BEGIN PUBLIC KEY-----
MFIwEAYHKoZIzj0CAQYFK4EEABoDPgAEAS+URvH1x1GXfTw6VZh8tLVPq3bgYwl8
g8OHtCKuADoZ8YayIHkJuYEqTJZBgI8YMX8FtrI8BOlBiBLF
-----END PUBLIC KEY-----
</code></pre>
","<p>Yeah, you're on the right track. Assuming that the curve is known, you can derive the public key as follows (which is essentially based on an idea of this <a href=""https://stackoverflow.com/a/30471945/9014097"">answer</a>):</p>

<ul>
<li><p>In the following, curve <a href=""https://tools.ietf.org/html/rfc8422#appendix-A"" rel=""nofollow noreferrer"">NIST B-233 (aka sect233r1)</a> is assumed whose raw public key has a size of 60 bytes. If the curve is different, the curve ID must be exchanged accordingly and the size of the curves's public key must be used instead. </p></li>
<li><p>Use <em>any</em> public key in DER-format that matches your curve.</p>

<p>If you don't have one, use OpenSSL to create a private key in PEM-format that matches your curve. The private key has the SEC1-format:</p>

<pre><code>openssl ecparam -out &lt;path to private key file&gt; -genkey -name sect233r1 -noout
</code></pre>

<p>From this private key, derive the public key as DER. The public key has the X.509 format:</p>

<pre><code>openssl ec -in &lt;path to private key file&gt; -pubout -outform der -out &lt;path to public key file&gt;
</code></pre></li>
<li><p>Determine the binary data of the public key with a hex-editor, e.g. <a href=""https://www.mobilefish.com/services/hex_editor/hex_editor.php"" rel=""nofollow noreferrer"">online</a>.  At this point it is made use of the fact that the raw public key is located <em>directly at the end</em> of the public key. In the case of B-233, the raw public key has a length of 60 bytes, i.e. the last 60 bytes of the generated public key must be exchanged with the 60 bytes of your current raw public key. This is the searched public key as DER, which contains your raw public key.</p></li>
<li><p>For the verification process with OpenSSL, the DER-format is sufficient if the <code>-keyform DER</code> option is used, e.g. </p>

<pre><code>openssl dgst -ecdsa-with-SHA1 -keyform DER -verify &lt;path to public key file&gt; -signature &lt;path to signature file&gt; &lt;path to file for which signature is&gt;
</code></pre></li>
<li><p>For the verification process in PHP with <a href=""https://www.php.net/manual/en/function.openssl-verify.php"" rel=""nofollow noreferrer""><code>openssl_verify</code></a> the PEM-format is required. A conversion to the PEM-format is easiest if the DER-data are Base64-encoded, e.g. <a href=""https://cryptii.com/pipes/hex-to-base64"" rel=""nofollow noreferrer"">online</a>. Finally you have to add header (<code>-----BEGIN PUBLIC KEY-----\n</code>) and footer (<code>\n-----END PUBLIC KEY-----</code>). Please make sure that there is exactly one line break immediately after the header and immediately before the footer. In the last parameter, the hash algorithm used to create the signature must be specified, e.g.: </p>

<pre><code>$data = hex2bin(&lt;binary data from file for which signature is&gt;); 
$signature = hex2bin(&lt;binary data from signature file&gt;);
$pub_key_id = ""-----BEGIN PUBLIC KEY-----\nMFIwEAYHKoZIzj0CAQYFK4EEABsDPgAEAfERAiIKyPaby4+efUcRmv8ucekCFMnjc6fN1IeQAO6EMcKCcFLhKRJUHijUNp0Dv/CWYLUdeN0qNOI6\n-----END PUBLIC KEY-----"";
$result = openssl_verify($data, $signature, $pub_key_id, OPENSSL_ALGO_SHA1);
print($result);
</code></pre></li>
</ul>
","62","<php><ecdsa>","1","1","1","2019-10-23 09:32:02","","4","","8783885","","2019-10-23 07:34:56","2019-10-22 07:35:00",""
"54769099","Non deterministic Ecdsa signature verification in solidity","<p>Please help me. How can i verify a non deterministic ecdsa signature(same message signed with same private key outputs random signature) in solidity? I have searched the whole web, tried many libraries but could'nt find a solution. I know ecrecover but it verifies deterministic signatures only. </p>

<p>I am generating ecdsa secp256k1 signature from frontend with this library - <a href=""https://github.com/kjur/jsrsasign"" rel=""nofollow noreferrer"">https://github.com/kjur/jsrsasign</a></p>

<p>Frontend Demo - <a href=""https://kjur.github.io/jsrsasign/sample/sample-ecdsa.html"" rel=""nofollow noreferrer"">https://kjur.github.io/jsrsasign/sample/sample-ecdsa.html</a></p>
","","61","<javascript><ethereum><signature><solidity><ecdsa>","0","","0","2019-02-19 15:11:31","","0","","11085091","","2019-02-19 15:11:31","2019-02-19 14:56:43",""
"48920965","difference in xamarin vs java documentation for ECPublicKey","<p>in andorid xamarin project I am generating key pair using EC curves </p>

<pre><code>generator = KeyPairGenerator.GetInstance(KeyProperties.KeyAlgorithmEc, AndroidKeyStoreContants.AndroidKeyStore);

            paramSpec = new KeyGenParameterSpec.Builder(
                    alias,
                    KeyStorePurpose.Sign | KeyStorePurpose.Verify)
                        .SetAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
                        .SetDigests(KeyProperties.DigestSha256)
                        .Build();

            generator.Initialize(paramSpec);


            var keyPair = generator.GenerateKeyPair();
</code></pre>

<p>which is fine, problem starts when I want to access the public key, <code>keyPair.Public</code>. This gives me an <code>IPublicKey</code> interface. On java, you will just cast it to <code>ECPublicKey</code> and on Xamarin you just can't do it.</p>

<p>I also noticed there is a missing member - the importat one for me - <code>getW()</code>- on xamarin representation of <code>ECPublicKey</code> vs java <code>ECPublicKey</code>.</p>

<p><a href=""https://developer.xamarin.com/api/type/Java.Security.Interfaces.ECPublicKey/"" rel=""nofollow noreferrer"">xamarin ECPublicKey</a></p>

<p><a href=""https://developer.android.com/reference/java/security/interfaces/ECPublicKey.html"" rel=""nofollow noreferrer"">java ECPublicKey</a> </p>

<p>My question is - how to access - and cast the public key to ECPublicKey in Xamarin? I want to access the X and Y coordinates.</p>

<p>Is there a way to add this missing declaration? </p>
","<p>Instead of casting to <code>ECPublicKey</code>, cast it to <code>ECPublicKeySpec</code>. IE,</p>

<pre><code>var pubKeySpec = (Java.Security.Spec.ECPublicKeySpec)keyPair.Public;
var w = pubKeySpec.GetW();
</code></pre>
","61","<java><android><xamarin><xamarin.android><ecdsa>","1","0","1","2018-02-22 09:31:23","","0","","","","","2018-02-22 06:28:15",""
"43958913","How to decrypt ECDHM SSL traffic?","<p>I am trying to decrypt some TLSv1.2 traffic with Java. I have some information from Wireshark like so...</p>

<p><a href=""https://i.stack.imgur.com/zuXc6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zuXc6.png"" alt=""enter image description here""></a></p>

<p>Any advice on how i might approach this? Let's assume i already have packet data in java i want to decrypt.</p>
","","60","<java><ssl><tls1.2><ecdsa>","0","","0","2017-05-13 23:30:50","","2","","5552705","","2017-05-13 23:30:50","2017-05-13 23:24:05",""
"56217625","How to verify ECDSA with Public Key?","<p>I have the following methods for generating keys and signing the password message.</p>

<pre><code>public void generateKeys() {
try {
  keyStore = KeyStore.getInstance(KEYSTORE_NAME);
  keyStore.load(null);

  if (!keyStore.containsAlias(KEY_NAME)) {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_EC, KEYSTORE_NAME);
    keyPairGenerator.initialize(
        new KeyGenParameterSpec.Builder(KEY_NAME,
                                        KeyProperties.PURPOSE_SIGN)
            .setDigests(KeyProperties.DIGEST_SHA256)
            .setAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
            // Require the user to authenticate with a fingerprint to authorize
            // every use of the private key
            .setUserAuthenticationRequired(true)
            .build());
    keyPairGenerator.generateKeyPair();
  }

  loadKeys();
} catch (NoSuchAlgorithmException e) {
  e.printStackTrace();
} catch (NoSuchProviderException e) {
  e.printStackTrace();
} catch (InvalidAlgorithmParameterException e) {
  e.printStackTrace();
} catch (CertificateException e) {
  e.printStackTrace();
} catch (KeyStoreException e) {
  e.printStackTrace();
} catch (IOException e) {
  e.printStackTrace();
}
</code></pre>

<p>}</p>

<pre><code>public BiometricPrompt.CryptoObject getCryptoObject() {
cryptoObject = new BiometricPrompt.CryptoObject(signature);
return cryptoObject;
}

private void loadKeys() {
try {
  keyStore = KeyStore.getInstance(KEYSTORE_NAME);
  keyStore.load(null);
  if (keyStore.containsAlias(KEY_NAME)) {
    publicKey = keyStore.getCertificate(KEY_NAME).getPublicKey();
    privateKey = (PrivateKey) keyStore.getKey(KEY_NAME, null);
    signature = Signature.getInstance(Constants.SIGNATURE);
    signature.initSign(privateKey);
  }
} catch (IOException e) {
  e.printStackTrace();
} catch (NoSuchAlgorithmException e) {
  e.printStackTrace();
} catch (CertificateException e) {
  e.printStackTrace();
} catch (KeyStoreException e) {
  e.printStackTrace();
} catch (UnrecoverableKeyException e) {
  e.printStackTrace();
} catch (InvalidKeyException e) {
  e.printStackTrace();
}
}

public String sign(String inputStr) {
try {
  Signature signature = cryptoObject.getSignature();
  signature.update(inputStr.getBytes());
  byte[] signedBytes = signature.sign();
  String result = HexManager.bytesToHex(signedBytes);
  Log.d(""TAG"", result);
  return result;
} catch (SignatureException e) {
  e.printStackTrace();
}
return null;
</code></pre>

<p>}</p>

<p>After that, I saved the signed password in Shared Preferences. Later, I want to verify the saved password with a new password that is verified with the fingerprint.</p>

<p>Here is my method to verify:</p>

<pre><code>public boolean verify(String inputStr, String savedStr) {
try {
  Signature signature = cryptoObject.getSignature();
  signature.initVerify(publicKey);
  signature.update(inputStr.getBytes());
  boolean isVerified = signature.verify(savedStr.getBytes());
  return isVerified;
} catch (InvalidKeyException e) {
  e.printStackTrace();
} catch (SignatureException e) {
  e.printStackTrace();
}
return false;
}
</code></pre>

<p>But it always return false.</p>

<p>Does anybody knows why?</p>

<p><a href=""https://i.stack.imgur.com/X3EMW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/X3EMW.png"" alt=""enter image description here""></a></p>
","<p>It looks like in your <code>sign()</code> method you're returning the <code>Hex</code> of the <code>byte[]</code> obtained from the <code>signature.sign()</code> method. If this is what you're saving as <code>savedStr</code>. Then the verification method should be changed to convert the <code>Hex</code> encoded string to a <code>byte[]</code>. You could use <code>HexManager.hexToBytes()</code> (or equivalent) if it exists to convert the <code>savedStr</code> to a <code>byte[] savedStrBytes</code>.</p>

<pre><code>public boolean verify(String inputStr, String savedStr) {
    try {
        byte[] savedStrBytes = HexManager.hexToByes(savedStr);
        Signature signature = cryptoObject.getSignature();
        signature.initVerify(publicKey);
        signature.update(inputStr.getBytes());
        boolean isVerified = signature.verify(savedStrBytes);
        return isVerified;
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (SignatureException e) {
        e.printStackTrace();
    }
    return false;
}
</code></pre>
","58","<android><android-keystore><ecdsa>","0","1","1","2019-05-31 04:32:36","56388702","1","","955836","","2019-05-20 10:02:05","2019-05-20 09:07:30",""
"51699354","Unable to use ssh - public key issue","<p>I am new to programming and am trying to ssh to my server as that may be needed later to edit code.</p>

<p>My ~/.ssh/id_rsa.pub is </p>

<p>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD3UP7ryN33fuzwg5wfXSsTDtcRc+jTsrU2+IYI0yrGqPZ7F4+LesO+1/delLvQuhr8O+YJPgAZK6mRoY+ruWPEf/hGsJkrR76kNeOSFkXP/QgSN7aWPhgRFs0EaUk+fgHcri1mOOgxcNto7Mwo8U+YuuMf3CMxMqBcWKccPvPSNMmL91cs56pTM6VXP+rNYBGEFiEqjZdYrUncICmgOO2fIgpcLOIBYsgBcWdl+vycc0oMhLtRPy6ALgzujI3FSMhRxwi8Oy0UjCHNJowcb+XFZrDk8qRUucp1/IYGXBgjS7jJVTejseIKZvnf1qEyRYY8p7pltfqrGKdPNRT5zSun mrinmaykalita@MacBook-Pro-77.local</p>

<p>and</p>

<p>my ~/.ssh/known_hosts has an entry as</p>

<p>173.<strong><em>.</em></strong>.** ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBMIkfmRuMEdyptRu11rW+3qlokDq3B5HDruYGow1fJTTQrPhL7YLAabAek97jChU09VcdBzr2x8+v3HsUfT6Blc=</p>

<p>What should I use for ***** in</p>

<p>ssh-copy-id -i ***** root@173.<strong><em>.</em></strong>.** to send public key to that server so I can ssh after that? And what is the significance of the other?</p>

<p>I am a newbie, so a dumb question.</p>

<p>Please help.</p>

<p>Thanks and Regards</p>
","<blockquote>
  <p>What should I use for ***** in ssh-copy-id -i ***** root@173...46 to send public key to that server so I can ssh after that?</p>
</blockquote>

<p>Use a path to the public key file:</p>

<pre><code>ssh-copy-id -i $HOME/.ssh/id_rsa.pub root@173...46 to send public key to that server so I can ssh after that?
</code></pre>

<p>Be careful with the access modes of files and directories (as said in a comment): as a general rule, do not set group or world access or modification rights to the corresponding inodes.</p>
","55","<ssh><rsa><ssh-keys><public-key><ecdsa>","-2","0","1","2018-08-06 15:55:56","","10","1","9612623","","2018-08-06 15:49:57","2018-08-06 00:47:03",""
"55386633","Veins simulation terminates calling openssl ECDSA_SIG_get0 function","<p>I am using the virtual machine <code>instant-veins-4-7-1-i1</code> on VirtualBox with <code>Omnet++-5.3</code> and <code>Sumo-0.32.0</code>.</p>

<p>I have installed the library <code>openssl</code> version 1.1.0. When I try to access to the struct <code>ECDSA_SIG</code> that store the signature with the function <code>ECDSA_SIG_get0</code> the simulation terminate suddenly with the following error </p>

<p><a href=""https://i.stack.imgur.com/KKrER.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KKrER.png"" alt=""enter image description here""></a></p>

<p>This is a snippet of the code that generate the error:</p>

<pre><code>ECDSA_SIG * signed_hash;
s-&gt;generateSignature(message, messageLength, signed_hash);
const BIGNUM **pr;
const BIGNUM **ps;
ECDSA_SIG_get0(signed_hash, pr, ps);
</code></pre>

<p>The <code>generateSignature</code> function code is:</p>

<pre><code>void SignatureOpenSSL::generateSignature(const unsigned char* message, int messageLength, ECDSA_SIG * signed_hash)
{

    unsigned char *md;
    unsigned char *hash;
    hash = SHA256(message, messageLength, md);

    // Computes the ECDSA signature of the given message using the supplied private key and returns the created signature
    signed_hash = ECDSA_do_sign(hash, 32, eckey);

    if (signed_hash == NULL){
        std::cout &lt;&lt;"" ko signature "" &lt;&lt; std::endl;
    }else{
        std::cout &lt;&lt;"" ok signature"" &lt;&lt; std::endl;
    }

}
</code></pre>

<p>I have upgraded the <code>openssl</code> library to version 1.1.1 but the error keeps occurring.</p>

<p>What am I doing wrong?</p>

<p>Thanks</p>
","<p>Your problem has nothing to do with openssl, but your ""C"" code and your misuse of pointers.</p>

<p>Your problem line is:</p>

<pre><code>signed_hash = ECDSA_do_sign(hash, 32, eckey);
</code></pre>

<p>Your code assumes it's changing the pointer in the calling function, it is not.  It's only changing the ""copy"" of the pointer.  You want to either return the pointer or pass in a pointer to a pointer and set it that way.</p>

<p>e.g.</p>

<pre><code>ECDSA_SIG *SignatureOpenSSL::generateSignature(const unsigned char* message, int messageLength)
{
    ...
    ECDSA_SIG *  signed_hash = ECDSA_do_sign(hash, 32, eckey);
    ...
    return signed_hash;
}


ECDSA_SIG * signed_hash = s-&gt;generateSignature(message, messageLength);
</code></pre>

<p>or</p>

<pre><code>void SignatureOpenSSL::generateSignature(const unsigned char* message, int messageLength, ECDSA_SIG ** signed_hash)
{
    ...
    *signed_hash = ECDSA_do_sign(hash, 32, eckey);

    if (*signed_hash == NULL){
        std::cout &lt;&lt;"" ko signature "" &lt;&lt; std::endl;
    }else{
        std::cout &lt;&lt;"" ok signature"" &lt;&lt; std::endl;
    }
}

ECDSA_SIG * signed_hash;
s-&gt;generateSignature(message, messageLength, &amp;signed_hash);
</code></pre>
","54","<c++><openssl><omnet++><veins><ecdsa>","0","2","1","2019-03-27 23:23:29","55387989","0","","","","","2019-03-27 21:20:26",""
"56474860","How to verify in c# an openssl ecdsa signature?","<p>I'm trying to verify in C# a signature of ECDSA done with openssl in C.
I'm forced to change the language since the device signing the documents works on linux and the one checking the signatures works on .NET.
As far as I understand an easy way to implement the algorithm in C is to use the command line to create a priv.pem, a pub.pem and a signature.bin file.</p>

<p>What I miss is a way to verify in C# what I wrote in C using the same curve and the same keys. 
I tried to import pub key, but the system returns exception for not correct parameters.</p>

<p>Thank you in advance for your help!
Marta</p>

<pre><code>$ openssl ecparam -genkey -name secp384r1 -noout -out private.pem

$ openssl ec -in private.pem -pubout -out public.pem

$ openssl dgst -sha256 -sign private.pem &lt; disp.cfg &gt; signature.txt

$ openssl dgst -sha256 -verify public.pem -signature signature.txt &lt; disp.cfg
</code></pre>
","","53","<c#><openssl><ecdsa>","0","","0","2019-06-06 09:39:04","","0","","","","","2019-06-06 09:39:04",""
"33595873","Does Domain Parameters in ECDSA are same?","<p>In <strong>ECDSA</strong>,<br>
Signer and <code>Verifier</code> should have same a, b and G?<br>
such that y^2 = x^3 + ax + b, G is starting point.</p>
","<p>Yes, the signer and verifier of an ECDSA message must agree on the curve parameters ahead of time.  Several curves are named and defined in <a href=""http://www.secg.org/sec2-v2.pdf"" rel=""nofollow"">SEC2</a>.</p>
","53","<ecdsa>","-1","1","1","2015-11-08 18:05:39","33597222","0","","","","","2015-11-08 15:57:55","2015-11-23 14:18:52"
"54840966","How to convert ECDSA private key to ASCII Armored key?","<p>I need to generate an ASCII Armored Key(as we have in PGP) from ECDSA private key.
I'm using OpenSSL to generate the ECDSA private key. </p>

<p><strong>ref:</strong>
<a href=""https://stackoverflow.com/questions/20086121/convert-ecdsa-private-hex-key-to-public-key"">Convert ECDSA private hex key to public key</a></p>

<p>Currently I'm using the OpenPGP node module for encryption/decryption using PGP ASCII Armored keys.I want to implement above functionality using Node.js</p>
","","50","<node.js><encryption><openssl><pgp><ecdsa>","0","","0","2019-02-23 11:12:23","","2","","","","","2019-02-23 11:12:23",""
"33886973","Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: 12 in PointMultiplication class","<p>I'm working to generate pointmultiplication in ECDSA class. I'm using window method for PM Scalar.</p>

<p><a href=""http://i.stack.imgur.com/ihq7K.jpg"" rel=""nofollow"">Window Method Algorithm</a></p>

<p>Here is my code</p>

<pre><code>public class PointMultiplication {

private BigInteger X;
private BigInteger Y;
private BigInteger Z;
private BigInteger zinv;
private static BigInteger zero = BigInteger.ZERO;
private boolean infinity;

//Nilai yang dihitung terlebih dahulu (precomputed points)
static PointMultiplication[] precompute = {};


 public PointMultiplication Scalar(BigInteger kin) {
    String K = kin.toString(16);
    PointMultiplication q = new PointMultiplication(zero, zero, null);
    int a = Integer.parseInt(K.substring(0, 1), 16);
    //jika d1&gt;0, q = d1.P (precomputed value)
    if (a &gt; 0) {
        q = precompute[a];
    }
    // untuk i=1 ke n
    for (int i = 1; i &lt; K.length(); i++) {
        // q =2^4P=16P=DoublePoint(DoublePoint(DoublePoint(DoublePoint(q)))).
        q = q.DoublePoint();
        q = q.DoublePoint();
        q = q.DoublePoint();
        q = q.DoublePoint();
        //Jika di&gt;0, q = q+diP (precomputed value)
        int di = Integer.parseInt(K.substring(i, i + 1),16);
        if (di&gt;0) {
            q = q.AddPoint(precompute [di]);
            }        
        }
        return q;
</code></pre>

<p>The output:</p>

<pre><code>Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: 12
    at PointMultiplication.Scalar(PointMultiplication.java:173)
    at ECDSA.Sign(ECDSA.java:58)
    at ECDSA.main(ECDSA.java:146)
</code></pre>

<p>The error is in precompute[a], I'm using projective coordinates.</p>
","","50","<ecdsa>","1","","0","2015-11-24 06:44:22","","0","","5494132","","2015-11-24 06:44:22","2015-11-24 06:37:34",""
"58616145","How to encrypt and decrypt using ECDSA private key and public key generated in Hyperledger fabric","<p>I am working on a basic-network project on <strong>Hyperledeger Fabric V-1.4.1</strong>. I have enrolled an admin and created a user using <strong>enrollAdmin.js</strong> and <strong>registerUser.js</strong>. A <strong>public Key</strong> and a <strong>private key</strong> is generated for <strong>user1</strong>. Now I want to use that <strong>private key</strong> to <strong>sign</strong> simple data and later <strong>verify</strong> using the <strong>public Key</strong>. I have tried using <strong>URSA</strong> node module which works fine with RSA keys generated through <strong>OpenSSL</strong> but isn't working with these two keys. Probably because these keys are not <strong>RSA</strong>, they are <strong>ECDSA</strong> keys. I have also read the documentation of the <strong>Crypto</strong> node module and it seems I need to have <strong>.pem</strong> files as keys to use in <strong>Crypto</strong> module. But In fabric, I have key files as <strong>-priv</strong> and <strong>-pub</strong> format.
<br>
Is there any node module that can encrypt decrypt using <strong>ECDSA</strong> keys?
<br>
Is there any specific way in hyperledger fabric to do this?
<br>
Or is there any other way I can do this thing?<br> Please ask any questions if necessary.<br>
Thank you.</p>
","<p>The two formats you see</p>

<ul>
<li>priv </li>
<li>pub </li>
</ul>

<p>Are wallet formate of filestorage</p>

<p>Try to register an identity and enroll with fabric-CA by importing identity service then you will receive certificate and private key just put it in a file and mark the extension as pem and it will work </p>
","49","<node.js><encryption><hyperledger-fabric><digital-signature><ecdsa>","0","1","1","2019-10-30 03:46:29","58618469","0","","","","","2019-10-29 22:16:35",""
"55042329","What cryptographic librairies will help calculate shared point and derive keys?","<p>We need to perform some cryptographic operations and I want to know what cryptographic librairies can fit my need. </p>

<p>The following is the context:</p>

<p><strong><em>Given the fact that we have:</em></strong></p>

<ul>
<li>An EC Private Key stored in the <strong>HSM</strong> </li>
<li>An EC Public Key (public point)</li>
<li>Encrypted AES key</li>
<li>MAC calculated with the EC public key ECDH</li>
</ul>

<p><strong><em>We need to perform the following:</em></strong></p>

<ul>
<li><strong>Calculate</strong> a <strong>shared point</strong> (K~X~, K~Y~) using ECKA-DH algorithm from the EC Private and EC Public Keys. (See BSI TR 03111)</li>
<li><strong>Derive</strong> K~ENC~ and K~MAC~ using KDF2(x, l) with SHA-256. K~ENC~ is first 8 bytes of output. K~MAC~ is last 8 bytes of output. (See ISO/IEC 18033-2)</li>
<li>Verify the MAC over the encrypted AES key against MAC ==> MAC = <strong>AES-CMAC</strong>(Encrypted AES key || ValueA || ValueB, K~MAC~).</li>
<li>Decrypt the encrypted AES key ==> AES key = <strong>AES-CBC</strong>(encrypted AES key, K~ENC~).</li>
</ul>

<blockquote>
  <p>What cryptographic librairies will help calculate shared point baed on
  the fact that the Private key is stored in the HSM?</p>
  
  <p>Can Bouncy Castle be used jointly with IAIK PKCS#11 wrapper?</p>
  
  <p>Can IAIK-JCE a commercial product from IAIK help on that?</p>
</blockquote>

<p>Thank you for your help.</p>

<p>Best regards.</p>
","<p>Since you are using HSM (your Elliptic Curve private is store on HSM) you can use API's from hsm vendors to perform your cryptographic operations. For eg: In case of Safenet HSM, Gemalto provides crystoki library like JSP and JCProv API's in java to perform all the operations you have stated.</p>
","48","<ecdsa><hsm><ecdh>","0","0","1","2019-04-10 13:53:36","","0","","","","","2019-03-07 11:06:06",""
"56308084","Which curve is SHA1withECDSA using?","<p>I am using SHA1withECDSA to verify signed messages in my java application. Now I want to create a second application in another programming language (node/js) which creates those signed messages. </p>

<p>However I could not find any api which has ""SHA1withECDSA"". All of them only support ECDSA with a selected curve. So my question: Which ec curve is java using?</p>

<p>Keyfactory:
<code>final KeyFactory keyFactory = KeyFactory.getInstance(""EC"");</code></p>

<p>Signature:
<code>final Signature dsa = Signature.getInstance(""SHA1withECDSA"");</code></p>
","<p>The <code>{hash}withECDSA</code> algorithms in Java support any curve that can be expressed in an <code>ECPrivateKey</code> object passed to <code>Signature.initSign(key)</code> or (your case) an <code>ECPublicKey</code> object passed to <code>Signature.initVerify(key)</code> which for the standard SunEC provider are <strong>any curve expressed in X9.62 (Weierstrass) form</strong>. This is basically everything used nowadays <em>except</em> Bernstein et al's {Curve,X,Ed}{25519,448} (EdDSA is <em>an</em> elliptic-curve signature algorithm but not <em>the</em> algorithm named ECDSA). </p>

<p>The standard X9/NIST and TLS curves are predefined, although (edit) accessing them other than for key <em>generation</em> is a bit clumsy; see <a href=""https://stackoverflow.com/questions/22646792/how-does-one-convert-a-public-ec-code-point-and-curve-name-into-a-publickey"">How does one convert a public EC code point and curve name into a PublicKey?</a> .</p>

<p>Normally the keypair should be <em>generated</em> by the signer, and (only) the publickey <strong>distributed to the verifier(s)</strong> either in advance of or along with the signature(s) and signed data; often this is done in the form of a certificate, which avoids manual effort and manual mistakes that create vulnerabilities. Java directly supports X.509 certificates, and the publickey format used by them (SubjectPublicKeyInfo aka SPKI); see the javadoc for <code>java.security.spec.X509EncodedKeySpec</code> and <code>java.security.Key</code>. For EC, the SPKI includes the curve identification, but unfortunately the Java API provides no convenient way to get it back out. </p>

<p>If you have an X.509 certificate or just the X.509 SPKI for the publickey in a file, in either DER or PEM format, and have OpenSSL, it can decode and display this info:</p>

<pre><code> openssl x509 -in certfile -inform {der|pem} -text 
 openssl pkey -in spkifile -inform {der|pem} -pubin -text # 1.0.0 up
 openssl ec -in spkifile -inform {der|pem} -pubin -text # 0.9.x 
 # look at the line labelled ASN1 OID:
</code></pre>
","48","<java><ecdsa>","0","0","1","2019-05-26 04:23:05","56310400","1","","","","","2019-05-25 19:34:38",""
"55283370","Get java.security.PrivateKey from private key file generated by hyperledger ca","<p>Using <a href=""https://hyperledger-fabric-ca.readthedocs.io/en/release-1.4/"" rel=""nofollow noreferrer"">hyperledger-fabric-ca</a> tool I got private key like following</p>

<pre><code>-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgrECQDuXL87QJKYDO
O/Z1TT+vzVPqF3106wT75dJF5OqhRANCAASsFuneE46/9JmUJCiQ14zWDKcFn6TL
kYl6mirTXefU7yYglu5hmehU0pD/PKKLkoTLNbPLn5RMdUe8aum3N1sZ
-----END PRIVATE KEY-----
</code></pre>

<p>By default that software uses <code>ecdsa-with-SHA256</code> (<code>prime256v1</code>) Signature Algorithm </p>

<p>In my java application i need to have instance of java.security.PrivateKey that based on private key above.</p>

<p>I have tried following code </p>

<pre><code> public static void main(String[] args) throws Exception {

        String privateKeyString = ""-----BEGIN PRIVATE KEY-----\n"" +
                ""MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgrECQDuXL87QJKYDO\n"" +
                ""O/Z1TT+vzVPqF3106wT75dJF5OqhRANCAASsFuneE46/9JmUJCiQ14zWDKcFn6TL\n"" +
                ""kYl6mirTXefU7yYglu5hmehU0pD/PKKLkoTLNbPLn5RMdUe8aum3N1sZ\n"" +
                ""-----END PRIVATE KEY-----\n"";


        String privateKeyContent = privateKeyString.replaceAll(""\\n|-----BEGIN PRIVATE KEY-----|-----END PRIVATE KEY-----"", """");
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(privateKeyContent.getBytes());
        KeyFactory factory = KeyFactory.getInstance(""EC"");
        PrivateKey privateKey = factory.generatePrivate(spec);
    }
</code></pre>

<p>but I am getting </p>

<pre><code>Exception in thread ""main"" java.security.spec.InvalidKeySpecException: java.security.InvalidKeyException: invalid key format
    at sun.security.ec.ECKeyFactory.engineGeneratePrivate(ECKeyFactory.java:169)
    at java.security.KeyFactory.generatePrivate(KeyFactory.java:372)
    at QueryApp.main(QueryApp.java:36)
Caused by: java.security.InvalidKeyException: invalid key format
    at sun.security.pkcs.PKCS8Key.decode(PKCS8Key.java:330)
    at sun.security.pkcs.PKCS8Key.decode(PKCS8Key.java:356)
    at sun.security.ec.ECPrivateKeyImpl.&lt;init&gt;(ECPrivateKeyImpl.java:73)
    at sun.security.ec.ECKeyFactory.implGeneratePrivate(ECKeyFactory.java:237)
    at sun.security.ec.ECKeyFactory.engineGeneratePrivate(ECKeyFactory.java:165)
    ... 2 more
</code></pre>
","<p>You must base64-decode the contents, e.g.</p>

<pre><code>String privateKeyContent = privateKeyString.replaceAll(""\\n|-----BEGIN PRIVATE KEY-----|-----END PRIVATE KEY-----"", """");
PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKeyContent));
KeyFactory factory = KeyFactory.getInstance(""EC"");
</code></pre>
","46","<java><hyperledger-fabric><bouncycastle><ecdsa>","0","1","1","2019-03-21 17:27:03","55286055","0","","","","","2019-03-21 14:59:19",""
"54517928","Logging into SFTP server using ECDSA client certificate using phpseclib","<p>I'm trying to log into an SSH server using a ECDSA client certificate in PHP. I'm using the master dev branch of phpseclib which includes support for ECDSA since October 2018.</p>

<p>I've taken the sample script for logging into an ssh server, and adapted it to use my certificate:</p>

<pre><code>use phpseclib\Crypt\ECDSA;
use phpseclib\Net\SFTP;

$sftp = new SFTP('server.ssh');
$key = new ECDSA();

echo $key-&gt;load(file_get_contents('/path/to/clientkey'));

if (!$sftp-&gt;login('username', $key)) {
    print_r($sftp-&gt;getErrors());
    echo 'Login Failed';
} else {
    echo 'Login Succeeded!';
}
</code></pre>

<p>This code yields the following pretty much instantaneously (so no timeout):</p>

<pre><code>1 // so the key loads successfully

Array
(
) // no errors that we know of
Login Failed // but no success either
</code></pre>

<p>The same login data works using sftp command line on the same machine. The remote server only supports SFTP connections, so I can't try a regular SSH2 connection.</p>

<p>Is this supposed to work yet? Is this how it's supposed to work, or is there an error in my code?</p>
","","45","<php><phpseclib><ecdsa>","0","","0","2019-02-04 14:07:12","","1","","","","","2019-02-04 14:07:12",""
"53835920","OpenSSH ecdsa to BCECPublicKey","<p>I would like to convert an OpenSSH ecdsa public key string(<code>.pub</code> file) to a <code>BCECPublicKey</code> instance.</p>

<p>What I want to achieve it the reverse of this code:</p>

<pre><code>BCECPublicKey publicKey = ...;

byte[] point = SubjectPublicKeyInfo.getInstance(ASN1Sequence.getInstance(publicKey.getEncoded())).getPublicKeyData().getOctets();

ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);

dataOutputStream.writeInt(""ecdsa-sha2-nistp256"".getBytes().length);
dataOutputStream.write(""ecdsa-sha2-nistp256"".getBytes());
dataOutputStream.writeInt(""nistp256"".getBytes().length);
dataOutputStream.write(""nistp256"".getBytes());
dataOutputStream.writeInt(point.length);
dataOutputStream.write(point);

String base64 = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());
</code></pre>

<p>This is what I've tried:</p>

<pre><code>    // Valid ecdsa-sha2-nistp256 public key string from a .pub file.
    String base64 = ""AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBG93uDMAjwxpPFXgLFFs7FzWZXrQRaXnBMqmHaRN/5JRzljuqYAUAkW98HvFxGKrnb2JdW3X785AxLNzVhiiw+4="";
    byte[] bytes = Base64.getDecoder().decode(base64);
    ECNamedCurveParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""secp256r1"");

    // java.lang.IllegalArgumentException: Incorrect length for infinity encoding
    ECPoint point = ecSpec.getCurve().decodePoint(bytes);
    ECPublicKeySpec publicKeySpec = new ECPublicKeySpec(point, ecSpec);
    KeyFactory keyFactory = KeyFactory.getInstance(""ECDSA"", ""BC"");
    PublicKey pk = keyFactory.generatePublic(publicKeySpec);
</code></pre>

<p>But this doesn't seem to work.</p>

<p>Is there an easy way to do this with bouncy castle?</p>
","<p>You know you created the blob by concatenating six things, only the sixth of which was the actual point encoding, so how on Earth could you imagine that using all of the blob as a point encoding would be correct? </p>

<p>The clean and robust way is to parse the blob back into its pieces and extract the point encoding; the dirty way is to just assume the blob is, as expected, for ecdsa-sha2-nistp256 (and uncompressed) so the last 65 bytes are the point encoding:</p>

<pre><code>String base64 = ""AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBG93uDMAjwxpPFXgLFFs7FzWZXrQRaXnBMqmHaRN/5JRzljuqYAUAkW98HvFxGKrnb2JdW3X785AxLNzVhiiw+4="";
byte[] bytes = Base64.getDecoder().decode(base64), temp;

if( clean ){
    DataInputStream instr = new DataInputStream (new ByteArrayInputStream (bytes));
    temp = new byte[instr.readInt()]; instr.read(temp);
    if( !Arrays.equals(temp,""ecdsa-sha2-nistp256"".getBytes())) throw new Exception (""bad key"");
    temp = new byte[instr.readInt()]; instr.read(temp);
    if( !Arrays.equals(temp,""nistp256"".getBytes())) throw new Exception (""bad key"");
    temp = new byte[instr.readInt()]; instr.read (temp);
}else{
    temp = Arrays.copyOfRange(bytes, bytes.length-65, bytes.length);
}
ECNamedCurveParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec (""secp256r1"");
org.bouncycastle.math.ec.ECPoint point = ecSpec.getCurve().decodePoint (temp);
KeyFactory keyFactory = KeyFactory.getInstance(""ECDSA"", ""BC"");
PublicKey pk = keyFactory.generatePublic(new org.bouncycastle.jce.spec.ECPublicKeySpec(point, ecSpec));
</code></pre>
","43","<java><bouncycastle><openssh><ecdsa>","0","2","1","2018-12-19 00:09:15","53842880","0","","2735398","","2018-12-18 16:17:09","2018-12-18 15:08:33",""
"58755669","How to get an elliptic curve public key from a private key","<p>So, I need to get a public key from a corresponding 256 bit number using ECC spec256k1. </p>

<p>So, lets say I get a private key using a sha256 from any passphrase, like this:</p>

<pre><code>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; private_key = hashlib.sha3_256(b""Led Zeppelin - No Quarter"").hexdigest()
&gt;&gt;&gt; private_key
'c0b279f18074de51d075b152c8ce78b7bddb284e8cfde19896162abec0a0acce'
</code></pre>

<p>How do I get a public key from that private key? I need to print the public key as a string. </p>
","<pre><code>pip install fastecdsa

from fastecdsa import keys, curve,ecdsa
priv_key, pub_key = keys.gen_keypair(curve.secp256k1) 

print(pub_key)
</code></pre>

<p>yield</p>

<pre><code>X: 0xcc228e1a4c8e187a0deeabcd6e43bc8f7b6bdd91b8f823912f2de188fba054e6
Y: 0x7995a9d3866a8fa11a9af933c76216a908995ec5cec6ed7d3056b787fa7d39d7
</code></pre>

<p><strong>Supported Primitives</strong></p>

<p><strong>Curves over Prime Fields</strong> - <a href=""https://pypi.org/project/fastecdsa/#curves-over-prime-fields"" rel=""nofollow noreferrer"">Source</a></p>

<pre><code>Name                      Class

P192 / secp192r1          fastecdsa.curve.P192  
P224 / secp224r1          fastecdsa.curve.P224  
P256 / secp256r1          fastecdsa.curve.P256  
P384 / secp384r1          fastecdsa.curve.P384  
P521 / secp521r1          fastecdsa.curve.P521 
secp192k1                 fastecdsa.curve.secp192k1     
secp224k1                 fastecdsa.curve.secp224k1     
secp256k1 (bitcoin curve) fastecdsa.curve.secp256k1     
brainpoolP160r1           fastecdsa.curve.brainpoolP160r1   
brainpoolP192r1           fastecdsa.curve.brainpoolP192r1   
brainpoolP224r1           fastecdsa.curve.brainpoolP224r1   
brainpoolP256r1           fastecdsa.curve.brainpoolP256r1   
brainpoolP320r1           fastecdsa.curve.brainpoolP320r1   
brainpoolP384r1           fastecdsa.curve.brainpoolP384r1
brainpoolP512r1           fastecdsa.curve.brainpoolP512r1
</code></pre>
","41","<python><public-key-encryption><elliptic-curve><ecdsa>","1","3","1","2019-11-08 17:31:24","58756097","3","1","1968","","2019-11-07 20:11:41","2019-11-07 19:27:43",""
"55902526","Using ssh ecdsa public key in libssl","<p>I am connecting via SSH to a (homemade) server, and I want to use the ECDSA public key in .ssh/authorized_keys to sign some packets.</p>

<p>The key looks like this : </p>

<pre><code>ecdsa-sha2-nistp256 AAAA...Kw= foo@bar
</code></pre>

<p>And my code is : </p>

<pre><code>std::string pubkey = ""ecdsa-sha2-nistp256 AAAA...Kw= foo@bar"";
std::string ecdsa = ""ecdsa-sha2-nistp256 "";
size_t begin = pubkey.find(ecdsa);
size_t end = pubkey.find("" "", begin + ecdsa.size() );
pubkey = pubkey.substr(begin + ecdsa.size(), end - (begin + ecdsa.size()) ); //pubkey is now : AAAA...Kw=

EC_GROUP *ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
EC_POINT *point = EC_POINT_new(ecgroup);
int res = EC_POINT_oct2point(ecgroup, point, (unsigned char *)pubkey.c_str(), pubkey.size(), NULL); //Return 0 here, but OK should be 1
eckey = EC_KEY_new();
res = EC_KEY_set_group(eckey, ecgroup);
res = EC_KEY_set_public_key(eckey, point);
</code></pre>

<p>The function EC_POINT_oct2point returns me an error, and I don't know why/ how to fix it. Does anyone have ever encountered this problem?</p>

<p>Thank you !</p>
","","41","<c++><ssh><ecdsa><libssl>","0","","0","2019-04-29 11:36:21","","1","","1413395","","2019-04-29 11:36:21","2019-04-29 11:35:47",""
"35562739","Distinguishing start of digitally signed message digest","<p>Since I just created this crude test using the functions from IETF RFC 4634, I don't know for certain whether I've used them correctly for HMAC-SHA-384-192, so I'll start with that code here:</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include ""sha.h""

int main(int argc, char *argv[]) {
        HMACContext hmac;
        const unsigned char *keyarr = ""0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"";
        int err = hmacReset(&amp;hmac, SHA384, keyarr, 48);
        if (err != shaSuccess) {
                printf(""err 1\n"");
                exit(1);
        }
        const uint8_t testarray[65] = {'I',' ','a','m',' ','n','o','t',' ','a',' ','c','r','o','o','k','!'};
        const unsigned char *prfkey = ""abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"";
        memcpy((void *)testarray + 17, (void *)prfkey, 48);
        const int testlen = 65;
        err = hmacInput(&amp;hmac, testarray, testlen);
        if (err != shaSuccess) {
                printf(""err 2\n"");
                exit(1);
        }
        uint8_t Message_Digest[USHAMaxHashSize];
        err = hmacResult(&amp;hmac, Message_Digest);
        if (err != shaSuccess) {
                printf(""err 3\n"");
                exit(1);
        }
        int i;
        for(i = 0; i &lt; 24; i++) printf("" %02X"", Message_Digest[i]);
        putchar('\n');
}
</code></pre>

<p>If I've done everything right (other than selecting good keys) so far, I would ordinarily have a 24-byte (i.e., 192-bit) digest, but if I digitally sign the digest prior to appending it, my experience is that the signature block isn't a predictable length.  I'm sure I could come up with any number of ways to identify the end of the message portion, but I don't want to make this a hack.  What is the accepted way of doing this?  (The signature will use ECDSA.)</p>

<p>I should also mention that this will be a multicast message using UDP inside ESP, since that puts constraints on message economy.  (That's also the main reason for the problem--keeping it binary.  The other is the practice of appending, rather than prefixing it with a byte count in front of it.)</p>
","","40","<digital-signature><hmac><digest><ecdsa>","0","","0","2016-02-22 21:05:39","","8","","1879439","","2016-02-22 21:05:39","2016-02-22 20:02:18",""
"56989912","ECDSA verification duration with mbedTLS","<p>I'm integrating mbedTLS on a project on STM32H753.
Environnement is STM32CubeIDE (arm-none-eabi-gcc). I've compiled in -Ofast.</p>

<p>I'm comparing the computation time of RSA2048 PKCS1 and ECDSA224 (curve SECP224R1) signature verification.</p>

<p>I've reused the example code from mbedTLS ( in mbedTLS\programs\pkey\ecdsa.c and rsa_verify.c ), I didn't modify anything.</p>

<p>I measured the computing time of functions <code>mbedtls_rsa_pkcs1_verify</code> and <code>mbed_ecdsa_read_signature</code> with DBG_CYCCNT and there is no exception or interrupt whatsoever. it does not include the computation of SHA256.</p>

<p>Here are the results I get:</p>

<ul>
<li><p>RSA 2048 signature verification: 850 000 cycles</p></li>
<li><p>ECDSA 224 signature verification: 200 000 000 cycles</p></li>
</ul>

<p>I can't understand the difference. I was indeed expecting a computing time slightly higher with ECDSA than with RSA. But here it's more than 200 times slower. On the other hand the signature generation is way faster with ECDSA, as expected.</p>

<p>Does it make sense ? </p>

<p>Is there a setting I could have missed that would explain the difference ?</p>
","","40","<rsa><stm32><ecdsa><mbedtls>","0","","0","2019-07-11 13:20:31","","0","1","5836577","","2019-07-11 13:20:31","2019-07-11 13:03:12",""
"55800819","Bouncycastle ECDSA signature verification is OK after signing but fails at next run when reloading public key, message and signatue","<p>I am testing a bouncy castle signature verification. Interestingly it verifies ok after the signing, but when running a new instance with the public key, message and signature if always fails. I am using the same verification routine right after signature generation and the next run which is a simple java code. (The whole story might not be relevant, but I am trying to crate a CA certificate of a javacard public key, and need to sign the resulting certificate. Right after generating the certificate and signing, the verification always passes, but when running the next instance to verify the public key certificate it fails.)
I would kindly ask for a feedback if this has happened to any one else. I am pretty much assume that the code is correct since it works right after signing.
If code is nevertheless required I will clean it up and post it, but it is similar to code examples found on the net.</p>

<pre><code>public class VerifyEccSignature {
public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException {
    boolean verify;
    Provider prov=new BouncyCastleProvider();
    Signature ecdsaSign;
    Security.addProvider(prov);

    // Card Public Key
    byte[] pubKey = HexAdapter.toBin(""04cd7a82795bf691232e409ebe10039be6167d15b07e19da0c417c830d4db8b9d8f6919113468a1f650125545cc0bca619ec3be88723889fb439b71dee3e1dbad3"");

    // Certificate to sign ()
    byte[] cert=HexAdapter.toBin(""48656C6C6F576F726C64"");

    // Signature returned by chip
    byte[] sigBytes=HexAdapter.toBin(""30450220459408F84F45A1F960C3260D8191083617C016ADC721E5162F667D8E01BAEBCD0221008BE3EFD1F09363653B699CA39174D265218911023DA0DCBD04C1F44228D5E5FD"");

    try {            
        // Get rpivate key
        KeyFactory keyFactory = KeyFactory.getInstance(""ECDSA"",prov);
        PKCS8EncodedKeySpec spec=new PKCS8EncodedKeySpec(HexAdapter.toBin(""308193020100301306072A8648CE3D020106082A8648CE3D0301070479307702010104200BF4B825E8B758853A49E01EAA45905E249B580421C7306A8EC85B4F4229675DA00A06082A8648CE3D030107A14403420004CD7A82795BF691232E409EBE10039BE6167D15B07E19DA0C417C830D4DB8B9D8F6919113468A1F650125545CC0BCA619EC3BE88723889FB439B71DEE3E1DBAD3""));
        PrivateKey priv = keyFactory.generatePrivate(spec);
        ecdsaSign = java.security.Signature.getInstance(""SHA256withECDSA"",prov);

        // Generate signature of first run
        byte[] cc=""HelloWorld"".getBytes();
        ecdsaSign.initSign(priv);
        ecdsaSign.update(cc);            
        byte[] signature=ecdsaSign.sign();
        System.out.println(""data "" + HexAdapter.toHex(cc));
        System.out.println(""signature= ""+HexAdapter.toHex(signature));

        // Convert it to export format required for Tachograph certificate
        byte[] rawSignature=VerifySignature.getRawSignature(signature);

        // Setup verifing class
        VerifySignature vv=new VerifySignature(prov);

        // Verify current run
        verify=vv.verify(pubKey, ByteBuffer.wrap(cc), rawSignature);
        System.out.println(""cc verify signature. Result: ""+verify);

        // Verify previous run whre signature is copied into cert from output of previous run
        verify=vv.verify(pubKey, ByteBuffer.wrap(cert), sigBytes);

        // Output information required for verification and to copy over to next run
        System.out.println(""pubkey ""+HexAdapter.toHex(pubKey));
        System.out.println(""cert ""+HexAdapter.toHex(cert));     
        System.out.println(""sig ""+HexAdapter.toHex(sigBytes));

    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(TestCaSignerEcc.class.getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(VerifyEccSignature.class.getName()).log(Level.SEVERE, null, ex);
    } catch (SignatureException ex) {
        Logger.getLogger(VerifyEccSignature.class.getName()).log(Level.SEVERE, null, ex);
    } catch (Exception ex) {
        Logger.getLogger(VerifyEccSignature.class.getName()).log(Level.SEVERE, null, ex);
    }

}
</code></pre>

<p>}</p>

<p>Verifying:</p>

<pre><code>public class VerifySignature {
Provider prov;
Signature ecdsaSign;

public VerifySignature(Provider prov) {
    this.prov = prov;
}

public boolean verify(byte[] pubKey, ByteBuffer plainCert, byte[] rawSignature){

    boolean verify=false;

    try {              
        ECPublicKey pp= decodeKey(prov,pubKey);

        ASN1EncodableVector v = new ASN1EncodableVector();
        v.add(/*r*/new ASN1Integer(new BigInteger(1, Arrays.copyOfRange(rawSignature,0,32))));
        v.add(/*s*/new ASN1Integer(new BigInteger(1, Arrays.copyOfRange(rawSignature,32,32*2))));
        byte[] sigDer = new DERSequence(v).getEncoded();
        System.out.println(""v ""+v);

        // Verify signature
        ecdsaSign = java.security.Signature.getInstance(""SHA256withECDSA"",prov);
        ecdsaSign.initVerify(pp);
        ecdsaSign.update(plainCert);
        verify = ecdsaSign.verify(sigDer);
        System.out.println("" - Singnature verified: ""+verify);

    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(TestCaSignerEcc.class.getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeySpecException | SignatureException | InvalidKeyException | IOException ex) {
        Logger.getLogger(VerifyEccSignature.class.getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchProviderException ex) {
        Logger.getLogger(VerifySignature.class.getName()).log(Level.SEVERE, null, ex);
    }
    return verify;
}

public static ECPublicKey decodeKey(Provider prov, byte[] encoded) throws InvalidKeySpecException, NoSuchAlgorithmException, NoSuchProviderException{
    java.security.spec.ECPoint point = new java.security.spec.ECPoint(  new BigInteger(1, Arrays.copyOfRange(encoded,1,33)), 
                                                                        new BigInteger(1, Arrays.copyOfRange(encoded,33,65))
                                                                        );

    ECNamedCurveParameterSpec params = ECNamedCurveTable.getParameterSpec(/*""secp256r1""""prime256v1*/""P-256"");
    KeyFactory fact = KeyFactory.getInstance(""ECDSA"",prov);
    ECCurve curve = params.getCurve();
    java.security.spec.EllipticCurve ellipticCurve = EC5Util.convertCurve(curve, params.getSeed());

    java.security.spec.ECParameterSpec params2=EC5Util.convertSpec(ellipticCurve, params);
    java.security.spec.ECPublicKeySpec keySpec = new java.security.spec.ECPublicKeySpec(point,params2);
    ECPublicKey pubKey=(ECPublicKey) fact.generatePublic(keySpec);
    return pubKey;
}

private static ASN1Primitive toAsn1Primitive(byte[] data) throws Exception
{
    try (ByteArrayInputStream inStream = new ByteArrayInputStream(data);
            ASN1InputStream asnInputStream = new ASN1InputStream(inStream);) 
    {
        return asnInputStream.readObject();
    }
}

public static byte[] getRawSignature(byte[] signed)throws Exception{
        ASN1Primitive asn1 = toAsn1Primitive(signed);
        byte[] rawSignature=new byte[0x40];
        byte[] tt;
        int ptr=0;
        if (asn1 instanceof ASN1Sequence) {
            ASN1Sequence asn1Sequence = (ASN1Sequence) asn1;
            ASN1Encodable[] asn1Encodables = asn1Sequence.toArray();
            for (ASN1Encodable asn1Encodable : asn1Encodables) {
                ASN1Primitive asn1Primitive = asn1Encodable.toASN1Primitive();
                if (asn1Primitive instanceof ASN1Integer) {
                    ASN1Integer asn1Integer = (ASN1Integer) asn1Primitive;
                    BigInteger integer = asn1Integer.getValue();
                    tt=BigIntegers.asUnsignedByteArray(asn1Integer.getValue());
                    System.arraycopy(tt, 0, rawSignature, ptr,  0x20);
                    ptr+=0x20;
                }
            }
        }
    return rawSignature;
}
</code></pre>

<p>}</p>
","<p>Sorry to bother you all. 
It seems I have been injecting the signature directly, intsead of converting it to raw format before converting it back to ASN1 during verification. My oversight. 
Peter</p>
","40","<java><signature><verify><ecdsa>","-1","0","1","2019-04-22 21:40:02","","2","","11396626","","2019-04-22 21:31:37","2019-04-22 20:37:20",""
"58361756","How to validate a signature in Java if the public key's algorithm is EC?","<p>Given an X509 certificate object of a person. (The object's type is sun.security.x509.X509CertImpl). This person signed a String with his private key. Given the signature that was made by this person, when he signed the above mentioned String object.</p>

<p>My task is to verify this signature, but have difficulties with it.</p>

<p>When I try to verify the signature with the below code:</p>

<pre><code>    ...
    X509Certificate x509Certificate = getCertificate(certificate);

    Signature signature = Signature.getInstance(""SHA256withECDSA"");

    signature.initVerify(x509Certificate.getPublicKey());

    signature.update(unsignedData);
    boolean bool = signature.verify(signatureToVerify);
    System.out.println(""The signature is "" + (bool ? """" : ""NOT"") + "" valid"");
</code></pre>

<p>I get <code>java.security.SignatureException: Could not verify signature</code></p>

<p>Do you have an idea, how can I make it working?</p>

<p><strong>Edited:</strong>
At the end, I managed to make it working, but do not understand the reason yet:
Before passing the signature to the verify method, i needed to do the following modification on it:</p>

<pre><code>    byte[] rBytes = Arrays.copyOfRange(signatureHash, 0, 32);
    byte[] sBytes = Arrays.copyOfRange(signatureHash, 32, 64);

    BigInteger r = new BigInteger(1, rBytes);
    BigInteger s = new BigInteger(1, sBytes);

    ASN1Integer asn1R = new ASN1Integer(r);
    ASN1Integer asn1S = new ASN1Integer(s);

    DERSequence seq = new DERSequence(new ASN1Integer[]{asn1R, asn1S});
    byte[] signatureToVerify2 = seq.getEncoded();
    // verifying the signatureToVerify2 instead of the original brings success
    boolean bool = signature.verify(signatureToVerify2);
</code></pre>
","<p>Here is a (semi)working app for further reference that verifies a signature, when ECDSA is involved in the story:</p>

<pre><code>import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.DERSequence;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Arrays;

public class SignatureTest {

    public static void main(String[] args) throws CertificateException, InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException {
        byte[] certificateAsByteArray = ...;
        byte[] dataToVerifyAsByteArray = ...;
        byte[] signatureHashAsByteArray = ...;

        CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
        InputStream in = new ByteArrayInputStream(certificateBytes);
        X509Certificate x509Certificate = (X509Certificate) certFactory.generateCertificate(in);

        Signature signature = Signature.getInstance(""SHA256withECDSA"");

        signature.initVerify(x509Certificate.getPublicKey());

        signature.update(dataToVerifyAsHexaString);

        byte[] rBytes = Arrays.copyOfRange(signatureHash, 0, 32);
        byte[] sBytes = Arrays.copyOfRange(signatureHash, 32, 64);

        ASN1Integer asn1R = new ASN1Integer(rBytes);
        ASN1Integer asn1S = new ASN1Integer(sBytes);

        DERSequence seq = new DERSequence(new ASN1Integer[] {asn1R, asn1S});

        boolean isSignatureOK = signature.verify(seq.getEncoded());

        System.out.println(""The signature is "" + (isSignatureOK ? """" : ""NOT "") + ""VALID"");
    }
}
</code></pre>
","40","<java><signature><public-key><elliptic-curve><ecdsa>","1","0","1","2019-10-14 13:47:57","58378193","9","","1203728","","2019-10-14 13:30:42","2019-10-13 08:19:00",""
"54056902","How to fix this issue of adding two points in curve secp256k1 of ECDSA?","<p>I got this error:
ava.lang.ClassCastException:            org.bouncycastle.math.ec.ECFieldElement$Fp cannot be cast to org.bouncycastle.math.ec.custom.sec.SecP256K1FieldElement</p>

<p>once trying to read a public key as a string in android which is retrieved from .pem file as </p>

<p>-----BEGIN PUBLIC KEY-----\n
MIH1MIGuBgcqhkjOPQIBMIGiAgEBMCwGByqGSM49AQECIQD/////////////////
///////////////////+///8LzAGBAEABAEHBEEEeb5mfvncu6xVoGKVzocLBwKb
/NstzijZWfKBWxb4F5hIOtp3JqPEZV2k+/wOEQio/Re0SKaFVBmcR9CP+xDUuAIh
AP////////////////////66rtzmr0igO7/SXozQNkFBAgEBA0IABK5F1KgwnBG3
jVLqtqJ9+uesDOzP00s88bgGyYQen86xLn1iUJxy/qPPmn9WZyfQ+b27UaHNAa09
83BuGKHERAE=
\n-----END PUBLIC KEY-----</p>

<p>This key from type secp256k1 </p>

<p>and this is the code part of reading a public key :</p>

<pre><code>       Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);

       Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());                                                
        Reader rdr = new StringReader (keys[seletedTFE]);
        Object parsed = new     org.bouncycastle.openssl.PEMParser(rdr).readObject();
        ECPublicKey key = (ECPublicKey) new    org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter().getPublicKey((Subje.ctPublicKeyInfo) parsed);

         ECPoint P = key.getQ();
</code></pre>

<p>and the error because of this point: of adding C1 with C2 and it says that C2 of type ECpointfp while C2 of type ECElementFieldsecp256k1</p>

<pre><code>     ECPoint C1;
     ECPoint C2;
     ECPoint C3;
     C2 = P.multiply(beta);
     C3 = C1.add(C2)   ;                    
</code></pre>

<p>and this code works with prime256v1 and secp256r1 ,but I need to use secp256k1,so  how to solve this issue ?</p>
","","38","<android><ecdsa>","1","","0","2019-01-05 22:34:03","","0","","","","","2019-01-05 22:34:03",""
"57894607","Is my leaf certificate truly invalid, or am I using `openssl verify` incorrectly?","<p>I <em>thought</em> I created my leaf certificate (<code>device.cert.pem</code>) correctly but it's not validating correctly with my software. I'm therefore trying to use OpenSSL on the command-line to verify said certificate before I debug my software any further.</p>

<p>The chain is: root (CN=Halo HSM CA) signs signer (CN=Halo Signing Server 0003) signs device (CN=Halo).</p>

<p>Here's how I'm invoking OpenSSL on the command line:</p>

<pre><code>$ openssl verify -show_chain -trusted &lt;path&gt;/devel_root.cert.pem signing_server.curly-0003.cert.pem device.cert.pem 
signing_server.curly-0003.cert.pem: OK
Chain:
depth=0: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo Signing Server 0003 (untrusted)
depth=1: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo HSM CA
C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo
error 20 at 0 depth lookup: unable to get local issuer certificate
error device.cert.pem: verification failed
</code></pre>

<p>And the root cert:</p>

<pre><code>$ openssl x509 -in &lt;path&gt;/devel_root.cert.pem -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            4e:81:59:83:f3:e5:3d:ff:70:ed:92:b4:48:9a:d3:64:5a:bf:1c:82
        Signature Algorithm: ecdsa-with-SHA256
        Issuer: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo HSM CA
        Validity
            Not Before: Sep  6 22:09:48 2019 GMT
            Not After : Oct  6 22:09:48 2019 GMT
        Subject: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo HSM CA
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:a3:8a:fd:87:aa:36:67:5c:e0:f7:49:5c:cd:4e:
                    86:96:53:9a:5a:9f:23:a3:3b:67:e2:76:87:e6:b6:
                    ab:ea:fc:2f:46:24:d7:7a:ce:ee:76:da:42:b4:e6:
                    a4:8b:48:d4:c7:59:cc:01:62:08:37:3f:ec:30:55:
                    76:3d:19:7b:c2
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                E0:1D:B4:40:9A:BA:F3:3F:ED:AC:6B:33:F4:8D:60:CE:C3:05:89:EA
            X509v3 Authority Key Identifier: 
                keyid:E0:1D:B4:40:9A:BA:F3:3F:ED:AC:6B:33:F4:8D:60:CE:C3:05:89:EA

            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:1
            X509v3 Key Usage: 
                Certificate Sign, CRL Sign
    Signature Algorithm: ecdsa-with-SHA256
         30:44:02:20:2b:48:6e:f2:ec:76:ad:88:85:52:74:fe:45:c8:
         93:7e:bc:4c:b6:d8:37:ff:26:fa:05:91:2c:13:a6:7c:e3:cc:
         02:20:61:7c:e1:23:8d:c6:93:b5:4e:c8:4b:46:8e:02:1f:67:
         04:82:a6:b0:98:b5:4b:09:7d:05:0c:aa:22:b2:16:01
-----BEGIN CERTIFICATE-----
MIICLjCCAdWgAwIBAgIUToFZg/PlPf9w7ZK0SJrTZFq/HIIwCgYIKoZIzj0EAwIw
ZTELMAkGA1UEBhMCVVMxFTATBgNVBAgMDFBlbm5zeWx2YW5pYTENMAsGA1UEBwwE
WW9yazEaMBgGA1UECgwRUmVkIExpb24gQ29udHJvbHMxFDASBgNVBAMMC0hhbG8g
SFNNIENBMB4XDTE5MDkwNjIyMDk0OFoXDTE5MTAwNjIyMDk0OFowZTELMAkGA1UE
BhMCVVMxFTATBgNVBAgMDFBlbm5zeWx2YW5pYTENMAsGA1UEBwwEWW9yazEaMBgG
A1UECgwRUmVkIExpb24gQ29udHJvbHMxFDASBgNVBAMMC0hhbG8gSFNNIENBMFkw
EwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEo4r9h6o2Z1zg90lczU6GllOaWp8joztn
4naH5rar6vwvRiTXes7udtpCtOaki0jUx1nMAWIINz/sMFV2PRl7wqNjMGEwHQYD
VR0OBBYEFOAdtECauvM/7axrM/SNYM7DBYnqMB8GA1UdIwQYMBaAFOAdtECauvM/
7axrM/SNYM7DBYnqMBIGA1UdEwEB/wQIMAYBAf8CAQEwCwYDVR0PBAQDAgEGMAoG
CCqGSM49BAMCA0cAMEQCICtIbvLsdq2IhVJ0/kXIk368TLbYN/8m+gWRLBOmfOPM
AiBhfOEjjcaTtU7IS0aOAh9nBIKmsJi1Swl9BQyqIrIWAQ==
-----END CERTIFICATE-----
</code></pre>

<p>And the signing cert</p>

<pre><code>$ openssl x509 -in signing_server.curly-0003.cert.pem -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            4e:3a:0c:d6:4d:64:d7:15:19:ee:f2:05:1b:99:0f:74
        Signature Algorithm: ecdsa-with-SHA256
        Issuer: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo HSM CA
        Validity
            Not Before: Sep 10 19:00:00 2019 GMT
            Not After : Dec 31 23:59:59 9999 GMT
        Subject: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo Signing Server 0003
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:14:df:32:ce:4f:a6:4d:9c:08:7d:35:d6:57:1a:
                    b6:95:07:7c:5e:72:d1:68:5a:ba:9e:28:47:62:fa:
                    ee:3a:04:19:03:86:7e:41:7b:8b:7d:33:8a:6f:3f:
                    88:27:6c:89:fc:9a:cd:c5:26:72:53:cc:92:b4:41:
                    5e:ad:c2:c0:e6
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:0
            X509v3 Key Usage: critical
                Digital Signature, Certificate Sign, CRL Sign
            X509v3 Subject Key Identifier: 
                57:55:32:18:99:54:20:30:1C:73:6F:08:46:0C:C9:86:EC:F6:E8:DB
            X509v3 Authority Key Identifier: 
                keyid:E0:1D:B4:40:9A:BA:F3:3F:ED:AC:6B:33:F4:8D:60:CE:C3:05:89:EA

    Signature Algorithm: ecdsa-with-SHA256
         30:45:02:20:73:f5:44:7b:be:b1:62:c5:89:28:f4:94:5a:85:
         f3:c1:67:60:c9:4a:63:f2:f5:4b:5d:f1:1a:26:89:5d:e2:04:
         02:21:00:b7:14:5f:30:e8:b9:24:4b:0f:73:9b:94:3c:a0:25:
         de:35:59:5d:c1:fd:af:76:25:81:13:0d:02:d8:95:aa:ef
-----BEGIN CERTIFICATE-----
MIICPTCCAeOgAwIBAgIQTjoM1k1k1xUZ7vIFG5kPdDAKBggqhkjOPQQDAjBlMQsw
CQYDVQQGEwJVUzEVMBMGA1UECAwMUGVubnN5bHZhbmlhMQ0wCwYDVQQHDARZb3Jr
MRowGAYDVQQKDBFSZWQgTGlvbiBDb250cm9sczEUMBIGA1UEAwwLSGFsbyBIU00g
Q0EwIBcNMTkwOTEwMTkwMDAwWhgPOTk5OTEyMzEyMzU5NTlaMHIxCzAJBgNVBAYT
AlVTMRUwEwYDVQQIDAxQZW5uc3lsdmFuaWExDTALBgNVBAcMBFlvcmsxGjAYBgNV
BAoMEVJlZCBMaW9uIENvbnRyb2xzMSEwHwYDVQQDDBhIYWxvIFNpZ25pbmcgU2Vy
dmVyIDAwMDMwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQU3zLOT6ZNnAh9NdZX
GraVB3xectFoWrqeKEdi+u46BBkDhn5Be4t9M4pvP4gnbIn8ms3FJnJTzJK0QV6t
wsDmo2YwZDASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIBhjAdBgNV
HQ4EFgQUV1UyGJlUIDAcc28IRgzJhuz26NswHwYDVR0jBBgwFoAU4B20QJq68z/t
rGsz9I1gzsMFieowCgYIKoZIzj0EAwIDSAAwRQIgc/VEe76xYsWJKPSUWoXzwWdg
yUpj8vVLXfEaJold4gQCIQC3FF8w6LkkSw9zm5Q8oCXeNVldwf2vdiWBEw0C2JWq
7w==
-----END CERTIFICATE-----
</code></pre>

<p>And the device cert</p>

<pre><code>$ openssl x509 -in device.cert.pem -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            46:f1:16:55:c4:bb:56:27:ab:36:75:00:7e:bb:60:b1
        Signature Algorithm: ecdsa-with-SHA256
        Issuer: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo Signing Server 0003
        Validity
            Not Before: Sep 10 19:00:00 2019 GMT
            Not After : Dec 31 23:59:59 3000 GMT
        Subject: C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:2b:dd:82:0b:59:e3:d7:c1:04:ce:d4:9c:bb:74:
                    4c:94:5c:c7:9f:41:21:b8:24:96:39:9c:43:ea:dc:
                    6a:31:7b:58:54:ee:c2:a9:b7:0f:ea:34:ef:72:45:
                    cd:2e:2e:d7:1f:0a:74:eb:79:2d:e0:5d:16:ab:89:
                    5e:a3:52:99:7a
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Authority Key Identifier: 
                keyid:A7:A9:0B:27:B4:0D:28:84:26:F0:64:70:B5:27:DD:0B:05:4A:25:46

            X509v3 Subject Key Identifier: 
                7E:0E:12:66:F0:CA:6C:D2:53:C3:0D:D3:40:6B:33:9A:91:C0:44:94
    Signature Algorithm: ecdsa-with-SHA256
         30:45:02:21:00:89:00:7e:64:03:1c:c3:8a:b1:17:30:ee:7b:
         29:41:15:95:8e:1d:98:49:87:16:67:b8:4c:fc:d4:dc:d5:af:
         c6:02:20:37:c8:09:39:ec:75:e2:4c:68:b5:b0:06:00:12:e8:
         61:57:8b:57:ce:1e:7b:b4:81:cb:e2:c0:1f:de:b5:0c:cf
-----BEGIN CERTIFICATE-----
MIICEjCCAbigAwIBAgIQRvEWVcS7VierNnUAfrtgsTAKBggqhkjOPQQDAjByMQsw
CQYDVQQGEwJVUzEVMBMGA1UECAwMUGVubnN5bHZhbmlhMQ0wCwYDVQQHDARZb3Jr
MRowGAYDVQQKDBFSZWQgTGlvbiBDb250cm9sczEhMB8GA1UEAwwYSGFsbyBTaWdu
aW5nIFNlcnZlciAwMDAzMCAXDTE5MDkxMDE5MDAwMFoYDzMwMDAxMjMxMjM1OTU5
WjBeMQswCQYDVQQGEwJVUzEVMBMGA1UECAwMUGVubnN5bHZhbmlhMQ0wCwYDVQQH
DARZb3JrMRowGAYDVQQKDBFSZWQgTGlvbiBDb250cm9sczENMAsGA1UEAwwESGFs
bzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCvdggtZ49fBBM7UnLt0TJRcx59B
IbgkljmcQ+rcajF7WFTuwqm3D+o073JFzS4u1x8KdOt5LeBdFquJXqNSmXqjQjBA
MB8GA1UdIwQYMBaAFKepCye0DSiEJvBkcLUn3QsFSiVGMB0GA1UdDgQWBBR+DhJm
8Mps0lPDDdNAazOakcBElDAKBggqhkjOPQQDAgNIADBFAiEAiQB+ZAMcw4qxFzDu
eylBFZWOHZhJhxZnuEz81NzVr8YCIDfICTnsdeJMaLWwBgAS6GFXi1fOHnu0gcvi
wB/etQzP
-----END CERTIFICATE-----
</code></pre>

<p>I've also tried combining the root and intermediate certs into a single file and using the <code>-CAfile</code> argument, but that yields the same result.</p>

<pre><code>$ cp &lt;path&gt;/devel_root.cert.pem trusted_certs.txt
$ cat signing_server.curly-0003.cert.pem &gt;&gt; trusted_certs.txt 
$ openssl verify -show_chain -CAfile trusted_certs.txt device.cert.pem 
C = US, ST = Pennsylvania, L = York, O = Red Lion Controls, CN = Halo
error 20 at 0 depth lookup: unable to get local issuer certificate
error device.cert.pem: verification failed
</code></pre>
","<p>At minimum, your device certificate has the wrong authority key identifier for the certificate you claim issued it.</p>

<p>The issuing CA:</p>

<blockquote>
<pre><code>    X509v3 extensions:
        X509v3 Basic Constraints: critical
            CA:TRUE, pathlen:0
        X509v3 Key Usage: critical
            Digital Signature, Certificate Sign, CRL Sign
        X509v3 Subject Key Identifier: 
            57:55:32:18:99:54:20:30:1C:73:6F:08:46:0C:C9:86:EC:F6:E8:DB
</code></pre>
</blockquote>

<p>57:55:32:...</p>

<p>The device certificate:</p>

<blockquote>
<pre><code>    X509v3 extensions:
        X509v3 Authority Key Identifier: 
            keyid:A7:A9:0B:27:B4:0D:28:84:26:F0:64:70:B5:27:DD:0B:05:4A:25:46
</code></pre>
</blockquote>

<p>A7:A9:0B:...</p>

<p>Since the device certificate Authority Key Identifier does not match the issuing CA Subject Key Identifier, the issuing CA certificate is eliminated as a candidate.</p>
","38","<openssl><ssl-certificate><ecdsa>","0","0","1","2019-09-12 15:00:49","57909559","3","","2784641","","2019-09-11 20:32:33","2019-09-11 18:07:45",""
"55407006","Cannot correctly encode string when reading from text file (encoding into sha256...)","<p>Basically what I want to accomplish (simplified...):</p>

<p>I want to make 100 bitcoin addresses from my own password that look kind of like:</p>

<p>password_1
password_2
password_3</p>

<p>So when I do this in the program, I am getting the correct result: </p>

<pre><code>def public_key(src):
    privatekey = (int(hashlib.sha256(src).hexdigest(), 16))
    return generate_address(privatekey)
def private_key(src):
    privatekey = hashlib.sha256(src).hexdigest()
    return str(privatekey)
herewego = ""password_1"".encode('utf-8')
somevariable = public_key(herewego)
print somevariable 
</code></pre>

<p>^ This works as intended...but if I put ""password_1"" in a txt file and try to read this line, it gives totally different result? </p>

<pre><code>for addr in file:
 address =  addr.encode('utf-8')
 print public_key(address)
</code></pre>

<p>So the issue is obviously that Notepad encodes the text file in say ansi or utf-8, it doesn't matter but the line read from there must be looking different to python than when I enter the "" ...."" within python? So what coding to use or if it's impossible: what alternative to Notepad? This is for Python 2.7 in windows by the way.</p>
","<p>There might be newline characters, you could try </p>

<pre><code>for addr in file:
address =  addr.rstrip('\n').encode('utf-8')
print public_key(address)
</code></pre>
","37","<python><blockchain><bitcoin><sha256><ecdsa>","1","0","1","2019-03-28 21:33:33","55407176","0","","","","","2019-03-28 21:19:56",""
"58432805","iOS FIDO2 BLE Authenticator: Invalid encoding for signature","<p>I'm developing an iOS BLE authenticator. As of now, I can register using NONE attestation. When I try to authenticate getting ""Invalid encoding for signature"".</p>

<p>As I want to do NONE and SURROGATE,  followed <a href=""https://www.w3.org/TR/webauthn/"" rel=""nofollow noreferrer"">https://www.w3.org/TR/webauthn/</a> section 6.4.5. Signature Formats for Packed Attestation, FIDO U2F Attestation, and Assertion Signatures. It states the following things,</p>

<p>For COSEAlgorithmIdentifier -7 (ES256), and other ECDSA-based algorithms, a signature value is encoded as an ASN.1 DER Ecdsa-Sig-Value, as defined in [RFC3279] section 2.2.3.</p>

<pre><code>    Example:
    30 44; SEQUENCE (68 Bytes)             02 20; INTEGER (32 Bytes)
        |  3d 46 28 7b 8c 6e 8c 8c  26 1c 1b 88 f2 73 b0 9a
        |  32 a6 cf 28 09 fd 6e 30  d5 a7 9f 26 37 00 8f 54
        02 20                            ; INTEGER (32 Bytes)
        |  4e 72 23 6e a3 90 a9 a1  7b cf 5f 7a 09 d6 3a b2
        |  17 6c 92 bb 8e 36 c0 41  98 a2 7b 90 9b 6e 8f 13
</code></pre>

<p><strong>My iOS encoded signature:</strong>
30450221008dec31cc36160522df4419935dd0aa6b5c198b946a90b19a47fd8927d57ceb6502201de973a69e7927e7eadace24bf7de352f38f5e0280c2364f3c108d28ec1d7fa1</p>

<p><strong>Android encoded signature:</strong>
304502200ea2e7de7c97c4594148b9a0bc6bd8dcffdf3a5e4cbab2d20f186039768db75d022100e627ac5c71c082f85d5bea2afd212fddd80438e5cfebf1d3d02e149512ebc528</p>

<p>When I pass the android signature to Java server, it is verified successfully. But iOS always throws the following error.</p>

<pre><code>at com.xxx.fido2.processor.TestSignature.main(TestSignature.java:21) . 
Caused by: java.security.SignatureException: Invalid encoding for signature . 
at sun.security.ec.ECDSASignature.decodeSignature(ECDSASignature.java:468) . 
Caused by: java.security.SignatureException: Invalid encoding for signature . 

at sun.security.ec.ECDSASignature.engineVerify(ECDSASignature.java:390) . 
... 4 more . 
Caused by: java.io.IOException: Sequence tag error . 
Caused by: java.io.IOException: Sequence tag error . 
Caused by: java.security.SignatureException: Invalid encoding for signature . 

at sun.security.ec.ECDSASignature.engineVerify(ECDSASignature.java:390) . 
... 4 more . 
Caused by: java.io.IOException: Sequence tag error . 
Caused by: java.io.IOException: Sequence tag error .
</code></pre>

<p>Any help would be appreciated. Thanks in advance.</p>
","","37","<ios><ecdsa><webauthn><fido>","0","","0","2019-10-21 16:29:25","","0","1","","","","2019-10-17 12:35:08",""
"55225677","C# BouncyCastle-How can I create a sha512ECDSA certificate and a valid certificate revocation list for this certificate?","<p>How can I create a sha512ECDSA certificate and a valid certificate revocation list for this certificate using the latest version of BouncyCastle? I did not find any hints and the documentation does not seem to be well maintained either...</p>
","<p>I did this now using OpenSSL directly. Here you can see the result: <a href=""https://gist.github.com/SeppPenner/2e423b06904615255c05fe9056e8704b"" rel=""nofollow noreferrer"">https://gist.github.com/SeppPenner/2e423b06904615255c05fe9056e8704b</a></p>
","35","<c#><certificate><bouncycastle><sha512><ecdsa>","0","0","1","2019-03-19 13:10:05","","3","1","","","","2019-03-18 16:14:25",""
"58338993","Application crashes when signing message with Crypto++ ECDSA under Xcode?","<p>I am performing ECDSA signing on Mac OS with Crypto++. The command line is OK, but under Xcode <code>EXC_BAD_ACCESS</code> error occurs on signing message.</p>

<p>The tests in <code>cryptest.exe</code> from the command line passes. <code>cryptest.exe</code> is the library's validation program.</p>

<p>I have tried to build the library using clang++ and libc++, and build it with XCode, all have this issue.</p>

<pre><code>clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -DCRYPTOPP_DISABLE_MIXED_ASM -fPIC -pthread -pipe -c 
</code></pre>

<p>Here is the code.</p>

<pre><code>AutoSeededRandomPool prng;

ECDSA&lt;ECP, SHA256&gt;::PrivateKey k1;   
k1.Initialize( prng, ASN1::secp256r1() );

ECDSA&lt;ECP, SHA256&gt;::PublicKey pKey;
k1.MakePublicKey( pKey );

const ECP::Point&amp; q = pKey.GetPublicElement();    
const Integer&amp; qx = q.x;
const Integer&amp; qy = q.y;

std::cout &lt;&lt; ""x: "" &lt;&lt; std::hex &lt;&lt; qx &lt;&lt; std::endl;    
std::cout &lt;&lt; ""y: "" &lt;&lt; std::hex &lt;&lt; qy &lt;&lt; std::endl;

const Integer&amp; x = k1.GetPrivateExponent();
std::cout &lt;&lt; ""K1: "" &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;

ByteQueue queue;
k1.Save(queue);

ECDSA&lt;ECP, SHA256&gt;::Signer signer(k1);

std::string message = ""Do or do not. There is no try."";
size_t siglen = signer.MaxSignatureLength();
std::string signature(siglen, 0x00);

siglen = signer.SignMessage( prng, (const byte*)&amp;message[0], message.size(), (byte*)&amp;signature[0] );
signature.resize(siglen);
</code></pre>

<p>I'm attaching stack trace below:</p>

<pre><code>* thread #1: tid = 0x15fc20, 0x00007fff910a9d26 libsystem_platform.dylib`_platform_bzero$VARIANT$Merom + 22, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
  frame #0: 0x00007fff910a9d26 libsystem_platform.dylib`_platform_bzero$VARIANT$Merom + 22  
* frame #1: 0x00000001000ccc23 testCrypto`CryptoPP::DL_SignatureMessageEncodingMethod_DSA::ComputeMessageRepresentative(this=&lt;unavailable&gt;, rng=&lt;unavailable&gt;, recoverableMessage=&lt;unavailable&gt;,   
  recoverableMessageLength=&lt;unavailable&gt;, hash=0x0000000104e7df30, hashIdentifier=&lt;unavailable&gt;, messageEmpty=false, representative=0x0000000000000000, representativeBitLength=&lt;unavailable&gt;) const + 83 at gfpcrypt.cpp:96  
  frame #2: 0x0000000100019ae8 testCrypto`CryptoPP::DL_VerifierBase&lt;CryptoPP::EC2NPoint&gt;::VerifyAndRestart(this=0x00007fff5fbfdab8, messageAccumulator=0x0000000104e7de40) const + 568 at pubkey.h:1693 
  frame #3: 0x0000000100034c1e testCrypto`CryptoPP::PK_Verifier::VerifyMessage(this=0x00007fff5fbfdab8, message=&lt;unavailable&gt;, messageLen=&lt;unavailable&gt;, signature=&lt;unavailable&gt;, signatureLen=&lt;unavailable&gt;) const + 94 at cryptlib.cpp:942
  frame #4: 0x000000010000464a testCrypto`ValidateECDSA() + 2762 at main.cpp:257
  frame #5: 0x0000000100004a35 testCrypto`main(argc=1, argv=0x00007fff5fbff9e0) + 53 at main.cpp:272
  frame #6: 0x00007fff8fec95c9 libdyld.dylib`start + 1
</code></pre>
","<p>I use Xcode to build the project to create a library, then can call the library without errors.</p>
","35","<xcode><macos><crypto++><ecdsa>","1","0","1","2019-10-21 08:48:05","","4","","608639","","2019-10-16 10:59:46","2019-10-11 10:08:59",""
"58482869","What is the correct way to use ECDSA in Crypto++","<p>When I verify a signature using ECDSA verifier in Crypto++, if the public key is incorrect the method just crash the application. Should I try catch the exception? What is the best way to handle this?</p>

<p>Thanks!</p>
","<blockquote>
  <p>... should I try catch the exception? What is the best way to handle this?</p>
</blockquote>

<p>It depends on how you want to do it. I think there are three options.</p>

<p>The information below is from <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">Elliptic Curve Digital Signature Algorithm</a> and <a href=""https://www.cryptopp.com/wiki/SignatureVerificationFilter"" rel=""nofollow noreferrer"">SignatureVerificationFilter</a> on the Crypto++ wiki.</p>

<p>First, you can catch the <code>SignatureVerificationFailed</code> exception if you like:</p>

<pre class=""lang-cpp prettyprint-override""><code>try
{
    DSA::Verifier verifier(publicKey);
    StringSource ss2(message+signature, true,
        new SignatureVerificationFilter(
            verifier, NULL, THROW_EXCEPTION
            /* SIGNATURE_AT_END */
       )
    );

    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;
}
catch (SignatureVerificationFailed&amp; ex)
{
    std::cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; std::endl;
}
</code></pre>

<p>Second, you can get the result as a boolean value. Notice lack of <code>THROW_EXCEPTION</code>:</p>

<pre class=""lang-cpp prettyprint-override""><code>bool result = false;
StringSource ss(message+signature, true,
    new SignatureVerificationFilter(
        verifier,
        new ArraySink(
            (byte*)&amp;result, sizeof(result)),
        PUT_RESULT | SIGNATURE_AT_END
   )
);

if(result)
    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;
else
    std::cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; std::endl;
</code></pre>

<p>Third, you can forgo pipelines and just call <code>VerifyMessage</code> on the <code>Verifier</code> object:</p>

<pre class=""lang-cpp prettyprint-override""><code>bool result = verifier.VerifyMessage(ConstBytePtr(message), BytePtrSize(message), ConstBytePtr(signature), BytePtrSize(signature));
if(result)
    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;
else
    std::cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; std::endl;
</code></pre>
","34","<c++><crypto++><ecdsa>","1","0","1","2019-10-21 16:28:37","58486296","1","","608639","","2019-10-21 12:27:42","2019-10-21 08:54:46",""
"57218017","How to Ethereum wallet address generated by derived ECDSA Public key in Android","<p>I'm new to Ethereum and for learning purposes,How to Ethereum wallet address generated by derived ECDSA Public key in Android .</p>
","","32","<android><ethereum><ecdsa>","1","","0","2019-07-26 10:43:40","","1","","1000551","","2019-07-26 10:43:40","2019-07-26 10:20:57",""
"56865047","How to use my pkcs#8 file to get ecdsa string","<p>I am trying to get a signature string locally from the file PKCS#8 file which is in .p8 format. When I open it I can see a string between the statement</p>

<pre><code> -----BEGIN PRIVATE KEY-----
// strings line 64 characters
// strings line 64 characters
// strings line 64 characters
// strings line 8 characters
-----END PRIVATE KEY-----
</code></pre>

<p>I want to convert this file and sign in ecdsa to get the signature.</p>

<p>How can I achieve this in c language using openssl</p>
","<p>Read the key data from your PKCS#8 file using <code>PEM_read_PrivateKey()</code> (or <code>PEM_read_bio_PrivateKey()</code>. This will give you the key as an <code>EVP_PKEY</code> object. Documentation for those functions is here:</p>

<p><a href=""https://www.openssl.org/docs/man1.1.1/man3/PEM_read_PrivateKey.html"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/man1.1.1/man3/PEM_read_PrivateKey.html</a></p>

<p>Typically when signing you normally want to digest the data to be signed first using some digest function (e.g. SHA256) followed by the signature operation (ECDSA in this case). Assuming that's what you want to do you should use the <code>EVP_DigestSign*</code> family of functions. Documentation for those functions is here:</p>

<p><a href=""https://www.openssl.org/docs/man1.1.1/man3/EVP_DigestSign.html"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/man1.1.1/man3/EVP_DigestSign.html</a></p>

<p>The code might look something like this (untested):</p>

<pre><code>EVP_PKEY *pkey = PEM_read_PrivateKey(myfile, NULL, NULL, NULL);
EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
size_t siglen = 0;
unsigned char *sig;

if (mdctx == NULL || pkey == NULL)
    goto err;

if (!EVP_DigestSignInit(mdctx, NULL, EVP_sha256(), NULL, pkey))
    goto err;

 if(!EVP_DigestSignUpdate(mdctx, tobesigned, tobesignedlen))
    goto err;

 /* Find out the signature length */
 if(!EVP_DigestSignFinal(mdctx, NULL, &amp;siglen))
    goto err;

 /* Allocate memory for the signature length */
 sig = OPENSSL_malloc(siglen);
 if (sig == NULL)
     goto err;

 /* Now get the signature */
 if(!EVP_DigestSignFinal(mdctx, sig, &amp;siglen))
     goto err;

 EVP_MD_CTX_free(mdctx);
 EVP_PKEY_free(pkey);
/* Free ""sig"" when you've finished with it */
</code></pre>
","31","<c><openssl><ecdsa>","0","1","1","2019-07-03 08:50:17","","0","","","","","2019-07-03 07:28:18",""
"53466649","How to automate ssh ECDSA key update when needed or avoid remote host identification changed messages?","<p>I am looking for a way to ease ECDSA key update on my lan as I have a local environment with very high recycle rate on VMs (cloud provisioning and PXE baremetal provisioning).</p>

<p>I do not not want to disable completely the SSH key verification as this would impose risks.</p>

<p>Still I do want to either make ssh prompt me about the key change and allow me to press ""y"" to fix it or fully automate it based on the IP subnet. </p>

<p>Another aproach that I am consiring is if it would be possible to assure that the ECDSA keys survive between reprovisionign of the machines via kickstart install scripts... mainly how big of an issue it would be to hardcode the key and share it betwen instances (or something similar).</p>

<p>This is a home-office development-testing environment so security requirements are lesser than on production but still I do not want to fully downgrate the security just to accomodate this issue. </p>
","","31","<security><ssh><ecdsa>","0","","0","2018-11-25 10:38:04","","0","","","","","2018-11-25 10:38:04",""
"57522698","Javascript convert ECDH keys into ECDSA keys","<p>I generate the ECDH keys in this way</p>

<pre><code>let _this = this;
window.crypto.subtle.generateKey(
        {
            name: ""ECDH"",
            namedCurve: ""P-256"", // the curve name
        },
        true, // &lt;== Here if you want it to be exportable !!
        [""deriveKey"", ""deriveBits""] // usage
    )
    .then(key =&gt; {
        _this.keys = key;
        // export
        return window.crypto.subtle.exportKey(
            ""raw"", //can be ""jwk"" (public or private), ""raw"" (public only), ""spki"" (public only), or ""pkcs8"" (private only)
            _this.keys.publicKey
        )
        .then(rawPublicKey =&gt; {
            _this.publicKey = rawPublicKey;
            return rawPublicKey;
        })
    })
</code></pre>

<p>In this way i have the cryptokeys and the raw (x,y coords) public key.<br>
I would use the keys for using it for ECDSA</p>

<p>How can I do that?</p>
","<pre><code>window.crypto.subtle.generateKey({
                name: ""ECDSA"",
                namedCurve: curve, //can be ""P-256"", ""P-384"", or ""P-521""
            },
            true, //whether the key is extractable (i.e. can be used in exportKey)
            [""sign"", ""verify""] //can be any combination of ""sign"" and ""verify""
        )
        .then(function(key) {

        publicKey = key.publicKey;
        privateKey = key.privateKey;
        // For Demo Purpos Only Exported in JWK format
        window.crypto.subtle.exportKey(""jwk"", key.publicKey).then(
            function(keydata) {
                publicKeyhold = keydata;
                publicKeyJson = JSON.stringify(publicKeyhold);
                document.getElementById(""ecdsapublic"").value = publicKeyJson;
            }
        );

        window.crypto.subtle.exportKey(""jwk"", key.privateKey).then(
            function(keydata) {
                privateKeyhold = keydata;
                privateKeyJson = JSON.stringify(privateKeyhold);
                document.getElementById(""ecdsaprivate"").value = privateKeyJson;
</code></pre>

<p>as you can see you can generate ECDSA keys using global method
they will be different , you can't use ECDH keys
                }
            );</p>
","30","<javascript><elliptic-curve><ecdsa><ecdh>","0","0","1","2019-08-16 10:30:18","57523044","2","","","","","2019-08-16 10:04:12",""
"58664536","Python Script for Extracting R, S and Public Key Values from Hexadecimal Scriptsig","<p>I have the following Sigscript in Hexadecimal:</p>

<p>""483045022100da43201760bda697222002f56266bf65023fef2094519e13077f777baed553b102205ce35d05eabda58cd50a67977a65706347cc25ef43153e309ff210a134722e9e0141042daa93315eebbe2cb9b5c3505df4c6fb6caca8b756786098567550d4820c09db988fe9997d049d687292f815ccd6e7fb5c1b1a91137999818d17c73d0f80aef9""</p>

<p>Now i need to obtain the values of R, S and the public key using a PYTHON script.</p>
","","29","<python><transactions><ecdsa>","0","","0","2019-11-01 19:03:11","","1","","","","","2019-11-01 19:03:11",""
"57797544","How to compress the public key to 33bytes with public-key object in java (secp256k1 algorithm used)","<p>I'm trying to get compressed public-key from the PublicKey Object. 
I used ECDSA secp256k1 algorithm at bouncy castle library to generate a key pair.</p>

<p>by getPublic() method, I could get PublicKey object and when I printed it out it showed me like this,</p>

<p>EC Public Key [bd:e1:53:71:35:6a:f0:74:cb:b4:a1:b5:9d:60:26:81:1f:d0:22:32]<br>
 X: 6da8d1d2732329fe207216ecf1dcaf45baf00eb02c55b97762ec014d4e71ccdd<br>
 Y: f9c91e4a0c755ba905f0ed80939f7c73640be790da025fc44baee1f45363a1ef</p>

<p>I would like to compress it so I could have
  information of Y(1byte) + X(32byte) in byte array or Hex.</p>

<p>Can anyone please let me know how to compress the public key? so I could get
33byte of compressed public key? 
I'd really appreciate your help.</p>

<pre><code>public static KeyPair getKeyPair()
        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException {
    Security.addProvider(new BouncyCastleProvider());

    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(KEY_FACTORY_ALGORITHM, ""BC"");
    ECGenParameterSpec ecSpec = new ECGenParameterSpec(""secp256k1"");

    keyGen.initialize(ecSpec, new SecureRandom());
    KeyPair keypair = keyGen.generateKeyPair();

    return keypair;
</code></pre>

<pre><code>System.out.println(keyPair.getPublic());
</code></pre>
","","28","<java><bouncycastle><public-key><ecdsa>","0","","0","2019-09-05 02:04:52","","1","","","","","2019-09-05 02:04:52",""
"57304452","In which file in the bitcoin source code is the signature verification process done?","<p>I'm looking for the transaction signature verification process in the bitcoin source code (from <a href=""https://github.com/bitcoin/bitcoin"" rel=""nofollow noreferrer"">https://github.com/bitcoin/bitcoin</a>) but I can't find it. Where is it done ?</p>
","<p>A bitcoin transaction does not have a signature. Instead, it references outputs from previous transactions by supplying an unlocking script for each of the referenced outputs. </p>

<p>For more information about the transaction layout see <a href=""https://en.bitcoin.it/wiki/Transaction"" rel=""nofollow noreferrer"">here</a></p>

<p>The transaction verification code can be found in <code>tx_check.cpp</code> and <code>tx_verify.cpp</code> <a href=""https://github.com/bitcoin/bitcoin/tree/master/src/consensus"" rel=""nofollow noreferrer"">here</a>. </p>

<p>The actual <code>script</code> execution code can be found in <code>EvalScript</code> <a href=""https://github.com/bitcoin/bitcoin/blob/master/src/script/interpreter.cpp"" rel=""nofollow noreferrer"">here</a></p>
","28","<digital-signature><bitcoin><ecdsa>","0","0","1","2019-08-05 07:41:14","","0","","6174553","","2019-08-01 08:11:29","2019-08-01 08:05:19",""
"41465379","Getting xml document from url with ECDSA certificate","<p>I need the XML from an Url that has an ECDSA certifcate.
When I try to get this, I get the error:</p>

<blockquote>
  <p>The request was aborted: Could not create SSL/TLS secure channel</p>
</blockquote>

<p>I tried:</p>

<pre><code>ServicePointManager.ServerCertificateValidationCallback = (snder, cert, chain, error) =&gt; true;
</code></pre>

<p>and </p>

<pre><code>ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
</code></pre>

<p>and</p>

<pre><code>ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls;
</code></pre>

<p>but still the same error.</p>
","<p>Finally fixed it by adding this row:</p>

<p>//Set the security protocol to SL12 otherwise it returns an error
ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | (SecurityProtocolType)3072;</p>
","27","<c#><xml><ecdsa>","1","1","1","2017-01-20 08:02:16","41758736","0","1","1768343","","2017-01-04 14:26:05","2017-01-04 13:48:20",""
"57841226","ECDsaCng key generated longer than expected 32-bytes","<p>I was playing around with the ECDsaCng, and I realised that the key size doesn't seem to be correct. From the code below, the privateKey variable, for instance, was a 104-long byte array, whereas I didn't expect it to be larger than 32. </p>

<p>What am I doing wrong?</p>

<pre><code>        ECDsaCng dsa = new ECDsaCng(256);
        dsa.HashAlgorithm = CngAlgorithm.Sha256;
        dsa.GenerateKey(ECCurve.NamedCurves.nistP256);
        var privateKey = dsa.Key.Export(CngKeyBlobFormat.EccPrivateBlob);
        var publicKey = dsa.Key.Export(CngKeyBlobFormat.EccPublicBlob);
</code></pre>

<p>Thank you in advance.</p>
","<p>The private key <code>d</code> is a random integer in <code>[1, n - 1]</code>, where <code>n</code> is the order of the base point <code>G</code>. The public key is the curve point <code>(x, y) = d * G</code>, <a href=""https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_generation_algorithm"" rel=""nofollow noreferrer"">here</a>. For <code>NIST P-256</code> (<a href=""https://www.secg.org/sec2-v2.pdf"" rel=""nofollow noreferrer""><code>secp256r1</code></a>) <code>d</code>, <code>x</code> and <code>y</code> are encoded to 32 bytes (the values cannot be larger). </p>

<p>MS stores both keys in a specific format described <a href=""https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_ecckey_blob"" rel=""nofollow noreferrer"">here</a>. The format for the public key has an 8 bytes header, followed by the 32 bytes <code>x</code>-value and the 32 bytes <code>y</code>-value, so that the total length is 72 bytes. The format for the private key has a (different) 8-byte header, followed by the 32 byte <code>x</code>-value, the 32 byte <code>y</code>-value, and the 32 byte <code>d</code>-value, so that the total length is 104 bytes, in accordance with the value you found. A detailed description of the headers can be found <a href=""https://stackoverflow.com/a/24255090/9014097"">here</a>.</p>
","26","<c#><ecdsa>","1","2","1","2019-09-08 19:06:46","57844965","0","","","","","2019-09-08 10:46:03",""
"43581574","how can we improve message authenticity in ad-hoc networks , without using traditional methods of encryption and digital signatures","<p>usually we are using public-key encryption, or functional encryption along with ECDSA signatures to provide message authenticity and integrity  in Ad-hoc networks, but both these techniques have inherent drawbacks, what else can we use to improve the message authenticity and integrity in ad-hoc networks. </p>
","<p>regarding ""without using traditional methods of encryption and digital signatures"", i can not say the following more clearly:</p>

<p>STOP ... right here... right now ...<br>
when we are talking about vehicular data exchange the cryptographic needs are mission critical. when you ask about what can be done <em>without</em> well established methods, you are thinking about breaking rule number one in cryptography: designing your own system. </p>

<p>you do not want your own crypto system / protocol ... you want a well tested, reliable, publicly available, system that has been audited by the crypto community</p>
","23","<encryption><functional-programming><ecdsa>","0","0","1","2017-04-25 07:51:26","","2","","","","","2017-04-24 06:53:04",""
"54689827","Using ECDSA for signing api requests","<p>Is it a good choice to use ECDSA for signing API requests, given the following conditions:</p>

<ol>
<li>Only clients must be able to create signatures</li>
<li>Requests integrity must be verifiable, eg. we should know if a replay-attack was initiated</li>
<li>If the keys database would be compromised, the client keys should still be valid.</li>
</ol>

<p>Signature is made from the request endpoint + params + timestamp. Hashed and signed.</p>

<p>What do you guys think? </p>
","","21","<api><authentication><ecdsa>","3","","0","2019-02-14 11:54:45","","0","","","","","2019-02-14 11:54:45",""
"56793733","How to sign Bitcoin transactions using JCE?","<p>I need to sign Bitcoin transactions using JCE primitives(no bitcoinj), but my signatures are not considered valid by bitcoinj.</p>

<p>I tried to simulate this process. I created a random hash and signed it using both JCE and bitcoinj. Signatures are not equal.</p>

<p>Here is the code</p>

<pre><code>import org.bitcoinj.core.ECKey;
import org.bitcoinj.core.Sha256Hash;
import org.spongycastle.crypto.digests.SHA256Digest;
import org.spongycastle.crypto.params.ECPrivateKeyParameters;
import org.spongycastle.crypto.signers.ECDSASigner;
import org.spongycastle.crypto.signers.HMacDSAKCalculator;
import sun.security.ec.ECPrivateKeyImpl;
import sun.security.ec.ECPublicKeyImpl;

import java.math.BigInteger;
import java.security.*;
import java.security.spec.ECGenParameterSpec;

public class ECDSABitcoin {

    private static final String SIGN_ALGORITHM = ""SHA256withECDSA"";

    public static void main(String[] args) throws Exception {

        KeyPairGenerator keyPairGenerator = createGenerator();
        final KeyPair keyPair = keyPairGenerator.generateKeyPair();
        ECPrivateKeyImpl privateKey = (ECPrivateKeyImpl) keyPair.getPrivate();
        ECPublicKeyImpl publicKey = (ECPublicKeyImpl) keyPair.getPublic();
        try {
            Sha256Hash hashOut = Sha256Hash.wrap(toSha256(""abc"".getBytes()));
            byte[] signatureBytes = sign(hashOut.getBytes(), keyPair);

            ECKey.ECDSASignature mySignature = ECKey.ECDSASignature.decodeFromDER(signatureBytes).toCanonicalised();
            ECKey.ECDSASignature bitcoinSignature = sign(privateKey.getS(), hashOut.getBytes()).toCanonicalised();
            System.out.println(""My signature s "" + mySignature.s + "" r "" + mySignature.r + "" canonical "" + mySignature.isCanonical());
            System.out.println(""Verify my "" + verify(keyPair, hashOut.getBytes(), signatureBytes));
            System.out.println(""Bitcoinj signature s "" + bitcoinSignature.s + "" r "" + bitcoinSignature.r + "" canonical "" + bitcoinSignature.isCanonical());
            System.out.println(""Verify Bitcoinj "" + verify(keyPair, hashOut.getBytes(), bitcoinSignature.encodeToDER()));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static boolean verify(KeyPair keyPair, byte[] message, byte[] signatureBytes) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
        final Signature verifySignature = Signature.getInstance(SIGN_ALGORITHM);
        verifySignature.initVerify(keyPair.getPublic());
        verifySignature.update(message);
        return verifySignature.verify(signatureBytes);
    }

    private static byte[] sign(byte[] message, KeyPair keyPair) throws InvalidKeyException, NoSuchAlgorithmException, SignatureException {
        final Signature signature = Signature.getInstance(SIGN_ALGORITHM);
        signature.initSign(keyPair.getPrivate());
        signature.update(message);
        return signature.sign();
    }

    private static KeyPairGenerator createGenerator() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {
        final KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""EC"");
        ECGenParameterSpec ecParam = new ECGenParameterSpec(""secp256k1"");
        keyPairGenerator.initialize(ecParam);
        return keyPairGenerator;
    }

    private static ECKey.ECDSASignature sign(BigInteger privateKeyForSigning, byte[] data) {
        ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));
        ECPrivateKeyParameters privKey = new ECPrivateKeyParameters(privateKeyForSigning, ECKey.CURVE);
        signer.init(true, privKey);
        BigInteger[] components = signer.generateSignature(data);
        return new ECKey.ECDSASignature(components[0], components[1]).toCanonicalised();
    }

    private static byte[] toSha256(byte[] message) throws NoSuchAlgorithmException {
        MessageDigest crypt = MessageDigest.getInstance(""SHA-256"");
        crypt.reset();
        crypt.update(message);
        return crypt.digest();
    }
}
</code></pre>

<p>The result is:</p>

<pre><code>My signature s 45669553786690215047884329722902825758089042579493437816717142987836102849876 r 14778973653615637448416336446742229796258878351047437829727432860950944374049 canonical true
Verify my true
Bitcoinj signature s 24278043061766196831119988370534304503511938256487950554838614741011144316017 r 26413727078831382349368962255251267289169651926313668837949728205557969096319 canonical true
Verify Bitcoinj false
</code></pre>

<p>As you see, signatures are completely different, even though I use the same private key. What is wrong with my code? I just don't get it.</p>
","","19","<bitcoin><jce><ecdsa><spongycastle>","0","","0","2019-06-27 14:52:57","","0","","","","","2019-06-27 14:52:57",""
"58209245","Validate a certificate chain (ecdsa)","<p>I need to validate a certificate chain, and I just have the certificates, is that possible?</p>

<p>I'm trying in OpenSSL with the command verify, so when I ran:</p>

<pre><code>OpenSSL&gt; verify -CAfile testeroot.cer testesub.cer
</code></pre>

<p>testesub.cer: OK</p>

<p>However when I try with the ending certificate, I get a error:</p>

<pre><code>OpenSSL&gt; verify -CAfile testeroot.cer testesub.cer testeapp.cer
testesub.cer: OK
CN = ecc-crypto-services-encipherment_UC6-InMemory, OU = ApplePay, O = Apple Inc., C = US
error 20 at 0 depth lookup: unable to get local issuer certificate
error testeapp.cer: verification failed
error in verify
</code></pre>

<p>here is the certificates:</p>

<p>to be validated (the last - testeapp.cer):</p>

<pre><code>-----BEGIN CERTIFICATE-----
MIIEEzCCA7igAwIBAgIIEvD9KtxTuV0wCgYIKoZIzj0EAwIwgYExOzA5BgNVBAMM
MlRlc3QgQXBwbGUgV29ybGR3aWRlIERldmVsb3BlcnMgUmVsYXRpb25zIENBIC0g
RUNDMSAwHgYDVQQLDBdDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTETMBEGA1UECgwK
QXBwbGUgSW5jLjELMAkGA1UEBhMCVVMwHhcNMTcwNTIwMDQxNTU3WhcNMTkwNjE5
MDQxNTU3WjBtMTYwNAYDVQQDDC1lY2MtY3J5cHRvLXNlcnZpY2VzLWVuY2lwaGVy
bWVudF9VQzYtSW5NZW1vcnkxETAPBgNVBAsMCEFwcGxlUGF5MRMwEQYDVQQKDApB
cHBsZSBJbmMuMQswCQYDVQQGEwJVUzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA
BC4+XM9rmrBL56IvP6zP3nPIfocVU5SjSBVAiolsoYo3TaxmmvO/YiD8hjdn9K9H
UHxbwiH8ShmHTa85tAdOPrijggIrMIICJzBPBggrBgEFBQcBAQRDMEEwPwYIKwYB
BQUHMAGGM2h0dHA6Ly9vY3NwLXVhdC5jb3JwLmFwcGxlLmNvbS9vY3NwMDQtdGVz
dHd3ZHJjYWVjYzAdBgNVHQ4EFgQUrS6jy340wu3uQ2hOJxEfzEkzOdAwDAYDVR0T
AQH/BAIwADAfBgNVHSMEGDAWgBTW1tVa5f/9wnw0w0PevWh2XDapvjCCAR0GA1Ud
IASCARQwggEQMIIBDAYJKoZIhvdjZAUBMIH+MIHDBggrBgEFBQcCAjCBtgyBs1Jl
bGlhbmNlIG9uIHRoaXMgY2VydGlmaWNhdGUgYnkgYW55IHBhcnR5IGFzc3VtZXMg
YWNjZXB0YW5jZSBvZiB0aGUgdGhlbiBhcHBsaWNhYmxlIHN0YW5kYXJkIHRlcm1z
IGFuZCBjb25kaXRpb25zIG9mIHVzZSwgY2VydGlmaWNhdGUgcG9saWN5IGFuZCBj
ZXJ0aWZpY2F0aW9uIHByYWN0aWNlIHN0YXRlbWVudHMuMDYGCCsGAQUFBwIBFipo
dHRwOi8vd3d3LmFwcGxlLmNvbS9jZXJ0aWZpY2F0ZWF1dGhvcml0eS8wQQYDVR0f
BDowODA2oDSgMoYwaHR0cDovL2NybC11YXQuY29ycC5hcHBsZS5jb20vYXBwbGV3
d2RyY2FlY2MuY3JsMA4GA1UdDwEB/wQEAwIDKDASBgkqhkiG92NkBicBAf8EAgUA
MAoGCCqGSM49BAMCA0kAMEYCIQCMvUq2YUxY/RqTWE4FqsPTr9zGyilCunIU3FSo
btep7gIhAN7Vdx3B0p7DTCqXHd05IPsZGLdIDG1NTxOk2Oj/N7GG
-----END CERTIFICATE-----
</code></pre>

<p>======================================================================</p>

<p>The intermediate (testesub.cer)</p>

<pre><code>-----BEGIN CERTIFICATE-----
MIIC5zCCAoygAwIBAgIIR1pCSszYnvcwCgYIKoZIzj0EAwIwZzEhMB8GA1UEAwwY
VGVzdCBBcHBsZSBSb290IENBIC0gRUNDMSAwHgYDVQQLDBdDZXJ0aWZpY2F0aW9u
IEF1dGhvcml0eTETMBEGA1UECgwKQXBwbGUgSW5jLjELMAkGA1UEBhMCVVMwHhcN
MTQwMjA2MTYxODI5WhcNMjQwMjA0MTYxODI5WjCBgTE7MDkGA1UEAwwyVGVzdCBB
cHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVycyBSZWxhdGlvbnMgQ0EgLSBFQ0MxIDAe
BgNVBAsMF0NlcnRpZmljYXRpb24gQXV0aG9yaXR5MRMwEQYDVQQKDApBcHBsZSBJ
bmMuMQswCQYDVQQGEwJVUzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDzb9Lsn
a4XrUdRwIjl36m9hTGhxQrW5Ls3wYr07kaZ/5tMOEG5jOBeHtI+x8YHmkgp0Ry43
nmZTik3vosay+6ajggEFMIIBATBUBggrBgEFBQcBAQRIMEYwRAYIKwYBBQUHMAGG
OGh0dHA6Ly9vY3NwLXVhdC5jb3JwLmFwcGxlLmNvbS9vY3NwMDQtdGVzdGFwcGxl
cm9vdGNhZWNjMB0GA1UdDgQWBBTW1tVa5f/9wnw0w0PevWh2XDapvjASBgNVHRMB
Af8ECDAGAQH/AgEAMB8GA1UdIwQYMBaAFNJH4sU0ccYQjZPuBEMf4RsP4c0RMEUG
A1UdHwQ+MDwwOqA4oDaGNGh0dHA6Ly9jcmwtdWF0LmNvcnAuYXBwbGUuY29tL3Rl
c3RhcHBsZXJvb3RjYWVjYy5jcmwwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMC
A0kAMEYCIQCd4eDjSiTu55mDKWCaD7Tqe4hp86pJ1Fsw7SlPKmH+bQIhAJ5coaJ3
uarz81Im19NGcrU45h1A8hNDTz55QPEHujS5
-----END CERTIFICATE-----
</code></pre>

<p>======================================================================</p>

<p>the root (CA) - testeroot.cer:</p>

<pre><code>-----BEGIN CERTIFICATE-----
MIICJzCCAc2gAwIBAgIIWdHsEJJBx8QwCgYIKoZIzj0EAwIwZzEhMB8GA1UEAwwY
VGVzdCBBcHBsZSBSb290IENBIC0gRUNDMSAwHgYDVQQLDBdDZXJ0aWZpY2F0aW9u
IEF1dGhvcml0eTETMBEGA1UECgwKQXBwbGUgSW5jLjELMAkGA1UEBhMCVVMwHhcN
MTQwMTMxMjE0NjQ2WhcNMzQwMTI2MjE0NjQ2WjBnMSEwHwYDVQQDDBhUZXN0IEFw
cGxlIFJvb3QgQ0EgLSBFQ0MxIDAeBgNVBAsMF0NlcnRpZmljYXRpb24gQXV0aG9y
aXR5MRMwEQYDVQQKDApBcHBsZSBJbmMuMQswCQYDVQQGEwJVUzBZMBMGByqGSM49
AgEGCCqGSM49AwEHA0IABHs4ENAKoxt8HST7OdZrHAqXSDD/THBJPSFmT/WJAK+T
73Sa6EwnPb6VUFI9U5DzMquDtl5zyOcXixgJk5+X1RajYzBhMB0GA1UdDgQWBBTS
R+LFNHHGEI2T7gRDH+EbD+HNETAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaA
FNJH4sU0ccYQjZPuBEMf4RsP4c0RMA4GA1UdDwEB/wQEAwIBBjAKBggqhkjOPQQD
AgNIADBFAiEA3AYrcocg7PfcyPL4iQpXY5qSSoRu3RdQ7m8BTKGgdNECIB81erUL
eYDUnJ8x3DYcxv1lckBnuvxvWV7v6l6HrDAN
-----END CERTIFICATE-----
</code></pre>

<p>I've already tried to concatenate the certificates, but it seems that it's just verified the first certificate of the concatenated exit.</p>
","<p>There are two possible scenarios we need to consider here.</p>

<p>1) The intermediate certificate is trusted by the verifier</p>

<p>2) The intermediate certificate is not trusted by the verifier</p>

<p>In the first case the intermediate certificate is in the trust store for the verifier. The simplest way to achieve that is to concatenate the root and sub files together:</p>

<pre><code>$ cat testeroot.cer testesub.cer &gt;testerootandsub.cer
</code></pre>

<p>Next we verify like this:</p>

<pre><code>$ openssl verify -CAfile testerootandsub.cer testeapp.cer
</code></pre>

<p>Unfortunately when I try this I get some errors:</p>

<pre><code>CN = ecc-crypto-services-encipherment_UC6-InMemory, OU = ApplePay, O = Apple Inc., C = US
error 34 at 0 depth lookup: unhandled critical extension
CN = ecc-crypto-services-encipherment_UC6-InMemory, OU = ApplePay, O = Apple Inc., C = US
error 10 at 0 depth lookup: certificate has expired
error testeapp.cer: verification failed
</code></pre>

<p>So the first one is an ""unhandled critical extension"" and the second one is ""certificate has expired"". Lets look at the certificate:</p>

<pre><code>$ openssl x509 -in testeapp.cer -noout -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1364869047620188509 (0x12f0fd2adc53b95d)
        Signature Algorithm: ecdsa-with-SHA256
        Issuer: CN = Test Apple Worldwide Developers Relations CA - ECC, OU = Certification Authority, O = Apple Inc., C = US
        Validity
            Not Before: May 20 04:15:57 2017 GMT
            Not After : Jun 19 04:15:57 2019 GMT
        Subject: CN = ecc-crypto-services-encipherment_UC6-InMemory, OU = ApplePay, O = Apple Inc., C = US
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:2e:3e:5c:cf:6b:9a:b0:4b:e7:a2:2f:3f:ac:cf:
                    de:73:c8:7e:87:15:53:94:a3:48:15:40:8a:89:6c:
                    a1:8a:37:4d:ac:66:9a:f3:bf:62:20:fc:86:37:67:
                    f4:af:47:50:7c:5b:c2:21:fc:4a:19:87:4d:af:39:
                    b4:07:4e:3e:b8
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            Authority Information Access: 
                OCSP - URI:http://ocsp-uat.corp.apple.com/ocsp04-testwwdrcaecc

            X509v3 Subject Key Identifier: 
                AD:2E:A3:CB:7E:34:C2:ED:EE:43:68:4E:27:11:1F:CC:49:33:39:D0
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Authority Key Identifier: 
                keyid:D6:D6:D5:5A:E5:FF:FD:C2:7C:34:C3:43:DE:BD:68:76:5C:36:A9:BE

            X509v3 Certificate Policies: 
                Policy: 1.2.840.113635.100.5.1
                  User Notice:
                    Explicit Text: Reliance on this certificate by any party assumes acceptance of the then applicable standard terms and conditions of use, certificate policy and certification practice statements.
                  CPS: http://www.apple.com/certificateauthority/

            X509v3 CRL Distribution Points: 

                Full Name:
                  URI:http://crl-uat.corp.apple.com/applewwdrcaecc.crl

            X509v3 Key Usage: critical
                Key Encipherment, Key Agreement
            1.2.840.113635.100.6.39: critical
                ..
    Signature Algorithm: ecdsa-with-SHA256
         30:46:02:21:00:8c:bd:4a:b6:61:4c:58:fd:1a:93:58:4e:05:
         aa:c3:d3:af:dc:c6:ca:29:42:ba:72:14:dc:54:a8:6e:d7:a9:
         ee:02:21:00:de:d5:77:1d:c1:d2:9e:c3:4c:2a:97:1d:dd:39:
         20:fb:19:18:b7:48:0c:6d:4d:4f:13:a4:d8:e8:ff:37:b1:86
</code></pre>

<p>First we can see that the certificate has indeed expired (""Not After"" is ""Jun 19 04:15:57 2019 GMT""). Secondly there is a critical extension that OpenSSL does not recognise:</p>

<pre><code>            1.2.840.113635.100.6.39: critical
                ..
</code></pre>

<p>We can get OpenSSL to ignore these two errors like this:</p>

<pre><code>$ openssl verify -ignore_critical -no_check_time -CAfile testerootandsub.cer testeapp.cer 
testeapp.cer: OK
</code></pre>

<p>The second scenario I talked about is where the intermediate certificate is not trusted by the verifier. In this case the verifier is assumed to have the root in their trust store, and the intermediate and end entity certificates will have been supplied to them. In that case the verification command looks like this:</p>

<pre><code>$ openssl verify -ignore_critical -no_check_time -CAfile testeroot.cer -untrusted testesub.cer testeapp.cer 
testeapp.cer: OK
</code></pre>
","19","<openssl><certificate><chain><ecdsa>","0","0","1","2019-10-03 07:55:28","","0","","","","","2019-10-02 20:56:57",""
"58753715","Extract ECDSA parameters from Bitcoin Blockchain Block","<p>I am trying to extract the parameters of ECDSA signature used in bitcoin to run some tests. For that i need to obtain :</p>

<pre><code>  --- r and s ,  i.e., the ECDSA signature

  --- H(m) , the hash of the message used to generate the ECDSA signature

  --- the random integer k used in ECDSA signature generation, 
      this is, the k such that  s = k*(H(m) + x*r) mod q  where x is 
      the private key
</code></pre>

<p>I already was able to obtain the r and the s of a very specific type of block, the ones where len(inp.script_sig) == 214 ).</p>

<p>So i need to obtain these parameters for all blocks and also need to know how to do this for Ethereum and LiteCoin.</p>

<pre class=""lang-py prettyprint-override""><code>
from blockchain import blockexplorer
from binascii import unhexlify
from pyasn1.codec.der import decoder as asn1der
import time, os, codecs
import numpy as np
from bitcoin_tools.bitcoin_tools.core.transaction import TX


# returns the blocks of given day
# if day = 0 , returns blocks of today
# if day = 1 , returns blocks of yesterday , and so on ....
def getBlocksofDay( day ):

    # get blocks from blockchain from given day
    # if we want the day before just subtract 86400000
    return blockexplorer.get_blocks(int(round(time.time() * 1000)) - 86400000*day)


# print SimpleBlock
def printSimpleBlock( block ):

    print(""\nHeight : "", block.height )
    print(""Hash : "", block.hash )
    print(""Time : "", block.time)
    print(""Main Chain :"",  block.main_chain, ""\n"" )


# print Block
def printBlock( block ):

    print(""\nHash : "", block.hash )
    print(""Version : "", block.version )
    print(""Previous Block : "", block.previous_block )
    print(""Merkle Root : "", block.merkle_root )
    print(""Time : "", block.time)
    print(""Bits : "", block.bits)
    print(""Fee : "", block.fee)
    print(""Nonce : "", block.nonce)
    print(""Number of transaction : "", block.n_tx)
    print(""Size : "", block.size )
    print(""Block Index : "" , block.block_index )
    print(""Main Chain :"",  block.main_chain )
    print(""Height : "", block.height )
    print(""Received Time : "", block.received_time )
    print(""Relayed By : "", block.relayed_by )

    if( block.n_tx &gt; 50):
        print(""Transactions : NOT PRINTING TX TOO MANY \n""  )
    else:
        print(""Transactions : "", block.transactions )


# print Transaction
def printTransaction( tx ):

    print(""\nDouble Spend : "", tx.double_spend )
    print(""Block height : "", tx.block_height )
    print(""Time : "", tx.time )
    print(""Relayed By : "", tx.relayed_by )
    print(""Hash : "", tx.hash )
    print(""Tx Index : "" , tx.tx_index )
    print(""Version : "", tx.version )
    print(""Size : "", tx.size )
    print(""Inputs : "", tx.inputs )
    print(""Outputs : "", tx.outputs, ""\n"" )


# print Input
def printInput( inp ):

    try:
        if( len(inp.script_sig) == 214 ):
            '''
            print(""\nN : "", inp.n )
            print(""Value : "", inp.value )
            print(""Address : "", inp.address )
            print(""Tx_Index : "", inp.tx_index )
            print(""Type : "", inp.type )
            print(""Script : "", inp.script )
            print(""Script_Sig : "", inp.script_sig )
            print(""Sequence : "", inp.sequence )
            '''
            return 0
    except:
        return -1


# print XPub
def printXPub( xpub ):

    print(""\nAddress : "", xpub.address)
    print(""Number of Transaction : "", xpub.n_tx )
    print(""Total Received : "", xpub.total_received / 100000000, ""BTC"" )
    print(""Total Sent : "", xpub.total_sent / 100000000, ""BTC"" )
    print(""Final Balance : "", xpub.final_balance )
    print(""Change Index : "", xpub.change_index )
    print(""Account Index : "", xpub.account_index, ""\n\n"" )

    for tx in xpub.transactions:
        printTransaction(tx)



def printR_S_PK(script_sig_hex):

    #script_sig_hex is the scriptsig hex
    values = asn1der.decode(unhexlify(script_sig_hex)[1:])
    '''
    #R Value in int form
    print( ""\nR value:"", values[0][0] )

    #S Value in int form
    print( ""S value:"", values[0][1]  )

    # X coordinate of Public Key
    print( ""X coordinate of PK:"",  int(values[1].hex()[4:],16) )
    '''

    return [ int(values[1].hex()[6:],16), int(values[1].hex()[4:6],16), int(values[0][0]), int(values[0][1]) ]






#if __name__ == ""__main__"":


def getThemBlocks(day):


    simpleBlocksofDay = getBlocksofDay(day)
    pubKeys = np.array([[-1], [-1], [-1], [-1], [-1], [-1]])

    print(""LEN : "", len(simpleBlocksofDay), ""\n"")

    # run through all blocks of this day
    for block in [simpleBlocksofDay[0]]:
        blocksofDay = blockexplorer.get_block( block.hash )
        txs = blocksofDay.transactions

        # run through all tx of this day
        for txofDay in txs:
            inpofTx = txofDay.inputs

            # run through all inputs of this day
            for inp in inpofTx:

                # if input has format we want
                if( printInput(inp) == 0 ):

                    numLines, numColumns = len(pubKeys), pubKeys[0].size

                    script_sig_hex = inp.script_sig
                    xC, sig, r, s = printR_S_PK(script_sig_hex)

                    aux = np.where(pubKeys[2]==xC)

                    columnToAdd = [ -1 for i in range(0,numLines) ]
                    columnToAdd[0], columnToAdd[1], columnToAdd[2], columnToAdd[3] = 6, 1, xC, sig
                    columnToAdd[4], columnToAdd[5] = r, s

                    lineToAdd = [ -1 for i in range(0,numColumns) ]


                    # xC it's not repeated
                    if( aux[0].size == 0 ):
                        pubKeys = np.c_[pubKeys, np.array(columnToAdd)]

                    # again xC it's not repeated
                    elif( (aux[0].size == 1) and (pubKeys[3][aux[0][0]] != sig) ):
                        pubKeys = np.c_[pubKeys, np.array(columnToAdd)]

                    # xC it's repeated
                    else:
                        if( pubKeys[3][aux[0][0]] == sig ):
                            column = aux[0][0]
                        else:
                            column = aux[0][1]

                        # need to add 2 new lines
                        if( pubKeys[0][column]+1 &gt; numLines ):
                            aux = np.array(lineToAdd)
                            pubKeys = np.r_[pubKeys, [aux]]
                            pubKeys = np.r_[pubKeys, [aux]]
                            pubKeys = np.r_[pubKeys, [aux]]

                        line = pubKeys[0][column]
                        pubKeys[line][column] = r
                        pubKeys[line+1][column] = s
                        pubKeys[line+2][column] = txofDay.hash

                        # increase the number of elements in that columns by 2
                        pubKeys[0][column] += 3

                        # increase the number of signatures by 1
                        pubKeys[1][column] += 1



    for j in range(1, pubKeys[0].size):

        if(pubKeys[1][j] &gt; 40):
            for i in range(0, len(pubKeys)):

                print(pubKeys[i][j])

            print(""\n\n"")




if __name__ == ""__main__"":

    '''
    for i in range(0,3):
        getThemBlocks(i)
    '''

    # First a transaction object is created (through the deserialize constructor) by deserializing the hex transaction we have selected.
    hex_tx = ""01000000013ca58d2f6fac36602d831ee0cf2bc80031c7472e80a322b57f614c5ce9142b71000000006b483045022100f0331d85cb7f7ec1bedc41f50c695d654489458e88aec0076fbad5d8aeda1673022009e8ca2dda1d6a16bfd7133b0008720145dacccb35c0d5c9fc567e52f26ca5f7012103a164209a7c23227fcd6a71c51efc5b6eb25407f4faf06890f57908425255e42bffffffff0241a20000000000001976a914e44839239ab36f5bc67b2079de00ecf587233ebe88ac74630000000000001976a914dc7016484646168d99e49f907c86c271299441c088ac00000000""

    tx = TX.deserialize(hex_tx)

    # Then, the transaction can be displayed using the display method to analyze how it's been constructed.
    tx.display()




</code></pre>
","","17","<bitcoin><ecdsa>","0","","0","2019-11-07 17:02:09","","0","","","","","2019-11-07 17:02:09",""
"57984822","ecdsa key pair from a user chosen public key","<p>Let's say that I have a random number 'x', I want to generate a ecdsa key pair with 'x' as the private key. Is it possible to generate such a key pair?</p>
","","14","<bitcoin><ecdsa>","0","","0","2019-09-18 03:47:31","","1","","","","","2019-09-18 03:47:31",""
"57154756","Digital signing and verifying using prime256v1 in Node","<p>I want to generate digital signatures in Node using ECDSA (prime256v1 curve) 
The private key is generated with this OpenSSL command:</p>

<pre><code>$ openssl ecparam -name prime256v1 -genkey -out private_key.pem
</code></pre>

<p>Would the following be the correct Node code to sign a message:</p>

<pre><code>import crypto from 'crypto'

const sign = (privateKey, messageString) =&gt; {
  const buffer = Buffer.from(messageString, 'utf8')
  const signature = crypto.sign('sha256', buffer, privateKey)
  return signature.toString('base64')
}
</code></pre>
","","13","<node.js><openssl><cryptojs><ecdsa>","0","","0","2019-07-22 23:04:35","","0","","","","","2019-07-22 23:04:35",""
"58708473","Best practice for uploading HMAC secretKey and RSA/ECDSA public key in a RESTful web application","<p>Imagine a web application with RESTful endpoint accepting HMAC secret keys / RSA or ECDSA public keys (for storage).</p>

<p>What would be the best user experience to submit such a key ?</p>

<p>Presumably the request body attribute is a <code>String</code>, so it can be convenient for using through <code>curl</code> for instance</p>

<p>I guess for HMAC it would be Base64#encode(keyBytes).</p>

<p>For RSA/ECDSA I'm kinda confused.</p>

<p><a href=""https://www.cryptosys.net/pki/rsakeyformats.html"" rel=""nofollow noreferrer"">https://www.cryptosys.net/pki/rsakeyformats.html</a></p>

<p>Specifies that RSA public key may be either X.509, XML or PKCS#1.</p>

<p>So, is base64 a good choice here as well ? or it should be some kind of US_ASCCI / iso-8859-1 string ?</p>

<hr>

<p>The assumption is that the user may come later and GET the keys, so it would be nice if he see the same values he submitted earlier (avoiding any string alteration due different text encoding)</p>
","","12","<rest><rsa><submit><public-key-encryption><ecdsa>","0","","0","2019-11-05 09:41:10","","1","","","","","2019-11-05 09:41:10",""
"58769996","libsodiums secret key contains public key?","<p>I noticed that libsodiums secret signing keys contain a copy of the public key?</p>

<p>What is the reason for this?
Does it have to do with how the ecdsa algorithm works or is it just for convenience?</p>
","","6","<ecdsa><libsodium>","0","","0","2019-11-08 16:00:42","","0","","","","","2019-11-08 16:00:42",""
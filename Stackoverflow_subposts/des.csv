post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<p>All of these schemes, except AES and Blowfish, have known vulnerabilities and should not be used.<br>
However, Blowfish has been replaced by <a href=""http://en.wikipedia.org/wiki/Twofish"" rel=""noreferrer"">Twofish</a>.</p>
","249415","<aes><blowfish><des><tripledes>","138","25","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<p>AES is the currently accepted standard algorithm to use (hence the name Advanced Encryption <strong>Standard</strong>).</p>

<p>The rest are not.</p>
","249415","<aes><blowfish><des><tripledes>","138","0","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<p>The encryption methods described are symmetric key block ciphers.</p>

<p>Data Encryption Standard (DES) is the predecessor, encrypting data in 64-bit blocks using a 56 bit key. Each block is encrypted in isolation, which is a security vulnerability.</p>

<p>Triple DES extends the key length of DES by applying three DES operations on each block: an encryption with key 0, a decryption with key 1 and an encryption with key 2. These keys may be related.</p>

<p>DES and 3DES are usually encountered when interfacing with legacy commercial products and services.</p>

<p>AES is considered the successor and modern standard. <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"">http://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></p>

<p>I believe the use of Blowfish is discouraged.</p>

<p>It is highly recommended that you do not attempt to implement your own cryptography and instead use a high-level implementation such as GPG for data at rest or SSL/TLS for data in transit. Here is an excellent and sobering video on encryption vulnerabilities <a href=""http://rdist.root.org/2009/08/06/google-tech-talk-on-common-crypto-flaws/"">http://rdist.root.org/2009/08/06/google-tech-talk-on-common-crypto-flaws/</a></p>
","249415","<aes><blowfish><des><tripledes>","138","11","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<p>Use AES.</p>

<p>In more details:</p>

<ul>
<li>DES is the old ""data encryption standard"" from the seventies. Its key size is too short for proper security (56 effective bits; this can be brute-forced, as has been demonstrated <a href=""http://en.wikipedia.org/wiki/EFF_DES_cracker"">more than ten years ago</a>). Also, DES uses 64-bit blocks, which raises some potential issues when encrypting several gigabytes of data with the same key (a gigabyte is not that big nowadays).</li>
<li>3DES is a trick to reuse DES implementations, by cascading three instances of DES (with distinct keys). 3DES is believed to be secure up to at least ""<em>2<sup>112</sup></em>"" security (which is quite a lot, and quite far in the realm of ""not breakable with today's technology""). But it is slow, especially in software (DES was designed for efficient hardware implementation, but it sucks in software; and 3DES sucks three times as much).</li>
<li>Blowfish is a block cipher proposed by Bruce Schneier, and deployed in some softwares. Blowfish can use huge keys and is believed secure, except with regards to its block size, which is 64 bits, just like DES and 3DES. Blowfish is efficient in software, at least on some software platforms (it uses key-dependent lookup tables, hence performance depends on how the platform handles memory and caches).</li>
<li>AES is the successor of DES as standard symmetric encryption algorithm for US federal organizations (and as standard for pretty much everybody else, too). AES accepts keys of 128, 192 or 256 bits (128 bits is already very unbreakable), uses 128-bit blocks (so no issue there), and is efficient in both software and hardware. It was selected through an open competition involving hundreds of cryptographers during several years. Basically, you cannot have better than that.</li>
</ul>

<p>So, when in doubt, use AES.</p>

<p>Note that a block cipher is a box which encrypts ""blocks"" (128-bit chunks of data with AES). When encrypting a ""message"" which may be longer than 128 bits, the message must be split into blocks, and the actual way you do the split is called the <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation"">mode of operation</a> or ""chaining"". The naive mode (simple split) is called ECB and has issues. Using a block cipher properly is not easy, and it is more important than selecting between, e.g., AES or 3DES.</p>
","249415","<aes><blowfish><des><tripledes>","138","244","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<p>AES is a symmetric cryptographic algorithm, while RSA is an asymmetric (or public key) cryptographic algorithm. Encryption and decryption is done with a single key in AES, while you use separate keys (public and private keys) in RSA. The strength of a 128-bit AES key is roughly equivalent to 2600-bits RSA key.</p>
","249415","<aes><blowfish><des><tripledes>","138","8","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<p>Although TripleDESCryptoServiceProvider is a safe and good method but it's too slow. If you want to refer to MSDN you will get that advise you to use AES rather TripleDES. Please check below link:
<a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledescryptoserviceprovider.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledescryptoserviceprovider.aspx</a>
you will see this attention in the remark section:</p>

<blockquote>
  <p><strong>Note</strong> 
  A newer symmetric encryption algorithm, Advanced Encryption
  Standard (AES), is available. Consider using the
  AesCryptoServiceProvider class instead of the
  TripleDESCryptoServiceProvider class. Use
  TripleDESCryptoServiceProvider only for compatibility with legacy
  applications and data.</p>
</blockquote>

<p>Good luck</p>
","249415","<aes><blowfish><des><tripledes>","138","4","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<pre><code>                DES                               AES
Developed       1977                              2000
Key Length      56 bits                           128, 192, or 256 bits
Cipher Type     Symmetric                         Symmetric
Block Size      64 bits                           128 bits
Security        inadequate                        secure
Performance     Fast                              Slow
</code></pre>
","249415","<aes><blowfish><des><tripledes>","138","0","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"5554526","Comparison of DES, Triple DES, AES, blowfish encryption for data","<p>Does anyone have pros and cons together for comparing these encryption algorithms ?</p>
","<p><a href=""https://i.stack.imgur.com/qrbbG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qrbbG.png"" alt=""enter image description here""></a></p>

<p>DES is the old ""data encryption standard"" from the seventies. </p>
","249415","<aes><blowfish><des><tripledes>","138","1","8","2018-01-28 15:27:00","5559132","2","64","","","","2011-04-05 15:39:52",""
"9031537","Really simple encryption with C# and SymmetricAlgorithm","<p>I'm looking for a <strong>very</strong> simple crypt / decrypt method. I will be using always the same static key. I'm aware of the risks of this approach. Currently I'm using the following code but it does not generate the same result after crypting and decripting the same string (there is some garbage in the middle of the string).</p>

<pre><code>public static string Crypt(this string text)
{
    string result = null;

    if (!String.IsNullOrEmpty(text))
    {
        byte[] plaintextBytes = Encoding.Unicode.GetBytes(text);

        SymmetricAlgorithm symmetricAlgorithm = DES.Create();
        symmetricAlgorithm.Key = new byte[8] {1, 2, 3, 4, 5, 6, 7, 8};
        using (MemoryStream memoryStream = new MemoryStream())
        {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, symmetricAlgorithm.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cryptoStream.Write(plaintextBytes, 0, plaintextBytes.Length);
            }

            result = Encoding.Unicode.GetString(memoryStream.ToArray());
        }
    }

    return result;
}

public static string Decrypt(this string text)
{
    string result = null;

    if (!String.IsNullOrEmpty(text))
    {
        byte[] encryptedBytes = Encoding.Unicode.GetBytes(text);

        SymmetricAlgorithm symmetricAlgorithm = DES.Create();
        symmetricAlgorithm.Key = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
        using (MemoryStream memoryStream = new MemoryStream(encryptedBytes))
        {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, symmetricAlgorithm.CreateDecryptor(), CryptoStreamMode.Read))
            {
                byte[] decryptedBytes = new byte[encryptedBytes.Length];
                cryptoStream.Read(decryptedBytes, 0, decryptedBytes.Length);
                result = Encoding.Unicode.GetString(decryptedBytes);
            }
        }
    }

    return result;
}
</code></pre>

<p>I can change whatever is needed, no limits (but I want just to have on method to crypt and another one to decrypt without sharing variables between them).</p>

<p>Thanks.</p>
","<p>You'll need to set the cipher mode to CipherMode.ECB or use an IV.</p>

<pre><code>SymmetricAlgorithm symmetricAlgorithm = DES.Create();
symmetricAlgorithm.Key = new byte[8] { 1, 2, 3, 4, 5, 6, 7, 8 };
symmetricAlgorithm.Mode = CipherMode.ECB;
...
</code></pre>

<p>Another point is not to use Unicode encoding. Use Base64 instead. Unicode might ""destroy"" bytes that are not UTF-16.</p>
","68813","<c#><encryption><encryption-symmetric><des>","26","9","3","2019-03-06 18:02:29","9034247","1","11","185123","","2019-03-06 18:02:29","2012-01-27 09:56:58",""
"9031537","Really simple encryption with C# and SymmetricAlgorithm","<p>I'm looking for a <strong>very</strong> simple crypt / decrypt method. I will be using always the same static key. I'm aware of the risks of this approach. Currently I'm using the following code but it does not generate the same result after crypting and decripting the same string (there is some garbage in the middle of the string).</p>

<pre><code>public static string Crypt(this string text)
{
    string result = null;

    if (!String.IsNullOrEmpty(text))
    {
        byte[] plaintextBytes = Encoding.Unicode.GetBytes(text);

        SymmetricAlgorithm symmetricAlgorithm = DES.Create();
        symmetricAlgorithm.Key = new byte[8] {1, 2, 3, 4, 5, 6, 7, 8};
        using (MemoryStream memoryStream = new MemoryStream())
        {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, symmetricAlgorithm.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cryptoStream.Write(plaintextBytes, 0, plaintextBytes.Length);
            }

            result = Encoding.Unicode.GetString(memoryStream.ToArray());
        }
    }

    return result;
}

public static string Decrypt(this string text)
{
    string result = null;

    if (!String.IsNullOrEmpty(text))
    {
        byte[] encryptedBytes = Encoding.Unicode.GetBytes(text);

        SymmetricAlgorithm symmetricAlgorithm = DES.Create();
        symmetricAlgorithm.Key = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
        using (MemoryStream memoryStream = new MemoryStream(encryptedBytes))
        {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, symmetricAlgorithm.CreateDecryptor(), CryptoStreamMode.Read))
            {
                byte[] decryptedBytes = new byte[encryptedBytes.Length];
                cryptoStream.Read(decryptedBytes, 0, decryptedBytes.Length);
                result = Encoding.Unicode.GetString(decryptedBytes);
            }
        }
    }

    return result;
}
</code></pre>

<p>I can change whatever is needed, no limits (but I want just to have on method to crypt and another one to decrypt without sharing variables between them).</p>

<p>Thanks.</p>
","<p>How about something like this?</p>

<p><em>Code</em></p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Text;

public static class StringUtil
{
    private static byte[] key = new byte[8] {1, 2, 3, 4, 5, 6, 7, 8};
    private static byte[] iv = new byte[8] {1, 2, 3, 4, 5, 6, 7, 8};

    public static string Crypt(this string text)
    {
        SymmetricAlgorithm algorithm = DES.Create();
        ICryptoTransform transform = algorithm.CreateEncryptor(key, iv);
        byte[] inputbuffer = Encoding.Unicode.GetBytes(text);
        byte[] outputBuffer = transform.TransformFinalBlock(inputbuffer, 0, inputbuffer.Length);
        return Convert.ToBase64String(outputBuffer);
    }

    public static string Decrypt(this string text)
    {
        SymmetricAlgorithm algorithm = DES.Create();
        ICryptoTransform transform = algorithm.CreateDecryptor(key, iv);
        byte[] inputbuffer = Convert.FromBase64String(text);
        byte[] outputBuffer = transform.TransformFinalBlock(inputbuffer, 0, inputbuffer.Length);
        return Encoding.Unicode.GetString(outputBuffer);
    }
}
</code></pre>

<p><em>Unit Test</em></p>

<pre><code>[Test]
public void Test()
{
    string expected = ""this is my test string"";
    string a = expected.Crypt();
    Debug.WriteLine(a);
    string actual = a.Decrypt();
    Assert.AreEqual(expected, actual);
}
</code></pre>

<hr>

<p><strong>EDIT:</strong></p>

<p>To clarify: I am aware this is not good practice. </p>

<blockquote>
  <p>""I'm aware of the risks of this approach. ""</p>
</blockquote>

<p>Iv'e made the assumption that the OP is also aware and will make relevant code changes before considering using anything like this in a production environment.</p>

<p>The question emphasizes simplicity over good practice.</p>
","68813","<c#><encryption><encryption-symmetric><des>","26","33","3","2019-03-06 18:02:29","9034247","1","11","185123","","2019-03-06 18:02:29","2012-01-27 09:56:58",""
"9031537","Really simple encryption with C# and SymmetricAlgorithm","<p>I'm looking for a <strong>very</strong> simple crypt / decrypt method. I will be using always the same static key. I'm aware of the risks of this approach. Currently I'm using the following code but it does not generate the same result after crypting and decripting the same string (there is some garbage in the middle of the string).</p>

<pre><code>public static string Crypt(this string text)
{
    string result = null;

    if (!String.IsNullOrEmpty(text))
    {
        byte[] plaintextBytes = Encoding.Unicode.GetBytes(text);

        SymmetricAlgorithm symmetricAlgorithm = DES.Create();
        symmetricAlgorithm.Key = new byte[8] {1, 2, 3, 4, 5, 6, 7, 8};
        using (MemoryStream memoryStream = new MemoryStream())
        {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, symmetricAlgorithm.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cryptoStream.Write(plaintextBytes, 0, plaintextBytes.Length);
            }

            result = Encoding.Unicode.GetString(memoryStream.ToArray());
        }
    }

    return result;
}

public static string Decrypt(this string text)
{
    string result = null;

    if (!String.IsNullOrEmpty(text))
    {
        byte[] encryptedBytes = Encoding.Unicode.GetBytes(text);

        SymmetricAlgorithm symmetricAlgorithm = DES.Create();
        symmetricAlgorithm.Key = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
        using (MemoryStream memoryStream = new MemoryStream(encryptedBytes))
        {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, symmetricAlgorithm.CreateDecryptor(), CryptoStreamMode.Read))
            {
                byte[] decryptedBytes = new byte[encryptedBytes.Length];
                cryptoStream.Read(decryptedBytes, 0, decryptedBytes.Length);
                result = Encoding.Unicode.GetString(decryptedBytes);
            }
        }
    }

    return result;
}
</code></pre>

<p>I can change whatever is needed, no limits (but I want just to have on method to crypt and another one to decrypt without sharing variables between them).</p>

<p>Thanks.</p>
","<p>If you don't want to handle keys yourself then let the operating system do it for your. E.g. use <a href=""http://msdn.microsoft.com/en-us/library/ms995355.aspx"" rel=""noreferrer"">Windows Data Protection</a> (DPAPI).</p>

<p>You can write your own, <code>string</code>-based, version of <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.protecteddata.protect.aspx"" rel=""noreferrer""><code>System.Security.Cryptography.ProtectedData.Protect</code></a> and <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.protecteddata.unprotect.aspx"" rel=""noreferrer""><code>Unprotect</code></a> methods by using something like:</p>

<pre><code>public static string Crypt (this string text)
{
    return Convert.ToBase64String (
        ProtectedData.Protect (
            Encoding.Unicode.GetBytes (text) ) );
}

public static string Derypt (this string text)
{
    return Encoding.Unicode.GetString (
        ProtectedData.Unprotect (
             Convert.FromBase64String (text) ) );
}
</code></pre>
","68813","<c#><encryption><encryption-symmetric><des>","26","55","3","2019-03-06 18:02:29","9034247","1","11","185123","","2019-03-06 18:02:29","2012-01-27 09:56:58",""
"5364338","Converted secret key into bytes, how to convert it back to secrect key?","<p>I convert the secretkey into bytes with following code</p>

<pre><code>SecretKey key = KeyGenerator.getInstance(""DES"").generateKey();
byte[] bkey=key.getEncoded();
</code></pre>

<p>Now how do I get the key from <code>bkey</code>? I tried:</p>

<pre><code>SecretKeySpec secretkey = new SecretKeySpec(bkey,""DES"");   
SecretKeyFactory sfkey = SecretKeyFactory.getInstance(""DES"");
SecretKey skey = sfkey.generateSecret(secretkey);
</code></pre>

<p>I get the following error:</p>

<pre><code>Error during Exception java.security.spec.InvalidKeySpecException: Inappropriate key specification
</code></pre>
","<p>This should work</p>

<pre><code>    SecretKey key = KeyGenerator.getInstance(""DES"").generateKey();
    byte[] data = key.getEncoded();
    SecretKey key2 = new SecretKeySpec(data, 0, data.length, ""DES"");
</code></pre>
","39816","<java><security><byte><des>","17","31","2","2013-07-04 13:26:56","5364380","8","6","634618","","2011-03-19 19:45:01","2011-03-19 19:22:25",""
"5364338","Converted secret key into bytes, how to convert it back to secrect key?","<p>I convert the secretkey into bytes with following code</p>

<pre><code>SecretKey key = KeyGenerator.getInstance(""DES"").generateKey();
byte[] bkey=key.getEncoded();
</code></pre>

<p>Now how do I get the key from <code>bkey</code>? I tried:</p>

<pre><code>SecretKeySpec secretkey = new SecretKeySpec(bkey,""DES"");   
SecretKeyFactory sfkey = SecretKeyFactory.getInstance(""DES"");
SecretKey skey = sfkey.generateSecret(secretkey);
</code></pre>

<p>I get the following error:</p>

<pre><code>Error during Exception java.security.spec.InvalidKeySpecException: Inappropriate key specification
</code></pre>
","<p>Try some of this code...</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.Key;
import java.security.InvalidKeyException;

public class DESede {
    private static String algorithm = ""DESede"";
    private static Key key = null;
    private static SecretKey secretKey = null;
    private static Cipher cipher = null;
    private static DESede obj = new DESede();

    private DESede() {
        try {
            key = KeyGenerator.getInstance(algorithm).generateKey();
            KeyGenerator.getInstance(algorithm).getProvider();
            byte[] keyBytes = key.getEncoded();
            String keyFormat = key.getFormat();
            String keyAlgorithm = key.getAlgorithm();
            String keyString = new String(keyBytes);
            System.out.println(""Key Format::"" + keyFormat);
            System.out.println(""Key Algorithm::"" + keyAlgorithm);
            System.out.println(""Key String::"" + keyString);
            keyString.getBytes();
            secretKey = new SecretKeySpec(keyBytes, 0, keyBytes.length, ""DESede"");
            byte[] secretKeyBytes = key.getEncoded();
            String secretKeyFormat = key.getFormat();
            String secretKeyAlgorithm = key.getAlgorithm();
            String secretKeyString = new String(secretKeyBytes);
            System.out.println(""Secret Key Format::"" + secretKeyFormat);
            System.out.println(""Secret Key Algorithm::"" + secretKeyAlgorithm);
            System.out.println(""Secret Key String::"" + secretKeyString);
            String keyNewString = ""bXŒ*êÂÕê›æOÄ’Îý‘ãô|8¶Ë1­"";
            byte[] keyNewBytes = keyString.getBytes();
            secretKey = new SecretKeySpec(keyBytes, 0, keyBytes.length, ""DESede"");
            cipher = Cipher.getInstance(algorithm);
        } catch (Exception e) {
        }
    }

    public static DESede getInstance() {
        return obj;
    }

    public static byte[] encrypt(String input) throws InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {
        System.out.println(""Inside encrypt()"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] inputBytes = input.getBytes();
        System.out.println(""Exit encrypt()"");
        return cipher.doFinal(inputBytes);
    }

    public static String decrypt(byte[] encryptionBytes)
            throws InvalidKeyException, BadPaddingException,
            IllegalBlockSizeException {
        System.out.println(""Inside decrypt()"");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        byte[] recoveredBytes = cipher.doFinal(encryptionBytes);
        String recovered = new String(recoveredBytes);
        System.out.println(""Exiting decrypt()"");
        return recovered;
    }

    public static void main(String args[]) throws InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {
        byte[] encryptedValue = DESede.encrypt(""plz try encrypt and decrypt me"");
        System.out.println(""encryptedValue::"" + encryptedValue);
        String decryptedValue = DESede.decrypt(encryptedValue);
        System.out.println(""decryptedValue::"" + decryptedValue);
    }
}
</code></pre>
","39816","<java><security><byte><des>","17","3","2","2013-07-04 13:26:56","5364380","8","6","634618","","2011-03-19 19:45:01","2011-03-19 19:22:25",""
"1354803","Java simple encryption","<p>I would like to encrypt a textual (configuration) file stored on disk.
Trying to use <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption I've had fatal error on client machines, I later found out the algorithm could not handle accented characters (!)
I suspect that was because I was using old packages (<code>sun.misc.BASE64Decoder</code>) - but I'm not sure that is the reason.</p>

<p>However, I'm looking for a simpler solution - I need a really simple encryption (I know some people would not agree on that) - not <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""noreferrer"">RSA</a> of 128 bit keys or so, just obscuring the text from curious eyes.</p>

<p>It is really weird that I could not find a simple trivial solution on the web.</p>

<p>How can I implement a simple encryption scheme?</p>
","<p>How about <a href=""http://en.wikipedia.org/wiki/ROT13"" rel=""nofollow noreferrer"">ROT13</a>? It's probably the most simple and worst encryption ever (it was also called the Caeser's Cipher)</p>

<p>Here's a basic implementation in Java by Jay Kominek:</p>

<pre><code>import java.io.*;

public class rot13 {
  public static void main (String args[]) {
    int abyte = 0;
    try { while((abyte = System.in.read())&gt;=0) {
      int cap = abyte &amp; 32;
      abyte &amp;= ~cap;
      abyte = ((abyte &gt;= 'A') &amp;&amp; (abyte &lt;= 'Z') ? ((abyte - 'A' + 13) % 26 + 'A') : abyte) | cap;
      System.out.print(String.valueOf((char)abyte));
    } } catch (IOException e) { }
    System.out.flush();
  }
}
</code></pre>
","33169","<java><encryption><des>","12","4","7","2013-02-01 11:26:05","","1","4","63550","","2010-04-22 20:20:48","2009-08-30 20:17:06",""
"1354803","Java simple encryption","<p>I would like to encrypt a textual (configuration) file stored on disk.
Trying to use <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption I've had fatal error on client machines, I later found out the algorithm could not handle accented characters (!)
I suspect that was because I was using old packages (<code>sun.misc.BASE64Decoder</code>) - but I'm not sure that is the reason.</p>

<p>However, I'm looking for a simpler solution - I need a really simple encryption (I know some people would not agree on that) - not <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""noreferrer"">RSA</a> of 128 bit keys or so, just obscuring the text from curious eyes.</p>

<p>It is really weird that I could not find a simple trivial solution on the web.</p>

<p>How can I implement a simple encryption scheme?</p>
","<p>If you have a single piece of text to encrypt, what about a one-time-pad? A one-time-pad is very easy to create; all you need is a random sequence of bytes the same length as the data you are encrypting</p>
","33169","<java><encryption><des>","12","0","7","2013-02-01 11:26:05","","1","4","63550","","2010-04-22 20:20:48","2009-08-30 20:17:06",""
"1354803","Java simple encryption","<p>I would like to encrypt a textual (configuration) file stored on disk.
Trying to use <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption I've had fatal error on client machines, I later found out the algorithm could not handle accented characters (!)
I suspect that was because I was using old packages (<code>sun.misc.BASE64Decoder</code>) - but I'm not sure that is the reason.</p>

<p>However, I'm looking for a simpler solution - I need a really simple encryption (I know some people would not agree on that) - not <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""noreferrer"">RSA</a> of 128 bit keys or so, just obscuring the text from curious eyes.</p>

<p>It is really weird that I could not find a simple trivial solution on the web.</p>

<p>How can I implement a simple encryption scheme?</p>
","<p>If you're not looking to really encrypt the text, why not encode with Base64? It'll look like nonsense, and it's very easy to decode. Plus, you're already using Base64 code...</p>
","33169","<java><encryption><des>","12","2","7","2013-02-01 11:26:05","","1","4","63550","","2010-04-22 20:20:48","2009-08-30 20:17:06",""
"1354803","Java simple encryption","<p>I would like to encrypt a textual (configuration) file stored on disk.
Trying to use <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption I've had fatal error on client machines, I later found out the algorithm could not handle accented characters (!)
I suspect that was because I was using old packages (<code>sun.misc.BASE64Decoder</code>) - but I'm not sure that is the reason.</p>

<p>However, I'm looking for a simpler solution - I need a really simple encryption (I know some people would not agree on that) - not <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""noreferrer"">RSA</a> of 128 bit keys or so, just obscuring the text from curious eyes.</p>

<p>It is really weird that I could not find a simple trivial solution on the web.</p>

<p>How can I implement a simple encryption scheme?</p>
","<p>See <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a> <code>BASE64Encoder</code> is used to represent the ciphered array of bytes, not the actual input.</p>
","33169","<java><encryption><des>","12","0","7","2013-02-01 11:26:05","","1","4","63550","","2010-04-22 20:20:48","2009-08-30 20:17:06",""
"1354803","Java simple encryption","<p>I would like to encrypt a textual (configuration) file stored on disk.
Trying to use <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption I've had fatal error on client machines, I later found out the algorithm could not handle accented characters (!)
I suspect that was because I was using old packages (<code>sun.misc.BASE64Decoder</code>) - but I'm not sure that is the reason.</p>

<p>However, I'm looking for a simpler solution - I need a really simple encryption (I know some people would not agree on that) - not <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""noreferrer"">RSA</a> of 128 bit keys or so, just obscuring the text from curious eyes.</p>

<p>It is really weird that I could not find a simple trivial solution on the web.</p>

<p>How can I implement a simple encryption scheme?</p>
","<p>Encryption algorithms work on raw bytes, not characters.</p>

<p>The reason you couldn't handle accented characters was because the code you were using to convert the characters to and from raw bytes didn't handle Unicode.</p>

<p>You should use <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a>; for an example of how to use it in Java, see <a href=""http://java.sun.com/developer/technicalArticles/Security/AES/AES_v1.html"" rel=""nofollow noreferrer"">here</a>.  </p>

<p><strong>EDIT</strong>: Right now, you might just be hiding it from curious eyes, but there's no telling what the future will hold, and it is always <strong>much</strong> better to use strong encryption now and not find out, to late, that you should have but didn't.</p>
","33169","<java><encryption><des>","12","6","7","2013-02-01 11:26:05","","1","4","63550","","2010-04-22 20:20:48","2009-08-30 20:17:06",""
"1354803","Java simple encryption","<p>I would like to encrypt a textual (configuration) file stored on disk.
Trying to use <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption I've had fatal error on client machines, I later found out the algorithm could not handle accented characters (!)
I suspect that was because I was using old packages (<code>sun.misc.BASE64Decoder</code>) - but I'm not sure that is the reason.</p>

<p>However, I'm looking for a simpler solution - I need a really simple encryption (I know some people would not agree on that) - not <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""noreferrer"">RSA</a> of 128 bit keys or so, just obscuring the text from curious eyes.</p>

<p>It is really weird that I could not find a simple trivial solution on the web.</p>

<p>How can I implement a simple encryption scheme?</p>
","<p>Check out the <a href=""http://jasypt.org/"" rel=""noreferrer"">Java Simplified Encryption (Jasypt)</a>.  </p>

<blockquote>
  <p>Jasypt is a java library which allows
  the developer to add basic encryption
  capabilities to his/her projects with
  minimum effort, and without the need
  of having deep knowledge on how
  cryptography works.</p>
  
  <ul>
  <li>High-security, standards-based encryption techniques, both for
  unidirectional and bidirectional
  encryption. Encrypt passwords, texts,
  numbers, binaries...</li>
  <li>Transparent integration with Hibernate.</li>
  <li>Suitable for integration into Spring-based applications and also
  transparently integrable with ACEGI
  (Spring Security).</li>
  <li>Integrated capabilities for encrypting the configuration of
  applications (i.e. datasources).</li>
  <li>Open API for use with any JCE provider.</li>
  <li>...and much more</li>
  </ul>
</blockquote>
","33169","<java><encryption><des>","12","22","7","2013-02-01 11:26:05","","1","4","63550","","2010-04-22 20:20:48","2009-08-30 20:17:06",""
"1354803","Java simple encryption","<p>I would like to encrypt a textual (configuration) file stored on disk.
Trying to use <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption I've had fatal error on client machines, I later found out the algorithm could not handle accented characters (!)
I suspect that was because I was using old packages (<code>sun.misc.BASE64Decoder</code>) - but I'm not sure that is the reason.</p>

<p>However, I'm looking for a simpler solution - I need a really simple encryption (I know some people would not agree on that) - not <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""noreferrer"">RSA</a> of 128 bit keys or so, just obscuring the text from curious eyes.</p>

<p>It is really weird that I could not find a simple trivial solution on the web.</p>

<p>How can I implement a simple encryption scheme?</p>
","<p>I'm using this simple <a href=""http://en.wikipedia.org/wiki/One-time_pad"" rel=""noreferrer"">One-Time-Pad</a> algorithm:</p>

<pre><code>import org.apache.commons.codec.binary.Base64;
public class Cipher {
  private static final String KEY = ""some-secret-key-of-your-choice"";
  public String encrypt(final String text) {
    return Base64.encodeBase64String(this.xor(text.getBytes()));
  }
  public String decrypt(final String hash) {
    try {
      return new String(this.xor(Base64.decodeBase64(hash.getBytes())), ""UTF-8"");
    } catch (java.io.UnsupportedEncodingException ex) {
      throw new IllegalStateException(ex);
    }
  }
  private byte[] xor(final byte[] input) {
    final byte[] output = new byte[input.length];
    final byte[] secret = this.KEY.getBytes();
    int spos = 0;
    for (int pos = 0; pos &lt; input.length; ++pos) {
      output[pos] = (byte) (input[pos] ^ secret[spos]);
      spos += 1;
      if (spos &gt;= secret.length) {
        spos = 0;
      }
    }
    return output;
  }
</code></pre>

<p>Don't forget to add <code>commons-codec</code> to classpath.</p>
","33169","<java><encryption><des>","12","8","7","2013-02-01 11:26:05","","1","4","63550","","2010-04-22 20:20:48","2009-08-30 20:17:06",""
"17205766","IllegalBlockSizeException: Input length must be multiple of 8 when decrypting with padded cipher","<p>I have the below method:</p>

<pre><code>public String decrypt(String strToBeDecrypted) {
    try {
        strToBeDecrypted = URLDecoder.decode(strToBeDecrypted, ""UTF-8"");
        DESKeySpec desKeySpec = new DESKeySpec(key);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
        SecretKey skey = keyFactory.generateSecret(desKeySpec);

        IvParameterSpec ivSpec = new IvParameterSpec(iv);

        cipher.init(Cipher.DECRYPT_MODE, skey, ivSpec);

        byte[] keyByteArray = new BASE64Decoder().decodeBuffer(strToBeDecrypted);

        byte[] original = cipher.doFinal(keyByteArray);

        return new String(original, ""UTF-8"");
    } catch (Exception e) {
        logger.error(ExceptionUtil.getDetailedMessage(e));
    }
    return """";
}
</code></pre>

<p>This is throwing </p>

<pre><code>""name=javax.crypto.IllegalBlockSizeException;message=Input length must be multiple of 8 when decrypting with padded cipher;""
</code></pre>

<p>at the below line:</p>

<pre><code> byte[] original = cipher.doFinal(keyByteArray);
</code></pre>

<p>Can someone please tell me whats the problem here?</p>
","<p>The input length it's referring to is the length of your ciphertext (strToBeDecrypted), which it expects to be a multiple of the block size. It is implied that by default the library is expecting your input to be padded.</p>

<p>That means either you either need to set the padding to 'none' when decrypting (as that was the 'padding' used when encrypting) or you've corrupted the ciphertext somehow.</p>

<p>Try changing ""DES"" to ""DES/ECB/NoPadding"". I don't know what the default cipher mode is for your implementation, but it's typically ""ECB"" or ""CBC"". If neither of those two work then you're corrupting your ciphertext somewhere along the line.</p>
","31981","<java><encryption><des>","3","2","1","2015-03-20 04:39:59","","3","1","474189","","2013-06-20 06:59:05","2013-06-20 05:14:25",""
"1284771","Java PBEWithMD5AndDES","<p>I am using password based encryption. My initial thought was to use AES to encrypt the file which contains passwords. Turns out password based encryption does not support AES. It uses DES. AFAIK des is not secure. Is PBEWithMD5AndDES secure enough to thrust my data or should i look for another implementation? </p>
","<p>You should not be keeping the passwords in any form other than <a href=""http://en.wikipedia.org/wiki/Salt_%28cryptography%29"" rel=""nofollow noreferrer"">salted</a> <a href=""http://en.wikipedia.org/wiki/Cryptographic_hash_function"" rel=""nofollow noreferrer"">hash digests</a>.</p>

<p>You should then use the operating system permission system to make it such that the hashed password file is only readable by the user which validates passwords.</p>
","26062","<java><encryption><aes><des>","11","-1","3","2014-02-26 04:09:21","1285463","2","2","","","","2009-08-16 16:58:33",""
"1284771","Java PBEWithMD5AndDES","<p>I am using password based encryption. My initial thought was to use AES to encrypt the file which contains passwords. Turns out password based encryption does not support AES. It uses DES. AFAIK des is not secure. Is PBEWithMD5AndDES secure enough to thrust my data or should i look for another implementation? </p>
","<p>It appears from your comments that what you would like to do is to encrypt a file which contains sensitive information, using a password-based encryption scheme, with a password provided by the user at decrypt-time. The sensitive information in this case also happens to be passwords, but that isn't really relevant.  (You should probably update the question to make this more clear).</p>

<p>You are doing the right thing, your problem is just that the SunJCE Java cryptography provider doesn't support AES for password-based encryption.  You need to use an alternative provider which does: for example, you could use the <a href=""http://www.bouncycastle.org/java.html"" rel=""noreferrer"">Bouncy Castle</a> provider with the algorithm <code>""PBEWITHSHA256AND128BITAES-CBC-BC""</code>.  (Despite the whimsical name, Bouncy Castle is well-respected).</p>

<p>As for ""is DES secure enough for my data"", well if the data you're protecting would be worth less than roughly $10,000 to an attacker, then back in 2009 it was probably just secure enough.  And in 2014, if your data is worth encrypting at all, the answer is no.</p>
","26062","<java><encryption><aes><des>","11","16","3","2014-02-26 04:09:21","1285463","2","2","","","","2009-08-16 16:58:33",""
"1284771","Java PBEWithMD5AndDES","<p>I am using password based encryption. My initial thought was to use AES to encrypt the file which contains passwords. Turns out password based encryption does not support AES. It uses DES. AFAIK des is not secure. Is PBEWithMD5AndDES secure enough to thrust my data or should i look for another implementation? </p>
","<p>If you have Java 6 available, everything you need is available. Check out this <a href=""https://stackoverflow.com/questions/992019/java-256bit-aes-encryption"">question</a> and look at the accepted answer for a code sample. Since you want to encrypt files, the iv that is generated should be prepended to the file you are writing the ciphertext to, so that it is available during the decryption.</p>
","26062","<java><encryption><aes><des>","11","3","3","2014-02-26 04:09:21","1285463","2","2","","","","2009-08-16 16:58:33",""
"12292389","Converting Key to String and back to Key Java","<p>so I'm trying to convert a Key into a string so I can display it with System.out, and then I want to convert it back to a Key. I am able to convert it to a string with BASE64Encoder, but I'm having problems converting it back. Here is my source code:</p>

<pre><code>    public class Encryption extends Applet {
    Key keyOrig;
    BASE64Decoder decoder = new BASE64Decoder();
    BASE64Encoder encoder = new BASE64Encoder();

    public void init() {
        try {
            keyOrig = generateKey();

            String keyString = encoder.encode(keyOrig.getEncoded());
            System.out.println(""Key: ""+keyString);

            Key key = new SecretKeySpec(keyString.getBytes(),0,keyString.getBytes().length, ""DES"");     

            String message = ""This is hacker proof!"";
            System.out.println(""Message is: ""+message);

            String encryptedMessage = encrypt(message,key);
            System.out.println(""Message encrypted: ""+ encryptedMessage);

            String decryptedMessage = decrypt(encryptedMessage,key);
            System.out.println(""Message decrypted: ""+ decryptedMessage);



        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public Key generateKey() throws NoSuchAlgorithmException {
        KeyGenerator generator;
        generator = KeyGenerator.getInstance(""DES"");
        generator.init(new SecureRandom());
        return keyOrig = generator.generateKey();
    }

    @SuppressWarnings(""unused"")
    public String encrypt(String message, Key key)
            throws IllegalBlockSizeException, BadPaddingException,
            NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, UnsupportedEncodingException {
        // Get a cipher object.
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);

        // Gets the raw bytes to encrypt, UTF8 is needed for
        // having a standard character set
        byte[] stringBytes = message.getBytes(""UTF8"");

        // encrypt using the cypher
        byte[] raw = cipher.doFinal(stringBytes);

        // converts to base64 for easier display.
        @SuppressWarnings(""restriction"")
        BASE64Encoder encoder = new BASE64Encoder();
        String base64 = encoder.encode(raw);

        return base64;
    }

    public String decrypt(String encrypted, Key key) throws InvalidKeyException,
            NoSuchAlgorithmException, NoSuchPaddingException,
            IllegalBlockSizeException, BadPaddingException, IOException {

        // Get a cipher object.
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key);

        // decode the BASE64 coded message
        BASE64Decoder decoder = new BASE64Decoder();
        byte[] raw = decoder.decodeBuffer(encrypted);

        // decode the message
        byte[] stringBytes = cipher.doFinal(raw);

        // converts the decoded message to a String
        String clear = new String(stringBytes, ""UTF8"");
        return clear;
    }
}
</code></pre>
","<p>You never use your <code>BASE64Decoder</code> to un-base-64 your string.</p>

<p>Replace this:</p>

<pre><code>        Key key = new SecretKeySpec(keyString.getBytes(),0,keyString.getBytes().length, ""DES"");     
</code></pre>

<p>with</p>

<pre><code>        byte[] encodedKey = decoder.decodeBuffer(keyString);
        Key key = new SecretKeySpec(encodedKey,0,encodedKey.length, ""DES"");     
</code></pre>
","19087","<java><key><des>","5","6","1","2012-09-06 03:05:44","12292428","0","4","","","","2012-09-06 03:00:11",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>The <a href=""http://www.openssl.org/"" rel=""nofollow noreferrer"">OpenSSL</a> library provides reliable source code for 3DES and many other cryptographic algorithms. The <a href=""http://www.openssl.org/docs/crypto/des.html#"" rel=""nofollow noreferrer"">libcrypto documentaton on the DES_*</a> functions describes what is available.</p>
","18952","<des><3des>","9","1","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>I'll bet some banking cards in fact use triple des. It is remarkable how running a business ( in the real world ) diverges from what one would think just from studying the problem. Just interested or is there an actual challenge at hand? ( be it study assignment or otherwise )</p>
","18952","<des><3des>","9","0","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>Triple-DES is still in use today but is widely considered a legacy encryption algorithm. DES is inherently insecure, while Triple-DES has much better security characteristics but is still considered problematic.</p>

<p>NIST is the government organization that standardizes on cryptographic algorithms. The most current symmetric-key encryption algorithm NIST standard is AES, the Advanced Encryption Standard. In fact, there were a number of good nominations to be NIST's AES, including the Rijndael algorithm which became AES, as well as Bruce Schneier's Blowfish, the Twofish algorithm, and the Serpent algorithm.</p>
","18952","<des><3des>","9","12","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>EDIT: @David Koontz replied to this post, and I had a chance to look 5 years into the past. I'm leaving my post intact below, but for anyone reading this now, avoid 3DES if you have the opportunity, and if not, get an expert to look at your specific system. There's no guarantee that a general answer will apply to your situation, in computer security especially.</p>

<p>Yes.</p>

<p>3DES is broken, but when a cryptographer says ""broken,"" that means something very specific: that an attacker can break the key in better-than-brute-force time. 3DES has a key length of 168 bits, which is reduced to 112 bits by some meet-in-the-middle attack cleverness. And, to quote Wikipedia, ""it is designated by NIST to have only 80 bits of security.""</p>

<p>It's pretty badly broken, but even so, 80 bits makes for a very big number; 3DES is plenty good for beating people with fewer resources than the NSA, for example, and it will be for maybe 10 or 15 years, with some luck. The incentive to replace 3DES it isn't high enough for a lot of people who aren't using it to protect expensive things.</p>
","18952","<des><3des>","9","10","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>You are right about banking. But everything happens in hardware level. One popular technology is <a href=""http://iss.thalesgroup.com/Products/Hardware%20Security%20Modules/HSM%208000.aspx#fragment-3"" rel=""nofollow noreferrer"">HSM</a>.</p>
","18952","<des><3des>","9","1","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>To answer your question of where 3DES is being used, I would like to add that Microsoft OneNote, Microsoft Outlook 2007 and Microsoft System Center Configuration Manager 2012 use Triple DES to password protect user content and system data.</p>

<p>See also:<br></p>

<ol>
<li>1.<a href=""http://blogs.msdn.com/descapa/archive/2006/11/09/encryption-for-password-protected-sections.aspx"" rel=""nofollow"">Daniel Escapa's OneNote Blog - Encryption for Password Protected Sections, November 2006</a></li>
<li><a href=""http://technet.microsoft.com/en-us/library/hh427327.aspx"" rel=""nofollow"">Microsoft TechNet product documentation - Technical Reference for Cryptographic Controls Used in Configuration Manager, October 2012</a></li>
</ol>
","18952","<des><3des>","9","1","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>3DES has a Problem described already in two CVE Issues
which is called the SWEET32 Issue. Its base Cipher Dephth is 64Bit (though used along three Rounds) so it belongs to a Family of originally weak Ciphers as well
From today's Standpoint of Security in 2017 and its probability to be broken
more often and more easily, is should no longer be used.</p>
","18952","<des><3des>","9","0","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"25425486","javax.crypto.IllegalBlockSizeException: Input length not multiple of 8 bytes","<p>i am getting this error while decryption i have go through the similar posts but i did not get any help from there. I want to store an object directly in a file with encryption for that i have posted my question <a href=""https://stackoverflow.com/questions/25399785/encrypt-complete-object-with-triple-des/25400892#25400892"">here</a>. But while using stream i am getting the same error as i am getting with string.  </p>

<pre><code>package security;

import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/**
 * This class defines methods for encrypting and decrypting using the Triple DES
 * algorithm and for generating, reading and writing Triple DES keys. It also
 * defines a main() method that allows these methods to be used from the command
 * line.
 */
public class TripleDesEncryptionDecryption {
  /**
   * The program. The first argument must be -e, -d, or -g to encrypt,
   * decrypt, or generate a key. The second argument is the name of a file
   * from which the key is read or to which it is written for -g. The -e and
   * -d arguments cause the program to read from standard input and encrypt or
   * decrypt to standard output.
   */
    private static final String UNICODE_FORMAT = ""UTF-8"";
    public static final String DESEDE_ENCRYPTION_SCHEME = ""DESede"";
    private KeySpec myKeySpec;
    private SecretKeyFactory mySecretKeyFactory;
    private Cipher cipher;
    byte[] keyAsBytes;
    private String myEncryptionKey;
    private String myEncryptionScheme;
    SecretKey key;
    static String stringToEncrypt="""";

    public void setKey(String myKey) throws Exception
    {
        myEncryptionKey = myKey ;
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        myKeySpec = new DESedeKeySpec(keyAsBytes);
        mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(""DESede/ECB/NoPadding"");
        key = mySecretKeyFactory.generateSecret(myKeySpec);
    }

    /**
     * Method To Encrypt The String
     */
    public String encrypt(byte[] plainText) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            //byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            //byte[] encryptedText = cipher.doFinal(plainText);
            BASE64Encoder base64encoder = new BASE64Encoder();
            encryptedString = base64encoder.encode(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }
    /**
     * Method To Decrypt An Ecrypted String
     */
    public String decrypt(String encryptedString) {
        String decryptedText=null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            BASE64Decoder base64decoder = new BASE64Decoder();
            System.out.println(myEncryptionKey);
            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }
    /**
     * Returns String From An Array Of Bytes
     */
    private static String bytes2String(byte[] bytes) {
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            stringBuffer.append((char) bytes[i]);
        }
        return stringBuffer.toString();
    }

    /**
     * Testing The DESede Encryption And Decryption Technique
    */
    public static void main(String args []) throws Exception
    {
        TripleDesEncryptionDecryption myEncryptor= new TripleDesEncryptionDecryption();


        myEncryptor.setKey(""tarunvermacdac@gmail.com"") ;

        System.out.println(""tarun1234"".getBytes());
        String encrypted=myEncryptor.encrypt(""tarun"".getBytes());
        String decrypted=myEncryptor.decrypt(encrypted);

        System.out.println(""String To Encrypt: ""+stringToEncrypt);
        System.out.println(""Encrypted Value :"" + encrypted);
        System.out.println(""Decrypted Value :""+decrypted);
    }
}
</code></pre>
","<p>I don't exactly know what you want to achieve, but I can at least explain the error you are getting.</p>

<p><strong>DES</strong> and <strong>3DES</strong> have a <em>block-length</em> of <code>64 bit</code>. That means you must pass a <em>plaintext</em> which length is a <strong>multiple of 64-bits</strong> to the encryption-function. To achieve this you usually <em>pad</em> / fill up the last block of the plaintext with data of a certain pattern so that you can easily remove it again after decryption.</p>

<p>In your code you specify the encryption-parameters like this: <code>DESede/ECB/NoPadding</code> <br>
So you explicitly opt to not automatically apply any padding.</p>

<hr>

<p>To fix this, just specify a padding mode (for example <code>PKCS5Padding</code>) instead of <code>NoPadding</code>.</p>

<p><strong>Note:</strong> The cipher-mode <code>ECB</code> is not secure at all! You should instead better use:</p>

<pre><code>Cipher.getInstance(""DESede/CBC/PKCS5Padding""); // or ""AES"" instead of ""DESede""
</code></pre>

<p><em>(you must provide an additional <code>IV</code> though when using a mode like <code>CBC</code> or <code>CTR</code>)</em></p>
","16245","<java><des><tripledes>","1","6","1","2014-08-21 15:47:06","","0","2","-1","","2017-05-23 11:45:46","2014-08-21 11:43:19",""
"2512184","How to encrypt an NSString in Objective C with DES in ECB-Mode?","<p>I am trying to encrypt an NSString in Objective C on the iPhone. At least I wan't to get a string like ""TmsbDaNG64lI8wC6NLhXOGvfu2IjLGuEwc0CzoSHnrs="" when I encode ""us=foo;pw=bar;pwAlg=false;"" by using this key: ""testtest"".</p>

<p>My problem for now is, that CCCrypt always returns ""4300 - Parameter error"" and I have no more idea why.</p>

<p>This is my code (the result of 5 hours google and try'n'error):</p>

<pre><code>NSString *token = @""us=foo;pw=bar;pwAlg=false;"";
NSString *key = @""testtest"";

const void *vplainText;
size_t plainTextBufferSize;

plainTextBufferSize = [token length];
vplainText = (const void *) [token UTF8String];

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t *movedBytes;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);
// memset((void *) iv, 0x0, (size_t) sizeof(iv));


NSString *initVec = @""init Vec"";
const void *vkey = (const void *) [key UTF8String];
const void *vinitVec = (const void *) [initVec UTF8String];

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithmDES,
                   kCCOptionECBMode,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySizeDES,
                   NULL,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   movedBytes);

NSString *result;
NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
result = [myData base64Encoding];
</code></pre>
","<p>DES encryption in ECB mode uses an 8 byte block size, and encodes each blocks individually. The problem is that your input string doesn't divide into 8 bytes equally and the cryptor doesn't know what to do with the final non 8 byte block.</p>

<p>The fix is to allow the cryptor to pad the final block by adding kCCOptionPKCS7Padding to the options to CCCrypt. eg (snippet from an NSData encryption category):</p>

<pre><code>CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, 
                                      kCCAlgorithmDES, 
                                      kCCOptionPKCS7Padding | kCCOptionECBMode,
                                      keyPtr, 
                                      kCCKeySizeDES,
                                      NULL, 
                                      [self bytes], 
                                      dataLength,
                                      buffer, 
                                      bufferSize
                                      &amp;numBytesEncrypted);
</code></pre>

<p>Take a look at this <a href=""http://www.di-mgt.com.au/cryptopad.html#exampleecb"" rel=""noreferrer"">post</a> for more details regarding padding algorithms. Hope this helps.</p>
","14124","<iphone><base64><encode><des>","2","10","1","2010-11-08 17:19:50","2512653","0","1","","","","2010-03-24 23:25:44",""
"24903575","How to return byte[] when decrypt using CryptoStream (DESCryptoServiceProvider)","<p>This is a beginner question, </p>

<p>Everytime I search on the internet, decrypt with DESCryptoServiceProvider function always returning a string. </p>

<p>How can we get byte[] for the return? </p>

<p>This is the code. Thank you for any help.</p>

<pre><code>DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
cryptoProvider.Padding = PaddingMode.None;
cryptoProvider.Mode = CipherMode.CBC;

MemoryStream memoryStream = new MemoryStream(value);
CryptoStream cryptoStream = new CryptoStream(memoryStream, 
cryptoProvider.CreateDecryptor(password, initVector), CryptoStreamMode.Read);
StreamReader reader = new StreamReader(cryptoStream);

return reader.ReadToEnd();            
//how to return byte[];
</code></pre>
","<p>I had this problem too, and I created a <code>class</code> with some functions to help me with this issues.</p>

<p>The function to perform the cryptography is:</p>

<pre><code>private byte[] PerformCryptography(ICryptoTransform cryptoTransform, byte[] data)
        {
            using (var memoryStream = new MemoryStream())
            {
                using (var cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))
                {
                    cryptoStream.Write(data, 0, data.Length);
                    cryptoStream.FlushFinalBlock();
                    return memoryStream.ToArray();
                }
            }
        }
</code></pre>

<p>The <code>ICryptoTransform</code> is either a spezific encryptor or decryptor.</p>

<p>This Method works for symmetric altorithm's</p>

<p>Just for example, the methods for encryption and decryption look like:</p>

<pre><code>public byte[] Encrypt(byte[] data)
{
    if (CanPerformCryptography(data))
    {
        using (var encryptor = _algorithm.CreateEncryptor(_key, _iv))
        {
            return PerformCryptography(encryptor, data);
        }
    }
    return data;
}

public byte[] Decrypt(byte[] data)
{
    if (CanPerformCryptography(data))
    {
        using (var decryptor = _algorithm.CreateDecryptor(_key, _iv))
        {
            return PerformCryptography(decryptor, data);
        }
    }
    return data;
}
</code></pre>
","13192","<c#><encryption><bytearray><des>","8","23","1","2015-12-14 03:18:50","24903689","0","3","2847237","","2015-12-14 03:18:50","2014-07-23 06:47:56",""
"22951606","Exception java.security.InvalidKeyException: Invalid key length: 24 bytes using DESede","<p>I know that this question is often asked but I have checked everything I found in Stack Overflow and did not find the solution to my problem.<br>
i am using DESede for encryption and decryption and taking external 24 byte key input. but getting exception.</p>

<p>here is my code:</p>

<pre><code>    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.spec.InvalidKeySpecException;

    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.SecretKeyFactory;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.DESedeKeySpec;
    import javax.xml.bind.DatatypeConverter;

    public class DESede {

     private static Cipher encryptCipher;
     private static Cipher decryptCipher;

     public static void main(String[] args) throws InvalidKeySpecException {
      try {


       String desKey = ""0123456789abcdef0123456789abcdef0123456789abcdef""; // value from user
       byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);
       System.out.println((int)keyBytes.length);

       SecretKeyFactory factory = SecretKeyFactory.getInstance(""DESede"");
       SecretKey key = factory.generateSecret(new DESedeKeySpec(keyBytes));

       encryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
       encryptCipher.init(Cipher.ENCRYPT_MODE, key); //throwing Exception
       byte[] encryptedData = encryptData(""Confidential data"");

       decryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
       decryptCipher.init(Cipher.DECRYPT_MODE, key);
       decryptData(encryptedData);

      } catch (NoSuchAlgorithmException e) {
       e.printStackTrace();
      } catch (NoSuchPaddingException e) {
       e.printStackTrace();
      } catch (InvalidKeyException e) {
       e.printStackTrace();
      } catch (IllegalBlockSizeException e) {
       e.printStackTrace();
      } catch (BadPaddingException e) {
       e.printStackTrace();
      }

     }
</code></pre>

<p>//method for encryption</p>

<pre><code>     private static byte[] encryptData(String data)
       throws IllegalBlockSizeException, BadPaddingException {
      System.out.println(""Data Before Encryption :"" + data);
      byte[] dataToEncrypt = data.getBytes();
      byte[] encryptedData = encryptCipher.doFinal(dataToEncrypt);
      System.out.println(""Encryted Data: "" + encryptedData);

      return encryptedData;
     }
</code></pre>

<p>//method for decryption</p>

<pre><code>     private static void decryptData(byte[] data)
       throws IllegalBlockSizeException, BadPaddingException {
      byte[] textDecrypted = decryptCipher.doFinal(data);
      System.out.println(""Decryted Data: "" + new String(textDecrypted));
     }
    }
</code></pre>

<p>i am getting exception at the line: java.security.InvalidKeyException: Invalid key length: 24 bytes</p>

<pre><code>encryptCipher.init(Cipher.ENCRYPT_MODE, key);
</code></pre>

<p>any one have any idea why this is happening?</p>
","<p>There is two mistakes you have done in your code</p>

<p>you use <code>DESede</code> to create the secret key factory in this line </p>

<pre><code> SecretKeyFactory factory = SecretKeyFactory.getInstance(""DESede"");
</code></pre>

<p>but you use the <code>DES</code> to get the <code>Cipher</code> object. you have to use <code>DESede</code> instead</p>

<p>so use this line </p>

<p><code>encryptCipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");</code> </p>

<p>instead of this line </p>

<p><code>encryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");</code></p>

<p>use the same algorithm to get decripting cipher </p>

<p>and another one is use a <code>AlgorithmParameterSpec</code> to init the decrypting cipher. </p>

<pre><code>byte iv[] = encryptCipher.getIV(); 
IvParameterSpec dps = new IvParameterSpec(iv);
decryptCipher.init(Cipher.DECRYPT_MODE, key, dps);
</code></pre>

<p>you can use above code to apply the <code>AlgorithmParameterSpec</code> to the initialization of cipher</p>
","12421","<java><exception><encryption><key><des>","2","1","1","2015-12-15 06:00:20","22952981","1","4","","","","2014-04-09 02:15:58",""
"965042","C# - Serializing/Deserializing a DES encrypted file from a stream","<p>Does anyone have any examples of how to encrypt serialized data to a file and then read it back using DES?</p>

<p>I've written some code already that isn't working, but I'd rather see a fresh attempt instead of pursuing my code.</p>

<p><strong>EDIT</strong>: Sorry, forgot to mention I need an example using XmlSerializer.Serialize/Deserialize.</p>
","<p><a href=""http://www.codeproject.com/KB/cs/NET_Encrypt_Decrypt.aspx"" rel=""nofollow noreferrer"">Here is an example</a> of DES encryption/decription for a string.</p>
","12269","<c#><serialization><encryption><des>","10","0","3","2012-05-16 14:47:43","965188","3","8","44269","","2009-06-08 14:11:02","2009-06-08 13:56:59",""
"965042","C# - Serializing/Deserializing a DES encrypted file from a stream","<p>Does anyone have any examples of how to encrypt serialized data to a file and then read it back using DES?</p>

<p>I've written some code already that isn't working, but I'd rather see a fresh attempt instead of pursuing my code.</p>

<p><strong>EDIT</strong>: Sorry, forgot to mention I need an example using XmlSerializer.Serialize/Deserialize.</p>
","<p>Encryption</p>

<pre><code>public static void EncryptAndSerialize(string filename, MyObject obj, SymmetricAlgorithm key)
{
    using(FileStream fs = File.Open(filename, FileMode.Create))
    {
        using(CryptoStream cs = new CryptoStream(fs, key.CreateEncryptor(), CryptoStreamMode.Write))
        {
            XmlSerializer xmlser = new XmlSerializer(typeof(MyObject));
            xmlser.Serialize(cs, obj); 
        }
    }
}
</code></pre>

<p>Decryption:</p>

<pre><code>public static MyObject DecryptAndDeserialize(string filename, SymmetricAlgorithm key)    
{
    using(FileStream fs = File.Open(filename, FileMode.Open))
    {
        using(CryptoStream cs = new CryptoStream(fs, key.CreateDecryptor(), CryptoStreamMode.Read))
        {
            XmlSerializer xmlser = new XmlSerializer(typeof(MyObject));
            return (MyObject) xmlser.Deserialize(cs);
        }
    }
}
</code></pre>

<p>Usage:</p>

<pre><code>DESCryptoServiceProvider key = new DESCryptoServiceProvider();
MyObject obj = new MyObject();
EncryptAndSerialize(""testfile.xml"", obj, key);
MyObject deobj = DecryptAndDeserialize(""testfile.xml"", key);
</code></pre>

<p>You need to change MyObject to whatever the type of your object is that you are serializing, but this is the general idea. The trick is to use the same SymmetricAlgorithm instance to encrypt and decrypt.</p>
","12269","<c#><serialization><encryption><des>","10","19","3","2012-05-16 14:47:43","965188","3","8","44269","","2009-06-08 14:11:02","2009-06-08 13:56:59",""
"965042","C# - Serializing/Deserializing a DES encrypted file from a stream","<p>Does anyone have any examples of how to encrypt serialized data to a file and then read it back using DES?</p>

<p>I've written some code already that isn't working, but I'd rather see a fresh attempt instead of pursuing my code.</p>

<p><strong>EDIT</strong>: Sorry, forgot to mention I need an example using XmlSerializer.Serialize/Deserialize.</p>
","<p>This thread gave the basic idea.  Here's a version that makes the functions generic, and also allows you to pass an encryption key so it's reversible.</p>

<pre><code>public static void EncryptAndSerialize&lt;T&gt;(string filename, T obj, string encryptionKey) {
  var key = new DESCryptoServiceProvider();
  var e = key.CreateEncryptor(Encoding.ASCII.GetBytes(""64bitPas""), Encoding.ASCII.GetBytes(encryptionKey));
  using (var fs = File.Open(filename, FileMode.Create))
  using (var cs = new CryptoStream(fs, e, CryptoStreamMode.Write))
      (new XmlSerializer(typeof (T))).Serialize(cs, obj);
}

public static T DecryptAndDeserialize&lt;T&gt;(string filename, string encryptionKey) {
  var key = new DESCryptoServiceProvider();
  var d = key.CreateDecryptor(Encoding.ASCII.GetBytes(""64bitPas""), Encoding.ASCII.GetBytes(encryptionKey));
  using (var fs = File.Open(filename, FileMode.Open))
  using (var cs = new CryptoStream(fs, d, CryptoStreamMode.Read))
      return (T) (new XmlSerializer(typeof (T))).Deserialize(cs);
}
</code></pre>
","12269","<c#><serialization><encryption><des>","10","3","3","2012-05-16 14:47:43","965188","3","8","44269","","2009-06-08 14:11:02","2009-06-08 13:56:59",""
"257015","DES Encryption","<p>Are DES Encryption called ""One Way Encryption"" or ""two way Encryption"" ?
Are there a PHP class or method decrypt the DES Encryption ?
thanks</p>
","<p>DES can be reversed, so it's a two-way encryption (if you meant that).</p>

<p>DES is a pretty well known encryption standard so it should be available in PHP too.</p>
","11909","<php><encryption><des>","0","2","6","2008-12-29 15:48:14","257036","0","1","21699","Tigraine","2008-11-02 16:22:34","2008-11-02 16:12:40",""
"257015","DES Encryption","<p>Are DES Encryption called ""One Way Encryption"" or ""two way Encryption"" ?
Are there a PHP class or method decrypt the DES Encryption ?
thanks</p>
","<p>I am not familiar with the ""one way encryption"" or ""two way encryption"" terms. There is a term ""one time password"" (totally irrelevant for DES), and there are ""symmetric"" and ""assymetric"" encryption algorithms, meaning whether the same key is used for encryption and decryption (symmetric) or a set of two different keys is used one for encryption and another for decryption (assymetric). DES is a symmetric algorithm. As for PHP, crypt() since to be doing the job:</p>

<p><a href=""http://us2.php.net/crypt"" rel=""nofollow noreferrer"">http://us2.php.net/crypt</a></p>
","11909","<php><encryption><des>","0","-1","6","2008-12-29 15:48:14","257036","0","1","21699","Tigraine","2008-11-02 16:22:34","2008-11-02 16:12:40",""
"257015","DES Encryption","<p>Are DES Encryption called ""One Way Encryption"" or ""two way Encryption"" ?
Are there a PHP class or method decrypt the DES Encryption ?
thanks</p>
","<p>The php <a href=""http://us2.php.net/crypt"" rel=""nofollow noreferrer"">crypt</a> function is a one-way hashing function, if you want to be able to decrypt, take a look at the <a href=""http://us2.php.net/manual/en/book.mcrypt.php"" rel=""nofollow noreferrer"">mcrypt</a> extension which supports <a href=""http://us2.php.net/manual/en/mcrypt.ciphers.php"" rel=""nofollow noreferrer"">a range of algorithms</a></p>
","11909","<php><encryption><des>","0","4","6","2008-12-29 15:48:14","257036","0","1","21699","Tigraine","2008-11-02 16:22:34","2008-11-02 16:12:40",""
"257015","DES Encryption","<p>Are DES Encryption called ""One Way Encryption"" or ""two way Encryption"" ?
Are there a PHP class or method decrypt the DES Encryption ?
thanks</p>
","<p>It should be noted that there are (and have always been) questions surrounding the <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow noreferrer"">DES</a> algorithm. It's been widely in use for a long time, but since it was originally specified with only a 56 bit key, it's questionable whether it's secure enough for any important uses at this point. Triple DES is generally better, but there are some known theoretical attacks. If you have a choice of cipher, you might want to look at <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a> instead. </p>
","11909","<php><encryption><des>","0","3","6","2008-12-29 15:48:14","257036","0","1","21699","Tigraine","2008-11-02 16:22:34","2008-11-02 16:12:40",""
"257015","DES Encryption","<p>Are DES Encryption called ""One Way Encryption"" or ""two way Encryption"" ?
Are there a PHP class or method decrypt the DES Encryption ?
thanks</p>
","<p><strong>One-way encryption</strong> is a secure form of <em>hashing</em>: the plaintext is changed into an apparently random sequence of data, often of fixed length, in such a way that the original plaintext (theoretically) cannot be retrieved without a brute-force effort.</p>

<p><strong>Two-way encryption</strong>, or <strong>reversible encryption</strong> is what we normally mean by the term <em>encryption</em>: the plaintext is transformed into apparently random data, but in a way that relies on a ""key"" that allows the original plaintext to be retrieved.</p>

<p>DES is a form of reversible encryption that is relatively weak by today's standards, as it relies on a 56-bit key (14 hex characters).  It has been superseded by 3DES, or triple-DES, which is essentially the same algorithm with a longer key.</p>

<p>You don't mention your application, but if you need only to <em>compare</em> the data and not <em>retrieve</em> it, hashing is considered more secure.  For example, you can store hashed passwords; then, when a user authenticates, perform the same hash on the entered text and compare it with the stored hashed value.  If they match, the correct password was entered.</p>

<p>A significant advantage to hashing is that you don't need to store a decryption key.</p>
","11909","<php><encryption><des>","0","2","6","2008-12-29 15:48:14","257036","0","1","21699","Tigraine","2008-11-02 16:22:34","2008-11-02 16:12:40",""
"257015","DES Encryption","<p>Are DES Encryption called ""One Way Encryption"" or ""two way Encryption"" ?
Are there a PHP class or method decrypt the DES Encryption ?
thanks</p>
","<p>I Think you probably mean a one-way function [1]. In cryptography one distinguishes between symmetric and asymmetric cryptography. Symmetric cryptography uses the same key to encrypt and decrypt (DES is symmetric). Asymmetric Cryptography is used for key exchange and a public key is used to encrypt the message, while the private key is used to decrypt it. An example of Asymmetric Cryptography is AES [2]. Asymmetric cryptography uses one way functions.</p>

<p>[1] <a href=""http://en.wikipedia.org/wiki/One-way_function"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/One-way_function</a>
[2] <a href=""http://en.wikipedia.org/wiki/AES"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/AES</a></p>
","11909","<php><encryption><des>","0","-1","6","2008-12-29 15:48:14","257036","0","1","21699","Tigraine","2008-11-02 16:22:34","2008-11-02 16:12:40",""
"15682840","Reading encrypted data from a file","<p>I was going through an IBM tutorial on encrypting using Private key. And I wrote the code as below</p>

<pre><code>import java.security.*;
import javax.crypto.*;

// encrypt and decrypt using the DES private key algorithm

public class PrivateExample {

  public static void main (String[] args) throws Exception {
    String text=new String();
     text=""THIS IS AN ENCRYPTION TEST"";
     byte[] plainText = text.getBytes(""UTF8"");

    // get a DES private key
    System.out.println( ""\nStart generating DES key"" );
    KeyGenerator keyGen = KeyGenerator.getInstance(""DES"");
    keyGen.init(56);
    Key key = keyGen.generateKey();
    System.out.println( ""Finish generating DES key"" );

    // get a DES cipher object and print the provider
    Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    System.out.println( ""\n"" + cipher.getProvider().getInfo() );
    //
    // encrypt using the key and the plaintext
    System.out.println( ""\nStart encryption"" );
    cipher.init(Cipher.ENCRYPT_MODE, key);
    byte[] cipherText = cipher.doFinal(plainText);
    System.out.println( ""Finish encryption: "" );
    System.out.println( new String(cipherText, ""UTF8"") );

    //
    // decrypt the ciphertext using the same key
    System.out.println( ""\nStart decryption"" );
    cipher.init(Cipher.DECRYPT_MODE, key);
    byte[] newPlainText = cipher.doFinal(cipherText);
    System.out.println( ""Finish decryption: "" );

    System.out.println( new String(newPlainText, ""UTF8"") );
  }
}
</code></pre>

<p>The above code works great. I am able to see the result and everything. But I want to modify it as follows so that i can store the cipherText in a file. Then another program reads the encrypted text from the file and decrypts it. Below is what I have done till now, but I cannot understand how to proceed. Just a little hint on how to proceed will help.</p>

<pre><code>import java.security.*;
import javax.crypto.*;

// encrypt and decrypt using the DES private key algorithm
public class PrivateExample {

  public static void main (String[] args) throws Exception {
    String text=new String();
    text=""This is an encryption test"";

    byte[] plainText = text.getBytes(""UTF8"");

    // get a DES private key
    System.out.println( ""\nStart generating DES key"" );
    KeyGenerator keyGen = KeyGenerator.getInstance(""DES"");
    keyGen.init(56);
    Key key = keyGen.generateKey();
    System.out.println( ""Finish generating DES key"" );
    //
    // get a DES cipher object and print the provider
    Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    System.out.println( ""\n"" + cipher.getProvider().getInfo() );
    //
   // encrypt using the key and the plaintext
    System.out.println( ""\nStart encryption"" );
    cipher.init(Cipher.ENCRYPT_MODE, key);
    byte[] cipherText = cipher.doFinal(plainText);
    System.out.println( ""Finish encryption: "" );
    System.out.println( new String(cipherText, ""UTF8"") );

   //Now writing to an ouput file the cipherText
   try{
       FileOutputStream fs=new FileOutputStream(""c:/test.txt"");
      fs.write(cipherText);
     }catch(Exception e){
       e.printStackTrace();
     }
//How to proceed from here

}
}
</code></pre>

<p>Now this program's job is complete. It has successfully written the encrypted string into a file. The new program only has to decrypt the data. How do I read the encrypted bytes from the file? The new program obviously has no idea regarding what the original string was, but I will be using the same key as in the algorith. Please help! I am new to encryption</p>
","<p>Here's how you write your key to a file:</p>

<pre><code>        //Write your key to an output file.
        byte[] keyAsByte = key.getEncoded();
        FileOutputStream keyfos = new FileOutputStream(""key.txt"");
        keyfos.write(keyAsByte);
        keyfos.close();
</code></pre>

<p>I wouldn't recommend putting the key with the encrypted text in the same file.</p>

<p>Here's how you read the encrypted text and the key back and decrypt:</p>

<pre><code>    //Read your key
    FileInputStream keyFis = new FileInputStream(""key.txt"");
    byte[] encKey = new byte[keyFis.available()];
    keyFis.read(encKey);
    keyFis.close();
    Key keyFromFile = new SecretKeySpec(encKey, ""DES"");
    //Read your text
    FileInputStream encryptedTextFis = new FileInputStream(""test.txt"");
    byte[] encText = new byte[encryptedTextFis.available()];
    encryptedTextFis.read(encText);
    encryptedTextFis.close();
    //Decrypt
    Cipher decrypter = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    decrypter.init(Cipher.DECRYPT_MODE, keyFromFile);
    byte[] decryptedText = decrypter.doFinal(encText);
    //Print result
    System.out.println(""Decrypted Text: "" + new String(decryptedText));
</code></pre>

<p><b>Note</b>: I didn't use the same path as you for writing the information.</p>
","11467","<java><encryption><des>","1","3","1","2019-07-02 02:14:37","15683916","4","3","1065197","","2013-03-28 13:17:36","2013-03-28 13:14:48",""
"11697402","Looking for Simple C Implementation of AES-128 and DES","<p>I need C versions of AES-128 and DES to run on an embedded SPARC processor. I'm trying to measure the electrical power of these algorithms in software and hardware. Is there a website where I could find software implementations? Currently I can compile C code with my cross-compiler so any language implementations other than C would not be useful.</p>

<p>I have implemented DES in hardware before. How much work would people estimate (hours/lines of code) to implement a software version?</p>

<p>Does anybody know how to use the aes_generic.c and des_generic.c built into the Linux kernel in the crypto directory?</p>
","<p>Wikipedia has a list of <a href=""http://en.wikipedia.org/wiki/AES_implementations"" rel=""nofollow"">AES implementations</a>.  Simple googling also found a <a href=""http://www.ubiqx.org/proj/libcifs/source/Auth/DES.c"" rel=""nofollow"">DES</a> implementation in C; you'll have to see if it fits your requirements.</p>
","11008","<c><aes><implementation><des><sparc>","3","1","2","2013-09-05 16:27:12","11705116","4","2","223513","","2012-07-29 00:00:52","2012-07-28 01:10:45","2015-01-12 13:49:17"
"11697402","Looking for Simple C Implementation of AES-128 and DES","<p>I need C versions of AES-128 and DES to run on an embedded SPARC processor. I'm trying to measure the electrical power of these algorithms in software and hardware. Is there a website where I could find software implementations? Currently I can compile C code with my cross-compiler so any language implementations other than C would not be useful.</p>

<p>I have implemented DES in hardware before. How much work would people estimate (hours/lines of code) to implement a software version?</p>

<p>Does anybody know how to use the aes_generic.c and des_generic.c built into the Linux kernel in the crypto directory?</p>
","<p>You may want to see if <a href=""https://github.com/libtom/libtomcrypt"" rel=""nofollow"">LibTomCrypt</a> will meet your needs</p>
","11008","<c><aes><implementation><des><sparc>","3","2","2","2013-09-05 16:27:12","11705116","4","2","223513","","2012-07-29 00:00:52","2012-07-28 01:10:45","2015-01-12 13:49:17"
"6766225","TripleDES key sizes - .NET vs Wikipedia","<p>According to <a href=""http://en.wikipedia.org/wiki/Triple_DES"">Wikipedia</a>, TripleDES supports 56, 112, and 168-bit key lengths, but the System.Cryptography.TripleDESCryptoServiceProvider.LegalKeySizes says it only accepts 128 and 192-bit key lengths.</p>

<p>The system I'm developing needs to be interoperable (data encrypted by my code needs to be decryptable in PHP, Java, and Objective-C) and I don't who is correct in this case.</p>

<p>So who should I believe? And how can I be sure my encrypted data is portable?</p>
","<p>Triple DES will only use 112/168 bits of your 128/192 bit key. .NET asks for more bits for the purpose of alignment (each 56 bit subkey is aligned on a 64 bit boundary).</p>

<p>56 bit DES is broken and I'd expect they've made it harder to use.</p>
","10697","<encryption><wikipedia><des><tripledes>","6","0","4","2011-07-20 18:35:57","6766409","0","2","","","","2011-07-20 17:52:17",""
"6766225","TripleDES key sizes - .NET vs Wikipedia","<p>According to <a href=""http://en.wikipedia.org/wiki/Triple_DES"">Wikipedia</a>, TripleDES supports 56, 112, and 168-bit key lengths, but the System.Cryptography.TripleDESCryptoServiceProvider.LegalKeySizes says it only accepts 128 and 192-bit key lengths.</p>

<p>The system I'm developing needs to be interoperable (data encrypted by my code needs to be decryptable in PHP, Java, and Objective-C) and I don't who is correct in this case.</p>

<p>So who should I believe? And how can I be sure my encrypted data is portable?</p>
","<p>Wikipedia does not say TripleDES supports 56 bit keys. The ""keying options"" talk about ""triple-length"" keys and ""double-length"" keys, the latter ""reduces the key size to 112 bits"".
The effective key size for the original DES is 56 bit. Such a key is constructed from 64 bit input though, where 8 bits remain unused. The ""triple-length"" key option thus works with a three times 56 bit (=168) constructed from three times 64 bit (=192 bit) and the ""double-length"" option works with two times 56 bit keys (=112) constructed from two times 64 bit (=128). </p>

<p>As your TripleDESCryptoServiceProvider needs to derive the actual keys from the 64 bit-based input first, it will only take either 128 bits (double-length) or 192 bits (triple-length) as input and then internally derive the 168 or 112 bit actual keys from that input.</p>

<p>That's standard procedure for TripleDES, so you should have no problems with portability across platforms.</p>
","10697","<encryption><wikipedia><des><tripledes>","6","13","4","2011-07-20 18:35:57","6766409","0","2","","","","2011-07-20 17:52:17",""
"6766225","TripleDES key sizes - .NET vs Wikipedia","<p>According to <a href=""http://en.wikipedia.org/wiki/Triple_DES"">Wikipedia</a>, TripleDES supports 56, 112, and 168-bit key lengths, but the System.Cryptography.TripleDESCryptoServiceProvider.LegalKeySizes says it only accepts 128 and 192-bit key lengths.</p>

<p>The system I'm developing needs to be interoperable (data encrypted by my code needs to be decryptable in PHP, Java, and Objective-C) and I don't who is correct in this case.</p>

<p>So who should I believe? And how can I be sure my encrypted data is portable?</p>
","<p>I believe some (all?) implementations of DES use only 7 bits per character of the key (ASCII encoding).  I'm not sure if the definition of DES allows for 8-bit characters in keys or if it actually ignores the high bit of each byte.  I think it's the latter.</p>

<p>However, in .NET key sizes are based on the number of bytes, times 8 bits per byte, even if the underlying algorithm ignores that top bit.  That is probably the main discrepancy.</p>

<p>TripleDES runs DES three times with potentially three different 56-bit DES keys.  In some implementations the middle run is reversed (encrypting-decrypting-encrypting or ""EDE"") so that using the same 56-bit DES key for all three duplicates the encryption of simple DES.  This was done for compatibility with older systems where both are using hardware-based encryption.  I'm not sure if the TripleDESCryptoServiceProvider uses this ""EDE"" approach or the ""EEE"" approach (or gives you a choice).  Further, the same 56-bit DES key can be used for the first and third run, using a 112-bit key instead of the 168-bit key it could also use.</p>

<p>The certified TripleDESCryptoServiceProvider wouldn't accept 56-bit (64-bit) keys because it's not really 3DES security (you could use DESCryptoServiceProvider instead?).  At one time it was determined that the 168-bit EEE (or EDE?) 3DES does not provide any greater security than using a 112-bit (128-bit) key.  However, there may be some extreme (generally unavailable) attacks in which the shorter key is theoretically more vulnerable.  That may also apply to the EDE vs EEE question.</p>

<p>On your compatibility vs other languages question, .NET's *CryptoServiceProvider classes are just a wrapper API around the underlying Windows CRYPTO library.  If the other languages are also using the Windows CRYPTO library it should be compatible.  Otherwise, you'd have to find out whether they are using EDE or EEE and make sure all are using the same one (you may or may not have flexibility on that), and obviously use the same key length.  They are probably all using the same byte order, but if you find things still don't match up that might be another thing to check.  Most likely on Windows they're all using CRYPTO and will probably match up as long as you can set the options the same way for all of them.</p>
","10697","<encryption><wikipedia><des><tripledes>","6","0","4","2011-07-20 18:35:57","6766409","0","2","","","","2011-07-20 17:52:17",""
"6766225","TripleDES key sizes - .NET vs Wikipedia","<p>According to <a href=""http://en.wikipedia.org/wiki/Triple_DES"">Wikipedia</a>, TripleDES supports 56, 112, and 168-bit key lengths, but the System.Cryptography.TripleDESCryptoServiceProvider.LegalKeySizes says it only accepts 128 and 192-bit key lengths.</p>

<p>The system I'm developing needs to be interoperable (data encrypted by my code needs to be decryptable in PHP, Java, and Objective-C) and I don't who is correct in this case.</p>

<p>So who should I believe? And how can I be sure my encrypted data is portable?</p>
","<p>Des uses multiples of 64 bit keys, but throws away 8 bits leaving a useful keylength of 64 bits.<br>
Triple des can use double or triple key length.<br>
However because repeating des with the same key decrypts the message running des an even number of times can partially decrypt stuff if the keys share patterns.    </p>

<p>For this reason des is always ran an odd number of times.  </p>

<p>This is also why you should never choose a key where 64 bit parts repeat.</p>

<p>With triple des 192 bit you thus have a effective key length of 112 bits</p>
","10697","<encryption><wikipedia><des><tripledes>","6","0","4","2011-07-20 18:35:57","6766409","0","2","","","","2011-07-20 17:52:17",""
"3637918","DES implementation in C/C++/C#","<p>I am looking for existing implementations of different types of DES in C/C++/C##. My running platform is Windows XP/Vista/7.</p>

<p>I am trying to write a C# program which will encrypt and decrypt using the DES algorithm. I need some implementations with which i can verify my code output to see if i did the things in right order. For the implementations the code along with the executable will be good however not a must.</p>
","<p>This might be what you are looking for: <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.des.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/system.security.cryptography.des.aspx</a></p>
","9892","<c#><c++><c><encryption><des>","1","1","3","2011-05-16 14:19:24","3644804","5","","505893","","2011-05-16 14:19:24","2010-09-03 17:01:15",""
"3637918","DES implementation in C/C++/C#","<p>I am looking for existing implementations of different types of DES in C/C++/C##. My running platform is Windows XP/Vista/7.</p>

<p>I am trying to write a C# program which will encrypt and decrypt using the DES algorithm. I need some implementations with which i can verify my code output to see if i did the things in right order. For the implementations the code along with the executable will be good however not a must.</p>
","<p>Nearly all open source C/C++ crypto libraries implement DES. You could for instance use OpenSSL, PolarSSL, LibTomCrypt, Crypto++, or any other library of your choosing for testing/experimentation.</p>

<p>In C# there seem to be fewer options, simply because the default .NET crypto libraries somewhat inhibit the desire for anyone else to compete in this space, but <a href=""http://www.bouncycastle.org/csharp"" rel=""nofollow noreferrer"">BouncyCastle's C# code</a> (<a href=""http://www.bouncycastle.org/csharp/index.html"" rel=""nofollow noreferrer"">http://www.bouncycastle.org/csharp/index.html</a>) does contain an implementation (in src/crypto/engines/DesEngine.cs).</p>
","9892","<c#><c++><c><encryption><des>","1","2","3","2011-05-16 14:19:24","3644804","5","","505893","","2011-05-16 14:19:24","2010-09-03 17:01:15",""
"3637918","DES implementation in C/C++/C#","<p>I am looking for existing implementations of different types of DES in C/C++/C##. My running platform is Windows XP/Vista/7.</p>

<p>I am trying to write a C# program which will encrypt and decrypt using the DES algorithm. I need some implementations with which i can verify my code output to see if i did the things in right order. For the implementations the code along with the executable will be good however not a must.</p>
","<p>Thanks for the input.. I found these links where in I could calculate the DES values for giving input.</p>

<ol>
<li><a href=""http://www.unsw.adfa.edu.au/~lpb/src/DEScalc/DEScalc.html"" rel=""nofollow noreferrer"">http://www.unsw.adfa.edu.au/~lpb/src/DEScalc/DEScalc.html</a></li>
<li><a href=""http://www.riscure.com/tech-corner/online-crypto-tools/des.html"" rel=""nofollow noreferrer"">http://www.riscure.com/tech-corner/online-crypto-tools/des.html</a></li>
</ol>
","9892","<c#><c++><c><encryption><des>","1","0","3","2011-05-16 14:19:24","3644804","5","","505893","","2011-05-16 14:19:24","2010-09-03 17:01:15",""
"19610358","Java Triple DES encryption with 2 different keys","<p>I'm trying to encrypt data using triple DES with two different keys, so given the two keys k1 and k2 the cryptotext would be Ek1(Dk2(Ek1(plaintext))) where E is Encryption and D Decryption. I'm trying to simulate this using DES algorithm from java. Here is the code:</p>

<pre><code>public static void main(String[] args) {

    SecretKey k1 = generateDESkey();
    SecretKey k2 = generateDESkey();

    String firstEncryption = desEncryption(""plaintext"", k1);
    String decryption = desDecryption(firstEncryption, k2);
    String secondEncryption = desEncryption(decryption, k1);

}

public static SecretKey generateDESkey() {
    KeyGenerator keyGen = null;
    try {
        keyGen = KeyGenerator.getInstance(""DES"");
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    keyGen.init(56); // key length 56
    SecretKey secretKey = keyGen.generateKey();
    return secretKey;
}

public static String desEncryption(String strToEncrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, desKey);
        String encryptedString = Base64.encode(cipher.doFinal(strToEncrypt.getBytes()));
        return encryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}

public static String desDecryption(String strToDecrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
        return decryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (Base64DecodingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}
</code></pre>

<p>I have this error: javax.crypto.BadPaddingException: Given final block not properly padded when trying to decrypt at this line of code:</p>

<pre><code>String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
</code></pre>

<p>Can you help me to resolve this problem or do you know a direct method to encrypt data using triple DES with two different keys with total key length of 128 bits? I didn't find any algorithm so I tried to simulate it using simple DES. </p>
","<p>You are converting arbitrary bytes to Strings, which is corrupting them.  work entirely with bytes.  if you need to convert the encrypted data to a String, then use Base64 encoding.</p>
","9077","<java><encryption><des><3des>","0","3","2","2013-10-30 16:54:29","19610476","0","2","","","","2013-10-26 18:31:34",""
"19610358","Java Triple DES encryption with 2 different keys","<p>I'm trying to encrypt data using triple DES with two different keys, so given the two keys k1 and k2 the cryptotext would be Ek1(Dk2(Ek1(plaintext))) where E is Encryption and D Decryption. I'm trying to simulate this using DES algorithm from java. Here is the code:</p>

<pre><code>public static void main(String[] args) {

    SecretKey k1 = generateDESkey();
    SecretKey k2 = generateDESkey();

    String firstEncryption = desEncryption(""plaintext"", k1);
    String decryption = desDecryption(firstEncryption, k2);
    String secondEncryption = desEncryption(decryption, k1);

}

public static SecretKey generateDESkey() {
    KeyGenerator keyGen = null;
    try {
        keyGen = KeyGenerator.getInstance(""DES"");
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    keyGen.init(56); // key length 56
    SecretKey secretKey = keyGen.generateKey();
    return secretKey;
}

public static String desEncryption(String strToEncrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, desKey);
        String encryptedString = Base64.encode(cipher.doFinal(strToEncrypt.getBytes()));
        return encryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}

public static String desDecryption(String strToDecrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
        return decryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (Base64DecodingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}
</code></pre>

<p>I have this error: javax.crypto.BadPaddingException: Given final block not properly padded when trying to decrypt at this line of code:</p>

<pre><code>String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
</code></pre>

<p>Can you help me to resolve this problem or do you know a direct method to encrypt data using triple DES with two different keys with total key length of 128 bits? I didn't find any algorithm so I tried to simulate it using simple DES. </p>
","<p>Why not just use the included DESede algorithm?</p>

<p>Change all your DES code instances to DESede and change your Key Generation method to as such:</p>

<pre><code>public static SecretKey generateDESkey() {
    KeyGenerator keyGen = null;
    try {
        keyGen = KeyGenerator.getInstance(""DESede"");
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    }
    keyGen.init(112); // key length 112 for two keys, 168 for three keys
    SecretKey secretKey = keyGen.generateKey();
    return secretKey;
}
</code></pre>

<p>Note how the getInstance() method is now supplied with DESede and the key size has been increased to 112 (168 for three keys).</p>

<p>Change your Cipher instances from:</p>

<pre><code>Cipher.getInstance(""DES/ECB/PKCS5Padding"");
</code></pre>

<p>to</p>

<pre><code>Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
</code></pre>

<p>And you are set.</p>
","9077","<java><encryption><des><3des>","0","2","2","2013-10-30 16:54:29","19610476","0","2","","","","2013-10-26 18:31:34",""
"23142363","Convert char or string to bitset in c++","<p>I'm doing an assignment on DES encryption and I can't seem to convert a string, let alone a char into a bitset. Can anyone show me how to convert a single char into a bitset in C++?</p>
","<p>The following:</p>

<pre><code>char c = 'A';
std::bitset&lt;8&gt; b(c);  // implicit cast to unsigned long long
</code></pre>

<p>should work.</p>

<p>See <a href=""http://ideone.com/PtSFvz"" rel=""nofollow"">http://ideone.com/PtSFvz</a></p>

<hr>

<p>Converting an arbitrary-length <code>string</code> to a <code>bitset</code> is harder, if at all possible. The size of a bitset must be known at compile-time, so there's not really a way of converting a string to one.</p>

<p>However, if you know the length of your string at compile-time (or can bound it at compile time), you can do something like:</p>

<pre><code>const size_t N = 50;  // bound on string length
bitset&lt;N * 8&gt; b;
for (int i = 0; i &lt; str.length(); ++i) {
  char c = s[i];
  for (int j = 7; j &gt;= 0 &amp;&amp; c; --j) {
    if (c &amp; 0x1) {
      b.set(8 * i + j);
    }
    c &gt;&gt;= 1;
  }
}
</code></pre>

<p>That may be a bit inefficient but I don't know if there's a better work-around.</p>
","8627","<c++><des>","4","5","1","2014-04-17 20:29:22","23142499","2","2","","","","2014-04-17 19:59:14",""
"6808652","DES-ECB encryption and decryption","<p>I'm using DES-ECB + base64 encryption in my application. That's the code of the class I called ""Crypto""</p>

<pre><code>public class Crypto
{

    public static string Decrypt(string encryptedString)
    {
        DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider();
        desProvider.Mode = CipherMode.ECB;
        desProvider.Padding = PaddingMode.PKCS7;
        desProvider.Key = Encoding.ASCII.GetBytes(""e5d66cf8"");
        using (MemoryStream stream = new MemoryStream(Convert.FromBase64String(encryptedString)))
        {
            using (CryptoStream cs = new CryptoStream(stream, desProvider.CreateDecryptor(), CryptoStreamMode.Read))
            {
                using (StreamReader sr = new StreamReader(cs, Encoding.ASCII))
                {
                    return sr.ReadToEnd();
                }
            }
        }
    }

    public static string Encrypt(string decryptedString)
    {
        DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider();
        desProvider.Mode = CipherMode.ECB;
        desProvider.Padding = PaddingMode.PKCS7;
        desProvider.Key = Encoding.ASCII.GetBytes(""e5d66cf8"");
        using (MemoryStream stream = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(stream, desProvider.CreateEncryptor(), CryptoStreamMode.Write))
            {
                byte[] data = Encoding.Default.GetBytes(decryptedString);
                cs.Write(data, 0, data.Length);
                return Convert.ToBase64String(stream.ToArray());
            }
        }
    }
}
</code></pre>

<p>but when I encrypt a string, then decrypt it again and encrypt one more time, the encrypted string is not the same as previous encrypted was. So that's the first encrypted string:  </p>

<blockquote>
  <blockquote>
    <p>kEN0HUp/dqz8kXA7nYivJG6Jl3haLJjhBq1UfEtQTwaPwizW//03M0UxF8dBuYZo2BoZ5vsVcXRJF1LpFZLWxDsdeKAC43L2K2OoYRxTn/dA6KmM13YS9xOezGiROQfVj5qrkdokJRCvj0gYfFoH2oeDGyN+EAw5Dgzsp697kj4=</p>
  </blockquote>
</blockquote>

<p>and here comes the second encrypted string:  </p>

<blockquote>
  <blockquote>
    <p>kEN0HUp/dqz8kXA7nYivJG6Jl3haLJjhBq1UfEtQTwaPwizW//03M0UxF8dBuYZo2BoZ5vsVcXRJF1LpFZLWxDsdeKAC43L2K2OoYRxTn/dA6KmM13YS9xOezGiROQfVj5qrkdokJRCvj0gYfFoH2oeDGyN+EAw5</p>
  </blockquote>
</blockquote>

<p>They are almost same, except this ""Dgzsp697kj4="" in the first string.<br>
What's wrong?<br>
Thanks in advance.</p>
","<p>I had a similar problem. You should check that white space is not getting appended to the end of the decrypted string. You might need to trim the white space off.</p>
","8374","<c#><encryption><base64><des>","3","1","2","2011-07-24 18:34:01","6808810","4","1","623115","","2011-07-24 18:15:56","2011-07-24 18:07:25",""
"6808652","DES-ECB encryption and decryption","<p>I'm using DES-ECB + base64 encryption in my application. That's the code of the class I called ""Crypto""</p>

<pre><code>public class Crypto
{

    public static string Decrypt(string encryptedString)
    {
        DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider();
        desProvider.Mode = CipherMode.ECB;
        desProvider.Padding = PaddingMode.PKCS7;
        desProvider.Key = Encoding.ASCII.GetBytes(""e5d66cf8"");
        using (MemoryStream stream = new MemoryStream(Convert.FromBase64String(encryptedString)))
        {
            using (CryptoStream cs = new CryptoStream(stream, desProvider.CreateDecryptor(), CryptoStreamMode.Read))
            {
                using (StreamReader sr = new StreamReader(cs, Encoding.ASCII))
                {
                    return sr.ReadToEnd();
                }
            }
        }
    }

    public static string Encrypt(string decryptedString)
    {
        DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider();
        desProvider.Mode = CipherMode.ECB;
        desProvider.Padding = PaddingMode.PKCS7;
        desProvider.Key = Encoding.ASCII.GetBytes(""e5d66cf8"");
        using (MemoryStream stream = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(stream, desProvider.CreateEncryptor(), CryptoStreamMode.Write))
            {
                byte[] data = Encoding.Default.GetBytes(decryptedString);
                cs.Write(data, 0, data.Length);
                return Convert.ToBase64String(stream.ToArray());
            }
        }
    }
}
</code></pre>

<p>but when I encrypt a string, then decrypt it again and encrypt one more time, the encrypted string is not the same as previous encrypted was. So that's the first encrypted string:  </p>

<blockquote>
  <blockquote>
    <p>kEN0HUp/dqz8kXA7nYivJG6Jl3haLJjhBq1UfEtQTwaPwizW//03M0UxF8dBuYZo2BoZ5vsVcXRJF1LpFZLWxDsdeKAC43L2K2OoYRxTn/dA6KmM13YS9xOezGiROQfVj5qrkdokJRCvj0gYfFoH2oeDGyN+EAw5Dgzsp697kj4=</p>
  </blockquote>
</blockquote>

<p>and here comes the second encrypted string:  </p>

<blockquote>
  <blockquote>
    <p>kEN0HUp/dqz8kXA7nYivJG6Jl3haLJjhBq1UfEtQTwaPwizW//03M0UxF8dBuYZo2BoZ5vsVcXRJF1LpFZLWxDsdeKAC43L2K2OoYRxTn/dA6KmM13YS9xOezGiROQfVj5qrkdokJRCvj0gYfFoH2oeDGyN+EAw5</p>
  </blockquote>
</blockquote>

<p>They are almost same, except this ""Dgzsp697kj4="" in the first string.<br>
What's wrong?<br>
Thanks in advance.</p>
","<p>You are losing data. In your Encrypt() method you need to call EncryptFinalBlock() to let the padding algorithm know that you are done so that it can add the padding:</p>

<pre><code>using (CryptoStream cs = new CryptoStream(stream, desProvider.CreateEncryptor(), CryptoStreamMode.Write))
{
  byte[] data = Encoding.Default.GetBytes(decryptedString);
  cs.Write(data, 0, data.Length);
  cs.FlushFinalBlock(); // &lt;-- Add this
  return Convert.ToBase64String(stream.ToArray());
}
</code></pre>
","8374","<c#><encryption><base64><des>","3","5","2","2011-07-24 18:34:01","6808810","4","1","623115","","2011-07-24 18:15:56","2011-07-24 18:07:25",""
"4936543","python: how to encrypt a file?","<p>Can anybody help(or point to some examples) about how to encrypt files with python?
I have to use following parameters to encrypt file:</p>

<pre><code>block size=8
iv=qwertyui12345678
method=des3_cbc
</code></pre>

<p>Also I have no idea about what <code>iv</code> means</p>

<p>Please help. Thanks in advance.</p>
","<p>Use  <a href=""http://www.dlitz.net/software/pycrypto/"" rel=""nofollow"">pycrypto</a> - note that implmenting crypto properly, even using a library for the hard parts, is tricky. If security matters get expert help.</p>
","8213","<python><encryption><des>","3","3","3","2015-03-10 15:23:57","4936628","2","","310399","","2011-11-04 20:01:08","2011-02-08 17:59:01",""
"4936543","python: how to encrypt a file?","<p>Can anybody help(or point to some examples) about how to encrypt files with python?
I have to use following parameters to encrypt file:</p>

<pre><code>block size=8
iv=qwertyui12345678
method=des3_cbc
</code></pre>

<p>Also I have no idea about what <code>iv</code> means</p>

<p>Please help. Thanks in advance.</p>
","<p>You will need to use the <a href=""http://www.dlitz.net/software/pycrypto/"" rel=""noreferrer"">Python Crypto Toolkit</a></p>

<p>IV is the Initialisation Vector.</p>
","8213","<python><encryption><des>","3","5","3","2015-03-10 15:23:57","4936628","2","","310399","","2011-11-04 20:01:08","2011-02-08 17:59:01",""
"4936543","python: how to encrypt a file?","<p>Can anybody help(or point to some examples) about how to encrypt files with python?
I have to use following parameters to encrypt file:</p>

<pre><code>block size=8
iv=qwertyui12345678
method=des3_cbc
</code></pre>

<p>Also I have no idea about what <code>iv</code> means</p>

<p>Please help. Thanks in advance.</p>
","<p>IV stands for <em>Initialization Vector</em>. Block cipher algorithms can be used in several operational modes; one of these modes is called CBC (<em>Cipher-Block Chaining</em>), in this mode the plain text block is XORed with the encrypted previous block. The IV is XORed with the initial plain text block. The IV can be see as an algorithm parameter.</p>

<p>A more detailed description can be read <a href=""http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29"" rel=""nofollow"">here</a>.</p>
","8213","<python><encryption><des>","3","3","3","2015-03-10 15:23:57","4936628","2","","310399","","2011-11-04 20:01:08","2011-02-08 17:59:01",""
"17465732","How to use three keys with triple des(3des) in Java","<p>I found a link in stackoverflow here <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">use-3des-encryption-decryption-in-java</a>,but in fact the method uses only two parameter:HG58YZ3CR9"" and the ""<code>IvParameterSpec iv = new IvParameterSpec(new byte[8]);</code>"" 
<br>But the most strong option of triple des could use three different key to encrypt the message.So how to do that? I find a mehond in Cipher, which use ""SecureRandom"" as another parameter.So is this the right way?
<br>
The first method code is below:</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TripleDESTest {

    public static void main(String[] args) throws Exception {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""kyle boon""
    }

    public byte[] encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return cipherText;
    }

    public String decrypt(byte[] message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
</code></pre>
","<p>As per <a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html"" rel=""nofollow"">this document</a>, simply pass the cipher a key that is 168 bits long.</p>

<blockquote>
  <p>Keysize must be equal to 112 or 168. </p>
  
  <p>A keysize of 112 will generate a Triple DES key with 2 intermediate keys, and a keysize of 168 will generate a Triple DES key with 3 intermediate keys.</p>
</blockquote>

<p>Your code seems to do something questionable to make up for the fact that the output of MD5 is only 128 bits long.</p>

<p>Copy-pasting cryptographic code off the internet will not produce secure applications. Using a static IV compromises several reasons why CBC mode is better than ECB. If you are using a static key, you should probably consider generating random bytes using a secure random number generator instead of deriving the key from a short ASCII string. Also, there is absolutely no reason to use Triple DES instead of AES in new applications.</p>
","7836","<java><encryption><des><3des>","3","2","2","2013-07-06 11:33:00","","2","3","-1","","2017-05-23 10:27:54","2013-07-04 08:43:01",""
"17465732","How to use three keys with triple des(3des) in Java","<p>I found a link in stackoverflow here <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">use-3des-encryption-decryption-in-java</a>,but in fact the method uses only two parameter:HG58YZ3CR9"" and the ""<code>IvParameterSpec iv = new IvParameterSpec(new byte[8]);</code>"" 
<br>But the most strong option of triple des could use three different key to encrypt the message.So how to do that? I find a mehond in Cipher, which use ""SecureRandom"" as another parameter.So is this the right way?
<br>
The first method code is below:</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TripleDESTest {

    public static void main(String[] args) throws Exception {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""kyle boon""
    }

    public byte[] encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return cipherText;
    }

    public String decrypt(byte[] message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
</code></pre>
","<p>In principle, the for-next loop to generate the DES ABA key does seem correct. <em>Note that you can provide DESede with a 16 byte key from Java 7 onwards, which amounts to the same thing</em>.</p>

<p>That said, the code you've shown leaves a lot to be desired:</p>

<p>I is not secure:</p>

<ul>
<li>the key is not generated by a Password Based Key Derivation Function (PBKDF) using the (password?) string</li>
<li>the key is composed of two keys instead of three (using a triple DES or TDEA with an ABA key)</li>
<li>the IV is set to all zero's instead of being randomized</li>
<li>the ""password"" string is too short</li>
</ul>

<p>Furthermore the following code mistakes can be seen:</p>

<ul>
<li>using <code>new sun.misc.BASE64Encoder()</code> which is in the Sun proprietary packages (which can be removed or changed during any upgrade of the runtime)</li>
<li>throwing <code>Exception</code> for platform exceptions and runtime exceptions (not being able to decrypt is handled the same way as not being able to instantiate the <code>Cipher</code>)</li>
<li>requesting 24 bytes instead of 16 within the <code>Arrays.copyOf()</code> call (which seems to return 24 SHA-1 output while there are only 20 bytes)</li>
</ul>

<p>To generate a 3DES 24 byte (168 bits used) DES ABC key from a password (like) String you should use PBKDF-2. Adding an authentication tag is also very important if man-in-the-middle attacks or padding oracle  apply. It would be much secure and much more practical to upgrade to AES if you can control the algorithms being used as well.</p>
","7836","<java><encryption><des><3des>","3","0","2","2013-07-06 11:33:00","","2","3","-1","","2017-05-23 10:27:54","2013-07-04 08:43:01",""
"14117025","DES Send and Receive Modes for DESFire Authentication","<p>I'm trying to authenticate DESFire card with my android application. I use <a href=""http://n3vrax.wordpress.com/2011/07/23/des-algorithm-java-implementation/"" rel=""nofollow"">the example in this link</a> to decypher the bytes I got from the card. For that, I ruled out padding in decryption (commented out below), because DESFire documentation points it out. Also, if I don't do so, decryption returns 7 bytes for input of 8 bytes. Below are DES and TripleDES decryption functions I use:</p>

<pre><code>public static byte[] TripleDES_Decrypt(byte[] data,byte[][] keys)
{
    int i;
    byte[] tmp = new byte[data.length];
    byte[] bloc = new byte[8];

    K = generateSubKeys(keys[0]);
    K1 = generateSubKeys(keys[1]);
    K2 = generateSubKeys(keys[2]);

    for (i = 0; i &lt; data.length; i++) {
        if (i &gt; 0 &amp;&amp; i % 8 == 0) {
            bloc = encrypt64Bloc(bloc,K2, true);
            bloc = encrypt64Bloc(bloc,K1, false);
            bloc = encrypt64Bloc(bloc,K, true);
            System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);
        }
        if (i &lt; data.length)
            bloc[i % 8] = data[i];
    }
    bloc = encrypt64Bloc(bloc,K2, true);
    bloc = encrypt64Bloc(bloc,K1, false);
    bloc = encrypt64Bloc(bloc,K, true);
    System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);


    //tmp = deletePadding(tmp);

    return tmp;
}

public static byte[] decrypt(byte[] data, byte[] key) {
    int i;
    byte[] tmp = new byte[data.length];
    byte[] bloc = new byte[8];

    K = generateSubKeys(key);

    for (i = 0; i &lt; data.length; i++) {
        if (i &gt; 0 &amp;&amp; i % 8 == 0) {
            bloc = encrypt64Bloc(bloc,K, true);
            System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);
        }
        if (i &lt; data.length)
            bloc[i % 8] = data[i];
    }
    bloc = encrypt64Bloc(bloc,K, true);
    System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);

    //tmp = deletePadding(tmp);

    return tmp;
}
</code></pre>

<p>According to DesFire document, I need two modes of decryption, send and receive. <a href=""http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/"" rel=""nofollow"">This blog post</a> has some explanation about it. </p>

<blockquote>
  <p>However, the DESFire crypto is a bit different from the normal DES/CBC scheme: The PCD uses DES “send mode” when sending data (xor before DES), and the card uses DES “recieve mode” when recieving data (xor after DES). But when the PCD recieves data, it uses normal DES/CBC mode (xor after DES), and the card uses normal DES send mode when sending data (xor before DES).</p>
</blockquote>

<p>And in Android side I follow the examples and recommendations:</p>

<pre><code>// connected to tag and application     

// result = encoded(randB) + af 
byte[] result = idTag.transceive(Utils.wrapMessage((byte)0x0a, new byte[]{(byte)0x0}));

byte[] b0 = new byte[8];
for(int i = 0; i &lt; 8; i++) {
    b0[i] = result[i];
}

// key
byte[] key = new byte[] {(byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
                 (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
                 (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
                 (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0 };
byte[][] keys = new byte[3][];
keys[0]=key; keys[1]=key; keys[2]=key;

// decrypt encoded(randB)
byte[] r0 = DES.TripleDES_Decrypt(b0, keys);

// generate randA (integer 0-7 for trying) 
byte[] nr = new byte[8];
for(int i = 0; i &lt; 8; i++) {
    nr[i] = Byte.parseByte(Integer.toString(i), 16);
}
// decrypt randA
byte[] b1 = DES.TripleDES_Decrypt(nr, keys);

// shift randB and get randB'
byte[] r1 =new byte[8];
for(int i = 0; i &lt; 7; i++) {
    r1[i] = r0[i + 1];
}
r1[7]=r0[0];

// concat (randA + randB')
byte[] b2 = new byte[16];
for(int i = 0; i &lt; 16; i++)
{
    if(i &lt;= 7) {
    b2[i] = b1[i];
} else {
    b2[i] = r1[i - 8];
}
}

// XOR (randA + randB') with IV
// IV is told to be consisting of 0's, 
// but XOR something with 0 results the same? 
for(int i=0;i&lt;16;i++) {
    b2[i] = (byte) (b2[i] ^ (byte)0x0);
}

// send AF and decrypt(A+B) 
// wrap message adds needed wrapping to message (90 to left, offset bytes etc.)
result = isodepTag.transceive(Utils.wrapMessage((byte)0xaf, DES.TripleDES_Decrypt(b2, keys)));
</code></pre>

<p>I get the first result, the encrypted randB. However, the second ""result"" is always ""91ae"", means authentication error. I'm doing something wrong here, send wrong data to card.</p>

<p>Can anyone tell me what must I change in the code to work in these modes? What should I XOR with data before/after TripleDES?</p>

<p>Not the real question, but I read that default ""Key"" in DesFire card is 16 zero bytes. Also the document points that I need to use TripleDES for 16 bytes of key, DES for 8 bytes of key. So I'm using and need to use TripleDES as I haven't changed the default key, am I right? </p>

<p>For those who need the know about <a href=""http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29"" rel=""nofollow"">CipherBlockChaining</a>.</p>

<p><strong>EDIT</strong>: I found out that I need to do XORing before and after TripleDES and I mustn't touch TripleDES's internal operations at all. I will be trying that in a while. </p>

<p>Deleted the inner TripleDES lines, just saying for the ones seeing the question for the first time.</p>
","<p>OK I got the solution. My mistake was that I was sending </p>

<pre><code>3DES(randA + randB') 
</code></pre>

<p>But I should send </p>

<pre><code>3DES(randA) + 3DES(randB' XOR 3DES(randA))
</code></pre>

<p>Here's the authentication code for Android/Java (it's so sad that this is the only one that can be found on the net currently!):</p>

<p>The actual authentication code:</p>

<pre><code>// send initial authentication request
byte[] result = idTag.transceive(Utils.wrapMessage((byte)0x0a, new byte[]{(byte)0x0}));

// get encrypted(randB) from the response
byte[] b0 = new byte[8];
for(int i = 0; i &lt; 8; i++) {
    b0[i] = result[i];
}

// 16 bytes default key
byte[] key = new byte[] {(byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
    (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
    (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
    (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0 };
// keys for TripleDes
byte[][] keys = new byte[3][];
keys[0] = key; keys[1] = key; keys[2] = key;

// decrypt encoded(randB)
byte[] r0 = DES.TripleDES_Decrypt(b0, keys);

// generate randA (integer 0-7 for trying, should randomize for real-life use) 
byte[] nr = new byte[8];
for(int i = 0; i &lt; 8; i++) {
    nr[i] = Byte.parseByte(Integer.toString(i), 16);
}

// decrypt randA, should XOR with IV, but IV is all 0's, not necessary
byte[] b1 = DES.TripleDES_Decrypt(nr, keys);

// shift randB one byte left and get randB'
byte[] r1 =new byte[8];
for(int i = 0; i &lt; 7; i++) {
    r1[i] = r0[i + 1];
}
r1[7]=r0[0];

// xor randB' with randA and decrypt
byte[] b2 = new byte[8];
for(int i = 0; i &lt; 8; i++) {
    b2[i] = (byte) (b1[i] ^ r1[i]);
}
b2 = DES.TripleDES_Decrypt(b2, keys);

// concat (randA + randB')
byte[] b1b2 = new byte[16];

for (int i = 0; i &lt; b1b2.length; i++) {
    if(i &lt;= 7) {
        b1b2[i] = b1[i];
    } else {
        b1b2[i]=b2[i-8];
    }
}

result = idTag.transceive(Utils.wrapMessage((byte)0xaf, b1b2));
</code></pre>

<p>TripleDes is the one in the question. wrapMessage function:</p>

<pre><code>public static byte[] wrapMessage (byte command, byte[] parameters) throws Exception {
    ByteArrayOutputStream stream = new ByteArrayOutputStream();

    stream.write((byte) 0x90);
    stream.write(command);
    stream.write((byte) 0x00);
    stream.write((byte) 0x00);
    if (parameters != null) {
        stream.write((byte) parameters.length);
        stream.write(parameters);
    }
    stream.write((byte) 0x00);

    return stream.toByteArray();
}
</code></pre>

<p><strong>EDIT:</strong> Thanks to VGe0rge, we found out the reason why this authentication doesn't work from time to time. Instead of calling the 3DES function in the question, just call:</p>

<pre><code>Cipher.getInstance(""DESede/CBC/NoPadding"");
</code></pre>
","7409","<java><android><nfc><des><mifare>","9","10","2","2015-12-10 12:46:26","14160507","2","15","1275577","","2013-01-04 05:20:54","2013-01-02 04:59:53",""
"14117025","DES Send and Receive Modes for DESFire Authentication","<p>I'm trying to authenticate DESFire card with my android application. I use <a href=""http://n3vrax.wordpress.com/2011/07/23/des-algorithm-java-implementation/"" rel=""nofollow"">the example in this link</a> to decypher the bytes I got from the card. For that, I ruled out padding in decryption (commented out below), because DESFire documentation points it out. Also, if I don't do so, decryption returns 7 bytes for input of 8 bytes. Below are DES and TripleDES decryption functions I use:</p>

<pre><code>public static byte[] TripleDES_Decrypt(byte[] data,byte[][] keys)
{
    int i;
    byte[] tmp = new byte[data.length];
    byte[] bloc = new byte[8];

    K = generateSubKeys(keys[0]);
    K1 = generateSubKeys(keys[1]);
    K2 = generateSubKeys(keys[2]);

    for (i = 0; i &lt; data.length; i++) {
        if (i &gt; 0 &amp;&amp; i % 8 == 0) {
            bloc = encrypt64Bloc(bloc,K2, true);
            bloc = encrypt64Bloc(bloc,K1, false);
            bloc = encrypt64Bloc(bloc,K, true);
            System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);
        }
        if (i &lt; data.length)
            bloc[i % 8] = data[i];
    }
    bloc = encrypt64Bloc(bloc,K2, true);
    bloc = encrypt64Bloc(bloc,K1, false);
    bloc = encrypt64Bloc(bloc,K, true);
    System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);


    //tmp = deletePadding(tmp);

    return tmp;
}

public static byte[] decrypt(byte[] data, byte[] key) {
    int i;
    byte[] tmp = new byte[data.length];
    byte[] bloc = new byte[8];

    K = generateSubKeys(key);

    for (i = 0; i &lt; data.length; i++) {
        if (i &gt; 0 &amp;&amp; i % 8 == 0) {
            bloc = encrypt64Bloc(bloc,K, true);
            System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);
        }
        if (i &lt; data.length)
            bloc[i % 8] = data[i];
    }
    bloc = encrypt64Bloc(bloc,K, true);
    System.arraycopy(bloc, 0, tmp, i - 8, bloc.length);

    //tmp = deletePadding(tmp);

    return tmp;
}
</code></pre>

<p>According to DesFire document, I need two modes of decryption, send and receive. <a href=""http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/"" rel=""nofollow"">This blog post</a> has some explanation about it. </p>

<blockquote>
  <p>However, the DESFire crypto is a bit different from the normal DES/CBC scheme: The PCD uses DES “send mode” when sending data (xor before DES), and the card uses DES “recieve mode” when recieving data (xor after DES). But when the PCD recieves data, it uses normal DES/CBC mode (xor after DES), and the card uses normal DES send mode when sending data (xor before DES).</p>
</blockquote>

<p>And in Android side I follow the examples and recommendations:</p>

<pre><code>// connected to tag and application     

// result = encoded(randB) + af 
byte[] result = idTag.transceive(Utils.wrapMessage((byte)0x0a, new byte[]{(byte)0x0}));

byte[] b0 = new byte[8];
for(int i = 0; i &lt; 8; i++) {
    b0[i] = result[i];
}

// key
byte[] key = new byte[] {(byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
                 (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
                 (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0,
                 (byte)0x0,(byte)0x0,(byte)0x0,(byte)0x0 };
byte[][] keys = new byte[3][];
keys[0]=key; keys[1]=key; keys[2]=key;

// decrypt encoded(randB)
byte[] r0 = DES.TripleDES_Decrypt(b0, keys);

// generate randA (integer 0-7 for trying) 
byte[] nr = new byte[8];
for(int i = 0; i &lt; 8; i++) {
    nr[i] = Byte.parseByte(Integer.toString(i), 16);
}
// decrypt randA
byte[] b1 = DES.TripleDES_Decrypt(nr, keys);

// shift randB and get randB'
byte[] r1 =new byte[8];
for(int i = 0; i &lt; 7; i++) {
    r1[i] = r0[i + 1];
}
r1[7]=r0[0];

// concat (randA + randB')
byte[] b2 = new byte[16];
for(int i = 0; i &lt; 16; i++)
{
    if(i &lt;= 7) {
    b2[i] = b1[i];
} else {
    b2[i] = r1[i - 8];
}
}

// XOR (randA + randB') with IV
// IV is told to be consisting of 0's, 
// but XOR something with 0 results the same? 
for(int i=0;i&lt;16;i++) {
    b2[i] = (byte) (b2[i] ^ (byte)0x0);
}

// send AF and decrypt(A+B) 
// wrap message adds needed wrapping to message (90 to left, offset bytes etc.)
result = isodepTag.transceive(Utils.wrapMessage((byte)0xaf, DES.TripleDES_Decrypt(b2, keys)));
</code></pre>

<p>I get the first result, the encrypted randB. However, the second ""result"" is always ""91ae"", means authentication error. I'm doing something wrong here, send wrong data to card.</p>

<p>Can anyone tell me what must I change in the code to work in these modes? What should I XOR with data before/after TripleDES?</p>

<p>Not the real question, but I read that default ""Key"" in DesFire card is 16 zero bytes. Also the document points that I need to use TripleDES for 16 bytes of key, DES for 8 bytes of key. So I'm using and need to use TripleDES as I haven't changed the default key, am I right? </p>

<p>For those who need the know about <a href=""http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29"" rel=""nofollow"">CipherBlockChaining</a>.</p>

<p><strong>EDIT</strong>: I found out that I need to do XORing before and after TripleDES and I mustn't touch TripleDES's internal operations at all. I will be trying that in a while. </p>

<p>Deleted the inner TripleDES lines, just saying for the ones seeing the question for the first time.</p>
","<p>Ismat, did you try to write data to the DESFIRE files?</p>

<p>As you explained, when sending data to the card: The PCD uses DES “send mode” when sending data (xor before DES), and the card uses DES “recieve mode” when recieving data (xor after DES)</p>

<p>So I can't get the proper code in order to implement the TDES with the XOR before..I need to do all the crypt-decrypt-crypt and the process is to slow for my application:</p>

<pre><code>res = criptoTransformDec.TransformBlock(datosEscribir, 0, 8, datosEscribir, 0);
res = criptoTransformEnc.TransformBlock(datosEscribir, 0, 8, datosEscribir, 0);
res = criptoTransformDec1.TransformBlock(datosEscribir, 0, 8, datosEscribir, 0);

int l_iAux = 0;
while (l_iAux &lt; (datosEscribir.Length - 8))
    {
        criptoTransformDec2 = desDec.CreateDecryptor(claveSes1, tdesInitialVector);
        //desEnc2 = new DESCryptoServiceProvider();
        criptoTransformEnc2 = desEnc.CreateEncryptor(claveSes2, tdesInitialVector);
        //desDec3 = new DESCryptoServiceProvider();
                criptoTransformDec3 = desDec.CreateDecryptor(claveSes1, tdesInitialVector);

        Array.Copy(datosEscribir, 8 + l_iAux, aux1, 0, 8);
        Array.Copy(datosEscribir, l_iAux, aux2, 0, 8);
        DesfireBarik.XorStr(ref aux1, ref aux2, 8);
        res = criptoTransformDec2.TransformBlock(aux1, 0, 8, datosEscribir, 8 + l_iAux);
        res = criptoTransformEnc2.TransformBlock(datosEscribir, 8 + l_iAux, 8, datosEscribir, 8 + l_iAux);
        res = criptoTransformDec3.TransformBlock(datosEscribir, 8 + l_iAux, 8, datosEscribir, 8 + l_iAux);

        l_iAux += 8;
    }

private static void XorStr (ref byte[] str1, ref byte[] str2, int qty )
    {
        int i = 0;
        for (i = 0; i &lt; qty; i++ )
            str1[i] = (byte)(str1[i] ^ str2[i]);
    }
</code></pre>
","7409","<java><android><nfc><des><mifare>","9","0","2","2015-12-10 12:46:26","14160507","2","15","1275577","","2013-01-04 05:20:54","2013-01-02 04:59:53",""
"47526","Simple encryption implementation in C","<p>I've used a nice public domain <a href=""http://efgh.com/software/des.htm"" rel=""noreferrer"">C++ DES implementation</a> before, but now I need some simple, basic, fast cryptography for an embedded system.</p>

<p>It doesn't need to be unbreakable, but it does need to thwart the casual hacker (ie, nothing that could be used for money or identity theft, but other personal info transferred on memory cards that could get lost or fall into the wrong hands).</p>

<p>Due to limited memory on this processor, I'd prefer something that can encode in discrete chunks (512 bytes or less).</p>

<p>The project is not open source, and won't be using libraries, which I know restricts options further - public domain being best, but BSD/apache/etc probably acceptable...</p>

<p>I'm hesitant to roll my own (as everyone should be).</p>

<p>-Adam</p>
","<p>If you're just looking for obfuscation, XOR with a secret constant is as small an implementation as you will find. It would also be also trivial to break, since its vulnerable to frequency analysis to look for the most common english letters.</p>

<p>If you need a stronger algorithm, I'd recommend looking at blowfish which tends to be small and fast. It does still require memory for tables, but hopefully it will work for your application.</p>

<p>Bruce Schneier explicitly placed the Blowfish algorithm into the public domain, disavowing patents. You can get his implementation in C (and other implementations as well) from <A HREF=""http://www.schneier.com/blowfish-download.html"" rel=""noreferrer"">his site</A>.  This source does not carry a copyright notice. I suspect that the source code too is in the public domain, but a bit more checking may be necessary.</p>
","7338","<encryption><rsa><blowfish><des><publicdomain>","9","7","4","2008-12-20 00:18:30","47543","0","1","2915","Adam Davis","2008-09-06 15:37:50","2008-09-06 15:00:06","2013-03-10 03:38:06"
"47526","Simple encryption implementation in C","<p>I've used a nice public domain <a href=""http://efgh.com/software/des.htm"" rel=""noreferrer"">C++ DES implementation</a> before, but now I need some simple, basic, fast cryptography for an embedded system.</p>

<p>It doesn't need to be unbreakable, but it does need to thwart the casual hacker (ie, nothing that could be used for money or identity theft, but other personal info transferred on memory cards that could get lost or fall into the wrong hands).</p>

<p>Due to limited memory on this processor, I'd prefer something that can encode in discrete chunks (512 bytes or less).</p>

<p>The project is not open source, and won't be using libraries, which I know restricts options further - public domain being best, but BSD/apache/etc probably acceptable...</p>

<p>I'm hesitant to roll my own (as everyone should be).</p>

<p>-Adam</p>
","<p>The same person that released the C++ DES implementation also released a <a href=""http://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm"" rel=""nofollow noreferrer"">C Rijndael Encryption Algorithm</a> - I should have poked around his website a bite more, The <a href=""http://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm"" rel=""nofollow noreferrer"">Tiny Encryption Algorithm</a> (<a href=""http://www.cix.co.uk/~klockstone/tea.pdf"" rel=""nofollow noreferrer"">academic paper here</a>) also has a very small C implementation footprint.</p>

<p><a href=""http://www.schneier.com/blowfish-download.html"" rel=""nofollow noreferrer"">Blowfish</a> looks good, and is likely the best of these three as far as security.</p>

<p>I'll start off with the TEA (small code and memory footprint) but wrap it so I can move to another algorithm later if needed.  It has notable weaknesses in its earlier implementations, but for this project might even be overkill.</p>

<p>-Adam</p>
","7338","<encryption><rsa><blowfish><des><publicdomain>","9","2","4","2008-12-20 00:18:30","47543","0","1","2915","Adam Davis","2008-09-06 15:37:50","2008-09-06 15:00:06","2013-03-10 03:38:06"
"47526","Simple encryption implementation in C","<p>I've used a nice public domain <a href=""http://efgh.com/software/des.htm"" rel=""noreferrer"">C++ DES implementation</a> before, but now I need some simple, basic, fast cryptography for an embedded system.</p>

<p>It doesn't need to be unbreakable, but it does need to thwart the casual hacker (ie, nothing that could be used for money or identity theft, but other personal info transferred on memory cards that could get lost or fall into the wrong hands).</p>

<p>Due to limited memory on this processor, I'd prefer something that can encode in discrete chunks (512 bytes or less).</p>

<p>The project is not open source, and won't be using libraries, which I know restricts options further - public domain being best, but BSD/apache/etc probably acceptable...</p>

<p>I'm hesitant to roll my own (as everyone should be).</p>

<p>-Adam</p>
","<p><a href=""http://en.wikipedia.org/wiki/RC4"" rel=""nofollow noreferrer"">RC4</a> is simple and fast.</p>
","7338","<encryption><rsa><blowfish><des><publicdomain>","9","3","4","2008-12-20 00:18:30","47543","0","1","2915","Adam Davis","2008-09-06 15:37:50","2008-09-06 15:00:06","2013-03-10 03:38:06"
"47526","Simple encryption implementation in C","<p>I've used a nice public domain <a href=""http://efgh.com/software/des.htm"" rel=""noreferrer"">C++ DES implementation</a> before, but now I need some simple, basic, fast cryptography for an embedded system.</p>

<p>It doesn't need to be unbreakable, but it does need to thwart the casual hacker (ie, nothing that could be used for money or identity theft, but other personal info transferred on memory cards that could get lost or fall into the wrong hands).</p>

<p>Due to limited memory on this processor, I'd prefer something that can encode in discrete chunks (512 bytes or less).</p>

<p>The project is not open source, and won't be using libraries, which I know restricts options further - public domain being best, but BSD/apache/etc probably acceptable...</p>

<p>I'm hesitant to roll my own (as everyone should be).</p>

<p>-Adam</p>
","<p>You could use a <a href=""http://en.wikipedia.org/wiki/Pseudo-random_number_generator"" rel=""nofollow noreferrer"">Pseudorandom number generator</a> (PRNG) to generate a repeatable sequence of words, which you then XOR with the corresponding word in your data stream. (The transmitter and receiver need to know in advance the parameters used to generate the pseudorandom sequence.)</p>

<p>This approach isn't unbreakable, but it's a step up from using a constant for the XOR-ing - and PRNGs are very simple to implement, typically consisting of one multiplication and modulo operation for each word.</p>
","7338","<encryption><rsa><blowfish><des><publicdomain>","9","1","4","2008-12-20 00:18:30","47543","0","1","2915","Adam Davis","2008-09-06 15:37:50","2008-09-06 15:00:06","2013-03-10 03:38:06"
"17330362","decrypting with DES throws an ”InvalidKeyException: Parameters missing” when using other mode than ECB","<p>I basically use the code from here <a href=""http://www.avajava.com/tutorials/lessons/how-do-i-encrypt-and-decrypt-files-using-des.html"" rel=""nofollow"">http://www.avajava.com/tutorials/lessons/how-do-i-encrypt-and-decrypt-files-using-des.html</a> for an encryption app but I want to be able to chose the mode of operation so I added this:</p>

<pre><code>private String key;
private static String algorithmMode;

    public DESCrypt(String password, String algorithmMode) {
        this.key = password;
        this.algorithmMode = ""DES/"" + algorithmMode + ""/PKCS5Padding"";
    }
</code></pre>

<p>the main looks like this:</p>

<pre><code>public static void main(String[] args) {
        try {
            DESCrypt des = new DESCrypt(""12345678"", algorithmMode);

            // FileInputStream fis1 = new FileInputStream(""d:\\_test.txt"");
            // FileOutputStream fos1 = new FileOutputStream(""d:\\_test.txt.des"");
            // des.encrypt(fis1, fos1);

            FileInputStream fis = new FileInputStream(""d:\\_test.txt.des"");
            FileOutputStream fos = new FileOutputStream(""d:\\_test.txt"");
            des.decrypt(fis, fos);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
</code></pre>

<p>As I was saying in the title it works fine with ECB but with other modes I can only encrypt.</p>
","<p>You are missing an IV value for your decryption. You need to include this in your <code>Cipher.init</code> call:</p>

<pre><code>... Cipher.init(Cipher.DECRYPT, someKey, new IvParameterSpec(eightByteValue));
</code></pre>

<p>If you omit it from your encryption code, a random IV value will be generated. You will need to store this (retrieved via <code>Cipher.getIV()</code>) to use in your decryption code.</p>
","7244","<java><des><ecb>","3","7","1","2013-06-26 21:08:18","17330464","0","","","","","2013-06-26 20:59:50",""
"15001673","Mifare DESFIRE EV1 GetCardUid","<p>The following code works and allows me to get the UID of a Mifare 1k card. Unfortunately, it does not work with Desfire cards.</p>

<pre><code>    public byte[] GetUid()
    {
        byte[] uid = new byte[6];
        int rc = Communicate(new byte[]{0xff, 0xca, 0x00, 0x00, 0x04}, ref uid);
        if (rc != 0)
            throw new Exception(""failure: "" + rc);

        int rc1, rc2;
        if (uid.Length == 2)
        {
            rc1 = uid[0];
            rc2 = uid[1];
        }
        else
        {
            rc1 = uid[4];
            rc2 = uid[5];
        }

        if (rc1 != 0x90 || rc2 != 0x00)
            throw new Exception(""failure: "" + rc1 + ""/"" + rc2);

        byte[] result = new byte[4];
        Array.Copy(uid, result, 4);
        return result;
    }
</code></pre>

<p>I had a look at following resources</p>

<ul>
<li><a href=""http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/"" rel=""nofollow"">http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/</a></li>
<li><a href=""http://code.google.com/p/nfc-tools/source/browse/trunk/libfreefare/libfreefare/mifare_desfire.c?r=532"" rel=""nofollow"">http://code.google.com/p/nfc-tools/source/browse/trunk/libfreefare/libfreefare/mifare_desfire.c?r=532</a></li>
</ul>

<p>... and tried to do it like this:</p>

<pre><code>        byte[] outb = new byte[15];
        int rc9 = Communicate(new byte[] { 0x60 }, ref outb);
</code></pre>

<p>outb always contains { 0x67, 0x00 } and not, as expected, { af 04 01 01 00 02 18 05 }.</p>

<p>Connect is sucessful, and SCardGetAttrib allows me to fetch the ATR. The Communicate method works with SCardTransmit. I can post the code if it helps.</p>

<p>Thanks for any pointer!</p>

<p><strong>EDIT</strong>:</p>

<p>Thanks for the first answer! I changed the program as suggested:</p>

<pre><code>        byte[] outb = new byte[9];
        int rc5 = Communicate(new byte[]{0x90, 0x60, 0x00, 0x00, 0x00, 0x00}, ref outb);
</code></pre>

<p>Now outb is {  0x91, 0x7E }. This seems to be better, 0x91 looking like an ISO 7816 response code, but unfortunately not 0x90, as expected. (I also had a look at the DESFIRE_TRANSCEIVE macro in the second link that continues reading if it receives 0xf2.) I tried a Google search for ISO 7816 APDU response codes, but had no success in decoding the error code.</p>

<p><strong>EDIT 2</strong>:</p>

<p>I also found the following comment:</p>

<blockquote>
  <p>with an omnikey 5321 I get DESFire ATR 3B8180018080 UID 04 52 2E AA 47
  23 80 90 00 [from apdu FFCA000000] All other apdu give 917E unknown
  error</p>
</blockquote>

<p>This explains my error code and gives me another hint, FFCA000000 looking quite similar to my other Mifare 1k string. So with FFCA000000 I get a 9 byte response that seem to contain the UID. Interestingly, the FFCA000000 code also works with the 1k cards, so maybe my solution is just to change the last 04 to 00 and deal with responses of different length. Right?</p>

<p><strong>EDIT 3</strong>:</p>

<p>It seems the penny has dropped... 0x04 = 4 bytes response = too small for a 7 byte UID = response 917E = buffer too small :-)</p>
","<p>Try the ""Native wrapped"" version of the first link you supplied instead. Your interface expects ISO 7816-4 style APDU's (as it returns an ISO 7816-4 status word meaning wrong length).</p>
","7019","<c#><.net><smartcard><des><mifare>","0","1","3","2013-08-17 18:05:41","15012922","0","3","347775","","2013-02-22 08:45:01","2013-02-21 11:57:12",""
"15001673","Mifare DESFIRE EV1 GetCardUid","<p>The following code works and allows me to get the UID of a Mifare 1k card. Unfortunately, it does not work with Desfire cards.</p>

<pre><code>    public byte[] GetUid()
    {
        byte[] uid = new byte[6];
        int rc = Communicate(new byte[]{0xff, 0xca, 0x00, 0x00, 0x04}, ref uid);
        if (rc != 0)
            throw new Exception(""failure: "" + rc);

        int rc1, rc2;
        if (uid.Length == 2)
        {
            rc1 = uid[0];
            rc2 = uid[1];
        }
        else
        {
            rc1 = uid[4];
            rc2 = uid[5];
        }

        if (rc1 != 0x90 || rc2 != 0x00)
            throw new Exception(""failure: "" + rc1 + ""/"" + rc2);

        byte[] result = new byte[4];
        Array.Copy(uid, result, 4);
        return result;
    }
</code></pre>

<p>I had a look at following resources</p>

<ul>
<li><a href=""http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/"" rel=""nofollow"">http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/</a></li>
<li><a href=""http://code.google.com/p/nfc-tools/source/browse/trunk/libfreefare/libfreefare/mifare_desfire.c?r=532"" rel=""nofollow"">http://code.google.com/p/nfc-tools/source/browse/trunk/libfreefare/libfreefare/mifare_desfire.c?r=532</a></li>
</ul>

<p>... and tried to do it like this:</p>

<pre><code>        byte[] outb = new byte[15];
        int rc9 = Communicate(new byte[] { 0x60 }, ref outb);
</code></pre>

<p>outb always contains { 0x67, 0x00 } and not, as expected, { af 04 01 01 00 02 18 05 }.</p>

<p>Connect is sucessful, and SCardGetAttrib allows me to fetch the ATR. The Communicate method works with SCardTransmit. I can post the code if it helps.</p>

<p>Thanks for any pointer!</p>

<p><strong>EDIT</strong>:</p>

<p>Thanks for the first answer! I changed the program as suggested:</p>

<pre><code>        byte[] outb = new byte[9];
        int rc5 = Communicate(new byte[]{0x90, 0x60, 0x00, 0x00, 0x00, 0x00}, ref outb);
</code></pre>

<p>Now outb is {  0x91, 0x7E }. This seems to be better, 0x91 looking like an ISO 7816 response code, but unfortunately not 0x90, as expected. (I also had a look at the DESFIRE_TRANSCEIVE macro in the second link that continues reading if it receives 0xf2.) I tried a Google search for ISO 7816 APDU response codes, but had no success in decoding the error code.</p>

<p><strong>EDIT 2</strong>:</p>

<p>I also found the following comment:</p>

<blockquote>
  <p>with an omnikey 5321 I get DESFire ATR 3B8180018080 UID 04 52 2E AA 47
  23 80 90 00 [from apdu FFCA000000] All other apdu give 917E unknown
  error</p>
</blockquote>

<p>This explains my error code and gives me another hint, FFCA000000 looking quite similar to my other Mifare 1k string. So with FFCA000000 I get a 9 byte response that seem to contain the UID. Interestingly, the FFCA000000 code also works with the 1k cards, so maybe my solution is just to change the last 04 to 00 and deal with responses of different length. Right?</p>

<p><strong>EDIT 3</strong>:</p>

<p>It seems the penny has dropped... 0x04 = 4 bytes response = too small for a 7 byte UID = response 917E = buffer too small :-)</p>
","<p>This code seems to work:</p>

<pre><code>        int rc = Communicate(new byte[] { 0xff, 0xca, 0x00, 0x00, 0x00 }, ref uid);
        if (rc != 0)
            throw new Exception(""failure: "" + rc);

        int rc1 = uid[uid.Length-2], rc2 = uid[uid.Length-1];

        if (rc1 != 0x90 || rc2 != 0x00)
            throw new Exception(""failure: "" + rc1 + ""/"" + rc2);

        byte[] result = new byte[uid.Length - 2];
        Array.Copy(uid, result, uid.Length - 2);
        return result;
</code></pre>

<p>Any comments?</p>
","7019","<c#><.net><smartcard><des><mifare>","0","3","3","2013-08-17 18:05:41","15012922","0","3","347775","","2013-02-22 08:45:01","2013-02-21 11:57:12",""
"15001673","Mifare DESFIRE EV1 GetCardUid","<p>The following code works and allows me to get the UID of a Mifare 1k card. Unfortunately, it does not work with Desfire cards.</p>

<pre><code>    public byte[] GetUid()
    {
        byte[] uid = new byte[6];
        int rc = Communicate(new byte[]{0xff, 0xca, 0x00, 0x00, 0x04}, ref uid);
        if (rc != 0)
            throw new Exception(""failure: "" + rc);

        int rc1, rc2;
        if (uid.Length == 2)
        {
            rc1 = uid[0];
            rc2 = uid[1];
        }
        else
        {
            rc1 = uid[4];
            rc2 = uid[5];
        }

        if (rc1 != 0x90 || rc2 != 0x00)
            throw new Exception(""failure: "" + rc1 + ""/"" + rc2);

        byte[] result = new byte[4];
        Array.Copy(uid, result, 4);
        return result;
    }
</code></pre>

<p>I had a look at following resources</p>

<ul>
<li><a href=""http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/"" rel=""nofollow"">http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/</a></li>
<li><a href=""http://code.google.com/p/nfc-tools/source/browse/trunk/libfreefare/libfreefare/mifare_desfire.c?r=532"" rel=""nofollow"">http://code.google.com/p/nfc-tools/source/browse/trunk/libfreefare/libfreefare/mifare_desfire.c?r=532</a></li>
</ul>

<p>... and tried to do it like this:</p>

<pre><code>        byte[] outb = new byte[15];
        int rc9 = Communicate(new byte[] { 0x60 }, ref outb);
</code></pre>

<p>outb always contains { 0x67, 0x00 } and not, as expected, { af 04 01 01 00 02 18 05 }.</p>

<p>Connect is sucessful, and SCardGetAttrib allows me to fetch the ATR. The Communicate method works with SCardTransmit. I can post the code if it helps.</p>

<p>Thanks for any pointer!</p>

<p><strong>EDIT</strong>:</p>

<p>Thanks for the first answer! I changed the program as suggested:</p>

<pre><code>        byte[] outb = new byte[9];
        int rc5 = Communicate(new byte[]{0x90, 0x60, 0x00, 0x00, 0x00, 0x00}, ref outb);
</code></pre>

<p>Now outb is {  0x91, 0x7E }. This seems to be better, 0x91 looking like an ISO 7816 response code, but unfortunately not 0x90, as expected. (I also had a look at the DESFIRE_TRANSCEIVE macro in the second link that continues reading if it receives 0xf2.) I tried a Google search for ISO 7816 APDU response codes, but had no success in decoding the error code.</p>

<p><strong>EDIT 2</strong>:</p>

<p>I also found the following comment:</p>

<blockquote>
  <p>with an omnikey 5321 I get DESFire ATR 3B8180018080 UID 04 52 2E AA 47
  23 80 90 00 [from apdu FFCA000000] All other apdu give 917E unknown
  error</p>
</blockquote>

<p>This explains my error code and gives me another hint, FFCA000000 looking quite similar to my other Mifare 1k string. So with FFCA000000 I get a 9 byte response that seem to contain the UID. Interestingly, the FFCA000000 code also works with the 1k cards, so maybe my solution is just to change the last 04 to 00 and deal with responses of different length. Right?</p>

<p><strong>EDIT 3</strong>:</p>

<p>It seems the penny has dropped... 0x04 = 4 bytes response = too small for a 7 byte UID = response 917E = buffer too small :-)</p>
","<p>Cla=ff commands are pcsc part 3 commands. Ins=ca should work with any cl reader that is pcsc 2.0x compliant</p>
","7019","<c#><.net><smartcard><des><mifare>","0","2","3","2013-08-17 18:05:41","15012922","0","3","347775","","2013-02-22 08:45:01","2013-02-21 11:57:12",""
"10583023","In a ""C"" program how can I store a hexadecimal value in a string variable?","<p>I have a program which takes the input data as a plaintext and then decrypts the message using 3DES method in CBC mode. But the values are hardcoded in the program I want to provide the encrypted value myself which should be decryted. How can I do this in the following program?</p>

<pre><code>int main(void)
{
    unsigned char in[BUFSIZE], out[BUFSIZE], back[BUFSIZE];
    unsigned char *e = out;
    int len;

    DES_cblock key;
    DES_cblock seed = {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};
    DES_cblock ivsetup = {0xE1, 0xE2, 0xE3, 0xD4, 0xD5, 0xC6, 0xC7, 0xA8};
    DES_key_schedule keysched;
    DES_cblock ivec;

    memset(in, 0, sizeof(in));
    memset(out, 0, sizeof(out));
    memset(back, 0, sizeof(back));

    RAND_seed(seed, sizeof(DES_cblock));

    DES_random_key(&amp;key);
    DES_set_odd_parity(&amp;key);
    if (DES_set_key_checked((C_Block *)key, &amp;keysched))
    {
        fprintf(stderr, ""ERROR: Unable to set key schedule\n"");
        exit(1);
    }

    /* 64 bytes of plaintext */

    /* From here, encryption starts for the plaintext below. */

    strcpy(in, ""Now is the time for all men to stand up and be counted"");

    printf(""Plaintext: [%s]\n"", in);

    len = strlen(in);
    memcpy(ivec, ivsetup, sizeof(ivsetup));
    DES_ncbc_encrypt(in, out, len, &amp;keysched, &amp;ivec, DES_ENCRYPT);

    printf(""Ciphertext:"");
    while (*e) printf("" [%02x]"", *e++);
    printf(""\n"");

    /* Till here, encryption is over. After this we have to decrypt
     * the value which has been encoded, but I want to remove all this
     * part and to provide my own encrypted message, and get the
     * proper output.
     */

    memcpy(ivec, ivsetup, sizeof(ivsetup));

    /* The problem I am facing is how to provide the value properly
     * to the parameter ""out"" and ""keysched"", which should be of my
     * choice. For ""out"" I want to provide THIS value:
     * ""2DC39619B4450A8C27A3976C50DE5799"".
     */

    DES_ncbc_encrypt(out, back, len, &amp;keysched, &amp;ivec, DES_DECRYPT);

    printf(""Decrypted Text: [%s]\n"", back);

    exit(0);
}
</code></pre>

<p>Read more: <a href=""http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv"" rel=""nofollow"">http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv</a></p>
","<p>Using the nonstandard <code>itoa</code> function that stores the value it as a string, you can do the following:</p>

<pre><code>char* hexstr = itoa(back,16); 

// print out a string
printf(""Decrypted Text: [%X]\n"", back);
</code></pre>
","6872","<c><encryption><des>","0","0","4","2012-07-17 19:25:10","10598464","5","1","60281","","2012-05-14 16:08:54","2012-05-14 12:08:52",""
"10583023","In a ""C"" program how can I store a hexadecimal value in a string variable?","<p>I have a program which takes the input data as a plaintext and then decrypts the message using 3DES method in CBC mode. But the values are hardcoded in the program I want to provide the encrypted value myself which should be decryted. How can I do this in the following program?</p>

<pre><code>int main(void)
{
    unsigned char in[BUFSIZE], out[BUFSIZE], back[BUFSIZE];
    unsigned char *e = out;
    int len;

    DES_cblock key;
    DES_cblock seed = {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};
    DES_cblock ivsetup = {0xE1, 0xE2, 0xE3, 0xD4, 0xD5, 0xC6, 0xC7, 0xA8};
    DES_key_schedule keysched;
    DES_cblock ivec;

    memset(in, 0, sizeof(in));
    memset(out, 0, sizeof(out));
    memset(back, 0, sizeof(back));

    RAND_seed(seed, sizeof(DES_cblock));

    DES_random_key(&amp;key);
    DES_set_odd_parity(&amp;key);
    if (DES_set_key_checked((C_Block *)key, &amp;keysched))
    {
        fprintf(stderr, ""ERROR: Unable to set key schedule\n"");
        exit(1);
    }

    /* 64 bytes of plaintext */

    /* From here, encryption starts for the plaintext below. */

    strcpy(in, ""Now is the time for all men to stand up and be counted"");

    printf(""Plaintext: [%s]\n"", in);

    len = strlen(in);
    memcpy(ivec, ivsetup, sizeof(ivsetup));
    DES_ncbc_encrypt(in, out, len, &amp;keysched, &amp;ivec, DES_ENCRYPT);

    printf(""Ciphertext:"");
    while (*e) printf("" [%02x]"", *e++);
    printf(""\n"");

    /* Till here, encryption is over. After this we have to decrypt
     * the value which has been encoded, but I want to remove all this
     * part and to provide my own encrypted message, and get the
     * proper output.
     */

    memcpy(ivec, ivsetup, sizeof(ivsetup));

    /* The problem I am facing is how to provide the value properly
     * to the parameter ""out"" and ""keysched"", which should be of my
     * choice. For ""out"" I want to provide THIS value:
     * ""2DC39619B4450A8C27A3976C50DE5799"".
     */

    DES_ncbc_encrypt(out, back, len, &amp;keysched, &amp;ivec, DES_DECRYPT);

    printf(""Decrypted Text: [%s]\n"", back);

    exit(0);
}
</code></pre>

<p>Read more: <a href=""http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv"" rel=""nofollow"">http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv</a></p>
","<p>Create a dump function like this:</p>

<pre><code>hexdump(char *buff, int len) { 
  int i,tmp;
  for(i=0; i &lt; len; i++) {
    tmp = buff[i] &amp; 0xff; /** to avoid sign extension */
    printf(""%02x"",tmp);
  }
} 
</code></pre>

<p>And use it.</p>

<pre><code>hexdump(back,len);
</code></pre>

<p>If you have to write it in memory, you can use sprintf, but you may have to write your own binary to hex function.</p>
","6872","<c><encryption><des>","0","0","4","2012-07-17 19:25:10","10598464","5","1","60281","","2012-05-14 16:08:54","2012-05-14 12:08:52",""
"10583023","In a ""C"" program how can I store a hexadecimal value in a string variable?","<p>I have a program which takes the input data as a plaintext and then decrypts the message using 3DES method in CBC mode. But the values are hardcoded in the program I want to provide the encrypted value myself which should be decryted. How can I do this in the following program?</p>

<pre><code>int main(void)
{
    unsigned char in[BUFSIZE], out[BUFSIZE], back[BUFSIZE];
    unsigned char *e = out;
    int len;

    DES_cblock key;
    DES_cblock seed = {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};
    DES_cblock ivsetup = {0xE1, 0xE2, 0xE3, 0xD4, 0xD5, 0xC6, 0xC7, 0xA8};
    DES_key_schedule keysched;
    DES_cblock ivec;

    memset(in, 0, sizeof(in));
    memset(out, 0, sizeof(out));
    memset(back, 0, sizeof(back));

    RAND_seed(seed, sizeof(DES_cblock));

    DES_random_key(&amp;key);
    DES_set_odd_parity(&amp;key);
    if (DES_set_key_checked((C_Block *)key, &amp;keysched))
    {
        fprintf(stderr, ""ERROR: Unable to set key schedule\n"");
        exit(1);
    }

    /* 64 bytes of plaintext */

    /* From here, encryption starts for the plaintext below. */

    strcpy(in, ""Now is the time for all men to stand up and be counted"");

    printf(""Plaintext: [%s]\n"", in);

    len = strlen(in);
    memcpy(ivec, ivsetup, sizeof(ivsetup));
    DES_ncbc_encrypt(in, out, len, &amp;keysched, &amp;ivec, DES_ENCRYPT);

    printf(""Ciphertext:"");
    while (*e) printf("" [%02x]"", *e++);
    printf(""\n"");

    /* Till here, encryption is over. After this we have to decrypt
     * the value which has been encoded, but I want to remove all this
     * part and to provide my own encrypted message, and get the
     * proper output.
     */

    memcpy(ivec, ivsetup, sizeof(ivsetup));

    /* The problem I am facing is how to provide the value properly
     * to the parameter ""out"" and ""keysched"", which should be of my
     * choice. For ""out"" I want to provide THIS value:
     * ""2DC39619B4450A8C27A3976C50DE5799"".
     */

    DES_ncbc_encrypt(out, back, len, &amp;keysched, &amp;ivec, DES_DECRYPT);

    printf(""Decrypted Text: [%s]\n"", back);

    exit(0);
}
</code></pre>

<p>Read more: <a href=""http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv"" rel=""nofollow"">http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv</a></p>
","<p>Read <a href=""http://c-faq.com/misc/hexio.html"" rel=""nofollow noreferrer"">C FAQ 20.10</a>. Hexadecimal is a representation. All numbers are stored in binary internally. Your <code>DES_cblock</code> is probably a <code>typedef</code> for an (unsigned, perhaps!) integral type. So, what you have in effect is an array of integers. You can put numbers in decimal, hexadecimal or binary -- but they will all work. <a href=""https://stackoverflow.com/questions/9800675/use-of-byte-arrays-and-hex-values-in-cryptography"">Hexadecimal is typically used</a> in cryptography because it has some notational advantages.</p>
","6872","<c><encryption><des>","0","2","4","2012-07-17 19:25:10","10598464","5","1","60281","","2012-05-14 16:08:54","2012-05-14 12:08:52",""
"10583023","In a ""C"" program how can I store a hexadecimal value in a string variable?","<p>I have a program which takes the input data as a plaintext and then decrypts the message using 3DES method in CBC mode. But the values are hardcoded in the program I want to provide the encrypted value myself which should be decryted. How can I do this in the following program?</p>

<pre><code>int main(void)
{
    unsigned char in[BUFSIZE], out[BUFSIZE], back[BUFSIZE];
    unsigned char *e = out;
    int len;

    DES_cblock key;
    DES_cblock seed = {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};
    DES_cblock ivsetup = {0xE1, 0xE2, 0xE3, 0xD4, 0xD5, 0xC6, 0xC7, 0xA8};
    DES_key_schedule keysched;
    DES_cblock ivec;

    memset(in, 0, sizeof(in));
    memset(out, 0, sizeof(out));
    memset(back, 0, sizeof(back));

    RAND_seed(seed, sizeof(DES_cblock));

    DES_random_key(&amp;key);
    DES_set_odd_parity(&amp;key);
    if (DES_set_key_checked((C_Block *)key, &amp;keysched))
    {
        fprintf(stderr, ""ERROR: Unable to set key schedule\n"");
        exit(1);
    }

    /* 64 bytes of plaintext */

    /* From here, encryption starts for the plaintext below. */

    strcpy(in, ""Now is the time for all men to stand up and be counted"");

    printf(""Plaintext: [%s]\n"", in);

    len = strlen(in);
    memcpy(ivec, ivsetup, sizeof(ivsetup));
    DES_ncbc_encrypt(in, out, len, &amp;keysched, &amp;ivec, DES_ENCRYPT);

    printf(""Ciphertext:"");
    while (*e) printf("" [%02x]"", *e++);
    printf(""\n"");

    /* Till here, encryption is over. After this we have to decrypt
     * the value which has been encoded, but I want to remove all this
     * part and to provide my own encrypted message, and get the
     * proper output.
     */

    memcpy(ivec, ivsetup, sizeof(ivsetup));

    /* The problem I am facing is how to provide the value properly
     * to the parameter ""out"" and ""keysched"", which should be of my
     * choice. For ""out"" I want to provide THIS value:
     * ""2DC39619B4450A8C27A3976C50DE5799"".
     */

    DES_ncbc_encrypt(out, back, len, &amp;keysched, &amp;ivec, DES_DECRYPT);

    printf(""Decrypted Text: [%s]\n"", back);

    exit(0);
}
</code></pre>

<p>Read more: <a href=""http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv"" rel=""nofollow"">http://blog.fpmurphy.com/2010/04/openssl-des-api.html#ixzz1uqOp1Yhv</a></p>
","<p>I got it done.
I did it in a childish way for the time being but it is working now. I did it like this.</p>

<pre><code>out[0]=0xA0; out[1]=0x69; out[2]=0x57; out[3]=0x3B;
out[4]=0x70; out[5]=0x26; out[6]=0x1C; out[7]=0xE8;
out[8]=0xEF; out[9]=0xF2; out[10]=0x9F;out[11]=0x60;
out[12]=0x80;out[13]=0x60;out[14]=0xB2;out[15]=0xE5;
</code></pre>

<p>Later I will do this thing in a for loop.</p>
","6872","<c><encryption><des>","0","1","4","2012-07-17 19:25:10","10598464","5","1","60281","","2012-05-14 16:08:54","2012-05-14 12:08:52",""
"6990286","Triple DES encryption","<p>Please note that the issue I am having here is with the key <em>size</em>. At first, based on the comments included in the below code, I figured that my key needed to be 24 bytes (192 bits). This didn't work so I gave 16, 32, and 8 byte keys a shot - nothing seems to be working. By ""not working"" I mean that after my text has been encrypted and decrypted it does not hold the same value as my original text.</p>

<h3>
Example: 
</h3>

<p><strong>Original Text:</strong> <code>'Example test this should work '</code></p>

<p><strong>Encrypted Text:</strong> ¸<code>¹pÕô6</code></p>

<p><strong>Decrypted Text:</strong> <code>'Example '</code></p>

<p>Here are the two functions I am using (Encrypt / Decrypt functions). Also I will include how I am calling each function.</p>

<pre><code>        // 168-bit (three-key) 3DES (Triple-DES) encrypt a single 8-byte block (ECB mode)
        // plain-text should be 8-bytes, key should be 24 bytes.
        public byte[] TripleDesEncryptOneBlock(byte[] plainText, byte[] key)
        {
            // Create a new 3DES key.
            TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();

            // Set the KeySize = 192 for 168-bit DES encryption.
            // The msb of each byte is a parity bit, so the key length is actually 168 bits.

            des.KeySize = 192;
            des.Key = key;
            des.Mode = CipherMode.ECB;
            des.Padding = PaddingMode.None;

            ICryptoTransform ic = des.CreateEncryptor();

            byte[] enc = ic.TransformFinalBlock(plainText, 0, 8);

            return enc;
        }

        public byte[] TripleDesDecryptBlock(byte[] plainText, byte[] key)
        {
            // Create a new 3DES key.
            TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();

            // Set the KeySize = 192 for 168-bit DES encryption.
            // The msb of each byte is a parity bit, so the key length is actually 168 bits.
            des.KeySize = 192;
            des.Key = key;
            des.Mode = CipherMode.ECB;
            des.Padding = PaddingMode.None;

            ICryptoTransform ic = des.CreateDecryptor();

            byte[] dec = ic.TransformFinalBlock(plainText, 0, 8);

            return dec;
        }

// Encrypt Text
textBox5.Text = ByteToString(TripleDesEncryptOneBlock(StringToByte(textBox5.Text), StringToByte(""1 2 3 4 5 6 7 8 9 1 1 2 "")));

// Decrypt Text
textBox5.Text = ByteToString(TripleDesDecryptBlock(StringToByte(textBox5.Text), StringToByte(""1 2 3 4 5 6 7 8 9 1 1 2 "")));
</code></pre>

<p>Thank you for any help,</p>

<p>Evan</p>
","<p>The clue is in the name of the function you're using:  <code>TripleDesEncryptOneBlock</code></p>

<p>This method only encrypts one block of the input string (8 bytes or 64 bits).  To encrypt the entire string you need to chain multiple calls to this method.</p>
","6740","<c#><encryption><des>","5","2","2","2012-12-12 07:20:50","","2","2","109702","","2011-08-09 01:13:00","2011-08-09 00:51:38",""
"6990286","Triple DES encryption","<p>Please note that the issue I am having here is with the key <em>size</em>. At first, based on the comments included in the below code, I figured that my key needed to be 24 bytes (192 bits). This didn't work so I gave 16, 32, and 8 byte keys a shot - nothing seems to be working. By ""not working"" I mean that after my text has been encrypted and decrypted it does not hold the same value as my original text.</p>

<h3>
Example: 
</h3>

<p><strong>Original Text:</strong> <code>'Example test this should work '</code></p>

<p><strong>Encrypted Text:</strong> ¸<code>¹pÕô6</code></p>

<p><strong>Decrypted Text:</strong> <code>'Example '</code></p>

<p>Here are the two functions I am using (Encrypt / Decrypt functions). Also I will include how I am calling each function.</p>

<pre><code>        // 168-bit (three-key) 3DES (Triple-DES) encrypt a single 8-byte block (ECB mode)
        // plain-text should be 8-bytes, key should be 24 bytes.
        public byte[] TripleDesEncryptOneBlock(byte[] plainText, byte[] key)
        {
            // Create a new 3DES key.
            TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();

            // Set the KeySize = 192 for 168-bit DES encryption.
            // The msb of each byte is a parity bit, so the key length is actually 168 bits.

            des.KeySize = 192;
            des.Key = key;
            des.Mode = CipherMode.ECB;
            des.Padding = PaddingMode.None;

            ICryptoTransform ic = des.CreateEncryptor();

            byte[] enc = ic.TransformFinalBlock(plainText, 0, 8);

            return enc;
        }

        public byte[] TripleDesDecryptBlock(byte[] plainText, byte[] key)
        {
            // Create a new 3DES key.
            TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();

            // Set the KeySize = 192 for 168-bit DES encryption.
            // The msb of each byte is a parity bit, so the key length is actually 168 bits.
            des.KeySize = 192;
            des.Key = key;
            des.Mode = CipherMode.ECB;
            des.Padding = PaddingMode.None;

            ICryptoTransform ic = des.CreateDecryptor();

            byte[] dec = ic.TransformFinalBlock(plainText, 0, 8);

            return dec;
        }

// Encrypt Text
textBox5.Text = ByteToString(TripleDesEncryptOneBlock(StringToByte(textBox5.Text), StringToByte(""1 2 3 4 5 6 7 8 9 1 1 2 "")));

// Decrypt Text
textBox5.Text = ByteToString(TripleDesDecryptBlock(StringToByte(textBox5.Text), StringToByte(""1 2 3 4 5 6 7 8 9 1 1 2 "")));
</code></pre>

<p>Thank you for any help,</p>

<p>Evan</p>
","<p>Use this:</p>

<p><code>byte[] enc = ic.TransformFinalBlock(plainText, 0, plainText.Length);</code></p>

<p>I hope it will encrypt/decrypt your whole string. Also you will need not to call this method multiple times</p>
","6740","<c#><encryption><des>","5","2","2","2012-12-12 07:20:50","","2","2","109702","","2011-08-09 01:13:00","2011-08-09 00:51:38",""
"16231224","Pkcs7 padding in java","<p>Iam using TripleDes /cbc/pkcs7padding in C#.net to encrypt file.
and i need to decrypt in java.In java am using DESede/CBC/PKcs5padding
But the file is decrypted,but corrupted.</p>

<p>*In java is it possible to use pkcs7padding?
or any other solution to decrypt the file in java with encrypted using pkcs7 padding</p>

<p>C# code</p>

<pre><code>namespace EncryptEpubFiles
 {
public class Encryptor
 {
    public static bool EncryptBook(FileInfo fileToEncrypt,string   outPathWithoutExtension,string keyString)
    {
       try
       {
           byte[] encryptedFileByteArray;
           //Start Encryption service provider
           TripleDESCryptoServiceProvider tDES = new TripleDESCryptoServiceProvider();
           //Read all bytes from input file
           byte[] _fileByteArray = File.ReadAllBytes(fileToEncrypt.FullName);
           tDES.Key = GetBytes(keyString);
           tDES.Mode = CipherMode.CBC;
           //tDES.Padding = PaddingMode.PKCS7;
           tDES.Padding = PaddingMode.PKCS7;
           ICryptoTransform trans = tDES.CreateEncryptor();
           //Create Encrypted file byte array
           encryptedFileByteArray = (trans.TransformFinalBlock(_fileByteArray, 0, ((_fileByteArray).Length)));
           //Write Encrypted file byte array to a filr with proper extension
           System.IO.File.WriteAllBytes((outPathWithoutExtension + "".akr""), encryptedFileByteArray);

           return true;
       }
       catch (Exception ex)
       {
           return false;
       }
   }
</code></pre>

<p>Java code</p>

<pre><code>public class DecryptFinal {
private static Cipher dcipher;

private static byte[] iv = {
    (byte)0xB2, (byte)0x12, (byte)0xD5, (byte)0xB2,
    (byte)0x44, (byte)0x21, (byte)0xC3, (byte)0xC3
    };


public static void main(String[] args){

    try {
        String s = ""123456789123456789111234"";
        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);

        SecretKeyFactory keyfactory=SecretKeyFactory.getInstance(""DESede"");
        byte[] encodedkey=s.getBytes();
        System.out.println();
         SecretKey key = keyfactory.generateSecret(new DESedeKeySpec(encodedkey));
         System.out.println(new DESedeKeySpec(encodedkey));
        SecretKeySpec(encodedKey,0,encodedKey.length,""DESede"" );

        dcipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
        FileInputStream fs =new FileInputStream(""E:\\Test1\\Test1\\Encrypted Files\\Wedding bells.akr"");
        FileOutputStream os= new FileOutputStream(""E:\\Test1\\Test1\\Encrypted Files\\Encrypted Files\\E-pub Totorials"");
        byte[] buf = new byte[1024];// bytes read from stream will be decrypted
        CipherInputStream cis = new CipherInputStream(fs, dcipher);// read in the decrypted bytes and write the clear text to out
        int numRead = 0;
        while ((numRead = cis.read(buf)) &gt;= 0) {
            os.write(buf, 0, numRead);
        }
        cis.close();// close all streams
        fs.close();
        os.close();

    }
    catch(FileNotFoundException e) {
        System.out.println(""File Not Found:"" + e.getMessage());
        return;
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();

    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    catch (IOException e) {
        System.out.println(""I/O Error:"" + e.getMessage());
    }
    catch (InvalidKeySpecException e) {
        // TODO: handle exception
        e.printStackTrace();
    }
</code></pre>
","","6458","<java><padding><encryption><des>","3","","0","2014-10-06 10:32:17","","3","0","2060529","","2013-04-26 09:48:13","2013-04-26 07:44:43",""
"19305102","C# DES Encryption example","<p>I've learned in school how DES works and I want to make an app that does this the way I learned it.</p>

<p>I managed to encrypt and decrypt (getting all kinds of weird symbols) but I never managed to decrypt my encrypted file. That's why I'm looking for a good example but can't seem to find one.</p>

<p>Do you know a good example project that does DES without using any built in libraries from the .NET framework? Or maybe you want to take a look at mine to see if you can spot what I'm doing wrong?</p>

<p>Any help would be appreciated, thanks!</p>

<p>Text I encrypt: Dit is een test om te kijken wat de uitkomst zal zijn!
Encrypted text:</p>

<pre><code>AÐ±§.ŒœwNÜúÈúÛü¿áX¯fMå©
MËà&gt;
¹ðLþa‚@šu
ñZ…U‚¬pÃ;¯        &lt;- white spaces (added block)
</code></pre>

<p>Decrypted text: <code>붿뿯붿塐뿯붿礷䨟ꛝ뿯榽뿯붿湵뿯⺽뿯綽붿뿯붿␤雟ḝ뿯厽㼆붿붿뿯붿붿뿯붿뿯梽뿯Ⓗ⭑붿붿뿯붿뿯붿뿯碽붿⁅</code>
Used password: <code>steutels van acht tekens</code></p>
","<p>There's a good <a href=""http://www.codeproject.com/Articles/91628/Simplified-version-of-the-DES-Data-Encryption-Stan"" rel=""nofollow"">article</a> on code project, that should have everything you need.</p>

<p>Here's the complete code from the article:</p>

<pre><code>namespace SDES_Project
{
    class SDES
    {
        BitArray[,] S_Box1 = new BitArray[4, 4];
        BitArray[,] S_Box2 = new BitArray[4, 4];
        BitArray Master_key;

        public SDES(string _key)
        {
            Master_key = new BitArray(10);

            for (int i = 0; i &lt; _key.Length; i++)
            {
                Master_key[i] = str2bin(_key[i]);
            }

            BitArray b0 = new BitArray(2);
            b0[0] = false;
            b0[1] = false;

            BitArray b1 = new BitArray(2);
            b1[0] = false;
            b1[1] = true;

            BitArray b2 = new BitArray(2);
            b2[0] = true;
            b2[1] = false;

            BitArray b3 = new BitArray(2);
            b3[0] = true;
            b3[1] = true;



            S_Box1[0, 0] = b1;
            S_Box1[0, 1] = b0;
            S_Box1[0, 2] = b3;
            S_Box1[0, 3] = b2;

            S_Box1[1, 0] = b3;
            S_Box1[1, 1] = b2;
            S_Box1[1, 2] = b1;
            S_Box1[1, 3] = b0;

            S_Box1[2, 0] = b0;
            S_Box1[2, 1] = b2;
            S_Box1[2, 2] = b1;
            S_Box1[2, 3] = b3;

            S_Box1[3, 0] = b3;
            S_Box1[3, 1] = b1;
            S_Box1[3, 2] = b3;
            S_Box1[3, 3] = b2;
            //---------------------
            S_Box2[0, 0] = b0;
            S_Box2[0, 1] = b1;
            S_Box2[0, 2] = b2;
            S_Box2[0, 3] = b3;

            S_Box2[1, 0] = b2;
            S_Box2[1, 1] = b0;
            S_Box2[1, 2] = b1;
            S_Box2[1, 3] = b3;

            S_Box2[2, 0] = b3;
            S_Box2[2, 1] = b0;
            S_Box2[2, 2] = b1;
            S_Box2[2, 3] = b0;

            S_Box2[3, 0] = b2;
            S_Box2[3, 1] = b1;
            S_Box2[3, 2] = b0;
            S_Box2[3, 3] = b3;
            //---------------------
        }

        public byte Encrypt(byte block)
        {
            BitArray bits_block = byte2bits(block);
            BitArray[] keys = Generate_Keys();
            return bits2byte(RIP(Fk(Switch(Fk(IP(bits_block), keys[0])), keys[1])));
            //ciphertext = IP-1( fK2 ( SW (fK1 (IP (plaintext)))))
        }

        public byte Decrypt(byte block)
        {
            BitArray bits_block = byte2bits(block);
            BitArray[] keys = Generate_Keys();

            return bits2byte(RIP(Fk(Switch(Fk(IP(bits_block), keys[1])), keys[0])));
            //IP-1 ( fK1( SW( fK2( IP(ciphertext)))))
        }

        BitArray byte2bits(byte block)
        {
            string bits = decimal2binstr(block);
            BitArray result = new BitArray(8);

            for (int i = 0; i &lt; bits.Length; i++)
            {
                result[i] = str2bin(bits[i]);
            }

            return result;
        }

        byte bits2byte(BitArray block)
        {
            string result = """";

            for (int i = 0; i &lt; block.Length; i++)
            {
                result += bin2str(block[i]);
            }

            return binstr2decimal(result);
        }

        BitArray[] Generate_Keys()
        {
            BitArray[] keys = new BitArray[2];
            BitArray[] temp = Split_Block(P10(Master_key));
            keys[0] = P8(Circular_left_shift(temp[0], 1), Circular_left_shift(temp[1], 1));
            keys[1] = P8(Circular_left_shift(temp[0], 3), Circular_left_shift(temp[1], 3)); //1 + 2 = 3
            return keys;
        }

        // decimal to binary string
        public string decimal2binstr(byte num)
        {
            string ret = """";
            for (int i = 0; i &lt; 8; i++)
            {
                if (num % 2 == 1)
                    ret = ""1"" + ret;
                else
                    ret = ""0"" + ret;
                num &gt;&gt;= 1;
            }
            return ret;
        }

        // binary to decimal string
        public byte binstr2decimal(string binstr)
        {
            byte ret = 0;
            for (int i = 0; i &lt; binstr.Length; i++)
            {
                ret &lt;&lt;= 1;
                if (binstr[i] == '1')
                    ret++;
            }
            return ret;
        }

        public string bin2str(bool input)
        {
            if (input)
                return ""1"";
            else
                return ""0"";
        }

        public bool str2bin(char bit)
        {
            if (bit == '0')
                return false;
            else if (bit == '1')
                return true;
            else
                throw new Exception(""Key should be in binary format [0,1]"");
        }

        //generates  permated array P10
        BitArray P10(BitArray key)
        {
            //0 1 2 3 4 5 6 7 8 9
            //2 4 1 6 3 9 0 8 7 5
            BitArray permutatedArray = new BitArray(10);

            permutatedArray[0] = key[2];
            permutatedArray[1] = key[4];
            permutatedArray[2] = key[1];
            permutatedArray[3] = key[6];
            permutatedArray[4] = key[3];
            permutatedArray[5] = key[9];
            permutatedArray[6] = key[0];
            permutatedArray[7] = key[8];
            permutatedArray[8] = key[7];
            permutatedArray[9] = key[5];

            return permutatedArray;
        }

        //generates permuted array P8
        BitArray P8(BitArray part1, BitArray part2)
        {
            //0 1 2 3 4 5 6 7
            //5 2 6 3 7 4 9 8
            //6 3 7 4 8 5 10 9
            BitArray permutatedArray = new BitArray(8);

            permutatedArray[0] = part2[0];//5
            permutatedArray[1] = part1[2];
            permutatedArray[2] = part2[1];//6
            permutatedArray[3] = part1[3];
            permutatedArray[4] = part2[2];//7
            permutatedArray[5] = part1[4];
            permutatedArray[6] = part2[4];//9
            permutatedArray[7] = part2[3];//8

            return permutatedArray;
        }

        BitArray P4(BitArray part1, BitArray part2)
        {
            //0 1 2 3
            //2 4 3 1
            //1 3 2 0
            BitArray permutatedArray = new BitArray(4);

            permutatedArray[0] = part1[1];
            permutatedArray[1] = part2[1];//3
            permutatedArray[2] = part2[0];//2
            permutatedArray[3] = part1[0];

            return permutatedArray;
        }

        BitArray EP(BitArray input)
        {
            //0 1 2 3
            //4 1 2 3 2 3 4 1
            //3 0 1 2 1 2 3 0
            BitArray permutatedArray = new BitArray(8);

            permutatedArray[0] = input[3];
            permutatedArray[1] = input[0];
            permutatedArray[2] = input[1];
            permutatedArray[3] = input[2];
            permutatedArray[4] = input[1];
            permutatedArray[5] = input[2];
            permutatedArray[6] = input[3];
            permutatedArray[7] = input[0];

            return permutatedArray;
        }

        //generates permuted text IP
        BitArray IP(BitArray plainText)
        {
            //0 1 2 3 4 5 6 7
            //1 5 2 0 3 7 4 6
            BitArray permutatedArray = new BitArray(8);

            permutatedArray[0] = plainText[1];
            permutatedArray[1] = plainText[5];
            permutatedArray[2] = plainText[2];
            permutatedArray[3] = plainText[0];
            permutatedArray[4] = plainText[3];
            permutatedArray[5] = plainText[7];
            permutatedArray[6] = plainText[4];
            permutatedArray[7] = plainText[6];

            return permutatedArray;
        }

        BitArray RIP(BitArray permutedText)
        {
            //0 1 2 3 4 5 6 7 
            //3 0 2 4 6 1 7 5

            BitArray permutatedArray = new BitArray(8);

            permutatedArray[0] = permutedText[3];
            permutatedArray[1] = permutedText[0];
            permutatedArray[2] = permutedText[2];
            permutatedArray[3] = permutedText[4];
            permutatedArray[4] = permutedText[6];
            permutatedArray[5] = permutedText[1];
            permutatedArray[6] = permutedText[7];
            permutatedArray[7] = permutedText[5];

            return permutatedArray;
        }

        BitArray Circular_left_shift(BitArray a, int bitNumber)
        {
            BitArray shifted = new BitArray(a.Length);
            int index = 0;

            for (int i = bitNumber; index &lt; a.Length; i++)
            {
                shifted[index++] = a[i % a.Length];
            }

            return shifted;
        }

        BitArray[] Split_Block(BitArray block)
        {
            BitArray[] splited = new BitArray[2];
            splited[0] = new BitArray(block.Length / 2);
            splited[1] = new BitArray(block.Length / 2);
            int index = 0;

            for (int i = 0; i &lt; block.Length / 2; i++)
            {
                splited[0][i] = block[i];
            }

            for (int i = block.Length / 2; i &lt; block.Length; i++)
            {
                splited[1][index++] = block[i];
            }

            return splited;
        }

        BitArray S_Boxes(BitArray input, int no)
        {
            BitArray[,] current_S_Box;

            if (no == 1)
                current_S_Box = S_Box1;
            else
                current_S_Box = S_Box2;

            return current_S_Box[binstr2decimal(bin2str(input[0]) + bin2str(input[3])),
                binstr2decimal(bin2str(input[1]) + bin2str(input[2]))];
        }

        BitArray F(BitArray right, BitArray sk)
        {
            BitArray[] temp = Split_Block(Xor(EP(right), sk));

            return P4(S_Boxes(temp[0], 1), S_Boxes(temp[1], 2));
        }

        BitArray Fk(BitArray IP, BitArray key)
        {
            BitArray[] temp = Split_Block(IP);
            BitArray Left = Xor(temp[0], F(temp[1], key));
            BitArray joined = new BitArray(8);
            int index = 0;

            for (int i = 0; i &lt; 4; i++)
            {
                joined[index++] = Left[i];
            }

            for (int i = 0; i &lt; 4; i++)
            {
                joined[index++] = temp[1][i];
            }

            return joined;
        }

        BitArray Switch(BitArray input)
        {
            BitArray switched = new BitArray(8);
            int index = 0;

            for (int i = 4; index &lt; input.Length; i++)
            {
                switched[index++] = input[i % input.Length];
            }

            return switched;
        }

        BitArray Xor(BitArray a, BitArray b)
        {
            return b.Xor(a);
        }
    }
}
</code></pre>
","6404","<c#><des>","0","1","1","2016-09-11 13:01:27","19344073","11","1","","","","2013-10-10 20:00:42",""
"22692109","WebRTC SRTP decryption","<p>I am trying to build an <code>SRTP</code> to <code>RTP</code> stream converter and I am having issues getting the <code>Master Key</code> from the <code>WebRTC peerconnection</code> I am creating. </p>

<p>From what I understand, with a <a href=""http://www.cisco.com/web/about/security/intelligence/securing-voip.html"">DES exchange</a>, the key is exchange via the <code>SDP</code> exchange and is shown in the <code>a=crypto</code> field. So, this situation seems pretty straight forward(please correct me if I am wrong), but ultimately useless as <code>WebRTC</code> standardization is now demanding that DES should not be used(only <code>Chrome</code> supports it now and it may be removed in the future).</p>

<p>For <a href=""https://tools.ietf.org/html/rfc4347#section-4.2"">DTLS</a> there is the fingerprint field in the <code>SDP</code>, is that a hash of the <a href=""https://www.ietf.org/proceedings/68/slides/rtpsec-0.pdf"">certificate desired</a> to be utilized in the future exchange?[EDIT: After doing some reading, I am thinking that that is not the case] I would think with knowledge of the fingerprint along side the ability to parse through the DTLS packets in the exchange I should be able to grab the <code>Master Key</code> to decode the SRTP stream, but I am hitting a wall as I do not know where to look or even 100% sure if it is possible. </p>

<p>So, in short, is it even feasible(without getting into the lower C++ API and creating my own implementation of <code>WebRTC</code>) to decode the <code>SRTP</code> feed that is created with a <code>WebRTC PeerConnection</code> in <code>Chrome</code> and <code>FireFox</code>(possibly through packet sniffing with the information gleaned from the <code>SDP</code> exchange)?[EDIT: depressingly, it seems that access to the private part of the key(aka, the master key) is not possible...please correct if I am wrong]</p>
","<p>I found 'SSL_export_keying_material'
Which can take a key from SSL mechanism (after DTLS handshake) and use it for SRTP.</p>

<p>I am not an expert, Just hitting the wall like you...</p>
","6040","<encryption><webrtc><rtp><des><dtls>","7","3","3","2015-08-22 21:42:00","24385249","2","4","1818849","","2014-03-27 16:43:18","2014-03-27 15:25:32",""
"22692109","WebRTC SRTP decryption","<p>I am trying to build an <code>SRTP</code> to <code>RTP</code> stream converter and I am having issues getting the <code>Master Key</code> from the <code>WebRTC peerconnection</code> I am creating. </p>

<p>From what I understand, with a <a href=""http://www.cisco.com/web/about/security/intelligence/securing-voip.html"">DES exchange</a>, the key is exchange via the <code>SDP</code> exchange and is shown in the <code>a=crypto</code> field. So, this situation seems pretty straight forward(please correct me if I am wrong), but ultimately useless as <code>WebRTC</code> standardization is now demanding that DES should not be used(only <code>Chrome</code> supports it now and it may be removed in the future).</p>

<p>For <a href=""https://tools.ietf.org/html/rfc4347#section-4.2"">DTLS</a> there is the fingerprint field in the <code>SDP</code>, is that a hash of the <a href=""https://www.ietf.org/proceedings/68/slides/rtpsec-0.pdf"">certificate desired</a> to be utilized in the future exchange?[EDIT: After doing some reading, I am thinking that that is not the case] I would think with knowledge of the fingerprint along side the ability to parse through the DTLS packets in the exchange I should be able to grab the <code>Master Key</code> to decode the SRTP stream, but I am hitting a wall as I do not know where to look or even 100% sure if it is possible. </p>

<p>So, in short, is it even feasible(without getting into the lower C++ API and creating my own implementation of <code>WebRTC</code>) to decode the <code>SRTP</code> feed that is created with a <code>WebRTC PeerConnection</code> in <code>Chrome</code> and <code>FireFox</code>(possibly through packet sniffing with the information gleaned from the <code>SDP</code> exchange)?[EDIT: depressingly, it seems that access to the private part of the key(aka, the master key) is not possible...please correct if I am wrong]</p>
","<p>tHere is some code using openssl and libsrtp native api</p>

<pre><code>#define SRTP_MASTER_KEY_KEY_LEN 16
#define SRTP_MASTER_KEY_SALT_LEN 14
static void dtls_srtp_init( struct transport_dtls *dtls )
{

/*
  When SRTP mode is in effect, different keys are used for ordinary
   DTLS record protection and SRTP packet protection.  These keys are
   generated using a TLS exporter [RFC5705] to generate

   2 * (SRTPSecurityParams.master_key_len +
        SRTPSecurityParams.master_salt_len) bytes of data

   which are assigned as shown below.  The per-association context value
   is empty.

   client_write_SRTP_master_key[SRTPSecurityParams.master_key_len];
   server_write_SRTP_master_key[SRTPSecurityParams.master_key_len];
   client_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];
   server_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];
*/
  int code;
  err_status_t     err;
  srtp_policy_t policy;
  char dtls_buffer[SRTP_MASTER_KEY_KEY_LEN * 2 + SRTP_MASTER_KEY_SALT_LEN * 2];
  char client_write_key[SRTP_MASTER_KEY_KEY_LEN + SRTP_MASTER_KEY_SALT_LEN];
  char server_write_key[SRTP_MASTER_KEY_KEY_LEN + SRTP_MASTER_KEY_SALT_LEN];
  size_t offset = 0;

  /*
   The exporter label for this usage is ""EXTRACTOR-dtls_srtp"".  (The
   ""EXTRACTOR"" prefix is for historical compatibility.)
   RFC 5764 4.2.  Key Derivation
  */
  const char * label = ""EXTRACTOR-dtls_srtp"";

  SRTP_PROTECTION_PROFILE * srtp_profile= SSL_get_selected_srtp_profile( dtls-&gt;ssl );

/* SSL_export_keying_material exports a value derived from the master secret,
 * as specified in RFC 5705. It writes |olen| bytes to |out| given a label and
 * optional context. (Since a zero length context is allowed, the |use_context|
 * flag controls whether a context is included.)
 *
 * It returns 1 on success and zero otherwise.
 */
  code = SSL_export_keying_material(dtls-&gt;ssl, 
                                    dtls_buffer, 
                                    sizeof(dtls_buffer),
                                    label, 
                                    strlen( label),
                                    NULL,
                                    0, 
                                    PJ_FALSE);

  memcpy(&amp;client_write_key[0], &amp;dtls_buffer[offset], SRTP_MASTER_KEY_KEY_LEN);
  offset += SRTP_MASTER_KEY_KEY_LEN;
  memcpy(&amp;server_write_key[0], &amp;dtls_buffer[offset], SRTP_MASTER_KEY_KEY_LEN);
  offset += SRTP_MASTER_KEY_KEY_LEN;
  memcpy(&amp;client_write_key[SRTP_MASTER_KEY_KEY_LEN], &amp;dtls_buffer[offset], SRTP_MASTER_KEY_SALT_LEN);
  offset += SRTP_MASTER_KEY_SALT_LEN;
  memcpy(&amp;server_write_key[SRTP_MASTER_KEY_KEY_LEN], &amp;dtls_buffer[offset], SRTP_MASTER_KEY_SALT_LEN); 

  switch( srtp_profile-&gt;id )
  {
  case SRTP_AES128_CM_SHA1_80:
    crypto_policy_set_aes_cm_128_hmac_sha1_80(&amp;policy.rtp);
    crypto_policy_set_aes_cm_128_hmac_sha1_80(&amp;policy.rtcp);
    break;
  case SRTP_AES128_CM_SHA1_32:
    crypto_policy_set_aes_cm_128_hmac_sha1_32(&amp;policy.rtp);   // rtp is 32,
    crypto_policy_set_aes_cm_128_hmac_sha1_80(&amp;policy.rtcp);  // rtcp still 80
    break;
  default:
    assert(0);
  }
  policy.ssrc.value = 0;
  policy.next = NULL;

  /* Init transmit direction */
  policy.ssrc.type = ssrc_any_outbound;  
  policy.key = client_write_key;    

  err = srtp_create(&amp;dtls-&gt;srtp_ctx_rx, &amp;policy);
  if (err != err_status_ok) {
    printf(""not working\n"");
  } 

  /* Init receive direction */
  policy.ssrc.type = ssrc_any_inbound;  
  policy.key = server_write_key;    

  err = srtp_create(&amp;dtls-&gt;srtp_ctx_tx, &amp;policy);
  if (err != err_status_ok) {
    printf(""not working\n"");
  } 

}
</code></pre>
","6040","<encryption><webrtc><rtp><des><dtls>","7","6","3","2015-08-22 21:42:00","24385249","2","4","1818849","","2014-03-27 16:43:18","2014-03-27 15:25:32",""
"22692109","WebRTC SRTP decryption","<p>I am trying to build an <code>SRTP</code> to <code>RTP</code> stream converter and I am having issues getting the <code>Master Key</code> from the <code>WebRTC peerconnection</code> I am creating. </p>

<p>From what I understand, with a <a href=""http://www.cisco.com/web/about/security/intelligence/securing-voip.html"">DES exchange</a>, the key is exchange via the <code>SDP</code> exchange and is shown in the <code>a=crypto</code> field. So, this situation seems pretty straight forward(please correct me if I am wrong), but ultimately useless as <code>WebRTC</code> standardization is now demanding that DES should not be used(only <code>Chrome</code> supports it now and it may be removed in the future).</p>

<p>For <a href=""https://tools.ietf.org/html/rfc4347#section-4.2"">DTLS</a> there is the fingerprint field in the <code>SDP</code>, is that a hash of the <a href=""https://www.ietf.org/proceedings/68/slides/rtpsec-0.pdf"">certificate desired</a> to be utilized in the future exchange?[EDIT: After doing some reading, I am thinking that that is not the case] I would think with knowledge of the fingerprint along side the ability to parse through the DTLS packets in the exchange I should be able to grab the <code>Master Key</code> to decode the SRTP stream, but I am hitting a wall as I do not know where to look or even 100% sure if it is possible. </p>

<p>So, in short, is it even feasible(without getting into the lower C++ API and creating my own implementation of <code>WebRTC</code>) to decode the <code>SRTP</code> feed that is created with a <code>WebRTC PeerConnection</code> in <code>Chrome</code> and <code>FireFox</code>(possibly through packet sniffing with the information gleaned from the <code>SDP</code> exchange)?[EDIT: depressingly, it seems that access to the private part of the key(aka, the master key) is not possible...please correct if I am wrong]</p>
","<p>It's not clear if this is your case, but note it's not possible to access the audio/video from (i.e.:unencrypt) the SRTP merely being a passive observer - that's the whole point of having transport encryption.</p>

<p>The protocol (DTLS-SRTP) works roughly like this:</p>

<ul>
<li>each browser has a unique keypair, usually generated on installation time</li>
<li>The <a href=""https://en.wikipedia.org/wiki/Public_key_fingerprint"" rel=""nofollow"">fingerprint of the public part of the keypair</a> of each side in included in the SDP, in the offer and answer.</li>
<li>Both ends negotiate a DTLS connection, through a <a href=""http://tools.ietf.org/html/rfc4347"" rel=""nofollow"">ordinary DTLS handshake</a>, thus deriving a kind of session key, which is used to secure the (DTLS) connection</li>
<li><a href=""https://tools.ietf.org/html/rfc5764#section-4.2"" rel=""nofollow"">The derived session key is used as the SRTP key</a></li>
</ul>

<p>If you don't have access to at least one of the private parts of the keypairs, it's not possible at all to decrypt the connection. If the endpoints choose to use a <a href=""https://en.wikipedia.org/wiki/Diffie-Hellman_key_exchange"" rel=""nofollow"">Diffie-Hellman key exchange</a> on the handshake, a passive attacker will not be able to get the derived key, even with access to both private keys. This property is called <a href=""https://en.wikipedia.org/wiki/Forward_secrecy"" rel=""nofollow"">forward secrecy</a>.</p>

<p>The only reliable way of accessing the SRTP contents is doing the handshake yourself, implementing a active MITM (changing the fingerprints on the SDP) or getting the private key from the browser and restricting DH key-exchange (which, AFAIK, is not possible at all)</p>
","6040","<encryption><webrtc><rtp><des><dtls>","7","3","3","2015-08-22 21:42:00","24385249","2","4","1818849","","2014-03-27 16:43:18","2014-03-27 15:25:32",""
"20921158","DES Decryption: Given final block not properly padded","<p>I'm trying to decrypt the content of a file bigger than 1k for a ""RETR"" action of an FTP Client and I'm encountering this kind of exception. </p>

<pre><code>   javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
at com.sun.crypto.provider.DESCipher.engineDoFinal(DESCipher.java:314)
at javax.crypto.Cipher.doFinal(Cipher.java:2145)
</code></pre>

<p>This is the code that is giving me problem:</p>

<pre><code>    byte[] encontent = new byte[0];
    byte[] buff = new byte[1024];
    int k = -1;
    while((k = bis.read(buff, 0, buff.length)) &gt; -1) {
    byte[] tbuff = new byte[encontent.length + k]; // temp buffer size = bytes already  read + bytes last read
    System.arraycopy(encontent, 0, tbuff, 0, encontent.length); // copy previous bytes
    System.arraycopy(buff, 0, tbuff, encontent.length, k);  // copy current lot
    encontent = tbuff; // call the temp buffer as your result buff
    }
     System.out.println(encontent.length + "" bytes read."");
     byte [] plain = dcipher.doFinal(encontent, 0,encontent.length);
</code></pre>

<p>The length of the byte array encontent is always an 8-bit multple, because it is the result of a previous encryption.</p>

<p>Here it's the code that starts the operation from server side:</p>

<pre><code>  public void download (String pathfile)
 {
       Socket DataSock = null;
    try {
            DataSock = new Socket (clientAddr, TRANSMISSION_PORT);
            if (DataSock.isConnected())
            {
                BufferedOutputStream bos = new BufferedOutputStream (DataSock.getOutputStream());
                int size=0;
                int blocks=0;
                int resto=0;
                if (pathfile.endsWith("".txt""))
                {
                    String text = readTxtFile (pathfile);
                    byte [] encontent = ecipher.doFinal(text.getBytes(""UTF8""));
                    sendFile (bos,encontent);
                } else {
                    byte [] content = readFile (pathfile);
                    byte [] encontent = ecipher.doFinal(content);
                    sendFile (bos, content);
                }
            }

    } catch (Exception e)
    {
        e.printStackTrace();
    } finally {
        try {
        DataSock.close();
    } catch (Exception e)
    {
        e.printStackTrace();
    }
    }
}
</code></pre>
","<p>The final block must contain 8 bytes. If it does not, one has to pad until its 8 bytes wide. Your assumption is wrong.
Have a look at <a href=""https://stackoverflow.com/a/10427679/867816"">https://stackoverflow.com/a/10427679/867816</a></p>
","5501","<java><encryption><des>","1","0","1","2014-01-21 10:03:20","20923105","2","1","3127365","","2014-01-21 10:03:20","2014-01-04 12:43:57",""
"12110459","Android DES Decrypt badpaddingexception: pad block corrupted","<p>First of all, I've reviewed all the entries on the forum, and I still can not find a solution to my problem.
I have to measure the time it takes to encode and decode a text with DES, and make a comparison with other algorithms. </p>

<p>When I run the code, I have this error: <strong>BadPaddingException: pad block corrupted</strong>. When I debug, the code fails in this line:</p>

<p>  <em>byte [] plaintext = cipher.doFinal (cipherBytes);</em></p>

<p>I use class Base64 to encode/decode String &lt;--> byte[]</p>

<p>Any idea?</p>

<p>thanks</p>

<pre><code>private static final String CIPHER_ALGORITHM = ""DES/ECB/PKCS5Padding"";
private static int KEY_LENGTH = 64;

 public static SecretKey deriveKeyDES() {
        try {
            long start = System.currentTimeMillis();

            KeyGenerator kgen = KeyGenerator.getInstance(""DES"");
            kgen.init(KEY_LENGTH);
            SecretKey result = kgen.generateKey();

            long elapsed = System.currentTimeMillis() - start;
            return result;

        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } 
    }


    public static String encrypt(String plaintext, SecretKey key) {
        try {

            long start = System.currentTimeMillis();
            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"")

            cipher.init(Cipher.ENCRYPT_MODE, key);

            byte[] cipherText = cipher.doFinal(plaintext.getBytes(""UTF-8""));

            long elapsed = System.currentTimeMillis() - start;

            return toBase64(cipherText);

        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static String toBase64(byte[] bytes) {
        return Base64.encodeToString(bytes, Base64.NO_WRAP).trim();
    }


    public static String decrypt(String ciphertext, SecretKey key) {
        try {
            byte[] cipherBytes = fromBase64(ciphertext);

                long start = System.currentTimeMillis();
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);

            cipher.init(Cipher.DECRYPT_MODE, key);
            cipher.update(cipherBytes);

             // This is where I get exception
            byte[] plaintext = cipher.doFinal(cipherBytes);

            String plainrStr = new String(plaintext, ""UTF-8"").trim();
            long elapsed = System.currentTimeMillis() - start;

            return plainrStr;
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static byte[] fromBase64(String base64) {
        return Base64.decode(base64, Base64.NO_WRAP);
    }
</code></pre>
","<pre><code>Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);

cipher.init(Cipher.DECRYPT_MODE, key);
cipher.update(cipherBytes);

// byte[] plaintext = cipher.doFinal(cipherBytes);
//                                   ^-- You shouldn't pass cipherBytes twice.
//                                   v-- instead use the parameter-less method:
byte[] plaintext    = cipher.doFinal();
</code></pre>
","5428","<android><encryption><des>","1","1","3","2017-07-25 15:45:24","","3","3","1622659","","2012-08-29 17:03:12","2012-08-24 13:33:29",""
"12110459","Android DES Decrypt badpaddingexception: pad block corrupted","<p>First of all, I've reviewed all the entries on the forum, and I still can not find a solution to my problem.
I have to measure the time it takes to encode and decode a text with DES, and make a comparison with other algorithms. </p>

<p>When I run the code, I have this error: <strong>BadPaddingException: pad block corrupted</strong>. When I debug, the code fails in this line:</p>

<p>  <em>byte [] plaintext = cipher.doFinal (cipherBytes);</em></p>

<p>I use class Base64 to encode/decode String &lt;--> byte[]</p>

<p>Any idea?</p>

<p>thanks</p>

<pre><code>private static final String CIPHER_ALGORITHM = ""DES/ECB/PKCS5Padding"";
private static int KEY_LENGTH = 64;

 public static SecretKey deriveKeyDES() {
        try {
            long start = System.currentTimeMillis();

            KeyGenerator kgen = KeyGenerator.getInstance(""DES"");
            kgen.init(KEY_LENGTH);
            SecretKey result = kgen.generateKey();

            long elapsed = System.currentTimeMillis() - start;
            return result;

        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } 
    }


    public static String encrypt(String plaintext, SecretKey key) {
        try {

            long start = System.currentTimeMillis();
            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"")

            cipher.init(Cipher.ENCRYPT_MODE, key);

            byte[] cipherText = cipher.doFinal(plaintext.getBytes(""UTF-8""));

            long elapsed = System.currentTimeMillis() - start;

            return toBase64(cipherText);

        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static String toBase64(byte[] bytes) {
        return Base64.encodeToString(bytes, Base64.NO_WRAP).trim();
    }


    public static String decrypt(String ciphertext, SecretKey key) {
        try {
            byte[] cipherBytes = fromBase64(ciphertext);

                long start = System.currentTimeMillis();
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);

            cipher.init(Cipher.DECRYPT_MODE, key);
            cipher.update(cipherBytes);

             // This is where I get exception
            byte[] plaintext = cipher.doFinal(cipherBytes);

            String plainrStr = new String(plaintext, ""UTF-8"").trim();
            long elapsed = System.currentTimeMillis() - start;

            return plainrStr;
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static byte[] fromBase64(String base64) {
        return Base64.decode(base64, Base64.NO_WRAP);
    }
</code></pre>
","<p>Padding exception occur when the last cipher text block does not compute to valid plain text. This would happen if last ciphertext block is corrupted or the key is incorrect. For CBC mode it would also happen if the second to last ciphertext was altered (but you are using ECB mode encryption).</p>

<p>In your case, the <code>deriveKeyDES()</code> is always generating a random key. Although we didn't get the actual calls to the security methods, I would <em>presume</em> you use a different key for encryption and decryption. In that case there is a very high chance that the resulting plain text does not contain valid padding bytes.</p>

<p>Rasmus answer certainly points to an error in your code, and it would screw up your timings and return a the plain text two times, but it would not remove the <code>BadPaddingException</code>.</p>
","5428","<android><encryption><des>","1","1","3","2017-07-25 15:45:24","","3","3","1622659","","2012-08-29 17:03:12","2012-08-24 13:33:29",""
"12110459","Android DES Decrypt badpaddingexception: pad block corrupted","<p>First of all, I've reviewed all the entries on the forum, and I still can not find a solution to my problem.
I have to measure the time it takes to encode and decode a text with DES, and make a comparison with other algorithms. </p>

<p>When I run the code, I have this error: <strong>BadPaddingException: pad block corrupted</strong>. When I debug, the code fails in this line:</p>

<p>  <em>byte [] plaintext = cipher.doFinal (cipherBytes);</em></p>

<p>I use class Base64 to encode/decode String &lt;--> byte[]</p>

<p>Any idea?</p>

<p>thanks</p>

<pre><code>private static final String CIPHER_ALGORITHM = ""DES/ECB/PKCS5Padding"";
private static int KEY_LENGTH = 64;

 public static SecretKey deriveKeyDES() {
        try {
            long start = System.currentTimeMillis();

            KeyGenerator kgen = KeyGenerator.getInstance(""DES"");
            kgen.init(KEY_LENGTH);
            SecretKey result = kgen.generateKey();

            long elapsed = System.currentTimeMillis() - start;
            return result;

        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } 
    }


    public static String encrypt(String plaintext, SecretKey key) {
        try {

            long start = System.currentTimeMillis();
            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"")

            cipher.init(Cipher.ENCRYPT_MODE, key);

            byte[] cipherText = cipher.doFinal(plaintext.getBytes(""UTF-8""));

            long elapsed = System.currentTimeMillis() - start;

            return toBase64(cipherText);

        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static String toBase64(byte[] bytes) {
        return Base64.encodeToString(bytes, Base64.NO_WRAP).trim();
    }


    public static String decrypt(String ciphertext, SecretKey key) {
        try {
            byte[] cipherBytes = fromBase64(ciphertext);

                long start = System.currentTimeMillis();
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);

            cipher.init(Cipher.DECRYPT_MODE, key);
            cipher.update(cipherBytes);

             // This is where I get exception
            byte[] plaintext = cipher.doFinal(cipherBytes);

            String plainrStr = new String(plaintext, ""UTF-8"").trim();
            long elapsed = System.currentTimeMillis() - start;

            return plainrStr;
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static byte[] fromBase64(String base64) {
        return Base64.decode(base64, Base64.NO_WRAP);
    }
</code></pre>
","<p>I had the same problem in one source code, and IllegalBlockSizeException in another one.
Solved this two problems by return encoding data like:</p>

<pre><code> public String encrypt(String input) {
    try {
        byte[] inputBytes = input.getBytes(""UTF-8"");
        byte[] enc = encryptCipher.doFinal(inputBytes);
        // and problem was in return encoding. That's how i fixed it 
        return Base64.encodeToString(enc,Base64.DEFAULT);
        .....
          }
        }
</code></pre>

<p>Give u a code for decrypt:</p>

<pre><code> public String decrypt(String input) {
    try {
        byte[] dec = Base64.decode(input.getBytes(), Base64.DEFAULT);
        //here had exception
        byte[] utf8 = decryptCipher.doFinal(dec);
        return new String(utf8,""UTF8"");
    } catch (IOException | BadPaddingException | IllegalBlockSizeException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>I should submit, that had BadPaddingException and IllegalBlockSizeException 
only in <em>decrypt method</em> <strong><em>byte[] utf8 = decryptCipher.doFinal(dec);</em></strong> (u had exeption in the same place: <strong><em>byte[] plaintext = cipher.doFinal(cipherBytes);</em></strong>), but real wrong is in <em>encrypt method(return value)</em> </p>

<p>That's why i recommend u to use that code in <em>encrypt method</em>:</p>

<pre><code>return Base64.encodeToString(enc,Base64.DEFAULT);
</code></pre>

<p>P.S Tried to a give full answer on your question.</p>
","5428","<android><encryption><des>","1","0","3","2017-07-25 15:45:24","","3","3","1622659","","2012-08-29 17:03:12","2012-08-24 13:33:29",""
"27805662","C code for Sbox in DES algorithm","<p>How to implement s-box for DES in c language?
i want to use array form creating the lookup table as the substitution table. and then call the function</p>

<p>the <strong><em>code</em></strong> i used is:-</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdint.h&gt;
int main()
{
uint32_t x,y,a,b,c,p,q;
int mask1=1;
int mask2=32;
printf(""enter any no.:"",x);
scanf(""%d"",&amp;x);
y=x&amp;mask1;
printf(""y=%d\n"",y);
a=x&amp;mask2;
printf(""a=%d\n"",a);
b=a&gt;&gt;4;
printf(""b=%d\n"",b);
c=y|b;
printf(""row no :%d\n"",c);
int mask3=0x1E;
p=x&amp;mask3;
printf(""p=%d\n"",p);
q=p&gt;&gt;1;
printf(""column no: %d\n"",q);
static const uint32_t s[4][16] =
{
  14,  0,  4, 15, 13,  7,  1,  4,  2, 14, 15,  2, 11, 13,  8,  1,
   3, 10, 10,  6,  6, 12, 12, 11,  5,  9,  9,  5,  0,  3,  7,  8,
   4, 15,  1, 12, 14,  8,  8,  2, 13,  4,  6,  9,  2,  1, 11,  7,
  15,  5, 12, 11,  9,  3,  7, 14,  3, 10, 10,  0,  5,  6,  0, 13};
int i,j;
{
printf(""SBox subsequent value[%d][%d]=%d\n"",c,q,s[c][q]);
}
return(0);
}
)
</code></pre>

<p>now i want to shorten the whole process by one line and call the function by reference. Please help.</p>
","<p>You can convert your program into a function:</p>

<pre><code>#include &lt;stdint.h&gt;
#define BIT(x)  ((1 &lt;&lt; x))
int sbox(int x) {
    static const uint32_t s[4][16] = {
      14,  0,  4, 15, 13,  7,  1,  4,  2, 14, 15,  2, 11, 13,  8,  1,
       3, 10, 10,  6,  6, 12, 12, 11,  5,  9,  9,  5,  0,  3,  7,  8,
       4, 15,  1, 12, 14,  8,  8,  2, 13,  4,  6,  9,  2,  1, 11,  7,
      15,  5, 12, 11,  9,  3,  7, 14,  3, 10, 10,  0,  5,  6,  0, 13
    };
    return (s[ (( x &amp; BIT(5))?2:0) | ( x &amp; BIT(0) ) ]   // c
            [(x &gt;&gt; 1) &amp; 0xf]);                          // q
}
</code></pre>

<p>But there's a flaw in the program, in that the indexing mechanism doesn't match the table organization.</p>

<p>I can take the original sbox1 code:</p>

<pre><code>#include &lt;stdint.h&gt;
static const uint32_t sbox1[64] = {
    14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7,
     0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8,
     4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0,
    15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13   
};
#define BIT(x)  (1 &lt;&lt; x)
#include &lt;stdio.h&gt;

int main() {
    int i;
    printf(""    static const uint32_t s[64] = {\n"");
    for (i = 0; i &lt; 64; i++) {
        if ((i &amp; 15 ) == 0) 
            printf(""       "");
        printf (""%3d%c"",
            sbox1[(( i &amp; BIT(5))?32:0) | ( i &amp; BIT(0)?16:0 ) |
              ((i &gt;&gt; 1) &amp; 0xf)], 
              (i &lt; 63)?',':' ');
        if ((i &amp; 15) == 15)
            printf(""\n"");
    }
    printf(""    };\n"");
    return (0);
}
</code></pre>

<p>And produce your table:</p>

<p>cc     sbox1.c   -o sbox1<br>
sbox1  </p>

<pre><code>static const uint32_t s[64] = {  
    14,  0,  4, 15, 13,  7,  1,  4,  2, 14, 15,  2, 11, 13,  8,  1,  
     3, 10, 10,  6,  6, 12, 12, 11,  5,  9,  9,  5,  0,  3,  7,  8,  
     4, 15,  1, 12, 14,  8,  8,  2, 13,  4,  6,  9,  2,  1, 11,  7,  
    15,  5, 12, 11,  9,  3,  7, 14,  3, 10, 10,  0,  5,  6,  0, 13  
};  
</code></pre>

<p>The give away here is that your table rows have duplicate values on them, something that doesn't occur in the DES standard.</p>

<p>So the little program sbox1 also demonstrates that the your sbox has been linearly indexed, meaning all I'd need to do in a program is <code>s[x]</code> to return the correct output, already indexed linearly.</p>

<p>And that says, assuming you make unique tables for the eight boxes, that it's not worth writing a function to call just for a straight table look up.</p>
","5311","<c><des>","-5","0","1","2015-01-15 04:35:09","","8","","3482140","","2015-01-06 19:41:18","2015-01-06 19:20:07",""
"23388756","ImportError: No module named pyDes","<p>I am trying to use DES and 3DES in python but when I tried to import pyDes I got this Error </p>

<p>ImportError: No module named pyDes</p>

<p>Why?</p>

<p><strong>UPDATE</strong></p>

<p>thank you </p>

<pre><code> from pyDes import *
    Message=(input(""Enter message""))
    key=(input(""Enter Key""))
    k = des(key, CBC, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)
    d = k.encrypt(message)
    print (""Encrypted: %r"" % d)
    print (""Decrypted: %r"" % k.decrypt(d))
</code></pre>

<p>when I run my code with this key 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
I got this error even though I'm sure it's 64 bit</p>

<pre><code>  k = des(key, CBC, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)
   File ""C:\Python32\lib\site-packages\pyDes.py"", line 400, in __init__
   raise ValueError(""Invalid DES key size. Key must be exactly 8 bytes long."")
   ValueError: Invalid DES key size. Key must be exactly 8 bytes long.
</code></pre>
","<p>Here is all you need: <a href=""http://twhiteman.netfirms.com/des.html"" rel=""nofollow"">http://twhiteman.netfirms.com/des.html</a>
If you need any more help you should state more information fe: what you tried to do so far?</p>
","5017","<python><python-3.x><des><3des>","0","1","1","2014-04-30 16:58:26","","2","","3464643","","2014-04-30 16:58:26","2014-04-30 12:58:32",""
"7862671","Decrypting DES with OpenSSL","<p>I'm trying to decrypt a DES-encrypted file from an external source with a known key and IV using OpenSSL (other libraries aren't really an option, as the application links against it already and I don't want to introduce new dependencies). It's a Qt application, so the data's coming in and out as QByteArrays.</p>

<p>Here's the code I have at the moment (set to write the decrypted data out to a file for inspection):</p>

<pre><code>AmzHandler::AmzHandler(QByteArray encoded)
{
    QByteArray encrypted = QByteArray::fromBase64(encoded);
    QByteArray decrypted = decrypt(encrypted);
    QFile fred (""decrypted"");
    fred.open(QFile::WriteOnly);
    fred.write(decrypted);
    fred.close();
}

QByteArray AmzHandler::decrypt(QByteArray encrypted)
{
    DES_cblock key = {0x29, 0xab, 0x9d, 0x18, 0xb2, 0x44, 0x9e, 0x31};
    DES_cblock iv = {0x5e, 0x72, 0xd7, 0x9a, 0x11, 0xb3, 0x4f, 0xee};
    DES_key_schedule schedule;
    unsigned char decrypted[encrypted.size()];

    DES_set_odd_parity(&amp;key);
    DES_set_key_checked(&amp;key, &amp;schedule);

    DES_ncbc_encrypt((unsigned char * )encrypted.constData(), (unsigned char * )decrypted, encrypted.size(), &amp;schedule, &amp;iv, DES_DECRYPT);

    return QByteArray::fromRawData((char * )decrypted, length);
}
</code></pre>

<p>The output file for my test input is nonsense, and is not consistent across multiple runs. (I have a working implementation in Python, which is attached at the bottom of this post, to test against.) I'm not really sure what's going on; whether I've made some simple screwup in the conversions to char or am misusing OpenSSL.</p>

<p>EDIT: Solved. It turns out the line <code>DES_set_odd_parity(&amp;key);</code> was missing. Add that and it works.</p>

<p>Here's working code in Python:</p>

<pre><code>def AmzHandler(encoded):
    encrypted = base64.b64decode(encoded)
    d = pyDes.des(hex_to_str(""29AB9D18B2449E31""), mode=pyDes.CBC, IV=hex_to_str(""5E72D79A11B34FEE""))
    decrypted = d.decrypt(encrypted)
    f = open(""decrypted-py"", ""w"")
    f.write(decrypted)
    f.close()
</code></pre>
","<p>The issue was just a missing call to <code>DES_set_odd_parity(&amp;key);</code>, which appears to be necessary for correct decoding with this implementation. Working code is as follows:</p>

<pre><code>QByteArray AmzHandler::decrypt(QByteArray encrypted)
{
    DES_cblock key = {0x29, 0xab, 0x9d, 0x18, 0xb2, 0x44, 0x9e, 0x31};
    DES_cblock iv = {0x5e, 0x72, 0xd7, 0x9a, 0x11, 0xb3, 0x4f, 0xee};
    DES_key_schedule schedule;
    unsigned char decrypted[encrypted.size()];

    DES_set_odd_parity(&amp;key);
    DES_set_key_checked(&amp;key, &amp;schedule);

    DES_ncbc_encrypt((unsigned char * )encrypted.constData(), (unsigned char * )decrypted, encrypted.size(), &amp;schedule, &amp;iv, DES_DECRYPT);

    return QByteArray::fromRawData((char * )decrypted, length);
}
</code></pre>
","4916","<c++><qt><openssl><des>","1","2","1","2011-10-26 22:23:00","7909659","7","1","326353","","2011-10-23 00:03:22","2011-10-22 21:16:58",""
"11375909","Encrypt/decrypt string with des cbc mode obj-c","<p>hi guys i'm pretty new in obj-c world and i would like know how can I encrypt a string in des? I already tried search but could not find any sample code that could help me the only thing I realized is that there is a class commonCrypt to do what I want but I do not know how to use it</p>

<p>my code</p>

<pre><code>NSString* key = @""abc43HU0"";
NSString *token = @""hellohello"";


const void *vplainText;
size_t plainTextBufferSize;

plainTextBufferSize = [token length];
vplainText = (const void *) [token UTF8String];

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t *movedBytes = NULL;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);
// memset((void *) iv, 0x0, (size_t) sizeof(iv));


//NSString *initVec = @""init Vec"";
const void *vkey = (const void *) [key UTF8String];
const void *vinitVec = (const void *) [key UTF8String];

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithmDES,
                   kCCModeCBC,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySizeDES,
                   vinitVec,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   movedBytes);

NSString *result;
NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

result = [myData base64encoding;

crypt_result.text = myData;
</code></pre>
","<p>Try <code>kCCOptionPKCS7Padding | kCCModeCBC</code> for ccOptions parameter.</p>
","4861","<objective-c><ios><encryption><des>","0","0","2","2012-07-10 08:08:28","11409103","6","0","1003884","","2012-07-07 20:43:19","2012-07-07 14:38:39",""
"11375909","Encrypt/decrypt string with des cbc mode obj-c","<p>hi guys i'm pretty new in obj-c world and i would like know how can I encrypt a string in des? I already tried search but could not find any sample code that could help me the only thing I realized is that there is a class commonCrypt to do what I want but I do not know how to use it</p>

<p>my code</p>

<pre><code>NSString* key = @""abc43HU0"";
NSString *token = @""hellohello"";


const void *vplainText;
size_t plainTextBufferSize;

plainTextBufferSize = [token length];
vplainText = (const void *) [token UTF8String];

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t *movedBytes = NULL;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);
// memset((void *) iv, 0x0, (size_t) sizeof(iv));


//NSString *initVec = @""init Vec"";
const void *vkey = (const void *) [key UTF8String];
const void *vinitVec = (const void *) [key UTF8String];

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithmDES,
                   kCCModeCBC,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySizeDES,
                   vinitVec,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   movedBytes);

NSString *result;
NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

result = [myData base64encoding;

crypt_result.text = myData;
</code></pre>
","<p>this is the working code:</p>

<pre><code>NSString* key = @""abc43HU0"";
NSString *token = @""hellohello"";

const void *vplainText;
size_t plainTextBufferSize = [token length];
vplainText = (const void *) [token UTF8String];    
CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;

bufferPtrSize = (plainTextBufferSize + kCCBlockSizeDES) &amp; ~(kCCBlockSizeDES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

Byte iv [] = {0x65, 0x110, 0x68, 0x26, 0x69, 0x178, 0x200, 0x219};

const void *vkey = (const void *) [key UTF8String];

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithmDES,
                   kCCOptionPKCS7Padding,
                   vkey, 
                   kCCKeySizeDES,
                   iv,
                   vplainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
NSString* result = [base64 base64EncodeData:myData];//my own method to encoding with base64
</code></pre>
","4861","<objective-c><ios><encryption><des>","0","2","2","2012-07-10 08:08:28","11409103","6","0","1003884","","2012-07-07 20:43:19","2012-07-07 14:38:39",""
"9979358","PyCrypto: Generate RSA key protected with DES3 password","<p>I have been able to create a RSA key protected by password with DES3 (well... <em>I think</em> because I'm very new to this encryption world) by using the command:</p>

<pre><code>openssl genrsa -out ""/tmp/myKey.pem"" -passout pass:""f00bar"" -des3 2048
</code></pre>

<p>Now, I would like to do that inside a Python script, using PyCrypto, if possible. I have seen <a href=""https://stackoverflow.com/questions/6897899/how-add-change-password-for-rsa-priv-key-using-pycrypto"">this message</a>, which seems to discourage the use of PyCrypto to do that. Is it still like that?</p>

<p>Of course I can always call <code>os.execute</code>, and execute the above command, but I'd consider that ""cheating"" <strong>:-)</strong>. I'm pretty much doing this to learn PyCrypto.</p>

<p>Thank you in advance.</p>
","<p>Starting from PyCrypto 2.5 you can export an RSA private key and have it protected under a passphrase. A Triple DES key is internally derived from the passphrase and used to perform the actual encryption.</p>

<p>For instance:</p>

<pre><code>from Crypto import RSA
from Crypto import Random

random_generator = Random.new().read
key = RSA.generate(1024, random_generator)
exportedKey = key.exportKey('PEM', 'my secret', pkcs=1)
</code></pre>

<p>The variable <code>exportedKey</code> contains an ASCII version (PEM) of the key, encoded according to PKCS#1 (a cryptographic standard. Another option is <code>pkcs=8</code> for - guess what - PKCS#8). Since the result is standard, you can use it with several other programs, including openssl.
And of course, you can also re-import it back into python via PyCrypto!</p>

<p>The <code>exportKey</code> method is documented <a href=""https://www.dlitz.net/software/pycrypto/api/current/Crypto.PublicKey.RSA._RSAobj-class.html#exportKey"" rel=""noreferrer"">here</a>.</p>
","4851","<python><encryption><rsa><des><pycrypto>","7","6","1","2012-04-02 19:56:33","9982832","0","4","-1","","2017-05-23 11:45:50","2012-04-02 15:39:58",""
"17796068","salt in DES crypt","<p>How does the system know for example in an svn environment, where the account is stored inside a .passwd using DES crypt hashing, if the entered password is correct.</p>

<p>Correct me If i'm wrong but if I convert a certain password for example ""test"" using DES hashing because of the salt there are many possibilities. How does the system (I image it just compares the generated hashes) than know that the entered password is correct?</p>
","<p>The salt is stored in plaintext, so to speak. It is there to prevent some kinds of attacks, but the salt is only some piece of public (although site-local) information that is catenated to the password before hashing.</p>

<p>So let us say that your password is “test” and you work at Cyberdyne. The administrator may have decided that the salt would be “Cyber”, so that the string that gets hashed though DES is “Cybertest”.</p>

<p>When you input the password “test”, it is added to the local salt again before applying DES, so that the result of salting+hashing matches the stored password.</p>

<p>If a smart guy (or gal) has built a <a href=""http://en.wikipedia.org/wiki/Rainbow_table"" rel=""noreferrer"">rainbow table</a> of the DES signatures of all dictionary words, he (or she) will not find your hashed password in it, because the crypted version is not DES(test), it is DES(cybertest).</p>
","4840","<hash><des>","2","6","2","2014-05-20 23:38:27","17796135","0","1","","","","2013-07-22 19:44:07",""
"17796068","salt in DES crypt","<p>How does the system know for example in an svn environment, where the account is stored inside a .passwd using DES crypt hashing, if the entered password is correct.</p>

<p>Correct me If i'm wrong but if I convert a certain password for example ""test"" using DES hashing because of the salt there are many possibilities. How does the system (I image it just compares the generated hashes) than know that the entered password is correct?</p>
","<p>This has been pretty well answered, but just thought I'd add some additional info with a practical example.</p>

<p>On most modern systems, the passwords are actually stored in a shadow file /etc/shadow (which is only readable by root), not in /etc/passwd.  As a simple exercise to see how it all actually works, try the following:  As root, view the line from the shadow file for your user record: </p>

<pre><code>cat /etc/shadow | grep yourusername
</code></pre>

<p>You will see something like this:</p>

<pre><code>yourusername:$1$TrOIigLp$PUHL00kS5UY3CMVaiC0/g0:15020:0:99999:7:::
</code></pre>

<p>After your username there is $1.  This indicates that it is an MD5 hash.  After that there is another $, then (in this case) <code>TrOIigLp</code> followed by another $.  TrOIigLp is the salt.  After that is the hashed password, which was hashed using the salt - in this case <code>PUHL00kS5UY3CMVaiC0/g0</code>.</p>

<p>Now, you can use openssl to hash your password using the same salt, like so:</p>

<pre><code> openssl passwd -1 -salt TrOIigLp
</code></pre>

<p>Enter your user password when prompted, the openssl command should compute the MD5 hash using the salt provided, and it should be exactly the same as the above from the shadow file.  The -1 in the above command is for MD5 hashing.</p>
","4840","<hash><des>","2","6","2","2014-05-20 23:38:27","17796135","0","1","","","","2013-07-22 19:44:07",""
"2727005","BitShifting with BigIntegers in Java","<p>I am implementing DES Encryption in Java with use of BigIntegers.</p>

<p>I am left shifting binary keys with Java BigIntegers by doing the BigInteger.leftShift(int n) method. Key of N (Kn) is dependent on the result of the shift of Kn-1.  The problem I am getting is that I am printing out the results after each key is generated and the shifting is not the expected out put.  The key is split in 2 Cn and Dn (left and right respectively).</p>

<p>I am specifically attempting this:
""To do a left shift, move each bit one place to the left, except for the first bit, which is cycled to the end of the block. ""</p>

<p>It seems to tack on O's on the end depending on the shift. Not sure how to go about correcting this.</p>

<p>Results:</p>

<p>c0: 11110101010100110011000011110</p>

<p>d0: 11110001111001100110101010100</p>

<p>c1: 111101010101001100110000111100</p>

<p>d1: 111100011110011001101010101000</p>

<p>c2: 11110101010100110011000011110000</p>

<p>d2: 11110001111001100110101010100000</p>

<p>c3: 1111010101010011001100001111000000</p>

<p>d3: 1111000111100110011010101010000000</p>

<p>c4: 111101010101001100110000111100000000</p>

<p>d4: 111100011110011001101010101000000000</p>

<p>c5: 11110101010100110011000011110000000000</p>

<p>d5: 11110001111001100110101010100000000000</p>

<p>c6: 1111010101010011001100001111000000000000</p>

<p>d6: 1111000111100110011010101010000000000000</p>

<p>c7: 111101010101001100110000111100000000000000</p>

<p>d7: 111100011110011001101010101000000000000000</p>

<p>c8: 1111010101010011001100001111000000000000000</p>

<p>d8: 1111000111100110011010101010000000000000000</p>

<p>c9: 111101010101001100110000111100000000000000000</p>

<p>d9: 111100011110011001101010101000000000000000000</p>

<p>c10:    11110101010100110011000011110000000000000000000</p>

<p>d10:    11110001111001100110101010100000000000000000000</p>

<p>c11:    1111010101010011001100001111000000000000000000000</p>

<p>d11:    1111000111100110011010101010000000000000000000000</p>

<p>c12:    111101010101001100110000111100000000000000000000000</p>

<p>d12:    111100011110011001101010101000000000000000000000000</p>

<p>c13:    11110101010100110011000011110000000000000000000000000</p>

<p>d13:    11110001111001100110101010100000000000000000000000000</p>

<p>c14:    1111010101010011001100001111000000000000000000000000000</p>

<p>d14:    1111000111100110011010101010000000000000000000000000000</p>

<p>c15:    11110101010100110011000011110000000000000000000000000000</p>

<p>d15:    11110001111001100110101010100000000000000000000000000000</p>
","<p>It seems that you need a <em>cyclic</em> left shift. <a href=""http://java.sun.com/javase/6/docs/api/java/math/BigInteger.html#shiftLeft%28int%29"" rel=""nofollow noreferrer""><code>BigInteger.shiftLeft</code></a> is not cyclic. You'd have to combine <code>shiftLeft</code>, <code>shiftRight</code>, <code>and</code> and <code>or</code>, just like you would if you were using <code>int</code> and <code>&lt;&lt;</code>.</p>

<pre><code>static BigInteger allOnes(int L) {
    return BigInteger.ZERO
        .setBit(L)
        .subtract(BigInteger.ONE);
}

static BigInteger cyclicLeftShift(BigInteger n, int L, int k) {
    return n.shiftLeft(k)
        .or(n.shiftRight(L - k))
        .and(allOnes(L));
}
</code></pre>

<p>Now, <code>cyclicLeftShift(n, L, k)</code> returns <code>n</code> cyclically-shifted <code>k</code> bits to the left, where the cycle window is <code>L</code>.</p>

<p>How this works is as follows:</p>

<pre><code>                               _________L__________
                              /                    \
n :                           [ABCDE][FG...........]
                              \__k__/\_____L-k_____/



n.shiftLeft(k) :       [ABCDE][FG...........][00000]
   .or
n.shiftRight(L - k) :                        [ABCDE]

   =                   [ABCDE][FG...........][ABCDE]

                               _________L__________
   .and                       /                    \
allOnes(L) :                  [111..............111]

   =                          [FG...........][ABCDE]
</code></pre>

<h3>See also</h3>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/Circular_shift"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Circular_shift</a></li>
</ul>

<hr>

<p><em>Note</em>: if you have a fixed <code>L</code>, you can optimize this a bit by caching <code>allOnes(L)</code> instead of computing it every time.</p>
","4813","<java><encryption><key><biginteger><des>","7","4","4","2010-05-21 01:20:21","","0","1","","","","2010-04-28 05:20:15",""
"2727005","BitShifting with BigIntegers in Java","<p>I am implementing DES Encryption in Java with use of BigIntegers.</p>

<p>I am left shifting binary keys with Java BigIntegers by doing the BigInteger.leftShift(int n) method. Key of N (Kn) is dependent on the result of the shift of Kn-1.  The problem I am getting is that I am printing out the results after each key is generated and the shifting is not the expected out put.  The key is split in 2 Cn and Dn (left and right respectively).</p>

<p>I am specifically attempting this:
""To do a left shift, move each bit one place to the left, except for the first bit, which is cycled to the end of the block. ""</p>

<p>It seems to tack on O's on the end depending on the shift. Not sure how to go about correcting this.</p>

<p>Results:</p>

<p>c0: 11110101010100110011000011110</p>

<p>d0: 11110001111001100110101010100</p>

<p>c1: 111101010101001100110000111100</p>

<p>d1: 111100011110011001101010101000</p>

<p>c2: 11110101010100110011000011110000</p>

<p>d2: 11110001111001100110101010100000</p>

<p>c3: 1111010101010011001100001111000000</p>

<p>d3: 1111000111100110011010101010000000</p>

<p>c4: 111101010101001100110000111100000000</p>

<p>d4: 111100011110011001101010101000000000</p>

<p>c5: 11110101010100110011000011110000000000</p>

<p>d5: 11110001111001100110101010100000000000</p>

<p>c6: 1111010101010011001100001111000000000000</p>

<p>d6: 1111000111100110011010101010000000000000</p>

<p>c7: 111101010101001100110000111100000000000000</p>

<p>d7: 111100011110011001101010101000000000000000</p>

<p>c8: 1111010101010011001100001111000000000000000</p>

<p>d8: 1111000111100110011010101010000000000000000</p>

<p>c9: 111101010101001100110000111100000000000000000</p>

<p>d9: 111100011110011001101010101000000000000000000</p>

<p>c10:    11110101010100110011000011110000000000000000000</p>

<p>d10:    11110001111001100110101010100000000000000000000</p>

<p>c11:    1111010101010011001100001111000000000000000000000</p>

<p>d11:    1111000111100110011010101010000000000000000000000</p>

<p>c12:    111101010101001100110000111100000000000000000000000</p>

<p>d12:    111100011110011001101010101000000000000000000000000</p>

<p>c13:    11110101010100110011000011110000000000000000000000000</p>

<p>d13:    11110001111001100110101010100000000000000000000000000</p>

<p>c14:    1111010101010011001100001111000000000000000000000000000</p>

<p>d14:    1111000111100110011010101010000000000000000000000000000</p>

<p>c15:    11110101010100110011000011110000000000000000000000000000</p>

<p>d15:    11110001111001100110101010100000000000000000000000000000</p>
","<p>BigInteger implements infinite-precision integers, so shifting to the left will keep adding zeros to the left.  You need a rotate:</p>

<pre><code>private static BigInteger rotateLeft(BigInteger bi) {
    BigInteger ret = bi.shiftLeft(1);
    if (ret.testBit(32)) {
        ret = ret.clearBit(32).setBit(0);
    }
    return ret;
}
</code></pre>

<p>That's going to be rather inefficient for 32-bit numbers, so you might as well just use primitives to rotate DES' 28-bit halves.  I'm not familiar with the DES algorithm, so I'll assume you need BigInteger for something else.</p>

<pre><code>private static BigInteger rotateLeftPrimitive(BigInteger bi) {
    int value = bi.intValue();
    return BigInteger.valueOf(((value &lt;&lt; 1) &amp; 0xffffffe) | ((value &gt;&gt;&gt; 27) &amp; 1));
}
</code></pre>
","4813","<java><encryption><key><biginteger><des>","7","10","4","2010-05-21 01:20:21","","0","1","","","","2010-04-28 05:20:15",""
"2727005","BitShifting with BigIntegers in Java","<p>I am implementing DES Encryption in Java with use of BigIntegers.</p>

<p>I am left shifting binary keys with Java BigIntegers by doing the BigInteger.leftShift(int n) method. Key of N (Kn) is dependent on the result of the shift of Kn-1.  The problem I am getting is that I am printing out the results after each key is generated and the shifting is not the expected out put.  The key is split in 2 Cn and Dn (left and right respectively).</p>

<p>I am specifically attempting this:
""To do a left shift, move each bit one place to the left, except for the first bit, which is cycled to the end of the block. ""</p>

<p>It seems to tack on O's on the end depending on the shift. Not sure how to go about correcting this.</p>

<p>Results:</p>

<p>c0: 11110101010100110011000011110</p>

<p>d0: 11110001111001100110101010100</p>

<p>c1: 111101010101001100110000111100</p>

<p>d1: 111100011110011001101010101000</p>

<p>c2: 11110101010100110011000011110000</p>

<p>d2: 11110001111001100110101010100000</p>

<p>c3: 1111010101010011001100001111000000</p>

<p>d3: 1111000111100110011010101010000000</p>

<p>c4: 111101010101001100110000111100000000</p>

<p>d4: 111100011110011001101010101000000000</p>

<p>c5: 11110101010100110011000011110000000000</p>

<p>d5: 11110001111001100110101010100000000000</p>

<p>c6: 1111010101010011001100001111000000000000</p>

<p>d6: 1111000111100110011010101010000000000000</p>

<p>c7: 111101010101001100110000111100000000000000</p>

<p>d7: 111100011110011001101010101000000000000000</p>

<p>c8: 1111010101010011001100001111000000000000000</p>

<p>d8: 1111000111100110011010101010000000000000000</p>

<p>c9: 111101010101001100110000111100000000000000000</p>

<p>d9: 111100011110011001101010101000000000000000000</p>

<p>c10:    11110101010100110011000011110000000000000000000</p>

<p>d10:    11110001111001100110101010100000000000000000000</p>

<p>c11:    1111010101010011001100001111000000000000000000000</p>

<p>d11:    1111000111100110011010101010000000000000000000000</p>

<p>c12:    111101010101001100110000111100000000000000000000000</p>

<p>d12:    111100011110011001101010101000000000000000000000000</p>

<p>c13:    11110101010100110011000011110000000000000000000000000</p>

<p>d13:    11110001111001100110101010100000000000000000000000000</p>

<p>c14:    1111010101010011001100001111000000000000000000000000000</p>

<p>d14:    1111000111100110011010101010000000000000000000000000000</p>

<p>c15:    11110101010100110011000011110000000000000000000000000000</p>

<p>d15:    11110001111001100110101010100000000000000000000000000000</p>
","<p>Addressing the bigger question 1) DES is broken and should never be used for anything other than working with legacy systems, 2) the Sun JCE already provides an implementation (as does BouncyCastle and other crypto providers), and 3) implementing any crypto algorithm is challenging and you really want to go with a well-tested implementation for production use.</p>

<p>If it's a class exercise I would use a byte[] instead of a BigInteger.  You'll need to do a little bit more by hand but it's a lot closer to the spirit of DES since it was designed to be easily implemented in hardware.</p>
","4813","<java><encryption><key><biginteger><des>","7","1","4","2010-05-21 01:20:21","","0","1","","","","2010-04-28 05:20:15",""
"2727005","BitShifting with BigIntegers in Java","<p>I am implementing DES Encryption in Java with use of BigIntegers.</p>

<p>I am left shifting binary keys with Java BigIntegers by doing the BigInteger.leftShift(int n) method. Key of N (Kn) is dependent on the result of the shift of Kn-1.  The problem I am getting is that I am printing out the results after each key is generated and the shifting is not the expected out put.  The key is split in 2 Cn and Dn (left and right respectively).</p>

<p>I am specifically attempting this:
""To do a left shift, move each bit one place to the left, except for the first bit, which is cycled to the end of the block. ""</p>

<p>It seems to tack on O's on the end depending on the shift. Not sure how to go about correcting this.</p>

<p>Results:</p>

<p>c0: 11110101010100110011000011110</p>

<p>d0: 11110001111001100110101010100</p>

<p>c1: 111101010101001100110000111100</p>

<p>d1: 111100011110011001101010101000</p>

<p>c2: 11110101010100110011000011110000</p>

<p>d2: 11110001111001100110101010100000</p>

<p>c3: 1111010101010011001100001111000000</p>

<p>d3: 1111000111100110011010101010000000</p>

<p>c4: 111101010101001100110000111100000000</p>

<p>d4: 111100011110011001101010101000000000</p>

<p>c5: 11110101010100110011000011110000000000</p>

<p>d5: 11110001111001100110101010100000000000</p>

<p>c6: 1111010101010011001100001111000000000000</p>

<p>d6: 1111000111100110011010101010000000000000</p>

<p>c7: 111101010101001100110000111100000000000000</p>

<p>d7: 111100011110011001101010101000000000000000</p>

<p>c8: 1111010101010011001100001111000000000000000</p>

<p>d8: 1111000111100110011010101010000000000000000</p>

<p>c9: 111101010101001100110000111100000000000000000</p>

<p>d9: 111100011110011001101010101000000000000000000</p>

<p>c10:    11110101010100110011000011110000000000000000000</p>

<p>d10:    11110001111001100110101010100000000000000000000</p>

<p>c11:    1111010101010011001100001111000000000000000000000</p>

<p>d11:    1111000111100110011010101010000000000000000000000</p>

<p>c12:    111101010101001100110000111100000000000000000000000</p>

<p>d12:    111100011110011001101010101000000000000000000000000</p>

<p>c13:    11110101010100110011000011110000000000000000000000000</p>

<p>d13:    11110001111001100110101010100000000000000000000000000</p>

<p>c14:    1111010101010011001100001111000000000000000000000000000</p>

<p>d14:    1111000111100110011010101010000000000000000000000000000</p>

<p>c15:    11110101010100110011000011110000000000000000000000000000</p>

<p>d15:    11110001111001100110101010100000000000000000000000000000</p>
","<p>I think your idea of implementing DES using bit strings is reasonable as an educational tool. Instead of directly using BigIntegers to represent these bitstrings, I recommend you create a BitString class that implements exactly those bit string methods you need for your project. Inside the BitString class, you can use BigIntegers, but you may find that a simple int array with 1 bit per array element is just as easy or easier, or maybe a linked list.</p>
","4813","<java><encryption><key><biginteger><des>","7","0","4","2010-05-21 01:20:21","","0","1","","","","2010-04-28 05:20:15",""
"6107288","DES decryption error ""Bad Data"" in C# when closing cryptostream","<p>I try to decrypt an  encrypted byte array (encrypt with K1 and decrypt with K2). Visual Studio throws an exception ""BAD DATA"" when it tries to close my crypto stream</p>

<p>here's my code snippet of DES decryption</p>

<pre><code>public Byte[] Decrypt(Byte[] cipherData, Byte[] key, Byte[] iv)
    {
        MemoryStream ms = new MemoryStream();
        DES mDES = DES.Create();
        mDES.Key = key;
        mDES.IV = iv;
        mDES.Padding = PaddingMode.PKCS7;
        CryptoStream cs = new CryptoStream(ms, mDES.CreateDecryptor(), CryptoStreamMode.Write);
        cs.Write(cipherData, 0, cipherData.Length);
        cs.Close();
        Byte[] decryptedData = ms.ToArray();
        return decryptedData;
    }
</code></pre>

<p>the initial vector is the same as encryption. I don't know why this error occurred. </p>

<p><em><strong>Added:</em></strong>
As recommended by Greg B, I post here my code snippet of encryption. The output of encryption is the input of decryption (two different keys)</p>

<pre><code>        public Byte[] Decrypt(Byte[] cipherData, Byte[] key, Byte[] iv)
    {
        MemoryStream ms = new MemoryStream();
        DES mDES = DES.Create();
        mDES.Key = key;
        mDES.IV = iv;
        mDES.Padding = PaddingMode.PKCS7;
        CryptoStream cs = new CryptoStream(ms, mDES.CreateDecryptor(), CryptoStreamMode.Write);
        cs.Write(cipherData, 0, cipherData.Length);
        cs.Close();
        Byte[] decryptedData = ms.ToArray();
        return decryptedData;
    }
</code></pre>
","<p>the problem you encountered comes from the selected padding mode.</p>

<p>since padding is used when decrypting your cipher text the cryptostream tries to remove the padding when your retrieve the decrypted bytes. since you don't use the key the data was encrypted with, you will get ""garbage"" ... the cryptostream fails to detect the padding that needs to be removed, and the operation fails with the observed exception.</p>

<p>if you want to rebuld someething like 3DES with the DES class use PaddingMode NONE for your decryption and the following encryption step (so only the first encryption or the last decryption uses padding)</p>
","4772","<c#><.net><encryption><des>","1","3","1","2011-05-28 11:15:27","","7","","493942","","2011-05-24 08:11:45","2011-05-24 07:49:50",""
"14587311","DES algorithm java code using string as input","<p>I am in search of Java implementation of the DES algorithm where I want a string as input. Can anybody guide me where to find it?</p>
","<p>As @m0skit0 pointed out, you need <code>inputString.getBytes()</code>, here is a sample code link also <a href=""http://java-espresso.blogspot.com/2011/09/des-algorithm-code-in-java.html"" rel=""nofollow"">http://java-espresso.blogspot.com/2011/09/des-algorithm-code-in-java.html</a></p>
","4752","<java><algorithm><des>","0","1","1","2013-01-29 16:23:10","14587387","4","0","","","","2013-01-29 16:18:42","2013-01-29 20:14:41"
"21684733","C# Decrypt bytes from SQL Server EncryptByPassPhrase?","<p>Following <a href=""https://stackoverflow.com/questions/13617807/replicate-t-sql-decryptbypassphrase-in-c-sharp"">Replicate T-SQL DecryptByPassPhrase in C#</a>, I am unable to get a simple encryption with MSSQL to descrypt in C#. The encrypted values in certain columns is necessary because the table is exported into Excel and Access on a regular basis so simple encryption is more than enough to ""block"" values  without having to involve developers to (re)do views, etc.</p>

<p>In SQL Server 2012:</p>

<pre><code>    select EncryptByPassPhrase( N'hello' , N'world'  ) 
-- returns 0x01000000AA959FFB3A8E4B06B734051437E198C8B72000A058ACE91D617123DA102287EB
</code></pre>

<p>In C#:</p>

<pre><code>byte[] buf = System.Text.Encoding.UTF8.GetBytes( ""0x010000003A95FA870ED699A5F90D33C2BF01491D9132F61BA162998E96F37117AF5DA0905D51EB6FB298EC88"" );
// bytes emitted from the database
var cp = new TripleDESCryptoServiceProvider();
var m = new MemoryStream(buf);
cp.Key = System.Text.Encoding.UTF8.GetBytes( ""hello"" ); // throws
cp.IV = System.Text.Encoding.UTF8.GetBytes( ""hello"" ); // throws
CryptoStream cs = new CryptoStream( m , cp.CreateDecryptor( cp.Key , cp.IV ) , CryptoStreamMode.Read );
StreamReader reader = new StreamReader( cs );
string plainText = reader.ReadToEnd();
</code></pre>

<p>What should working C# code look like?</p>

<p>Thanks.</p>
","<p>I believe the link you are following is suggesting a new way to encrypt and decrypt mimicking that of how the SQL EncryptByPassPhrase is made. So, you could only use the decrypt in C#, if you encrypted in C# as well.</p>

<p>Since, you already used EncryptByPassPhrase in SQL then I would suggest just using DecryptByPassPhrase in SQL before passing to C# code.</p>

<p>Example of your hello world encrypt and decrypt:</p>

<pre><code>Declare @lEncryptedText VARBINARY(256) = (select ENCRYPTBYPASSPHRASE('hello','world'))
SELECT @lEncryptedText --Encrypted VALUE for world

SELECT CONVERT(VARCHAR(100),DECRYPTBYPASSPHRASE('hello',@lEncryptedText)) --Decrypted Value
</code></pre>
","4703","<sql-server><encryption><des><cryptostream>","4","1","2","2018-08-10 23:11:25","","1","1","-1","","2017-05-23 11:43:26","2014-02-10 18:07:09",""
"21684733","C# Decrypt bytes from SQL Server EncryptByPassPhrase?","<p>Following <a href=""https://stackoverflow.com/questions/13617807/replicate-t-sql-decryptbypassphrase-in-c-sharp"">Replicate T-SQL DecryptByPassPhrase in C#</a>, I am unable to get a simple encryption with MSSQL to descrypt in C#. The encrypted values in certain columns is necessary because the table is exported into Excel and Access on a regular basis so simple encryption is more than enough to ""block"" values  without having to involve developers to (re)do views, etc.</p>

<p>In SQL Server 2012:</p>

<pre><code>    select EncryptByPassPhrase( N'hello' , N'world'  ) 
-- returns 0x01000000AA959FFB3A8E4B06B734051437E198C8B72000A058ACE91D617123DA102287EB
</code></pre>

<p>In C#:</p>

<pre><code>byte[] buf = System.Text.Encoding.UTF8.GetBytes( ""0x010000003A95FA870ED699A5F90D33C2BF01491D9132F61BA162998E96F37117AF5DA0905D51EB6FB298EC88"" );
// bytes emitted from the database
var cp = new TripleDESCryptoServiceProvider();
var m = new MemoryStream(buf);
cp.Key = System.Text.Encoding.UTF8.GetBytes( ""hello"" ); // throws
cp.IV = System.Text.Encoding.UTF8.GetBytes( ""hello"" ); // throws
CryptoStream cs = new CryptoStream( m , cp.CreateDecryptor( cp.Key , cp.IV ) , CryptoStreamMode.Read );
StreamReader reader = new StreamReader( cs );
string plainText = reader.ReadToEnd();
</code></pre>

<p>What should working C# code look like?</p>

<p>Thanks.</p>
","<p>SQL Server 2017 uses SHA256 hashing of password + AES-256 encryption</p>

<p>Older versions use SHA1 hashing of password + 3DES-128 encryption</p>

<p>IV size is the same as block size: AES = 128 bits, 3DES = 64 bits</p>

<p>Padding mode: PKCS #7
Cipher mode: CBC</p>

<p>Data encrypted by server 2017 starts with ""0x02"", older versions start with ""0x01"".</p>

<pre><code>// Example decrypt:
// UInt32 - ""magic"" (0xbaadf00d): 0d f0 ad ba
// UInt16 - unknown (always zero): 00 00
// UInt16 - decrypted data length (16): 10 00
// byte[] - decrypted data: 4c 65 74 54 68 65 53 75 6e 53 68 69 6e 69 6e 67

DecryptCombined(""0x02000000266AD4F387FA9474E825B013B0232E73A398A5F72B79BC90D63BD1E45AE3AA5518828D187125BECC285D55FA7CAFED61"", ""Radames"");
DecryptCombined(""0x010000007854E155CEE338D5E34808BA95367D506B97C63FB5114DD4CE687FE457C1B5D5"", ""banana"");


void DecryptCombined(string FromSql, string Password)
{
    // Encode password as UTF16-LE
    byte[] passwordBytes = Encoding.Unicode.GetBytes(Password);

    // Remove leading ""0x""
    FromSql = FromSql.Substring(2);

    int version = BitConverter.ToInt32(StringToByteArray(FromSql.Substring(0, 8)), 0);
    byte[] encrypted = null;

    HashAlgorithm hashAlgo = null;
    SymmetricAlgorithm cryptoAlgo = null;
    int keySize = (version == 1 ? 16 : 32);

    if (version == 1)
    {
        hashAlgo = SHA1.Create();
        cryptoAlgo = TripleDES.Create();
        cryptoAlgo.IV = StringToByteArray(FromSql.Substring(8, 16));
        encrypted = StringToByteArray(FromSql.Substring(24));
    }
    else if (version == 2)
    {
        hashAlgo = SHA256.Create();
        cryptoAlgo = Aes.Create();
        cryptoAlgo.IV = StringToByteArray(FromSql.Substring(8, 32));
        encrypted = StringToByteArray(FromSql.Substring(40));
    }
    else
    {
        throw new Exception(""Unsupported encryption"");
    }

    cryptoAlgo.Padding = PaddingMode.PKCS7;
    cryptoAlgo.Mode = CipherMode.CBC;

    hashAlgo.TransformFinalBlock(passwordBytes, 0, passwordBytes.Length);
    cryptoAlgo.Key = hashAlgo.Hash.Take(keySize).ToArray();

    byte[] decrypted = cryptoAlgo.CreateDecryptor().TransformFinalBlock(encrypted, 0, encrypted.Length);
    int decryptLength = BitConverter.ToInt16(decrypted, 6);
    UInt32 magic = BitConverter.ToUInt32(decrypted, 0);
    if (magic != 0xbaadf00d)
    {
        throw new Exception(""Decrypt failed"");
    }

    byte[] decryptedData = decrypted.Skip(8).ToArray();
    bool isUtf16 = (Array.IndexOf(decryptedData, (byte)0) != -1);
    string decryptText = (isUtf16 ? Encoding.Unicode.GetString(decryptedData) : Encoding.UTF8.GetString(decryptedData));

    Console.WriteLine(""Result: {0}"", decryptText);
}

// Method taken from https://stackoverflow.com/questions/321370/how-can-i-convert-a-hex-string-to-a-byte-array?answertab=votes#tab-top
public static byte[] StringToByteArray(string hex)
{
    return Enumerable.Range(0, hex.Length)
                     .Where(x =&gt; x % 2 == 0)
                     .Select(x =&gt; Convert.ToByte(hex.Substring(x, 2), 16))
                     .ToArray();
}
</code></pre>
","4703","<sql-server><encryption><des><cryptostream>","4","11","2","2018-08-10 23:11:25","","1","1","-1","","2017-05-23 11:43:26","2014-02-10 18:07:09",""
"22858497","Edit code sample to specify DES key value","<p>I have a working code example that uses DES (see below), but I want to specify the key data to use. How can I edit the code sample to do this?</p>

<pre><code>import java.security.InvalidKeyException;  
import java.security.NoSuchAlgorithmException;    
import javax.crypto.BadPaddingException;  
import javax.crypto.Cipher;  
import javax.crypto.IllegalBlockSizeException;  
import javax.crypto.KeyGenerator;  
import javax.crypto.NoSuchPaddingException;  
import javax.crypto.SecretKey;

public class DESEncryptionDecryption {

private static Cipher encryptCipher;  
private static Cipher decryptCipher; 
public static void main(String[] args) {  
try {
KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");  
SecretKey secretKey = keygenerator.generateKey();  

encryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");  
encryptCipher.init(Cipher.ENCRYPT_MODE, secretKey);  
byte[] encryptedData = encryptData(""Classified Information!"");  

decryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");  
decryptCipher.init(Cipher.DECRYPT_MODE, secretKey);  
decryptData(encryptedData);
}}}
</code></pre>
","<p>Do not use a <code>KeyGenerator</code>, use a <code>SecretKeyFactory</code>:</p>

<pre><code>String desKey = ""0123456789abcdef""; // value from user  
byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);

SecretKeyFactory factory = SecretKeyFactory.getInstance(""DES"");
SecretKey key = factory.generateSecret(new DESKeySpec(keyBytes));
</code></pre>

<p>Note that DES is not a secure algorithm. Consider using AES or Triple DES (DESede).</p>

<hr>

<p>For DESede:</p>

<pre><code>String desKey = ""0123456789abcdef0123456789abcdef0123456789abcdef""; // user value (24 bytes)  
byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);

SecretKeyFactory factory = SecretKeyFactory.getInstance(""DESede"");
SecretKey key = factory.generateSecret(new DESedeKeySpec(keyBytes));
</code></pre>

<hr>

<p>For AES, just do:</p>

<pre><code>String aesKey = ""0123456789abcdef0123456789abcdef""; // user value (16/24/32 bytes)
byte[] keyBytes = DatatypeConverter.parseHexBinary(aesKey);
SecretKey key = new SecretKeySpec(keyBytes, ""AES""); 
</code></pre>
","4532","<java><security><encryption><key><des>","1","1","1","2014-04-08 07:18:00","22859612","2","2","474189","","2014-04-04 10:05:33","2014-04-04 09:15:48",""
"29831300","Convert DESede/ECB/NoPadding algorithm written in java into Nodejs using crypto module","<p>I am working on migration of code form java to Nodejs. I have one requirement to encrypt the text with private key using ""DESede/ECB/NoPadding"" algorithm. Currently code is written in Java and now I need to migrate to Nodejs. Since encrypted key is sent to other application therefore I can't change the algorithm or key here. Following is approach used in java</p>

<pre><code>1. Stored the private key in hex string. I.e. 48 chars hex string as below which is equivalent to 24 bytes reuquired for 3des
73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2
2. Following is code written in java 
https://github.com/dilipkumar2k6/3des/blob/master/TripleDes.java
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;


public class TripleDes {
    // Crypto library related keys
    private static final String ALGO_NAME = ""DESede/ECB/NoPadding"";
    private static final int PADDING_BLOCK = 8;

    // Test Data
    private static final String PLAIN_TEXT = ""Hello World"";
    private static final String SHARED_KEY = ""73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2"";

    public static void main(String[] arg) {

        try {
            // Get Algorithm name
            String desAlgoName = getDESAlgorithmName(ALGO_NAME);
            // Create Cipher object
            Cipher cipher = Cipher.getInstance(ALGO_NAME);
            //Actual DES algo needs 56 bits key, which is equivalent to 1byte (0 at 0th position)  Get 8*3 byets key
            byte [] key = hexFromString(SHARED_KEY);
            System.out.println(""DES Algorithm  shared key size in bytes &gt;&gt; ""+key.length);
            // Create SecretKeySpec
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, desAlgoName);
            //Encrypt bytes
            byte [] encryptedBytes = encryptIntoBytes(cipher, secretKeySpec, PLAIN_TEXT.getBytes(), 0, PLAIN_TEXT.getBytes().length);
            String encryptedString=  hexToString(encryptedBytes);
            System.out.println(encryptedString);

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static byte[] encryptIntoBytes(Cipher cipher, SecretKeySpec secretKeySpec, byte[] dct, int offset, int len) throws GeneralSecurityException {
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] ect = cipher.doFinal(addPadding(dct, offset, len));
        return ect;
    }

    public static String getDESAlgorithmName(String algoName) {
        System.out.println(""getDESAlgorithmName algoName &gt;&gt; ""+algoName);
        String desAlgoName = null;
        int i = algoName.indexOf(""/"");
        if (i != -1)
            desAlgoName = algoName.substring(0, i);
        else
            desAlgoName = algoName;
        return desAlgoName;
    }

    /**
     * Adds padding characters to the data to be encrypted. Also adds random
     * Initial Value to the beginning of the encrypted data when using Triple
     * DES in CBC mode (DES-EDE3/CBC).
     * 
     * @param inData
     *            Array of bytes to be padded
     * @param offset
     *            Offset to starting point within array
     * @param len
     *            Number of bytes to be encrypted
     * @return Padded array of bytes
     */
    public static byte[] addPadding(byte[] inData, int offset, int len) {
        System.out.println(""addPadding offset &gt;&gt; ""+offset+"", len &gt;&gt; ""+len);
        byte[] bp = null;
        int padChars = PADDING_BLOCK; // start with max padding value
        int partial = (len + 1) % padChars; // calculate how many extra bytes
                                            // exist
        if (partial == 0) {
            padChars = 1; // if none, set to only pad with length byte
        } else {
            padChars = padChars - partial + 1; // calculate padding size to
                                                // include length
        }
        System.out.println(""addPadding &gt;&gt; Add padding of ""+padChars);
        /*
         * Create a byte array large enough to hold data plus padding bytes The
         * count of padding bytes is placed in the first byte of the data to be
         * encrypted. That byte is included in the count.
         */
        bp = new byte[len + padChars];
        bp[0] = Byte.parseByte(Integer.toString(padChars));
        System.arraycopy(inData, offset, bp, 1, len);
        return bp;
    }

    public static byte[] hexFromString(String hex) {
        int len = hex.length();
        byte[] buf = new byte[((len + 1) / 2)];

        int i = 0, j = 0;
        if ((len % 2) == 1)
            buf[j++] = (byte) fromDigit(hex.charAt(i++));

        while (i &lt; len) {
            buf[j++] = (byte) ((fromDigit(hex.charAt(i++)) &lt;&lt; 4) | fromDigit(hex
                    .charAt(i++)));
        }
        return buf;
    }

    public static int fromDigit(char ch) {
        if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
            return ch - '0';
        if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F')
            return ch - 'A' + 10;
        if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')
            return ch - 'a' + 10;

        throw new IllegalArgumentException(""invalid hex digit '"" + ch + ""'"");
    }

    public static String hexToString(byte[] ba) {
        return hexToString(ba, 0, ba.length);
    }

    public static final char[] hexDigits = { '0', '1', '2', '3', '4', '5',
            '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

    public static String hexToString(byte[] ba, int offset, int length) {
        char[] buf = new char[length * 2];
        int j = 0;
        int k;

        for (int i = offset; i &lt; offset + length; i++) {
            k = ba[i];
            buf[j++] = hexDigits[(k &gt;&gt;&gt; 4) &amp; 0x0F];
            buf[j++] = hexDigits[k &amp; 0x0F];
        }
        return new String(buf);
    }

}
</code></pre>

<p>I need to migrate this code to Nodejs and facing multiple issues. I refeered <a href=""http://mygo.iteye.com/blog/2018882"" rel=""nofollow"">http://mygo.iteye.com/blog/2018882</a> to get the basic idea on nodejs way to do the encryption in des3. However I see following difference in JAVA way and Nodejs way.</p>

<pre><code>1. JAVA is using Hex string of 48 lenght as key, since one char in hex is 4 bits therfore final size is equivalent to 24 bytes length which meets DES3 requirement. 
2. In Java code, final key is being used as bytes (as needed by DES) which made indpendent of the way we store the key
3. In node js, key is stored as character i.e. to use des3 I have to use 24 bytes which is equivalent to 24 chars key as  73AD9CEC99816AA6A4D82FB2. Here this is string of 24 chars and since one char is one byte thereofore total length is 24 bytes which meets DES3 requirement.
4. Following is nodejs code for reference
https://github.com/dilipkumar2k6/3des/blob/master/Crypto.js
'use strict';
/*
 *  Offers related services.
 */
var crypto = require(""crypto"");

module.exports = {
    encrypt: function (plainText) {
        return encrypt({
            alg: 'des-ede3', //3des-ecb  
            autoPad: true,
            key: '73AD9CEC99816AA6A4D82FB2',
            plaintext: 'Hello World',
            iv: null
        });
    }
};

function encrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0);
    var plaintext = param.plaintext;
    var alg = param.alg;
    var autoPad = param.autoPad;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);  //default true  
    var ciph = cipher.update(plaintext, 'utf8', 'hex');
    ciph += cipher.final('hex');
    console.log(alg, ciph);
    return ciph;

}

function decrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0)
    var alg = param.alg;
    var autoPad = param.autoPad;

    //decrypt  
    var decipher = crypto.createDecipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);
    var txt = decipher.update(ciph, 'hex', 'utf8');
    txt += decipher.final('utf8');
    console.log(alg, txt);
    return txt;
}
</code></pre>

<p>Following is my problem.</p>

<pre><code>1. How can i convert my existing hex code into string? I used ""hexToString"" method (please check the java code)to convert hex into string. However getting weired character (this is also expected but problem is how i can use this transformed key in nodejs.
2. Can I pass byte array as key to Nodejs? It will make problem easy as I can easily convert my hex key into bytes array and I store my bytes array key in nodejs code.
3. In my javacode, I have custom padding logic, how can i write same logic in nodejs?
4. Most importantly, can I achieve same encryption logic in nodejs (similar to java)?
</code></pre>

<p>Artjom B. helped me to get the insight of nodejs and des3 algorithm. I have edited my post to clarify my exact requirement.</p>

<p>I think my main problem is, how can i feed byte[] as key to nodejs crypto for DES3?</p>

<p>I am kind of stuck. Please help.</p>
","<p>Running <code>crypto.getCiphers()</code> shows you the available ciphers. Triple DES (EDE) in ECB mode with two keys (16 byte key) can be used as <code>des-ede</code>. If you have three part key (24 byte key) you should use <code>des-ede3</code>. <code>ecb</code> probably does not appear in the cipher description, because it's the most basic form.</p>

<p>Triple DES-EDE has different ways to use a key. EDE means encrypt-decrypt-encrypt with three different keys. If you only have for example one 8 byte key, this suggests that you use the same key for every phase of EDE. It's clear from your Java code that you have a 24 byte key (48 hex encoded chars). You have to <strong>use the same key</strong>.</p>

<p>The crypto module uses PKCS7 padding by default, so you will need to set the <a href=""https://nodejs.org/api/crypto.html#crypto_cipher_setautopadding_auto_padding_true"" rel=""nofollow"">auto padding to false</a> and do the padding yourself. I leave that task up to you.</p>

<pre><code>module.exports = {
    encrypt: function (plainText) {
        return encrypt({
            alg: 'des-ede3', //3des-ecb  
            autoPad: false,
            key: '73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2',
            plaintext: 'Hello World',
            iv: null
        });
    }
};

function mypad(buf){
    // TODO: do the padding
    // replicate padding as in Java
    return buf;
}

function myunpad(buf){
    // TODO: do the unpadding
    // read the first *byte* and remove as many trailing *bytes*
    return buf;
}

function encrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0);
    var plaintext = mypad(new Buffer(param.plaintext));
    var alg = param.alg;
    var autoPad = param.autoPad;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);  //default true  
    var ciph = cipher.update(plaintext, 'utf8', 'hex');
    ciph += cipher.final('hex');
    console.log(alg, ciph);
    return ciph;
}

function decrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0)
    var alg = param.alg;
    var autoPad = param.autoPad;

    //decrypt  
    var decipher = crypto.createDecipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);
    var txt = decipher.update(ciph, 'hex', 'utf8');
    txt += decipher.final('utf8');
    console.log(alg, txt);
    return myunpad(new Buffer(txt, 'hex'));
}
</code></pre>

<hr>

<p>Word of caution:</p>

<p>Don't use (3)DES especially with only one 8 byte key! Don't use ECB mode! Don't use NoPadding for block modes! Use AES-256 with GCM mode (no padding since it's a streaming mode).-</p>
","4474","<node.js><des><cryptojs>","0","3","2","2016-08-17 10:03:12","29832471","1","2","1122154","","2015-04-25 00:37:55","2015-04-23 18:13:38",""
"29831300","Convert DESede/ECB/NoPadding algorithm written in java into Nodejs using crypto module","<p>I am working on migration of code form java to Nodejs. I have one requirement to encrypt the text with private key using ""DESede/ECB/NoPadding"" algorithm. Currently code is written in Java and now I need to migrate to Nodejs. Since encrypted key is sent to other application therefore I can't change the algorithm or key here. Following is approach used in java</p>

<pre><code>1. Stored the private key in hex string. I.e. 48 chars hex string as below which is equivalent to 24 bytes reuquired for 3des
73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2
2. Following is code written in java 
https://github.com/dilipkumar2k6/3des/blob/master/TripleDes.java
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;


public class TripleDes {
    // Crypto library related keys
    private static final String ALGO_NAME = ""DESede/ECB/NoPadding"";
    private static final int PADDING_BLOCK = 8;

    // Test Data
    private static final String PLAIN_TEXT = ""Hello World"";
    private static final String SHARED_KEY = ""73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2"";

    public static void main(String[] arg) {

        try {
            // Get Algorithm name
            String desAlgoName = getDESAlgorithmName(ALGO_NAME);
            // Create Cipher object
            Cipher cipher = Cipher.getInstance(ALGO_NAME);
            //Actual DES algo needs 56 bits key, which is equivalent to 1byte (0 at 0th position)  Get 8*3 byets key
            byte [] key = hexFromString(SHARED_KEY);
            System.out.println(""DES Algorithm  shared key size in bytes &gt;&gt; ""+key.length);
            // Create SecretKeySpec
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, desAlgoName);
            //Encrypt bytes
            byte [] encryptedBytes = encryptIntoBytes(cipher, secretKeySpec, PLAIN_TEXT.getBytes(), 0, PLAIN_TEXT.getBytes().length);
            String encryptedString=  hexToString(encryptedBytes);
            System.out.println(encryptedString);

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static byte[] encryptIntoBytes(Cipher cipher, SecretKeySpec secretKeySpec, byte[] dct, int offset, int len) throws GeneralSecurityException {
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] ect = cipher.doFinal(addPadding(dct, offset, len));
        return ect;
    }

    public static String getDESAlgorithmName(String algoName) {
        System.out.println(""getDESAlgorithmName algoName &gt;&gt; ""+algoName);
        String desAlgoName = null;
        int i = algoName.indexOf(""/"");
        if (i != -1)
            desAlgoName = algoName.substring(0, i);
        else
            desAlgoName = algoName;
        return desAlgoName;
    }

    /**
     * Adds padding characters to the data to be encrypted. Also adds random
     * Initial Value to the beginning of the encrypted data when using Triple
     * DES in CBC mode (DES-EDE3/CBC).
     * 
     * @param inData
     *            Array of bytes to be padded
     * @param offset
     *            Offset to starting point within array
     * @param len
     *            Number of bytes to be encrypted
     * @return Padded array of bytes
     */
    public static byte[] addPadding(byte[] inData, int offset, int len) {
        System.out.println(""addPadding offset &gt;&gt; ""+offset+"", len &gt;&gt; ""+len);
        byte[] bp = null;
        int padChars = PADDING_BLOCK; // start with max padding value
        int partial = (len + 1) % padChars; // calculate how many extra bytes
                                            // exist
        if (partial == 0) {
            padChars = 1; // if none, set to only pad with length byte
        } else {
            padChars = padChars - partial + 1; // calculate padding size to
                                                // include length
        }
        System.out.println(""addPadding &gt;&gt; Add padding of ""+padChars);
        /*
         * Create a byte array large enough to hold data plus padding bytes The
         * count of padding bytes is placed in the first byte of the data to be
         * encrypted. That byte is included in the count.
         */
        bp = new byte[len + padChars];
        bp[0] = Byte.parseByte(Integer.toString(padChars));
        System.arraycopy(inData, offset, bp, 1, len);
        return bp;
    }

    public static byte[] hexFromString(String hex) {
        int len = hex.length();
        byte[] buf = new byte[((len + 1) / 2)];

        int i = 0, j = 0;
        if ((len % 2) == 1)
            buf[j++] = (byte) fromDigit(hex.charAt(i++));

        while (i &lt; len) {
            buf[j++] = (byte) ((fromDigit(hex.charAt(i++)) &lt;&lt; 4) | fromDigit(hex
                    .charAt(i++)));
        }
        return buf;
    }

    public static int fromDigit(char ch) {
        if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
            return ch - '0';
        if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F')
            return ch - 'A' + 10;
        if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')
            return ch - 'a' + 10;

        throw new IllegalArgumentException(""invalid hex digit '"" + ch + ""'"");
    }

    public static String hexToString(byte[] ba) {
        return hexToString(ba, 0, ba.length);
    }

    public static final char[] hexDigits = { '0', '1', '2', '3', '4', '5',
            '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

    public static String hexToString(byte[] ba, int offset, int length) {
        char[] buf = new char[length * 2];
        int j = 0;
        int k;

        for (int i = offset; i &lt; offset + length; i++) {
            k = ba[i];
            buf[j++] = hexDigits[(k &gt;&gt;&gt; 4) &amp; 0x0F];
            buf[j++] = hexDigits[k &amp; 0x0F];
        }
        return new String(buf);
    }

}
</code></pre>

<p>I need to migrate this code to Nodejs and facing multiple issues. I refeered <a href=""http://mygo.iteye.com/blog/2018882"" rel=""nofollow"">http://mygo.iteye.com/blog/2018882</a> to get the basic idea on nodejs way to do the encryption in des3. However I see following difference in JAVA way and Nodejs way.</p>

<pre><code>1. JAVA is using Hex string of 48 lenght as key, since one char in hex is 4 bits therfore final size is equivalent to 24 bytes length which meets DES3 requirement. 
2. In Java code, final key is being used as bytes (as needed by DES) which made indpendent of the way we store the key
3. In node js, key is stored as character i.e. to use des3 I have to use 24 bytes which is equivalent to 24 chars key as  73AD9CEC99816AA6A4D82FB2. Here this is string of 24 chars and since one char is one byte thereofore total length is 24 bytes which meets DES3 requirement.
4. Following is nodejs code for reference
https://github.com/dilipkumar2k6/3des/blob/master/Crypto.js
'use strict';
/*
 *  Offers related services.
 */
var crypto = require(""crypto"");

module.exports = {
    encrypt: function (plainText) {
        return encrypt({
            alg: 'des-ede3', //3des-ecb  
            autoPad: true,
            key: '73AD9CEC99816AA6A4D82FB2',
            plaintext: 'Hello World',
            iv: null
        });
    }
};

function encrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0);
    var plaintext = param.plaintext;
    var alg = param.alg;
    var autoPad = param.autoPad;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);  //default true  
    var ciph = cipher.update(plaintext, 'utf8', 'hex');
    ciph += cipher.final('hex');
    console.log(alg, ciph);
    return ciph;

}

function decrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0)
    var alg = param.alg;
    var autoPad = param.autoPad;

    //decrypt  
    var decipher = crypto.createDecipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);
    var txt = decipher.update(ciph, 'hex', 'utf8');
    txt += decipher.final('utf8');
    console.log(alg, txt);
    return txt;
}
</code></pre>

<p>Following is my problem.</p>

<pre><code>1. How can i convert my existing hex code into string? I used ""hexToString"" method (please check the java code)to convert hex into string. However getting weired character (this is also expected but problem is how i can use this transformed key in nodejs.
2. Can I pass byte array as key to Nodejs? It will make problem easy as I can easily convert my hex key into bytes array and I store my bytes array key in nodejs code.
3. In my javacode, I have custom padding logic, how can i write same logic in nodejs?
4. Most importantly, can I achieve same encryption logic in nodejs (similar to java)?
</code></pre>

<p>Artjom B. helped me to get the insight of nodejs and des3 algorithm. I have edited my post to clarify my exact requirement.</p>

<p>I think my main problem is, how can i feed byte[] as key to nodejs crypto for DES3?</p>

<p>I am kind of stuck. Please help.</p>
","<p>This is my decrypt function based on Artjom's answer. use 'des-ede3' if you have a 24byte key.</p>

<pre><code>internals.decrypt = function (message, key) {
    var message = Buffer.from(message, 'base64');
    var decipher = crypto.createDecipher('des-ede', key);

    var decryptedMessage = decipher.update(message, 'hex', 'utf8');
    decryptedMessage += decipher.final('utf8');
    return decryptedMessage.toString();
}
</code></pre>
","4474","<node.js><des><cryptojs>","0","1","2","2016-08-17 10:03:12","29832471","1","2","1122154","","2015-04-25 00:37:55","2015-04-23 18:13:38",""
"6959660","Bit manipulation of chars in Java or C?","<p>I am a student trying to implement the DES algorithm.
I have a choice of 2 languages: C &amp; Java.
I did understand the algorithm, but am stuck at the very beginning as to manipulation of the key.</p>

<p>Here's the problem.
In DES, we have a 64-bit key (8 chars in C and 4 in Java, although I can cast the char to byte to get only the ASCII part), of which every 8th bit is a parity bit and needs to be stripped to make it a 56-bit key and do further processing. I have thought about this for long, but cannot find a way to strip every 8th bit and store the result in another char array (in Java as well as C).
I tried using the <code>java.util.BitSet class</code>, but got confused.</p>

<p>Any suggestions as to how can I remove every 8th bit and concat adjacent bytes(Java) or chars(C) to get the 56 bit key?</p>

<p>I am aware of the bit operations and shifting, but for the specific example:<br>
Suppose I have an 16 bit key: <code>1100 1001 1101 1000</code>.<br>
I need to remove the 8th and 16th bit, making the key: <code>1100 100 1101 100</code>.</p>

<p>If I declare 2 bytes, how do I truncate the 8th bit and append the 9th bit to it, making the first byte: <code>1100 1001</code></p>

<p>So, what I need help with is how do I, replace 8th bit with 9th bit, replace 16th bit with 17th bit and so on to derive a 56-bit key from 64-bit key?</p>

<p>If someone can explain it to me, I might probably be able to implement it regardless of language.</p>
","<p>In C, you can manipulate bits with the bitwise operators, such as <code>&amp;</code> and <code>|</code>, as well as the bitshift operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>.</p>

<p>For instance, to turn off the high bit of a given byte, you can do this.</p>

<pre><code>char c = 0xBF;  // initial value is bit pattern 10111111
c &amp;= 0x7F;      // perform AND against the bit pattern 01111111
                // final value is bit pattern 00111111 (0x3F)
</code></pre>

<p>Does that make sense?
Obviously, you need to be able to convert from a bit pattern to hex, but that's not too hard.</p>

<p>You can use similar masking to extract the bits you want, and put them in an output buffer.</p>

<p><strong>Update:</strong></p>

<p>You have 64 bits (8 bytes) of input, and want 56 bits (7 bytes) of output.</p>

<p>Let's represent your input as the following, where each letter represents a single bit
The 'x' bits are the ones you want to throw away.</p>

<pre><code>xAAAAAAA xBBBBBBB xCCCCCCC xDDDDDDD xEEEEEEE xFFFFFFF xGGGGGGG xHHHHHHH
</code></pre>

<p>So you want your final answer to be:</p>

<pre><code>AAAAAAAB BBBBBBCC CCCCCDDD DDDDEEEE EEEFFFFF FFGGGGGG GHHHHHHH
</code></pre>

<p>So in C, we might have code like this:</p>

<pre><code>unsigned char data[8] = {/* put data here */};

// chop off the top bit of the first byte
data[0] &lt;&lt;= 1;

// the bottom bit of data[0] needs to come from the top data bit of data[1]
data[0] |= (data[1] &gt;&gt; 6) &amp; 0x01;

// use similar transformations to fill in data[1], data[2], ... data[6]
// At the end, data[7] will be useless
</code></pre>

<p>Of course this is not optimized at all, but hopefully you get the idea.</p>
","4403","<java><c><bit-manipulation><bit><des>","3","1","4","2015-06-30 17:29:29","6959750","1","0","117507","","2015-06-30 12:22:11","2011-08-05 16:37:25",""
"6959660","Bit manipulation of chars in Java or C?","<p>I am a student trying to implement the DES algorithm.
I have a choice of 2 languages: C &amp; Java.
I did understand the algorithm, but am stuck at the very beginning as to manipulation of the key.</p>

<p>Here's the problem.
In DES, we have a 64-bit key (8 chars in C and 4 in Java, although I can cast the char to byte to get only the ASCII part), of which every 8th bit is a parity bit and needs to be stripped to make it a 56-bit key and do further processing. I have thought about this for long, but cannot find a way to strip every 8th bit and store the result in another char array (in Java as well as C).
I tried using the <code>java.util.BitSet class</code>, but got confused.</p>

<p>Any suggestions as to how can I remove every 8th bit and concat adjacent bytes(Java) or chars(C) to get the 56 bit key?</p>

<p>I am aware of the bit operations and shifting, but for the specific example:<br>
Suppose I have an 16 bit key: <code>1100 1001 1101 1000</code>.<br>
I need to remove the 8th and 16th bit, making the key: <code>1100 100 1101 100</code>.</p>

<p>If I declare 2 bytes, how do I truncate the 8th bit and append the 9th bit to it, making the first byte: <code>1100 1001</code></p>

<p>So, what I need help with is how do I, replace 8th bit with 9th bit, replace 16th bit with 17th bit and so on to derive a 56-bit key from 64-bit key?</p>

<p>If someone can explain it to me, I might probably be able to implement it regardless of language.</p>
","<p>Be careful of 16-bit chars in Java.  Many methods only convert the lower 8 bits.  Read the documentation carefully.  It is more usual to treat a cryptographic key as a a <code>byte[]</code> in Java due to the stronger typing than in C.</p>

<p>As to the parity bits, check through the DES algorithm carefully and see where they are used.  That should give you a hint as to what you need to do with them.</p>
","4403","<java><c><bit-manipulation><bit><des>","3","3","4","2015-06-30 17:29:29","6959750","1","0","117507","","2015-06-30 12:22:11","2011-08-05 16:37:25",""
"6959660","Bit manipulation of chars in Java or C?","<p>I am a student trying to implement the DES algorithm.
I have a choice of 2 languages: C &amp; Java.
I did understand the algorithm, but am stuck at the very beginning as to manipulation of the key.</p>

<p>Here's the problem.
In DES, we have a 64-bit key (8 chars in C and 4 in Java, although I can cast the char to byte to get only the ASCII part), of which every 8th bit is a parity bit and needs to be stripped to make it a 56-bit key and do further processing. I have thought about this for long, but cannot find a way to strip every 8th bit and store the result in another char array (in Java as well as C).
I tried using the <code>java.util.BitSet class</code>, but got confused.</p>

<p>Any suggestions as to how can I remove every 8th bit and concat adjacent bytes(Java) or chars(C) to get the 56 bit key?</p>

<p>I am aware of the bit operations and shifting, but for the specific example:<br>
Suppose I have an 16 bit key: <code>1100 1001 1101 1000</code>.<br>
I need to remove the 8th and 16th bit, making the key: <code>1100 100 1101 100</code>.</p>

<p>If I declare 2 bytes, how do I truncate the 8th bit and append the 9th bit to it, making the first byte: <code>1100 1001</code></p>

<p>So, what I need help with is how do I, replace 8th bit with 9th bit, replace 16th bit with 17th bit and so on to derive a 56-bit key from 64-bit key?</p>

<p>If someone can explain it to me, I might probably be able to implement it regardless of language.</p>
","<p>I can briefly tell about a way....i will explain further if required...</p>

<p>Right shift all the 8 chars by 1 ie c1 = c1>>1 etc</p>

<p>Multiplyc1 with the total number of bytes (ie56) ie c1 * 0x0000000000 (not sure how  many zeros)</p>

<p>Then, add 0x0000+ to next chars ie c2 = c2 + 0x0000; c3 = c3 + 0x000000 so on (Keep adding 2 0s for proceeding chars)  </p>

<p>Now, start adding c1 + c2 + c3.......</p>

<p>The idea here is that, first fill in the number with zeros and start adding teh other chars so that they keep lying properly</p>

<pre><code>00 00 00 00 00 00 00 00 00
34 00 00 00 00 00 00 00 00   (c1 = c1&gt;&gt;1) . Here c1=0x34, c2=0x67
00 67 00 00 00 00 00 00 00   (c2 = c2&gt;&gt;1)
so on...............
</code></pre>

<p>Add teh above;
I hope this will help.</p>
","4403","<java><c><bit-manipulation><bit><des>","3","0","4","2015-06-30 17:29:29","6959750","1","0","117507","","2015-06-30 12:22:11","2011-08-05 16:37:25",""
"6959660","Bit manipulation of chars in Java or C?","<p>I am a student trying to implement the DES algorithm.
I have a choice of 2 languages: C &amp; Java.
I did understand the algorithm, but am stuck at the very beginning as to manipulation of the key.</p>

<p>Here's the problem.
In DES, we have a 64-bit key (8 chars in C and 4 in Java, although I can cast the char to byte to get only the ASCII part), of which every 8th bit is a parity bit and needs to be stripped to make it a 56-bit key and do further processing. I have thought about this for long, but cannot find a way to strip every 8th bit and store the result in another char array (in Java as well as C).
I tried using the <code>java.util.BitSet class</code>, but got confused.</p>

<p>Any suggestions as to how can I remove every 8th bit and concat adjacent bytes(Java) or chars(C) to get the 56 bit key?</p>

<p>I am aware of the bit operations and shifting, but for the specific example:<br>
Suppose I have an 16 bit key: <code>1100 1001 1101 1000</code>.<br>
I need to remove the 8th and 16th bit, making the key: <code>1100 100 1101 100</code>.</p>

<p>If I declare 2 bytes, how do I truncate the 8th bit and append the 9th bit to it, making the first byte: <code>1100 1001</code></p>

<p>So, what I need help with is how do I, replace 8th bit with 9th bit, replace 16th bit with 17th bit and so on to derive a 56-bit key from 64-bit key?</p>

<p>If someone can explain it to me, I might probably be able to implement it regardless of language.</p>
","<p>@jwd, @jscode
Thanks a lot for your help.
To jwd: I got the idea from your code. Seemed pretty simple logic after I read it..  :-) Wonder why I didnt think of that.
Well, I did polish your idea a little bit and it works fine now in Java.
If anyone has any suggestions, please let me know.
THANKS..
P.S.: The testing part is very primitive. I print the bit values. I did it manually for a couple of examples and used the same as input and it works fine.</p>

<p>=============================================</p>

<pre><code>public static void main(String[] args) {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(""Enter an 8 char key: "");
        String input;
        try {
            // get key, key.length()&gt;=8 chars
            input = br.readLine();
            if (input.length() &lt; 8) {
                System.out.println(""Key &lt; 8B. Exiting. . ."");
                System.exit(1);
            }
            // java char has 16 bits instead of 8 bits as in C,
            // so convert it to 8 bit char by getting lower order byte &amp;
            // discarding higher order byte
            char[] inputKey = input.toCharArray();
            byte[] key64 = new byte[8];
            byte[] key56 = new byte[7];

            // consider only first 8 chars even if input &gt; 8
            for (int counter = 0; counter &lt; 8; counter++)
                key64[counter] = (byte) inputKey[counter];

            System.out.print(""\n$$ "" + new String(key64) + ""  $$\n"");

            // converting 64bit key to 56 bit key
            for (int counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
                key64[counter] = (byte) (key64[counter] &gt;&gt;&gt; 1);
                key64[counter] = (byte) (key64[counter] &lt;&lt; 1);
            }

            for (int counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
                key56[counter] = (byte) (key64[counter] &lt;&lt; counter);
                key56[counter] = (byte) (key56[counter] | (key64[counter + 1] &gt;&gt;&gt; (KEY_LENGTH - 1 - counter)));
            }

            /*Conversion from 64 to 56 bit testing code
             System.out.println(new String(key56));

            System.out.println();
            for (int counter1 = 0; counter1 &lt; 7; counter1++) {
                for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
                    System.out.println(key56[counter1] &amp; (1 &lt;&lt; counter2));
                }
                System.out.println();
            }*/

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
","4403","<java><c><bit-manipulation><bit><des>","3","0","4","2015-06-30 17:29:29","6959750","1","0","117507","","2015-06-30 12:22:11","2011-08-05 16:37:25",""
"22070990","How to decrypt 3DES in ECB mode (using a wordlist)?","<p>I have some encrypted texts (encrypted with 3DES in ECB mode without salt). </p>

<p><strong>My question: How can I decrypt them using a wordlist? (or without one?)</strong></p>

<p>Example: </p>

<p>Encrypted text:  </p>

<pre><code>Xfi+h4Ir6l7zXCP+N4EPvQ==
</code></pre>

<p>The wordlist for this: </p>

<pre><code>foo
bar
marketing
</code></pre>

<p>The original text was before encrypting was: ""marketing"" (just to make the example full). </p>

<p>I tried with the commented python script: </p>

<pre><code>$ cat 3des.py 
 #!/usr/local/bin/python

from pyDes import *

data = ""marketing""
k = des(""DESCRYPT"", CBC, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)
d = k.encrypt(data)
print ""Encrypted: %r"" % d
print ""Decrypted: %r"" % k.decrypt(d)
assert k.decrypt(d, padmode=PAD_PKCS5) == data
</code></pre>

<p>testing it: </p>

<pre><code>$ python 3des.py 
Encrypted: '\xabd\xfc\x98x\x86\x8d\xb5A\xba\x8e\x12,\x1f\x83\xb5'
Decrypted: 'marketing'
$ 
</code></pre>

<p>A little help please?</p>
","<p>If you're going to use pyDES, you'll first have to configure your the script to use 3DES...  Here's the provided pyDES example, modified to use 3DES:</p>

<pre><code>from pyDes import *

data = ""marketing""
k = triple_des(""DESCRYPTDESCRYPT"", ECB, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)
d = k.encrypt(data)
print ""Encrypted: %r"" % d
print ""Decrypted: %r"" % k.decrypt(d)
assert k.decrypt(d, padmode=PAD_PKCS5) == data
</code></pre>

<p>To break it down...</p>

<p>The following line contains the class initialization information:</p>

<pre><code>k = triple_des(""DESCRYPTDESCRYPT"", ECB, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)
</code></pre>

<p>From the documentation, the params are as follows:</p>

<pre><code>(key, [mode], [IV], [pad], [padmode])

key     -&gt; Bytes containing the encryption key. 8 bytes for DES, 16 or 24 bytes
       for Triple DES
mode    -&gt; Optional argument for encryption type, can be either
       pyDes.ECB (Electronic Code Book) or pyDes.CBC (Cypher Block Chaining)
IV      -&gt; Optional Initial Value bytes, must be supplied if using CBC mode.
       Length must be 8 bytes.
pad     -&gt; Optional argument, set the pad character (PAD_NORMAL) to use during
       all encrypt/decrpt operations done with this instance.
padmode -&gt; Optional argument, set the padding mode (PAD_NORMAL or PAD_PKCS5)
       to use during all encrypt/decrpt operations done with this instance.
</code></pre>

<p>So, in my modified example, I've configured the params like this...</p>

<pre><code>Key: DESCRYPTDESCRYPT
Mode: ECB
IV: ""\0\0\0\0\0\0\0\0""
pad: None
padmode: PAD_PKCS5
</code></pre>

<p>So, from here, you'll need to change the 'data' variable above to the ciphertext you want to decrypt and then load your wordlist into an array, set up a loop to iterate the values in the array through the 'key' param...</p>
","4402","<python><des><3d-secure>","2","1","1","2014-03-05 07:27:23","","6","1","3366378","","2014-03-05 07:27:23","2014-02-26 14:45:56",""
"9038298","Java DESede encrypt, OpenSSL equivalent","<p></p>

<p>I'm using DESede encryptation in Java and I want to make the same encryptation using  the OpenSSL's API in C++.</p>

<p>Java code:</p>

<pre><code>    String secretKey = ""abcdefghijklmnopqrstuvwx"";

    byte[] bytes = secretKey.getBytes(""UTF-8"");
    SecretKey key = new SecretKeySpec(bytes, ""DESede"");

    Cipher ecipher = Cipher.getInstance(""DESede"");
    ecipher.init(Cipher.ENCRYPT_MODE, key);

    String input = ""holahola1""; 

    byte[] utf8 = input.getBytes(""UTF8"");
    byte[] enc = ecipher.doFinal(utf8); // Encrypt
</code></pre>

<p>output: [94, -45, 64, -105, 99, -55, 99, -42, 95, 122, 72, 117, -119, 95, -43, 40]</p>

<p>C++ code:</p>

<pre><code>    unsigned char intext[256], outtext[256];

    memset(intext, 0, sizeof(intext));
    memset(outtext, 0, sizeof(outtext));

    char *output = (char *)outtext;
    DES_key_schedule keyschedc1;
    DES_key_schedule keyschedc2;
    DES_key_schedule keyschedc3;
    DES_cblock keyc1;
    DES_cblock keyc2;
    DES_cblock keyc3;

    DES_string_to_key(""abcdefgh"", &amp;keyc1);
    DES_string_to_key(""ijklmnop"", &amp;keyc2);
    DES_string_to_key(""qrstuvwx"", &amp;keyc3);
    DES_set_key((DES_cblock *)keyc1, &amp;keyschedc1);
    DES_set_key((DES_cblock *)keyc2, &amp;keyschedc2);
    DES_set_key((DES_cblock *)keyc3, &amp;keyschedc3); 

    strcpy((char *)intext, ""holahola1"");

    for (int i=0; i&lt;16; i += 8)
    {
        DES_ecb3_encrypt((DES_cblock *)(intext + i),
                        (DES_cblock *)(outtext + i), 
                        &amp;keyschedc1, &amp;keyschedc2, 
                        &amp;keyschedc3,DES_ENCRYPT);
    }              
</code></pre>

<p>output: [30 55 9 -58 -18 -65 -66 123 -32 72 30 110 120 69 101 -81]</p>

<p>What's wrong? Can someone help me? Thanks!.</p>
","<p>Try DES_ecb3_encrypt instead as you are using 3 separate keys.</p>
","4386","<java><c++><encryption><openssl><des>","2","1","3","2012-09-25 13:00:02","9078993","6","4","705545","","2012-01-31 07:39:28","2012-01-27 18:35:06",""
"9038298","Java DESede encrypt, OpenSSL equivalent","<p></p>

<p>I'm using DESede encryptation in Java and I want to make the same encryptation using  the OpenSSL's API in C++.</p>

<p>Java code:</p>

<pre><code>    String secretKey = ""abcdefghijklmnopqrstuvwx"";

    byte[] bytes = secretKey.getBytes(""UTF-8"");
    SecretKey key = new SecretKeySpec(bytes, ""DESede"");

    Cipher ecipher = Cipher.getInstance(""DESede"");
    ecipher.init(Cipher.ENCRYPT_MODE, key);

    String input = ""holahola1""; 

    byte[] utf8 = input.getBytes(""UTF8"");
    byte[] enc = ecipher.doFinal(utf8); // Encrypt
</code></pre>

<p>output: [94, -45, 64, -105, 99, -55, 99, -42, 95, 122, 72, 117, -119, 95, -43, 40]</p>

<p>C++ code:</p>

<pre><code>    unsigned char intext[256], outtext[256];

    memset(intext, 0, sizeof(intext));
    memset(outtext, 0, sizeof(outtext));

    char *output = (char *)outtext;
    DES_key_schedule keyschedc1;
    DES_key_schedule keyschedc2;
    DES_key_schedule keyschedc3;
    DES_cblock keyc1;
    DES_cblock keyc2;
    DES_cblock keyc3;

    DES_string_to_key(""abcdefgh"", &amp;keyc1);
    DES_string_to_key(""ijklmnop"", &amp;keyc2);
    DES_string_to_key(""qrstuvwx"", &amp;keyc3);
    DES_set_key((DES_cblock *)keyc1, &amp;keyschedc1);
    DES_set_key((DES_cblock *)keyc2, &amp;keyschedc2);
    DES_set_key((DES_cblock *)keyc3, &amp;keyschedc3); 

    strcpy((char *)intext, ""holahola1"");

    for (int i=0; i&lt;16; i += 8)
    {
        DES_ecb3_encrypt((DES_cblock *)(intext + i),
                        (DES_cblock *)(outtext + i), 
                        &amp;keyschedc1, &amp;keyschedc2, 
                        &amp;keyschedc3,DES_ENCRYPT);
    }              
</code></pre>

<p>output: [30 55 9 -58 -18 -65 -66 123 -32 72 30 110 120 69 101 -81]</p>

<p>What's wrong? Can someone help me? Thanks!.</p>
","<p>I got it. Java DESede encryption, uses a triple DES with ecb mode, and uses a PKCS#5 padding. So, I fill my text, using PKCS#5, and it solve all.</p>

<p>Example C++ code:</p>

<pre><code>unsigned char intext[256], outtext[256];

memset(intext, 0x07, sizeof(intext)); //PKCS#5 padding (See documentation)
memset(outtext, 0, sizeof(outtext));
char *output = (char *)outtext;

DES_key_schedule keyschedc1;
DES_key_schedule keyschedc2;
DES_key_schedule keyschedc3;
DES_cblock keyc1;
DES_cblock keyc2;
DES_cblock keyc3;

DES_set_key((DES_cblock *)""abcdefgh"", &amp;keyschedc1);
DES_set_key((DES_cblock *)""ijklmnop"", &amp;keyschedc2);
DES_set_key((DES_cblock *)""qrstuvwx"", &amp;keyschedc3); 

strcpy((char *)intext, ""holahola1"");

for (int i=0; i&lt;16; i += 8)
{
    DES_ecb3_encrypt((DES_cblock *)(intext + i),
                    (DES_cblock *)(outtext + i), 
                    &amp;keyschedc1, &amp;keyschedc2, 
                    &amp;keyschedc3,DES_ENCRYPT);
}              
</code></pre>
","4386","<java><c++><encryption><openssl><des>","2","2","3","2012-09-25 13:00:02","9078993","6","4","705545","","2012-01-31 07:39:28","2012-01-27 18:35:06",""
"9038298","Java DESede encrypt, OpenSSL equivalent","<p></p>

<p>I'm using DESede encryptation in Java and I want to make the same encryptation using  the OpenSSL's API in C++.</p>

<p>Java code:</p>

<pre><code>    String secretKey = ""abcdefghijklmnopqrstuvwx"";

    byte[] bytes = secretKey.getBytes(""UTF-8"");
    SecretKey key = new SecretKeySpec(bytes, ""DESede"");

    Cipher ecipher = Cipher.getInstance(""DESede"");
    ecipher.init(Cipher.ENCRYPT_MODE, key);

    String input = ""holahola1""; 

    byte[] utf8 = input.getBytes(""UTF8"");
    byte[] enc = ecipher.doFinal(utf8); // Encrypt
</code></pre>

<p>output: [94, -45, 64, -105, 99, -55, 99, -42, 95, 122, 72, 117, -119, 95, -43, 40]</p>

<p>C++ code:</p>

<pre><code>    unsigned char intext[256], outtext[256];

    memset(intext, 0, sizeof(intext));
    memset(outtext, 0, sizeof(outtext));

    char *output = (char *)outtext;
    DES_key_schedule keyschedc1;
    DES_key_schedule keyschedc2;
    DES_key_schedule keyschedc3;
    DES_cblock keyc1;
    DES_cblock keyc2;
    DES_cblock keyc3;

    DES_string_to_key(""abcdefgh"", &amp;keyc1);
    DES_string_to_key(""ijklmnop"", &amp;keyc2);
    DES_string_to_key(""qrstuvwx"", &amp;keyc3);
    DES_set_key((DES_cblock *)keyc1, &amp;keyschedc1);
    DES_set_key((DES_cblock *)keyc2, &amp;keyschedc2);
    DES_set_key((DES_cblock *)keyc3, &amp;keyschedc3); 

    strcpy((char *)intext, ""holahola1"");

    for (int i=0; i&lt;16; i += 8)
    {
        DES_ecb3_encrypt((DES_cblock *)(intext + i),
                        (DES_cblock *)(outtext + i), 
                        &amp;keyschedc1, &amp;keyschedc2, 
                        &amp;keyschedc3,DES_ENCRYPT);
    }              
</code></pre>

<p>output: [30 55 9 -58 -18 -65 -66 123 -32 72 30 110 120 69 101 -81]</p>

<p>What's wrong? Can someone help me? Thanks!.</p>
","<pre><code>byte[] bytes = secretKey.getBytes(""UTF-8"");
SecretKey key = new SecretKeySpec(bytes, ""**DESede/PKCS#5**"");
</code></pre>
","4386","<java><c++><encryption><openssl><des>","2","1","3","2012-09-25 13:00:02","9078993","6","4","705545","","2012-01-31 07:39:28","2012-01-27 18:35:06",""
"20943305","MIFARE DESFire EV1 Authentication Issue","<p>I've been trying to authenticate with a MIFARE DESFire EV1 card with the default key (00000000h) for the last week to no avail. I have followed <a href=""http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/"" rel=""nofollow noreferrer"">this blog</a>'s instructions to the letter. I implemented <code>Send mode CBC</code> and <code>Receive mode CBC</code> like this:</p>

<pre><code>var
  SendVector, ReceiveVector: UInt64;

procedure ResetVectors;
begin
  SendVector := 0;
  ReceiveVector := 0;
end;

procedure Encrypt(var Data: TBytes; Key: TBytes);
var
  iData, iKey: UInt64;
  i: Integer;
begin
  if Length(Data) mod 8 &gt; 0 then
    SetLength(Data, Length(Data) + (8 - Length(Data) mod 8));

  Move(Key[0], iKey, 8);
  for i := 0 to (Length(Data) - 1) div 8 do
  begin
    Move(Data[i * 8], iData, 8);
    EncryptInt64(iData, iKey);
    Move(iData, Data[i * 8], 8);
  end;
end;

procedure EncryptInt64(var Data, Key: Int64);
begin
  Data := Data xor SendVector;
  DESEncrypt(@Data, @Key);
  SendVector := Data;
end;

procedure Decrypt(var Data: TBytes; Key: TBytes);
var
  iData, iKey: UInt64;
  i: Integer;
begin
  Move(Key[0], iKey, 8);
  for i := 0 to (Length(Data) - 1) div 8 do
  begin
    Move(Data[i * 8], iData, 8);
    DecryptInt64(iData, iKey);
    Move(iData, Data[i * 8], 8);
  end;
end;

procedure DecryptInt64(var Data, Key: Int64);
var
  Tmp: UInt64;
begin
  Tmp := ReceiveVector;
  ReceiveVector := Data;
  DESDecrypt(@Data, @Key);
  Data := Data xor Tmp;
end;
</code></pre>

<p>This is the log of APDU commands I sent to the card, and their corresponding responses:</p>

<pre><code>--&gt;90 6A 00 00 00 // List Applications
&lt;--01 02 03 
&lt;--9100 (OK)

--&gt;90 5A 00 00 03 00 00 00 00 // Select PICC
&lt;--9100 (OK)

--&gt;90 1A 00 00 01 00 00 // ISO Authenticate with master key (00000000h)
&lt;--91AF

--&gt;90 AF 00 00 00 // Retreive RndB
&lt;--A4 4C 2B D1 EB 6F 64 0C 
&lt;--9100 (OK)

--&gt;90 AF 00 00 10 0D 9F 27 9B A5 D8 72 60 25 DD 7A 19 63 0F 26 2D 00 // Send DES(RndA + RndB')
&lt;--91AE (AUTHENTICATION_FAILURE)
</code></pre>

<p>Here is the whole code of my <code>Authenticate</code> method:</p>

<pre><code>procedure Authenticate;
var
  Key, Data: TBytes;
  s: string;
  b: Byte;
  RndA: UInt64;
  i: Integer;
begin
  ResetVectors;
  Key := HexStringToBuffer('00 00 00 00 00 00 00 00');
  s := '90 1A 00 00 01 00 00';
  s := SendAPDU(s, False);
  Data := HexStringToBuffer(s);
  Decrypt(Data, Key);

  b := Data[0];
  for i := 0 to 6 do
    Data[i] := Data[i + 1];
  Data[7] := b;

  RndA := 1; // not very wise

  SetLength(Data, 16);
  Move(Data[0], Data[8], 8);
  Move(RndA, Data[0], 8);

  Encrypt(Data, Key);
  s := '90 AF 00 00 10 ' + BufferToHexString(Data) + ' 00';
  SendAPDU(s, False);
end;
</code></pre>

<p>I'm lost as to why the card is rejecting my authentication attempt flatly. Any thoughts?</p>

<hr>

<p>Here's the diagram of CBC Send and CBC Receive algorithms as per DESFire EV1 manufacturer instructions:
<img src=""https://i.stack.imgur.com/02fJK.png"" alt=""CBC Send"">
<img src=""https://i.stack.imgur.com/3Bt14.png"" alt=""CBC Receive""></p>
","<p>Try replace encrypt to decrypt in DES cipher. Card ALWAYS uses DES ENCRYPT mode (both when recieving and sending data). And the host ALWAYS uses DECRYPT mode.</p>

<p>For more info: 
<a href=""https://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/#comment-30"" rel=""nofollow"">https://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/#comment-30</a></p>
","4160","<delphi><nfc><delphi-xe5><des><mifare>","2","3","2","2016-07-11 12:57:16","","4","1","1629919","","2014-01-06 06:36:53","2014-01-06 05:05:33",""
"20943305","MIFARE DESFire EV1 Authentication Issue","<p>I've been trying to authenticate with a MIFARE DESFire EV1 card with the default key (00000000h) for the last week to no avail. I have followed <a href=""http://ridrix.wordpress.com/2009/09/19/mifare-desfire-communication-example/"" rel=""nofollow noreferrer"">this blog</a>'s instructions to the letter. I implemented <code>Send mode CBC</code> and <code>Receive mode CBC</code> like this:</p>

<pre><code>var
  SendVector, ReceiveVector: UInt64;

procedure ResetVectors;
begin
  SendVector := 0;
  ReceiveVector := 0;
end;

procedure Encrypt(var Data: TBytes; Key: TBytes);
var
  iData, iKey: UInt64;
  i: Integer;
begin
  if Length(Data) mod 8 &gt; 0 then
    SetLength(Data, Length(Data) + (8 - Length(Data) mod 8));

  Move(Key[0], iKey, 8);
  for i := 0 to (Length(Data) - 1) div 8 do
  begin
    Move(Data[i * 8], iData, 8);
    EncryptInt64(iData, iKey);
    Move(iData, Data[i * 8], 8);
  end;
end;

procedure EncryptInt64(var Data, Key: Int64);
begin
  Data := Data xor SendVector;
  DESEncrypt(@Data, @Key);
  SendVector := Data;
end;

procedure Decrypt(var Data: TBytes; Key: TBytes);
var
  iData, iKey: UInt64;
  i: Integer;
begin
  Move(Key[0], iKey, 8);
  for i := 0 to (Length(Data) - 1) div 8 do
  begin
    Move(Data[i * 8], iData, 8);
    DecryptInt64(iData, iKey);
    Move(iData, Data[i * 8], 8);
  end;
end;

procedure DecryptInt64(var Data, Key: Int64);
var
  Tmp: UInt64;
begin
  Tmp := ReceiveVector;
  ReceiveVector := Data;
  DESDecrypt(@Data, @Key);
  Data := Data xor Tmp;
end;
</code></pre>

<p>This is the log of APDU commands I sent to the card, and their corresponding responses:</p>

<pre><code>--&gt;90 6A 00 00 00 // List Applications
&lt;--01 02 03 
&lt;--9100 (OK)

--&gt;90 5A 00 00 03 00 00 00 00 // Select PICC
&lt;--9100 (OK)

--&gt;90 1A 00 00 01 00 00 // ISO Authenticate with master key (00000000h)
&lt;--91AF

--&gt;90 AF 00 00 00 // Retreive RndB
&lt;--A4 4C 2B D1 EB 6F 64 0C 
&lt;--9100 (OK)

--&gt;90 AF 00 00 10 0D 9F 27 9B A5 D8 72 60 25 DD 7A 19 63 0F 26 2D 00 // Send DES(RndA + RndB')
&lt;--91AE (AUTHENTICATION_FAILURE)
</code></pre>

<p>Here is the whole code of my <code>Authenticate</code> method:</p>

<pre><code>procedure Authenticate;
var
  Key, Data: TBytes;
  s: string;
  b: Byte;
  RndA: UInt64;
  i: Integer;
begin
  ResetVectors;
  Key := HexStringToBuffer('00 00 00 00 00 00 00 00');
  s := '90 1A 00 00 01 00 00';
  s := SendAPDU(s, False);
  Data := HexStringToBuffer(s);
  Decrypt(Data, Key);

  b := Data[0];
  for i := 0 to 6 do
    Data[i] := Data[i + 1];
  Data[7] := b;

  RndA := 1; // not very wise

  SetLength(Data, 16);
  Move(Data[0], Data[8], 8);
  Move(RndA, Data[0], 8);

  Encrypt(Data, Key);
  s := '90 AF 00 00 10 ' + BufferToHexString(Data) + ' 00';
  SendAPDU(s, False);
end;
</code></pre>

<p>I'm lost as to why the card is rejecting my authentication attempt flatly. Any thoughts?</p>

<hr>

<p>Here's the diagram of CBC Send and CBC Receive algorithms as per DESFire EV1 manufacturer instructions:
<img src=""https://i.stack.imgur.com/02fJK.png"" alt=""CBC Send"">
<img src=""https://i.stack.imgur.com/3Bt14.png"" alt=""CBC Receive""></p>
","<p>During an ISO or AES authentication the following scheme is used:</p>

<ol>
<li>Random B is received from the card with RECEIVE + DECIPHER</li>
<li>Random AB is sent to the card with SEND + ENCIPHER</li>
<li>Random A is received with RECEIVE + DECIPHER</li>
</ol>

<p><strong>IMPORTANT</strong>: ALL encryption goes through CBC. The <strong>IV</strong> of the key used for CBC encryption/decryption is only reset ONCE at the beginning. Then it must be maintained up to date during ALL the following commands.</p>

<p>If you use ISO or AES mode, after a successfull authentication, you MUST also calulcate the CMAC over sent commands and received data, otherwise your IV will not be in sync with the card and you get an Integrity Error each time you use the Session key!</p>

<p>As I was struggeling with the same problems I posted some communication examples that will help you much in testing your code. You find them here on Stackoverflow: <a href=""https://stackoverflow.com/questions/38283998/desfire-ev1-communication-examples"">Desfire EV1 communication examples</a> There you also find a link to my source code that I recommnd you to study.</p>
","4160","<delphi><nfc><delphi-xe5><des><mifare>","2","0","2","2016-07-11 12:57:16","","4","1","1629919","","2014-01-06 06:36:53","2014-01-06 05:05:33",""
"6966419","ISO 9797 padding method 2 and MAC generation in java","<p>I'm hoping that some of you may be able to help me on this issue.</p>

<p>I've used the SmartCardShell program to run a javascript code that extracts the data off a British e-Passport.</p>

<p>I'm trying to replicate the code in java for my dissertation. However I am stumped on the MAC generation. </p>

<p>The javascript code for the data encryption and MAC generation is:</p>

<pre><code>var cryptogram = crypto.encrypt(kenc, Crypto.DES_CBC, plain, new ByteString(""0000000000000000"", HEX));
print(""Cryptogram   : "" + cryptogram);'

var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, cryptogram.pad(Crypto.ISO9797_METHOD_2));
print(""MAC          : "" + mac);
</code></pre>

<p>I've managed to correctly verify that my encryption key (Kenc) is generated correctly.</p>

<p>Going off the script code, the MAC key (Kmac) is also a triple DES key which is done via:</p>

<pre><code>byte[] kmackey = new byte[24];
System.arraycopy(kmac, 0, kmackey, 0, kmac.length);
System.arraycopy(kmac, 0, kmackey, kmac.length, 8);
System.out.println(""kmackey = "" + ConvertToHex.convertToHex(kmackey));

DESedeKeySpec desedekey = new DESedeKeySpec(kmackey);
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DESede"");
Key KMac = keyFactory.generateSecret(desedekey);
</code></pre>

<p>As seen above, the javascript code ""signs"" the data with the Kmac key, the DES_MAC_EMV mechanism and pads the cryptogram data with the ISO 9797 padding method 2 - which I believe is called ""bit padding"".</p>

<p>Can anyone assist me in creating/explaining to me a Java equivalent of the DES_MAC_EMV mechanism and the ISO 9797 padding method 2?</p>

<p>Appreciate the help</p>

<p>Just to add as I forgot to mention it, I am creating a system to connect to the e-Passport and extract data. At the minute I am verifying the data I obtained from the SmartCardShell program/javascript code. This is not a javacard applet/application, it is solely a Java ""host"" application</p>

<p>HSK</p>
","<h3>Padding</h3>

<p>Padding is actually very simple. Some places refer to the padding method 2 of ISO 9797-1 as <em>Bit Padding</em>. You basically add a single 0x80 byte at the end and then append sufficient number of 0x00 so that the total length of the message is a multiple of 8.</p>

<h3>Encryption</h3>

<p>DES_MAC_EMV in the above code is more formally named <strong>ISO 9797-1 Algorithm 3</strong>. Some articles/ websites also refer to it as <em>Retail MAC algorithm</em>.</p>

<p>You need two 8 byte keys for this algorithm and perform 3DES as defined below. Please note that this is my understanding of the algorithm (off-my-head); please read the formal specs for a ""correct"" understanding:</p>

<ol>
<li>First do the required padding</li>
<li>Use an initialisation vector of 0 (all zeroes)</li>
<li>Chain and encrypt 8 bit blocks using the first key (as in
single DES)</li>
<li>The final block needs a 3DES application; hence decrypt using the second key and encrypt it with the first key again</li>
</ol>
","4141","<java><macos><des><3des>","0","1","1","2011-08-11 11:00:29","","0","","","","","2011-08-06 11:12:18",""
"11102449","How to find the correct OpenSSL EVP key length for DES3 encryption","<p>I'm trying to implement a <a href=""http://en.wikipedia.org/wiki/Hybrid_cryptosystem"" rel=""nofollow"">hybrid cryptosystem</a> (<strong>RSA</strong> for key envelope, and <strong>DES3 (with two-key option</strong>) for data envelope). Thus, I'm trying first to implement DES3 with Openssl's <code>EVP</code> functions. Because it seems I can easily use EVP to combine RSA and DES3 encryption. </p>

<p>I've got this example code (changed data types to fix gcc warnings and put snippets in one file) from the Openssl book:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/rand.h&gt;

unsigned char *encrypt_example(EVP_CIPHER_CTX *ctx, unsigned char *data, int inl, int *rb);
unsigned char *decrypt_example(EVP_CIPHER_CTX *ctx, unsigned char *ct, int inl);
void select_random_key(unsigned char *key, int b);
void select_random_iv(unsigned char *iv, int b);
int seed_prng(int bytes);


int main(int argc, char *argv[])
{
    EVP_CIPHER_CTX ctx;
    EVP_CIPHER_CTX_init(&amp;ctx);

    unsigned char key[EVP_MAX_KEY_LENGTH];
    unsigned char iv[EVP_MAX_IV_LENGTH];
    unsigned char *ct, *out;
    unsigned char final[EVP_MAX_BLOCK_LENGTH];
    unsigned char str[] = ""123456789abcdef"";
    int i = 0;

    if (!seed_prng(16))
    {
        printf(""Fatal Error! Unable to seed the PRNG!\n"");
        abort();
    }

    select_random_key(key, EVP_MAX_KEY_LENGTH);
    select_random_iv(iv, EVP_MAX_IV_LENGTH);


    /* EVP_des_ede3()       :three-key DES3 with ECB
     * EVP_des_ede()        :two-key DES3 with ECB
     * EVP_des_ede_cbc()    :two-key DES3 with CBC 
     * EVP_des_ede3_cbc()   :three-key DES3 with CBC */

    EVP_EncryptInit(&amp;ctx, EVP_des_ede_cbc(), key, NULL);
    ct = encrypt_example(&amp;ctx, str, strlen((const char*)str), &amp;i);
    printf(""Ciphertext is %d bytes.\n"", i);

    EVP_DecryptInit(&amp;ctx, EVP_des_ede_cbc(), key, NULL);
    out = decrypt_example(&amp;ctx, ct, 8);
    printf(""Decrypted: &gt;&gt;%s&lt;&lt;\n"", out);
    out = decrypt_example(&amp;ctx, ct + 8, 8);
    printf(""Decrypted: &gt;&gt;%s&lt;&lt;\n"", out);

    if (!EVP_DecryptFinal(&amp;ctx, final, &amp;i))
    {
        printf(""Padding incorrect.\n"");
        abort();
    }

    final[i] = 0;
    printf(""Decrypted: &gt;&gt;%s&lt;&lt;\n"", final);
    return 0;
}

int seed_prng(int bytes)
{
    if (!RAND_load_file(""/dev/random"", bytes))
        return 0;
    return 1;
}

void select_random_key(unsigned char *key, int b)
{
    int i;

    RAND_bytes(key, b);
    for (i = 0; i &lt; b - 1; i++)
        printf(""%02X:"",key[i]);
    printf(""%02X\n\n"", key[b - 1]);
}

void select_random_iv (unsigned char *iv, int b)
{
    RAND_pseudo_bytes (iv, b);
}

unsigned char *encrypt_example(EVP_CIPHER_CTX *ctx, unsigned char *data, int inl, int *rb)
{
    unsigned char *ret = (unsigned char *)malloc(inl + EVP_CIPHER_CTX_block_size(ctx));
    int i, tmp, ol;

    ol = 0;
    for (i = 0; i &lt; inl /100; i++)
    {
        EVP_EncryptUpdate(ctx, &amp;ret[ol], &amp;tmp, &amp;data[ol], 100);
        ol += tmp;
    }

    if (inl % 100)
    {
        EVP_EncryptUpdate(ctx, &amp;ret[ol], &amp;tmp, &amp;data[ol], inl%100);
        ol += tmp;
    }

    EVP_EncryptFinal(ctx, &amp;ret[ol], &amp;tmp);
    *rb = ol + tmp;
    return ret;
}

unsigned char *decrypt_example(EVP_CIPHER_CTX *ctx, unsigned char *ct, int inl)
{

    /* We're going to null-terminate the plaintext under the assumption it's
     * non-null terminated ASCII text. The null can be ignored otherwise.
     */
    unsigned char *pt = (unsigned char *)malloc(inl + EVP_CIPHER_CTX_block_size(ctx) + 1);
    int ol;

    EVP_DecryptUpdate(ctx, pt, &amp;ol, ct, inl);
    if (!ol) /* there's no block to decrypt */
    {
        free(pt);
        return NULL;
    }

    pt[ol] = 0;
    return pt;
}
</code></pre>

<p>I'm compiling it with this </p>

<pre><code>gcc -g -O0 -Wall evp_encrypt_decrypt.c  -o evp_encrypt_decrypt -lssl -lcrypto
</code></pre>

<p>Now if I execute this i get this output:</p>

<pre><code>13:98:EB:64:D5:8B:1E:0A:70:1D:28:9D:25:3A:13:40:FE:C1:81:3C:C5:8F:4B:F6:66:1A:07:F8:17:D6:10:B6:4E:BC:45:96:00:A1:9F:59:44:A0:43:D9:9D:DD:C8:A9:0B:22:EC:7B:F2:5F:78:01:D1:58:6D:0B:B4:CB:5F:CD 

Ciphertext is 16 bytes.
Decrypted: &gt;&gt;(null)&lt;&lt;
Decrypted: &gt;&gt;12345678&lt;&lt;
Decrypted: &gt;&gt;9abcdef&lt;&lt;
</code></pre>

<p>Here it says that the the chipertext is 16 bytes (which is ok). But the key itself(hex code printed above) is <strong>64 bytes long!</strong> </p>

<p>However, DES3 with two-key options should have key length with 128 bits (including parity bits). However the <strong>EVP_MAX_KEY_LENGTH</strong> definition is by default <strong>64</strong>. Also I've tried to print  the chiper key length, the size of variable <code>key</code> and the ctx key size as seen below:</p>

<pre><code>printf(""Key length DES3: %d\n"", EVP_CIPHER_key_length(EVP_des_ede3_cbc()));
printf(""Key size: %d\n"", sizeof(key));
printf(""Cipher CTX key length: %d\n\n"", EVP_CIPHER_CTX_key_length(&amp;ctx));
</code></pre>

<p>This will output:</p>

<pre><code>Key length DES3: 24
Key size: 64
Cipher CTX key length: 16
</code></pre>

<p>I'm a little bit confused here. Shouldn't be the DES3(two-key) key size 128 bits? Why is the length of DES3 key printed as 24(is this bit,byte,etc..)? Why are all these key lengths and sizes different?</p>
","<blockquote>
  <p>However, DES3 with two-key options should have key length with 128 bits (including parity bits)</p>
</blockquote>

<p>Yes. 2-key 3DES has a key size of 64x2 = 128-bits; and 3-key 3DES has a key size of 64x3 = 192-bits (as Greg S stated).</p>

<blockquote>
  <p>However the EVP_MAX_KEY_LENGTH definition is by default 64</p>
</blockquote>

<p>That's the maximum it can be (for all EVP symmetric ciphers), and not just DES/3DES/AES, etc. That value might even change in the future.</p>

<blockquote>
  <p>Shouldn't be the DES3 (two-key) key size 128 bits?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>Why is the length of DES3 key printed as 24 (is this bit, byte, etc..)?</p>
</blockquote>

<p>Who knows.... but its in bytes, not bits.</p>

<blockquote>
  <p>Why are all these key lengths and sizes different?</p>
</blockquote>

<p>The size is based on the algorithm or cryptosystem.</p>

<p>2-key 3DES performs Encrypt-Decrypt-Encrypt and uses two keys. So one of the keys is used twice. 3-key 3DES performs Encrypt-Decrypt-Encrypt and uses three independent keys. That's how they were designed.</p>
","4117","<encryption><openssl><rsa><des>","1","0","1","2014-04-20 12:12:50","","8","","","","","2012-06-19 13:51:01",""
"9696170","VB.Net DES encryption function, to Triple DES","<pre><code>Public Shared Function DESEncrypt(ByVal Data As String, ByVal Key As String) As Byte()
    Dim IV() As Byte = {&amp;H12, &amp;H34, &amp;H56, &amp;H78, &amp;H90, &amp;HAB, &amp;HCD, &amp;HEF}
    Try
        Dim bykey() As Byte = System.Text.Encoding.UTF8.GetBytes(Left(Key, 8))
        Dim InputByteArray() As Byte = System.Text.Encoding.UTF8.GetBytes(Data)
        Dim des As New DESCryptoServiceProvider
        Dim ms As New MemoryStream
        Dim cs As New CryptoStream(ms, des.CreateEncryptor(bykey, IV), CryptoStreamMode.Write)
        cs.Write(InputByteArray, 0, InputByteArray.Length)
        cs.FlushFinalBlock()
        Return ms.ToArray()
    Catch ex As Exception
    End Try
End Function
</code></pre>

<p>this is what I currently have for my DES encryption, but as I am fairly new to VB.Net I can figure out how to make it use Triple DES rather than DES</p>
","<p>Try this</p>

<pre><code>       Public Shared Function DESEncrypt(ByVal Data As String, ByVal Key As String) As Byte()
    Dim IV() As Byte = {&amp;H12, &amp;H34, &amp;H56, &amp;H78, &amp;H90, &amp;HAB, &amp;HCD, &amp;HEF}
    Try
        Dim bykey() As Byte = System.Text.Encoding.UTF8.GetBytes(Left(Key, 24))


        If String.IsNullOrEmpty(Data) Then

            Throw New ArgumentException(""No data passed"", ""input"")

        ElseIf bykey Is Nothing OrElse bykey.Length &lt;&gt; 24 Then

            Throw New ArgumentException(""Invalid Key. Key must be 24 bytes length"", ""key"")

        End If

        Dim InputByteArray() As Byte = System.Text.Encoding.UTF8.GetBytes(Data)

        Using ms As New IO.MemoryStream

            Using des As New Security.Cryptography.TripleDESCryptoServiceProvider


                Using cs As New Security.Cryptography.CryptoStream(ms, des.CreateEncryptor(bykey, IV), Security.Cryptography.CryptoStreamMode.Write)

                    cs.Write(InputByteArray, 0, InputByteArray.Length)
                    cs.FlushFinalBlock()
                    Return ms.ToArray()

                End Using

            End Using

        End Using

    Catch ex As Exception
    End Try

End Function
</code></pre>
","4104","<vb.net><encryption><des><tripledes>","0","1","1","2012-03-14 05:40:41","9696259","0","","","","","2012-03-14 04:57:22",""
"9182004","DES - Permutation of bits and inverse","<p>I am currently trying to make an implementation of the encryption scheme DES but I've run into a problem early on. This is the first time I have ever performed bitwise manipulations in a program and I am not very proficient with C either. I apply a permutation and its inverse and the result is not the same as the input.</p>

<p>What I am trying to do is to apply the initial permutation and inverse permutation on a block of 64 bits. I have my block of 64 bits that I want to encrypt in the array input. According to the permutation table IP I take the first bit in the first byte and put it as bit 58 in the permutation. Bit 2 is sent to bit 50 and so on. After the permutation the result is divided in half and the sides swapped. This will enable it to be put back using the same algorithm but with the IPinverse table.</p>

<pre><code>include &lt;stdio.h&gt;
include &lt;stdlib.h&gt;

static unsigned char Positions[8] = {1,2,4,8,16,32,64,128};

int main()
{
  unsigned char input[8] = {'a','b','c','d','e','f','g','h'};
  unsigned char permutation[8];
  unsigned char inverse[8];
  int i;
  for (i = 0; i &lt; 8; i++) {
        permutation[i] = 0;
        inverse[i] = 0;
  }

  int IP[8][8] ={{58,50,42,34,26,18,10,2},
                          {60,52,44,36,28,20,12,4},
                          {62,54,46,38,30,22,14,6},
                          {64,56,48,40,32,24,16,8},
                          {57,49,41,33,25,17, 9, 1},
                          {59,51,43,35,27,19,11,3},
                          {61,53,45,37,29,21,13,5},
                          {63,55,47,39,31,23,15,7}};

  int IPinverse[8][8] ={{40,8,48,16,56,24,64,32},
                                      {39,7,47,15,55,23,63,31},
                                      {38,6,46,14,54,22,62,30},
                                      {37,5,45,13,53,21,61,29},
                                      {36,4,44,12,52,20,60,28},
                                      {35,3,43,11,51,19,59,27},
                                      {34,2,42,10,50,18,58,26},
                                      {33, 1,41, 9,49,17,57,25}};

  printf(""\n Before: \n"");
  for (i = 0; i &lt; 8; i++) {
        printf("" %c"", input[i]);
  }

  // Initial permutation
  int bit, newpos;
  unsigned char desiredbit;
  for (bit = 0; bit &lt; 64; bit++) {
        // Get the location for where the bit will be sent and translate it to array index
        newpos = ((int)IP[bit/8][bit%8])-1;
        // examine the bit we're currently considering
        desiredbit = input[bit/8] &amp; Positions[bit%8];
        // if equal to zero that means no change necessary
        if (desiredbit != 0) {
              // else it was a 1 and we need to set the appropriate bit to 1
              desiredbit = Positions[newpos%8];
              permutation[newpos/8] = desiredbit ^ permutation[newpos/8];
        }
  }

  printf(""\n Permutation: \n"");
  for (i = 0; i &lt; 8; i++) {
        printf("" %c"", permutation[i]);
  }

  // Perform swap
  unsigned char tempcopy[4] = {0,0,0,0};
  int j;
  for (j = 0; j &lt; 4; j++) {
        tempcopy[j] = permutation[j+4];
  }
  for (j = 0; j &lt; 4; j++) {
        permutation[j+4] = permutation[j];
        permutation[j] = tempcopy[j];
  }

  // Reverse Permutation, remember to swap left side with right
  for (bit = 0; bit &lt; 64; bit++) {
        newpos = ((int)IPinverse[bit/8][bit%8])-1;
        desiredbit = permutation[bit/8] &amp; Positions[bit%8];
        if (desiredbit != 0) {
              desiredbit = Positions[newpos%8];
              inverse[newpos/8] = desiredbit ^ inverse[newpos/8];
        }
  }

 printf(""\n Reverse Permutation: \n"");
  for (i = 0; i &lt; 8; i++) {
        printf("" %c"", inverse[i]);
  }

  return 0;
</code></pre>

<p>}</p>
","<ol>
<li><strike>Your permutation contains indexes from 1 to 64, but the way you use them, they should be 0 to 63.</strike></li>
<li>What's the swap for? If you permute, swap, then permute back, you won't reach the same place.</li>
<li><strike>You need to verify that the permutation and reverse are indeed opposites. I'm surely not going to go over all the numbers and verify it.</strike></li>
</ol>
","4081","<c><bit-manipulation><des>","2","1","1","2012-02-07 19:42:58","9182246","1","","","","","2012-02-07 18:48:16",""
"8803077","Java encryption with PBEWithMD5AndDES algorithm","<p>I am trying to do some encryption stuff between a Java server and Android client. After some research, And</p>

<p>Here are my encryption settings:</p>

<pre><code>public static String encryptionAlgoirthm = ""DES"";
public static short encryptionBitCount = 128;
public static String hashingAlgorithm = ""PBEWithMD5AndDES"";
public static short hashingCount = 512;
public static String cipherTransformation = ""DES/CBC/PKCS5Padding"";
</code></pre>

<p>But when trying to run the server on my CentOS VPS I get the following: </p>

<p><code>Algorithm [PBEWithMD5AndDES] of type [SecretKeyFactory] from provider [gnu.javax.security.auth.callback.GnuCallbacks: name=GNU-CALLBACKS version=2.1] is not found.</code></p>

<p>Here is the code:</p>

<pre><code>    KeySpec keySpec = new PBEKeySpec(EncryptionSettings.password, EncryptionSettings.salt, EncryptionSettings.hashingCount, EncryptionSettings.encryptionBitCount);
    SecretKey tmpKey = null;

    try
    {
        tmpKey = SecretKeyFactory.getInstance(EncryptionSettings.hashingAlgorithm).generateSecret(keySpec);
    }
    catch (final InvalidKeySpecException e)
    {
        Console.writeFatalError(""Unable to generate key: invalid key specification"");
    } 
    catch (final NoSuchAlgorithmException e)
    {
        Console.writeFatalError(""Unable to generate key: encryption algorithm not supported - "" + e.getMessage());
    }
</code></pre>

<p>How do I fix this?</p>
","<p>Looks like you are using the GNU JRE and it doesn't have a JCE in it. You can solve this by downloading the <a href=""http://www.bouncycastle.org/java.html"" rel=""nofollow"">bouncy castle</a> JCE and add it as a provider;</p>

<pre><code>Security.addProvider(new BouncyCastleProvider());
</code></pre>

<p>Note also that your <code>encryptionBitCount</code> looks suspicious as DES has a fixed key sice of 56 bits.</p>

<p>DES and MD5 are considered obsolete, you might want to try AES for the cipher and SHA for the hashing instead. The bouncy castle API provides an algorithm <code>PBEWITHSHAAND128BITAES-CBC-BC</code> which might do the trick.</p>
","3979","<java><android><encryption><des>","2","1","1","2012-01-10 12:32:49","8803321","1","1","","","","2012-01-10 12:11:21",""
"1615252","DES Initialization Vector in C#","<p>I am trying to decrypt (using the DES algorithm) data that comes from a third party in C# code. There are plenty of examples here and elsewhere that have helped me out. The problem is that I don't know what to use for the 'initialization vector'. </p>

<p>The third party supplied a tool for use on the command line (DES.EXE, which I believe is an out-of-the-box build of the libdes library v4.01) which only requires that you supply an encryption key. So, I can decrypt fine with the tool. However, I would rather not spawn a process to run the tool from my code.</p>

<p>My question is how do I generate/find that initialization vector. I am 99.9% sure it can be done from looking at other posts but I can't figure it out. I talked to the third party and they said they do not support that approach. Any help would be greatly appreciated.</p>
","<p>See <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation</a> for a description of the different modes of operation used in block ciphers. You don't need an initialization vector (IV) if you're using ECB mode which is just encrypting the message block by block. Maybe you have to check your DES library for setting ECB mode / disabling others.</p>

<p>If they aren't using ECB mode you need the IV, you can't ""guess"" it. The IV in most cases doesn't has to be secret, so it's not a problem to move it around.</p>
","3941","<c#><encryption><des>","4","0","2","2016-12-14 14:33:52","","5","1","","","","2009-10-23 18:46:00",""
"1615252","DES Initialization Vector in C#","<p>I am trying to decrypt (using the DES algorithm) data that comes from a third party in C# code. There are plenty of examples here and elsewhere that have helped me out. The problem is that I don't know what to use for the 'initialization vector'. </p>

<p>The third party supplied a tool for use on the command line (DES.EXE, which I believe is an out-of-the-box build of the libdes library v4.01) which only requires that you supply an encryption key. So, I can decrypt fine with the tool. However, I would rather not spawn a process to run the tool from my code.</p>

<p>My question is how do I generate/find that initialization vector. I am 99.9% sure it can be done from looking at other posts but I can't figure it out. I talked to the third party and they said they do not support that approach. Any help would be greatly appreciated.</p>
","<p>I spent some time (~2 days) to sort out the same issue. ""Rewriting"" des.exe into C#. In the end I got the libdes sources and reverse-engineered the logic.</p>

<p>The initialization vector are all (8) zeros. I.e. new byte[8] should do. </p>

<p>However, the trick may be how to convert a string password into 8 bytes long key. If you're using simple DES (not Triple DES), this code may do the trick for you:</p>

<pre><code>public class LibDesPasswordConvertor
{
    public byte[] PasswordToKey(string password)
    {
        if (password == null)
            throw new ArgumentNullException(""password"");
        if (password == """")
            throw new ArgumentException(""password"");

        var key = new byte[8];

        for (int i = 0; i &lt; password.Length; i++)
        {
            var c = (int)password[i];
            if ((i % 16) &lt; 8)
            {
                key[i % 8] ^= (byte)(c &lt;&lt; 1);
            }
            else
            {
                // reverse bits e.g. 11010010 -&gt; 01001011
                c = (((c &lt;&lt; 4) &amp; 0xf0) | ((c &gt;&gt; 4) &amp; 0x0f));
                c = (((c &lt;&lt; 2) &amp; 0xcc) | ((c &gt;&gt; 2) &amp; 0x33));
                c = (((c &lt;&lt; 1) &amp; 0xaa) | ((c &gt;&gt; 1) &amp; 0x55));
                key[7 - (i % 8)] ^= (byte)c;
            }
        }

        AddOddParity(key);

        var target = new byte[8];
        var passwordBuffer =
            Encoding.ASCII.GetBytes(password).Concat(new byte[8]).Take(password.Length + (8 - (password.Length % 8)) % 8).ToArray();

        var des = DES.Create();
        var encryptor = des.CreateEncryptor(key, key);
        for (int x = 0; x &lt; passwordBuffer.Length / 8; ++x)
        {
            encryptor.TransformBlock(passwordBuffer, 8 * x, 8, target, 0);
        }

        AddOddParity(target);

        return target;
    }


    private void AddOddParity(byte[] buffer)
    {
        for (int i = 0; i &lt; buffer.Length; ++i)
        {
            buffer[i] = _oddParityTable[buffer[i]];
        }
    }

    private static byte[] _oddParityTable = {
          1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
         16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
         32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
         49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
         64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
         81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
         97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
        112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
        128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
        145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
        161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
        176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
        193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
        208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
        224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
        241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254};
}
</code></pre>

<p>(Some pieces of libdes code reused, though I had to figure out the DES ""checksum"" part myself).</p>

<p>The last pitfall is, that libdes uses non-standard padding mechanism. It's almost like the ISO one, but the last byte is not the number of added bytes but 8 - this number. I set the Padding property to None and handled the padding myself.</p>
","3941","<c#><encryption><des>","4","1","2","2016-12-14 14:33:52","","5","1","","","","2009-10-23 18:46:00",""
"21641921","Decrypt file have bad data if wrong key","<p>I've code to decrypt file in DES Encryption, I try I keep getting the file even though I enter the key at the time when the key decrypt the encrypted differently. But i've get the error.</p>

<pre><code> while ((data = cryptostreamDecr.ReadByte()) != -1)  // Message Error : Bad Data.
</code></pre>

<p>Which code should I add or change in order to keep the process running decrypt?</p>

<pre><code>private static void DecryptFile(string sInputFilename, string sKey)
{
    var DES = new DESCryptoServiceProvider();
    DES.Key = Encoding.ASCII.GetBytes(sKey);
    DES.IV = Encoding.ASCII.GetBytes(sKey);
    ICryptoTransform desdecrypt = DES.CreateDecryptor();
     using (var fsread = new FileStream(sInputFilename, FileMode.Open,
                FileAccess.ReadWrite))
            {
                using (var cryptostreamDecr = new CryptoStream(fsread,
                    desdecrypt,
                    CryptoStreamMode.Read))
                {
                    int data;

                    fsread.Flush();

                    using (var ms = new MemoryStream())
                    {
                        while ((data = cryptostreamDecr.ReadByte()) != -1)
                        {
                            ms.WriteByte((byte)data);
                        }

                        cryptostreamDecr.Close();

                        using (var fsWrite = new FileStream(sInputFilename, FileMode.Truncate))
                        {
                            ms.WriteTo(fsWrite);
                            ms.Flush();
                        }
                    }
                }
            }
        }
</code></pre>

<p>Encrypt Code :</p>

<pre><code>public static void EncryptFile(string sInputFilename, string sKey)
        {
            FileStream fsInput = new FileStream(sInputFilename,
               FileMode.Open,
               FileAccess.ReadWrite);

            DESCryptoServiceProvider DES = new DESCryptoServiceProvider();
            DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey);
            DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey);
            ICryptoTransform desencrypt = DES.CreateEncryptor();
            CryptoStream cryptostream = new CryptoStream(fsInput,
               desencrypt,
               CryptoStreamMode.Write);

            byte[] bytearrayinput = new byte[fsInput.Length];
            fsInput.Read(bytearrayinput, 0, bytearrayinput.Length);
            fsInput.SetLength(0);
            cryptostream.Write(bytearrayinput, 0, bytearrayinput.Length);
            cryptostream.FlushFinalBlock();
            cryptostream.Close();
            fsInput.Close();
        }
</code></pre>

<p><strong>[EDIT]</strong> : remove in Encypt :</p>

<blockquote>
  <p>cryptostream.FlushFinalBlock();</p>
</blockquote>

<p>And add in decrypt</p>

<blockquote>
  <p>DES.Padding = PaddingMode.None;</p>
</blockquote>
","<p>64 bits is the only valid key size for the DES encryption algorithm.
8 bits is equal to one ASCII character means 64 bits is equal to 8 Characters.</p>

<p>If you send 8 characters only then check this (<a href=""https://stackoverflow.com/questions/5591361/c-sharp-bad-data-exception-when-decrypting-encrypted-file"">C# &quot;Bad Data&quot; exception when decrypting encrypted file</a>). It may solve your problem.</p>

<p><strong>[Edit]</strong>
Add <code>DES.Padding = PaddingMode.None;</code> in <code>DecryptFile</code>.</p>
","3919","<c#><encryption><des>","1","2","1","2014-02-08 09:56:38","21641963","0","","3143132","","2014-02-08 09:56:38","2014-02-08 04:33:10",""
"10784032","DES ECB C# encryption/decryption","<p>I have a problem with decryption of data previously encrypted. I am using the sequential encrypt-decrypt-encrypt with three different keys to get triple des effect. The encryption function works correctly (returns 8-byte array), but the decryption function returns empty array.</p>

<pre><code>    public static byte[] EncryptDES(byte[] clearData, byte[] key) 
    { 
        DES desEncrypt = new DESCryptoServiceProvider(); 
        desEncrypt.Mode = CipherMode.ECB; 
        desEncrypt.Key = key; 
        ICryptoTransform transForm = desEncrypt.CreateEncryptor(); 
        MemoryStream encryptedStream = new MemoryStream(); 
        CryptoStream cryptoStream = new CryptoStream(encryptedStream, transForm, CryptoStreamMode.Write); 
        cryptoStream.Write(clearData, 0, clearData.Length); 
        byte [] encryptedData = encryptedStream.ToArray(); 
        return encryptedData;
    }

    public static byte[] DecryptDES(byte[] clearData, byte[] key)
    {
        DES desDecrypt = new DESCryptoServiceProvider();
        desDecrypt.Mode = CipherMode.ECB;
        desDecrypt.Key = key;
        ICryptoTransform transForm = desDecrypt.CreateDecryptor();
        MemoryStream decryptedStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(decryptedStream, transForm, CryptoStreamMode.Write);
        cryptoStream.Write(clearData, 0, clearData.Length);
        byte[] encryptedData = decryptedStream.ToArray();
        return encryptedData;
    }

    public static byte[] Encrypt3DES(byte[] clearData, byte[] key0, byte[] key1, byte[] key2) 
    {
        byte[] encryptedData1 = new byte[clearData.Length];
        byte[] encryptedData2 = new byte[clearData.Length];
        byte[] encryptedData3 = new byte[clearData.Length];
        encryptedData1 = DESCrypto.EncryptDES(clearData    , key0);
        encryptedData2 = DESCrypto.DecryptDES(encryptedData1, key1);
        encryptedData3 = DESCrypto.EncryptDES(encryptedData2, key2);
        return encryptedData3;
    } 
</code></pre>

<p>What am I doing wrong?</p>
","<p><a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledes.aspx"" rel=""nofollow"">TripleDES</a> already exist in the Framework but I guess you want to roll your own implementation for educational purposes.</p>

<p>You're making things more complicated than necessary. Since you are using streams why don't you chain them all instead:</p>

<pre><code>public static byte[] TripleDESEncrypt(byte[] plainText, byte[] key1, byte[] key2, byte[] key3)
{
  var des = DES.Create();
  des.Mode = CipherMode.ECB;

  des.Padding = PaddingMode.None;
  des.Key = key3;
  var encryptor1 = des.CreateEncryptor();

  des.Key = key2;
  var decryptor = des.CreateDecryptor();

  des.Padding = PaddingMode.PKCS7;
  des.Key = key1;
  var encryptor2 = des.CreateEncryptor();

  byte[] result;
  using (var ms = new MemoryStream())
  {
    using (var cs1 = new CryptoStream(ms, encryptor1, CryptoStreamMode.Write))
    using (var cs2 = new CryptoStream(cs1, decryptor, CryptoStreamMode.Write))
    using (var cs3 = new CryptoStream(cs2, encryptor2, CryptoStreamMode.Write))
      cs3.Write(plainText, 0, plainText.Length);

    result = ms.ToArray();
  }


  return result;
}
</code></pre>

<p> </p>

<pre><code>public static byte[] TripleDESDecrypt(byte[] cipherText, byte[] key1, byte[] key2, byte[] key3)
{
  var des = DES.Create();
  des.Mode = CipherMode.ECB;

  des.Padding = PaddingMode.PKCS7;
  des.Key = key1;
  var decryptor1 = des.CreateDecryptor();

  des.Padding = PaddingMode.None;
  des.Key = key2;
  var encryptor = des.CreateEncryptor();

  des.Key = key3;
  var decryptor2 = des.CreateDecryptor();

  byte[] result;
  using (var ms = new MemoryStream())
  {
    using (var cs1 = new CryptoStream(ms, decryptor1, CryptoStreamMode.Write))
    using (var cs2 = new CryptoStream(cs1, encryptor, CryptoStreamMode.Write))
    using (var cs3 = new CryptoStream(cs2, decryptor2, CryptoStreamMode.Write))
      cs3.Write(cipherText, 0, cipherText.Length);

    result = ms.ToArray();
  }


  return result;
}
</code></pre>

<p>Make note of the usage of <code>using</code> blocks and also how the padding is applied to the different streams.</p>

<p>The framework <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledes.aspx"" rel=""nofollow"">TripleDES</a> is about 2.5 times faster than the above code.</p>

<pre><code>public static byte[] TripleDESEncryptFramework(byte[] plainText, byte[] key)
{
  var tdes = TripleDES.Create();
  tdes.Mode = CipherMode.ECB;
  tdes.Padding = PaddingMode.PKCS7;
  tdes.Key = key;

  var encryptor = tdes.CreateEncryptor();

  byte[] result;
  using (var ms = new MemoryStream())
  {
    using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
      cs.Write(plainText, 0, plainText.Length);

    result = ms.ToArray();
  }

  return result;
}
</code></pre>

<p>If you want to compare the results of the two different encryption methods then you need to remember that the 24-bit key for <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledes.aspx"" rel=""nofollow"">TripleDES</a> is actually the 3 keys put in one array:</p>

<pre><code>[  key1  ][  key2  ][  key3  ]
==============================
[            key             ]
</code></pre>
","3879","<c#><encryption><des><ecb>","1","0","2","2016-09-15 18:25:23","","5","1","","","","2012-05-28 11:35:32",""
"10784032","DES ECB C# encryption/decryption","<p>I have a problem with decryption of data previously encrypted. I am using the sequential encrypt-decrypt-encrypt with three different keys to get triple des effect. The encryption function works correctly (returns 8-byte array), but the decryption function returns empty array.</p>

<pre><code>    public static byte[] EncryptDES(byte[] clearData, byte[] key) 
    { 
        DES desEncrypt = new DESCryptoServiceProvider(); 
        desEncrypt.Mode = CipherMode.ECB; 
        desEncrypt.Key = key; 
        ICryptoTransform transForm = desEncrypt.CreateEncryptor(); 
        MemoryStream encryptedStream = new MemoryStream(); 
        CryptoStream cryptoStream = new CryptoStream(encryptedStream, transForm, CryptoStreamMode.Write); 
        cryptoStream.Write(clearData, 0, clearData.Length); 
        byte [] encryptedData = encryptedStream.ToArray(); 
        return encryptedData;
    }

    public static byte[] DecryptDES(byte[] clearData, byte[] key)
    {
        DES desDecrypt = new DESCryptoServiceProvider();
        desDecrypt.Mode = CipherMode.ECB;
        desDecrypt.Key = key;
        ICryptoTransform transForm = desDecrypt.CreateDecryptor();
        MemoryStream decryptedStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(decryptedStream, transForm, CryptoStreamMode.Write);
        cryptoStream.Write(clearData, 0, clearData.Length);
        byte[] encryptedData = decryptedStream.ToArray();
        return encryptedData;
    }

    public static byte[] Encrypt3DES(byte[] clearData, byte[] key0, byte[] key1, byte[] key2) 
    {
        byte[] encryptedData1 = new byte[clearData.Length];
        byte[] encryptedData2 = new byte[clearData.Length];
        byte[] encryptedData3 = new byte[clearData.Length];
        encryptedData1 = DESCrypto.EncryptDES(clearData    , key0);
        encryptedData2 = DESCrypto.DecryptDES(encryptedData1, key1);
        encryptedData3 = DESCrypto.EncryptDES(encryptedData2, key2);
        return encryptedData3;
    } 
</code></pre>

<p>What am I doing wrong?</p>
","<p>Just need cryptoStream.FlushFinalBlock(). Its code works great:</p>

<pre><code>   //ENCRYPT
   public static byte[] EncryptDES(byte[] clearData, byte[] key) 
   { 
       DES desEncrypt = new DESCryptoServiceProvider(); 
       desEncrypt.Mode = CipherMode.ECB; 
       desEncrypt.Key = key; 
       ICryptoTransform transForm = desEncrypt.CreateEncryptor(); 
       MemoryStream encryptedStream = new MemoryStream(); 
       CryptoStream cryptoStream = new CryptoStream(encryptedStream, transForm, CryptoStreamMode.Write); 
       cryptoStream.Write(clearData, 0, clearData.Length);
       cryptoStream.FlushFinalBlock();
       return encryptedStream.ToArray();
   }

   //DECRYPT
   public static byte[] DecryptDES(byte[] clearData, byte[] key)
   {
       DES desDecrypt = new DESCryptoServiceProvider();
       desDecrypt.Mode = CipherMode.ECB;
       desDecrypt.Key = key;
       ICryptoTransform transForm = desDecrypt.CreateDecryptor();
       MemoryStream decryptedStream = new MemoryStream();
       CryptoStream cryptoStream = new CryptoStream(decryptedStream, transForm, CryptoStreamMode.Write);
       cryptoStream.Write(clearData, 0, clearData.Length);
       cryptoStream.FlushFinalBlock();
       return decryptedStream.ToArray();
   }
</code></pre>
","3879","<c#><encryption><des><ecb>","1","0","2","2016-09-15 18:25:23","","5","1","","","","2012-05-28 11:35:32",""
"16833530","Objective C DESede/CBC/PKCS5Padding","<p>im trying to implement an encryption way on iOS . to match the one running on JAVA . </p>

<p>but every thing i tried result in a different encrypted schema </p>

<p>here is my Java Code that i Use for Encryption :</p>

<pre><code>  public static String encrypt(String plaintext)
    throws Exception
  {
    Cipher c = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sharedkey, ""DESede""), new IvParameterSpec(sharedvector));
    byte[] encrypted = c.doFinal(plaintext.getBytes(""UTF-8""));
    return Base64.encode(encrypted);
  }
</code></pre>

<p>is there any easy way to use DESede/CBC/PKCS5Padding in objective c ? </p>

<p>this is the code I'm Using but it gives different result </p>

<pre><code>+ (NSString*) doCipher:(NSString*)plainText:(CCOperation)encryptOrDecrypt {

    const void *vplainText;
    size_t plainTextBufferSize;

    if (encryptOrDecrypt == kCCDecrypt)
    {
       // NSData *EncryptData = [NSData dataWithBase64EncodedString:plainText];
       // plainTextBufferSize = [EncryptData length];
       // vplainText = [EncryptData bytes];
    }
    else
    {
        NSData *tempData = [plainText dataUsingEncoding:NSASCIIStringEncoding];
        plainTextBufferSize = [tempData length];
        vplainText =  [tempData bytes];
    }

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    //  uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);


    //my shared key i changed to Zeros 
    NSMutableData *payload = [[NSMutableData alloc] init];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
     [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];

    NSString *key = [[NSString alloc]initWithData:payload encoding:NSUTF8StringEncoding];

//my iV i changed it to zeros 
    NSMutableData *IV = [[NSMutableData alloc] init];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];

    NSLog(@""key byte is %s"", [payload bytes]);
     NSLog(@""IV byte is %s"", [IV bytes]);
    // Initialization vector; dummy in this case 0's.
    uint8_t iv[kCCBlockSize3DES];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding,
                       (const void *)[payload bytes], //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       [IV bytes],  //iv,
                       vplainText,  //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    //if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
    /*else*/ if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

    NSString *result;

    if (encryptOrDecrypt == kCCDecrypt)
    {

        //  result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:[(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding]];
        result = [[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding];
    }
    else
    {
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        NSLog(@""data is: %@"", myData);
        result = [myData base64EncodedString];
      //  result = [[NSString alloc]initWithData:myData encoding:NSUTF8StringEncoding];
    }
    return result;
}
</code></pre>
","<p>@owlstead thanx for your hint , </p>

<p>i really checked every thing and you are right the problem was with the input </p>

<p>so here is the right way to enter the input :</p>

<pre><code>  unsigned char result1[24]=      {0,0,0,0,0,0,0,0,0,0,0,00,0,0,0,0,0,0,0,00,00,00,00,0};
    unsigned char IV3[8]={0,0,0,0,0,0,0,0};
</code></pre>

<p>off-course you have to change the numbers to your own key and IV . </p>

<p>the Full Code : just change the IV and the result to your data :)</p>

<pre><code>    - (NSString*) doCipher:(NSString*)plainText enc:(CCOperation)encryptOrDecrypt{

    const void *vplainText;
    size_t plainTextBufferSize;





    if (encryptOrDecrypt == kCCDecrypt)
    {
        NSData *EncryptData =[NSData  dataWithBase64EncodedString:plainText];
        plainTextBufferSize = [EncryptData length];
        vplainText = [EncryptData bytes];
    }
    else
    {
        plainTextBufferSize = [plainText length];
        vplainText = (const void *) [plainText UTF8String];
    }


    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    //  uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);


    unsigned char result1[24]= {0,0,0,0,0,0,0,0,0,0,0,00,0,0,0,0,0,0,0,00,00,00,00,0};
    unsigned char IV3[8]={0,0,0,0,0,0,0,0};

    uint8_t iv[kCCBlockSize3DES];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding ,
                       result1, //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       IV3 ,  //iv,
                       vplainText,  //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    //if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
    /*else*/ if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

    NSString *result;

    if (encryptOrDecrypt == kCCDecrypt)
    {


        result = [ [NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding];

    }
    else
    {
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        NSLog(@""data is: %@"", myData);
        result = [NSData base64StringFromData:myData length:myData.length];
        //  result = [[NSString alloc]initWithData:myData encoding:NSUTF8StringEncoding];
    }
    return result;
}
</code></pre>
","3762","<ios><objective-c><encryption><des>","3","3","2","2015-03-10 08:34:07","16881118","1","4","","","","2013-05-30 10:17:09",""
"16833530","Objective C DESede/CBC/PKCS5Padding","<p>im trying to implement an encryption way on iOS . to match the one running on JAVA . </p>

<p>but every thing i tried result in a different encrypted schema </p>

<p>here is my Java Code that i Use for Encryption :</p>

<pre><code>  public static String encrypt(String plaintext)
    throws Exception
  {
    Cipher c = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sharedkey, ""DESede""), new IvParameterSpec(sharedvector));
    byte[] encrypted = c.doFinal(plaintext.getBytes(""UTF-8""));
    return Base64.encode(encrypted);
  }
</code></pre>

<p>is there any easy way to use DESede/CBC/PKCS5Padding in objective c ? </p>

<p>this is the code I'm Using but it gives different result </p>

<pre><code>+ (NSString*) doCipher:(NSString*)plainText:(CCOperation)encryptOrDecrypt {

    const void *vplainText;
    size_t plainTextBufferSize;

    if (encryptOrDecrypt == kCCDecrypt)
    {
       // NSData *EncryptData = [NSData dataWithBase64EncodedString:plainText];
       // plainTextBufferSize = [EncryptData length];
       // vplainText = [EncryptData bytes];
    }
    else
    {
        NSData *tempData = [plainText dataUsingEncoding:NSASCIIStringEncoding];
        plainTextBufferSize = [tempData length];
        vplainText =  [tempData bytes];
    }

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    //  uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);


    //my shared key i changed to Zeros 
    NSMutableData *payload = [[NSMutableData alloc] init];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
        [payload appendBytes:""00"" length:1];
     [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];
    [payload appendBytes:""00"" length:1];

    NSString *key = [[NSString alloc]initWithData:payload encoding:NSUTF8StringEncoding];

//my iV i changed it to zeros 
    NSMutableData *IV = [[NSMutableData alloc] init];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];
    [IV appendBytes:""00"" length:1];

    NSLog(@""key byte is %s"", [payload bytes]);
     NSLog(@""IV byte is %s"", [IV bytes]);
    // Initialization vector; dummy in this case 0's.
    uint8_t iv[kCCBlockSize3DES];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding,
                       (const void *)[payload bytes], //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       [IV bytes],  //iv,
                       vplainText,  //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    //if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
    /*else*/ if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

    NSString *result;

    if (encryptOrDecrypt == kCCDecrypt)
    {

        //  result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:[(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding]];
        result = [[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding];
    }
    else
    {
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        NSLog(@""data is: %@"", myData);
        result = [myData base64EncodedString];
      //  result = [[NSString alloc]initWithData:myData encoding:NSUTF8StringEncoding];
    }
    return result;
}
</code></pre>
","<p>Updating Waleed's Answer</p>

<p>key and IV could be :</p>

<pre><code>const unsigned char *keyString = (const unsigned char *)[@""ASAF#Key$M0BiLE!WS@DG_1@""  cStringUsingEncoding: NSUTF8StringEncoding];
const unsigned char *initializeVactorString = (const unsigned char *)[@""ASAF@DG#"" cStringUsingEncoding: NSUTF8StringEncoding];
</code></pre>

<p>Complete method would be :</p>

<pre><code>- (NSString*) EncodeText:(NSString*)plainText enc:(CCOperation)encryptOrDecrypt{

const void *vplainText;
size_t plainTextBufferSize;

if (encryptOrDecrypt == kCCDecrypt)
{
    NSString *base64EncodedString = [[plainText dataUsingEncoding:NSUTF8StringEncoding] base64EncodedStringWithOptions:0];
    NSData *encryptData = [[NSData alloc]initWithBase64EncodedString:base64EncodedString options:0];
    plainTextBufferSize = [encryptData length];
    vplainText = [encryptData bytes];
}
else
{
    plainTextBufferSize = [plainText length];
    vplainText = (const void *) [plainText UTF8String];
}

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

const unsigned char *keyString = (const unsigned char *)[@""ASAF#Key$M0BiLE!WS@DG_1@""  cStringUsingEncoding: NSUTF8StringEncoding];
const unsigned char *initializeVactorString = (const unsigned char *)[@""ASAF@DG#"" cStringUsingEncoding: NSUTF8StringEncoding];

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x0, (size_t) sizeof(iv));

ccStatus = CCCrypt(encryptOrDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding,
                   keyString,
                   kCCKeySize3DES,
                   initializeVactorString,
                   vplainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
else{
    if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";
}

NSString *result;
if (encryptOrDecrypt == kCCDecrypt)
{
    result = [ [NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding];
}
else
{
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    result = [myData base64EncodedStringWithOptions:0];
}
NSLog(@""%@"",result);
return result   ;
</code></pre>

<p>}</p>

<p>Some times server wants hex conversion, here is the way to convert string into hex</p>

<pre><code>+ (NSString *) stringToHex:(NSString *)str{

       NSUInteger len = [str length];
       unichar *chars = malloc(len * sizeof(unichar));
       [str getCharacters:chars];

       NSMutableString *hexString = [[NSMutableString alloc] init];

       for(NSUInteger i = 0; i &lt; len; i++ )
       {
          [hexString appendString:[NSString stringWithFormat:@""%x"", chars[i]]];
       }
       free(chars);

       return hexString ;
 }

+ (NSString *) stringFromHex:(NSString *)str{

     NSMutableData *stringData = [[NSMutableData alloc] init];
     unsigned char whole_byte;
     char byte_chars[3] = {'\0','\0','\0'};
     int i;
     for (i=0; i &lt; [str length] / 2; i++) {
        byte_chars[0] = [str characterAtIndex:i*2];
        byte_chars[1] = [str characterAtIndex:i*2+1];
        whole_byte = strtol(byte_chars, NULL, 16);
        [stringData appendBytes:&amp;whole_byte length:1];
      }
      return [[NSString alloc] initWithData:stringData encoding:NSASCIIStringEncoding];
}
</code></pre>
","3762","<ios><objective-c><encryption><des>","3","1","2","2015-03-10 08:34:07","16881118","1","4","","","","2013-05-30 10:17:09",""
"21044011","Encrypt and decrypt contents of a text file (Java)","<p>I'm looking for some help with my program here. This program can encrypt and decrypt <strong>a phrase</strong> using DES symmetric cipher, based on CBC mode of operation.</p>

<p>What I am trying to do now is it to change it such that it can encrypt and decrypt <strong>the content of a text file</strong> using DES symmetric cipher using CBC mode of operation. </p>

<p>Can anyone help me out with this please?</p>

<p>Thank you!</p>

<pre><code>import java.security.*;

import javax.crypto.*;

import java.security.spec.*;

import javax.crypto.spec.*;

import javax.crypto.spec.IvParameterSpec;



public class myProgram
{
  public static void main (String[] args) throws Exception
  {

    String text = ""Hello World;

    SecureRandom sr = new SecureRandom();
    byte [] iv = new byte[8];
    sr.nextBytes(iv);
    IvParameterSpec IV = new IvParameterSpec(iv);
    KeyGenerator kg = KeyGenerator.getInstance(""DES"");
    Key mykey = kg.generateKey();
    Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, mykey,IV);

    byte[] plaintext = text.getBytes(""UTF8"");



    byte[] ciphertext = cipher.doFinal(plaintext);

    System.out.println(""\n\nCiphertext: "");
    for (int i=0;i&lt;ciphertext.length;i++) {

        if (chkEight(i)) {
            System.out.print(""\n"");
        }
        System.out.print(ciphertext[i]+"" "");
    }
</code></pre>
","<p>So you just want to know how to read and write to a file?</p>

<p>Take a look at <a href=""http://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/FileUtils.html"" rel=""nofollow"">apache.commons.io.FileUtils</a>. It offers both methods for reading and writing strings from/to a file. Here are some examples:</p>

<pre><code>// info.txt represents the path to the file
File someFile = new File(""info.txt"");

// Create String from File
try {
  String filecontent = FileUtils.readFileToString(someFile, Charset.defaultCharset());
  System.out.println(filecontent);

} catch (IOException e) {
  e.printStackTrace();
}

// Encode / Decode string here

// Write String to file     
try {
  FileUtils.writeStringToFile(someFile, ""your new file content string"", Charset.defaultCharset());
  System.out.println(""Success!"");

} catch (IOException e) {
  e.printStackTrace();
}
</code></pre>

<p>You might want to use a different <a href=""http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"" rel=""nofollow"">Charset</a>, depending on the charset of your text file.</p>
","3699","<java><des><cbc-mode>","1","0","1","2014-01-10 12:51:08","21044366","3","","","","","2014-01-10 12:08:28",""
"8226156","EncryptByPassPhrase in SQL Server and Triple DES descrypt in C#","<p>Context:</p>

<ul>
<li>data is stored in SQL Server. Some fields are encrypted using EncryptWithPassPhrase</li>
</ul>

<p><code>update my_table set my_field = EncryptByPassPhrase('012345678901234567890123','some value')</code></p>

<ul>
<li><p>data is fetch using NHibernate. Encrypted data are decoded using Interceptor</p>

<pre><code>public static string Decrypt(byte[] toDecryptArray, string key)
{
    byte[] keyArray;

    keyArray = UTF8Encoding.UTF8.GetBytes(key);

    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    tdes.Key = keyArray;
    tdes.Mode = CipherMode.ECB;
    tdes.Padding = PaddingMode.PKCS7;

    ICryptoTransform cTransform = tdes.CreateDecryptor();
    byte[] resultArray = cTransform.TransformFinalBlock(toDecryptArray, 0, toDecryptArray.Length);

    return UTF8Encoding.UTF8.GetString(resultArray);
}
</code></pre></li>
</ul>

<p>It fails on <code>cTransform.TransformFinalBlock</code> saying ""Length of data to decrypt is invalid"".</p>

<p>What is wrong with my code? Data is encrypted/decrypted with same key (<code>012345678901234567980123</code>).</p>
","<p>I did not found out how to decrypt by C# code what was encrypted with T-SQL function <em>EncryptByPassPhrase</em>.</p>

<p>But SQL Server 2005 allow you to create C# assembly and load it into SQL Server, then build stored procedures or functions or your C# methods. Thus, I created ""my"" <em>EncryptByPassPhrase</em> function with shared code between app and SQL Server, so that I can encrypt/decrypt in both sides. </p>
","3646","<c#><tsql><des>","2","1","2","2013-03-04 19:15:56","","2","","446576","","2011-11-22 12:56:49","2011-11-22 11:37:45",""
"8226156","EncryptByPassPhrase in SQL Server and Triple DES descrypt in C#","<p>Context:</p>

<ul>
<li>data is stored in SQL Server. Some fields are encrypted using EncryptWithPassPhrase</li>
</ul>

<p><code>update my_table set my_field = EncryptByPassPhrase('012345678901234567890123','some value')</code></p>

<ul>
<li><p>data is fetch using NHibernate. Encrypted data are decoded using Interceptor</p>

<pre><code>public static string Decrypt(byte[] toDecryptArray, string key)
{
    byte[] keyArray;

    keyArray = UTF8Encoding.UTF8.GetBytes(key);

    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    tdes.Key = keyArray;
    tdes.Mode = CipherMode.ECB;
    tdes.Padding = PaddingMode.PKCS7;

    ICryptoTransform cTransform = tdes.CreateDecryptor();
    byte[] resultArray = cTransform.TransformFinalBlock(toDecryptArray, 0, toDecryptArray.Length);

    return UTF8Encoding.UTF8.GetString(resultArray);
}
</code></pre></li>
</ul>

<p>It fails on <code>cTransform.TransformFinalBlock</code> saying ""Length of data to decrypt is invalid"".</p>

<p>What is wrong with my code? Data is encrypted/decrypted with same key (<code>012345678901234567980123</code>).</p>
","<p>The documentation says of the passphrase:</p>

<p>""A variable of type nvarchar, char, varchar, binary, varbinary, or nchar containing a passphrase <em>from which to generate</em> a symmetric key.""</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms190357.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms190357.aspx</a></p>

<p>So the reason why you can't decrypt it in C# is that you need to use the derived key, not the passphrase itself. I don't know how you'd derive the key, though.</p>
","3646","<c#><tsql><des>","2","0","2","2013-03-04 19:15:56","","2","","446576","","2011-11-22 12:56:49","2011-11-22 11:37:45",""
"41579325","Golang: How do I decrypt with DES, CBC, and PKCS7?","<p>Currently trying to figure out why my decryption method is not working. I used DES, CBC, and PKCS7Padding to encrypt my string. My current <a href=""https://play.golang.org/p/FZN6POxqU8"" rel=""nofollow noreferrer"">code</a> outputs <code>panic: crypto/cipher: input not full blocks</code> during decryption. </p>
","<p>Buddy it's work completely fine. </p>

<pre><code>package main

    import (
        ""bytes""
        ""crypto/des""
        ""crypto/cipher""
        ""fmt""
    )

    func DesEncryption(key, iv, plainText []byte) ([]byte, error) {

        block, err := des.NewCipher(key)

        if err != nil {
            return nil, err
        }

        blockSize := block.BlockSize()
        origData := PKCS5Padding(plainText, blockSize)
        blockMode := cipher.NewCBCEncrypter(block, iv)
        cryted := make([]byte, len(origData))
        blockMode.CryptBlocks(cryted, origData)
        return cryted, nil
    }

    func DesDecryption(key, iv, cipherText []byte) ([]byte, error) {

        block, err := des.NewCipher(key)

        if err != nil {
            return nil, err
        }

        blockMode := cipher.NewCBCDecrypter(block, iv)
        origData := make([]byte, len(cipherText))
        blockMode.CryptBlocks(origData, cipherText)
        origData = PKCS5UnPadding(origData)
        return origData, nil
    }

    func PKCS5Padding(src []byte, blockSize int) []byte {
        padding := blockSize - len(src)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(src, padtext...)
    }

    func PKCS5UnPadding(src []byte) []byte {
        length := len(src)
        unpadding := int(src[length-1])
        return src[:(length - unpadding)]
    }


    func main() {
        originalText := ""sysys""
        fmt.Println(originalText)
        mytext := []byte(originalText)

        key := []byte{0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC }
        iv := []byte{0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC }


        cryptoText,_ := DesEncryption(key, iv, mytext)
        fmt.Println(string(cryptoText))
        decryptedText,_ := DesDecryption(key, iv, cryptoText)
        fmt.Println(string(decryptedText))

    }
</code></pre>
","3628","<go><base64><des><pkcs#7><cbc-mode>","1","3","1","2017-01-11 16:13:46","41595640","5","1","4021006","","2017-01-11 15:38:50","2017-01-10 22:10:39",""
"17316547","Java Equivalent for .NET Encryption-DESCryptoServiceProvider","<p>Good Day, I need to encrypt some text using the base64 encoding and pass the encoded data to .NET application. The .NET application uses the following form of encoding &amp; decoding. I have tried this <a href=""https://stackoverflow.com/questions/4489942/equivalent-to-cryptostream-net-in-java"">Equivalent to CryptoStream .NET in Java?</a>.
I have used Apache commons codec for this purpose following the above link. But Stuck with the cryptoProvider.CreateEncryptor(bytes, bytes) , When i checked the third parameter in java equivalent - </p>

<blockquote>
  <p>Cipher.init(cipher.ENCRYPT_MODE,key,iv)</p>
</blockquote>

<p>it  must be an IvParameterSpec.I dont know how to solve this. Hope to get some help, Cheers!  </p>

<blockquote>
  <p>.NET encryption</p>
</blockquote>

<pre><code>static byte[] bytes = ASCIIEncoding.ASCII.GetBytes(""mykey"");
public static string Encrypt(string originalString)
{        
    DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
    MemoryStream memoryStream = new MemoryStream();
    CryptoStream cryptoStream = new CryptoStream(memoryStream,cryptoProvider.CreateEncryptor(bytes, bytes), CryptoStreamMode.Write);
    StreamWriter writer = new StreamWriter(cryptoStream);
    writer.Write(originalString);
    writer.Flush();
    cryptoStream.FlushFinalBlock();
    writer.Flush();
    return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
}
</code></pre>

<p>Equivalent </p>

<blockquote>
  <p>Java Encryption</p>
</blockquote>

<pre><code>void encrypt(String inputText) throws Exception {
    try {
        String myKey = ""mykey"";
        byte[] mybyte = str.getBytes(""ASCII"");
        //String plainIV = ""1234567890ABCDEF"";
        KeySpec keySpec = new DESKeySpec(myKey.getBytes(""ASCII""));
        SecretKey key = SecretKeyFactory.getInstance(""DES"").generateSecret(keySpec);
        //IvParameterSpec iv = new IvParameterSpec(org.apache.commons.codec.binary.Hex.decodeHex(plainIV.toCharArray()));
        IvParameterSpec iv = new IvParameterSpec(mybyte);
        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE,key,iv);
        byte[] encoded = cipher.doFinal(inputText.getBytes(""ASCII""));   
        System.out.println(""Encoded Value ..... ""+Base64.encodeBase64(encoded));
    } catch(UnsupportedEncodingException e) {
        System.out.println(""Exception .. ""+ e.getMessage());
    }
</code></pre>

<p>In .Net i get this- AOb0B20x2onFGz+JaFBsZyFbvCS9WF49D as the encoded value but in java, I'm getting wired encoded string- =�SKNv?�N�Ɛq{���U�;�/Z���8��&lt;

<p>Edit:- </p>

<p>Followed zacheusz and solved encoding problem, but encoded strings in both .NET and java are different...</p>
","<p>I see that in .NET you are specyfing IV:</p>

<pre><code>cryptoProvider.CreateEncryptor(bytes, bytes)
</code></pre>

<p>According to the <a href=""http://msdn.microsoft.com/en-us/library/0dh224hh.aspx"" rel=""nofollow"">documentation</a> the second byte array is the IV. So you should use the same array in Java.</p>

<p>I think that the bug is here:</p>

<pre><code>cipher.doFinal(Base64.encodeBase64(inputText.getBytes(""ASCII""))); 
</code></pre>

<p>You are b64 encoding input before decrypting it.</p>

<p>Try</p>

<pre><code>    byte[] output = cipher.doFinal(inputText.getBytes(""ASCII""));  
    System.out.println(""Encoded Value ..... ""+new String(Base64.encodeBase64(output)));
</code></pre>

<p>Additional remarks (regarding your questions in comments):</p>

<ul>
<li>you need the same iv for Java and .NET </li>
<li>the <a href=""http://docs.oracle.com/javase/6/docs/api/javax/crypto/spec/IvParameterSpec.html#IvParameterSpec%28byte%5B%5D%29"" rel=""nofollow"">constructor for IvParameterSpec</a> takes byte[] as an argument </li>
<li>In .NET the <a href=""http://msdn.microsoft.com/en-us/library/0dh224hh.aspx"" rel=""nofollow"">CreateEncryptor</a> method takes byte[] IV as second argument: </li>
</ul>
","3581","<java><.net><des><encryption-symmetric>","1","2","2","2017-02-13 08:12:56","17317100","3","2","-1","","2017-05-23 11:45:26","2013-06-26 09:38:38",""
"17316547","Java Equivalent for .NET Encryption-DESCryptoServiceProvider","<p>Good Day, I need to encrypt some text using the base64 encoding and pass the encoded data to .NET application. The .NET application uses the following form of encoding &amp; decoding. I have tried this <a href=""https://stackoverflow.com/questions/4489942/equivalent-to-cryptostream-net-in-java"">Equivalent to CryptoStream .NET in Java?</a>.
I have used Apache commons codec for this purpose following the above link. But Stuck with the cryptoProvider.CreateEncryptor(bytes, bytes) , When i checked the third parameter in java equivalent - </p>

<blockquote>
  <p>Cipher.init(cipher.ENCRYPT_MODE,key,iv)</p>
</blockquote>

<p>it  must be an IvParameterSpec.I dont know how to solve this. Hope to get some help, Cheers!  </p>

<blockquote>
  <p>.NET encryption</p>
</blockquote>

<pre><code>static byte[] bytes = ASCIIEncoding.ASCII.GetBytes(""mykey"");
public static string Encrypt(string originalString)
{        
    DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
    MemoryStream memoryStream = new MemoryStream();
    CryptoStream cryptoStream = new CryptoStream(memoryStream,cryptoProvider.CreateEncryptor(bytes, bytes), CryptoStreamMode.Write);
    StreamWriter writer = new StreamWriter(cryptoStream);
    writer.Write(originalString);
    writer.Flush();
    cryptoStream.FlushFinalBlock();
    writer.Flush();
    return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
}
</code></pre>

<p>Equivalent </p>

<blockquote>
  <p>Java Encryption</p>
</blockquote>

<pre><code>void encrypt(String inputText) throws Exception {
    try {
        String myKey = ""mykey"";
        byte[] mybyte = str.getBytes(""ASCII"");
        //String plainIV = ""1234567890ABCDEF"";
        KeySpec keySpec = new DESKeySpec(myKey.getBytes(""ASCII""));
        SecretKey key = SecretKeyFactory.getInstance(""DES"").generateSecret(keySpec);
        //IvParameterSpec iv = new IvParameterSpec(org.apache.commons.codec.binary.Hex.decodeHex(plainIV.toCharArray()));
        IvParameterSpec iv = new IvParameterSpec(mybyte);
        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE,key,iv);
        byte[] encoded = cipher.doFinal(inputText.getBytes(""ASCII""));   
        System.out.println(""Encoded Value ..... ""+Base64.encodeBase64(encoded));
    } catch(UnsupportedEncodingException e) {
        System.out.println(""Exception .. ""+ e.getMessage());
    }
</code></pre>

<p>In .Net i get this- AOb0B20x2onFGz+JaFBsZyFbvCS9WF49D as the encoded value but in java, I'm getting wired encoded string- =�SKNv?�N�Ɛq{���U�;�/Z���8��&lt;

<p>Edit:- </p>

<p>Followed zacheusz and solved encoding problem, but encoded strings in both .NET and java are different...</p>
","<p>Thank you @zacheusz, 
I got it!!!
It was a silly mistake,I was printing the byte[] value, i forget to convert it to String</p>

<p>So Changed </p>

<blockquote>
  <p>System.out.println(""Encoded Value ..... ""+Base64.encodeBase64(encoded));</p>
</blockquote>

<p>To</p>

<blockquote>
  <p>System.out.println(""Encoded Value ..... ""+new String(Base64.encodeBase64(encoded),""ASCII"");</p>
</blockquote>

<p>and That Solved my problem. Also modified code with <a href=""http://docs.oracle.com/javase/6/docs/api/java/io/ByteArrayOutputStream.html"" rel=""nofollow"">ByteArrayOutputStream</a>.
Here is the Encoding &amp; Decoding functions</p>

<pre><code>String encrypt(String inputText) throws Exception {
    byte[] keyValue = new byte[] { 'm', 'y', 'k', 'e', 'y', 'n', 'u', 'l'};
    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    try {           
        KeySpec keySpec = new DESKeySpec(keyValue);
        SecretKey key = SecretKeyFactory.getInstance(""DES"").generateSecret(keySpec);
        IvParameterSpec iv = new IvParameterSpec(keyValue);
        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding""); 
        cipher.init(Cipher.ENCRYPT_MODE,key,iv);
        bout.write(cipher.doFinal(inputText.getBytes(""ASCII"")));                        
    } catch(Exception e) {
        System.out.println(""Exception .. ""+ e.getMessage());
    }
    return new String(Base64.encodeBase64(bout.toByteArray()),""ASCII"");
}

String decrypt(String inputText) throws Exception {
    byte[] keyValue = new byte[] { 'm', 'y', 'k', 'e', 'y', 'n', 'u', 'l'};
    try {
        KeySpec keySpec = new DESKeySpec(keyValue);
        SecretKey key = SecretKeyFactory.getInstance(""DES"").generateSecret(keySpec);
        IvParameterSpec iv = new IvParameterSpec(keyValue);

        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE,key,iv);
        //byte[] decoded = Base64.decodeBase64(inputText); //Works with apache.commons.codec-1.8
        byte[] decoded = Base64.decodeBase64(inputText.getBytes(""ASCII""));// works with apache.commons.codec-1.3
        bout.write(cipher.doFinal(decoded));
    } catch(Exception e) {
        System.out.println(""Exception ... ""+e);
    }
    return new String(bout.toByteArray(),""ASCII"");
}
</code></pre>

<p>Hope Someone will find it helpful...</p>
","3581","<java><.net><des><encryption-symmetric>","1","1","2","2017-02-13 08:12:56","17317100","3","2","-1","","2017-05-23 11:45:26","2013-06-26 09:38:38",""
"9315589","CryptoStream: Length of the data to decrypt is invalid. Same code does not generate error on same data","<p>Okay, this weird, to me.  I have this code, which works:</p>

<pre><code>using (MemoryStream memStream = new MemoryStream(inBytes))
using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write))
using (CryptoStream cs = new CryptoStream(memStream, decryptor, CryptoStreamMode.Read))
{
    byte[] buffer;
    if (inBytes.Length &lt; (1024 * 10)) buffer = new byte[inBytes.Length];
    else buffer = new byte[(1024 * 10)];
    long readBytes = 0;
    long totalBytes = inStream.Length;
    int currBytes;

    while (readBytes &lt; totalBytes)
    {
        currBytes = cs.Read(buffer, 0, buffer.Length);
        fs.Write(buffer, 0, currBytes);
        readBytes += currBytes;
    }
}
</code></pre>

<p>This writes decrypted data out to a file.</p>

<p>Then I have this code which does exactly the same thing, except it writes to (and returns) a <code>MemoryStream</code>:</p>

<pre><code>using(MemoryStream memStream = new MemoryStream(inBytes))
using(MemoryStream ms = new MemoryStream())
using (CryptoStream cs = new CryptoStream(memStream, decryptor, CryptoStreamMode.Read))
{
    byte[] buffer;
    if (inBytes.Length &lt; (1024 * 10)) buffer = new byte[inBytes.Length];
    else buffer = new byte[(1024 * 10)];
    long readBytes = 0;
    long totalBytes = inStream.Length;
    int currBytes;

    while (readBytes &lt; totalBytes)
    {
        currBytes = cs.Read(buffer, 0, buffer.Length);
        ms.Write(buffer, 0, currBytes);
        readBytes += currBytes;
    }

    return ms;
}
</code></pre>

<p>On the line <code>currBytes = cs.Read(buffer, 0, buffer.Length)</code> I receive the error ""Length of the data to decrypt is invalid"" but only on the second set, not the first.  The <code>ICryptoTransform</code> ""decryptor"" is created from a common method, and I know it's using the same key.</p>

<p>Can anyone tell me why I would not be getting this error in the first instance, but would be in the second, and (more importantly) how to fix it.</p>

<p>And, yes, I know DES is not the best encryption method ever.  This is something in the nature of a proof-of-concept that will never see the light of day in a production environment.</p>
","<p>Try to add these checks to both pieces of code. I strongly suspect one or both of these fails:</p>

<pre><code>if ( inStream.Length != inBytes.Length )
  throw new Exception(""inBytes read incorrectly"");
if ( inBytes.Length % 8 == 0 )
  throw new Exception(""inBytes is not a valid DES encryption"");
</code></pre>
","3492","<c#><encryption><des>","1","0","2","2012-09-27 08:27:35","","13","","5542","","2012-02-16 19:15:43","2012-02-16 17:02:20",""
"9315589","CryptoStream: Length of the data to decrypt is invalid. Same code does not generate error on same data","<p>Okay, this weird, to me.  I have this code, which works:</p>

<pre><code>using (MemoryStream memStream = new MemoryStream(inBytes))
using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write))
using (CryptoStream cs = new CryptoStream(memStream, decryptor, CryptoStreamMode.Read))
{
    byte[] buffer;
    if (inBytes.Length &lt; (1024 * 10)) buffer = new byte[inBytes.Length];
    else buffer = new byte[(1024 * 10)];
    long readBytes = 0;
    long totalBytes = inStream.Length;
    int currBytes;

    while (readBytes &lt; totalBytes)
    {
        currBytes = cs.Read(buffer, 0, buffer.Length);
        fs.Write(buffer, 0, currBytes);
        readBytes += currBytes;
    }
}
</code></pre>

<p>This writes decrypted data out to a file.</p>

<p>Then I have this code which does exactly the same thing, except it writes to (and returns) a <code>MemoryStream</code>:</p>

<pre><code>using(MemoryStream memStream = new MemoryStream(inBytes))
using(MemoryStream ms = new MemoryStream())
using (CryptoStream cs = new CryptoStream(memStream, decryptor, CryptoStreamMode.Read))
{
    byte[] buffer;
    if (inBytes.Length &lt; (1024 * 10)) buffer = new byte[inBytes.Length];
    else buffer = new byte[(1024 * 10)];
    long readBytes = 0;
    long totalBytes = inStream.Length;
    int currBytes;

    while (readBytes &lt; totalBytes)
    {
        currBytes = cs.Read(buffer, 0, buffer.Length);
        ms.Write(buffer, 0, currBytes);
        readBytes += currBytes;
    }

    return ms;
}
</code></pre>

<p>On the line <code>currBytes = cs.Read(buffer, 0, buffer.Length)</code> I receive the error ""Length of the data to decrypt is invalid"" but only on the second set, not the first.  The <code>ICryptoTransform</code> ""decryptor"" is created from a common method, and I know it's using the same key.</p>

<p>Can anyone tell me why I would not be getting this error in the first instance, but would be in the second, and (more importantly) how to fix it.</p>

<p>And, yes, I know DES is not the best encryption method ever.  This is something in the nature of a proof-of-concept that will never see the light of day in a production environment.</p>
","<p>I ran into this error today and it turned out that I had converted one source string into a byte array using ASCII in one function and the other using Base64 in a different function.</p>

<p>It may be that although your inputs are of the correct length they are not using the same encoding.</p>
","3492","<c#><encryption><des>","1","1","2","2012-09-27 08:27:35","","13","","5542","","2012-02-16 19:15:43","2012-02-16 17:02:20",""
"13827466","Use private key in java using DES without generating key automatically","<p>I have to encrypt/decrypt plain text in java using DES with a key. I have got a very good tutorial at IBM which can be found <a href=""http://www.ibm.com/developerworks/java/tutorials/j-sec1/section4.html#prikeyexample"" rel=""nofollow"">here</a> . The problem with this example is that it is generating the key in the program itself. Now if I encrypt a string(eg password) and store in database then I would not be able to decrypt it because I would not know the key.</p>

<p>Below is the example at IBM</p>

<pre><code>import java.security.*;
import javax.crypto.*;
//
// encrypt and decrypt using the DES private key algorithm
public class PrivateExample {

  public static void main (String[] args) throws Exception {
  //
  // check args and get plaintext
    if (args.length !=1) {
      System.err.println(""Usage: java PrivateExample text"");
      System.exit(1);
    }
  byte[] plainText = args[0].getBytes(""UTF8"");
  //
  // get a DES private key
  System.out.println( ""\nStart generating DES key"" );
  KeyGenerator keyGen = KeyGenerator.getInstance(""DES"");
  keyGen.init(56);
  Key key = keyGen.generateKey();
  System.out.println( ""Finish generating DES key"" );
//
// get a DES cipher object and print the provider
Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
System.out.println( ""\n"" + cipher.getProvider().getInfo() );
//
// encrypt using the key and the plaintext
System.out.println( ""\nStart encryption"" );
cipher.init(Cipher.ENCRYPT_MODE, key);
byte[] cipherText = cipher.doFinal(plainText);
System.out.println( ""Finish encryption: "" );
System.out.println( new String(cipherText, ""UTF8"") );

//
// decrypt the ciphertext using the same key
System.out.println( ""\nStart decryption"" );
cipher.init(Cipher.DECRYPT_MODE, key);
byte[] newPlainText = cipher.doFinal(cipherText);
System.out.println( ""Finish decryption: "" );

System.out.println( new String(newPlainText, ""UTF8"") );
}
}
</code></pre>

<p>Can anyone suggest how can I add my own key in this example?</p>
","<p>Make the key one of the args instead of generateKey if you plan to supply the key.</p>

<p>Edit: generateKey generates a random key. It might be simpler to save this key to use for decryption than to add code to parse a key arg. Have a look at <a href=""http://docs.oracle.com/javase/6/docs/api/javax/crypto/KeyGenerator.html"" rel=""nofollow"">KeyGenerator</a> and <a href=""http://docs.oracle.com/javase/6/docs/api/javax/crypto/SecretKey.html"" rel=""nofollow"">SecretKey</a>.</p>
","3435","<java><des><encryption-symmetric>","3","1","2","2012-12-11 20:52:21","13827521","0","2","","","","2012-12-11 19:52:58",""
"13827466","Use private key in java using DES without generating key automatically","<p>I have to encrypt/decrypt plain text in java using DES with a key. I have got a very good tutorial at IBM which can be found <a href=""http://www.ibm.com/developerworks/java/tutorials/j-sec1/section4.html#prikeyexample"" rel=""nofollow"">here</a> . The problem with this example is that it is generating the key in the program itself. Now if I encrypt a string(eg password) and store in database then I would not be able to decrypt it because I would not know the key.</p>

<p>Below is the example at IBM</p>

<pre><code>import java.security.*;
import javax.crypto.*;
//
// encrypt and decrypt using the DES private key algorithm
public class PrivateExample {

  public static void main (String[] args) throws Exception {
  //
  // check args and get plaintext
    if (args.length !=1) {
      System.err.println(""Usage: java PrivateExample text"");
      System.exit(1);
    }
  byte[] plainText = args[0].getBytes(""UTF8"");
  //
  // get a DES private key
  System.out.println( ""\nStart generating DES key"" );
  KeyGenerator keyGen = KeyGenerator.getInstance(""DES"");
  keyGen.init(56);
  Key key = keyGen.generateKey();
  System.out.println( ""Finish generating DES key"" );
//
// get a DES cipher object and print the provider
Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
System.out.println( ""\n"" + cipher.getProvider().getInfo() );
//
// encrypt using the key and the plaintext
System.out.println( ""\nStart encryption"" );
cipher.init(Cipher.ENCRYPT_MODE, key);
byte[] cipherText = cipher.doFinal(plainText);
System.out.println( ""Finish encryption: "" );
System.out.println( new String(cipherText, ""UTF8"") );

//
// decrypt the ciphertext using the same key
System.out.println( ""\nStart decryption"" );
cipher.init(Cipher.DECRYPT_MODE, key);
byte[] newPlainText = cipher.doFinal(cipherText);
System.out.println( ""Finish decryption: "" );

System.out.println( new String(newPlainText, ""UTF8"") );
}
}
</code></pre>

<p>Can anyone suggest how can I add my own key in this example?</p>
","<p>Have a look at <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/SecretKeyFactory.html"" rel=""nofollow""><code>SecretKeyFactory</code></a> and <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/DESKeySpec.html"" rel=""nofollow""><code>DESKeySpec</code></a>. These can be used to construct a DES key from the key material (a byte array).</p>

<p>You can get the key material from a DES key using <a href=""http://docs.oracle.com/javase/7/docs/api/java/security/Key.html#getEncoded%28%29"" rel=""nofollow""><code>getEncoded()</code></a>.</p>
","3435","<java><des><encryption-symmetric>","3","1","2","2012-12-11 20:52:21","13827521","0","2","","","","2012-12-11 19:52:58",""
"15901740","Java & PHP symmetric encryption (DES)","<p>I need to have a basic/simple String encryption (i.e. low security is good enough, I just want to avoid that the communication is human readable) between my Java client application and the PHP server.</p>

<p>I opted thus for the symmetric DES encryption as it doesn't require any key exchange (same key will be used on client and on server) + it doesn't require Java Security Policy updates for longer keys.
I also encode/decode Base64 as the data gets sent by a Http post.</p>

<p>Unfortunately my code doesn't work as decrypted text doesn't match input.</p>

<p>My Java code to encrypt:</p>

<pre><code>SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
DESKeySpec keySpecEncrypt = new DESKeySpec(ParamsProvider.SERVER_ECRYPTION_SECRETKEY2); //Secret key is a byte[8] = {1, 2, 3, 4, 5, 6, 7, 8}
SecretKey keyEncrypt = keyFactory.generateSecret(keySpecEncrypt);

// Create the cipher 
Cipher desCipher = Cipher.getInstance(""DES/CFB8/NoPadding"");

// Initialize the cipher for encryption
desCipher.init(Cipher.ENCRYPT_MODE, keyEncrypt);

// Encrypt the text
byte[] textEncrypted = desCipher.doFinal(data.getBytes(""UTF-8""));

//B64 encoding and return
byte[] encryptedB64ByteArray = (new org.apache.commons.codec.binary.Base64()).encode(textEncrypted);
return new String(encryptedB64ByteArray, ""UTF8"");
</code></pre>

<p>My PHP code to decrypt:</p>

<pre><code>function decrypt($message) {
    $secret_key = array(1, 2, 3, 4, 5, 6, 7, 8);
    $decodedMsg = base64_decode($message);
    return base64_decode(mcrypt_decrypt(MCRYPT_DES, $key, $decodedMsg, MCRYPT_MODE_CFB));
}
</code></pre>

<p>My best guess is that my Java and PHP en/decryption parameters are not equal (e.g. CFB8 mode) but I have no clue on how to solve this.</p>

<p>Any help or hint would be greatly appreciated (I already lost a few hours on this one),
Cheers,
Thomas</p>
","<p>You have too choose a padding method, read <a href=""https://stackoverflow.com/a/15882657/1562303"">this</a>
With the php code at the link of @Jon you haveto choose the PKCS#5-padding:</p>

<pre><code>// Create the cipher 
Cipher desCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
</code></pre>
","3346","<java><php><encryption><des>","1","1","3","2016-11-22 10:13:59","15910919","2","2","6422820","","2016-11-22 10:13:59","2013-04-09 12:20:54",""
"15901740","Java & PHP symmetric encryption (DES)","<p>I need to have a basic/simple String encryption (i.e. low security is good enough, I just want to avoid that the communication is human readable) between my Java client application and the PHP server.</p>

<p>I opted thus for the symmetric DES encryption as it doesn't require any key exchange (same key will be used on client and on server) + it doesn't require Java Security Policy updates for longer keys.
I also encode/decode Base64 as the data gets sent by a Http post.</p>

<p>Unfortunately my code doesn't work as decrypted text doesn't match input.</p>

<p>My Java code to encrypt:</p>

<pre><code>SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
DESKeySpec keySpecEncrypt = new DESKeySpec(ParamsProvider.SERVER_ECRYPTION_SECRETKEY2); //Secret key is a byte[8] = {1, 2, 3, 4, 5, 6, 7, 8}
SecretKey keyEncrypt = keyFactory.generateSecret(keySpecEncrypt);

// Create the cipher 
Cipher desCipher = Cipher.getInstance(""DES/CFB8/NoPadding"");

// Initialize the cipher for encryption
desCipher.init(Cipher.ENCRYPT_MODE, keyEncrypt);

// Encrypt the text
byte[] textEncrypted = desCipher.doFinal(data.getBytes(""UTF-8""));

//B64 encoding and return
byte[] encryptedB64ByteArray = (new org.apache.commons.codec.binary.Base64()).encode(textEncrypted);
return new String(encryptedB64ByteArray, ""UTF8"");
</code></pre>

<p>My PHP code to decrypt:</p>

<pre><code>function decrypt($message) {
    $secret_key = array(1, 2, 3, 4, 5, 6, 7, 8);
    $decodedMsg = base64_decode($message);
    return base64_decode(mcrypt_decrypt(MCRYPT_DES, $key, $decodedMsg, MCRYPT_MODE_CFB));
}
</code></pre>

<p>My best guess is that my Java and PHP en/decryption parameters are not equal (e.g. CFB8 mode) but I have no clue on how to solve this.</p>

<p>Any help or hint would be greatly appreciated (I already lost a few hours on this one),
Cheers,
Thomas</p>
","<p>Thanks for the hints.</p>

<p>Unfortunately none of them worked out for me.</p>

<p>I finally solved it based on this code:
<a href=""https://github.com/stevenholder/PHP-Java-AES-Encrypt"" rel=""nofollow"">https://github.com/stevenholder/PHP-Java-AES-Encrypt</a></p>

<p>Cheers,
Thomas</p>
","3346","<java><php><encryption><des>","1","3","3","2016-11-22 10:13:59","15910919","2","2","6422820","","2016-11-22 10:13:59","2013-04-09 12:20:54",""
"15901740","Java & PHP symmetric encryption (DES)","<p>I need to have a basic/simple String encryption (i.e. low security is good enough, I just want to avoid that the communication is human readable) between my Java client application and the PHP server.</p>

<p>I opted thus for the symmetric DES encryption as it doesn't require any key exchange (same key will be used on client and on server) + it doesn't require Java Security Policy updates for longer keys.
I also encode/decode Base64 as the data gets sent by a Http post.</p>

<p>Unfortunately my code doesn't work as decrypted text doesn't match input.</p>

<p>My Java code to encrypt:</p>

<pre><code>SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
DESKeySpec keySpecEncrypt = new DESKeySpec(ParamsProvider.SERVER_ECRYPTION_SECRETKEY2); //Secret key is a byte[8] = {1, 2, 3, 4, 5, 6, 7, 8}
SecretKey keyEncrypt = keyFactory.generateSecret(keySpecEncrypt);

// Create the cipher 
Cipher desCipher = Cipher.getInstance(""DES/CFB8/NoPadding"");

// Initialize the cipher for encryption
desCipher.init(Cipher.ENCRYPT_MODE, keyEncrypt);

// Encrypt the text
byte[] textEncrypted = desCipher.doFinal(data.getBytes(""UTF-8""));

//B64 encoding and return
byte[] encryptedB64ByteArray = (new org.apache.commons.codec.binary.Base64()).encode(textEncrypted);
return new String(encryptedB64ByteArray, ""UTF8"");
</code></pre>

<p>My PHP code to decrypt:</p>

<pre><code>function decrypt($message) {
    $secret_key = array(1, 2, 3, 4, 5, 6, 7, 8);
    $decodedMsg = base64_decode($message);
    return base64_decode(mcrypt_decrypt(MCRYPT_DES, $key, $decodedMsg, MCRYPT_MODE_CFB));
}
</code></pre>

<p>My best guess is that my Java and PHP en/decryption parameters are not equal (e.g. CFB8 mode) but I have no clue on how to solve this.</p>

<p>Any help or hint would be greatly appreciated (I already lost a few hours on this one),
Cheers,
Thomas</p>
","<p>I had the same problem in the context of RSA (java:encryption, php:decryption),
solved my problem the following way: in the keyPair-generation in increased the 'initialize' value from 512 to 1024. and it works.
the hint i followed was here: <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html"" rel=""nofollow"">http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html</a>
where it states that every java-implementation has to implement at least:
...
RSA/ECB/PKCS1Padding (1024, 2048)
...
so maybe the result of the keygeneration was not compatible</p>
","3346","<java><php><encryption><des>","1","0","3","2016-11-22 10:13:59","15910919","2","2","6422820","","2016-11-22 10:13:59","2013-04-09 12:20:54",""
"15406388","init of a Cipher object in Java","<p>When encrypting data in java as following:</p>

<pre><code>    SecureRandom sr = new SecureRandom();  
    DESKeySpec dks = new DESKeySpec(rawKeyData);

    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");  
    SecretKey key = keyFactory.generateSecret(dks);  
    Cipher cipher = Cipher.getInstance(""DES"");  
    cipher.init(Cipher.ENCRYPT_MODE, key, sr);  
    // why the sr is necessary to init a Cipher object?
    byte data[] = str.getBytes();  
    byte[] encryptedData = cipher.doFinal(data);
</code></pre>

<p>Why the a <code>SecureRandom</code> object <code>sr</code> is necessary to init a Cipher object?  As for the decryption side there is also need an <code>SecureRandom</code> object which is not the same as the one generated in the encryption size. Is these<code>SecureRandom</code> objects just for parity digit?</p>
","<p>The <code>SecureRandom</code> object is optional. If you don't select one, Java will use a default source of randomness. See the documentation of <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#init%28int,%20java.security.Key%29"" rel=""nofollow"">this method</a> to understand how one is selected.</p>

<p>The <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#init%28int,%20java.security.Key,%20java.security.SecureRandom%29"" rel=""nofollow""><code>Cipher</code> Javadocs</a> explains the purpose of this argument:</p>

<blockquote>
  <p>If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. </p>
</blockquote>

<p>So, in your particular case, you are probably not making use of this item at all. Nothing in your DES usage will require random data (since you appear to be using ECB mode). If you were using CBC-mode, then I assume the IV would be randomly generated from the <code>SecureRandom</code> object.</p>
","3320","<java><encryption><des>","1","2","1","2017-06-25 10:38:05","15406629","0","2","","","","2013-03-14 10:13:37",""
"19734916","PHP script for DES/CBC/ with PKCS5Padding encryption and decryption","<p>I would like to know in the following code if PKCS#5 padding is added ? If not how to add ?</p>

<pre><code>$message = ""insert plaintext message here"";

$iv  = pack('H*', 'insert hex iv here');
$key = pack('H*', 'insert hex key here');

$enc = mcrypt_encrypt(MCRYPT_DES, $key, $message, MCRYPT_MODE_CBC, $iv);

echo bin2hex($enc);
</code></pre>

<p>I also want to create a PHP code to decrypt a string created with DES/CBC/PKCS5Padding. I think the above mentioned code can be modified to get a decryption.</p>

<p>The important thing for me is to get the PKCS#5 Padding and Unpadding script.</p>
","<p>No, it is not added. Unfortunately PHP / mcrypt uses zero padding until the message is N times the block size.</p>

<p>To add PKCS#5 padding, use the formula:</p>

<pre><code>p = b - l % b
</code></pre>

<p>Where <code>l</code> is the message length, <code>b</code> is the block size and <code>%</code> is the remainder operation. Then add <code>p</code> bytes with the value <code>p</code> to the end before performing the encryption.</p>
","3202","<php><encryption><mcrypt><des><pkcs#5>","2","3","2","2013-11-03 15:15:00","","0","1","367456","","2013-11-03 15:15:00","2013-11-01 20:30:55",""
"19734916","PHP script for DES/CBC/ with PKCS5Padding encryption and decryption","<p>I would like to know in the following code if PKCS#5 padding is added ? If not how to add ?</p>

<pre><code>$message = ""insert plaintext message here"";

$iv  = pack('H*', 'insert hex iv here');
$key = pack('H*', 'insert hex key here');

$enc = mcrypt_encrypt(MCRYPT_DES, $key, $message, MCRYPT_MODE_CBC, $iv);

echo bin2hex($enc);
</code></pre>

<p>I also want to create a PHP code to decrypt a string created with DES/CBC/PKCS5Padding. I think the above mentioned code can be modified to get a decryption.</p>

<p>The important thing for me is to get the PKCS#5 Padding and Unpadding script.</p>
","<p>I have found some scripts and modified them below , check if now the PKCS#5 Padding is done .</p>

<pre><code>&lt;?php 
function printStringToHex($text)
{
    $size = strlen($text);
    for($i = 0; $i &lt; $size; $i++)
    {
        echo dechex(ord($text[$i])) . "" "";
    }
}

function encrypt($input) 
{ 
    echo ""&lt;PRE&gt;*** Encrypt *** &lt;/PRE&gt;"";
    echo ""&lt;PRE&gt;Raw input: "" . $input . ""&lt;/PRE&gt;"";
    $size = mcrypt_get_block_size('des', 'cbc'); 
    echo ""&lt;PRE&gt;Block: "" . $size . ""&lt;/PRE&gt;"";
    $input = pkcs5_pad($input, $size); 
    echo ""&lt;PRE&gt;PKCS#5 padding: "";
    echo printStringToHex($input);
    echo ""&lt;/PRE&gt;"";

    $td = mcrypt_module_open('des', '', 'cbc', ''); 
    $iv = pack('H*','insert hex iv here');
    $key = pack('H*','insert hex key here');
    mcrypt_generic_init($td, $key, $iv); 
    $data = mcrypt_generic($td, $input); 
    echo ""&lt;PRE&gt;Raw output: "" . $data . ""&lt;/PRE&gt;"";
    echo ""&lt;PRE&gt;Hex output: "";
    echo printStringToHex($data);
    echo ""&lt;/PRE&gt;"";
    mcrypt_generic_deinit($td); 
    mcrypt_module_close($td); 
    $data = base64_encode($data); 
    echo ""&lt;PRE&gt;B64 output: "" . $data . ""&lt;/PRE&gt;"";
    echo ""&lt;PRE&gt;B64 output len: "";
    echo strlen($data) . ""&lt;/PRE&gt;"";
    return $data; 
} 

function pkcs5_pad ($text, $blocksize) 
{ 
    $pad = $blocksize - (strlen($text) % $blocksize); 
    return $text . str_repeat(chr($pad), $pad); 
} 

$enc = encrypt(""insert plaintext message here"");
</code></pre>
","3202","<php><encryption><mcrypt><des><pkcs#5>","2","2","2","2013-11-03 15:15:00","","0","1","367456","","2013-11-03 15:15:00","2013-11-01 20:30:55",""
"7627266","DES Cryptography in C#","<p>I've been trying to find out the correct way to encrypt a byte[16] variable using DES algorithm. Here's the scenario:  </p>

<ul>
<li>The data should be encrypted in 8-byte parts. the key for encryption is: <code>byte[] {11, 11, 11, 11, 11, 11, 11, 11}</code></li>
<li>First 8 bytes is encrypted using <code>Instance Vector = new byte[8]</code> (8 bytes with 0 value).</li>
<li>the encrypted result will be the IV for the next 8 bytes.  (is this CBC?)</li>
<li>that last 8 byte is the result I should send.  </li>
</ul>

<p>With this information, I have implemented the <code>Encrypt</code> method as follows:  </p>

<pre><code>public static byte[] Encrypt(byte[] data)
{
    var dataChunk = new byte[8];
    var IV = new byte[8];
    var result = new byte[8];
    var key = new byte[] { 11, 11, 11, 11, 11, 11, 11, 11 };

    for (int counter = 0; counter &lt; data.Length / 8; counter++)
    {
        // Copy the next 8-byte chunk.
        Array.Copy(data, counter * 8, dataChunk, 0, 8);
        var des = System.Security.Cryptography.DES.Create();
        des.Key = key;
        des.IV = IV;
        des.Padding = PaddingMode.None;
        ICryptoTransform cryptoTransform = des.CreateEncryptor(key, IV);

        // Encrypt the datra chunk.
        cryptoTransform.TransformBlock(dataChunk, 0, 8, result, 0);

        // Set the new IV.
        Array.Copy(result, IV, 8);
    } 
return result;
}
</code></pre>

<p>Is this the correct way of encrypting data using DES cryptography?</p>
","<p>You don't need to create an <em>encryptor</em> for each block. <strong>The <em>encryptor</em> itself implements the operation modes (<em>CBC</em>, ...) and padding.</strong>
So you need something like this:</p>

<pre><code>byte[] input = ...
byte[] key = ...
byte[] iv = ...

using (DES des = DES.Create())
{
    des.Mode = CipherMode.CBC;
    des.Padding = PaddingMode.None;

    using (ICryptoTransform encryptor = des.CreateEncryptor(key , iv))
    {
        byte[] output = encryptor.TransformFinalBlock(input, 0, input.Length);
    }
}
</code></pre>

<p><em>I'm omitting the warning of using DES here. You might also want to take a look at <a href=""http://msdn.microsoft.com/library/system.security.cryptography.cryptostream.aspx"" rel=""nofollow"">CryptoStream</a> afterwards for an even easier en- and decryption ...</em></p>
","3195","<.net><encryption><des>","1","3","2","2011-10-02 19:59:08","7627802","1","","516656","","2011-10-02 17:25:57","2011-10-02 14:25:01",""
"7627266","DES Cryptography in C#","<p>I've been trying to find out the correct way to encrypt a byte[16] variable using DES algorithm. Here's the scenario:  </p>

<ul>
<li>The data should be encrypted in 8-byte parts. the key for encryption is: <code>byte[] {11, 11, 11, 11, 11, 11, 11, 11}</code></li>
<li>First 8 bytes is encrypted using <code>Instance Vector = new byte[8]</code> (8 bytes with 0 value).</li>
<li>the encrypted result will be the IV for the next 8 bytes.  (is this CBC?)</li>
<li>that last 8 byte is the result I should send.  </li>
</ul>

<p>With this information, I have implemented the <code>Encrypt</code> method as follows:  </p>

<pre><code>public static byte[] Encrypt(byte[] data)
{
    var dataChunk = new byte[8];
    var IV = new byte[8];
    var result = new byte[8];
    var key = new byte[] { 11, 11, 11, 11, 11, 11, 11, 11 };

    for (int counter = 0; counter &lt; data.Length / 8; counter++)
    {
        // Copy the next 8-byte chunk.
        Array.Copy(data, counter * 8, dataChunk, 0, 8);
        var des = System.Security.Cryptography.DES.Create();
        des.Key = key;
        des.IV = IV;
        des.Padding = PaddingMode.None;
        ICryptoTransform cryptoTransform = des.CreateEncryptor(key, IV);

        // Encrypt the datra chunk.
        cryptoTransform.TransformBlock(dataChunk, 0, 8, result, 0);

        // Set the new IV.
        Array.Copy(result, IV, 8);
    } 
return result;
}
</code></pre>

<p>Is this the correct way of encrypting data using DES cryptography?</p>
","<p>I can't help you with the C#, but I can attempt to address your last question: whether this is the ""correct way"" to encrypt. Well, that answer depends on what you're expecting to do.</p>

<p>What you've implemented is a mode known as CBC-MAC; it doesn't allow the receiver to recover the message (and hence it's not really ""encryption"" at all); one clue to this is that the message is 16 bytes, but the ""encrypted"" message is only 8 bytes.  It does have the property that it is difficult for someone in the middle to modify the message and to come up with the correct 8 byte MAC value (assuming they don't have the key); hence, things like this are often used as cryptographically strong integrity checks.  Now, CBC-MAC does have problems with length extension attacks; if you don't care about length extension attacks (all your messages are 16 bytes), this might not be important to you?</p>

<p>Is CBC-MAC the right thing for your application?  Well, I don't know the answer to that; the key questions for you:</p>

<ul>
<li>What are you trying to do?  Are you trying to ""encrypt"" a message (so that the other side can recover it)?  Or, are you trying to prove that the message was sent by someone with the key?</li>
<li>Are you trying to be compatible with someone else?  Has that someone else specified this ""encryption"" method?</li>
<li>ortag decided to omit the warnings for DES, but I think I'll include them - DES can be broken with not totally unreasonable amounts of work; it's probably safe against your kid sister and maybe even joe average hacker, but if your adversary has access to a some computer resources, he can break this.  If this is a concern, you'll want to switch to a stronger cipher, such as AES</li>
</ul>
","3195","<.net><encryption><des>","1","2","2","2011-10-02 19:59:08","7627802","1","","516656","","2011-10-02 17:25:57","2011-10-02 14:25:01",""
"10634065","encryption using provided key using DES with padding","<p>I want to encrypt a frame using DES using a given key. </p>

<p>The padding style I am using is PKCS5Padding. This pads the string with 02 02 if 2 bytes are to be added and with 03 03 03 if 3 bytes are to be added to make multiple of 8.
But my requirement is to pad a string with my particular bytes. e.g if 2 bytes are to be added then 30 30 and 3 bytes are to be added then 30 30 30 (in hex 0's value is 30). Also, I must know how many padded bytes have been added.
Which padding technique should I follow and how can I use it?</p>

<p>Below is my code for encryption:</p>

<pre><code>byte[] keyValue = new byte[]{(byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x16,(byte) 0x05, (byte) 0x12};
myKeySpec = new DESKeySpec(keyValue);
mySecretKeyFactory = SecretKeyFactory.getInstance(""DES"");
key = mySecretKeyFactory.generateSecret(myKeySpec);


Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
IvParameterSpec iv2 = new IvParameterSpec(new byte[8]);
cipher.init(Cipher.ENCRYPT_MODE, key, iv2);
byte[] plainText = function.HexStringToByteArray(payloadRecv);
byte[] encryptedText = cipher.doFinal(plainText);
</code></pre>
","<p>Do not select <code>PKCS5Padding</code> in the cipher specification. Select <code>NoPadding</code>. You'll have to add the padding onto the data yourself prior to encrypting it. After decrypting it (also using no padding), you'll have to inspect the last byte to know how many bytes of padding to remove and remove it yourself.</p>

<p>Basically, just code exactly what you described.</p>
","3192","<java><encryption><padding><des>","1","3","1","2018-06-26 09:12:46","","0","2","1033581","","2018-06-26 09:12:46","2012-05-17 10:33:17",""
"13107675","C# Simplified DES (S-DES) to encrypt and decrypt 128-bit blocks of plain text","<p>Can you please help me with C# source code for Console, Web or Win form to encrypt and decrypt 128-bit blocks of plain text with Simplified DES (S-DES)? I know that C# has a class of DES in <code>System.Security.Cryptography</code> namespace but I can not use it for academic use.</p>
","<p>There's a fairly verbose (=readable) Python implementation of that algorithm here:</p>

<p><a href=""http://hg.sagemath.org/sage-main/file/d06cf4b2215d/sage/crypto/block_cipher/sdes.py"" rel=""nofollow"">http://hg.sagemath.org/sage-main/file/d06cf4b2215d/sage/crypto/block_cipher/sdes.py</a></p>

<p>You could translate that into C# and be on your merry way. :)</p>
","3135","<c#><encryption><des>","1","0","2","2012-10-29 16:33:58","","1","","159369","","2012-10-29 16:33:58","2012-10-28 09:24:38","2012-10-29 18:09:00"
"13107675","C# Simplified DES (S-DES) to encrypt and decrypt 128-bit blocks of plain text","<p>Can you please help me with C# source code for Console, Web or Win form to encrypt and decrypt 128-bit blocks of plain text with Simplified DES (S-DES)? I know that C# has a class of DES in <code>System.Security.Cryptography</code> namespace but I can not use it for academic use.</p>
","<p>I have written an <a href=""http://www.codeproject.com/Articles/91628/Simplified-version-of-the-DES-Data-Encryption-Stan"" rel=""nofollow"">article</a> in CodeProject, to Implement a simplified version of the DES block cipher algorithm using C# to encrypt and decrypt binary files.</p>

<p>The <strong><em>SDES.cs</em></strong> class is a generic class which could be used to encrypt/decrypt binary files or plain text.</p>

<p>I will change the two following methods in MainFrm.cs file to suit your needs</p>

<pre><code>private void Encrypt()
private void Decrypt()
</code></pre>

<p>The changes as follow, instead of opening the file using the <strong><em>BinaryReader</em></strong> class,</p>

<ul>
<li>I will loop over the plain text ""string"" and read it char by char</li>
<li>convert each char to byte </li>
<li>encrypt the byte and append it to byte array</li>
<li>finally convert the encrypted bytes to chars again</li>
</ul>

<p>the code will be:</p>

<pre><code>private void Encrypt()
{
     byte[] output = new byte[txt_enc_in.Text.Length];
     for (int i = 0; i &lt; output.Length; i++)
     {
          output[i] = my_Des.Encrypt(Convert.ToByte(txt_enc_in.Text[i]));
     }
     txt_enc_out.Text = """";
     for (int i = 0; i &lt; output.Length; i++)
     {
          txt_enc_out.Text += Convert.ToChar(output[i]);
     }
 }  
</code></pre>

<p>the inverse steps also applied on the <strong><em>Decrypt()</em></strong> method, also some changes should be applied on the GUI.
the final code is available <a href=""http://imljh.ucoz.com/code/SDES_Plain_Text.zip"" rel=""nofollow"">here</a>.</p>
","3135","<c#><encryption><des>","1","1","2","2012-10-29 16:33:58","","1","","159369","","2012-10-29 16:33:58","2012-10-28 09:24:38","2012-10-29 18:09:00"
"1262594","DES encryption of 8 bytes plain text results in 16 bytes array","<p>I am using this code to encrypt a 8 bytes PlainText with a 8 bytes Key but the result is always a 16 bytes array.</p>

<pre><code>public static byte[] Encrypt(byte[] PlainText, byte[] key)
{
    MemoryStream ms = new MemoryStream();
    DESCryptoServiceProvider mDES = new DESCryptoServiceProvider();
    mDES.Mode = CipherMode.ECB;
    mDES.Key = key;

    CryptoStream encStream = new CryptoStream(ms, mDES.CreateEncryptor(), CryptoStreamMode.Write);
    BinaryWriter bw = new BinaryWriter(encStream);

    bw.Write(PlainText);
    bw.Close();
    encStream.Close();

    byte[] buffer = ms.ToArray();
    ms.Close();

    return buffer;
}
</code></pre>

<p>The first 8 bytes of the ouptut is what I expect but the rest I don't what it is.. is it something wrong with this code?</p>
","<p>The input will be padded to the <strong>next</strong> block size using <a href=""http://en.wikipedia.org/wiki/PKCS"" rel=""nofollow noreferrer"">PKCS padding</a>. 7 bytes input will be padded to 8. 8-15 to 16. 16-23 to 24 and so on and so forth.</p>
","3114","<c#><encryption><des>","4","8","1","2012-02-27 19:51:44","1262623","0","","14131","","2012-02-27 19:51:44","2009-08-11 20:04:09",""
"10197249","DES/ECB/PKCS5Padding decryption in PHP","<p>I'm in the need of decrypting with PHP (or Javascript) some service calls. I've spent all the day trying to accomplish, this, but I've been unable to decrypt it properly.</p>

<p>As a reference, the service provider sent me the following decryption sample code in Java:</p>

<pre><code>DESKeySpec dks = new DESKeySpec(""keyword"".getBytes()); 
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
SecretKey key = keyFactory.generateSecret(dks);

Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
SecureRandom sr = new SecureRandom();  
cipher.init( Cipher.DECRYPT_MODE, key ,sr); 

byte b[] = response.toByteArray();      
byte decryptedData[] = cipher.doFinal( b );
</code></pre>

<p>I think I'm in the correct path by using:</p>

<pre><code>$td = mcrypt_module_open(MCRYPT_DES, '', 'ecb', '');
$iv_size = mcrypt_enc_get_iv_size($td);
$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
$key = substr($keyword, 0, mcrypt_enc_get_key_size($td));
mcrypt_generic_init($td, $key, $iv);
$decrypted = mdecrypt_generic($td, $data);
$decrypted = pkcs5_unpad($decrypted);
</code></pre>

<p>But, frankly, I'm sure I'm messing everything with the $iv creationg and $keyword setup (or maybe with $data or $decrypted types?). The pkcs5_unpad function is as follows:</p>

<pre><code>function pkcs5_unpad($text)
{
   $pad = ord($text{strlen($text)-1});
   if ($pad &gt; strlen($text)) return false;
   return substr($text, 0, -1 * $pad);
}
</code></pre>

<p>I'm not only a noob on php, but also on cryptography techniques... could you please help me to solve this issue?</p>
","<p>Make sure your key consists of the same bytes (strings may be encoded differently) and feed it a IV filled with zero's. ECB mode does not use an IV (and the PHP manual specifies as much), but if you do give it one default it to all zero's - the IV will be XOR'ed with the first plain text block, so setting it to all zero's will cancel out that operation. Also, make sure that the input cipher data is the same. Ignore the padding in the first instance, you should be able to check if the result is correct before unpadding.</p>
","3020","<php><encryption><des>","3","0","1","2012-04-18 00:17:38","","4","2","","","","2012-04-17 18:51:35",""
"19924657","Encrypt the text using DES secret key in java","<p>I am trying to make encryption and decryption program through DES. In this code section I am creating a secretKey </p>

<pre><code>  Cipher desCipher;
  KeyGenerator keygenerator;
  SecretKey myDesKey; 
  try{
    keygenerator = KeyGenerator.getInstance(""DES"");
    myDesKey = keygenerator.generateKey();
    byte[] encoded = myDesKey.getEncoded();
    // convert secret key to string 
   String stringKey =Base64.encodeToString(myDesKey.getEncoded());

    // converting back from  string to secret key. 
    //its returning javax.crypto.spec.SecretKey object but i need com.sun.crypto.provider.DESKey object

   SecretKey originalKey = new SecretKeySpec(stringKey.getBytes(), 0, stringKey.length(), ""DES""); 
      String text=""hello how are you "" 
     desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
    byte[] textEncrypted = desCipher.doFinal(text.getBytes());   

    System.out.println(""text encrypted successfully"");        

    }
    catch(Exception ex)
     {
       ex.printStackTrace();
     }

is throwing the exception 
</code></pre>

<p>java.security.InvalidKeyException: No installed provider supports this key: (null)</p>
","<p>You're converting the key to base-64, but not converting it back again.</p>
","3001","<java><encryption><des>","0","1","1","2013-11-12 09:37:18","","3","2","2791255","","2013-11-12 09:37:18","2013-11-12 08:50:20",""
"24168246","Replicate Java's PBEWithMD5AndDES in Python 2.7","<p>If it's not immediately obvious, let me start by saying I am not a crypto person.</p>

<p>I have been tasked with replicating the behavior of Java's PBEWithMD5AndDES (MD5 digest with DES encryption) in Python 2.7.</p>

<p>I do have access to Python's cryptography toolkit PyCrypto.</p>

<p>Here is the Java code whose behavior I am trying to replicate:</p>

<pre><code>import java.security.spec.KeySpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.Cipher;
import javax.xml.bind.DatatypeConverter;

public class EncryptInJava
{
    public static void main(String[] args)
    {
      String encryptionPassword = ""q1w2e3r4t5y6"";
      byte[] salt = { -128, 64, -32, 16, -8, 4, -2, 1 };
      int iterations = 50;

      try
      {
        KeySpec keySpec = new PBEKeySpec(encryptionPassword.toCharArray(), salt, iterations);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterations);

        Cipher encoder = Cipher.getInstance(key.getAlgorithm());
        encoder.init(Cipher.ENCRYPT_MODE, key, paramSpec);

        String str_to_encrypt = ""MyP455w0rd"";
        byte[] enc = encoder.doFinal(str_to_encrypt.getBytes(""UTF8""));

        System.out.println(""encrypted = "" + DatatypeConverter.printBase64Binary(enc));
      }
      catch (Exception e)
      {
        e.printStackTrace();
      }
    }
}
</code></pre>

<p>For the given values, it outputs the following:</p>

<pre><code>encrypted = Icy6sAP7adLgRoXNYe9N8A==
</code></pre>

<p>Here's my ham-handed attempt to port the above to Python, <code>encrypt_in_python.py</code>:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES

_password = 'q1w2e3r4t5y6'
_salt = '\x80\x40\xe0\x10\xf8\x04\xfe\x01'
_iterations = 50
plaintext_to_encrypt = 'MyP455w0rd'

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    key = result[:8]

    encoder = DES.new(key)
    encrypted = encoder.encrypt(plaintext_to_encrypt + ' ' * (8 - (len(plaintext_to_encrypt) % 8)))
    print encrypted.encode('base64')
</code></pre>

<p>It outputs a completely different string.</p>

<p>Is it possible to port the Java implementation to a Python implementation with standard Python libraries?</p>

<p>Apparently the Python implementation requires that the plaintext that I encrypt be a multiple of eight characters, and I'm not even sure exactly how to pad my plaintext input to meet that condition.</p>

<p>Thanks for your help.</p>
","<p>Thanks to GregS's comment, I was able to sort this conversion out!</p>

<p>For future reference, this Python code mimics the behavior of the Java code above:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES

_password = 'q1w2e3r4t5y6'
_salt = '\x80\x40\xe0\x10\xf8\x04\xfe\x01'
_iterations = 50
plaintext_to_encrypt = 'MyP455w0rd'

# Pad plaintext per RFC 2898 Section 6.1
padding = 8 - len(plaintext_to_encrypt) % 8
plaintext_to_encrypt += chr(padding) * padding

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])
    encrypted = encoder.encrypt(plaintext_to_encrypt)

    print encrypted.encode('base64')
</code></pre>

<p>This Python code outputs the following in Python 2.7:</p>

<pre><code>Icy6sAP7adLgRoXNYe9N8A==
</code></pre>

<p>Thanks again to GregS for pointing me in the right direction!</p>
","2965","<java><python-2.7><encryption><md5><des>","4","2","4","2018-03-05 22:14:58","24251226","3","4","","","","2014-06-11 16:43:35",""
"24168246","Replicate Java's PBEWithMD5AndDES in Python 2.7","<p>If it's not immediately obvious, let me start by saying I am not a crypto person.</p>

<p>I have been tasked with replicating the behavior of Java's PBEWithMD5AndDES (MD5 digest with DES encryption) in Python 2.7.</p>

<p>I do have access to Python's cryptography toolkit PyCrypto.</p>

<p>Here is the Java code whose behavior I am trying to replicate:</p>

<pre><code>import java.security.spec.KeySpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.Cipher;
import javax.xml.bind.DatatypeConverter;

public class EncryptInJava
{
    public static void main(String[] args)
    {
      String encryptionPassword = ""q1w2e3r4t5y6"";
      byte[] salt = { -128, 64, -32, 16, -8, 4, -2, 1 };
      int iterations = 50;

      try
      {
        KeySpec keySpec = new PBEKeySpec(encryptionPassword.toCharArray(), salt, iterations);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterations);

        Cipher encoder = Cipher.getInstance(key.getAlgorithm());
        encoder.init(Cipher.ENCRYPT_MODE, key, paramSpec);

        String str_to_encrypt = ""MyP455w0rd"";
        byte[] enc = encoder.doFinal(str_to_encrypt.getBytes(""UTF8""));

        System.out.println(""encrypted = "" + DatatypeConverter.printBase64Binary(enc));
      }
      catch (Exception e)
      {
        e.printStackTrace();
      }
    }
}
</code></pre>

<p>For the given values, it outputs the following:</p>

<pre><code>encrypted = Icy6sAP7adLgRoXNYe9N8A==
</code></pre>

<p>Here's my ham-handed attempt to port the above to Python, <code>encrypt_in_python.py</code>:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES

_password = 'q1w2e3r4t5y6'
_salt = '\x80\x40\xe0\x10\xf8\x04\xfe\x01'
_iterations = 50
plaintext_to_encrypt = 'MyP455w0rd'

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    key = result[:8]

    encoder = DES.new(key)
    encrypted = encoder.encrypt(plaintext_to_encrypt + ' ' * (8 - (len(plaintext_to_encrypt) % 8)))
    print encrypted.encode('base64')
</code></pre>

<p>It outputs a completely different string.</p>

<p>Is it possible to port the Java implementation to a Python implementation with standard Python libraries?</p>

<p>Apparently the Python implementation requires that the plaintext that I encrypt be a multiple of eight characters, and I'm not even sure exactly how to pad my plaintext input to meet that condition.</p>

<p>Thanks for your help.</p>
","<p>I found one from <a href=""https://github.com/binsgit/PBEWithMD5AndDES"" rel=""nofollow"">here</a></p>

<pre><code>import base64
import hashlib
import re
import os
from Crypto.Cipher import DES
def get_derived_key(password, salt, count):
    key = password + salt
    for i in range(count):
        m = hashlib.md5(key)
        key = m.digest()
    return (key[:8], key[8:])
def decrypt(msg, password):
    msg_bytes = base64.b64decode(msg)
    salt = '\xA9\x9B\xC8\x32\x56\x35\xE3\x03'
    enc_text = msg_bytes
    (dk, iv) = get_derived_key(password, salt, 2)
    crypter = DES.new(dk, DES.MODE_CBC, iv)
    text = crypter.decrypt(enc_text)
    return re.sub(r'[\x01-\x08]','',text)
def encrypt(msg, password):
    salt = '\xA9\x9B\xC8\x32\x56\x35\xE3\x03'
    pad_num = 8 - (len(msg) % 8)
    for i in range(pad_num):
        msg += chr(pad_num)
    (dk, iv) = get_derived_key(password, salt, 2)
    crypter = DES.new(dk, DES.MODE_CBC, iv)
    enc_text = crypter.encrypt(msg)
    return base64.b64encode(enc_text)
def main():
    msg = ""hello""
    passwd = ""xxxxxxxxxxxxxx""
    encrypted_msg = encrypt(msg, passwd)
    print encrypted_msg
    plain_msg = decrypt(encrypted_msg, passwd)
    print plain_msg
if __name__ == ""__main__"":
    main()
</code></pre>
","2965","<java><python-2.7><encryption><md5><des>","4","0","4","2018-03-05 22:14:58","24251226","3","4","","","","2014-06-11 16:43:35",""
"24168246","Replicate Java's PBEWithMD5AndDES in Python 2.7","<p>If it's not immediately obvious, let me start by saying I am not a crypto person.</p>

<p>I have been tasked with replicating the behavior of Java's PBEWithMD5AndDES (MD5 digest with DES encryption) in Python 2.7.</p>

<p>I do have access to Python's cryptography toolkit PyCrypto.</p>

<p>Here is the Java code whose behavior I am trying to replicate:</p>

<pre><code>import java.security.spec.KeySpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.Cipher;
import javax.xml.bind.DatatypeConverter;

public class EncryptInJava
{
    public static void main(String[] args)
    {
      String encryptionPassword = ""q1w2e3r4t5y6"";
      byte[] salt = { -128, 64, -32, 16, -8, 4, -2, 1 };
      int iterations = 50;

      try
      {
        KeySpec keySpec = new PBEKeySpec(encryptionPassword.toCharArray(), salt, iterations);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterations);

        Cipher encoder = Cipher.getInstance(key.getAlgorithm());
        encoder.init(Cipher.ENCRYPT_MODE, key, paramSpec);

        String str_to_encrypt = ""MyP455w0rd"";
        byte[] enc = encoder.doFinal(str_to_encrypt.getBytes(""UTF8""));

        System.out.println(""encrypted = "" + DatatypeConverter.printBase64Binary(enc));
      }
      catch (Exception e)
      {
        e.printStackTrace();
      }
    }
}
</code></pre>

<p>For the given values, it outputs the following:</p>

<pre><code>encrypted = Icy6sAP7adLgRoXNYe9N8A==
</code></pre>

<p>Here's my ham-handed attempt to port the above to Python, <code>encrypt_in_python.py</code>:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES

_password = 'q1w2e3r4t5y6'
_salt = '\x80\x40\xe0\x10\xf8\x04\xfe\x01'
_iterations = 50
plaintext_to_encrypt = 'MyP455w0rd'

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    key = result[:8]

    encoder = DES.new(key)
    encrypted = encoder.encrypt(plaintext_to_encrypt + ' ' * (8 - (len(plaintext_to_encrypt) % 8)))
    print encrypted.encode('base64')
</code></pre>

<p>It outputs a completely different string.</p>

<p>Is it possible to port the Java implementation to a Python implementation with standard Python libraries?</p>

<p>Apparently the Python implementation requires that the plaintext that I encrypt be a multiple of eight characters, and I'm not even sure exactly how to pad my plaintext input to meet that condition.</p>

<p>Thanks for your help.</p>
","<p>For Python 3.6, I tested with following code and it works with a little change from above:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES
import base64
import re

_password = b'q1w2e3r4t5y6'
_salt = b'\x80\x40\xe0\x10\xf8\x04\xfe\x01'

_iterations = 50

plaintext_to_encrypt = 'MyP455w0rd'

# Pad plaintext per RFC 2898 Section 6.1
padding = 8 - len(plaintext_to_encrypt) % 8
plaintext_to_encrypt += chr(padding) * padding

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])
    encrypted = encoder.encrypt(plaintext_to_encrypt)

    print (str(base64.b64encode(encrypted),'utf-8'))

    decoder = DES.new(result[:8], DES.MODE_CBC, result[8:])
    d = str(decoder.decrypt(encrypted),'utf-8')
    print (re.sub(r'[\x01-\x08]','',d))
</code></pre>

<p>Output:</p>

<blockquote>
  <p>Icy6sAP7adLgRoXNYe9N8A==</p>
  
  <p>MyP455w0rd</p>
</blockquote>
","2965","<java><python-2.7><encryption><md5><des>","4","2","4","2018-03-05 22:14:58","24251226","3","4","","","","2014-06-11 16:43:35",""
"24168246","Replicate Java's PBEWithMD5AndDES in Python 2.7","<p>If it's not immediately obvious, let me start by saying I am not a crypto person.</p>

<p>I have been tasked with replicating the behavior of Java's PBEWithMD5AndDES (MD5 digest with DES encryption) in Python 2.7.</p>

<p>I do have access to Python's cryptography toolkit PyCrypto.</p>

<p>Here is the Java code whose behavior I am trying to replicate:</p>

<pre><code>import java.security.spec.KeySpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.Cipher;
import javax.xml.bind.DatatypeConverter;

public class EncryptInJava
{
    public static void main(String[] args)
    {
      String encryptionPassword = ""q1w2e3r4t5y6"";
      byte[] salt = { -128, 64, -32, 16, -8, 4, -2, 1 };
      int iterations = 50;

      try
      {
        KeySpec keySpec = new PBEKeySpec(encryptionPassword.toCharArray(), salt, iterations);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterations);

        Cipher encoder = Cipher.getInstance(key.getAlgorithm());
        encoder.init(Cipher.ENCRYPT_MODE, key, paramSpec);

        String str_to_encrypt = ""MyP455w0rd"";
        byte[] enc = encoder.doFinal(str_to_encrypt.getBytes(""UTF8""));

        System.out.println(""encrypted = "" + DatatypeConverter.printBase64Binary(enc));
      }
      catch (Exception e)
      {
        e.printStackTrace();
      }
    }
}
</code></pre>

<p>For the given values, it outputs the following:</p>

<pre><code>encrypted = Icy6sAP7adLgRoXNYe9N8A==
</code></pre>

<p>Here's my ham-handed attempt to port the above to Python, <code>encrypt_in_python.py</code>:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES

_password = 'q1w2e3r4t5y6'
_salt = '\x80\x40\xe0\x10\xf8\x04\xfe\x01'
_iterations = 50
plaintext_to_encrypt = 'MyP455w0rd'

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    key = result[:8]

    encoder = DES.new(key)
    encrypted = encoder.encrypt(plaintext_to_encrypt + ' ' * (8 - (len(plaintext_to_encrypt) % 8)))
    print encrypted.encode('base64')
</code></pre>

<p>It outputs a completely different string.</p>

<p>Is it possible to port the Java implementation to a Python implementation with standard Python libraries?</p>

<p>Apparently the Python implementation requires that the plaintext that I encrypt be a multiple of eight characters, and I'm not even sure exactly how to pad my plaintext input to meet that condition.</p>

<p>Thanks for your help.</p>
","<p>If you're using the newer Cryptodome library with Python 3, you'll need to also encode your plaintext_to_encrypt to 'latin-1', as is shown below.</p>

<pre><code>from Cryptodome.Hash import MD5
from Cryptodome.Cipher import DES
import base64
import re

_password = b'q1w2e3r4t5y6'
_salt = b'\x80\x40\xe0\x10\xf8\x04\xfe\x01'

_iterations = 50

plaintext_to_encrypt = 'MyP455w0rd'

# Pad plaintext per RFC 2898 Section 6.1
padding = 8 - len(plaintext_to_encrypt) % 8
plaintext_to_encrypt += chr(padding) * padding

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])
    encrypted = encoder.encrypt(plaintext_to_encrypt.encode('latin-1'))  #encoded plaintext

    print (str(base64.b64encode(encrypted),'utf-8'))

    decoder = DES.new(result[:8], DES.MODE_CBC, result[8:])
    d = str(decoder.decrypt(encrypted),'utf-8')
    print (re.sub(r'[\x01-\x08]','',d))
</code></pre>
","2965","<java><python-2.7><encryption><md5><des>","4","0","4","2018-03-05 22:14:58","24251226","3","4","","","","2014-06-11 16:43:35",""
"16390526","Using DES to encrypt and decrypt a file in Java","<p>I'm trying to serialize an object (in this case a simple string), encrypt it, and write it to a file. The encryption seems to work, but the decryption always fails. I've tried searching around, but I can't seem to figure out what I'm doing wrong..</p>

<pre><code>// Create a new key to encrypt and decrypt the file
byte[] key = ""password"".getBytes();

// Get a cipher object in encrypt mode 
Cipher cipher = null;
try {
    DESKeySpec dks = new DESKeySpec(key);
    SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
    SecretKey desKey = skf.generateSecret(dks);
    cipher = Cipher.getInstance(""DES"");
    cipher.init(Cipher.ENCRYPT_MODE, desKey);
} catch (InvalidKeyException | NoSuchAlgorithmException | InvalidKeySpecException | NoSuchPaddingException ex) {
    System.err.println(""[CRITICAL] Incryption chiper error"");
}

// Encrypt the file
try {
    new ObjectOutputStream(new CipherOutputStream(new FileOutputStream(""test""), cipher)).writeObject(""test text"");
} catch (IOException e) {
    System.err.println(""[CRITICAL] Error encrypting data: "" + e.getMessage());
    e.printStackTrace();
}

// Get a cipher object in decrypt mode
try {
    DESKeySpec dks = new DESKeySpec(key);
    SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
    SecretKey desKey = skf.generateSecret(dks);
    cipher = Cipher.getInstance(""DES"");
    cipher.init(Cipher.DECRYPT_MODE, desKey);
} catch (InvalidKeyException | NoSuchAlgorithmException | InvalidKeySpecException | NoSuchPaddingException ex) {
    System.err.println(""[CRITICAL] Incryption chiper error"");
}

// Decrypt the file
try {
    // This is the line that throws the exception
    System.out.println((String) new ObjectInputStream(new CipherInputStream(new FileInputStream(""test""), cipher)).readObject()); 
} catch (IOException | ClassNotFoundException e) {
    System.err.println(""[CRITICAL] Error decrypting data: "" + e.getMessage());
    e.printStackTrace();
}
</code></pre>

<p>Running the above code results in the following exception:</p>

<pre><code>[CRITICAL] Error decrypting data: null
java.io.EOFException
at java.io.ObjectInputStream$PeekInputStream.readFully(ObjectInputStream.java:2304)
at java.io.ObjectInputStream$BlockDataInputStream.readUTFBody(ObjectInputStream.java:3042)
at java.io.ObjectInputStream$BlockDataInputStream.readUTF(ObjectInputStream.java:2843)
at java.io.ObjectInputStream.readString(ObjectInputStream.java:1617)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1338)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:369)
at Server.DataPersistence.main(DataPersistence.java:203)
</code></pre>

<p>Does anyone have any ideas?</p>

<p>Thanks!</p>
","<p>My guess is that nothing has been written to the file when you attempt to open and re-read the data back into your program.  Try calling <code>flush();</code> and then <code>close();</code> on the output stream before attempting to read the file back in again.</p>
","2963","<java><serialization><des>","1","5","1","2013-05-06 00:44:15","16390546","0","","2234261","","2013-05-06 00:44:15","2013-05-06 00:28:34",""
"29698474","Paddling DES with Crypto.Cipher / ValueError: Input strings must be a multiple of 8 in length","<p>I'm trying to decrypt Bloomberg files which are DES encrypted.</p>

<p>I'm getting a 'ValueError: Input strings must be a multiple of 8 in length 
' which I understand means I need to 'paddle' the data to the proper byte size. In this correct?</p>

<p>If so, how can I do it using Crypto.Cipher?</p>

<pre><code>f = open(SourcePath+FileName, 'r')
content = f.readlines()
key = b'Eight888'
msg=content[0]
from Crypto.Cipher import DES
decCipher = DES.new(key, DES.MODE_OFB, msg[:DES.block_size])
msgback = decCipher.decrypt(msg[DES.block_size:])
</code></pre>
","<p>You need to be sure that <code>msg</code> has a length that is a multiple of 8. It not, just add some random chars at the end of it.</p>

<p><em>Updated after BuckTurgidson comments</em></p>

<p>A quick test can be </p>

<pre><code>if len(msg) % 8 != 0:
    toAdd = 8 - len(msg) % 8
    # add toAdd chars to msg
</code></pre>

<p>but this work only if <code>msg</code> is a string</p>

<p>The logic is valid also for binary buffers</p>
","2882","<python><padding><des><bloomberg>","0","1","2","2015-04-20 13:17:28","29699046","1","","","","","2015-04-17 11:54:45",""
"29698474","Paddling DES with Crypto.Cipher / ValueError: Input strings must be a multiple of 8 in length","<p>I'm trying to decrypt Bloomberg files which are DES encrypted.</p>

<p>I'm getting a 'ValueError: Input strings must be a multiple of 8 in length 
' which I understand means I need to 'paddle' the data to the proper byte size. In this correct?</p>

<p>If so, how can I do it using Crypto.Cipher?</p>

<pre><code>f = open(SourcePath+FileName, 'r')
content = f.readlines()
key = b'Eight888'
msg=content[0]
from Crypto.Cipher import DES
decCipher = DES.new(key, DES.MODE_OFB, msg[:DES.block_size])
msgback = decCipher.decrypt(msg[DES.block_size:])
</code></pre>
","<p>Bloomberg supply a command line decryption tool, having implemented the decryption in Java myself I would say it was not worth the effort and we should have just continued to call out of process for decryption.</p>

<p>You can find a sample Java implementation <a href=""http://www.wilmott.com/messageview.cfm?catid=10&amp;threadid=35390"" rel=""nofollow"">here</a> although I warn you there is a bug when the decryption message is exactly the size of the buffer you are loading it into.</p>
","2882","<python><padding><des><bloomberg>","0","0","2","2015-04-20 13:17:28","29699046","1","","","","","2015-04-17 11:54:45",""
"4975843","How to encrypt a serialized object with DES(CBC mode) in Java?","<p>I was reading this <a href=""http://java.sun.com/developer/technicalArticles/ALT/serialization/"" rel=""nofollow"">article</a> about serialization.</p>

<p>It was the first time I saw encrypting a serialized object.
I'm trying to encrypt some serializable object and then save them into a file.
But the article's example uses ECB mode which is known to reveal informations about the encrypted plaintext. I was wondering, how is it possible to encrypt a serialized object
by using CBC instead of ECB mode?</p>

<p>In order to use CBC, an initial vector is needed. This vector must be saved with the serialized object, but if the vector gets encrypted then we can't find the vector in order to decrypt the object.</p>

<p>Also, is it possible to say that the initial vector will be saved as plaintext in the file where the serialiazable object is saved. But then wouldn't the file be destroyed?</p>

<p>An example using CBC mode would be very useful.</p>
","<p>There's a decent SO question and answer <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">about using 3DES here</a>.   The IV is a digest of the password/key.  The solution cited there can be augmented with the appropriate serialization mechanics to a <code>ByteArrayOutputStream</code> or directly to/from a <code>FileOutputStream</code>.</p>

<p>(Not an expert by any means, but pointing out what's on SO already...)</p>
","2828","<java><serialization><encryption><des>","4","0","1","2011-02-12 12:20:57","","2","1","613854","","2011-02-12 10:58:22","2011-02-12 02:01:58",""
"15640104","DES encryption with objective c","<p>I am trying to encrypt data in objective c with DES algorithm. Here is my code. I am getting my data :&lt;> and encrypted str: from this code. Can anyone say what is wrong please?    </p>

<pre><code>    NSString *token = @""hello world"";
    const void *vplainText;
    size_t plainTextBufferSize;

    plainTextBufferSize = [token length];
    vplainText = (const void *) [token UTF8String];

    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t *movedBytes;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    NSString *key = [[NSString alloc] initWithString:@""12345678""];
    const void *vkey = (const void *) [key UTF8String];
    CCCryptorStatus cryptStatus =CCCrypt(
                            kCCEncrypt,         /* kCCEncrypt, etc. */
                            kCCAlgorithmDES,        /* kCCAlgorithmAES128, etc. */
                           kCCOptionPKCS7Padding | kCCOptionECBMode,    /*kCCOptionPKCS7Padding, etc. */
                            vkey,
                            kCCKeySizeDES,
                            NULL,           /* optional initialization vector */
                            vplainText,     /* optional per op and alg */
                            plainTextBufferSize,
                            (void *)bufferPtr,          /* data RETURNED here */
                            bufferPtrSize,
                            movedBytes);

    NSString *result;

    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    NSLog(@""my data :%@"",myData);


    result = [self base64Encoding:myData];
    NSLog(@""enrypted str: %@"",result);
</code></pre>
","<p>Sample code ... </p>

<pre><code>- (void) testDES
{
    NSData * data = [OpenSSLProxy getRandomBytes:20]; // generate some random bytes
    NSData * key = [OpenSSLProxy getRandomBytes:kCCKeySizeDES];
    NSData * enc = [self encryptDESByKey:key data:data];
    NSData *dec = [self decryptDESByKey:key data:enc];
    STAssertEqualObjects(data, dec, @"""");
}

- (NSData *)encryptDESByKey:(NSData *)key data:(NSData *)data
{
    size_t numBytesEncrypted = 0;
    size_t bufferSize = data.length + kCCBlockSizeDES;
    void *buffer = malloc(bufferSize);

    CCCryptorStatus result = CCCrypt( kCCEncrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding,
                                     key.bytes, kCCKeySizeDES,
                                     NULL,
                                     data.bytes, data.length,
                                     buffer, bufferSize,
                                     &amp;numBytesEncrypted);
    NSData *output = [NSData dataWithBytes:buffer length:numBytesEncrypted];
    free(buffer);
    if( result == kCCSuccess )
    {
        return output;
    } else {
        NSLog(@""Failed DES encrypt..."");
        return nil;
    }
}

- (NSData *) decryptDESByKey:(NSData *)key data:(NSData *)data
{
   size_t numBytesEncrypted = 0;

    size_t bufferSize = data.length + kCCBlockSizeDES;
    void *buffer_decrypt = malloc(bufferSize);
    CCCryptorStatus result = CCCrypt( kCCDecrypt , kCCAlgorithmDES, kCCOptionPKCS7Padding,
                                     key.bytes, kCCKeySizeDES,
                                     NULL,
                                     data.bytes, data.length,
                                     buffer_decrypt, bufferSize,
                                     &amp;numBytesEncrypted );

    NSData *output = [NSData dataWithBytes:buffer_decrypt length:numBytesEncrypted];
    free(buffer_decrypt);
    if( result == kCCSuccess )
    {
        return output;
    } else {
        NSLog(@""Failed DES decrypt ..."");
        return nil;
    }
}
</code></pre>
","2762","<ios><objective-c><security><des>","2","2","1","2014-04-23 07:37:03","","3","3","","","","2013-03-26 14:50:48",""
"19741927","set and get DES key in java.security.KeyStore PKCS11","<p>I'm trying to encrypt using the loaded des key from KeyStore and I get:</p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: No installed provider supports this key: sun.security.pkcs11.P11Key$P11SecretKey
    at javax.crypto.Cipher.chooseProvider(Cipher.java:878)
    at javax.crypto.Cipher.init(Cipher.java:1213)
    at javax.crypto.Cipher.init(Cipher.java:1153)
</code></pre>

<p>and this is my code:</p>

<pre><code>public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException, IOException, CertificateException {
        Provider provider = new sun.security.pkcs11.SunPKCS11(DesSaveLoad.class.getClassLoader().getResourceAsStream(""pkcs11.cfg""));
        Security.removeProvider(provider.getName());
        Security.insertProviderAt(provider, 1);
        KeyStore keyStore = KeyStore.getInstance(""PKCS11"", provider);
        keyStore.load(null, null);
        SecretKey desKey = desGenerateKey();
        keyStore.setKeyEntry(""t1"", desKey, null, null);
        SecretKey t1 = (SecretKey) keyStore.getKey(""t1"", null);
        byte[] messageBytes = ""message"".getBytes();
        desEncrypt(messageBytes, 0, messageBytes.length, desKey);
        desEncrypt(messageBytes, 0, messageBytes.length, t1);  //Exception is thrown here
    }

    public static SecretKey desGenerateKey() throws NoSuchAlgorithmException {
        KeyGenerator keygenerator = null;
        keygenerator = KeyGenerator.getInstance(""DES"");
        return keygenerator.generateKey();
    }

    public static byte[] desEncrypt(byte[] plainText, int offset, int size, SecretKey key) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher;
        if (size % 8 != 0) {
            cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        } else {
            cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        }
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(plainText, offset, size);
    }
</code></pre>

<p>As you can see there is no exception thrown when encrypting using generated des key.</p>
","<p>See if <a href=""https://stackoverflow.com/questions/5172069/access-restriction-on-sun-security-pkcs11-sunpkcs11"">this</a> post helps </p>

<p>Either the key is incorrect <s>(more likely)</s> or the given key is not supported by the provider.</p>

<pre><code>KeyStore.getInstance(""PKCS11"", provider);
</code></pre>

<p>PS: Are you using a custom provider?</p>
","2739","<java><get><keystore><des><pkcs#11>","1","-1","2","2013-11-03 13:39:16","19753478","3","2","","","","2013-11-02 12:32:01",""
"19741927","set and get DES key in java.security.KeyStore PKCS11","<p>I'm trying to encrypt using the loaded des key from KeyStore and I get:</p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: No installed provider supports this key: sun.security.pkcs11.P11Key$P11SecretKey
    at javax.crypto.Cipher.chooseProvider(Cipher.java:878)
    at javax.crypto.Cipher.init(Cipher.java:1213)
    at javax.crypto.Cipher.init(Cipher.java:1153)
</code></pre>

<p>and this is my code:</p>

<pre><code>public static void main(String[] args) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException, IOException, CertificateException {
        Provider provider = new sun.security.pkcs11.SunPKCS11(DesSaveLoad.class.getClassLoader().getResourceAsStream(""pkcs11.cfg""));
        Security.removeProvider(provider.getName());
        Security.insertProviderAt(provider, 1);
        KeyStore keyStore = KeyStore.getInstance(""PKCS11"", provider);
        keyStore.load(null, null);
        SecretKey desKey = desGenerateKey();
        keyStore.setKeyEntry(""t1"", desKey, null, null);
        SecretKey t1 = (SecretKey) keyStore.getKey(""t1"", null);
        byte[] messageBytes = ""message"".getBytes();
        desEncrypt(messageBytes, 0, messageBytes.length, desKey);
        desEncrypt(messageBytes, 0, messageBytes.length, t1);  //Exception is thrown here
    }

    public static SecretKey desGenerateKey() throws NoSuchAlgorithmException {
        KeyGenerator keygenerator = null;
        keygenerator = KeyGenerator.getInstance(""DES"");
        return keygenerator.generateKey();
    }

    public static byte[] desEncrypt(byte[] plainText, int offset, int size, SecretKey key) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher;
        if (size % 8 != 0) {
            cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        } else {
            cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        }
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(plainText, offset, size);
    }
</code></pre>

<p>As you can see there is no exception thrown when encrypting using generated des key.</p>
","<p>If you perform encryption using a HSM then the encryption procedure is performed within the HSM, not in the software. <code>Cipher</code> does not implement the encryption procedure itself. The underlying <code>CipherSpi</code> of the PKCS#11 provider for <code>Cipher</code> is chosen using <em>delayed provider selection</em> depending on the key given during the call to <code>init()</code>. So although the <code>desEncrypt()</code> function seems to perform the same operations, in reality the functionality depends on the provider, and in your case, on the PKCS#11 wrapper, library and of course HSM.</p>

<p>Now PKCS#11 is an interface specification; not all mechanisms in PKCS#11 will be implemented in every token. It is likely that some encryption algorithms are too obscure or too unsafe. The latter is probably the case for DES ECB as that algorithm is extremely insecure. That does not mean that DES keys cannot be used in general - they could still play a role in e.g. MAC calculations. So please check the documentation of your HSM if DES ECB is supported (in the current setting).</p>

<p>You can get more information about the PKCS#11 method calls by adding <code>-Djava.security.debug=sunpkcs11</code> to your call to the Java interpreter (<code>java</code> or <code>javaw</code>). If DES does not work, try the much safer and more common <code>""AES/CBC/PKCS5Padding""</code> or triple DES mechanism.</p>
","2739","<java><get><keystore><des><pkcs#11>","1","2","2","2013-11-03 13:39:16","19753478","3","2","","","","2013-11-02 12:32:01",""
"43642667","Using Triple DES(3DES) with PHP 7.1","<p>I need a way to encrypt and decrypt with 3des. I'm currently using php 7.1</p>

<p>I found <a href=""https://stackoverflow.com/questions/22592919/triple-des-encryption-decryption-using-php"">this</a> question, but mcrypt is <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow noreferrer"">deprecated</a> as of php 7.1 and I can't find any other resource for this. </p>
","<p>Continue to the Comments section of the function's manual and you'll see the following:</p>

<blockquote>
  <p>If you're writing code to encrypt/encrypt data in 2015, you should use
  openssl_encrypt() and openssl_decrypt(). The underlying library
  (libmcrypt) has been abandoned since 2007, and performs far worse than
  OpenSSL (which leverages AES-NI on modern processors and is
  cache-timing safe).
  [<a href=""http://php.net/manual/en/function.mcrypt-encrypt.php#117667"" rel=""nofollow noreferrer"">Link to the full comment]</a></p>
</blockquote>

<p>So, Consider using <a href=""http://php.net/manual/en/function.openssl-encrypt.php"" rel=""nofollow noreferrer""><code>openssl_encrypt()</code></a> &amp; openssl_decrypt() instead.
They are still being supported and better performing.</p>
","2698","<php><des><3des><tripledes><php-7.1>","0","1","1","2017-07-09 23:55:20","","2","","-1","","2017-05-23 12:02:34","2017-04-26 19:11:58","2019-03-07 07:42:48"
"13869034","DES encrypt/decrypt from a file","<p>I am writting a program where I take a string, encrypt it and then write it in a file. Then later, I read from the file the string, decrypt it and then modify it. Here's my code for DES encryption/decryption:</p>

<pre><code>/* class for crypting and decrypting a file */
class DESEncrypter
{
private Cipher encryptionCipher;
private Cipher decryptionCipher;

public DESEncrypter (SecretKey key) throws Exception
{
encryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
encryptionCipher.init(Cipher.ENCRYPT_MODE, key);
decryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
decryptionCipher.init(Cipher.DECRYPT_MODE, key);
}

/* write to 'out' the encryption of the information read from 'in' */
public String encrypt(String unencryptedString)
{
    String encryptedString = """";

    try {
        byte[] unencryptedByteArray = unencryptedString.getBytes(""UTF8"");

        byte[] encryptedBytes = this.encryptionCipher.doFinal(unencryptedByteArray);

        encryptedString = new sun.misc.BASE64Encoder().encode(encryptedBytes);

    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return encryptedString;
}

private static String bytes2String(byte[] bytes)
{

    StringBuffer stringBuffer = new StringBuffer();
    for (int i = 0; i &lt; bytes.length; i++) 
    {
        stringBuffer.append((char) bytes[i]);
    }

    return stringBuffer.toString();
}

/* write to 'out' the information obtained by decrypting the information read from 'in' */
public String decrypt (String encryptedString) throws UnsupportedEncodingException
{
    byte[] unencryptedByteArray = new byte[4096];

    try {
        // Encode bytes to base64 to get a string
        byte[] decodedBytes = new sun.misc.BASE64Decoder().decodeBuffer(encryptedString);

       // Decrypt
       unencryptedByteArray = this.decryptionCipher.doFinal(decodedBytes);     
    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return bytes2String(unencryptedByteArray);
}
} 
</code></pre>

<p>And this is the function where I write a encrypted String in a file:</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
        String crypt = """";
        String aux;
        while ((aux = br.readLine()) != null)
        {
            crypt += aux;
        }
        br.close();

        String info = this.server.crypt.decrypt(crypt);
        info += filename + "" "" + owner + "" "" + departament + ""\n"";

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();

        String infoCrypt = this.server.crypt.encrypt(info); 

        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        BufferedWriter bw = new BufferedWriter(new FileWriter(newFiles));
        bw.write(infoCrypt);
        bw.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>While the server runs, I can make modification to that String from file(run that function many time). The problem is when I close the server and then I open it again because I get the error:
javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>This is how I read from file when the server opens:</p>

<pre><code>BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
String crypto = new String();
String aux;
while ((aux = br.readLine()) != null)
{
    crypto += aux;
    readBytes++;
}
br.close();
System.out.println(readBytes);
info = this.crypt.decrypt(crypto); 
</code></pre>

<p>Why do I get that error? What I'm doing wrong? I must write the encrypted String in file some other way?</p>

<p>LATER EDIT:</p>

<p>I've changed the function that read a String from a file, decrypt it, modify it , encrypt it and then write it in file.</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        File f = new File(""files_encrypted"");
        int nrRead = 0;
        String info = null;
        FileInputStream fis = new FileInputStream(f);
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = fis.read()) != -1)
        {
            sb.append((char)ch);
            nrRead++;
        }
        fis.close();

        StringBuilder sba = null;
        if (nrRead != 0)
        {
            info = this.server.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));
            sba = new StringBuilder(info);
            sba.append(filename + "" "" + owner + "" "" + departament + "" "");
        }
        else
        {
            sba = new StringBuilder(filename + "" "" + owner + "" "" + departament + "" "");
        }

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();
        //System.out.println(""before: "" + sba.toString());
        String infoCrypt = this.server.crypt.encrypt(sba.toString()); 
        //System.out.println(""after: "" + infoCrypt);
        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        FileOutputStream fos = new FileOutputStream(newFiles);
        fos.write(infoCrypt.getBytes(""UTF-8""));
        fos.flush();
        fos.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>I've also modified where I read the info from file when server opens for the first time:</p>

<pre><code>FileInputStream fis = new FileInputStream(f);
StringBuffer sb = new StringBuffer();
int ch;
while ((ch = fis.read()) != -1)
{
    sb.append((char)ch);
    readBytes++;
}

fis.close();
if (readBytes != 0)
{
    System.out.println(""on: "" + sb.toString());
    info = this.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));                
    System.out.println(""load: "" + info);
}
} 
</code></pre>

<p>At the System.out.println with ""on: "" what I read from file is exactly what I've written encrypted, without any spaces or new lines. If I read with read(buffer), where buffer is byte[], it seems that adds a lot of spaces.</p>

<p>Although I've made all this modifications I still get the error javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>Has somebody any idea what's going on here?</p>
","<p>I think it is in the initialization</p>

<p>SecureRandom sr = new SecureRandom();<br>
   cipher.init( Cipher.DECRYPT_MODE, desKey ,sr); </p>
","2619","<java><security><base64><des>","1","0","4","2012-12-19 11:06:55","13869347","3","2","1070818","","2012-12-13 23:27:30","2012-12-13 21:47:18",""
"13869034","DES encrypt/decrypt from a file","<p>I am writting a program where I take a string, encrypt it and then write it in a file. Then later, I read from the file the string, decrypt it and then modify it. Here's my code for DES encryption/decryption:</p>

<pre><code>/* class for crypting and decrypting a file */
class DESEncrypter
{
private Cipher encryptionCipher;
private Cipher decryptionCipher;

public DESEncrypter (SecretKey key) throws Exception
{
encryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
encryptionCipher.init(Cipher.ENCRYPT_MODE, key);
decryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
decryptionCipher.init(Cipher.DECRYPT_MODE, key);
}

/* write to 'out' the encryption of the information read from 'in' */
public String encrypt(String unencryptedString)
{
    String encryptedString = """";

    try {
        byte[] unencryptedByteArray = unencryptedString.getBytes(""UTF8"");

        byte[] encryptedBytes = this.encryptionCipher.doFinal(unencryptedByteArray);

        encryptedString = new sun.misc.BASE64Encoder().encode(encryptedBytes);

    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return encryptedString;
}

private static String bytes2String(byte[] bytes)
{

    StringBuffer stringBuffer = new StringBuffer();
    for (int i = 0; i &lt; bytes.length; i++) 
    {
        stringBuffer.append((char) bytes[i]);
    }

    return stringBuffer.toString();
}

/* write to 'out' the information obtained by decrypting the information read from 'in' */
public String decrypt (String encryptedString) throws UnsupportedEncodingException
{
    byte[] unencryptedByteArray = new byte[4096];

    try {
        // Encode bytes to base64 to get a string
        byte[] decodedBytes = new sun.misc.BASE64Decoder().decodeBuffer(encryptedString);

       // Decrypt
       unencryptedByteArray = this.decryptionCipher.doFinal(decodedBytes);     
    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return bytes2String(unencryptedByteArray);
}
} 
</code></pre>

<p>And this is the function where I write a encrypted String in a file:</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
        String crypt = """";
        String aux;
        while ((aux = br.readLine()) != null)
        {
            crypt += aux;
        }
        br.close();

        String info = this.server.crypt.decrypt(crypt);
        info += filename + "" "" + owner + "" "" + departament + ""\n"";

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();

        String infoCrypt = this.server.crypt.encrypt(info); 

        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        BufferedWriter bw = new BufferedWriter(new FileWriter(newFiles));
        bw.write(infoCrypt);
        bw.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>While the server runs, I can make modification to that String from file(run that function many time). The problem is when I close the server and then I open it again because I get the error:
javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>This is how I read from file when the server opens:</p>

<pre><code>BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
String crypto = new String();
String aux;
while ((aux = br.readLine()) != null)
{
    crypto += aux;
    readBytes++;
}
br.close();
System.out.println(readBytes);
info = this.crypt.decrypt(crypto); 
</code></pre>

<p>Why do I get that error? What I'm doing wrong? I must write the encrypted String in file some other way?</p>

<p>LATER EDIT:</p>

<p>I've changed the function that read a String from a file, decrypt it, modify it , encrypt it and then write it in file.</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        File f = new File(""files_encrypted"");
        int nrRead = 0;
        String info = null;
        FileInputStream fis = new FileInputStream(f);
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = fis.read()) != -1)
        {
            sb.append((char)ch);
            nrRead++;
        }
        fis.close();

        StringBuilder sba = null;
        if (nrRead != 0)
        {
            info = this.server.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));
            sba = new StringBuilder(info);
            sba.append(filename + "" "" + owner + "" "" + departament + "" "");
        }
        else
        {
            sba = new StringBuilder(filename + "" "" + owner + "" "" + departament + "" "");
        }

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();
        //System.out.println(""before: "" + sba.toString());
        String infoCrypt = this.server.crypt.encrypt(sba.toString()); 
        //System.out.println(""after: "" + infoCrypt);
        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        FileOutputStream fos = new FileOutputStream(newFiles);
        fos.write(infoCrypt.getBytes(""UTF-8""));
        fos.flush();
        fos.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>I've also modified where I read the info from file when server opens for the first time:</p>

<pre><code>FileInputStream fis = new FileInputStream(f);
StringBuffer sb = new StringBuffer();
int ch;
while ((ch = fis.read()) != -1)
{
    sb.append((char)ch);
    readBytes++;
}

fis.close();
if (readBytes != 0)
{
    System.out.println(""on: "" + sb.toString());
    info = this.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));                
    System.out.println(""load: "" + info);
}
} 
</code></pre>

<p>At the System.out.println with ""on: "" what I read from file is exactly what I've written encrypted, without any spaces or new lines. If I read with read(buffer), where buffer is byte[], it seems that adds a lot of spaces.</p>

<p>Although I've made all this modifications I still get the error javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>Has somebody any idea what's going on here?</p>
","<p>Not sure this is the primary problem, but when you return the decrypted String from <code>decrypt()</code>, you should be using:</p>

<pre><code>return new String(unencryptedByteArray, ""UTF-8"");
</code></pre>
","2619","<java><security><base64><des>","1","0","4","2012-12-19 11:06:55","13869347","3","2","1070818","","2012-12-13 23:27:30","2012-12-13 21:47:18",""
"13869034","DES encrypt/decrypt from a file","<p>I am writting a program where I take a string, encrypt it and then write it in a file. Then later, I read from the file the string, decrypt it and then modify it. Here's my code for DES encryption/decryption:</p>

<pre><code>/* class for crypting and decrypting a file */
class DESEncrypter
{
private Cipher encryptionCipher;
private Cipher decryptionCipher;

public DESEncrypter (SecretKey key) throws Exception
{
encryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
encryptionCipher.init(Cipher.ENCRYPT_MODE, key);
decryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
decryptionCipher.init(Cipher.DECRYPT_MODE, key);
}

/* write to 'out' the encryption of the information read from 'in' */
public String encrypt(String unencryptedString)
{
    String encryptedString = """";

    try {
        byte[] unencryptedByteArray = unencryptedString.getBytes(""UTF8"");

        byte[] encryptedBytes = this.encryptionCipher.doFinal(unencryptedByteArray);

        encryptedString = new sun.misc.BASE64Encoder().encode(encryptedBytes);

    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return encryptedString;
}

private static String bytes2String(byte[] bytes)
{

    StringBuffer stringBuffer = new StringBuffer();
    for (int i = 0; i &lt; bytes.length; i++) 
    {
        stringBuffer.append((char) bytes[i]);
    }

    return stringBuffer.toString();
}

/* write to 'out' the information obtained by decrypting the information read from 'in' */
public String decrypt (String encryptedString) throws UnsupportedEncodingException
{
    byte[] unencryptedByteArray = new byte[4096];

    try {
        // Encode bytes to base64 to get a string
        byte[] decodedBytes = new sun.misc.BASE64Decoder().decodeBuffer(encryptedString);

       // Decrypt
       unencryptedByteArray = this.decryptionCipher.doFinal(decodedBytes);     
    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return bytes2String(unencryptedByteArray);
}
} 
</code></pre>

<p>And this is the function where I write a encrypted String in a file:</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
        String crypt = """";
        String aux;
        while ((aux = br.readLine()) != null)
        {
            crypt += aux;
        }
        br.close();

        String info = this.server.crypt.decrypt(crypt);
        info += filename + "" "" + owner + "" "" + departament + ""\n"";

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();

        String infoCrypt = this.server.crypt.encrypt(info); 

        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        BufferedWriter bw = new BufferedWriter(new FileWriter(newFiles));
        bw.write(infoCrypt);
        bw.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>While the server runs, I can make modification to that String from file(run that function many time). The problem is when I close the server and then I open it again because I get the error:
javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>This is how I read from file when the server opens:</p>

<pre><code>BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
String crypto = new String();
String aux;
while ((aux = br.readLine()) != null)
{
    crypto += aux;
    readBytes++;
}
br.close();
System.out.println(readBytes);
info = this.crypt.decrypt(crypto); 
</code></pre>

<p>Why do I get that error? What I'm doing wrong? I must write the encrypted String in file some other way?</p>

<p>LATER EDIT:</p>

<p>I've changed the function that read a String from a file, decrypt it, modify it , encrypt it and then write it in file.</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        File f = new File(""files_encrypted"");
        int nrRead = 0;
        String info = null;
        FileInputStream fis = new FileInputStream(f);
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = fis.read()) != -1)
        {
            sb.append((char)ch);
            nrRead++;
        }
        fis.close();

        StringBuilder sba = null;
        if (nrRead != 0)
        {
            info = this.server.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));
            sba = new StringBuilder(info);
            sba.append(filename + "" "" + owner + "" "" + departament + "" "");
        }
        else
        {
            sba = new StringBuilder(filename + "" "" + owner + "" "" + departament + "" "");
        }

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();
        //System.out.println(""before: "" + sba.toString());
        String infoCrypt = this.server.crypt.encrypt(sba.toString()); 
        //System.out.println(""after: "" + infoCrypt);
        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        FileOutputStream fos = new FileOutputStream(newFiles);
        fos.write(infoCrypt.getBytes(""UTF-8""));
        fos.flush();
        fos.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>I've also modified where I read the info from file when server opens for the first time:</p>

<pre><code>FileInputStream fis = new FileInputStream(f);
StringBuffer sb = new StringBuffer();
int ch;
while ((ch = fis.read()) != -1)
{
    sb.append((char)ch);
    readBytes++;
}

fis.close();
if (readBytes != 0)
{
    System.out.println(""on: "" + sb.toString());
    info = this.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));                
    System.out.println(""load: "" + info);
}
} 
</code></pre>

<p>At the System.out.println with ""on: "" what I read from file is exactly what I've written encrypted, without any spaces or new lines. If I read with read(buffer), where buffer is byte[], it seems that adds a lot of spaces.</p>

<p>Although I've made all this modifications I still get the error javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>Has somebody any idea what's going on here?</p>
","<p>You have several problems. The reading and decrypting process should be symmetric with the encrypting and writing process. But</p>

<ul>
<li>you transform your String into a byte[] using <code>getBytes(""UTF8"")</code>, which is fine, but you don't use <code>new String(byte[], ""UTF8"")</code> to do the reverse operation.</li>
<li>you write a whole String to a file, including potential line breaks, but you read it line by line and concatenate each line, thus losing the line breaks in the process. You must read each and every char that has been written.</li>
</ul>

<p>Also, relying on undocumented, unsupported classes like sun.misc.Base64Encoder/Decoder shouldn't be done. Use Apache commons-codec to find a documented Base64 encoding, guaranteed to still be there when the next JDK comes out, and which can be used on every JVM, including non-Sun JVMs.</p>
","2619","<java><security><base64><des>","1","1","4","2012-12-19 11:06:55","13869347","3","2","1070818","","2012-12-13 23:27:30","2012-12-13 21:47:18",""
"13869034","DES encrypt/decrypt from a file","<p>I am writting a program where I take a string, encrypt it and then write it in a file. Then later, I read from the file the string, decrypt it and then modify it. Here's my code for DES encryption/decryption:</p>

<pre><code>/* class for crypting and decrypting a file */
class DESEncrypter
{
private Cipher encryptionCipher;
private Cipher decryptionCipher;

public DESEncrypter (SecretKey key) throws Exception
{
encryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
encryptionCipher.init(Cipher.ENCRYPT_MODE, key);
decryptionCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
decryptionCipher.init(Cipher.DECRYPT_MODE, key);
}

/* write to 'out' the encryption of the information read from 'in' */
public String encrypt(String unencryptedString)
{
    String encryptedString = """";

    try {
        byte[] unencryptedByteArray = unencryptedString.getBytes(""UTF8"");

        byte[] encryptedBytes = this.encryptionCipher.doFinal(unencryptedByteArray);

        encryptedString = new sun.misc.BASE64Encoder().encode(encryptedBytes);

    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return encryptedString;
}

private static String bytes2String(byte[] bytes)
{

    StringBuffer stringBuffer = new StringBuffer();
    for (int i = 0; i &lt; bytes.length; i++) 
    {
        stringBuffer.append((char) bytes[i]);
    }

    return stringBuffer.toString();
}

/* write to 'out' the information obtained by decrypting the information read from 'in' */
public String decrypt (String encryptedString) throws UnsupportedEncodingException
{
    byte[] unencryptedByteArray = new byte[4096];

    try {
        // Encode bytes to base64 to get a string
        byte[] decodedBytes = new sun.misc.BASE64Decoder().decodeBuffer(encryptedString);

       // Decrypt
       unencryptedByteArray = this.decryptionCipher.doFinal(decodedBytes);     
    } catch (Exception ex) {
        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);
    }

    return bytes2String(unencryptedByteArray);
}
} 
</code></pre>

<p>And this is the function where I write a encrypted String in a file:</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
        String crypt = """";
        String aux;
        while ((aux = br.readLine()) != null)
        {
            crypt += aux;
        }
        br.close();

        String info = this.server.crypt.decrypt(crypt);
        info += filename + "" "" + owner + "" "" + departament + ""\n"";

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();

        String infoCrypt = this.server.crypt.encrypt(info); 

        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        BufferedWriter bw = new BufferedWriter(new FileWriter(newFiles));
        bw.write(infoCrypt);
        bw.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>While the server runs, I can make modification to that String from file(run that function many time). The problem is when I close the server and then I open it again because I get the error:
javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>This is how I read from file when the server opens:</p>

<pre><code>BufferedReader br = new BufferedReader(new FileReader(new File(""files_encrypted"")));
String crypto = new String();
String aux;
while ((aux = br.readLine()) != null)
{
    crypto += aux;
    readBytes++;
}
br.close();
System.out.println(readBytes);
info = this.crypt.decrypt(crypto); 
</code></pre>

<p>Why do I get that error? What I'm doing wrong? I must write the encrypted String in file some other way?</p>

<p>LATER EDIT:</p>

<p>I've changed the function that read a String from a file, decrypt it, modify it , encrypt it and then write it in file.</p>

<pre><code>public void writeToFileEncrypted(String filename, String owner, String departament)
{
try 
    {
        File f = new File(""files_encrypted"");
        int nrRead = 0;
        String info = null;
        FileInputStream fis = new FileInputStream(f);
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = fis.read()) != -1)
        {
            sb.append((char)ch);
            nrRead++;
        }
        fis.close();

        StringBuilder sba = null;
        if (nrRead != 0)
        {
            info = this.server.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));
            sba = new StringBuilder(info);
            sba.append(filename + "" "" + owner + "" "" + departament + "" "");
        }
        else
        {
            sba = new StringBuilder(filename + "" "" + owner + "" "" + departament + "" "");
        }

        /* delete the old encryption */
        File temp = new File(""files_encrypted"");
        temp.delete();
        //System.out.println(""before: "" + sba.toString());
        String infoCrypt = this.server.crypt.encrypt(sba.toString()); 
        //System.out.println(""after: "" + infoCrypt);
        File newFiles = new File(""files_encrypted"");
        if (newFiles.createNewFile() == false) 
        {
    log.severe(""Failed to re-create the 'files_encrypted' file when trying to add a new file"");
    return; 
        }

        FileOutputStream fos = new FileOutputStream(newFiles);
        fos.write(infoCrypt.getBytes(""UTF-8""));
        fos.flush();
        fos.close();
    }
    catch (Exception e)
    {
        log.warning(""An exception was caught while trying to remove '"" + clientName + ""' from the banned list"");
        e.printStackTrace();
        return;
}
}
</code></pre>

<p>I've also modified where I read the info from file when server opens for the first time:</p>

<pre><code>FileInputStream fis = new FileInputStream(f);
StringBuffer sb = new StringBuffer();
int ch;
while ((ch = fis.read()) != -1)
{
    sb.append((char)ch);
    readBytes++;
}

fis.close();
if (readBytes != 0)
{
    System.out.println(""on: "" + sb.toString());
    info = this.crypt.decrypt(new String(sb.toString().getBytes(""UTF-8""), ""UTF-8""));                
    System.out.println(""load: "" + info);
}
} 
</code></pre>

<p>At the System.out.println with ""on: "" what I read from file is exactly what I've written encrypted, without any spaces or new lines. If I read with read(buffer), where buffer is byte[], it seems that adds a lot of spaces.</p>

<p>Although I've made all this modifications I still get the error javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>Has somebody any idea what's going on here?</p>
","<p>There are a few things here. </p>

<pre><code>private static String bytes2String(byte[] bytes)
</code></pre>

<p>Is dodgy, you are casting a byte to a char in this method so there is no character encoding specified here. To convert bytes to characters you should just use the String constructor that takes an array of bytes and an encoding. e.g.</p>

<pre><code>    byte[] tmp = new byte[10];      
    String a = new String(tmp, ""UTF-8"");
</code></pre>

<p>Be careful using BufferedReaders + .readLine() - this will strip out any newline characters from your file as you read it unless you add them back into your buffer. Although I don't think this is your problem.</p>

<p>But I think the best way to simplify your code is to write the encoded bytes via an OutputStream directly to the file. Unless you need to send the contents of the file over a transport that doesn't like binary data, there is no need to base64 encode. Just use Input/OutputStreams to write the encrypted bytes direct to disk.</p>

<p>RESPONSE TO LATER EDIT:</p>

<p>You are still mixing up your use of binary data (bytes) and character data (String/chars). You can't do things like:</p>

<pre><code>    int ch;
    while ((ch = fis.read()) != -1)
    {
        sb.append((char)ch);
</code></pre>

<p>The input stream is retuning bytes, a byte is not a character and just casting it to one is going to cause problems. When using encryption the output from the encryption operation is binary data, and the input to the decryption operation is also binary data. The fact that your are encrypting text is something you deal with before the encryption occurs, and after the decryption occurs. You basic operation should go along the following lines.</p>

<ul>
<li>Take the text you want to encrypt and convert it to bytes, specifying an encoding using the .getBytes(String charsetName) on your String.</li>
<li>Pass these bytes into your encryption routine</li>
<li>Write the resulting bytes directly to disk</li>
</ul>

<p>To decrypt:</p>

<ul>
<li>Read the bytes from the file</li>
<li>Pass the bytes to your decryption routine (as bytes! no Strings/ text involved)</li>
<li>Take the out put bytes and re-construct you String using new String(byte[] bytes, String charsetName) specifying the same encoding as before. </li>
</ul>

<p>You might find the following (untested, but should work) methods useful:</p>

<pre><code>public byte[] readBinaryFile(File f) throws IOException
{       
    byte[] contents = new byte[(int)f.length()];
    BufferedInputStream bis = null;
    try
    {
        bis = new BufferedInputStream(new FileInputStream(f));
        DataInputStream dis = new DataInputStream(bis);
        dis.readFully(contents);
    }
    finally
    {
        if(bis != null)
        {
            bis.close();
        }
    }           
    return contents;            
}

public void writeBinaryFile(byte[] contents, File f) throws IOException
{
    BufferedOutputStream bos = null;
    try
    {
        bos = new BufferedOutputStream(new FileOutputStream(f));
        bos.write(contents);
    }
    finally
    {
        if(bos != null)
        {
            bos.close();
        }
    }           
}
</code></pre>

<p>So you will also need to change the interface, and internals of your encrypt and decrypt methods so they take and return byte arrays, and ditch the base64 encoding.</p>
","2619","<java><security><base64><des>","1","1","4","2012-12-19 11:06:55","13869347","3","2","1070818","","2012-12-13 23:27:30","2012-12-13 21:47:18",""
"19460186","C# DES File Decryption Breaking Non-Text Files","<p>I have these two methods which are pretty much copy+pastes from <a href=""http://support.microsoft.com/kb/307010"" rel=""nofollow"">http://support.microsoft.com/kb/307010</a>.</p>

<p>When I decrypt the files, if they are any type of text file such as .txt, .xml, .html, etc. I can open them up and everything is fine. Any type of file not just text, such as .exe, .jpg, .pdf, etc. all break when decrypted. Is there anything I am doing wrong? Are these methods using binary to encrypt/decrypt the files? If not is there a way I can make it binary?</p>

<p>Any help is greatly appreciated!</p>

<pre><code>public static void EncryptFile(string sInputFilename,
       string sOutputFilename,
       string sKey)
    {
        FileStream fsInput = new FileStream(sInputFilename,
           FileMode.Open,
           FileAccess.Read);

        FileStream fsEncrypted = new FileStream(sOutputFilename,
           FileMode.Create,
           FileAccess.Write);
        DESCryptoServiceProvider DES = new DESCryptoServiceProvider();
        DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey);
        DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey);
        ICryptoTransform desencrypt = DES.CreateEncryptor();
        CryptoStream cryptostream = new CryptoStream(fsEncrypted,
           desencrypt,
           CryptoStreamMode.Write);

        byte[] bytearrayinput = new byte[fsInput.Length];
        fsInput.Read(bytearrayinput, 0, bytearrayinput.Length);
        cryptostream.Write(bytearrayinput, 0, bytearrayinput.Length);
        cryptostream.Close();
        fsInput.Close();
        fsEncrypted.Close();
    }

    public static void DecryptFile(string sInputFilename,
       string sOutputFilename,
       string sKey)
    {
        DESCryptoServiceProvider DES = new DESCryptoServiceProvider();
        //A 64 bit key and IV is required for this provider.
        //Set secret key For DES algorithm.
        DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey);
        //Set initialization vector.
        DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey);

        //Create a file stream to read the encrypted file back.
        FileStream fsread = new FileStream(sInputFilename,
           FileMode.Open,
           FileAccess.Read);
        //Create a DES decryptor from the DES instance.
        ICryptoTransform desdecrypt = DES.CreateDecryptor();
        //Create crypto stream set to read and do a 
        //DES decryption transform on incoming bytes.
        CryptoStream cryptostreamDecr = new CryptoStream(fsread,
           desdecrypt,
           CryptoStreamMode.Read);
        //Print the contents of the decrypted file.
        StreamWriter fsDecrypted = new StreamWriter(sOutputFilename);
        fsDecrypted.Write(new StreamReader(cryptostreamDecr).ReadToEnd());
        fsDecrypted.Flush();
        fsDecrypted.Close();
        fsread.Close();
        cryptostreamDecr.Close();
    }
</code></pre>
","<p>I don't know what the guy that wrote that article was smoking, but:</p>

<pre><code>DESCryptoServiceProvider desCrypto =
   (DESCryptoServiceProvider)DESCryptoServiceProvider.Create();

return ASCIIEncoding.ASCII.GetString(desCrypto.Key);
</code></pre>

<p>will not get you a valid key. At least one problem is the fact that the key you use to encrypt is not the same key that you're using to decrypt, because you can't convert bytes to ASCII and back like that.</p>

<p>If you want to treat the key as a string, what you probably want is:</p>

<pre><code>string keyAsString = Convert.ToBase64String(desCrypto.Key);
</code></pre>

<p>Then when you want to turn it back into bytes, instead of <code>ASCIIEncoding.ASCII.GetBytes</code>, you'll do:</p>

<pre><code>byte[] key = Convert.FromBase64String(keyAsString);
</code></pre>

<p><strong>EDIT</strong></p>

<p>There's a ton more wrong with that article too. I'd say ignore that one and find a better example.</p>

<p><strong>EDIT</strong></p>

<p>Here's a very clean basic AES working example that I use for my standard encryption needs. Some of the major improvements over the article are:</p>

<ul>
<li>Proper creation of a key</li>
<li>Current algorithm (AES 256-bit key)</li>
<li>Random IV</li>
<li>Buffered file access instead of reading/writing the entire file in one chunk</li>
<li>Wrapping all the disposable objects in <code>using</code></li>
</ul>

<p>Aside from that, it's the same basic idea.</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;

namespace ConsoleApplication12
{
    class Program
    {
        private const int KEY_SIZE_BYTES = 32;
        private const int IV_SIZE_BYTES = 16;

        static void Main(string[] args)
        {
            var rand = new Random();
            using (var fs = File.Open(@""C:\temp\input.bin"", FileMode.Create, FileAccess.Write, FileShare.None))
            {
                byte[] buffer = new byte[10000];
                for (int i = 0; i &lt; 100; ++i)
                {
                    rand.NextBytes(buffer);
                    fs.Write(buffer, 0, buffer.Length);
                }
            }
            string key = GenerateRandomKey();
            Encrypt(@""C:\temp\input.bin"", @""C:\temp\encrypted.bin"", key);
            Decrypt(@""C:\temp\encrypted.bin"", @""C:\temp\decyrypted.bin"", key);
        }

        static string GenerateRandomKey()
        {
            byte[] key = new byte[KEY_SIZE_BYTES];
            using (var rng = RandomNumberGenerator.Create())
            {
                rng.GetBytes(key);
            }
            return Convert.ToBase64String(key);
        }

        static void Encrypt(string inputFile, string outputFile, string key)
        {
            const int BUFFER_SIZE = 8192;
            byte[] buffer = new byte[BUFFER_SIZE];
            byte[] keyBytes = Convert.FromBase64String(key);
            byte[] ivBytes = new byte[IV_SIZE_BYTES];
            using (var rng = RandomNumberGenerator.Create())
            {
                rng.GetBytes(ivBytes);
            }
            using (var inputStream = File.Open(inputFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                using (var outputStream = File.Open(outputFile, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    outputStream.Write(ivBytes, 0, ivBytes.Length);
                    using (var cryptoAlgo = Aes.Create())
                    {
                        using (var encryptor = cryptoAlgo.CreateEncryptor(keyBytes, ivBytes))
                        {
                            using (var cryptoStream = new CryptoStream(outputStream, encryptor, CryptoStreamMode.Write))
                            {
                                int count;
                                while ((count = inputStream.Read(buffer, 0, buffer.Length)) &gt; 0)
                                {
                                    cryptoStream.Write(buffer, 0, count);
                                }
                            }
                        }
                    }
                }
            }
        }

        static void Decrypt(string inputFile, string outputFile, string key)
        {
            const int BUFFER_SIZE = 8192;
            byte[] buffer = new byte[BUFFER_SIZE];
            byte[] keyBytes = Convert.FromBase64String(key);
            byte[] ivBytes = new byte[IV_SIZE_BYTES];
            using (var inputStream = File.Open(inputFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                inputStream.Read(ivBytes, 0, ivBytes.Length);
                using (var outputStream = File.Open(outputFile, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    using (var cryptoAlgo = Aes.Create())
                    {
                        using (var decryptor = cryptoAlgo.CreateDecryptor(keyBytes, ivBytes))
                        {
                            using (var cryptoStream = new CryptoStream(inputStream, decryptor, CryptoStreamMode.Read))
                            {
                                int count;
                                while ((count = cryptoStream.Read(buffer, 0, buffer.Length)) &gt; 0)
                                {
                                    outputStream.Write(buffer, 0, count);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
</code></pre>

<p>Because the IV is random, you'll see another small difference in technique. When encrypting the file, you first write the IV to the encrypted file (it's not a secret, so you just write it straight out). When decrypting the file, you read the first few bytes to retrieve the IV, then the rest of the file contains the actual encrypted data. The purpose of a random IV is so the same plaintext file will encrypt into a different encrypted file every time you run it.</p>

<p>The <code>Main</code> method here demonstrates encryption with a random key. If you want to use a password, it's a little more work, but you can implement PBKDF2 with maybe a dozen or so extra lines of code.</p>
","2547","<c#><encryption><des>","1","3","1","2013-10-19 08:33:53","19460257","2","","","","","2013-10-18 22:46:38",""
"21443426","DES-encrypting a string and converting to hex","<p>I am trying to find a way in PHP that can encrypt a string in hex using DES algorithm. The result I need should be exactly like <a href=""http://www.emvlab.org/descalc/"" rel=""nofollow"">this page</a>.</p>

<p>All PHP codes that I tried gave different results than what I got in that page.
I tried this code for example:</p>

<pre><code>&lt;?php
function Encrypt($data, $key)
{    
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return $encData;
}
echo strtoupper(bin2hex(Encrypt(""12341234"", ""1100000120140129"")));
?&gt;
</code></pre>

<p>The result was: <code>0D54E1C0B08DCB90</code>. While in <a href=""http://www.emvlab.org/descalc/?key=31313030303030313230313430313239&amp;iv=0000000000000000&amp;input=3132333431323334&amp;mode=ecb&amp;action=Encrypt&amp;output=4DC7D8B78F0F33A3"" rel=""nofollow"">this link</a>, the result is: <code>4DC7D8B78F0F33A3</code>.</p>

<p>Note that <code>31313030303030313230313430313239</code> is <code>1100000120140129</code> in hex
and <code>3132333431323334</code> is <code>12341234</code> in hex.</p>
","<p>This problem seems to be caused by the way PHP reads keys and data when you supply them as strings. Solve this problem by using code such as the following:</p>

<pre><code>$key = pack('H*', ""0123456789abcdef""); // this correctly maps hex to bytes
$data = pack('H*', ""0123456789abcdef"");
echo bin2hex(mcrypt_encrypt(MCRYPT_DES, $key, $data, MCRYPT_MODE_ECB));
</code></pre>

<p>This outputs <code>56cc09e7cfdc4cef</code> which matches the DES calculator (<a href=""http://www.emvlab.org/descalc/?key=0123456789abcdef&amp;iv=0000000000000000&amp;input=0123456789abcdef&amp;mode=ecb&amp;action=Encrypt&amp;output=8CA64DE9C1B123A7"" rel=""nofollow"">proof</a>).</p>

<hr>

<p>For those interested, I also used the following Java code to deduce what was going on. This prints the same result as the PHP:</p>

<pre><code>SecretKey key = new SecretKeySpec(new byte[8], ""DES"");

Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
cipher.init(Cipher.ENCRYPT_MODE, key);

System.out.println(DatatypeConverter.printHexBinary(cipher
    .doFinal(new byte[8])));
</code></pre>
","2517","<php><encryption><hex><des>","3","0","2","2014-01-30 13:14:32","","5","2","474189","","2014-01-30 08:50:06","2014-01-29 21:51:39",""
"21443426","DES-encrypting a string and converting to hex","<p>I am trying to find a way in PHP that can encrypt a string in hex using DES algorithm. The result I need should be exactly like <a href=""http://www.emvlab.org/descalc/"" rel=""nofollow"">this page</a>.</p>

<p>All PHP codes that I tried gave different results than what I got in that page.
I tried this code for example:</p>

<pre><code>&lt;?php
function Encrypt($data, $key)
{    
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return $encData;
}
echo strtoupper(bin2hex(Encrypt(""12341234"", ""1100000120140129"")));
?&gt;
</code></pre>

<p>The result was: <code>0D54E1C0B08DCB90</code>. While in <a href=""http://www.emvlab.org/descalc/?key=31313030303030313230313430313239&amp;iv=0000000000000000&amp;input=3132333431323334&amp;mode=ecb&amp;action=Encrypt&amp;output=4DC7D8B78F0F33A3"" rel=""nofollow"">this link</a>, the result is: <code>4DC7D8B78F0F33A3</code>.</p>

<p>Note that <code>31313030303030313230313430313239</code> is <code>1100000120140129</code> in hex
and <code>3132333431323334</code> is <code>12341234</code> in hex.</p>
","<p>This code did the trick for me:</p>

<pre><code>$keyA = ""11000001"";
$keyB = ""20140129"";
$data = ""12341234"";
$TMP = mcrypt_encrypt('tripledes', $keyA, $data, 'ecb');
$TMP = mcrypt_decrypt('tripledes', $keyB, $TMP, 'ecb');
echo strtoupper(bin2hex(mcrypt_encrypt('tripledes', $keyA, $TMP, 'ecb')));
</code></pre>

<p>I used two-key triple DES method to generate the exact result in this <a href=""http://www.emvlab.org/descalc/"" rel=""nofollow"">DES calculator</a> website.</p>

<ol>
<li>Encrypt the data using the first half of the key (most left 8 digits)</li>
<li>Decrypt the ciphertext using the second half of the key (most right 8 digits)</li>
<li>Re-encrypt the ciphertext using the first half of the key again</li>
</ol>

<p>Thanks to @Duncan for the useful help.</p>
","2517","<php><encryption><hex><des>","3","1","2","2014-01-30 13:14:32","","5","2","474189","","2014-01-30 08:50:06","2014-01-29 21:51:39",""
"22135353","Converting String to Secret Key","<p>I want to transform a String value to secret KEY DES:</p>

<pre><code>String sb=""fffe7a50"" //Example of DES key 
byte []b=sb.getBytes();  //string to bytes
SecretKey key2 = new SecretKeySpec(b, 0, b.length, ""DES"");
</code></pre>

<p>however the output is completly different :</p>

<pre><code>javax.crypto.spec.SecretKeySpec@183a2
</code></pre>

<p>i know that the numbers after the ""@"" are supposed to be the DES key , but why are the results different ? how can i fix it ?</p>
","<p>You've got a few issues here:</p>

<ol>
<li><p><code>sb.getBytes()</code> <em>does not</em> do what you think it does. What you are expecting is a byte array containing <code>{ 0xff, 0xfe, 0x7a, 0x50 }</code>. What you are getting is a byte array containing <code>{ 0x46, 0x46, 0x46, 0x45, 0x37, 0x61, 0x35, 0x30 }</code> (assuming you're using UTF-8).</p>

<p>Your choices here would be to either initialise the byte array manually, like so:</p>

<pre><code>byte[] b = new byte[]{ (byte) 0xff, (byte) 0xfe, (byte) 0x7a, (byte) 0x50 };
</code></pre>

<p>Or to parse the string correctly. I'm not sure exactly how you'd go about that, but it should be doable (and there will likely be an open-source library to do it for you).</p></li>
<li><p>The output <code>javax.crypto.spec.SecretKeySpec@183a2</code> is not writing out the value of the key. All you're seeing is the <code>toString</code> output of the <code>SecretKeySpec</code>, which follows the format <code>&lt;fully-qualified-class-name&gt;@&lt;hashcode&gt;</code> (see <a href=""http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString%28%29"" rel=""nofollow"">here</a> for details on the toString() method), so the numbers you're seeing, <code>183a2</code>, are just the hashcode of the <code>SecretKeySpec</code> object, which <em>must not</em> be the key - that would very insecure. To see the value of the key it's holding, you'd need to call the <code>SecretKeySpec#getEncoded()</code> method.</p>

<p>Note that just calling <code>System.out.println(byteArray)</code> will not display the content of the byte array - it will just display the class name and hashcode again. You'll need to either iterate through the array and print out the elements one-by-one, or use another tool to compare the two arrays.</p></li>
</ol>
","2479","<java><type-conversion><byte><des>","1","1","1","2014-03-03 01:17:43","22136093","0","4","1065197","","2014-03-02 23:55:34","2014-03-02 23:51:24",""
"49341304","Cannot resolve symbol BASE64Decoder (Java version 9.0.1)","<p>When I return encrypted or decrypted string in Base64 format it can<code>t resolve</code>BASE64Encoder()<code>and</code>BASE64Dencoder()`. How can I resolve it?</p>

<pre><code>import javax.crypto.*;
import java.io.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

class DesEncrypter {
    Cipher ecipher;
    Cipher dcipher;

public DesEncrypter(SecretKey key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    ecipher = Cipher.getInstance(""DES"");
    dcipher = Cipher.getInstance(""DES"");
    ecipher.init(Cipher.ENCRYPT_MODE, key);
    dcipher.init(Cipher.DECRYPT_MODE, key);
}

public String encrypt(String str) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {
    byte[] utf8 = str.getBytes(""UTF8"");
    byte[] enc = ecipher.doFinal(utf8);
    return new sun.misc.BASE64Encoder().encode(enc);
}

public String decrypt(String str) throws IOException, IllegalBlockSizeException, BadPaddingException {
    byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);
    byte[] utf8 = dcipher.doFinal(dec);
    return new String(utf8, ""UTF8"");
}
</code></pre>

<p>}</p>
","<p>try to use the java9 one, not the sun.misc...:</p>

<p><a href=""https://docs.oracle.com/javase/9/docs/api/java/util/Base64.Decoder.html"" rel=""nofollow noreferrer"">https://docs.oracle.com/javase/9/docs/api/java/util/Base64.Decoder.html</a></p>
","2440","<java><base64><des>","0","0","3","2018-10-04 17:18:02","","0","","5781745","","2018-03-17 22:19:38","2018-03-17 19:56:36",""
"49341304","Cannot resolve symbol BASE64Decoder (Java version 9.0.1)","<p>When I return encrypted or decrypted string in Base64 format it can<code>t resolve</code>BASE64Encoder()<code>and</code>BASE64Dencoder()`. How can I resolve it?</p>

<pre><code>import javax.crypto.*;
import java.io.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

class DesEncrypter {
    Cipher ecipher;
    Cipher dcipher;

public DesEncrypter(SecretKey key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    ecipher = Cipher.getInstance(""DES"");
    dcipher = Cipher.getInstance(""DES"");
    ecipher.init(Cipher.ENCRYPT_MODE, key);
    dcipher.init(Cipher.DECRYPT_MODE, key);
}

public String encrypt(String str) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {
    byte[] utf8 = str.getBytes(""UTF8"");
    byte[] enc = ecipher.doFinal(utf8);
    return new sun.misc.BASE64Encoder().encode(enc);
}

public String decrypt(String str) throws IOException, IllegalBlockSizeException, BadPaddingException {
    byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);
    byte[] utf8 = dcipher.doFinal(dec);
    return new String(utf8, ""UTF8"");
}
</code></pre>

<p>}</p>
","<p>You should not use sun.misc in general. Those classes are internal to the JDK and may be removed with new versions of Java (as happened here).</p>

<p>I recommend using a third party library like Apache Codecs. There are a bunch of utility classes that would make it unneccessary to do any of the code you listed. </p>

<p><strong>Site</strong>: <a href=""https://commons.apache.org/proper/commons-codec/"" rel=""nofollow noreferrer"">https://commons.apache.org/proper/commons-codec/</a></p>

<p><strong>Documentation</strong>: <a href=""https://commons.apache.org/proper/commons-codec/archives/1.11/apidocs/org/apache/commons/codec/binary/Base64.html"" rel=""nofollow noreferrer"">https://commons.apache.org/proper/commons-codec/archives/1.11/apidocs/org/apache/commons/codec/binary/Base64.html</a></p>
","2440","<java><base64><des>","0","0","3","2018-10-04 17:18:02","","0","","5781745","","2018-03-17 22:19:38","2018-03-17 19:56:36",""
"49341304","Cannot resolve symbol BASE64Decoder (Java version 9.0.1)","<p>When I return encrypted or decrypted string in Base64 format it can<code>t resolve</code>BASE64Encoder()<code>and</code>BASE64Dencoder()`. How can I resolve it?</p>

<pre><code>import javax.crypto.*;
import java.io.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

class DesEncrypter {
    Cipher ecipher;
    Cipher dcipher;

public DesEncrypter(SecretKey key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    ecipher = Cipher.getInstance(""DES"");
    dcipher = Cipher.getInstance(""DES"");
    ecipher.init(Cipher.ENCRYPT_MODE, key);
    dcipher.init(Cipher.DECRYPT_MODE, key);
}

public String encrypt(String str) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {
    byte[] utf8 = str.getBytes(""UTF8"");
    byte[] enc = ecipher.doFinal(utf8);
    return new sun.misc.BASE64Encoder().encode(enc);
}

public String decrypt(String str) throws IOException, IllegalBlockSizeException, BadPaddingException {
    byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);
    byte[] utf8 = dcipher.doFinal(dec);
    return new String(utf8, ""UTF8"");
}
</code></pre>

<p>}</p>
","<p>I had the same problem today while I was running JDK 8 on Intellij and a maven task wouldn't compile the project properly, giving me the same error. Solution was: I had JDK10 folder setup on my Environment Variables... just changed to JDK8 and everything compiled just fine.</p>
","2440","<java><base64><des>","0","0","3","2018-10-04 17:18:02","","0","","5781745","","2018-03-17 22:19:38","2018-03-17 19:56:36",""
"5866510","Fast DES for Python","<p>i am searching for compiled des implementation for python. M2Crypto don't work for me with error message ""ImportError: DLL load failed:"". OpenSSLLight installed.</p>

<p>Edit: ok, fixed with M2Crypto. For some reasons, if you select during the installation of SSLLight that the libraries should be placed in the program directory, they are not recognised by programs. I reinstalled openssllight with placing the libs into windows dir, and now M2Crypto loads.</p>
","<p><a href=""http://www.dlitz.net/software/pycrypto/"" rel=""nofollow"">Pycrypto</a> supports DES/DES3 and has <a href=""http://www.voidspace.org.uk/python/modules.shtml#pycrypto"" rel=""nofollow"">prebuilt Windows installers from Voidspace</a>. Quick example:</p>

<pre><code>from Crypto.Cipher import DES
des = DES.new('13371337', DES.MODE_ECB)
des.encrypt('plaintxt')

'\xeb\x9d\xe7~&amp;\xb4fp'
</code></pre>
","2422","<python><des>","0","0","1","2011-05-03 20:14:17","","0","","735673","","2011-05-03 20:14:17","2011-05-03 07:38:19",""
"23193035","what's the supported sip encryption protocols by Asterisk?","<p>Based on the following sencryption protocols, what's the supported one by Asterisk?</p>

<ul>
<li>RC4</li>
<li>RC2</li>
<li>DES</li>
<li>3DES</li>
</ul>

<p>Are there other encryption protocols suppoorted by asterisk?</p>

<p>Are there an asterisk command to know the supported encryption protocols?</p>
","<p>With regards to SIP, Asterisk (via chan_sip) supports encryption of both the signalling and the media. Arheops comment that Asterisk 1.8 doesn't support encryption is incorrect; this is true in Asterisk 1.8 and all later versions. For more information, see the <a href=""https://wiki.asterisk.org/wiki/display/AST/Secure+Calling"" rel=""nofollow"">Secure Calling</a> section on the Asterisk <a href=""https://wiki.asterisk.org"" rel=""nofollow"">wiki</a>.</p>

<p>Signalling is encrypted using OpenSSL (yes, the one with the vulnerability. Upgrade if you haven't). It defers encryption of the SIP signalling to OpenSSL. Which <a href=""https://www.openssl.org/docs/apps/ciphers.html#CIPHER_SUITE_NAMES"" rel=""nofollow"">cipher</a> is used is dependent on the version of OpenSSL you have installed, as well as what you configure in <a href=""http://svn.asterisk.org/svn/asterisk/branches/1.8/configs/sip.conf.sample"" rel=""nofollow"">sip.conf</a>, via the tlscipher option.</p>

<pre><code>;tlscipher=&lt;SSL cipher string&gt;
;        A string specifying which SSL ciphers to use or not use
;        A list of valid SSL cipher strings can be found at:
;                http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS
;
</code></pre>

<p>Asterisk supports encryption of the media in one of two ways. The first, supported in Asterisk 1.8 and later, is <a href=""http://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol"" rel=""nofollow"">SDES-SRTP</a>, via the libsrtp library. libsrtp uses AES as the default cipher.</p>

<p>As SDES-SRTP has to exchange keys in plain text in the signalling, another method of encrypting the media is available in Asterisk 11 and later, DTLS-SRTP. This uses OpenSSL's <a href=""http://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security"" rel=""nofollow"">DTLS</a> capabilities (available in more recent versions) to exchange the keys between the participants in the encrypted media stream. Note that this is the mechanism mandated by WebRTC (whereas SDES-SRTP got slapped down with a ""SHOULD NOT"" be implemented).</p>

<p>On a final note, in Asterisk 12, the <a href=""https://wiki.asterisk.org/wiki/display/AST/Configuring+res_pjsip"" rel=""nofollow"">new SIP stack</a> (based on PJSIP), also supports all of these various encryption mechanisms.</p>
","2403","<encryption><asterisk><des>","2","2","1","2014-04-23 03:43:51","23234350","5","1","","","","2014-04-21 07:38:16",""
"1418846","How do you use the crypt library in C for DES encryption? (setkey, encrypt, crypt, etc.)","<p>I need to do some simple DES encryption in C to interface with some old code. From what I understand you can use the ""crypt"" library for this, with the functions setkey, encrypt, crypt, etc. I have been messing with it and can't get it right. The example on the man page for setkey/encrypt is lacking.</p>

<p>I want to get the same output as I would be able to get with some java code (see below).</p>

<p>So let's say I have two character arrays in C.</p>

<pre><code>char *message = ""hellothe"";
char *key = ""iamakey0"";
</code></pre>

<p>Can someone give an example of how to encrypt these with setkey/encrypt and get the same result as I would from the java code? I realize you have to put message and key into a 64-byte array where each char represents a bit, but some of that is confusing too. Apparently you have to get the bit parity right on that too or something?</p>

<pre><code>public static byte[] encryptDES(byte[] message, byte[] key) {
    byte[] encrypted = new byte[0];
    try{
        Cipher c = Cipher.getInstance(""DES"");
        c.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(key,""DES""));
        encrypted = c.doFinal(message);
    }
    catch (Exception e) {
        e.printStackTrace();
    }
    return encrypted;
}
</code></pre>
","<p>Don't use crypt(). It uses some non-standard algorithm so it will be very difficult to interoperate with other systems. Besides, DES is not secure anyway. </p>

<p>I suggest you use OpenSSL in C. Most of its ciphers are compatible with JCE.</p>

<p>If you really have to use crypt, Sun's JRE comes with a class to handle crypt,</p>

<pre><code>   com.sun.security.auth.module.Crypt
</code></pre>

<p>This is internal class so the documentation isn't there. Just read the source code.</p>
","2389","<java><c><encryption><des>","0","1","2","2009-09-14 06:08:22","1419426","0","3","","","","2009-09-13 21:11:39",""
"1418846","How do you use the crypt library in C for DES encryption? (setkey, encrypt, crypt, etc.)","<p>I need to do some simple DES encryption in C to interface with some old code. From what I understand you can use the ""crypt"" library for this, with the functions setkey, encrypt, crypt, etc. I have been messing with it and can't get it right. The example on the man page for setkey/encrypt is lacking.</p>

<p>I want to get the same output as I would be able to get with some java code (see below).</p>

<p>So let's say I have two character arrays in C.</p>

<pre><code>char *message = ""hellothe"";
char *key = ""iamakey0"";
</code></pre>

<p>Can someone give an example of how to encrypt these with setkey/encrypt and get the same result as I would from the java code? I realize you have to put message and key into a 64-byte array where each char represents a bit, but some of that is confusing too. Apparently you have to get the bit parity right on that too or something?</p>

<pre><code>public static byte[] encryptDES(byte[] message, byte[] key) {
    byte[] encrypted = new byte[0];
    try{
        Cipher c = Cipher.getInstance(""DES"");
        c.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(key,""DES""));
        encrypted = c.doFinal(message);
    }
    catch (Exception e) {
        e.printStackTrace();
    }
    return encrypted;
}
</code></pre>
","<p>Because you're calling <code>Cipher.getInstance</code> with just the string <code>""DES""</code>, you're not specifying a cipher mode or padding method.  This means you get the defaults, which depends on what Java cryptography provider you're using - you need to know exactly what they are to write compatible C.  (You really should be specifying them rather than relying on defaults).</p>

<p>If you're using the SunJCE provider, then the defaults for DES are ECB mode and PKCS #5 padding.  The best way to do this is probably to use OpenSSL or another meaty crypto library - but if you want to use functions that are usually found in the standard C library on UNIX-type platforms, the <code>ecb_crypt</code> family of functions is going to be a lot easier to work with than the <code>setkey</code> / <code>encrypt</code> family.</p>

<p>You will need to add PKCS#5 padding when encrypting, and check it (and discard it) when decrypting).  The following <code>ecb_pkcs5_encrypt</code> function should do the rough equivalent of the above Java code using those functions.</p>

<pre><code>/* Returns a newly-allocated buffer containing the contents of `data',
 * padded out to a multiple of 8 bytes using PKCS #5 style padding.
 *
 * If `padded_len` is non-NULL, the value it points to is updated to
 * the size of the padded output data.
 *
 * Returns NULL on error.
 */
char *pad_pkcs5(const char *data, size_t data_len, size_t *padded_len)
{
    char *padded_data;
    unsigned padding_len = 8 - (data_len % 8);
    const char padding = padding_len;
    char *pad_ptr;

    /* check for length overflow */
    if (data_len + padding_len &lt; data_len)
        return NULL;

    /* Copy data into a new buffer and pad it out */
    padded_data = malloc(data_len + padding_len);

    if (!padded_data)
        return NULL;

    memcpy(padded_data, data, data_len);

    if (*padded_len)
    {
        *padded_len = data_len + padding_len;
    }

    /* Add the padding bytes */
    pad_ptr = padded_data + data_len;
    while (padding_len--)
    {
        *pad_ptr++ = padding;
    }

    return padded_data;
}

/* Returns a newly-allocated buffer containing the contents of `data',
 * encrypted with `key' using DES/ECB/PKCS5.
 *
 * If `out_len` is non-NULL, the value it points to is updated to
 * the size of the encrypted output data (which will always be a
 * multiple of 8).
 *
 * Returns NULL on error.
 */
char *ecb_pkcs5_encrypt(const char *key, const char *data, size_t data_len, size_t *out_len)
{
    char des_key[8];
    char *padded_data;
    size_t padded_len;
    int status;

    /* One of the few cases where strncpy() is exactly what we want! */
    strncpy(des_key, key, sizeof des_key);
    des_setparity(des_key);

    padded_data = pad_pkcs5(data, data_len, &amp;padded_len);

    if (!padded_data)
        return NULL;

    status = ecb_crypt(des_key, padded_data, padded_len, DES_ENCRYPT);

    if (DES_FAILED(status))
        return NULL;

    if (out_len)
        *out_len = padded_len;

    return padded_data;
}
</code></pre>
","2389","<java><c><encryption><des>","0","2","2","2009-09-14 06:08:22","1419426","0","3","","","","2009-09-13 21:11:39",""
"16235817","Python equivalent of PHP Mcrypt","<p>I wrote the following DES encryption scheme in PHP . It uses a static Initialization Vector to make sure the output  and input is one to one mapped </p>

<p>PHP code :</p>

<pre><code>function encrypt($plaintext, $key)
{
    # use an explicit encoding for the plain text
    $plaintext_utf8 = utf8_encode($plaintext);

    # create a random IV to use with CBC encoding
    # $iv_size = mcrypt_get_iv_size(MCRYPT_DES, MCRYPT_MODE_CBC);
    # $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
    # defining a constant IV to use with CBC encoding
    $iv = ""kritanj "";

    # creates the DES cipher text 
    $ciphertext = mcrypt_encrypt(MCRYPT_DES, $key, $plaintext_utf8, MCRYPT_MODE_CBC, $iv);
    # prepend the IV for it to be available for decryption
    $ciphertext = $iv . $ciphertext;   

    # encode the resulting cipher text so it can be represented by a string
    $ciphertext_base64 = base64_encode($ciphertext); 

    return $ciphertext_base64;
}

function decrypt($ciphertext_base64, $key)
{   
    $ciphertext_dec = base64_decode($ciphertext_base64);

    # retrieves the IV, iv_size should be created using mcrypt_get_iv_size()
    # $iv_size = mcrypt_get_iv_size(MCRYPT_DES, MCRYPT_MODE_CBC);
    # $iv = substr($ciphertext_dec, 0, $iv_size);
    $iv = ""kritanj "";

    # retrieves the cipher text (everything except the $iv_size in the front)
    $ciphertext_dec = substr($ciphertext_dec, $iv_size);

    # decrypting the DES cipher text 
    $plaintext_utf8_dec = mcrypt_decrypt(MCRYPT_DES, $key, $ciphertext_dec, MCRYPT_MODE_CBC, $iv);
    return $plaintext_utf8_dec;
}

$plaintext = ""The secret message is : "" ;
$key = ""7chrkey"" ;
$ciphertext = encrypt($plaintext, $key);
echo ""Encrypted: "".$ciphertext .""&lt;br&gt;"";
$plaintext1 = decrypt($ciphertext, $key);
echo ""Decrypted: "".$plaintext1  ;
</code></pre>

<p>Output :</p>

<pre><code>Encrypted: a3JpdGFuaiB3DY63WHnE9led43FyFe53HlhUEr+vVJg=
Decrypted: The secret message is :
</code></pre>

<p>Now I tried to write a equivalent code in python
Here is what I managed</p>

<p>Python code:</p>

<pre><code>import binascii
def conv_sevnCharKey_to_64bit_DESkey(key):
  st = bin(int(binascii.hexlify(key), 16))
  st = st[2:]
  des_key = ''
  for i in xrange(8) :
    parity = 0
    sevnBits = st[i*7:i*7+7]
    for c in sevnBits :
      if c in '1' :
        parity += 1
    if parity % 2 == 0 :
      eigthBytes = sevnBits + '1'
    else :
      eigthBytes = sevnBits + '0'
  des_key += eigthBytes

  n = int('0b'+des_key, 2)
  DESkey =  binascii.unhexlify('%x' % n)

  return DESkey

from pyDes import *
plaintext = ""The secret message is : ""
iv = 'kritanj '
key = conv_sevnCharKey_to_64bit_DESkey('7chrkey')

plaintext_utf8 = plaintext.encode('utf-8')
# iniltalizing DES in cbc mode     
k = des(key, CBC, iv)
# encrypting
ciphertext = k.encrypt(plaintext_utf8)
# prepending the IV
ciphertext = iv + ciphertext;
# encoding to base64 
ciphertext_base64 = ciphertext.encode('base64','strict')

print ""Encrypted: "", ciphertext_base64

# decoding base64 
ciphertext= ciphertext_base64.decode('base64','strict')
# striping the IV and decrypting
plaintext_utf8 = k.decrypt(ciphertext[8:])
# decoding utf-8 (if nessacary)
plaintext1 = plaint`ext_utf8.decode('utf-8') 

print ""Decrypted: "", plaintext1

assert plaintext1== plaintext
</code></pre>

<p>Output:</p>

<pre><code>Encrypted:  a3JpdGFuaiD+sGHb2GfZSXDac1r6mH+JDx7535yxL9k=

Decrypted:  The secret message is : 
</code></pre>

<p>Why are the ciphertexts different? And is there a way to make sure they are identical ?</p>

<p>[I want to make a 'meet in the middle' attack on a text encrypted under a double DES encryption using the above php code .
But since I cant recreate the encryption I cant implement the attack]</p>
","<p>Looks like your scheme to pad the key differs from the PHP code:
</p>

<pre><code>from pyDes import *
plaintext = ""The secret message is : ""
iv = 'kritanj '
key = '7chrkey'
plaintext = plaintext.encode(""utf-8"")
iv = 'kritanj '
k = des(key+'\0', CBC, iv)
print (iv + k.encrypt(plaintext)).encode(""base64"", ""strict"")
</code></pre>

<p>Output:</p>

<pre><code>'a3JpdGFuaiB3DY63WHnE9led43FyFe53HlhUEr+vVJg=\n'
</code></pre>

<p>In short: padding the encryption key with a NULL byte will yield the same result as your PHP code.</p>
","2386","<php><python><encryption><mcrypt><des>","3","2","1","2013-04-26 12:19:52","16236317","0","","","","","2013-04-26 11:54:43",""
"4723322","DES encoding with security key C#","<p>I know It's a probably common question but I cannot find answer anywhere. So I have byte array key and byte array value and I need to produce new 8 byte array that has been encrypted with DES in C#</p>
","<p>Here is your sample code. Remember to pad trailig zeros with random data, remember the bytes written, and DES parametrs: Key, IV.</p>

<p>Best wishes ;)</p>

<pre><code>using System.Security.Cryptography;
using System.IO;
namespace hash
{
    public static class Program
    {
        static void Main(string[] args)
        {
            byte[] data = new byte[10000];
            DES des = DES.Create();
            int bytesWritten = 0;
            data = Encode(data, des, out bytesWritten);
        }

        private static byte[] Encode(byte[] data, DES des, out int bytesWritten)
        {
            using (var input = new MemoryStream(data))
            using (var output = new MemoryStream())
            using (var csp = new DESCryptoServiceProvider())
            using (var encStream = new CryptoStream(output, csp.CreateEncryptor(des.Key, des.IV), CryptoStreamMode.Write))
            {
                int length = 0;
                byte[] buffer = new byte[256];
                bytesWritten = 0;
                while ((length = input.Read(buffer, 0, 256)) &gt; 0)
                {
                    if (length &lt; 256)
                    {
                        byte[] pad = new byte[256];
                        using (var rng = RNGCryptoServiceProvider.Create())
                        {
                            rng.GetBytes(pad);
                            for (int i = 0; i &lt; 256 - length; i++)
                            {
                                buffer[length + i] = pad[i];
                            }
                        }
                        encStream.Write(buffer, 0, length);
                        bytesWritten += length;
                        break;
                    }
                    encStream.Write(buffer, 0, 256);
                    bytesWritten += length;
                }
                return output.ToArray();
            }
        }
    }
}
</code></pre>
","2380","<c#><.net><encryption><des>","4","4","2","2011-01-19 08:15:18","4733077","5","2","","","","2011-01-18 11:05:07",""
"4723322","DES encoding with security key C#","<p>I know It's a probably common question but I cannot find answer anywhere. So I have byte array key and byte array value and I need to produce new 8 byte array that has been encrypted with DES in C#</p>
","<p>This is what I was looking for :D:D...thank you :D</p>

<pre><code>   private static byte[] Encrypt(byte[] value, byte[] key)
    {
        DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider
                                                      {
                                                          Mode = CipherMode.ECB,
                                                          Padding = PaddingMode.None
                                                      };

        MemoryStream memoryStream = new MemoryStream();

        CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateEncryptor(key, key), CryptoStreamMode.Write);

        cryptoStream.Write(value, 0, value.Length);
        cryptoStream.Close();

        return memoryStream.ToArray();
    }
</code></pre>
","2380","<c#><.net><encryption><des>","4","1","2","2011-01-19 08:15:18","4733077","5","2","","","","2011-01-18 11:05:07",""
"10750977","C# DES ECB Encryption","<p>I am having difficulty encrypting something in C#.</p>

<p>I have 3 variables.
First one is a 16 digit hex,lets call it X value I.E 0072701351979990
Second one is also a 16 digit hex value, lets call it Y I.E 3008168011FFFFFF</p>

<p>These two values have to be XOR 'ed to get the key for the DES-ECB encryption.</p>

<p>Thus resulting in 307a66934068666f . Now thus is my keyblock for the encryption.
Then i have this as my datablock,which is 64 bits for encryption 0E329232EA6D0D73</p>

<p>Now i have the following code for encryption this. 
The result of the encryption should be XOR'ed with the datablock again and 
result in a 64bit result. This is not the case.</p>

<p>This is my code for the encryption</p>

<pre><code>$ public static string DESEncrypt(string keyBlock,string dataBlock){
        DES desEncrypt = new DESCryptoServiceProvider();
        byte[] keyBlockBytes = BitConverter.GetBytes(Convert.ToInt64(keyBlock, 16));
        byte[] dataBlockBytes = BitConverter.GetBytes(Convert.ToInt64(dataBlock, 16));
        desEncrypt.Mode = CipherMode.ECB;
        desEncrypt.Key = keyBlockBytes;
        ICryptoTransform transForm = desEncrypt.CreateEncryptor();
        MemoryStream enecryptedStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(enecryptedStream, transForm, CryptoStreamMode.Write);
        cryptoStream.Write(dataBlockBytes, 0, dataBlockBytes.Length);
        cryptoStream.FlushFinalBlock();
        byte[] encryptedData = new byte[enecryptedStream.Length];
        enecryptedStream.Position = 0;
        enecryptedStream.Read(encryptedData, 0, encryptedData.Length);
        string enCryptedHex = BitConverter.ToString(encryptedData);

        return enCryptedHex.Replace(""-"",""""); 
    }
</code></pre>

<p>What am i doing wrong?</p>

<p><strong>UPDATED QUESTION</strong> 
I have tested the above solution from CodeInChaos. 
It does give me back a 64 bit result. But still there is something wrong.</p>

<p>Here is my updated code.</p>

<p>The keyblock value is abababababababab
and the data block value is 215135734068666F.</p>

<p>The resultant 64 bit result should be XOR'ed with the data block again.</p>

<p>The final answer is suppose to be 414945DD33C97C47 but I get 
288a08c01a57ed3d. </p>

<p>Why does it not come out right? </p>

<p>Here is the specifications in suppliers documentation for the encryption.</p>

<p>Encryption is DEA in accordance with FIPS 46-3, single DES in ECB mode, using a single 64-
bit DES Key with odd parity.</p>

<pre><code>$      public static string DESEncrypt(string keyBlock,string dataBlock){
        DES desEncrypt = new DESCryptoServiceProvider();
        byte[] keyBlockBytes = BitConverter.GetBytes(Convert.ToInt64(keyBlock, 16));
        byte[] dataBlockBytes = BitConverter.GetBytes(Convert.ToInt64(dataBlock, 16));
        desEncrypt.Mode = CipherMode.ECB;
        desEncrypt.Key = keyBlockBytes;
        desEncrypt.Padding = PaddingMode.None;
        ICryptoTransform transForm = desEncrypt.CreateEncryptor();
        MemoryStream enecryptedStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(enecryptedStream, transForm, CryptoStreamMode.Write);
        cryptoStream.Write(dataBlockBytes, 0, dataBlockBytes.Length);
        cryptoStream.FlushFinalBlock();
        byte[] encryptedData = enecryptedStream.ToArray();
        string enCryptedHex = BitConverter.ToString(encryptedData);
        enCryptedHex = enCryptedHex.Replace(""-"", """");
        long iDeaEncrypt = Convert.ToInt64(enCryptedHex, 16);
        long iDataBlock = Convert.ToInt64(dataBlock, 16);
        long decoderKey = iDeaEncrypt ^ iDataBlock;
        string decKeyHex = Convert.ToString(decoderKey, 16);
        return decKeyHex;
    }
</code></pre>
","<p>I think you need to set the padding to <code>PaddingMode.None</code>:</p>

<pre><code>desEncrypt.Padding = PaddingMode.None;
</code></pre>

<p>But you should really think hard, if DES and ECB is really what you want.</p>

<hr>

<p>b.t.w.</p>

<pre><code>byte[] encryptedData = new byte[enecryptedStream.Length];
encryptedStream.Position = 0;
encryptedStream.Read(encryptedData, 0, encryptedData.Length);
</code></pre>

<p>can be replaced by:</p>

<pre><code>encryptedData = encryptedStream.ToArray();
</code></pre>
","2343","<c#><encryption><des><ecb>","-1","0","2","2014-10-22 10:59:42","","1","1","1416885","","2012-05-25 10:02:53","2012-05-25 08:22:27",""
"10750977","C# DES ECB Encryption","<p>I am having difficulty encrypting something in C#.</p>

<p>I have 3 variables.
First one is a 16 digit hex,lets call it X value I.E 0072701351979990
Second one is also a 16 digit hex value, lets call it Y I.E 3008168011FFFFFF</p>

<p>These two values have to be XOR 'ed to get the key for the DES-ECB encryption.</p>

<p>Thus resulting in 307a66934068666f . Now thus is my keyblock for the encryption.
Then i have this as my datablock,which is 64 bits for encryption 0E329232EA6D0D73</p>

<p>Now i have the following code for encryption this. 
The result of the encryption should be XOR'ed with the datablock again and 
result in a 64bit result. This is not the case.</p>

<p>This is my code for the encryption</p>

<pre><code>$ public static string DESEncrypt(string keyBlock,string dataBlock){
        DES desEncrypt = new DESCryptoServiceProvider();
        byte[] keyBlockBytes = BitConverter.GetBytes(Convert.ToInt64(keyBlock, 16));
        byte[] dataBlockBytes = BitConverter.GetBytes(Convert.ToInt64(dataBlock, 16));
        desEncrypt.Mode = CipherMode.ECB;
        desEncrypt.Key = keyBlockBytes;
        ICryptoTransform transForm = desEncrypt.CreateEncryptor();
        MemoryStream enecryptedStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(enecryptedStream, transForm, CryptoStreamMode.Write);
        cryptoStream.Write(dataBlockBytes, 0, dataBlockBytes.Length);
        cryptoStream.FlushFinalBlock();
        byte[] encryptedData = new byte[enecryptedStream.Length];
        enecryptedStream.Position = 0;
        enecryptedStream.Read(encryptedData, 0, encryptedData.Length);
        string enCryptedHex = BitConverter.ToString(encryptedData);

        return enCryptedHex.Replace(""-"",""""); 
    }
</code></pre>

<p>What am i doing wrong?</p>

<p><strong>UPDATED QUESTION</strong> 
I have tested the above solution from CodeInChaos. 
It does give me back a 64 bit result. But still there is something wrong.</p>

<p>Here is my updated code.</p>

<p>The keyblock value is abababababababab
and the data block value is 215135734068666F.</p>

<p>The resultant 64 bit result should be XOR'ed with the data block again.</p>

<p>The final answer is suppose to be 414945DD33C97C47 but I get 
288a08c01a57ed3d. </p>

<p>Why does it not come out right? </p>

<p>Here is the specifications in suppliers documentation for the encryption.</p>

<p>Encryption is DEA in accordance with FIPS 46-3, single DES in ECB mode, using a single 64-
bit DES Key with odd parity.</p>

<pre><code>$      public static string DESEncrypt(string keyBlock,string dataBlock){
        DES desEncrypt = new DESCryptoServiceProvider();
        byte[] keyBlockBytes = BitConverter.GetBytes(Convert.ToInt64(keyBlock, 16));
        byte[] dataBlockBytes = BitConverter.GetBytes(Convert.ToInt64(dataBlock, 16));
        desEncrypt.Mode = CipherMode.ECB;
        desEncrypt.Key = keyBlockBytes;
        desEncrypt.Padding = PaddingMode.None;
        ICryptoTransform transForm = desEncrypt.CreateEncryptor();
        MemoryStream enecryptedStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(enecryptedStream, transForm, CryptoStreamMode.Write);
        cryptoStream.Write(dataBlockBytes, 0, dataBlockBytes.Length);
        cryptoStream.FlushFinalBlock();
        byte[] encryptedData = enecryptedStream.ToArray();
        string enCryptedHex = BitConverter.ToString(encryptedData);
        enCryptedHex = enCryptedHex.Replace(""-"", """");
        long iDeaEncrypt = Convert.ToInt64(enCryptedHex, 16);
        long iDataBlock = Convert.ToInt64(dataBlock, 16);
        long decoderKey = iDeaEncrypt ^ iDataBlock;
        string decKeyHex = Convert.ToString(decoderKey, 16);
        return decKeyHex;
    }
</code></pre>
","<p>Perhaps it is necessary to set DES Provider to use the FIPS 46-3 Standard so that the DEA uses the permutation tables etc. specified in FIPS 46-3.  Unfortunately I’m also struggling with this same issue.</p>
","2343","<c#><encryption><des><ecb>","-1","0","2","2014-10-22 10:59:42","","1","1","1416885","","2012-05-25 10:02:53","2012-05-25 08:22:27",""
"18082863","Test vectors for ECB, CBC, CFB and OFB modes of Triple DES","<p>Where I can get test vectors for CBC, CFB and OFB modes of Triple DES?</p>

<p>Help me please.</p>
","<p><a href=""http://csrc.nist.gov/publications/nistpubs/800-20/800-20.pdf"" rel=""nofollow"">This</a> is NIST's document specifying the modes of operation for 3-DES. It includes test vectors.</p>
","2338","<testing><encryption><standards><des><tripledes>","0","0","1","2016-01-25 15:10:12","","0","","4370109","","2016-01-25 15:10:12","2013-08-06 14:22:06",""
"20060200","DES Encryption: Given final block not properly padded","<p>I got this piece of code:</p>

<pre><code>static ReadableByteChannel readChannel = null;
static WritableByteChannel writeChannel = null;
static SecretKey key = makeKeyFromPassword(""chuj"".getBytes());

public static SecretKey makeKeyFromPassword(byte[] password) {

    try {
        key = KeyGenerator.getInstance(""DES"").generateKey();
        byte[] encoded = key.getEncoded();
        return new SecretKeySpec(encoded, ""DES"");
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    return null;
}

public static void run(int mode) throws Exception {
    ByteBuffer readBuffer = ByteBuffer.allocate(1024);
    ByteBuffer writeBuffer = ByteBuffer.allocate(1024);

    //initializing cipher...
    Cipher cipher = javax.crypto.Cipher.getInstance(""DES"");                                                         
    cipher.init(mode, key);  

    int read = -1;
    while((read = readChannel.read(readBuffer)) != -1){
        readBuffer.flip();
        cipher.doFinal(readBuffer, writeBuffer);
        writeChannel.write(writeBuffer);
        readBuffer.clear();
        writeBuffer.clear();
    }
}

public static void main(String[] args) {
    // TODO Auto-generated method stub\
    FileOutputStream fos = null;
    String inFileString = ""C:\\test.txt""; // Valid file pathname
    String fileString = ""C:\\des.txt""; // Valid file pathname
    int mode = Cipher.ENCRYPT_MODE;
    FileSystem fs = FileSystems.getDefault();
    Path fp = fs.getPath(inFileString);

    try {
        readChannel = FileChannel.open(fp, EnumSet.of(StandardOpenOption.READ));
        fos = new FileOutputStream(fileString);
        writeChannel = Channels.newChannel(fos);
        run(mode);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre>

<p>Encryption works without exceptions.
But when I try decrypt data (mode == DECRYPT_MODE and switched filenames) </p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
at com.sun.crypto.provider.DESCipher.engineDoFinal(DESCipher.java:357)
at javax.crypto.CipherSpi.bufferCrypt(CipherSpi.java:767)
at javax.crypto.CipherSpi.engineDoFinal(CipherSpi.java:721)
at javax.crypto.Cipher.doFinal(Cipher.java:2382)
at Test.run(Test.java:57)
at Test.main(Test.java:77)
</code></pre>

<p>pops out.</p>

<p>I tried with different keys, but unsuccessfully.
Any help will be appreciated.
[I have to use channels, this code is only test for part of bigger class]</p>
","<p>Two things:</p>

<ol>
<li>First of all, there is no correlation with <code>password</code> variable in the <code>makeKeyFromPassword</code> method. The returned <code>SecretKey</code> is random, so it will be impossible to decode the data in a two separates run of the program.</li>
<li>Secondly, there should be <code>writeBuffer.flip()</code> after <code>cipher.doFinal(readBuffer, writeBuffer)</code> ;-)</li>
</ol>

<p>Working code (please notice that password which is used to generate DES key need to be at least 8 characters):</p>

<pre><code>public class Test {

    static ReadableByteChannel readChannel = null;
    static WritableByteChannel writeChannel = null;
    static SecretKey key = makeKeyFromPassword(""abcdefghi"".getBytes()); 
    static byte b[];

    public static SecretKey makeKeyFromPassword(byte[] password) {
        try {
            DESKeySpec dks = new DESKeySpec(password);
            SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
            return skf.generateSecret(dks);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void run(int mode) throws Exception {
        ByteBuffer readBuffer = ByteBuffer.allocate(1024);
        ByteBuffer writeBuffer = ByteBuffer.allocate(1024);

        // initializing cipher...
        Cipher cipher = Cipher.getInstance(""DES"");
        cipher.init(mode, key);

        while (readChannel.read(readBuffer) != -1) {
            readBuffer.flip();
            cipher.doFinal(readBuffer, writeBuffer);
            writeBuffer.flip();
            writeChannel.write(writeBuffer);
            readBuffer.clear();
            writeBuffer.clear();
        }
    }

    static void f(String inFileString, String fileString, int mode) {
        FileOutputStream fos = null;
        FileSystem fs = FileSystems.getDefault();
        Path fp = fs.getPath(inFileString);

        try {
            readChannel = FileChannel.open(fp,
                    EnumSet.of(StandardOpenOption.READ));
            fos = new FileOutputStream(fileString);
            writeChannel = Channels.newChannel(fos);
            run(mode);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        f(""C:\\test.txt"", ""C:\\des.txt"", Cipher.ENCRYPT_MODE);
        System.out.println(""Encrypted."");
        f(""C:\\des.txt"", ""C:\\undes.txt"", Cipher.DECRYPT_MODE);
        System.out.println(""Decrypted."");
    }

}
</code></pre>
","2319","<java><encryption><padding><des>","2","2","2","2014-02-26 16:12:16","20061563","0","2","","","","2013-11-18 23:31:08",""
"20060200","DES Encryption: Given final block not properly padded","<p>I got this piece of code:</p>

<pre><code>static ReadableByteChannel readChannel = null;
static WritableByteChannel writeChannel = null;
static SecretKey key = makeKeyFromPassword(""chuj"".getBytes());

public static SecretKey makeKeyFromPassword(byte[] password) {

    try {
        key = KeyGenerator.getInstance(""DES"").generateKey();
        byte[] encoded = key.getEncoded();
        return new SecretKeySpec(encoded, ""DES"");
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    return null;
}

public static void run(int mode) throws Exception {
    ByteBuffer readBuffer = ByteBuffer.allocate(1024);
    ByteBuffer writeBuffer = ByteBuffer.allocate(1024);

    //initializing cipher...
    Cipher cipher = javax.crypto.Cipher.getInstance(""DES"");                                                         
    cipher.init(mode, key);  

    int read = -1;
    while((read = readChannel.read(readBuffer)) != -1){
        readBuffer.flip();
        cipher.doFinal(readBuffer, writeBuffer);
        writeChannel.write(writeBuffer);
        readBuffer.clear();
        writeBuffer.clear();
    }
}

public static void main(String[] args) {
    // TODO Auto-generated method stub\
    FileOutputStream fos = null;
    String inFileString = ""C:\\test.txt""; // Valid file pathname
    String fileString = ""C:\\des.txt""; // Valid file pathname
    int mode = Cipher.ENCRYPT_MODE;
    FileSystem fs = FileSystems.getDefault();
    Path fp = fs.getPath(inFileString);

    try {
        readChannel = FileChannel.open(fp, EnumSet.of(StandardOpenOption.READ));
        fos = new FileOutputStream(fileString);
        writeChannel = Channels.newChannel(fos);
        run(mode);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre>

<p>Encryption works without exceptions.
But when I try decrypt data (mode == DECRYPT_MODE and switched filenames) </p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
at com.sun.crypto.provider.DESCipher.engineDoFinal(DESCipher.java:357)
at javax.crypto.CipherSpi.bufferCrypt(CipherSpi.java:767)
at javax.crypto.CipherSpi.engineDoFinal(CipherSpi.java:721)
at javax.crypto.Cipher.doFinal(Cipher.java:2382)
at Test.run(Test.java:57)
at Test.main(Test.java:77)
</code></pre>

<p>pops out.</p>

<p>I tried with different keys, but unsuccessfully.
Any help will be appreciated.
[I have to use channels, this code is only test for part of bigger class]</p>
","<p>i had a similar issue, but was solved after i made the -passin and -passout fields different (in my pkcs12 -export command)</p>
","2319","<java><encryption><padding><des>","2","0","2","2014-02-26 16:12:16","20061563","0","2","","","","2013-11-18 23:31:08",""
"15443591","Mangler function for DES?","<p>The Mangler function takes as input 32 bits, and expands it to 48 bits.  It does this breaking the 32 bits in 8 4 bit chunks and concatenating the left and right bits to each chunk.  My question is this.  Where do the first four bit chunk get the left bit from?  Would it take it from the last bit of the last chunk?  Or would it simply concatenate a 0.  This applies to the last 4 bit chunk as well, except they would need to get the right bit which does not exist.</p>

<p>Thanks  </p>
","<p>The <a href=""http://en.wikipedia.org/wiki/DES_supplementary_material#Expansion_function_.28E.29"" rel=""nofollow noreferrer"">Expansion Function</a> takes the last bit from the last ""chunk"" and prepends it to the first ""chunk"" and the last ""chunk"" gets its rightmost bit from the leftmost bit in the first ""chunk"".</p>

<pre>
   32-bits  =>      48-bits
--------------------------------
 1  2  3  4 => <i>32</i>  <b>1  2  3  4</b>  <i>5</i>
 5  6  7  8 =>  <i>4  <b>5</i>  6  7  8</b>  <i>9</i>
 9 10 11 12 =>  <i>8  <b>9</i> 10 11 12</b> <i>13</i>
13 14 15 16 => <i>12 <b>13</i> 14 15 16</b> <i>17</i>
17 18 19 20 => <i>16 <b>17</i> 18 19 20</b> <i>21</i>
21 22 23 24 => <i>20 <b>21</i> 22 23 24</b> <i>25</i>
25 26 27 28 => <i>24 <b>25</i> 26 27 28</b> <i>29</i>
29 30 31 32 => <i>28 <b>29</i> 30 31 32</b>  <i>1</i>
</pre>  

<p>This illustration shows it quite clearly:</p>

<p><img src=""https://i.stack.imgur.com/YErik.png"" alt=""enter image description here""></p>
","2292","<security><des>","1","4","1","2013-03-15 23:51:35","15443714","0","","","","","2013-03-15 23:16:03",""
"39446834","How many keys does Triple DES encryption need?","<p>I am porting some C# code to C++, and trying to encrypt a textfile with Triple DES encryption. But I am confused; some encryption APIs only require one key for Triple DES (C# for example: <a href=""https://stackoverflow.com/questions/11413576/how-to-implement-triple-des-in-c-sharp-complete-example"">How to implement Triple DES in C# (complete example)</a> ), while others require 2 or 3 keys (in several C++ implementations I've found). </p>

<p>Why is that?</p>
","<p>The <a href=""https://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">TDEA</a> keying is maybe better understood here considering the key length over just a simple key. Depending on the keying option used, it can be a single key length, double key length, or triple key length. All parts are required and would constitute the ""key bundle"".</p>

<p>The TDEA is basically three applications of the DES cipher. Each part of the ""key bundle"" is used with one or more executions of the DES cipher algorithm (see also the <a href=""https://en.wikipedia.org/wiki/Feistel_cipher"" rel=""nofollow"">Feistel cipher</a>);</p>

<ul>
<li>for a single key, it is used three times (equates to classic DES but is no longer recommended), K1 = K2 = K3;</li>
<li>for a double key, the first part of the key is used twice, K1 and K2 are independent and K3 = K1;</li>
<li>and for the triple key length, each key part is used once, all parts are independent.</li>
</ul>

<p>What you are seeing as ""two"" (or ""three"") keys is most likely the double (or triple) key length being used, each part being provided separately.</p>

<p>The documentation for each API should provide details on how the keys are provided/expected.</p>

<p>A few test cases to check interoperability never hurt either.</p>

<hr>

<p>Some background/context on how TDEA works; source <a href=""https://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">Wikipedia</a>;</p>

<blockquote>
  <p>Triple DES uses a ""key bundle"" that comprises three DES keys, K1, K2 and K3, each of 56 bits (excluding parity bits)...</p>
  
  <p>The encryption algorithm is:</p>
  
  <p>ciphertext = E<sub>K3</sub>(D<sub>K2</sub>(E<sub>K1</sub>(plaintext)))</p>
  
  <p>I.e., DES encrypt with K1, DES decrypt with K2, then DES encrypt with K3.</p>
  
  <p>Decryption is the reverse:</p>
  
  <p>plaintext = D<sub>K1</sub>(E<sub>K2</sub>(D<sub>K3</sub>(ciphertext)))</p>
  
  <p>I.e., decrypt with K3, encrypt with K2, then decrypt with K1.</p>
  
  <p>Each triple encryption encrypts one block of 64 bits of data.</p>
</blockquote>
","2285","<c#><c++><encryption><des><tripledes>","3","2","2","2016-09-13 07:31:55","39447007","0","","-1","","2017-05-23 12:22:53","2016-09-12 09:09:27",""
"39446834","How many keys does Triple DES encryption need?","<p>I am porting some C# code to C++, and trying to encrypt a textfile with Triple DES encryption. But I am confused; some encryption APIs only require one key for Triple DES (C# for example: <a href=""https://stackoverflow.com/questions/11413576/how-to-implement-triple-des-in-c-sharp-complete-example"">How to implement Triple DES in C# (complete example)</a> ), while others require 2 or 3 keys (in several C++ implementations I've found). </p>

<p>Why is that?</p>
","<p>Niall's answer is correct, but to me it felt like a little bit more information would help your understanding of the problem better.</p>

<p>3DES is alternately referred to in some specifications as DES-EDE, which is DES-Encrypt/Decrypt/Encrypt.</p>

<pre><code>var x = Encrypt(key1, input);
x = Decrypt(key2, x);
x = Encrypt(key3, x);
return x;
</code></pre>

<p>So 3DES always requires 3 keys, each of which are have 56 key bits stretched into 64 bits (8 bytes) because every 7 bits gets a 1 bit parity check. This is frequently expressed as one 192-bit value (24 bytes) value, or an intermediate 128-bit value (16 bytes).</p>

<ul>
<li>If the 3DES key is 64 bits (which has a key strength of 56 bits, and many implementations will reject)

<ul>
<li>k1 = key</li>
<li>k2 = key</li>
<li>k3 = key</li>
</ul></li>
<li>If the 3DES key is 128 bits (which has a key strength of 112 bits)

<ul>
<li>k1 = key[0..7]</li>
<li>k2 = key[8..15]</li>
<li>k3 = k1</li>
</ul></li>
<li>If the 3DES key is 192 bits (which has a key strength of 168 bits)

<ul>
<li>k1 = key[0..7]</li>
<li>k2 = key[8..15]</li>
<li>k3 = key[16..23]</li>
</ul></li>
</ul>

<p>So if we have a 64-bit 3DES key we encrypt with the key, then decrypt with the key (returning the original data) and then encrypt with the key again. That makes ""one key"" 3DES equivalent to (1)DES.</p>

<p>Note that the DES-equivalent behavior can happen for two-key 3DES if k2 is coincidentally k1, (or 3-key if k1=k2=k3) so using 3DES isn't always an upgrade over using DES.</p>

<p>As for why the implementations differ: In C# arrays are length tagged, so passing one array the recipient can check if you are passing 8, 16, or 24 bytes. In C arrays aren't length tagged, so the API needs to either ask you how long your data is (which is what Windows CAPI and CNG do) or just take three different key pointers, and make you do the fragment cloning for 1-key and 2-key keys.</p>
","2285","<c#><c++><encryption><des><tripledes>","3","6","2","2016-09-13 07:31:55","39447007","0","","-1","","2017-05-23 12:22:53","2016-09-12 09:09:27",""
"23438146","Create custom key for DES encryption and decryption - Android","<p>I'm looking to encrypt a string using DES in one app and then decrypt it in another app. Currently I think its not working because the key to encrypt is generated randomly and so in the second app, the key generated when attempting to decrypt is different.</p>

<p>I need to be able to set my own key for when I am encrypting and then set the same key in the second app when decrypting but cannot find an explicit method on how to do so</p>

<p>Currently my key is being generated as follows:</p>

<pre><code>     KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
        SecretKey myDesKey = keygenerator.generateKey();
</code></pre>

<p>How can I create a dummy key to use (e.g. 12345678) </p>

<p>Thanks</p>
","<p>see this article, perhaps it can help you: </p>

<p><a href=""http://examples.javacodegeeks.com/core-java/crypto/encrypt-decrypt-with-des-using-pass-phrase/"" rel=""nofollow"">http://examples.javacodegeeks.com/core-java/crypto/encrypt-decrypt-with-des-using-pass-phrase/</a></p>
","2254","<android><encryption><key><des>","0","0","1","2014-05-03 01:33:27","","0","1","","","","2014-05-02 22:54:20",""
"25549279","Decrypt - Encrypt crypto-js","<p>I am trying to get crypto-js library to encrypt/decrypt a simple message, please see the following jsfiddle (<a href=""http://jsfiddle.net/6gunq2nx/"" rel=""nofollow noreferrer"">http://jsfiddle.net/6gunq2nx/</a>)</p>

<pre><code>&lt;script&gt;
    var encrypted = CryptoJS.AES.encrypt(""this is some test"", ""770A8A65DA156D24EE2A093277530142"");
    var decrypted = CryptoJS.AES.decrypt(encrypted, ""770A8A65DA156D24EE2A093277530142"");
    alert(decrypted);
&lt;/script&gt;
</code></pre>

<p><strong>The problem</strong> is that, it is not decrypting the message properly, I have tried AES and DES but both do not work, what im I doing wrong? please see below screenshot</p>

<p><img src=""https://i.stack.imgur.com/tqpjH.jpg"" alt=""AES""></p>
","<p>It's almost correct. The string you get is a hexadecimal representation of your original string. Try to convert it like this:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, ""770A8A65DA156D24EE2A093277530142"").toString(CryptoJS.enc.Utf8);
</code></pre>

<p>forked jsfiddle: <a href=""http://jsfiddle.net/1qgzk9j8/"" rel=""nofollow"">http://jsfiddle.net/1qgzk9j8/</a></p>
","2185","<javascript><algorithm><encryption><aes><des>","2","3","2","2014-08-28 12:59:01","25549377","1","","","","","2014-08-28 12:51:19",""
"25549279","Decrypt - Encrypt crypto-js","<p>I am trying to get crypto-js library to encrypt/decrypt a simple message, please see the following jsfiddle (<a href=""http://jsfiddle.net/6gunq2nx/"" rel=""nofollow noreferrer"">http://jsfiddle.net/6gunq2nx/</a>)</p>

<pre><code>&lt;script&gt;
    var encrypted = CryptoJS.AES.encrypt(""this is some test"", ""770A8A65DA156D24EE2A093277530142"");
    var decrypted = CryptoJS.AES.decrypt(encrypted, ""770A8A65DA156D24EE2A093277530142"");
    alert(decrypted);
&lt;/script&gt;
</code></pre>

<p><strong>The problem</strong> is that, it is not decrypting the message properly, I have tried AES and DES but both do not work, what im I doing wrong? please see below screenshot</p>

<p><img src=""https://i.stack.imgur.com/tqpjH.jpg"" alt=""AES""></p>
","<p>try this :-</p>

<pre><code>// Replace this with user input (only user should know the passphrase which can be used to decrypt the message)
var passphrase = '770A8A65DA156D24EE2A093277530142';

// Some content that we want to crypt
var content = 'this is some test';

// Use CryptoJS.AES to encrypt content using AES (Advanced Encryption Standard)
 var encryptedContent = CryptoJS.AES.encrypt(content, passphrase);

// Use CryptoJS.AES also to decrypt content
 var decryptedContent = CryptoJS.AES.decrypt(encryptedContent, passphrase).toString(CryptoJS.enc.Utf8);

alert(encryptedContent);
alert(decryptedContent);
</code></pre>

<p><a href=""http://jsfiddle.net/6gunq2nx/1/"" rel=""nofollow"">Demo</a></p>
","2185","<javascript><algorithm><encryption><aes><des>","2","1","2","2014-08-28 12:59:01","25549377","1","","","","","2014-08-28 12:51:19",""
"19943934","How do I decrypt an Adobe Triple Des ECB mode encrypted password?","<p>So as you may have heard. The adobe user database of 130 million was leaked recently. I want to find out what password I used for the adobe account I created to make sure that I'm not using it anywhere else. But how do I decrypt the Triple DES ECB Mode encrypted password? Is there a way to do this without knowing the Adobe Cipher Key? Is there a way to get the Cipher Key?</p>
","<p>You're using the wrong terminology.  You don't want to decrypt your password, you want to know how to re-encrypt your plain-text password to see if it matches the stolen one.  I'm sure there's a way.  However, you can solve this issue a lot easier just by logging in at adobe.com.  If you login successfully, they'll ask you to change your password.</p>
","2181","<encryption><adobe><des><ecb>","0","-1","1","2013-11-14 01:21:12","","5","","","","","2013-11-13 02:12:03",""
"15103237","Encryption algorithm about 3DES's ECB","<p>the data will be encrypted :<code>5140000000080401AEBFFFFFFFF7FBFE</code></p>

<p>the key is: <code>00000000000000000000000000000000</code></p>

<p>and the final result :<code>DBBE8A87A4E37D95B5EDDD2BE6A4151F</code></p>

<pre><code>//SecretKey to save data
    private SecretKey desKey;

    //Complete encryption and decryption work
    private Cipher c;

    //Save encryption results
    private byte[] cipherResultByte;

    private final static String Algorithm = ""DESede/ECB/NoPadding"";//Encryption method/operation mode

    private static DESedeKeySpec dks;

    private static SecretKeyFactory keyFactory;   

    public DESeseTest02() {

        Security.addProvider(new com.sun.crypto.provider.SunJCE());

        try {

            dks = new DESedeKeySpec(""00000000000000000000000000000000"".getBytes());   

             keyFactory = SecretKeyFactory.getInstance(""DESede"");


            //Generate key
            desKey=keyFactory.generateSecret(dks);


            //Generate Cipher object, specify its support DES algorithm
            c=Cipher.getInstance(Algorithm);

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
    }


    public byte[] createEncryptor(byte[] b){

        try {

//          System.out.println(str);
            //根据密钥，对Cipher进行初使化，DECRYPT_MODE加密模式
            c.init(Cipher.ENCRYPT_MODE, desKey);

//          byte[] input=str.getBytes();
//          System.out.println(input.length);

            //Encryption, the results will be preserved
            cipherResultByte=c.doFinal(b);

        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }
        return cipherResultByte;
    }
</code></pre>

<p>but the result is not as expected ,why?anyone 's help will be highly appreciate.</p>
","<p>Replace </p>

<pre><code>""00000000000000000000000000000000"".getBytes() 
</code></pre>

<p>with</p>

<pre><code>new byte[34]
</code></pre>

<p>""0"".getBytes() is not the same as new byte[]{0}</p>
","2145","<java><des>","0","2","1","2013-02-27 05:13:16","15104667","0","2","","","","2013-02-27 02:39:38",""
"3800888","Using function pointer member variables within an Objective-C Class","<p>(New to Objective-C, but well versed in C/C++).</p>

<p>Presently I have an Objective-C class and a number of its member variables will be function pointers.  These function pointers will only be modified by the class itself, but may be used by other classes.</p>

<p>I'm not sure how to set up access to said function pointers.</p>

<p>The solution I currently envision is to declare said function pointers @public, which as I understand it will allow me to call them using the -> operator.  This seems fairly unsatisfactory to me, since the function pointers are left open to meddling, and it flies in the face of sound OOP.  </p>

<p>My next inclination is toward using @property, and declaring them read only. This <strong>seems</strong> more sane.  I assume I'd call them using the dot operator, as the idea of using to getter to get the function pointer and then call it seems entirely ludicrous. </p>

<p>Can one use function pointers as properties?  If so, how would I go about declaring these to be properties:</p>

<pre><code>void (*sort)(SET, int) ;
char *(*toASCII)(CARD) ;
</code></pre>

<p>I have a feeling I'm missing a slight nuance to declaring these as properties.</p>
","<p>I believe you should be able to use function pointers as properties. You'd do it like this:</p>

<pre><code>@property (nonatomic, readonly) char *(*toASCII)(CARD);
</code></pre>

<p>And then in your implementation:</p>

<pre><code>@synthesize toASCII;
</code></pre>

<p>Then</p>

<pre><code>object.toASCII();
</code></pre>
","2139","<objective-c><class><oop><des>","1","1","2","2010-09-27 03:29:39","3800900","0","","","","","2010-09-27 03:18:56",""
"3800888","Using function pointer member variables within an Objective-C Class","<p>(New to Objective-C, but well versed in C/C++).</p>

<p>Presently I have an Objective-C class and a number of its member variables will be function pointers.  These function pointers will only be modified by the class itself, but may be used by other classes.</p>

<p>I'm not sure how to set up access to said function pointers.</p>

<p>The solution I currently envision is to declare said function pointers @public, which as I understand it will allow me to call them using the -> operator.  This seems fairly unsatisfactory to me, since the function pointers are left open to meddling, and it flies in the face of sound OOP.  </p>

<p>My next inclination is toward using @property, and declaring them read only. This <strong>seems</strong> more sane.  I assume I'd call them using the dot operator, as the idea of using to getter to get the function pointer and then call it seems entirely ludicrous. </p>

<p>Can one use function pointers as properties?  If so, how would I go about declaring these to be properties:</p>

<pre><code>void (*sort)(SET, int) ;
char *(*toASCII)(CARD) ;
</code></pre>

<p>I have a feeling I'm missing a slight nuance to declaring these as properties.</p>
","<p>In your @interface:</p>

<pre><code>@property(readonly) void (*sort)(SET, int);
@property(readonly) char *(*toASCII)(CARD);
</code></pre>

<p>In your @implementation:</p>

<pre><code>@synthesize sort, toASCII;
</code></pre>

<p>In your init method (or wherever else you want to set the function pointers):</p>

<pre><code>sort = someFunction;
toASCII = someFunction;
</code></pre>

<p>On modern versions of iOS, you don't even need to add an ivar (it gets added automatically for you when you do @synthesize).</p>
","2139","<objective-c><class><oop><des>","1","1","2","2010-09-27 03:29:39","3800900","0","","","","","2010-09-27 03:18:56",""
"24740361","java.security.NoSuchAlgorithmException: Cannot find any provider supporting PBEWithMD5AndDES","<p>I am getting the following Exception while executing my code.</p>

<p>Here the code snippet which causes this error</p>

<pre><code>Cipher c = Cipher.getInstance(""PBEWithMD5AndDES"");
</code></pre>

<p>I have used javax-crypto.jar.</p>

<pre><code>Caused by: java.security.NoSuchAlgorithmException: Cannot find any provider supporting PBEWithMD5AndDES
    at javax.crypto.Cipher.getInstance(DashoA13*..)
</code></pre>

<p>My runtime is </p>

<pre><code>C:\Documents and Settings\592635&gt;java -version
java version ""1.6.0_22""
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Java HotSpot(TM) Client VM (build 17.1-b03, mixed mode, sharing)
</code></pre>

<p>What can be the reason ? 
Please help.</p>
","<p>Your Oracle JRE has been configured this way or it has become corrupted. For instance, the provider that contains the required algorithm may have been removed from the list in <code>lib/security/java.security</code> in your Java JRE.</p>

<p>If you are not in an Oracle JRE then your runtime may not contain a provider that implements the algorithm. Note that a Java RE is not required to support <code>""PBEWithMD5AndDES""</code>, at least <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#impl"" rel=""nofollow"">not at the Java 7 level</a>. In that case install the Bouncy Castle or Spongy Castle libraries (according to their documentation).</p>
","2111","<java><encryption><md5><des>","-1","0","1","2014-07-15 22:54:48","","2","2","935374","","2014-07-15 07:36:18","2014-07-14 15:39:50",""
"42266168","Given final block not properly padded BadPaddingException from Cipher.doFinal DES","<p>NOTE: Per the accepted answer, this was simply a matter of supplying the wrong key.  If it's useful to others, I've left the code and initial question below.</p>

<p>=======</p>

<p>I had encrypted some text about a year and a half ago and now I can't decrypt it.  It worked then (and I know that the string itself hasn't changed), but now I get a ""Given final block not properly padded"" BadPaddingException.</p>

<p>Here's a standalone program with an encrypted string, key, and the code that I used at the time:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;


public class DoDecode {
    private static final String DES_TYPE = ""DES"";
//    private static final String DES_TYPE = ""DES/CBC/NoPadding"";
//    private static final String DES_TYPE = ""DES/CBC/PKCS5Padding"";
//    private static final String DES_TYPE = ""DES/ECB/NoPadding"";
//    private static final String DES_TYPE = ""DES/ECB/PKCS5Padding""; //Use this
//    private static final String DES_TYPE = ""DESede/CBC/NoPadding"";
//    private static final String DES_TYPE = ""DESede/CBC/PKCS5Padding"";
//    private static final String DES_TYPE = ""DESede/ECB/NoPadding"";
//    private static final String DES_TYPE = ""DESede/ECB/PKCS5Padding"";

    public synchronized static String encode(String unencodedString, String key) {
        String ret = null;

        try {
            DESKeySpec keySpec = new DESKeySpec(key.getBytes(""UTF8""));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
            SecretKey skey = keyFactory.generateSecret(keySpec);
            sun.misc.BASE64Encoder base64encoder = new BASE64Encoder();

            byte[] cleartext = unencodedString.getBytes(""UTF8"");

            Cipher cipher = Cipher.getInstance(DES_TYPE);
            cipher.init(Cipher.ENCRYPT_MODE, skey);

            ret = base64encoder.encode(cipher.doFinal(cleartext));
        } catch (Exception ex) {
            System.err.println(""Encode exception: ""+ex.getMessage());
        }

        return ret;
    }

    public static String decode(String encodedString, String key) {
        String ret = null;

        try {
            DESKeySpec keySpec = new DESKeySpec(key.getBytes(""UTF8""));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
            SecretKey skey = keyFactory.generateSecret(keySpec);
            sun.misc.BASE64Decoder base64decoder = new BASE64Decoder();

            byte[] encrypedPwdBytes = base64decoder.decodeBuffer(encodedString);

            Cipher cipher = Cipher.getInstance(DES_TYPE);
            cipher.init(Cipher.DECRYPT_MODE, skey);
            byte[] plainTextPwdBytes = (cipher.doFinal(encrypedPwdBytes));

            ret = new String(plainTextPwdBytes);
        } catch (Exception ex) {
            System.err.println(""Decode exception: "" + ex.getMessage());
        }

        return ret;
    }

    private static final String wasValidStr = ""h1JTFcRjW6vveQUrQqPUgnjGXo3NEZKDnBThZQN7uLfzPEpeFFONV4mvL71cT/xQb1mz5Xa/XZ/aW2GawZNumgO0reUZSDh30F7NfK0S/rMWM8FxcjBCkfFWAbLZHcyDJ5wW3F1yl5g="";

    public static void main(String[] args) {
        System.out.println(DoDecode.decode(wasValidStr, ""invpwd~~""));

        String encoded = DoDecode.encode(""This has worked in the past!"", ""invpwd~~"");
        System.out.println(encoded);
        System.out.println(DoDecode.decode(encoded, ""invpwd~~""));
    }
}
</code></pre>

<p>Gives me output of:</p>

<pre><code>Decode exception: Given final block not properly padded
null
U3ruztxHelQegTLyyA3IfMaGgVtmbP5na43S9JQmIc8=
This has worked in the past!
</code></pre>

<p>Note that I restored the code that I used since it may be a culprit.  I'm not currently using the sun.misc packages for Base64 and I get the same errors (java.util.Base64).</p>

<p>I've tried this on Linux, a Mac and a PC with the same result.  I utilized multiple JDK versions back to Java 1.6u45.  I also run the sample code with each of the different DES_TYPEs at the top of the class.</p>

<p>Any help much appreciated!</p>
","<p>I tracked down the answer.  The secret key was, in fact incorrect.  The error message is so confusing that I had been chasing far more sophisticated reasons for the Exception.  When I finally broke down and tried other historical keys, one magically unlocked everything.  :(</p>

<p>So (as other posts have highlighed), this error might just mean that you have supplied the wrong key.</p>
","2108","<java><exception><encryption><des>","0","0","1","2017-02-22 15:32:29","42335225","3","2","1709256","","2017-02-22 15:32:29","2017-02-16 06:05:52",""
"7045756","DES Implementation in Java: Error during Key Generation Phase","<p>I am a student doing a mini-project - DES implementation.
I had a doubt previously about converting a 64 bit key to 56 bit key, and could do that successfully, thanks to some guidance received here.</p>

<p>I have divided my implementation into the key-gen phase (where I generate a new key for each of the 16 rounds) and the encryption phase.</p>

<p>However, I am not able to generate the correct keys.
I did an example manually using ""abcdefgh"" as key and I am not able to reproduce the results in my program.</p>

<p>The DES keygen phase involves:</p>

<ol>
<li><p>Dividing 56-bit key into 2 28 bit keys. I store 28 bits in 4 bytes as <code>leftkey28[4]</code> (which has the last 4 bits as 0) &amp; <code>rightkey28[4]</code> (which has the first 4 bits as 0)</p></li>
<li><p>These 28 bit groups are left circular shifted using (&lt;&lt; 1 &amp; &lt;&lt; 2 in the original algorithm and then combined to get a new 56-bit key). However, because of this problem, I scrapped left shifting by 2 for now, and am only left circular shifting by 1. And still, the root of this problem is untraceable.</p></li>
</ol>

<p>The problem seems to be in the line <code>Round#2 Byte#2</code> in my output.</p>

<p>I will be grateful for any guidance or hints towards finding out the root cause.
(
P.S. I have never done so much bit manipulation before!
The code is not optimized or written according to Java rules/conventions as I just wanted to make it work before doing any other things
)</p>

<p>Thanks in advance.</p>

<pre><code>    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;

/**
 * @author krish 2nd Aug, 2011
 */

    class DES {

final static int KEY_LENGTH = 8; // 8 byte key, 64 bits
final static int BLOCK_SIZE = 8; // 8 byte blocks, 64 bits
final static int NUM_ROUNDS = 16; // 16 rounds per block

// =======================================================================
// FOR KEY TRANSFORMATION
int[] compressionPermutation = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21,
        10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47,
        55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36,
        29, 32 };

// int[] keyShiftValue = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };
// ---
// don't need this
// =======================================================================

public static void main(String[] args) {

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    System.out.println(""Enter an 8 char key: "");
    String inputKey, inputMsg;
    char[] inputArray;
    byte[] key64 = new byte[8];
    byte[] key56 = new byte[7];
    int counter;

    try {
        // get key, key length() &gt;= 8 chars

        // inputKey = br.readLine();// uncomment later!!$$$$$$$
        inputKey = ""abcdefgh"";
        System.out.println(inputKey);
        if (inputKey.length() &lt; 8) {
            System.out.println(""Key &lt; 8 B. Exiting. . ."");
            System.exit(1);
        }
        // java char has 16 bits instead of 8 bits as in C,
        // so convert it to 8 bit char by getting lower order byte &amp;
        // discarding higher order byte; &amp;
        // consider only first 8 chars even if input &gt; 8
        inputArray = inputKey.toCharArray();
        for (counter = 0; counter &lt; 8; counter++)
            key64[counter] = (byte) inputArray[counter];

        // converting 64bit key to 56 bit key
        for (counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
            key64[counter] = (byte) (key64[counter] &gt;&gt;&gt; 1);
            key64[counter] = (byte) (key64[counter] &lt;&lt; 1);
        }
        for (counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
            key56[counter] = (byte) (key64[counter] &lt;&lt; counter);
            key56[counter] = (byte) (key56[counter] | (key64[counter + 1] &gt;&gt;&gt; (KEY_LENGTH - 1 - counter)));
        }
        /*
         * Conversion from 64 to 56 bit testing code
         * 
         * System.out.println(""64 to 56 test:""); System.out.println(new
         * String(key56)); System.out.println(); for (int counter1 = 0;
         * counter1 &lt; 7; counter1++) { for (int counter2 = 7; counter2 &gt;= 0;
         * counter2--) { System.out.println(key56[counter1] &amp; (1 &lt;&lt;
         * counter2)); } System.out.println(); }
         */

        // end of obtaining 56bit key

        // KEY GENERATION PHASE
        // DS USED - compressionPermutation

        byte[] leftKey28 = new byte[4];
        byte[] rightKey28 = new byte[4];
        byte circularBit;
        byte[][] newKey56 = new byte[16][7];

        // new 56 bit key for the first round, then loop for other rounds
        leftKey28[0] = key56[0];
        leftKey28[1] = key56[1];
        leftKey28[2] = key56[2];
        leftKey28[3] = (byte) (key56[3] &amp; 11110000);

        // rightKey28[0] = (byte) (key56[3] &amp; 00001111);
        // prob here, doesnt work as given above??
        rightKey28[0] = (byte) (key56[3] - leftKey28[3]);
        rightKey28[1] = key56[4];
        rightKey28[2] = key56[5];
        rightKey28[3] = key56[6];

        /*
         * // printing starts here System.out.print(""1 Byte # 0"" + ""     "");
         * for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
         * System.out.print(leftKey28[0] &amp; (1 &lt;&lt; counter2));
         * System.out.print("", ""); } System.out.println(); // printing ends
         * here
         */

        circularBit = (byte) (leftKey28[0] &amp; (1 &lt;&lt; 7));

        leftKey28[0] = (byte) (leftKey28[0] &lt;&lt; 1);
        leftKey28[0] = (byte) (leftKey28[0] | ((((int) leftKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[1] = (byte) (leftKey28[1] &lt;&lt; 1);
        leftKey28[1] = (byte) (leftKey28[1] | ((((int) leftKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[2] = (byte) (leftKey28[2] &lt;&lt; 1);
        leftKey28[2] = (byte) (leftKey28[2] | ((((int) leftKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[3] = (byte) (leftKey28[3] &lt;&lt; 1);
        leftKey28[3] = (byte) (leftKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3));

        circularBit = (byte) (rightKey28[0] &amp; (1 &lt;&lt; 3));
        circularBit &lt;&lt;= 4;

        rightKey28[0] = (byte) (rightKey28[0] &lt;&lt; 1);
        rightKey28[0] = (byte) (rightKey28[0] | ((((int) rightKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[1] = (byte) (rightKey28[1] &lt;&lt; 1);
        rightKey28[1] = (byte) (rightKey28[1] | ((((int) rightKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[2] = (byte) (rightKey28[2] &lt;&lt; 1);
        rightKey28[2] = (byte) (rightKey28[2] | ((((int) rightKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[3] = (byte) (rightKey28[3] &lt;&lt; 1);
        rightKey28[3] = (byte) (rightKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3));

        newKey56[0][0] = leftKey28[0];
        newKey56[0][1] = leftKey28[1];
        newKey56[0][2] = leftKey28[2];
        newKey56[0][3] = (byte) (leftKey28[3] | rightKey28[0]);
        newKey56[0][4] = rightKey28[1];
        newKey56[0][5] = rightKey28[2];
        newKey56[0][6] = rightKey28[3];
        // we have a new left circular shifted key in newKey56

        // done testing for newkey56[0] // left and right testing code
        for (int counter1 = 0; counter1 &lt; 7; counter1++) {
            System.out.print(""Round#0 Byte#"" + counter1 + ""  "");
            for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
                if (counter2 == 3)
                    System.out.print(""   "");
                if ((newKey56[0][counter1] &amp; (1 &lt;&lt; counter2)) &gt; 0) {
                    System.out.print(""1"");
                } else {
                    System.out.print(""0"");
                }
            }
            System.out.println();
        }
        // left and right testing code ends here

        // for round 1 to 15: left circular shift each 28 bit block by 1{
        for (int round = 1; round &lt; NUM_ROUNDS; round++) {
            // for the first round, then loop for other rounds
            leftKey28[0] = newKey56[round - 1][0];
            leftKey28[1] = newKey56[round - 1][1];
            leftKey28[2] = newKey56[round - 1][2];
            leftKey28[3] = (byte) (newKey56[round - 1][3] &amp; 11110000);

            // rightKey28[0] = (byte) (newKey56[round - 1][3] &amp; 00001111);
            rightKey28[0] = (byte) (newKey56[round - 1][3] - leftKey28[3]);
            rightKey28[1] = newKey56[round - 1][4];
            rightKey28[2] = newKey56[round - 1][5];
            rightKey28[3] = newKey56[round - 1][6];

            // if (round == 1 || round == 8 || round == 15) {
            // left circular shift by 1
            circularBit = (byte) (leftKey28[0] &amp; (1 &lt;&lt; 7));

            leftKey28[0] &lt;&lt;= 1;
            leftKey28[0] |= ((((int) leftKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7);

            leftKey28[1] &lt;&lt;= 1;
            leftKey28[1] |= ((((int) leftKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7);

            // ////////////////////////error here ////////////////////////////
            leftKey28[2] &lt;&lt;= 1;
            leftKey28[2] |= ((((int) leftKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7);
            // ////////////////////////error here //////////////////////////

            leftKey28[3] &lt;&lt;= 1;
            leftKey28[3] |= ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3);

            circularBit = (byte) (rightKey28[0] &amp; (1 &lt;&lt; 3));
            circularBit &lt;&lt;= 4;

            // //////////////////////////////////////////////////
            rightKey28[0] = (byte) (rightKey28[0] &lt;&lt; 1);
            rightKey28[0] &amp;= 00001111;
            rightKey28[0] = (byte) (rightKey28[0] | ((((int) rightKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));
            // //////////////////////////////////////////////////

            rightKey28[1] = (byte) (rightKey28[1] &lt;&lt; 1);
            rightKey28[1] = (byte) (rightKey28[1] | ((((int) rightKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

            rightKey28[2] = (byte) (rightKey28[2] &lt;&lt; 1);
            rightKey28[2] = (byte) (rightKey28[2] | ((((int) rightKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

            rightKey28[3] = (byte) (rightKey28[3] &lt;&lt; 1);
            rightKey28[3] = (byte) (rightKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 7));
            // } else {
            // // left circular shift by 2
            // }

            newKey56[round][0] = leftKey28[0];
            newKey56[round][1] = leftKey28[1];
            newKey56[round][2] = leftKey28[2];
            newKey56[round][3] = (byte) (leftKey28[3] | rightKey28[0]);
            newKey56[round][4] = rightKey28[1];
            newKey56[round][5] = rightKey28[2];
            newKey56[round][6] = rightKey28[3];

            // testing code for all keys for rounds 1 to 15
            System.out.println();
            for (int counter1 = 0; counter1 &lt; 7; counter1++) {
                System.out.print(""Round#"" + round + ""  Byte#"" + counter1
                        + ""  "");
                for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
                    if (counter2 == 3)
                        System.out.print(""   "");
                    if ((newKey56[round][counter1] &amp; (1 &lt;&lt; counter2)) &gt; 0) {
                        System.out.print(""1"");
                    } else {
                        System.out.print(""0"");
                    }

                }
                System.out.println();
            }
            if (round == 2)
                break;
            // testing code ends

        }// for loop ends

        /*
         * // newKey56 testing code
         * System.out.println(""new56key testing here""); for (counter = 0;
         * counter &lt; NUM_ROUNDS; counter++) { System.out.println(new
         * String(newKey56[counter])); System.out.println();
         * 
         * for (int counter1 = 0; counter1 &lt; 7; counter1++) {
         * System.out.print(""Round # "" + counter + "" Byte # "" + counter1 +
         * ""     ""); for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
         * System.out.print(newKey56[counter][counter1] &amp; (1 &lt;&lt; counter2));
         * System.out.print("", ""); } System.out.println(); } }
         */

        // DO KEY COMPRESSION ROUTINE HERE

    } catch (Exception e) {
        e.printStackTrace();
    }
}
    }

    Enter an 8 char key: 
    abcdefgh
    Round#0 Byte#0  1100   0001
    Round#0 Byte#1  1000   1011
    Round#0 Byte#2  0001   0110
    Round#0 Byte#3  0100   1100
    Round#0 Byte#4  1001   1001
    Round#0 Byte#5  1011   0011
    Round#0 Byte#6  0110   1000

    Round#1  Byte#0  1000   0011
    Round#1  Byte#1  0001   0110
    Round#1  Byte#2  0010   1100
    Round#1  Byte#3  1001   1001
    Round#1  Byte#4  0011   0011
    Round#1  Byte#5  0110   0110
    Round#1  Byte#6  1101   0001

    Round#2  Byte#0  0000   0110
    Round#2  Byte#1  0010   1100
    Round#2  Byte#2  0101   1000 //error here =&gt; 0101 1001
    Round#2  Byte#3  0011   0000 //error here =&gt; 0011 0010
    Round#2  Byte#4  0110   0110
    Round#2  Byte#5  1100   1101
    Round#2  Byte#6  1010   0011
</code></pre>
","<p>The convention with DES is to pretend you have 64 bit keys (8 bytes), but if you want to be really, uhh, pedantic, you clobber the 8th bit of each of these bytes with the parity of preceding 7 bits.</p>

<p>I've only played with Java, and I've seen that Java (Sun/Oracle JRE) doesn't bother checking parity.  It just ignores the 8th bit of each byte.</p>

<p>Maybe the <code>DESEngine</code> in BouncyCastle will be of some help to you.  The <code>generateWorkingKey()</code> method looks interesting:</p>

<p><a href=""http://www.bouncycastle.org/viewcvs/viewcvs.cgi/java/crypto/src/org/bouncycastle/crypto/engines/DESEngine.java?view=markup"" rel=""nofollow"">http://www.bouncycastle.org/viewcvs/viewcvs.cgi/java/crypto/src/org/bouncycastle/crypto/engines/DESEngine.java?view=markup</a></p>
","2060","<java><bit-manipulation><des>","2","1","3","2011-09-10 20:50:13","","4","","544963","","2011-08-12 20:22:31","2011-08-12 20:09:47",""
"7045756","DES Implementation in Java: Error during Key Generation Phase","<p>I am a student doing a mini-project - DES implementation.
I had a doubt previously about converting a 64 bit key to 56 bit key, and could do that successfully, thanks to some guidance received here.</p>

<p>I have divided my implementation into the key-gen phase (where I generate a new key for each of the 16 rounds) and the encryption phase.</p>

<p>However, I am not able to generate the correct keys.
I did an example manually using ""abcdefgh"" as key and I am not able to reproduce the results in my program.</p>

<p>The DES keygen phase involves:</p>

<ol>
<li><p>Dividing 56-bit key into 2 28 bit keys. I store 28 bits in 4 bytes as <code>leftkey28[4]</code> (which has the last 4 bits as 0) &amp; <code>rightkey28[4]</code> (which has the first 4 bits as 0)</p></li>
<li><p>These 28 bit groups are left circular shifted using (&lt;&lt; 1 &amp; &lt;&lt; 2 in the original algorithm and then combined to get a new 56-bit key). However, because of this problem, I scrapped left shifting by 2 for now, and am only left circular shifting by 1. And still, the root of this problem is untraceable.</p></li>
</ol>

<p>The problem seems to be in the line <code>Round#2 Byte#2</code> in my output.</p>

<p>I will be grateful for any guidance or hints towards finding out the root cause.
(
P.S. I have never done so much bit manipulation before!
The code is not optimized or written according to Java rules/conventions as I just wanted to make it work before doing any other things
)</p>

<p>Thanks in advance.</p>

<pre><code>    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;

/**
 * @author krish 2nd Aug, 2011
 */

    class DES {

final static int KEY_LENGTH = 8; // 8 byte key, 64 bits
final static int BLOCK_SIZE = 8; // 8 byte blocks, 64 bits
final static int NUM_ROUNDS = 16; // 16 rounds per block

// =======================================================================
// FOR KEY TRANSFORMATION
int[] compressionPermutation = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21,
        10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47,
        55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36,
        29, 32 };

// int[] keyShiftValue = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };
// ---
// don't need this
// =======================================================================

public static void main(String[] args) {

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    System.out.println(""Enter an 8 char key: "");
    String inputKey, inputMsg;
    char[] inputArray;
    byte[] key64 = new byte[8];
    byte[] key56 = new byte[7];
    int counter;

    try {
        // get key, key length() &gt;= 8 chars

        // inputKey = br.readLine();// uncomment later!!$$$$$$$
        inputKey = ""abcdefgh"";
        System.out.println(inputKey);
        if (inputKey.length() &lt; 8) {
            System.out.println(""Key &lt; 8 B. Exiting. . ."");
            System.exit(1);
        }
        // java char has 16 bits instead of 8 bits as in C,
        // so convert it to 8 bit char by getting lower order byte &amp;
        // discarding higher order byte; &amp;
        // consider only first 8 chars even if input &gt; 8
        inputArray = inputKey.toCharArray();
        for (counter = 0; counter &lt; 8; counter++)
            key64[counter] = (byte) inputArray[counter];

        // converting 64bit key to 56 bit key
        for (counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
            key64[counter] = (byte) (key64[counter] &gt;&gt;&gt; 1);
            key64[counter] = (byte) (key64[counter] &lt;&lt; 1);
        }
        for (counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
            key56[counter] = (byte) (key64[counter] &lt;&lt; counter);
            key56[counter] = (byte) (key56[counter] | (key64[counter + 1] &gt;&gt;&gt; (KEY_LENGTH - 1 - counter)));
        }
        /*
         * Conversion from 64 to 56 bit testing code
         * 
         * System.out.println(""64 to 56 test:""); System.out.println(new
         * String(key56)); System.out.println(); for (int counter1 = 0;
         * counter1 &lt; 7; counter1++) { for (int counter2 = 7; counter2 &gt;= 0;
         * counter2--) { System.out.println(key56[counter1] &amp; (1 &lt;&lt;
         * counter2)); } System.out.println(); }
         */

        // end of obtaining 56bit key

        // KEY GENERATION PHASE
        // DS USED - compressionPermutation

        byte[] leftKey28 = new byte[4];
        byte[] rightKey28 = new byte[4];
        byte circularBit;
        byte[][] newKey56 = new byte[16][7];

        // new 56 bit key for the first round, then loop for other rounds
        leftKey28[0] = key56[0];
        leftKey28[1] = key56[1];
        leftKey28[2] = key56[2];
        leftKey28[3] = (byte) (key56[3] &amp; 11110000);

        // rightKey28[0] = (byte) (key56[3] &amp; 00001111);
        // prob here, doesnt work as given above??
        rightKey28[0] = (byte) (key56[3] - leftKey28[3]);
        rightKey28[1] = key56[4];
        rightKey28[2] = key56[5];
        rightKey28[3] = key56[6];

        /*
         * // printing starts here System.out.print(""1 Byte # 0"" + ""     "");
         * for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
         * System.out.print(leftKey28[0] &amp; (1 &lt;&lt; counter2));
         * System.out.print("", ""); } System.out.println(); // printing ends
         * here
         */

        circularBit = (byte) (leftKey28[0] &amp; (1 &lt;&lt; 7));

        leftKey28[0] = (byte) (leftKey28[0] &lt;&lt; 1);
        leftKey28[0] = (byte) (leftKey28[0] | ((((int) leftKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[1] = (byte) (leftKey28[1] &lt;&lt; 1);
        leftKey28[1] = (byte) (leftKey28[1] | ((((int) leftKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[2] = (byte) (leftKey28[2] &lt;&lt; 1);
        leftKey28[2] = (byte) (leftKey28[2] | ((((int) leftKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[3] = (byte) (leftKey28[3] &lt;&lt; 1);
        leftKey28[3] = (byte) (leftKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3));

        circularBit = (byte) (rightKey28[0] &amp; (1 &lt;&lt; 3));
        circularBit &lt;&lt;= 4;

        rightKey28[0] = (byte) (rightKey28[0] &lt;&lt; 1);
        rightKey28[0] = (byte) (rightKey28[0] | ((((int) rightKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[1] = (byte) (rightKey28[1] &lt;&lt; 1);
        rightKey28[1] = (byte) (rightKey28[1] | ((((int) rightKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[2] = (byte) (rightKey28[2] &lt;&lt; 1);
        rightKey28[2] = (byte) (rightKey28[2] | ((((int) rightKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[3] = (byte) (rightKey28[3] &lt;&lt; 1);
        rightKey28[3] = (byte) (rightKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3));

        newKey56[0][0] = leftKey28[0];
        newKey56[0][1] = leftKey28[1];
        newKey56[0][2] = leftKey28[2];
        newKey56[0][3] = (byte) (leftKey28[3] | rightKey28[0]);
        newKey56[0][4] = rightKey28[1];
        newKey56[0][5] = rightKey28[2];
        newKey56[0][6] = rightKey28[3];
        // we have a new left circular shifted key in newKey56

        // done testing for newkey56[0] // left and right testing code
        for (int counter1 = 0; counter1 &lt; 7; counter1++) {
            System.out.print(""Round#0 Byte#"" + counter1 + ""  "");
            for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
                if (counter2 == 3)
                    System.out.print(""   "");
                if ((newKey56[0][counter1] &amp; (1 &lt;&lt; counter2)) &gt; 0) {
                    System.out.print(""1"");
                } else {
                    System.out.print(""0"");
                }
            }
            System.out.println();
        }
        // left and right testing code ends here

        // for round 1 to 15: left circular shift each 28 bit block by 1{
        for (int round = 1; round &lt; NUM_ROUNDS; round++) {
            // for the first round, then loop for other rounds
            leftKey28[0] = newKey56[round - 1][0];
            leftKey28[1] = newKey56[round - 1][1];
            leftKey28[2] = newKey56[round - 1][2];
            leftKey28[3] = (byte) (newKey56[round - 1][3] &amp; 11110000);

            // rightKey28[0] = (byte) (newKey56[round - 1][3] &amp; 00001111);
            rightKey28[0] = (byte) (newKey56[round - 1][3] - leftKey28[3]);
            rightKey28[1] = newKey56[round - 1][4];
            rightKey28[2] = newKey56[round - 1][5];
            rightKey28[3] = newKey56[round - 1][6];

            // if (round == 1 || round == 8 || round == 15) {
            // left circular shift by 1
            circularBit = (byte) (leftKey28[0] &amp; (1 &lt;&lt; 7));

            leftKey28[0] &lt;&lt;= 1;
            leftKey28[0] |= ((((int) leftKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7);

            leftKey28[1] &lt;&lt;= 1;
            leftKey28[1] |= ((((int) leftKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7);

            // ////////////////////////error here ////////////////////////////
            leftKey28[2] &lt;&lt;= 1;
            leftKey28[2] |= ((((int) leftKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7);
            // ////////////////////////error here //////////////////////////

            leftKey28[3] &lt;&lt;= 1;
            leftKey28[3] |= ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3);

            circularBit = (byte) (rightKey28[0] &amp; (1 &lt;&lt; 3));
            circularBit &lt;&lt;= 4;

            // //////////////////////////////////////////////////
            rightKey28[0] = (byte) (rightKey28[0] &lt;&lt; 1);
            rightKey28[0] &amp;= 00001111;
            rightKey28[0] = (byte) (rightKey28[0] | ((((int) rightKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));
            // //////////////////////////////////////////////////

            rightKey28[1] = (byte) (rightKey28[1] &lt;&lt; 1);
            rightKey28[1] = (byte) (rightKey28[1] | ((((int) rightKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

            rightKey28[2] = (byte) (rightKey28[2] &lt;&lt; 1);
            rightKey28[2] = (byte) (rightKey28[2] | ((((int) rightKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

            rightKey28[3] = (byte) (rightKey28[3] &lt;&lt; 1);
            rightKey28[3] = (byte) (rightKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 7));
            // } else {
            // // left circular shift by 2
            // }

            newKey56[round][0] = leftKey28[0];
            newKey56[round][1] = leftKey28[1];
            newKey56[round][2] = leftKey28[2];
            newKey56[round][3] = (byte) (leftKey28[3] | rightKey28[0]);
            newKey56[round][4] = rightKey28[1];
            newKey56[round][5] = rightKey28[2];
            newKey56[round][6] = rightKey28[3];

            // testing code for all keys for rounds 1 to 15
            System.out.println();
            for (int counter1 = 0; counter1 &lt; 7; counter1++) {
                System.out.print(""Round#"" + round + ""  Byte#"" + counter1
                        + ""  "");
                for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
                    if (counter2 == 3)
                        System.out.print(""   "");
                    if ((newKey56[round][counter1] &amp; (1 &lt;&lt; counter2)) &gt; 0) {
                        System.out.print(""1"");
                    } else {
                        System.out.print(""0"");
                    }

                }
                System.out.println();
            }
            if (round == 2)
                break;
            // testing code ends

        }// for loop ends

        /*
         * // newKey56 testing code
         * System.out.println(""new56key testing here""); for (counter = 0;
         * counter &lt; NUM_ROUNDS; counter++) { System.out.println(new
         * String(newKey56[counter])); System.out.println();
         * 
         * for (int counter1 = 0; counter1 &lt; 7; counter1++) {
         * System.out.print(""Round # "" + counter + "" Byte # "" + counter1 +
         * ""     ""); for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
         * System.out.print(newKey56[counter][counter1] &amp; (1 &lt;&lt; counter2));
         * System.out.print("", ""); } System.out.println(); } }
         */

        // DO KEY COMPRESSION ROUTINE HERE

    } catch (Exception e) {
        e.printStackTrace();
    }
}
    }

    Enter an 8 char key: 
    abcdefgh
    Round#0 Byte#0  1100   0001
    Round#0 Byte#1  1000   1011
    Round#0 Byte#2  0001   0110
    Round#0 Byte#3  0100   1100
    Round#0 Byte#4  1001   1001
    Round#0 Byte#5  1011   0011
    Round#0 Byte#6  0110   1000

    Round#1  Byte#0  1000   0011
    Round#1  Byte#1  0001   0110
    Round#1  Byte#2  0010   1100
    Round#1  Byte#3  1001   1001
    Round#1  Byte#4  0011   0011
    Round#1  Byte#5  0110   0110
    Round#1  Byte#6  1101   0001

    Round#2  Byte#0  0000   0110
    Round#2  Byte#1  0010   1100
    Round#2  Byte#2  0101   1000 //error here =&gt; 0101 1001
    Round#2  Byte#3  0011   0000 //error here =&gt; 0011 0010
    Round#2  Byte#4  0110   0110
    Round#2  Byte#5  1100   1101
    Round#2  Byte#6  1010   0011
</code></pre>
","<p>It looks like you had it right in the first place (sort of):</p>

<pre><code>// rightKey28[0] = (byte) (key56[3] &amp; 00001111);
</code></pre>

<p>But you replaced it with subtraction: </p>

<pre><code>rightKey28[0] = (byte) (key56[3] - leftKey28[3]);
</code></pre>

<p>If you want the first byte of <code>rightKey28</code> to have its four least-order bits set, your original code was (almost) correct; the new code is wrong.</p>

<p>The ""sort of"" and ""almost"" refer to the fact that binary literals are not supported until Java 7. So ""11110000"" is a decimal integer, with a binary pattern of <code>101010011000011001110000</code>. It almost works by coincidence, but you miss the highest order bit; I think what you want here is <code>0xF0</code> (and <code>0x0F</code> for the low order bits).</p>

<p>Also, these parts looks suspect:</p>

<pre><code>circularBit = (byte) (rightKey28[0] &amp; (1 &lt;&lt; 3));
circularBit &lt;&lt;= 4;
</code></pre>

<p>This is moving the ""circular"" bit to the high order position in the byte: <code>X000000</code>.</p>

<p>But later you shift it right only 3 bits:</p>

<pre><code>rightKey28[3] = (byte) (rightKey28[3] &lt;&lt; 1);
rightKey28[3] = (byte) (rightKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3));
</code></pre>

<p>If <code>rightKey28[3]</code> starts with a bit pattern <code>ABCDEFGH</code>, it will end up with pattern <code>BCDYFGH0</code>, where <code>Y</code> is the logical result of <code>X | E</code>. Don't you really want <code>BCDEFGHX</code>? If so, you right shift <code>circularBit</code> by 7 bits.</p>

<p>Finally, note that <code>rightKey[0]</code> will have 5 bits set, because you shift the 4 bits it starts with left by 1. You may want to mask to ensure only the low order 4 bits contain data:</p>

<pre><code>rightKey28[0] = (byte) ((rightKey28[0] &lt;&lt; 1) &amp; 0x0F);
</code></pre>
","2060","<java><bit-manipulation><des>","2","1","3","2011-09-10 20:50:13","","4","","544963","","2011-08-12 20:22:31","2011-08-12 20:09:47",""
"7045756","DES Implementation in Java: Error during Key Generation Phase","<p>I am a student doing a mini-project - DES implementation.
I had a doubt previously about converting a 64 bit key to 56 bit key, and could do that successfully, thanks to some guidance received here.</p>

<p>I have divided my implementation into the key-gen phase (where I generate a new key for each of the 16 rounds) and the encryption phase.</p>

<p>However, I am not able to generate the correct keys.
I did an example manually using ""abcdefgh"" as key and I am not able to reproduce the results in my program.</p>

<p>The DES keygen phase involves:</p>

<ol>
<li><p>Dividing 56-bit key into 2 28 bit keys. I store 28 bits in 4 bytes as <code>leftkey28[4]</code> (which has the last 4 bits as 0) &amp; <code>rightkey28[4]</code> (which has the first 4 bits as 0)</p></li>
<li><p>These 28 bit groups are left circular shifted using (&lt;&lt; 1 &amp; &lt;&lt; 2 in the original algorithm and then combined to get a new 56-bit key). However, because of this problem, I scrapped left shifting by 2 for now, and am only left circular shifting by 1. And still, the root of this problem is untraceable.</p></li>
</ol>

<p>The problem seems to be in the line <code>Round#2 Byte#2</code> in my output.</p>

<p>I will be grateful for any guidance or hints towards finding out the root cause.
(
P.S. I have never done so much bit manipulation before!
The code is not optimized or written according to Java rules/conventions as I just wanted to make it work before doing any other things
)</p>

<p>Thanks in advance.</p>

<pre><code>    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;

/**
 * @author krish 2nd Aug, 2011
 */

    class DES {

final static int KEY_LENGTH = 8; // 8 byte key, 64 bits
final static int BLOCK_SIZE = 8; // 8 byte blocks, 64 bits
final static int NUM_ROUNDS = 16; // 16 rounds per block

// =======================================================================
// FOR KEY TRANSFORMATION
int[] compressionPermutation = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21,
        10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47,
        55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36,
        29, 32 };

// int[] keyShiftValue = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };
// ---
// don't need this
// =======================================================================

public static void main(String[] args) {

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    System.out.println(""Enter an 8 char key: "");
    String inputKey, inputMsg;
    char[] inputArray;
    byte[] key64 = new byte[8];
    byte[] key56 = new byte[7];
    int counter;

    try {
        // get key, key length() &gt;= 8 chars

        // inputKey = br.readLine();// uncomment later!!$$$$$$$
        inputKey = ""abcdefgh"";
        System.out.println(inputKey);
        if (inputKey.length() &lt; 8) {
            System.out.println(""Key &lt; 8 B. Exiting. . ."");
            System.exit(1);
        }
        // java char has 16 bits instead of 8 bits as in C,
        // so convert it to 8 bit char by getting lower order byte &amp;
        // discarding higher order byte; &amp;
        // consider only first 8 chars even if input &gt; 8
        inputArray = inputKey.toCharArray();
        for (counter = 0; counter &lt; 8; counter++)
            key64[counter] = (byte) inputArray[counter];

        // converting 64bit key to 56 bit key
        for (counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
            key64[counter] = (byte) (key64[counter] &gt;&gt;&gt; 1);
            key64[counter] = (byte) (key64[counter] &lt;&lt; 1);
        }
        for (counter = 0; counter &lt; KEY_LENGTH - 1; counter++) {
            key56[counter] = (byte) (key64[counter] &lt;&lt; counter);
            key56[counter] = (byte) (key56[counter] | (key64[counter + 1] &gt;&gt;&gt; (KEY_LENGTH - 1 - counter)));
        }
        /*
         * Conversion from 64 to 56 bit testing code
         * 
         * System.out.println(""64 to 56 test:""); System.out.println(new
         * String(key56)); System.out.println(); for (int counter1 = 0;
         * counter1 &lt; 7; counter1++) { for (int counter2 = 7; counter2 &gt;= 0;
         * counter2--) { System.out.println(key56[counter1] &amp; (1 &lt;&lt;
         * counter2)); } System.out.println(); }
         */

        // end of obtaining 56bit key

        // KEY GENERATION PHASE
        // DS USED - compressionPermutation

        byte[] leftKey28 = new byte[4];
        byte[] rightKey28 = new byte[4];
        byte circularBit;
        byte[][] newKey56 = new byte[16][7];

        // new 56 bit key for the first round, then loop for other rounds
        leftKey28[0] = key56[0];
        leftKey28[1] = key56[1];
        leftKey28[2] = key56[2];
        leftKey28[3] = (byte) (key56[3] &amp; 11110000);

        // rightKey28[0] = (byte) (key56[3] &amp; 00001111);
        // prob here, doesnt work as given above??
        rightKey28[0] = (byte) (key56[3] - leftKey28[3]);
        rightKey28[1] = key56[4];
        rightKey28[2] = key56[5];
        rightKey28[3] = key56[6];

        /*
         * // printing starts here System.out.print(""1 Byte # 0"" + ""     "");
         * for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
         * System.out.print(leftKey28[0] &amp; (1 &lt;&lt; counter2));
         * System.out.print("", ""); } System.out.println(); // printing ends
         * here
         */

        circularBit = (byte) (leftKey28[0] &amp; (1 &lt;&lt; 7));

        leftKey28[0] = (byte) (leftKey28[0] &lt;&lt; 1);
        leftKey28[0] = (byte) (leftKey28[0] | ((((int) leftKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[1] = (byte) (leftKey28[1] &lt;&lt; 1);
        leftKey28[1] = (byte) (leftKey28[1] | ((((int) leftKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[2] = (byte) (leftKey28[2] &lt;&lt; 1);
        leftKey28[2] = (byte) (leftKey28[2] | ((((int) leftKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

        leftKey28[3] = (byte) (leftKey28[3] &lt;&lt; 1);
        leftKey28[3] = (byte) (leftKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3));

        circularBit = (byte) (rightKey28[0] &amp; (1 &lt;&lt; 3));
        circularBit &lt;&lt;= 4;

        rightKey28[0] = (byte) (rightKey28[0] &lt;&lt; 1);
        rightKey28[0] = (byte) (rightKey28[0] | ((((int) rightKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[1] = (byte) (rightKey28[1] &lt;&lt; 1);
        rightKey28[1] = (byte) (rightKey28[1] | ((((int) rightKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[2] = (byte) (rightKey28[2] &lt;&lt; 1);
        rightKey28[2] = (byte) (rightKey28[2] | ((((int) rightKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

        rightKey28[3] = (byte) (rightKey28[3] &lt;&lt; 1);
        rightKey28[3] = (byte) (rightKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3));

        newKey56[0][0] = leftKey28[0];
        newKey56[0][1] = leftKey28[1];
        newKey56[0][2] = leftKey28[2];
        newKey56[0][3] = (byte) (leftKey28[3] | rightKey28[0]);
        newKey56[0][4] = rightKey28[1];
        newKey56[0][5] = rightKey28[2];
        newKey56[0][6] = rightKey28[3];
        // we have a new left circular shifted key in newKey56

        // done testing for newkey56[0] // left and right testing code
        for (int counter1 = 0; counter1 &lt; 7; counter1++) {
            System.out.print(""Round#0 Byte#"" + counter1 + ""  "");
            for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
                if (counter2 == 3)
                    System.out.print(""   "");
                if ((newKey56[0][counter1] &amp; (1 &lt;&lt; counter2)) &gt; 0) {
                    System.out.print(""1"");
                } else {
                    System.out.print(""0"");
                }
            }
            System.out.println();
        }
        // left and right testing code ends here

        // for round 1 to 15: left circular shift each 28 bit block by 1{
        for (int round = 1; round &lt; NUM_ROUNDS; round++) {
            // for the first round, then loop for other rounds
            leftKey28[0] = newKey56[round - 1][0];
            leftKey28[1] = newKey56[round - 1][1];
            leftKey28[2] = newKey56[round - 1][2];
            leftKey28[3] = (byte) (newKey56[round - 1][3] &amp; 11110000);

            // rightKey28[0] = (byte) (newKey56[round - 1][3] &amp; 00001111);
            rightKey28[0] = (byte) (newKey56[round - 1][3] - leftKey28[3]);
            rightKey28[1] = newKey56[round - 1][4];
            rightKey28[2] = newKey56[round - 1][5];
            rightKey28[3] = newKey56[round - 1][6];

            // if (round == 1 || round == 8 || round == 15) {
            // left circular shift by 1
            circularBit = (byte) (leftKey28[0] &amp; (1 &lt;&lt; 7));

            leftKey28[0] &lt;&lt;= 1;
            leftKey28[0] |= ((((int) leftKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7);

            leftKey28[1] &lt;&lt;= 1;
            leftKey28[1] |= ((((int) leftKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7);

            // ////////////////////////error here ////////////////////////////
            leftKey28[2] &lt;&lt;= 1;
            leftKey28[2] |= ((((int) leftKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7);
            // ////////////////////////error here //////////////////////////

            leftKey28[3] &lt;&lt;= 1;
            leftKey28[3] |= ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 3);

            circularBit = (byte) (rightKey28[0] &amp; (1 &lt;&lt; 3));
            circularBit &lt;&lt;= 4;

            // //////////////////////////////////////////////////
            rightKey28[0] = (byte) (rightKey28[0] &lt;&lt; 1);
            rightKey28[0] &amp;= 00001111;
            rightKey28[0] = (byte) (rightKey28[0] | ((((int) rightKey28[1]) &amp; 0xff) &gt;&gt;&gt; 7));
            // //////////////////////////////////////////////////

            rightKey28[1] = (byte) (rightKey28[1] &lt;&lt; 1);
            rightKey28[1] = (byte) (rightKey28[1] | ((((int) rightKey28[2]) &amp; 0xff) &gt;&gt;&gt; 7));

            rightKey28[2] = (byte) (rightKey28[2] &lt;&lt; 1);
            rightKey28[2] = (byte) (rightKey28[2] | ((((int) rightKey28[3]) &amp; 0xff) &gt;&gt;&gt; 7));

            rightKey28[3] = (byte) (rightKey28[3] &lt;&lt; 1);
            rightKey28[3] = (byte) (rightKey28[3] | ((((int) circularBit) &amp; 0xff) &gt;&gt;&gt; 7));
            // } else {
            // // left circular shift by 2
            // }

            newKey56[round][0] = leftKey28[0];
            newKey56[round][1] = leftKey28[1];
            newKey56[round][2] = leftKey28[2];
            newKey56[round][3] = (byte) (leftKey28[3] | rightKey28[0]);
            newKey56[round][4] = rightKey28[1];
            newKey56[round][5] = rightKey28[2];
            newKey56[round][6] = rightKey28[3];

            // testing code for all keys for rounds 1 to 15
            System.out.println();
            for (int counter1 = 0; counter1 &lt; 7; counter1++) {
                System.out.print(""Round#"" + round + ""  Byte#"" + counter1
                        + ""  "");
                for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
                    if (counter2 == 3)
                        System.out.print(""   "");
                    if ((newKey56[round][counter1] &amp; (1 &lt;&lt; counter2)) &gt; 0) {
                        System.out.print(""1"");
                    } else {
                        System.out.print(""0"");
                    }

                }
                System.out.println();
            }
            if (round == 2)
                break;
            // testing code ends

        }// for loop ends

        /*
         * // newKey56 testing code
         * System.out.println(""new56key testing here""); for (counter = 0;
         * counter &lt; NUM_ROUNDS; counter++) { System.out.println(new
         * String(newKey56[counter])); System.out.println();
         * 
         * for (int counter1 = 0; counter1 &lt; 7; counter1++) {
         * System.out.print(""Round # "" + counter + "" Byte # "" + counter1 +
         * ""     ""); for (int counter2 = 7; counter2 &gt;= 0; counter2--) {
         * System.out.print(newKey56[counter][counter1] &amp; (1 &lt;&lt; counter2));
         * System.out.print("", ""); } System.out.println(); } }
         */

        // DO KEY COMPRESSION ROUTINE HERE

    } catch (Exception e) {
        e.printStackTrace();
    }
}
    }

    Enter an 8 char key: 
    abcdefgh
    Round#0 Byte#0  1100   0001
    Round#0 Byte#1  1000   1011
    Round#0 Byte#2  0001   0110
    Round#0 Byte#3  0100   1100
    Round#0 Byte#4  1001   1001
    Round#0 Byte#5  1011   0011
    Round#0 Byte#6  0110   1000

    Round#1  Byte#0  1000   0011
    Round#1  Byte#1  0001   0110
    Round#1  Byte#2  0010   1100
    Round#1  Byte#3  1001   1001
    Round#1  Byte#4  0011   0011
    Round#1  Byte#5  0110   0110
    Round#1  Byte#6  1101   0001

    Round#2  Byte#0  0000   0110
    Round#2  Byte#1  0010   1100
    Round#2  Byte#2  0101   1000 //error here =&gt; 0101 1001
    Round#2  Byte#3  0011   0000 //error here =&gt; 0011 0010
    Round#2  Byte#4  0110   0110
    Round#2  Byte#5  1100   1101
    Round#2  Byte#6  1010   0011
</code></pre>
","<p>Here's my DES code (incomplete in C).
Well, I tried Java for 2 weeks, and was having trouble with using long for ints, ints for bytes and shorts, etc (for bit manipulation/bit-shifting).
Then, gave up on Java and did this in C. It is the encryption code only.
Hope it helps someone in the future. Let me know if I am incorrect anywhere.
Thanks to all you guys for the help.</p>

<pre><code>/*
 * des.c
 *  Created on: 2-Aug-2011
 *  Author: krish
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define KEY_LENGTH 8 // 8 char key, 64 bits
#define BLOCK_SIZE 8 // 8 char blocks, 64 bits
#define NUM_ROUNDS 16 // 16 uintRounds per block
// =======================================================================
// S-BOXES
int gSBox_1 = { { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7 },
                { 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8 },
                { 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0 },
                { 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 }
            }; //gSBox_1[8][8]

int getSBoxValue(int sbox,char position)
{
}
/*
 int sbox_2[] = { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3,
 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11,
 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2,
 11, 6, 7, 12, 0, 5, 14, 9, };

 int sbox_3[] = { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13,
 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8,
 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4,
 15, 14, 3, 11, 5, 2, 12, };

 int sbox_4[] = { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13,
 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12,
 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9,
 4, 5, 11, 12, 7, 2, 14, };

 int sbox_5[] = { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14,
 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10,
 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6,
 15, 0, 9, 10, 4, 5, 3, };

 int sbox_6[] = { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10,
 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2,
 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11,
 14, 1, 7, 6, 0, 8, 13, };

 int sbox_7[] = { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13,
 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12,
 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9,
 5, 0, 15, 14, 2, 3, 12, };

 int sbox_8[] = { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1,
 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9,
 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13,
 15, 12, 9, 0, 3, 5, 6, 11 };

 // =======================================================================
 */

void getKey(char *key64) {
    int returnValue = 0;
    printf(""\nEnter an 8 char key: "");
    returnValue = scanf(""%[a-zA-Z0-9]s"", key64);
    if (!returnValue) {
        printf(""\nError in scanf enintCountered.. Exiting...\n"");
        exit(1);
    }

    // key length() &gt;= 8 chars
    printf(""\nInput key: %s\n"", key64);
    if (strlen(key64) != 8) {
        printf(""Key &lt;&gt; 8 bytes. Exiting. . ."");
        exit(3);
    }
}

void getMessage(char *inputMsg) {
    int returnValue = 0;
    printf(""\nEnter a message: "");
    returnValue = scanf("" %[A-Za-z0-9. ]s"", inputMsg);
    if (!returnValue) {
        printf(""\nError in scanf enintCountered.. Exiting...\n"");
        exit(2);
    }
}

void compressKey(char *key64, char *key56) {
    int intCounter;
    // conversion -64bit key to 56 bit key - starts here
    for (intCounter = 0; intCounter &lt; KEY_LENGTH; intCounter++) {
        key64[intCounter] &gt;&gt;= 1;
        key64[intCounter] &lt;&lt;= 1;
    }
    for (intCounter = 0; intCounter &lt; KEY_LENGTH - 1; intCounter++) {
        key56[intCounter] = key64[intCounter] &lt;&lt; intCounter;
        key56[intCounter] = key56[intCounter] | ((key64[intCounter + 1]
                &gt;&gt; (KEY_LENGTH - 1 - intCounter)));
    }
    // conversion -64bit key to 56 bit key - ends here
}

char expandPlainText(unsigned uintCurrBits, unsigned uintPrevBit,
        unsigned uintNextBit) {
    char resultPtr;
    //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
    resultPtr = (char) (uintCurrBits &amp; 0xff);
    resultPtr |= (uintPrevBit &lt;&lt; 4);
    resultPtr &lt;&lt;= 1;
    resultPtr |= (uintNextBit);

    //printf(""'%d'"", resultPtr);
    return resultPtr;
}

int main(int argc, char** argv) {
    // =======================================================================
    // FOR KEY TRANSFORMATION
    int compressionPermutation[] = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21,
            10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47,
            55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36,
            29, 32 };

    //int keyShiftValue[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };---don't need this
    // =======================================================================

    // =======================================================================
    // FOR PLAINTEXT TRANSFORMATION
    int
            initialPermutation[] = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44,
                    36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56,
                    48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59,
                    51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5,
                    63, 55, 47, 39, 31, 23, 15, 7 };

    /*int
     finalPermutation[] = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47,
     15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5,
     45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35,
     3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26,
     33, 1, 41, 9, 49, 17, 57, 25 };

     int permutationFunction[] = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26,
     5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11,
     4, 25 };

     int expansionPermutation[] = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9,
     10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20,
     21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };
     // ---
     // don't need this
     */
    // =======================================================================


    char *key64 = (char *) calloc(9, sizeof(char)); //stores user input key
    char *key56 = (char *) calloc(8, sizeof(char)); //56 bit key

    char newKey56[16][7]; //used for key transformation
    char compressedKey[16][6]; //stores compressed keys
    char leftKey28[4], rightKey28[4];
    unsigned int uintLeftTemp, uintRightTemp, uintCircularBit;

    char *inputMsg = (char *) calloc(BLOCK_SIZE * 10, sizeof(char));
    char *permutedPlaintextBlock =
            (char *) calloc(BLOCK_SIZE + 1, sizeof(char)); //to store permuted plaintetx
    char *plaintextBlock = (char *) calloc(BLOCK_SIZE + 1, sizeof(char)); // to store 1 block of plaintext
    char expandedRightPlaintext[8];
    //char expandedLeftPlaintext[8];// = (char *) calloc(BLOCK_SIZE + 1, sizeof(char));
    char expandedPlaintext[6], XORedText[6], sboxText[8], encryptedText[4];

    unsigned int uintCurrBits, uintPrevBit, uintNextBit;

    int intCounter, intCounter1, intCounter2; //keep this signed!!!$$$$$$$$$$$$$
    unsigned int uintNumBlocks, uintTempInteger, uintRound, uintPaddingSpaces;

    getKey(key64);
    getMessage(inputMsg);

    //printing test code starts here
    printf(""\nInput key in binary:\n"");
    for (intCounter = 0; intCounter &lt; 8; intCounter++) {
        for (intCounter1 = 7; intCounter1 &gt;= 0; intCounter1--) {
            if ((key64[intCounter] &amp; (1 &lt;&lt; intCounter1)) &gt; 0)
                printf(""1"");
            else
                printf(""0"");
        }
        printf("" "");
    }
    printf(""\n"");
    //printing test code ends here

    compressKey(key64, key56);

    //printing test code starts here
    printf(""\n64 to 56 bit key:\n"");
    for (intCounter = 0; intCounter &lt; 7; intCounter++) {
        for (intCounter1 = 7; intCounter1 &gt;= 0; intCounter1--) {
            if ((key56[intCounter] &amp; (1 &lt;&lt; intCounter1)) &gt; 0)
                printf(""1"");
            else
                printf(""0"");
        }
        printf("" "");
    }
    printf(""\n"");
    //printing test code ends here

    ////////////////////////////////
    // KEY TRANSFORMATION PHASE
    ////////////////////////////////


    // new 56 bit key for the first uintRound, then loop for other uintRounds


    leftKey28[0] = key56[0];
    leftKey28[1] = key56[1];
    leftKey28[2] = key56[2];
    leftKey28[3] = key56[3] &amp; 0xf0;

    rightKey28[0] = key56[3] &amp; 0x0f;
    rightKey28[1] = key56[4];
    rightKey28[2] = key56[5];
    rightKey28[3] = key56[6];

    uintLeftTemp = 0;
    uintLeftTemp = uintLeftTemp | ((((int) leftKey28[0]) &amp; 0xff) &lt;&lt; 24);
    uintLeftTemp = uintLeftTemp | ((((int) leftKey28[1]) &amp; 0xff) &lt;&lt; 16);
    uintLeftTemp = uintLeftTemp | ((((int) leftKey28[2]) &amp; 0xff) &lt;&lt; 8);
    uintLeftTemp = uintLeftTemp | ((((int) leftKey28[3]) &amp; 0xff) &lt;&lt; 0);

    uintRightTemp = 0;
    uintRightTemp = uintRightTemp | ((((int) rightKey28[0]) &amp; 0xff) &lt;&lt; 24);
    uintRightTemp = uintRightTemp | ((((int) rightKey28[1]) &amp; 0xff) &lt;&lt; 16);
    uintRightTemp = uintRightTemp | ((((int) rightKey28[2]) &amp; 0xff) &lt;&lt; 8);
    uintRightTemp = uintRightTemp | ((((int) rightKey28[3]) &amp; 0xff) &lt;&lt; 0);

    uintCircularBit = uintLeftTemp &amp; (1 &lt;&lt; 31);
    uintCircularBit = uintCircularBit &gt;&gt; 31;

    uintLeftTemp &lt;&lt;= 1;
    uintLeftTemp |= (uintCircularBit &lt;&lt; 4);

    uintCircularBit = uintRightTemp &amp; (1 &lt;&lt; 27);
    uintCircularBit &gt;&gt;= 27;

    uintRightTemp &lt;&lt;= 1;
    uintRightTemp = uintRightTemp &amp; 0x0fffffff;
    uintRightTemp |= (uintCircularBit);

    //convert uintLeftTemp to leftKey28 again
    leftKey28[0] = uintLeftTemp &gt;&gt; 24;
    leftKey28[1] = uintLeftTemp &gt;&gt; 16;
    leftKey28[2] = uintLeftTemp &gt;&gt; 8;
    leftKey28[3] = uintLeftTemp &gt;&gt; 0;

    rightKey28[0] = uintRightTemp &gt;&gt; 24;
    rightKey28[1] = uintRightTemp &gt;&gt; 16;
    rightKey28[2] = uintRightTemp &gt;&gt; 8;
    rightKey28[3] = uintRightTemp &gt;&gt; 0;

    newKey56[0][0] = leftKey28[0];
    newKey56[0][1] = leftKey28[1];
    newKey56[0][2] = leftKey28[2];
    newKey56[0][3] = leftKey28[3] | rightKey28[0];
    newKey56[0][4] = rightKey28[1];
    newKey56[0][5] = rightKey28[2];
    newKey56[0][6] = rightKey28[3];

    // have a new left circular shifted key in newKey56[0]
    //*******************

    //printing test code starts here
    printf(""\nnewKey56[0] key: "");
    for (intCounter = 0; intCounter &lt; 7; intCounter++) {
        for (intCounter1 = 7; intCounter1 &gt;= 0; intCounter1--) {
            if ((newKey56[0][intCounter] &amp; (1 &lt;&lt; intCounter1)) &gt; 0)
                printf(""1"");
            else
                printf(""0"");
        }
        printf("" "");
    }
    //printing test code ends here

    // for uintRound 1 to 15: left circular shift each 28 bit block by 1{
    for (uintRound = 1; uintRound &lt; NUM_ROUNDS; uintRound++) {
        leftKey28[0] = newKey56[uintRound - 1][0];
        leftKey28[1] = newKey56[uintRound - 1][1];
        leftKey28[2] = newKey56[uintRound - 1][2];
        leftKey28[3] = newKey56[uintRound - 1][3] &amp; 0xf0;
        rightKey28[0] = newKey56[uintRound - 1][3] &amp; 0x0f;
        rightKey28[1] = newKey56[uintRound - 1][4];
        rightKey28[2] = newKey56[uintRound - 1][5];
        rightKey28[3] = newKey56[uintRound - 1][6];

        uintLeftTemp = 0;
        uintLeftTemp = uintLeftTemp | ((((int) leftKey28[0]) &amp; 0xff) &lt;&lt; 24);
        uintLeftTemp = uintLeftTemp | ((((int) leftKey28[1]) &amp; 0xff) &lt;&lt; 16);
        uintLeftTemp = uintLeftTemp | ((((int) leftKey28[2]) &amp; 0xff) &lt;&lt; 8);
        uintLeftTemp = uintLeftTemp | ((((int) leftKey28[3]) &amp; 0xff) &lt;&lt; 0);

        uintRightTemp = 0;
        uintRightTemp = uintRightTemp | ((((int) rightKey28[0]) &amp; 0xff) &lt;&lt; 24);
        uintRightTemp = uintRightTemp | ((((int) rightKey28[1]) &amp; 0xff) &lt;&lt; 16);
        uintRightTemp = uintRightTemp | ((((int) rightKey28[2]) &amp; 0xff) &lt;&lt; 8);
        uintRightTemp = uintRightTemp | ((((int) rightKey28[3]) &amp; 0xff) &lt;&lt; 0);

        if (uintRound == 1 || uintRound == 8 || uintRound == 15) {
            //left circular shift by 1
            uintCircularBit = uintLeftTemp &amp; (1 &lt;&lt; 31);
            uintCircularBit = uintCircularBit &gt;&gt; 31;

            uintLeftTemp &lt;&lt;= 1;
            uintLeftTemp |= (uintCircularBit &lt;&lt; 4);

            uintCircularBit = uintRightTemp &amp; (1 &lt;&lt; 27);
            uintCircularBit &gt;&gt;= 27;

            uintRightTemp &lt;&lt;= 1;
            uintRightTemp = uintRightTemp &amp; 0x0fffffff;
            uintRightTemp |= (uintCircularBit);
        } else {
            //left circular shift by 2
            uintCircularBit = 0;
            uintCircularBit = uintLeftTemp &amp; (11 &lt;&lt; 30);

            uintCircularBit = uintCircularBit &gt;&gt; 30;

            uintLeftTemp &lt;&lt;= 2;
            uintLeftTemp |= uintCircularBit &lt;&lt; 4;

            uintCircularBit = 0;
            uintCircularBit = uintRightTemp &amp; (11 &lt;&lt; 26);
            uintCircularBit &gt;&gt;= 26;

            uintRightTemp &lt;&lt;= 2;
            uintRightTemp = uintRightTemp &amp; 0x0fffffff;
            uintRightTemp |= (uintCircularBit);
        }

        //convert uintLeftTemp to leftKey28 again
        leftKey28[0] = uintLeftTemp &gt;&gt; 24;
        leftKey28[1] = uintLeftTemp &gt;&gt; 16;
        leftKey28[2] = uintLeftTemp &gt;&gt; 8;
        leftKey28[3] = uintLeftTemp &gt;&gt; 0;

        rightKey28[0] = uintRightTemp &gt;&gt; 24;
        rightKey28[1] = uintRightTemp &gt;&gt; 16;
        rightKey28[2] = uintRightTemp &gt;&gt; 8;
        rightKey28[3] = uintRightTemp &gt;&gt; 0;

        newKey56[uintRound][0] = leftKey28[0];
        newKey56[uintRound][1] = leftKey28[1];
        newKey56[uintRound][2] = leftKey28[2];
        newKey56[uintRound][3] = leftKey28[3] | rightKey28[0];
        newKey56[uintRound][4] = rightKey28[1];
        newKey56[uintRound][5] = rightKey28[2];
        newKey56[uintRound][6] = rightKey28[3];

        //printing test code starts here
        printf(""\nnewKey56[%d]: "", uintRound);
        for (intCounter = 0; intCounter &lt; 7; intCounter++) {
            for (intCounter1 = 7; intCounter1 &gt;= 0; intCounter1--) {
                if ((newKey56[uintRound][intCounter] &amp; (1 &lt;&lt; intCounter1)) &gt; 0)
                    printf(""1"");
                else
                    printf(""0"");
            }
            printf("" "");
        }
        //printing test code ends here
    }// for loop ends

    ////////////////////////////////
    // KEY COMPRESSION PHASE
    ////////////////////////////////

    for (uintRound = 0; uintRound &lt; NUM_ROUNDS; uintRound++) {
        for (intCounter = 0; intCounter &lt; 48; intCounter++) {
            uintTempInteger = 0;
            uintTempInteger
                    = ((int) (newKey56[uintRound][(compressionPermutation[intCounter]
                            - 1) / 8])) &amp; (1 &lt;&lt; (7
                            - ((compressionPermutation[intCounter] - 1) % 8)));

            // test code for printing temp value - starts here
            if (uintTempInteger &gt; 0) {
                compressedKey[uintRound][intCounter / 8] |= (1 &lt;&lt; (7
                        - (intCounter % 8)));
            }
        }
    }

    //printing test code starts here
    for (intCounter1 = 0; intCounter1 &lt; NUM_ROUNDS; intCounter1++) {
        printf(""\ncompressedKey[%d]:  "", intCounter1);
        for (intCounter = 0; intCounter &lt; 6; intCounter++) {
            for (intCounter2 = 7; intCounter2 &gt;= 0; intCounter2--) {
                if ((compressedKey[intCounter1][intCounter]
                        &amp; (1 &lt;&lt; intCounter2)) &gt; 0)
                    printf(""1"");
                else
                    printf(""0"");
            }
            printf("" "");
        }
    }
    //printing test code ends here*/
    // KEY COMPRESSION DONE

    //////////////////////////
    // WORKING WITH PLAINTEXT
    //////////////////////////

    printf(""\n'%s'\n"", inputMsg);
    // if input length not a multiple of BLOCK_SIZE, pad it with spaces(ascii:32)
    if (strlen(inputMsg) % BLOCK_SIZE != 0) {
        uintPaddingSpaces = BLOCK_SIZE - (strlen(inputMsg) % BLOCK_SIZE);
        for (intCounter = 0; intCounter &lt; uintPaddingSpaces; intCounter++)
            strcat(inputMsg, "" "");
    }
    uintNumBlocks = strlen(inputMsg) / 8;
    printf(""\n'%s'\n'%d'\n"", inputMsg, uintNumBlocks);

    //intCounter1, intCounter2, uintRound;
    for (intCounter = 0; intCounter &lt; uintNumBlocks; intCounter++) {

        for (intCounter1 = 0; intCounter1 &lt; BLOCK_SIZE; intCounter1++) {
            plaintextBlock[intCounter1] = inputMsg[intCounter * BLOCK_SIZE
                    + intCounter1];
        }
        printf(""'%s'"", plaintextBlock);

        ////////////////////////////////
        // INITIAL PERMUTATION FOR EACH BLOCK
        ////////////////////////////////

        for (uintRound = 0; uintRound &lt; NUM_ROUNDS; uintRound++) {
            for (intCounter1 = 0; intCounter1 &lt; 64; intCounter1++) {
                uintTempInteger = 0;
                uintTempInteger
                        = (((int) (plaintextBlock[(initialPermutation[intCounter1]
                                - 1) / 8])) &amp; 0xff) &amp; (1 &lt;&lt; (7
                                - ((initialPermutation[intCounter1] - 1) % 8)));

                // test code for printing temp value - starts here
                if (uintTempInteger &gt; 0) {
                    permutedPlaintextBlock[intCounter1 / 8] |= (1 &lt;&lt; (7
                            - (intCounter1 % 8)));
                }
            }
            //printing test code starts here
            printf(""\nBlock # %d uintRound # %d: "", intCounter, uintRound);
            for (uintTempInteger = 0; uintTempInteger &lt; BLOCK_SIZE; uintTempInteger++) {
                for (intCounter2 = 7; intCounter2 &gt;= 0; intCounter2--) {
                    if ((permutedPlaintextBlock[uintTempInteger] &amp; (1
                            &lt;&lt; intCounter2)) &gt; 0)
                        printf(""1"");
                    else
                        printf(""0"");
                }
                printf("" "");
            }
            //printing test code ends here

            /* IP DONE
             * After IP, divide into leftPT and rightPT - 32 bits each
             * do expansion permutation
             * then do the 16 rounds
             */

            uintLeftTemp = 0;

            uintLeftTemp = uintLeftTemp
                    | ((((unsigned int) permutedPlaintextBlock[0]) &amp; 0xff)
                            &lt;&lt; 24);
            uintLeftTemp = uintLeftTemp
                    | ((((unsigned int) permutedPlaintextBlock[1]) &amp; 0xff)
                            &lt;&lt; 16);
            uintLeftTemp
                    = uintLeftTemp
                            | ((((unsigned int) permutedPlaintextBlock[2])
                                    &amp; 0xff) &lt;&lt; 8);
            uintLeftTemp
                    = uintLeftTemp
                            | ((((unsigned int) permutedPlaintextBlock[3])
                                    &amp; 0xff) &lt;&lt; 0);

            //printing test code starts here
            printf(""\nuintLeftTemp: "");
            for (uintTempInteger = 32; uintTempInteger &gt; 0; uintTempInteger--) {

                if ((uintTempInteger) % 8 == 0)
                    printf("" "");
                if ((uintLeftTemp &amp; (1 &lt;&lt; (uintTempInteger - 1))) &gt; 0)
                    printf(""1"");
                else
                    printf(""0"");

            }
            //printing test code ends here


            uintRightTemp = 0;
            uintRightTemp = uintRightTemp
                    | ((((unsigned int) permutedPlaintextBlock[4]) &amp; 0xff)
                            &lt;&lt; 24);
            uintRightTemp = uintRightTemp
                    | ((((unsigned int) permutedPlaintextBlock[5]) &amp; 0xff)
                            &lt;&lt; 16);
            uintRightTemp
                    = uintRightTemp
                            | ((((unsigned int) permutedPlaintextBlock[6])
                                    &amp; 0xff) &lt;&lt; 8);
            uintRightTemp
                    = uintRightTemp
                            | ((((unsigned int) permutedPlaintextBlock[7])
                                    &amp; 0xff) &lt;&lt; 0);

            //printing test code starts here
            printf(""\nuintRightTemp: "");
            for (uintTempInteger = 32; uintTempInteger &gt; 0; uintTempInteger--) {
                if ((uintTempInteger) % 8 == 0)
                    printf("" "");
                if ((uintRightTemp &amp; (1 &lt;&lt; (uintTempInteger - 1))) &gt; 0)
                    printf(""1"");
                else
                    printf(""0"");
            }
            //printing test code ends here

            //done getting LPT &amp; RPT
            /*
             * 32 bit RPT divided into 8 blks of 4 bits each
             * 4 bit block converted into 6 bit block by adding prev blks'
             * last bit and next blks' first bit
             */

            //for block 0
            uintCurrBits = (uintRightTemp &gt;&gt; 28) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 27) &amp; 0x01;
            uintPrevBit = (uintRightTemp &gt;&gt; 0) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[0] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[0]: '%d'"",expandedRightPlaintext[0]);

            //for block 1
            uintCurrBits = (uintRightTemp &gt;&gt; 24) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 23) &amp; 0x01;
            uintPrevBit = (uintRightTemp &gt;&gt; 28) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[1] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[1]: '%d'"",expandedRightPlaintext[1]);

            //for block 2
            uintCurrBits = (uintRightTemp &gt;&gt; 20) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 19) &amp; 0x01;
            uintPrevBit = (uintRightTemp &gt;&gt; 24) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[2] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[2]: '%d'"",expandedRightPlaintext[2]);

            //for block 3
            uintCurrBits = (uintRightTemp &gt;&gt; 16) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 15) &amp; 0x01;
            uintPrevBit = (uintRightTemp &gt;&gt; 20) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[3] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[3]: '%d'"",expandedRightPlaintext[3]);

            //for block 4
            uintCurrBits = (uintRightTemp &gt;&gt; 12) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 11) &amp; 0x01;
            uintPrevBit = (uintRightTemp &gt;&gt; 16) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[4] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[4]: '%d'"",expandedRightPlaintext[4]);

            //for block 5
            uintCurrBits = (uintRightTemp &gt;&gt; 8) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 7) &amp; 0x01;
            uintPrevBit = (uintRightTemp &gt;&gt; 12) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[5] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[5]: '%d'"",expandedRightPlaintext[5]);

            //for block 6
            uintCurrBits = (uintRightTemp &gt;&gt; 4) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 3) &amp; 0x01;
            uintPrevBit = (uintRightTemp &gt;&gt; 8) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[6] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[6]: '%d'"",expandedRightPlaintext[6]);

            //for block 7
            uintCurrBits = (uintRightTemp &gt;&gt; 0) &amp; 0x0f;
            uintNextBit = (uintRightTemp &gt;&gt; 31) &amp; 0x01;//********
            uintPrevBit = (uintRightTemp &gt;&gt; 4) &amp; 0x01;
            //printf(""\n%d %d %d\n"", uintCurrBits, uintNextBit, uintPrevBit);
            expandedRightPlaintext[7] = expandPlainText(uintCurrBits,
                    uintPrevBit, uintNextBit);
            //printf(""\nexpandedRightPlaintext[7]: '%d'"",expandedRightPlaintext[7]);

            //combine expandedRightPlaintext[0..7] to get a 48 bit RPT
            //XOR with 48bit compressedKey and give result to SBox
            //char compressedKey[16][6]; //stores compressed keys

            //printing test code starts here
            printf(""\nexpandedRightPlaintext: "");
            for (uintTempInteger = 0; uintTempInteger &lt; BLOCK_SIZE; uintTempInteger++) {
                for (intCounter2 = 7; intCounter2 &gt;= 0; intCounter2--) {
                    if ((expandedRightPlaintext[uintTempInteger] &amp; (1
                            &lt;&lt; intCounter2)) &gt; 0)
                        printf(""1"");
                    else
                        printf(""0"");
                }
                printf("" "");
            }
            //printing test code ends here

            // conversion - 64 bit key to 48 bit RPT - starts here
            for (uintTempInteger = 0; uintTempInteger &lt; BLOCK_SIZE; uintTempInteger++)
                expandedRightPlaintext[uintTempInteger] &lt;&lt;= 2;

            expandedPlaintext[0] = (expandedRightPlaintext[0] &lt;&lt; 0)
                    | (expandedRightPlaintext[1] &gt;&gt; 6);

            expandedPlaintext[1] = (expandedRightPlaintext[1] &lt;&lt; 2)
                    | (expandedRightPlaintext[2] &gt;&gt; 4);

            expandedPlaintext[2] = (expandedRightPlaintext[2] &lt;&lt; 4)
                    | (expandedRightPlaintext[3] &gt;&gt; 2);

            expandedPlaintext[3] = (expandedRightPlaintext[4] &lt;&lt; 0)
                    | (expandedRightPlaintext[5] &gt;&gt; 6);

            expandedPlaintext[4] = (expandedRightPlaintext[5] &lt;&lt; 2)
                    | (expandedRightPlaintext[6] &gt;&gt; 4);

            expandedPlaintext[5] = (expandedRightPlaintext[6] &lt;&lt; 4)
                    | (expandedRightPlaintext[7] &gt;&gt; 2);

            // conversion - 64 bit key to 48 bit RPT - ends here
            //we have a 48 bit plaintext in expandedPlaintext and a 48 bit key in compressedKey

            //printing test code starts here
            printf(""\nexpandedPlaintext: "");
            for (uintTempInteger = 0; uintTempInteger &lt; 6; uintTempInteger++) {
                for (intCounter2 = 7; intCounter2 &gt;= 0; intCounter2--) {
                    if ((expandedPlaintext[uintTempInteger]
                            &amp; (1 &lt;&lt; intCounter2)) &gt; 0)
                        printf(""1"");
                    else
                        printf(""0"");
                }
                printf("" "");
            }
            //printing test code ends here

            /* 48 bit RPT XORed with 48 bit key, then Sbox sub
             * XORing here
             */
            for (uintTempInteger = 0; uintTempInteger &lt; 6; uintTempInteger++)
                XORedText[uintTempInteger] = expandedPlaintext[uintTempInteger]
                        ^ compressedKey[uintRound][uintTempInteger];
            //printing test code starts here
            printf(""\nXORedPlaintext: "");
            for (uintTempInteger = 0; uintTempInteger &lt; 6; uintTempInteger++) {
                for (intCounter2 = 7; intCounter2 &gt;= 0; intCounter2--) {
                    if ((XORedText[uintTempInteger] &amp; (1 &lt;&lt; intCounter2)) &gt; 0)
                        printf(""1"");
                    else
                        printf(""0"");
                }
                printf("" "");
            }
            //printing test code ends here

            // converting XORed text to blocks of 6 bits
            //XORedPlaintext: 110111 01 10101101 00001000  01011011 10111011 01000010
            sboxText[0] = (XORedText[0] &gt;&gt; 2) &amp; 0x3f;
            sboxText[1] = ((XORedText[0] &amp; 0x03) &lt;&lt; 4) | ((XORedText[1] &gt;&gt; 4)
                    &amp; 0x0f);
            sboxText[2] = ((XORedText[1] &amp; 0x0f) &lt;&lt; 2) | ((XORedText[2] &gt;&gt; 6)
                    &amp; 0x03);
            sboxText[3] = XORedText[2] &amp; 0x3f;
            sboxText[4] = (XORedText[3] &gt;&gt; 2) &amp; 0x3f;
            sboxText[5] = ((XORedText[3] &amp; 0x03) &lt;&lt; 4) | ((XORedText[4] &gt;&gt; 4)
                    &amp; 0x0f);
            sboxText[6] = ((XORedText[4] &amp; 0x0f) &lt;&lt; 2) | ((XORedText[5] &gt;&gt; 6)
                    &amp; 0x03);
            sboxText[7] = XORedText[5] &amp; 0x3f;

            //printing test code starts here
            printf(""\nsboxText: "");
            for (uintTempInteger = 0; uintTempInteger &lt; BLOCK_SIZE; uintTempInteger++) {
                for (intCounter2 = 7; intCounter2 &gt;= 0; intCounter2--) {
                    if ((sboxText[uintTempInteger] &amp; (1 &lt;&lt; intCounter2)) &gt; 0)
                        printf(""1"");
                    else
                        printf(""0"");
                }
                printf("" "");
            }
            //printing test code ends here

            //CORRECT TILL HERE
            for (uintTempInteger = 0; uintTempInteger &lt; 4; uintTempInteger++) {
                encryptedText[uintTempInteger]=getSBoxValue(gSBox_1,sboxText[uintTempInteger]);
                encryptedText[0]&lt;&lt;=4;
                encryptedText[uintTempInteger]=getSBoxValue(gSBox_1,sboxText[uintTempInteger+1]);
            }
            printf(""\nencrypt: %d"",encryptedText[0]);

            break;
        }
    }

    printf(""\n\nSAFE EXIT\n"");
    return EXIT_SUCCESS;
}

/*
 *
 * TEST ROUTINES HERE
 *
 * //printing test code starts here
 printf(""\nleftKey28:\n"");
 for(intCounter=0;intCounter&lt;4;intCounter++)
 {
 for(intCounter1=7;intCounter1&gt;=0;intCounter1--)
 {
 if((leftKey28[intCounter] &amp; (1 &lt;&lt; intCounter1)) &gt; 0)
 printf(""1"");
 else
 printf(""0"");
 }
 printf("" "");
 }
 printf(""\n"");
 //printing test code ends here*/

//printf(""%ld %ld %ld\n"", sizeof(int),sizeof(long int),sizeof(char));
//sizeof char = 8 bits
//sizeof int = 32 bits
//sizeof long = 64 bits

///
///
</code></pre>
","2060","<java><bit-manipulation><des>","2","1","3","2011-09-10 20:50:13","","4","","544963","","2011-08-12 20:22:31","2011-08-12 20:09:47",""
"26493253","DES decryption in Ruby","<p>The following is my java code for DES decryption:</p>

<pre><code>public static byte[] decrypt(final byte[] value, final String key) throws InvalidKeyException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, UnsupportedEncodingException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException {
    final DESKeySpec objDesKeySpec = new DESKeySpec(key.getBytes(""UTF-8""));
    final SecretKeyFactory objKeyFactory = SecretKeyFactory.getInstance(""DES"");
    final SecretKey objSecretKey = objKeyFactory.generateSecret(objDesKeySpec);
    final byte[] rgbIV = key.getBytes();
    final IvParameterSpec iv = new IvParameterSpec(rgbIV);
    final Cipher objCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    objCipher.init(2, objSecretKey, iv);
    return objCipher.doFinal(value);
}
</code></pre>

<p>And I try to convert it to Ruby code as the following:</p>

<pre><code>def decryption(key, decodeString)
    ALG = 'des'
    cipher = OpenSSL::Cipher::Cipher.new(ALG)
    cipher.decrypt  #choose descryption mode.
    cipher.key = key
    plain = cipher.update(decodeString )
    plain &lt;&lt; cipher.final
end
</code></pre>

<p>After executing the java and ruby code, I got the same size of bytes, but the contents of bytes are different. Where did I go wrong?</p>
","<p>Thanks for your question!</p>

<p>To do this, use the OpenSSL::Cipher library. Here is a link with some sample code for AES: <a href=""http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html#class-OpenSSL::Cipher-label-Encrypting+and+decrypting+some+data"" rel=""nofollow"">http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html#class-OpenSSL::Cipher-label-Encrypting+and+decrypting+some+data</a></p>

<p>To use DES, run this command to see if your Ruby installation supports DES.</p>

<pre><code>puts OpenSSL::Cipher.ciphers
</code></pre>
","2036","<ruby><encryption><des>","-3","2","2","2014-10-27 14:50:09","26493366","3","2","1476062","","2014-10-23 05:24:55","2014-10-21 18:02:52",""
"26493253","DES decryption in Ruby","<p>The following is my java code for DES decryption:</p>

<pre><code>public static byte[] decrypt(final byte[] value, final String key) throws InvalidKeyException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, UnsupportedEncodingException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException {
    final DESKeySpec objDesKeySpec = new DESKeySpec(key.getBytes(""UTF-8""));
    final SecretKeyFactory objKeyFactory = SecretKeyFactory.getInstance(""DES"");
    final SecretKey objSecretKey = objKeyFactory.generateSecret(objDesKeySpec);
    final byte[] rgbIV = key.getBytes();
    final IvParameterSpec iv = new IvParameterSpec(rgbIV);
    final Cipher objCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    objCipher.init(2, objSecretKey, iv);
    return objCipher.doFinal(value);
}
</code></pre>

<p>And I try to convert it to Ruby code as the following:</p>

<pre><code>def decryption(key, decodeString)
    ALG = 'des'
    cipher = OpenSSL::Cipher::Cipher.new(ALG)
    cipher.decrypt  #choose descryption mode.
    cipher.key = key
    plain = cipher.update(decodeString )
    plain &lt;&lt; cipher.final
end
</code></pre>

<p>After executing the java and ruby code, I got the same size of bytes, but the contents of bytes are different. Where did I go wrong?</p>
","<p>According to this article : <a href=""http://43n141e.blogspot.tw/2008/08/des-encryption-java-to-openssl-to-ruby.html"" rel=""nofollow"">http://43n141e.blogspot.tw/2008/08/des-encryption-java-to-openssl-to-ruby.html</a> , I try the following two steps :
1. Calculate iv value in Java:</p>

<pre><code>String key = ""123456""
final byte[] rgbIV = key.getBytes();
final IvParameterSpec iv = new IvParameterSpec(rgbIV);
byte[] ivBytes = iv.getIV();
StringBuffer sbuf = new StringBuffer();
for (byte b : ivBytes) {
    sbuf.append(String.format(""%02x"", (b &amp; 0xFF)));
}
System.out.println(""iv: "" + sbuf);
</code></pre>

<p>2. Decrypt in Ruby :</p>

<pre><code>def decode(encryptedString, key, iv)
    decrypt = OpenSSL::Cipher::Cipher.new('des-cbc')
    decrypt.decrypt
    decrypt.key = key
    decrypt.iv = iv.scan(/../).map{|b|b.hex}.pack('c*')
    decrypt.update(encryptedString) + decrypt.final
end
</code></pre>

<p>and it works !</p>
","2036","<ruby><encryption><des>","-3","3","2","2014-10-27 14:50:09","26493366","3","2","1476062","","2014-10-23 05:24:55","2014-10-21 18:02:52",""
"7855238","Encode / Decode RealVNC password","<p>I'm trying to write C# application that can remotely change the RealVNC password on another box.</p>

<p>What works currently is that I can pull a password from a box that has already been changed, store it as a hex string, and then send it to another box AND then change the password that way but I need to be able to change the password or randomize it on the fly.</p>

<p>I'm having problems with creating the correct binary to place in the registry.</p>

<p>I know the VNC key:</p>

<pre><code>byte[] Key = { 23, 82, 107, 6, 35, 78, 88, 7 };
</code></pre>

<p>So using the above key and passing ""1234"" as the password to encrypt using the following code:</p>

<pre><code>public static byte[] EncryptTextToMemory(string Data, byte[] Key)
{
    try
    {
        MemoryStream mStream = new MemoryStream()

        DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider();
        desProvider.Mode = CipherMode.ECB;
        desProvider.Key = Key;

        CryptoStream cStream = new CryptoStream(mStream,
            desProvider.CreateEncryptor(),
            CryptoStreamMode.Write);

        byte[] toEncrypt = new ASCIIEncoding().GetBytes(Data);

        cStream.Write(toEncrypt, 0, toEncrypt.Length);
        cStream.FlushFinalBlock();

        byte[] ret = mStream.ToArray();

        cStream.Close();
        mStream.Close();

        return ret;
    }
    catch (CryptographicException ex)
    {
        MessageBox.Show(""A Cryptographic error occurred: "" + ex.Message);
        return null;
    }
</code></pre>

<p>After passing the returned byte array to <code>BitConverter.ToString</code>, I would expect to get the same hex values as stored in the registry of a password already set to 1234 with RealVNC itself, but I'm not.</p>
","<p>Here are my sources to encrypt/decrypt VNC password:</p>

<pre><code>public static string EncryptVNC(string password)
    {
        if (password.Length &gt; 8)
        {
            password = password.Substring(0, 8);
        }
        if (password.Length &lt; 8)
        {
            password = password.PadRight(8, '\0');
        }

        byte[] key = { 23, 82, 107, 6, 35, 78, 88, 7 };
        byte[] passArr = new ASCIIEncoding().GetBytes(password);
        byte[] response = new byte[passArr.Length];
        char[] chars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

        // reverse the byte order
        byte[] newkey = new byte[8];
        for (int i = 0; i &lt; 8; i++)
        {
            // revert desKey[i]:
            newkey[i] = (byte)(
                ((key[i] &amp; 0x01) &lt;&lt; 7) |
                ((key[i] &amp; 0x02) &lt;&lt; 5) |
                ((key[i] &amp; 0x04) &lt;&lt; 3) |
                ((key[i] &amp; 0x08) &lt;&lt; 1) |
                ((key[i] &amp; 0x10) &gt;&gt; 1) |
                ((key[i] &amp; 0x20) &gt;&gt; 3) |
                ((key[i] &amp; 0x40) &gt;&gt; 5) |
                ((key[i] &amp; 0x80) &gt;&gt; 7)
                );
        }
        key = newkey;
        // reverse the byte order

        DES des = new DESCryptoServiceProvider();
        des.Padding = PaddingMode.None;
        des.Mode = CipherMode.ECB;

        ICryptoTransform enc = des.CreateEncryptor(key, null);
        enc.TransformBlock(passArr, 0, passArr.Length, response, 0);

        string hexString = String.Empty;
        for (int i = 0; i &lt; response.Length; i++)
        {
            hexString += chars[response[i] &gt;&gt; 4];
            hexString += chars[response[i] &amp; 0xf];
        }
        return hexString.Trim().ToLower();
    }
</code></pre>

<p>And to decrypt:</p>

<pre><code>public static string DecryptVNC(string password)
    {
        if (password.Length &lt; 16)
        {
            return string.Empty;
        }

        byte[] key = { 23, 82, 107, 6, 35, 78, 88, 7 };
        byte[] passArr = ToByteArray(password);
        byte[] response = new byte[passArr.Length];

        // reverse the byte order
        byte[] newkey = new byte[8];
        for (int i = 0; i &lt; 8; i++)
        {
            // revert key[i]:
            newkey[i] = (byte)(
                ((key[i] &amp; 0x01) &lt;&lt; 7) |
                ((key[i] &amp; 0x02) &lt;&lt; 5) |
                ((key[i] &amp; 0x04) &lt;&lt; 3) |
                ((key[i] &amp; 0x08) &lt;&lt; 1) |
                ((key[i] &amp; 0x10) &gt;&gt; 1) |
                ((key[i] &amp; 0x20) &gt;&gt; 3) |
                ((key[i] &amp; 0x40) &gt;&gt; 5) |
                ((key[i] &amp; 0x80) &gt;&gt; 7)
                );
        }
        key = newkey;
        // reverse the byte order

        DES des = new DESCryptoServiceProvider();
        des.Padding = PaddingMode.None;
        des.Mode = CipherMode.ECB;

        ICryptoTransform dec = des.CreateDecryptor(key, null);
        dec.TransformBlock(passArr, 0, passArr.Length, response, 0);

        return System.Text.ASCIIEncoding.ASCII.GetString(response);
    }
</code></pre>

<p>Also this function is needed:</p>

<pre><code>public static byte[] ToByteArray(String HexString)
    {
        int NumberChars = HexString.Length;
        byte[] bytes = new byte[NumberChars / 2];

        for (int i = 0; i &lt; NumberChars; i += 2)
        {
            bytes[i / 2] = Convert.ToByte(HexString.Substring(i, 2), 16);
        }

        return bytes;
    }
</code></pre>

<p>At top add:</p>

<pre><code>using System.Security.Cryptography;
</code></pre>

<p>Can't remember where I got the code from. I am not the original author.</p>
","2027","<c#><.net-2.0><des>","2","3","1","2016-10-07 09:55:52","","2","1","1243316","","2012-03-18 18:28:33","2011-10-21 21:00:58",""
"7085143","C: DES Encryption problem","<p>I was looking for examples how to encode stuff in C using DES cypher and openssl headers and I found this one: <a href=""http://www.codealias.info/technotes/des_encryption_using_openssl_a_simple_example"" rel=""nofollow"">http://www.codealias.info/technotes/des_encryption_using_openssl_a_simple_example</a></p>

<p>The code is almost perfect but I'm not so expert in this stuff and my C knowledge in C is not so big since I use it on PIC and AVR micro controllers... </p>

<p>Anyway in the code:</p>

<pre><code>printf(""Clear text\t : %s \n"",clear);
memcpy(encrypted,Encrypt(key,clear,sizeof(clear)), sizeof(clear));
printf(""Encrypted text\t : %s \n"",encrypted);
memcpy(decrypted,Decrypt(key,encrypted,sizeof(clear)), sizeof(clear));
printf(""Decrypted text\t : %s \n"",decrypted);
</code></pre>

<p>As you can see, sizeof(clear) is used as the size of the string... the problem is that on the example we know the size of the text string... but when I'm sending this text over the network the other computer don't know it...</p>

<p>How can solve this issue... I don't understand so well why I need to have the size of the original string to decrypt :S</p>

<p>Thanks!!</p>
","<p>In the implementations I have seen of DES, I only ever recall seeing plaintext and ciphertext of the same size. <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">Wikipedia seems to confirm this</a>. Since DES works on 64-bit chunks, that would make since as long as the code implementing DES properly pads the input to match those 64-bit boundaries. In fact, that's pretty much the definition of a <a href=""http://en.wikipedia.org/wiki/Block_cipher"" rel=""nofollow"">block cipher</a> (which is what DES is).</p>

<p>Thus I would wager you will see it work flawlessly with the other computer using the size of the encrypted text. A few tests of your own should be able to confirm this absolutely.</p>

<p>Also, I firmly agree with the Jeremy's comment that DES is a poor choice of encryption algorithm for most situations. Triple DES or AES are much better options.</p>
","2008","<c><encryption><openssl><des>","0","2","2","2011-08-16 21:27:13","7085253","3","","","","","2011-08-16 21:18:10",""
"7085143","C: DES Encryption problem","<p>I was looking for examples how to encode stuff in C using DES cypher and openssl headers and I found this one: <a href=""http://www.codealias.info/technotes/des_encryption_using_openssl_a_simple_example"" rel=""nofollow"">http://www.codealias.info/technotes/des_encryption_using_openssl_a_simple_example</a></p>

<p>The code is almost perfect but I'm not so expert in this stuff and my C knowledge in C is not so big since I use it on PIC and AVR micro controllers... </p>

<p>Anyway in the code:</p>

<pre><code>printf(""Clear text\t : %s \n"",clear);
memcpy(encrypted,Encrypt(key,clear,sizeof(clear)), sizeof(clear));
printf(""Encrypted text\t : %s \n"",encrypted);
memcpy(decrypted,Decrypt(key,encrypted,sizeof(clear)), sizeof(clear));
printf(""Decrypted text\t : %s \n"",decrypted);
</code></pre>

<p>As you can see, sizeof(clear) is used as the size of the string... the problem is that on the example we know the size of the text string... but when I'm sending this text over the network the other computer don't know it...</p>

<p>How can solve this issue... I don't understand so well why I need to have the size of the original string to decrypt :S</p>

<p>Thanks!!</p>
","<blockquote>
  <blockquote>
    <p><a href=""http://www.schneier.com/book-sandl-pref.html"" rel=""nofollow"">The world is full of bad security systems designed by people who read Applied Cryptography.</a> </p>
  </blockquote>
</blockquote>

<p>Don't send your own 'encryptyed' stuff on wire. You're missing an HMAC, you're missing a key exchange protocol, you're missing a wire frame protocol (which is exactly the answer to your question 'how do I know the size'). Just use an off-the-shelf protocol like TLS/SSL. <a href=""http://www.gnu.org/software/gnutls/"" rel=""nofollow"">gnu-tls</a> offers a easy to use API for SSL/TLS, openssl also supports it but is notoriously cumbersome to use. Whatever you do, don't start writing your own protocol, you'll come up with yet another broken 'encryption' protocol because of a bad key exchange or a 'optimized nonce' or a missing frame signature or whatever.</p>

<p>Here is a simple example using gnu-tls: <a href=""http://www.gnu.org/software/gnutls/manual/html_node/Simple-client-example-in-C_002b_002b.html#Simple-client-example-in-C_002b_002b"" rel=""nofollow"">Simple client example using the C++ API</a></p>
","2008","<c><encryption><openssl><des>","0","3","2","2011-08-16 21:27:13","7085253","3","","","","","2011-08-16 21:18:10",""
"20252706","S-DES implementation : how to work with the individual bits?","<p>I have an assignment that asks us to implement S-DES (Simplified DES), and the algorithm includes a lot of bit permutations, shifts as well as XOR-ing.</p>

<p>Obviously, the fastest way to implement this would be using bit operations, such as:</p>

<pre><code>char CLS(char key, int shift){
    char skey;
    skey = (key &lt;&lt; shift) | (key &gt;&gt; (8 - shift)) 
    return skey;
}

/* Get 8-bit subkey from 10-bit key */
char permute(short int key){
    short int i;
    short int k1[] = { BIT_6, BIT_3, BIT_7, BIT_4, BIT_8, BIT_5, BIT_10, BIT_9 }; // SDES spec
    char sk1 = '\0';

    for(i = 0; i &lt; 8; i++){
        sk1 = (sk1 &lt;&lt; 1) | (key &amp; k1[i]);
    }
}

...
</code></pre>

<p>Which is simple enough to do. However, how do I <em>get</em> those bits efficiently? Using something like <code>fread()</code>, I could read at least 1 byte at a time and supply those to the SDES algorithm, but that grossly under-utilizes the CPU, as I'd not only be reading and encrypting only 1 byte at a time, I would also be writing 1 byte of encrypted data to disk at a time! Surely there must be a better way.</p>

<p>The only alternative to this that I could think of was treat each byte as a char array and manipulate the bits that way, but not only does that add memory overhead: I'd still be stuck working with 1 byte at a time <em>and</em> I wouldn't be able to use shift operations and need to instead use temporary arrays and array indices.</p>

<p>I'm looking to improve this behaviour slightly, but all I could think of was bringing bigger blocks into memory. For example, I could use <code>fread()</code> to read 4K blocks of data into a char array[4096] and then work with that as opposed to reading 4096 bytes one-by-one from disk. </p>

<p>But, I'm not certain if this is all I could do given that it's a simple algorithm. Could further improvements be made, or is this about as good as it gets?</p>

<p>Should anyone want to take a look, <a href=""http://homepage.smc.edu/morgan_david/vpn/C-SDES.pdf"" rel=""nofollow"">here</a> is the specification of the S-DES algorithm. </p>
","<p>If you want to speed-up your algorithm you could parallelize the encryption on the byte array, for example with OpenMP. As DarkSquirrel42 pointed out in a comment, to gain speed you should also replace your permute function with a function using a look-up table:</p>

<pre><code>#define LUT_SIZE 1024
static char lookup_table[LUT_SIZE];

/* Get 8-bit subkey from 10-bit key */
char permute(short int key)
{
    // SDES spec
    short int k1[] = { BIT_6, BIT_3, BIT_7, BIT_4, BIT_8, BIT_5, BIT_10, BIT_9 }; 
    char sk1 = '\0';

    for (short int i = 0; i &lt; 8; i++) {
        sk1 = (sk1 &lt;&lt; 1) | (key &amp; k1[i]);
    }
    return sk1;
}

void init_lut()
{
    for (short int i = 0; i &lt; LUT_SIZE; i++) {
        lookup_table[i] = permute(i);
    }
}

char permute_fast(short int key)
{
    if (key &lt; 0 || key &gt;= LUT_SIZE) {
        //error handling
        return 0;
    }
    return lookup_table[key];
}
</code></pre>
","1963","<c><algorithm><encryption><bit-manipulation><des>","3","3","1","2013-11-29 16:51:51","20254793","3","","991710","","2013-11-27 20:48:40","2013-11-27 20:43:09",""
"20459456","Python DES libraries","<p>I am just wondering if there are any Python libraries out there that can help me implement DES. Maybe ones that can generate the sub keys or apply permutations.</p>

<p>Thanks.</p>
","<p>The <a href=""https://www.dlitz.net/software/pycrypto/"" rel=""nofollow""><code>pycrypto</code> library</a> is the de-facto encryption library for python.  It supports encryption and decryption of DES blocks, however DES only supports passwords of 7 bytes in length, and is considered obsolete and insecure. You're better off using a newer encryption standard like AES.</p>
","1947","<python><des>","0","0","1","2013-12-08 21:52:25","","2","","","","","2013-12-08 21:39:48","2014-04-12 02:38:44"
"13245385","Invalid block padding trying to decrypt 2-key triple DES","<p>I am trying to implement 2-key triple DES with crypto++ in C++.</p>

<p>My implementation is based upon the code in the crypto++ wiki located <a href=""http://www.cryptopp.com/wiki/TripleDES"" rel=""nofollow"">here</a>.</p>

<p>The code on the wiki builds properly; I can see that it is encrypting and decrypting correctly when I run the sample program.</p>

<p>For my implementation, I am trying to do the following:</p>

<ol>
<li><p>the user can run ""desimp.exe encrypt test.txt"". The program will encrypt test.txt and then output an encrypted file named test.txt.des . This seems to be working properly.</p></li>
<li><p>the user can run ""desimp.exe decrypt test.txt.des"" and the program will decrypt test.txt.des and output the decrypted text to a file ""decrypted.txt"" I can't get this to work. The error that I get is ""<strong>StreamTransformationFilter: invalid PKCS #7 block padding found</strong>""</p></li>
</ol>

<p>I believe I might need to save the data in the iv to a file at the time of encryption as well. Is this correct? I have tried doing this, and I think I'm able to get the iv saved to a file correctly - but I think in order to read in the iv to be used to for decryption, it needs to be read in as an array of 8 bytes. The file size of test.txt.iv when I attempt to save the iv is 21 bytes. If this is the right approach, I'm not sure how to proceed. If this is the wrong approach, I'd like to know what I need to do differently. Here is the code:</p>

<pre><code>#ifndef CRYPTOPP_DLL_ONLY
#define CRYPTOPP_DEFAULT_NO_DLL
#endif

#include ""dll.h""
#include ""rc6.h""
#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;
#include &lt;fstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;streambuf&gt;

USING_NAMESPACE(CryptoPP)
USING_NAMESPACE(std)

#ifdef CRYPTOPP_IMPORTS
static PNew s_pNew = NULL;
static PDelete s_pDelete = NULL;
#endif
#ifdef CRYPTOPP_DLL_ONLY

int __cdecl main(int argc, char *argv[])
{

    AutoSeededRandomPool prng;
    SecByteBlock key(DES_EDE2::DEFAULT_KEYLENGTH);
    prng.GenerateBlock(key, key.size());
    byte iv[DES_EDE2::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
    string plain = ""CBC Mode Test"";
    string cipher, encoded, recovered;


    char *fileName = argv[1];
    char *runMode = argv[2];
    char *ivFile = argv[3];

    cout &lt;&lt; ""ARGUMENT 1: "" &lt;&lt; fileName &lt;&lt; endl;
    cout &lt;&lt; ""ARGUMENT 2: "" &lt;&lt; runMode &lt;&lt; endl;

    string fileNameString(fileName);
    string encryptedFileNameString = fileNameString + "".des"";//add .des to the filename of the encrypted file once it's generated
    string ivString = fileNameString + "".iv"";//iv file
    string runModeString(runMode);

    if (runModeString == ""encrypt"")
    {
        ifstream t(fileName);
        string str((std::istreambuf_iterator&lt;char&gt;(t)),
        istreambuf_iterator&lt;char&gt;());
        try
        {
            cout &lt;&lt; ""plain text: "" &lt;&lt; str &lt;&lt; endl;

            CBC_Mode&lt; DES_EDE2 &gt;::Encryption e;
            e.SetKeyWithIV(key, key.size(), iv);

            // The StreamTransformationFilter adds padding
            //  as required. ECB and CBC Mode must be padded
            //  to the block size of the cipher.
            StringSource ss1(str, true, 
                new StreamTransformationFilter(e,
                    new StringSink(cipher)
                ) // StreamTransformationFilter      
            ); // StringSource
        }
        catch(const CryptoPP::Exception&amp; e)
        {
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            exit(1);
        }
        // Pretty print
        StringSource ss2(cipher, true,
            new HexEncoder(
                new StringSink(encoded)
            ) // HexEncoder
        ); // StringSource

        cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;//""encoded"" is just the pretty print version of the ciphertext.
        ofstream fout(encryptedFileNameString); 
        fout &lt;&lt; cipher; 
        fout.close();//outputs/saves the encrypted file
        cout &lt;&lt; ""Encrypted file was saved to local path as "" &lt;&lt; encryptedFileNameString &lt;&lt; endl;

        ofstream fout2(ivString); 
        fout2 &lt;&lt; iv; 
        fout2.close();
        cout &lt;&lt; ""iv was saved to local path as "" &lt;&lt; ivString &lt;&lt; endl;
    }

    if (runModeString == ""decrypt"")// USER WANTS TO DECRYPT A FILE
        {           
            ifstream t2(fileName);
            string str2((istreambuf_iterator&lt;char&gt;(t2)),istreambuf_iterator&lt;char&gt;());
            cipher = str2;

        try
        {
            CBC_Mode&lt; DES_EDE2 &gt;::Decryption d;
            d.SetKeyWithIV(key, key.size(), iv);
            // The StreamTransformationFilter removes
            //  padding as required.
            StringSource ss3(cipher, true, 
                new StreamTransformationFilter(d,
                    new StringSink(recovered)
                ) // StreamTransformationFilter
            ); // StringSource

            cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
        }
        catch(const CryptoPP::Exception&amp; e)
            {
                cerr &lt;&lt; e.what() &lt;&lt; endl;
                exit(1);
            }
        }
        return 0;
    }//end main

    extern ""C"" __declspec(dllexport) void __cdecl SetNewAndDeleteFromCryptoPP(PNew pNew, PDelete pDelete, PSetNewHandler pSetNewHandler)
    {
        s_pNew = pNew;
        s_pDelete = pDelete;
    }

    void * __cdecl operator new (size_t size)
    {
        return s_pNew(size);
    }

    void __cdecl operator delete (void * p)
    {
        s_pDelete(p);
    }

    #endif
</code></pre>
","<p>I think you need to open your encrypted file with <code>std::ios_base::binary</code> in the mode (both for reading and writing); otherwise, the I/O library will mangle sequences which look like line-ends.</p>
","1947","<c++><encryption><des><crypto++>","1","1","1","2015-05-02 22:43:15","13246047","1","","608639","","2015-05-02 22:43:15","2012-11-06 06:11:18",""
"9790967","PBEwithMD5andDES in C#","<p>How should I specify a text input and output using this code?
I need to open a file and read its contents (which I know how to do) and then decrypt it using this code.</p>

<pre><code>    public string DecryptUsernamePassword(string cipherText)
    {
        if (string.IsNullOrEmpty(cipherText))
        {
            return cipherText;
        }

        byte[] salt = new byte[]
        {
            (byte)0xc7,
            (byte)0x73,
            (byte)0x21,
            (byte)0x8c,
            (byte)0x7e,
            (byte)0xc8,
            (byte)0xee,
            (byte)0x99
        };

        PKCSKeyGenerator crypto = new PKCSKeyGenerator(""PASSWORD HERE"", salt, 20, 1);

        ICryptoTransform cryptoTransform = crypto.Decryptor;
        byte[] cipherBytes = System.Convert.FromBase64String(cipherText);
        byte[] clearBytes = cryptoTransform.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);
        return Encoding.UTF8.GetString(clearBytes);
    }
</code></pre>

<p>cipherText is the encrypted text and clearBytes are the unencrypted bytes but I need to use a textBox with C# forms for input and output.</p>

<p>This is how it needs to work: textBox1.Text (input) -> bytes -> ^above^ string -> bytes -> textBox2.Text (output) Anything works tbh as long as my input is encrypted text and my output is decrypted text.</p>
","<p>Based on your comments, assuming I'm still understanding the question properly. Make this into it's own class:</p>

<pre><code> public class UsernameDecryptor
 {
      public string Decrypt(string cipherText)
      {
           if (string.IsNullOrEmpty(cipherText))
                return cipherText;


           byte[] salt = new byte[]
           {
                (byte)0xc7,
                (byte)0x73,
                 (byte)0x21,
                (byte)0x8c,
                (byte)0x7e,
                (byte)0xc8,
                (byte)0xee,
                (byte)0x99
            };

            PKCSKeyGenerator crypto = new PKCSKeyGenerator(""PASSWORD HERE"", salt, 20, 1);

            ICryptoTransform cryptoTransform = crypto.Decryptor;
            byte[] cipherBytes = System.Convert.FromBase64String(cipherText);
            byte[] clearBytes = cryptoTransform.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);

            return Encoding.UTF8.GetString(clearBytes);
      }
 }
</code></pre>

<p>Then, inside your button handler:</p>

<pre><code>private void button1_Click (object sender, System.EventArgs e)
{
     UsernameDecryptor decryptor = new UsernameDecryptor();

     string result = decryptor.Decrypt(inputTextBox.Text);

     outputTextBox.Text = result;
}
</code></pre>
","1928","<c#><java><md5><des>","0","0","1","2015-11-12 10:59:08","9792022","5","0","1191228","","2012-03-20 16:54:30","2012-03-20 16:34:20",""
"34923553","DES decrypting in Java for File from DES.EXE","<p>i found a question where the answer from Elephantik basically answerd my question:
<a href=""https://stackoverflow.com/questions/1615252/des-initialization-vector-in-c-sharp/20221027"">DES Initialization Vector in C#</a></p>

<p>I have a file which was encrypted with the DES.EXE command line tool. And i can decrypt it with following command: ""des -D -k YSTxyHBH file.cr file.txt""</p>

<p>With this command i get an decrypted file.txt, but i need do decrypt this file in Java.</p>

<p>So i tried to transfer the solution from Elephantik to Java, but there has to be something wrong with my solution, because as result i only get some encrypted text when i call the decryptData(...) method.</p>

<pre><code>public byte[] decryptData(byte input[], String password) throws Exception {
    byte[] result = null;
    //Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    Cipher cipher = Cipher.getInstance(""DES/CBC/NoPadding"");
    //byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0 };
    byte[] iv = { -128, -128, -128, -128, -128, -128, -128, -128 };
    IvParameterSpec ivspec = new IvParameterSpec(iv);
    cipher.init(Cipher.DECRYPT_MODE, generateSecretKey(passwordToKey(password)), ivspec);
    result = cipher.doFinal(input);
    return result;
}

protected SecretKey generateSecretKey(byte[] key) throws Exception {
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""DES"");
    KeySpec keySpec = new DESKeySpec(key);
    SecretKey secretKey = factory.generateSecret(keySpec);
    return secretKey;
}

public byte[] passwordToKey(String password) throws Exception
{
    if (password == null)
        throw new IllegalArgumentException(""password"");
    if (password == """")
        throw new IllegalArgumentException(""password"");

    byte[] key = new byte[8];

    for (int i = 0; i &lt; password.length(); i++)
    {
        int c = (int)password.charAt(i);
        if ((i % 16) &lt; 8)
        {
            key[i % 8] ^= (byte)(c &lt;&lt; 1);
        }
        else
        {
            // reverse bits e.g. 11010010 -&gt; 01001011
            c = (((c &lt;&lt; 4) &amp; 0xf0) | ((c &gt;&gt; 4) &amp; 0x0f));
            c = (((c &lt;&lt; 2) &amp; 0xcc) | ((c &gt;&gt; 2) &amp; 0x33));
            c = (((c &lt;&lt; 1) &amp; 0xaa) | ((c &gt;&gt; 1) &amp; 0x55));
            key[7 - (i % 8)] ^= (byte)c;
        }
    }

    addOddParity(key);

    byte[] target = new byte[8];
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream( );
    outputStream.write(password.getBytes(""US-ASCII""));
    outputStream.write(new byte[8]);
    byte[] temp = outputStream.toByteArray();
    outputStream = new ByteArrayOutputStream( );
    for (int i = 0; i &lt; (password.length() + (8 - (password.length() % 8)) % 8); ++i) {
        outputStream.write(temp[i]);
    }
    byte[] passwordBuffer = outputStream.toByteArray(); 

    Cipher cipher = Cipher.getInstance(""DES/CBC/NoPadding"");
    //byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0 };
    byte[] iv = { -128, -128, -128, -128, -128, -128, -128, -128 };
    IvParameterSpec ivspec = new IvParameterSpec(iv);
    cipher.init(Cipher.ENCRYPT_MODE, generateSecretKey(key), ivspec);
    for (int x = 0; x &lt; passwordBuffer.length / 8; ++x)
    {
        cipher.update(passwordBuffer, 8 * x, 8, target, 0);
    }

    addOddParity(target);

    return target;
}

private void addOddParity(byte[] buffer)
{
    for (int i = 0; i &lt; buffer.length; ++i)
    {
        buffer[i] = _oddParityTable[buffer[i] &amp; 0xFF];
    }
}

private static byte[] _oddParityTable = {
   -127,-127,-126,-126,-124,-124,-121,-121,-120,-120,-117,-117,-115,-115,-114,-114,
   -112,-112,-109,-109,-107,-107,-106,-106,-103,-103,-102,-102,-100,-100, -97, -97,
    -96, -96, -93, -93, -91, -91, -90, -90, -87, -87, -86, -86, -84, -84, -81, -81,
    -79, -79, -78, -78, -76, -76, -73, -73, -72, -72, -69, -69, -67, -67, -66, -66,
    -64, -64, -61, -61, -59, -59, -58, -58, -55, -55, -54, -54, -52, -52, -49, -49,
    -47, -47, -46, -46, -44, -44, -41, -41, -40, -40, -37, -37, -35, -35, -34, -34,
    -31, -31, -30, -30, -28, -28, -25, -25, -24, -24, -21, -21, -19, -19, -18, -18,
    -16, -16, -13, -13, -11, -11, -10, -10,  -7,  -7,  -6,  -6,  -4,  -4,  -1,  -1,
      0,   0,   3,   3,   5,   5,   6,   6,   9,   9,  10,  10,  12,  12,  15,  15,
     17,  17,  18,  18,  20,  20,  23,  23,  24,  24,  27,  27,  29,  29,  30,  30,
     33,  33,  34,  34,  36,  36,  39,  39,  40,  40,  43,  43,  45,  45,  46,  46,
     48,  48,  51,  51,  53,  53,  54,  54,  57,  57,  58,  58,  60,  60,  63,  63,
     65,  65,  66,  66,  68,  68,  71,  71,  72,  72,  75,  75,  77,  77,  78,  78,
     80,  80,  83,  83,  85,  85,  86,  86,  89,  89,  90,  90,  92,  92,  95,  95,
     96,  96,  99,  99, 101, 101, 102, 102, 105, 105, 106, 106, 108, 108, 111, 111,
    113, 113, 114, 114, 116, 116, 119, 119, 120, 120, 123, 123, 125, 125, 126, 126
};
</code></pre>
","<p>Michael, There are few mistakes I found in your code. Check the line <code>cipher.init(Cipher.ENCRYPT_MODE, generateSecretKey(key), ivspec);</code> You need to pass the same <strong><em>key</em></strong> as <strong><em>initialization vector</em></strong>,but not IV you have. The des.exe program is based on source code of <a href=""http://ftp.nluug.nl/security/coast/libs/libdes/"" rel=""nofollow noreferrer"">LibDes</a> library. You can find all the details in the documentation and source code. You have mention <code>des -D</code> parameter. It means you need to decrypt <strong><em>DES</em></strong> with <strong><em>CBC/NoPadding</em></strong> mode. Check also the <code>_oddParityTable</code> method you have. </p>

<p>If your file is not UUdecoded omit the related part in my code. </p>

<p>Here is ready Java example: </p>

<pre><code>public class UUDES {

    public static void main (String[] args) throws Exception
    {                                   
        String password = ""xxxxxx"";
        String pathToUUEencodedEncryptedFile = ""C:\DES\path-to-decoded-and-encrypted-file"";

        byte[] secretKey = passwordToKey(password);
        byte[] iv = new byte[8];        
        byte[] uuEncodedFile = Files.readAllBytes(Paths.get(pathToUUEencodedEncryptedFile));

        SecretKey key = new SecretKeySpec(secretKey, ""DES"");

        Cipher decryptor = Cipher.getInstance(""DES/CBC/NoPadding"");
        decryptor.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));          

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        InputStream in = null;      
        try {
            in = MimeUtility.decode(new ByteArrayInputStream(uuEncodedFile), ""uuencode"");
            byte[] buf = new byte[1024];
            int length;
            while (true) {
                length = in.read(buf);
                if (length == -1) {
                    break;
                }
                bout.write(buf, 0, length);
            }

            byte[] bytesDecrypted = decryptor.doFinal(bout.toByteArray());

            ByteArrayInputStream bais = new ByteArrayInputStream(bytesDecrypted);
            GZIPInputStream gzis = new GZIPInputStream(bais);
            InputStreamReader reader = new InputStreamReader(gzis);
            BufferedReader buffer = new BufferedReader(reader);

            String readed;
            while ((readed = buffer.readLine()) != null) {
                System.out.println(readed);
            }                              
        }
        finally {
            if (in != null) {
                try {
                    in.close();
                }
                catch (IOException e) {
                    System.out.println(e.getMessage());
                }
            }
        }                                   
    }

    static SecretKey generateSecretKey(byte[] key) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""DES"");
        KeySpec keySpec = new DESKeySpec(key);
        SecretKey secretKey = factory.generateSecret(keySpec);
        return secretKey;
    }

    static byte[] passwordToKey(String password) throws Exception
    {
        if (password == null)
            throw new IllegalArgumentException(""password"");
        if (password == """")
            throw new IllegalArgumentException(""password"");

        byte[] key = new byte[8];

        for (int i = 0; i &lt; password.length(); i++)
        {
            int c = (int)password.charAt(i);
            if ((i % 16) &lt; 8)
            {
                key[i % 8] ^= (byte)(c &lt;&lt; 1);
            }
            else
            {
                // reverse bits e.g. 11010010 -&gt; 01001011
                c = (((c &lt;&lt; 4) &amp; 0xf0) | ((c &gt;&gt; 4) &amp; 0x0f));
                c = (((c &lt;&lt; 2) &amp; 0xcc) | ((c &gt;&gt; 2) &amp; 0x33));
                c = (((c &lt;&lt; 1) &amp; 0xaa) | ((c &gt;&gt; 1) &amp; 0x55));
                key[7 - (i % 8)] ^= (byte)c;
            }
        }

        addOddParity(key);

        byte[] target = new byte[8];
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream( );
        outputStream.write(password.getBytes(""US-ASCII""));
        outputStream.write(new byte[8]);
        byte[] temp = outputStream.toByteArray();
        outputStream = new ByteArrayOutputStream( );
        for (int i = 0; i &lt; (password.length() + (8 - (password.length() % 8)) % 8); ++i) {
            outputStream.write(temp[i]);
        }
        byte[] passwordBuffer = outputStream.toByteArray(); 

        Cipher cipher = Cipher.getInstance(""DES/CBC/NoPadding"");
        byte[] iv = key;

        IvParameterSpec ivspec = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, generateSecretKey(key), ivspec);
        for (int x = 0; x &lt; passwordBuffer.length / 8; ++x)
        {
            cipher.update(passwordBuffer, 8 * x, 8, target, 0);
        }

        addOddParity(target);

        return target;
    }

    static void addOddParity(byte[] buffer)
    {
        for (int i = 0; i &lt; buffer.length; ++i)
        {
            buffer[i] = _oddParityTable[buffer[i] &amp; 0xFF];
        }
    }

    static byte[] _oddParityTable = {
            (byte)1,(byte)1,(byte)2,(byte)2,(byte)4,(byte)4,(byte)7,(byte)7,(byte)8,(byte)8,(byte)11,(byte)11,(byte)13,(byte)13,(byte)14,(byte)14,
            (byte)16,(byte)16,(byte)19,(byte)19,(byte)21,(byte)21,(byte)22,(byte)22,(byte)25,(byte)25,(byte)26,(byte)26,(byte)28,(byte)28,(byte)31,(byte)31,
           (byte)32,(byte)32,(byte)35,(byte)35,(byte)37,(byte)37,(byte)38,(byte)38,(byte)41,(byte)41,(byte)42,(byte)42,(byte)44,(byte)44,(byte)47,(byte)47,
           (byte)49,(byte)49,(byte)50,(byte)50,(byte)52,(byte)52,(byte)55,(byte)55,(byte)56,(byte)56,(byte)59,(byte)59,(byte)61,(byte)61,(byte)62,(byte)62,
           (byte)64,(byte)64,(byte)67,(byte)67,(byte)69,(byte)69,(byte)70,(byte)70,(byte)73,(byte)73,(byte)74,(byte)74,(byte)76,(byte)76,(byte)79,(byte)79,
           (byte)81,(byte)81,(byte)82,(byte)82,(byte)84,(byte)84,(byte)87,(byte)87,(byte)88,(byte)88,(byte)91,(byte)91,(byte)93,(byte)93,(byte)94,(byte)94,
           (byte)97,(byte)(byte)97,(byte)(byte)98,(byte)(byte)98,(byte)100,(byte)100,(byte)103,(byte)103,(byte)104,(byte)104,(byte)107,(byte)107,(byte)109,(byte)109,(byte)110,(byte)110,
           (byte)112,(byte)112,(byte)115,(byte)115,(byte)117,(byte)117,(byte)118,(byte)118,(byte)121,(byte)121,(byte)122,(byte)122,(byte)124,(byte)124,(byte)127,(byte)127,
           (byte)128,(byte)128,(byte)131,(byte)131,(byte)133,(byte)133,(byte)134,(byte)134,(byte)137,(byte)137,(byte)138,(byte)138,(byte)140,(byte)140,(byte)143,(byte)143,
           (byte)145,(byte)145,(byte)146,(byte)146,(byte)148,(byte)148,(byte)151,(byte)151,(byte)152,(byte)152,(byte)155,(byte)155,(byte)157,(byte)157,(byte)158,(byte)158,
           (byte)161,(byte)161,(byte)162,(byte)162,(byte)164,(byte)164,(byte)167,(byte)167,(byte)168,(byte)168,(byte)171,(byte)171,(byte)173,(byte)173,(byte)174,(byte)174,
           (byte)176,(byte)176,(byte)179,(byte)179,(byte)181,(byte)181,(byte)182,(byte)182,(byte)185,(byte)185,(byte)186,(byte)186,(byte)188,(byte)188,(byte)191,(byte)191,
           (byte)193,(byte)193,(byte)194,(byte)194,(byte)196,(byte)196,(byte)199,(byte)199,(byte)200,(byte)200,(byte)203,(byte)203,(byte)205,(byte)205,(byte)206,(byte)206,
           (byte)208,(byte)208,(byte)211,(byte)211,(byte)213,(byte)213,(byte)214,(byte)214,(byte)217,(byte)217,(byte)218,(byte)218,(byte)220,(byte)220,(byte)223,(byte)223,
           (byte)224,(byte)224,(byte)227,(byte)227,(byte)229,(byte)229,(byte)230,(byte)230,(byte)233,(byte)233,(byte)234,(byte)234,(byte)236,(byte)236,(byte)239,(byte)239,
           (byte)241,(byte)241,(byte)242,(byte)242,(byte)244,(byte)244,(byte)247,(byte)247,(byte)248,(byte)248,(byte)251,(byte)251,(byte)253,(byte)253,(byte)254,(byte)254};    
}
</code></pre>
","1909","<java><encryption><des>","1","0","1","2018-04-09 12:55:38","","4","3","1033581","","2018-04-09 12:55:38","2016-01-21 12:15:23",""
"20665821","How to left shift a bitarray in python","<p>I have a bit array named <code>c0</code> containing 28 bits </p>

<pre><code>bitarray('1111011111111111111111110001')
</code></pre>

<p>how can I left shift this bit array for a number of times, meaning one left shift, two left shift, etc.? 
One left shift is fine for now!</p>

<p><strong>NOTE:</strong> This pertains to the <a href=""https://pypi.python.org/pypi/bitarray/"" rel=""nofollow"">bitarray</a> package.</p>
","<p>You could use slicing:</p>

<pre><code>def leftshift(ba, count):
    return ba[count:] + (bitarray('0') * count)

def rightshift(ba, count):
    return (bitarray('0') * count) + ba[:-count]
</code></pre>

<p>These maintain the bit-width of the input, dropping bits on one end and padding with <code>0</code> on the other.</p>

<p>You can create your own subclass of the <code>bitarray</code> type:</p>

<pre><code>class mybitarray(bitarray):
    def __lshift__(self, count):
        return self[count:] + type(self)('0') * count
    def __rshift__(self, count):
        return type(self)('0') * count + self[:-count]
    def __repr__(self):
        return ""{}('{}')"".format(type(self).__name__, self.to01())
</code></pre>

<p>Demo:</p>

<pre><code>&gt;&gt;&gt; c0 = mybitarray(c0)
&gt;&gt;&gt; c0
mybitarray('1111011111111111111111110001')
&gt;&gt;&gt; c0 &lt;&lt; 4
mybitarray('0111111111111111111100010000')
&gt;&gt;&gt; c0 &gt;&gt; 4
mybitarray('0000111101111111111111111111')
</code></pre>

<p>You can also poke the author to <a href=""https://github.com/ilanschnell/bitarray/issues/7"" rel=""nofollow"">support these operations natively</a>.</p>
","1870","<python><des>","2","4","2","2013-12-18 19:13:55","20665900","7","","237974","","2013-12-18 19:13:55","2013-12-18 18:36:01",""
"20665821","How to left shift a bitarray in python","<p>I have a bit array named <code>c0</code> containing 28 bits </p>

<pre><code>bitarray('1111011111111111111111110001')
</code></pre>

<p>how can I left shift this bit array for a number of times, meaning one left shift, two left shift, etc.? 
One left shift is fine for now!</p>

<p><strong>NOTE:</strong> This pertains to the <a href=""https://pypi.python.org/pypi/bitarray/"" rel=""nofollow"">bitarray</a> package.</p>
","<p><code>&lt;&lt;</code> and <code>&gt;&gt;</code> are the shift operators (the bitarray class should override the <code>__ilshift__</code> and <code>__irshift__</code> methods. </p>
","1870","<python><des>","2","1","2","2013-12-18 19:13:55","20665900","7","","237974","","2013-12-18 19:13:55","2013-12-18 18:36:01",""
"14260393","DESede/3DES ECB Encrypt/Decrypt on Windows Phone 8 with C#","<p>I'm looking for a way to encrypt a string with cipher <strong>""DESede/ECB/PKCS5Padding""</strong> on <strong>windows phone 8</strong>.</p>

<p>Unlike Win8 RT, there isn't <em>SymmetricKeyAlgorithmProvider</em>.</p>

<p>I tried to add a BounceCastle c# library, as suggested <a href=""http://nicksnettravels.builttoroam.com/post/2012/03/27/TripleDes-Encryption-with-Key-and-IV-for-Windows-Phone.aspx"" rel=""nofollow"">here</a>, but it seems that there isn't cipher ""DESede/ECB/"", but only ""DESede/CBC/"" with IV Key, while i want <strong>ECB without IV key</strong>.</p>

<p>Any suggestion will be appreciated. Thanks :)</p>

<p><strong>EDIT:</strong> Solution with BounceCastle library:</p>

<pre><code>// DESEDE, not DESEDE/CBC!!!
var cipher = CipherUtilities.GetCipher(""DESEDE"");
byte[] byte_key = Encoding.UTF8.GetBytes(string_key);
var param_key = new DesEdeParameters(byte_key);
byte[] data = Encoding.UTF8.GetBytes(string_data);
cipher.Init(true, param_key);
var data_encrypted = cipher.DoFinal(data);
</code></pre>
","<p>This is 3DES Encrypt-Decrypt-Encrypt cipher with PKCS#5 padding, and it should be supported by BouncyCastle (search for 3DES ECB).
Also it is supported by SecureBlackbox library (however, it is commercial).</p>
","1807","<encryption><windows-phone-8><bouncycastle><des>","0","0","1","2013-01-10 15:37:01","","2","1","1839268","","2013-01-10 15:37:01","2013-01-10 14:40:37",""
"13973662","Android DES algorithm default attributes","<p><br/>
I am using following code for encryption in Android project:<br/><br/></p>

<pre><code>SecretKeyFactory kf = SecretKeyFactory.getInstance(""DES"");
String key = ""abcdefg"";
DESKeySpec keySpec = new DESKeySpec(key.getBytes());
SecretKey _key = kf.generateSecret(keySpec);
String xform = ""DES"";
Cipher cipher = Cipher.getInstance(xform);
byte[] IV = { 11, 22, 33, 44, 55, 66, 77, 88, 99, 18, 69, 17, 72, 94, 18, 30 };
IvParameterSpec ips = new IvParameterSpec(IV);
cipher.init(Cipher.ENCRYPT_MODE, _key, ips);
String plainText = ""abcdeffdkflsdkf"";
byte[] cipherText = cipher.doFinal(plainText.getBytes());
</code></pre>

<p><br/><br/>
I write this encrypted data in file and I want to decrypt this file in my java project where I am using following code:
<br/><br/></p>

<pre><code>SecretKeyFactory kf = SecretKeyFactory.getInstance(""DES"");
String key = ""abcdefg"";
DESKeySpec keySpec = new DESKeySpec(key.getBytes());
SecretKey _key = kf.generateSecret(keySpec);
String xform = ""DES"";
Cipher cipher = Cipher.getInstance(xform);
byte[] IV = { 11, 22, 33, 44, 55, 66, 77, 88, 99, 18, 69, 17, 72, 94, 18, 30 };
IvParameterSpec ips = new IvParameterSpec(IV);
cipher.init(Cipher.DECRYPT_MODE, _key, ips);
String cipherText;
//cipher text is read from file.
byte[] plainText = cipher.doFinal(cipherText.getBytes());
</code></pre>

<p><br/><br/>
But it's not working.
When we do not specify mode of operation(i.e. <code>CBC/ECB</code>) and padding method(i.e. <code>PKCS5Padding/NoPadding</code>) and only algorithm name is specified for getting instance of Cipher then what are the default values which Android and Java use?
<br/><br/>
Does Android uses CBC by default? As it doesn't give error for IV. If I specify IV in <code>init</code> method and don't specify mode in my java project, it throws exception as IV cannot be used for ECB.
<br/><br/>
Thanks.</p>
","<p>Both Android and Java default to <code>""AES/ECB/PKCS5Padding""</code>. Both your key and IV are not of the correct size (so the code should not even run!) and you forget to perform (character) encoding/decoding correctly. Especially the ciphertext should never be directly converted into a string, as unprintable characters are likely to be dropped or converted.</p>
","1792","<java><android><encryption><des>","0","0","1","2013-01-26 17:54:55","","5","3","676691","","2012-12-20 13:58:09","2012-12-20 13:51:40",""
"19462675","DES encryption plain vs. cipher length","<p>I am using Java to make a toy program that encrypts a message using DES encryption. The message I want to encrypt is:</p>

<pre><code>String msg=""This is a secret message"";
</code></pre>

<p>Which I convert to bytes as:</p>

<pre><code>byte [] msgBytes=msg.getBytes();
</code></pre>

<p>And send it to encrypt function that works as follows:</p>

<pre><code>//encryption function
public static String encryptMsg(byte [] msgBytes, SecretKey myDesKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException
{
    Cipher desCipher;
    // Create the cipher 
    desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
    byte[] textEncrypted = desCipher.doFinal(msgBytes);

// converts to base64 for easier display.
byte[] base64Cipher = Base64.encode(textEncrypted);
return new String(base64Cipher);
} //end encryptMsg
</code></pre>

<p>Then, I display the cipher, the cipher and plaintext lengths and I get:</p>

<pre><code>Encrypted Message: FDCU+kgWz25urbQB5HbFtqm0HqWHGlGBHlwwEatFTiI=
Original msg length: 24
Encrypted msg length: 44
</code></pre>

<p>Can you please clarify to me why the cipher length is 44 while the original message length is 24?</p>

<p><strong>EDIT:</strong>
Kindly, I need the answer with clarification. The cipher always ends with =. Could this be because of the padding? Can you explain to me why/how the cipher is resulted with this length? And always ends with =? 
Is my code correct or there is a mistake? I have doubts in the encoding part.</p>
","<p>There are several things going on:</p>

<ol>
<li><p><a href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#getBytes()"" rel=""nofollow noreferrer""><code>msg.getBytes()</code></a> returns the bytes representing an encoding of the string using the ""platform's default charset"" (e.g. could be UTF-8 <em>or</em> UTF-16 <em>or</em> ..): <a href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#getBytes(java.nio.charset.Charset)"" rel=""nofollow noreferrer"">specify the encoding manually</a> to avoid confusion! In any case, see <code>msgBytes.length</code> to get the <em>true</em> plain text length.</p></li>
<li><p><a href=""http://en.wikipedia.org/wiki/DES"" rel=""nofollow noreferrer"">DES</a>, being a block cypher, will have output padded along a <a href=""http://en.wikipedia.org/wiki/Block_size_(cryptography)"" rel=""nofollow noreferrer"">block size</a> boundary - <em>but</em> this will <em>always</em> be larger than the plain text (refer to <code>msgBytes.length</code>) length when using <a href=""http://www.ietf.org/rfc/rfc2898.txt"" rel=""nofollow noreferrer"">PKCS#5</a> because the plain text is always padded with [1,8] bytes. To see what the <em>true</em> encrypted size is, see <code>textEncrypted.length</code>.</p></li>
<li><p>The encrypted bytes are encoded using base-64 and this process - which is independent of the encryption - inflates the number of bytes required <a href=""https://stackoverflow.com/questions/4715415/base64-what-is-the-worst-possible-increase-in-space-usage"">by about 33%</a> (as only 6 bits per character/byte are used). The Java base-64 implementation also <a href=""http://en.wikipedia.org/wiki/Base64#Padding"" rel=""nofollow noreferrer"">adds padding</a> which is where the trailing ""="" character is introduced.</p></li>
</ol>

<p>As long as you (or someone else with the correct algorithm and cipher key) can retrieve the initial string - by performing the inverse of each step in reverse order, then it works. If a particular step does not have an inverse/reverse operation or cannot be ""undone"", then something is wrong; but this also means that <em>every step can be individually tested</em>.</p>

<hr>

<p>To the numbers!</p>

<ol>
<li><code>msg.getBytes()</code> returns an ASCII/UTF-8 encoded sequence (if it used UTF-16 or another another ""wide"" encoding then the numbers below would be too large)</li>
<li>Therefore, <code>msgBytes.length</code> is 24</li>
<li>And since <code>msgBytes.length</code> mod 8 is 0, the plain text is <em>padded</em> with 8 bytes that have the value of 0x08 (per CKCS#5)</li>
<li>Thus, <code>textEncrypted.length</code> is 32 (24 data + 8 padding)</li>
<li>Due to base-64 encoding, 32 bytes * 1.33 ~ 43 characters</li>
<li>And with base-64 padding (<code>=</code>), the final result is 44 characters!</li>
</ol>
","1764","<java><encryption><des><encryption-symmetric>","1","2","2","2013-10-21 20:55:35","19462861","0","2","815724","","2013-10-19 08:17:44","2013-10-19 05:21:14",""
"19462675","DES encryption plain vs. cipher length","<p>I am using Java to make a toy program that encrypts a message using DES encryption. The message I want to encrypt is:</p>

<pre><code>String msg=""This is a secret message"";
</code></pre>

<p>Which I convert to bytes as:</p>

<pre><code>byte [] msgBytes=msg.getBytes();
</code></pre>

<p>And send it to encrypt function that works as follows:</p>

<pre><code>//encryption function
public static String encryptMsg(byte [] msgBytes, SecretKey myDesKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException
{
    Cipher desCipher;
    // Create the cipher 
    desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
    byte[] textEncrypted = desCipher.doFinal(msgBytes);

// converts to base64 for easier display.
byte[] base64Cipher = Base64.encode(textEncrypted);
return new String(base64Cipher);
} //end encryptMsg
</code></pre>

<p>Then, I display the cipher, the cipher and plaintext lengths and I get:</p>

<pre><code>Encrypted Message: FDCU+kgWz25urbQB5HbFtqm0HqWHGlGBHlwwEatFTiI=
Original msg length: 24
Encrypted msg length: 44
</code></pre>

<p>Can you please clarify to me why the cipher length is 44 while the original message length is 24?</p>

<p><strong>EDIT:</strong>
Kindly, I need the answer with clarification. The cipher always ends with =. Could this be because of the padding? Can you explain to me why/how the cipher is resulted with this length? And always ends with =? 
Is my code correct or there is a mistake? I have doubts in the encoding part.</p>
","<p>The result of a DES encryption will always be a multiple of 8 bytes. The input is also padded to a multiple of 8 bytes according to the padding algorithm specified.</p>

<p>The base 64 encoding encodes each 3 bytes into 4 characters (3x8 = 4x6 = 24), and ensures the output length is a multiple of 4 by padding with = characters. </p>

<p>So, the 44 characters output corresponds to 33 bytes, but the = at the end indicates that in fact there were only 32 bytes. Which is fine, since 24 bytes clear data with PKCS5 padding becomes 32 bytes.</p>
","1764","<java><encryption><des><encryption-symmetric>","1","2","2","2013-10-21 20:55:35","19462861","0","2","815724","","2013-10-19 08:17:44","2013-10-19 05:21:14",""
"19464004","PyCrypto Decrypting Cipher text does no yield plaintext","<p>I was playing around PyCrypto's AES and DES implementation. Every time, I decrypted a cipher text, that I encrypted from a plain text, It gives out random strings.</p>

<p>I have tried the following:</p>

<pre><code>from Crypto.Cipher import AES,DES
from Crypto import Random

iv_AES = Random.new().read(AES.block_size)
iv_DES = Random.get_random_bytes(8)

key_AES = 'abcdefghijklmnop'
key_DES = 'abcdefgh'

aes = AES.new(key_AES,AES.MODE_CFB,iv_AES)
aes1 = AES.new(key_AES,AES.MODE_CFB,iv_AES)
des = DES.new(key_DES,DES.MODE_CFB,iv_DES)
des1 = DES.new(key_DES,DES.MODE_CFB,iv_DES)

plaintext = 'Hello! World'

print plaintext == aes.decrypt(aes.encrypt(plaintext))
print plaintext == des.decrypt(des.encrypt(plaintext))
print plaintext == aes1.decrypt(aes.encrypt(plaintext))
print plaintext == des1.decrypt(des.encrypt(plaintext))
</code></pre>

<p>Result: </p>

<pre><code>False
False
True
True
</code></pre>

<p>I don't understand why this is happening. </p>

<p>Can you please explain what is actually happening here, and why is it so?</p>
","<p>From the <a href=""https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html"" rel=""nofollow"">PyCrypto documentation</a>:</p>

<blockquote>
  <p>That also means that you cannot reuse an object for encrypting or decrypting other data with the same key.</p>
</blockquote>

<p>The issue is that you will have to reinitialize your cipher, or - probably better - to construct separate object instances for encryption and decryption.</p>

<pre><code>from Crypto.Cipher import AES,DES
from Crypto import Random

iv_AES = Random.new().read(AES.block_size)
iv_DES = Random.get_random_bytes(8)

key_AES = 'abcdefghijklmnop'
key_DES = 'abcdefgh'

aese = AES.new(key_AES,AES.MODE_CFB,iv_AES)
aesd = AES.new(key_AES,AES.MODE_CFB,iv_AES)
dese = DES.new(key_DES,DES.MODE_CFB,iv_DES)
desd = DES.new(key_DES,DES.MODE_CFB,iv_DES)

plaintext = 'Hello! World'

print plaintext == aesd.decrypt(aese.encrypt(plaintext))
print plaintext == desd.decrypt(dese.encrypt(plaintext))
</code></pre>
","1751","<python-2.7><aes><des><pycrypto>","0","1","1","2013-10-21 07:52:25","19480030","0","","1958893","","2013-10-19 08:36:18","2013-10-19 08:22:10",""
"10126269","encrypt data in T-SQL using DES (not triple) algorithm","<p>I need to encode some strings using DES (not triple DES - I know that there is many articles describing how to use NCRYPTBYPASSPHRASE command). I have key and IV.
How I can do it using T-SQL? Is there any ready to use procedure or function?</p>
","<p>Ripped from <a href=""http://msdn.microsoft.com/en-us/library/ms179331%28v=sql.90%29.aspx"" rel=""nofollow"">here</a>.  I haven't tested this, but <a href=""http://msdn.microsoft.com/en-us/library/ms345262%28v=sql.90%29.aspx"" rel=""nofollow"">this</a> page lists all of the encryption types and DES appears to be one of them.  </p>

<pre><code>--If there is no master key, create one now. 
IF NOT EXISTS 
    (SELECT * FROM sys.symmetric_keys WHERE symmetric_key_id = 101)
    CREATE MASTER KEY ENCRYPTION BY 
    PASSWORD = '23987hxJKL969#ghf0%94467GRkjg5k3fd117r$$#1946kcj$n44nhdlj'
GO

CREATE CERTIFICATE HumanResources037
   WITH SUBJECT = 'Employee Social Security Numbers';
GO

CREATE SYMMETRIC KEY SSN_Key_01
    WITH ALGORITHM = DES
    ENCRYPTION BY CERTIFICATE HumanResources037;
GO

-- Open the symmetric key with which to encrypt the data.
OPEN SYMMETRIC KEY SSN_Key_01
   DECRYPTION BY CERTIFICATE HumanResources037;

-- Encrypt the value 
SET @encrypted = EncryptByKey(Key_GUID('SSN_Key_01'), '555-77-4444');
</code></pre>
","1744","<tsql><des>","0","0","1","2012-04-12 21:34:17","","0","","","","","2012-04-12 15:01:06",""
"18691646","Why does the DES algorithm use 16 rounds?","<p>Can anyone tell me why the single DES (data encryption standard) algorithm uses 16 rounds? </p>

<p>Is there any reason to use 16 rounds other than for more security? </p>
","<p>I do not know specifically why the number 16 was chosen. However, one would surmise that <em>at that time</em>, cryptanalysis would have shown that 16 rounds provided an 'adequate' amount of security based on the performance tradeoff. That is to say that your ""more security"" statement would be correct.</p>

<p>Remember that less rounds means it is easier to brute-force because it takes less time and is less expensive to expand out the pipeline in dedicated hardware. More rounds on the other hand do make it harder to crack, but it is more computationally expensive across the board. This means that (especially in those days, remember DES dates back to the 1970s) it is more expensive/time-consuming - this means for the ""good guys"" (those who know the key and are legitimately using the cypher) too.</p>

<p>Therefore it is always important to find the ""right balance"" between performance and security. The most common guideline being ""by the time the cyphertext is cracked, the value of the encrypted information has decreased to a point where it does not matter"". That is, encryption will never protect data <em>forever</em> due to increasingly available computing power and diminishing costs, but it should be designed to last <em>long enough</em>.</p>
","1740","<security><des>","0","0","2","2013-09-09 05:08:32","","0","","369","","2013-09-09 04:59:29","2013-09-09 04:50:25",""
"18691646","Why does the DES algorithm use 16 rounds?","<p>Can anyone tell me why the single DES (data encryption standard) algorithm uses 16 rounds? </p>

<p>Is there any reason to use 16 rounds other than for more security? </p>
","<p>You would have to ask the designers, but the <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">wikipedia article</a> contains this quote:</p>

<blockquote>
  <p>There have also been attacks proposed against reduced-round versions of the cipher, that is, versions of DES with fewer than 16 rounds. Such analysis gives an insight into how many rounds are needed for safety, and how much of a ""security margin"" the full version retains. Differential-linear cryptanalysis was proposed by Langford and Hellman in 1994, and combines differential and linear cryptanalysis into a single attack. An enhanced version of the attack can break 9-round DES with 215.8 chosen plaintexts and has a 229.2 time complexity (Biham and others, 2002).</p>
</blockquote>

<p>Which suggests to me that 16 rounds was simply a tradeoff between security and performance.</p>

<p>The fact that 16 is a power of two could simplify things, also.</p>
","1740","<security><des>","0","0","2","2013-09-09 05:08:32","","0","","369","","2013-09-09 04:59:29","2013-09-09 04:50:25",""
"1116350","What is DES-X?","<p>What is DES-X?</p>

<p>And</p>

<p>DES-X and DES, are they backwards compatible?</p>
","<p>DES and DES-X are both block ciphers. 
See <a href=""http://en.wikipedia.org/wiki/DES-X"" rel=""nofollow noreferrer""><a href=""http://en.wikipedia.org/wiki/DES-X"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/DES-X</a></a>
for more details. In short, DES-X adds key whitening.</p>
","1730","<encryption><des>","0","0","4","2009-07-12 17:09:31","1116383","2","","2699","","2009-07-12 17:09:31","2009-07-12 16:21:00",""
"1116350","What is DES-X?","<p>What is DES-X?</p>

<p>And</p>

<p>DES-X and DES, are they backwards compatible?</p>
","<p><a href=""http://en.wikipedia.org/wiki/DES-X"" rel=""nofollow noreferrer"">Here</a>'s the wikipedia article on DES-X.  DES-X increases the key size by appending XOR'd versions of the key before and after the encryption.</p>
","1730","<encryption><des>","0","0","4","2009-07-12 17:09:31","1116383","2","","2699","","2009-07-12 17:09:31","2009-07-12 16:21:00",""
"1116350","What is DES-X?","<p>What is DES-X?</p>

<p>And</p>

<p>DES-X and DES, are they backwards compatible?</p>
","<p>Well, DES-X is a variant of the DES block cipher (as I'm sure you already knew).</p>

<p>The reason for the introduction of the DES-X was an attempt to increase the security of the original DES algorithm (which was limited to a 56bit key). The proposed solution with DEX-X was to use two more 64-bit keys which would be applied to make it harder for an attacker to guess the key of the DES algorithm. Basically, the first additional key is XORed to the plain text which is then encrypted with DES. The second additional key is XORed to the resulting cypher.</p>

<p>However, as far the backwards compatibility.. I'm not sure what you mean by that? If you're asking if you can use DES to decrypt DES-X messages then NO (it the strict sense). If you're asking whether a DES-X implementation could be configured to encrypt/decrypt DES messages then the answer is YES.</p>

<p>Here's an example:</p>

<pre>
    DES(msg) = CYPHER
    DES-X(msg) = K2 X DES(K1 x msg) = CYPER-X
</pre>

<p>If you choose K2 and K1 to be the all 0 then:</p>

<pre>
    DES-x(msg) = K2 x DES(K1 x msg) [where K1 = 0, K2 =0] = DES(msg)
</pre>

<p><em>It should be pointed out that what I mean by making K1 and K2 0 is actually choosing a key which is 64 bits of 0 = {0,0,0,0,0...0} (64 times). Such a key does not modify the plaintext of the cypher at all when the XOR operation is applied.</em></p>
","1730","<encryption><des>","0","5","4","2009-07-12 17:09:31","1116383","2","","2699","","2009-07-12 17:09:31","2009-07-12 16:21:00",""
"1116350","What is DES-X?","<p>What is DES-X?</p>

<p>And</p>

<p>DES-X and DES, are they backwards compatible?</p>
","<p>The summary of this paper says that DES-X is ""compatible.""  However, I'm not sure if that includes backwards-compatibility.</p>

<p><a href=""http://www.cs.ucdavis.edu/~rogaway/papers/cryptobytes.ps"" rel=""nofollow noreferrer"">http://www.cs.ucdavis.edu/~rogaway/papers/cryptobytes.ps</a></p>
","1730","<encryption><des>","0","0","4","2009-07-12 17:09:31","1116383","2","","2699","","2009-07-12 17:09:31","2009-07-12 16:21:00",""
"21039602","Creating 8 byte IV in Java","<p>Im new to cryptography in Java and I am trying to write a program to encrypt and decrypt a phrase using DES symmetric cipher, based on CBC mode of operation.</p>

<p>Can anyone tell me how to go about <strong>creating an 8-byte initialization vector</strong> and <strong>how to cast the new IV into AlgorithmParameterSpec class?</strong></p>

<p>Also, <strong>which packages should I import?</strong></p>

<p>Edit: Right now I have these lines:<pre><code>SecureRandom sr = new SecureRandom(); <strong>//create new secure random</strong>
byte [] iv = new byte[8]; <strong>//create an array of 8 bytes</strong> 
sr.nextBytes(iv); <strong>//create random bytes to be used for the IV (?) Not too sure.</strong>
IvParameterSpec IV = new IvParameterSpec(iv); <strong>//creating the IV</strong> </code></pre></p>

<p>Is my above approach correct?</p>

<p>Thanks.</p>
","<p>Yes. Till Now You are right.<br/>
the <code>Class IvParameterSpec</code> is used to pass Initial Vector to <code>Class Cipher</code><br/>
After this create a <code>Cipher</code> as below</p>

<pre><code>Cipher cipherInstance = Cipher.getInstance(""DES/CBC/NoPadding"");
</code></pre>

<p>here <code>DES/CBC/NoPadding</code> is used because you are useing <b>DES</b> encryption in <b>CBC</b> mode.<br/></p>

<p>Next is initializing it.</p>

<pre><code>cipherInstance.init(Cipher.DECRYPT_MODE, Key, ivParameterSpec);
</code></pre>

<p>Parameters are:<br/>
<b>1st is mode of encryption either <code>Cipher.DECRYPT_MODE</code> or <code>Cipher.ENCRYPT_MODE</code><br/>
2nd is Secret Key You have generated using <code>Class SecretKey</code><br/>
3rd is generated ivParameterSpec<br/></b></p>

<p>and last line is</p>

<pre><code>outData = cipherInstance.doFinal(input);
</code></pre>

<p>if mode is <b>Decrypt</b> it will return decrypted data and if mode is <b>Encrypt</b> it will return encrypted data.</p>

<p>Last but important catch all the <b>Exceptions</b> properly.<br/>
And you are done</p>
","1714","<java><des><cbc-mode>","1","0","1","2014-01-10 11:40:45","21043423","5","3","2298700","","2014-01-10 11:16:46","2014-01-10 08:45:03",""
"4004886","Encrypt with PHP and Decrypt with Java","<p>I have to write a program to decrypt a message using JAVA. The message is encrypted using Triple DES / ECB implemented in PHP. I have tried a few different settings on the algorithm, mode, and padding schema. I do not get the correct result. What is missing? </p>

<p>Here is the PHP program that encrypt the message:</p>

<pre><code>$config_mcrypt_ecb_key = ""12345678901234567890"";
$data = ""hello"";
echo ""Data Before Encrypt: "" . $data . ""\n"";
$td = mcrypt_module_open('tripledes', '', 'ecb', '');
$iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_ENCRYPT);
mcrypt_generic_init($td, $config_mcrypt_ecb_key, $iv);
$data_encrypt = bin2hex(mcrypt_generic($td, $data));
mcrypt_generic_deinit($td);
mcrypt_module_close($td);
echo ""Data After Encrypt: "" . $data_encrypt . ""\n"";
</code></pre>

<p>And below is the java program to decrypt the message: (I'm using the BouncyCastleProvider)</p>

<pre><code>import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;

public class DecryptionTest {
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException {
        String password = ""12345678901234567890"";
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        SecretKeySpec key = new SecretKeySpec(password.getBytes(), ""ECB"");
        Cipher m_decrypter = Cipher.getInstance(""DESede/ECB/ZeroBytePadding"");
        m_decrypter.init(Cipher.DECRYPT_MODE, key);
        byte[] decryptedText = m_decrypter.doFinal(""bdf0baf948bff7e7"".getBytes());
        System.out.println(new String(decryptedText));
    }
}
</code></pre>
","<p>You don't seem to be using an IV (Initialisation Vector) when performing the decrypt.  My understanding is that <code>mcrypt_create_iv()</code> will generate a random IV, so you need to store that with the encrypted data so that it can be used when decrypting.</p>

<p>Alternatively (if you're happy with using a weaker encryption) omit the IV from your PHP side. </p>
","1710","<encryption><mcrypt><jce><des><ecb>","2","0","1","2010-11-01 07:29:25","","0","3","","","","2010-10-23 16:14:20",""
"6855054","Question about DES encryption in python","<p>I am trying to create an LM/NTLM response for which I require encrypting the challenge sent by server using DES algorithm</p>

<p>The following is what I did:</p>

<pre><code>from M2Crypto.EVP import Cipher

def encryptChallenge(magic, key):  
    str_key = """"  
    for iter1 in key:  
        str_key = str_key + chr(iter1)  

    encrypt = 1
    cipher = Cipher(alg='des_ede_ecb', key=str_key, op=encrypt, iv='\0'*16)
    ciphertext = cipher.update(magic)
    ciphertext += cipher.final()

    return ciphertext
</code></pre>

<p>However when I try encrypting <code>""\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f""</code> using DES, I get the following result:</p>

<p>Key used to encrypt: <code>['0xfe', '0x9b', '0xd5', '0x16', '0xcd', '0x15', '0xc8', '0x49']</code></p>

<p>Challenge after encryption:</p>

<pre><code> Encrypted_server_challenge_using_key_1 : ['0x66', '0xf7', '0xa', '0xf8', '0xda', '0x4e', '0x7', '0xaa', '0x65', '0xc3', '0x8d', '0xaa', '0x48', '0xcc', '0x67', '0x57', '0xe2', '0xb0', '0x6e', '0x10', '0xb', '0x5e', '0xdd', '0xb4']
</code></pre>

<p>The above response was not accepted by the server</p>

<p>Tried using a tool called DEScalc.jar (http://www.unsw.adfa.edu.au/~lpb/src/DEScalc/index.html) and found that the encrypted result is: </p>

<pre><code>setKey(fe9bd516cd15c849)
encryptDES(0123456789abcdef)
  IP:   L0=cc00ccff, R0=f0aaf0aa
  Rnd1  f(R0=f0aaf0aa, SK1=0b 2c 23 12 33 1c 2b 09 ) = 988995a0
  Rnd2  f(R1=5489595f, SK2=21 15 0d 11 1c 1a 3b 38 ) = 63200664
  Rnd3  f(R2=938af6ce, SK3=01 35 2f 05 3e 19 30 1f ) = c206c318
  Rnd4  f(R3=968f9a47, SK4=06 37 07 01 03 37 1a 3e ) = bdf738ef
  Rnd5  f(R4=2e7dce21, SK5=06 14 17 29 0f 17 27 25 ) = 76c68d3d
  Rnd6  f(R5=e049177a, SK6=34 14 06 0d 28 2c 23 37 ) = c182a1c7
  Rnd7  f(R6=efff6fe6, SK7=04 18 2e 05 31 3a 3e 17 ) = c3e45497
  Rnd8  f(R7=23ad43ed, SK8=04 13 22 27 2f 30 1f 19 ) = 4977a92c
  Rnd9  f(R8=a688c6ca, SK9=12 0a 38 0c 3d 33 19 26 ) = 4975507e
  Rnd10 f(R9=6ad81393, SK10=10 0b 30 1e 1f 08 2f 2e ) = d52a9361
  Rnd11 f(R10=73a255ab, SK11=19 0a 31 22 05 0f 33 1f ) = 38b2a619
  Rnd12 f(R11=526ab58a, SK12=38 2e 30 22 1b 3b 13 31 ) = e9dec064
  Rnd13 f(R12=9a7c95cf, SK13=3a 0a 1c 12 2a 3e 35 2b ) = d88ee399
  Rnd14 f(R13=8ae45613, SK14=19 09 18 1b 0b 2d 3c 16 ) = 9de6ddb2
  Rnd15 f(R14=079a487d, SK15=19 39 01 12 37 14 17 36 ) = 5fb60a90
  Rnd16 f(R15=d5525c83, SK16=24 05 0d 39 31 1f 2d 34 ) = 6a40b6ea
  FP:   L=c337cd5c, R=bd44fc97
 returns c337cd5cbd44fc97
</code></pre>

<p>Noticed that the above result is accepted by the server</p>

<p>Is there a specific algorithm that is used by DEScalc.jar which I am missing, because of which I don't get the results obtained by DEScalc.jar</p>

<hr>

<p>Hi Everyone,
                 Thanks a lot for your help; The issue was with the way I represented the hexadecimal in python; I used the following function to convert ""0123456789abcdef"" to hex representation as Keith mentioned and it worked:</p>

<pre><code>def HexToByte( hexStr ):
    """"""
    Convert a string hex byte values into a byte string. The Hex Byte values may
    or may not be space separated.
    """"""
    # The list comprehension implementation is fractionally slower in this case    
    #
    #    hexStr = ''.join( hexStr.split("" "") )
    #    return ''.join( [""%c"" % chr( int ( hexStr[i:i+2],16 ) ) \
    #                                   for i in range(0, len( hexStr ), 2) ] )

    bytes = []

    hexStr = ''.join( hexStr.split("" "") )

    for i in range(0, len(hexStr), 2):
        bytes.append( chr( int (hexStr[i:i+2], 16 ) ) )

    return ''.join( bytes )
</code></pre>

<p>Thanks a lot</p>
","<p>Are you sure you need to use DES-EDE-ECB?</p>

<p>EDE means that you're actually using Triple DES: you run DES three times (with three different keys), and EDE means that you encrypt-decrypt-encrypt (each time with a different key).</p>

<p>But it sounds like you should just be using plain DES ('des_ecb').</p>
","1709","<python><des>","0","0","2","2011-07-28 10:05:46","","1","","866779","","2011-07-28 10:05:46","2011-07-28 06:50:06",""
"6855054","Question about DES encryption in python","<p>I am trying to create an LM/NTLM response for which I require encrypting the challenge sent by server using DES algorithm</p>

<p>The following is what I did:</p>

<pre><code>from M2Crypto.EVP import Cipher

def encryptChallenge(magic, key):  
    str_key = """"  
    for iter1 in key:  
        str_key = str_key + chr(iter1)  

    encrypt = 1
    cipher = Cipher(alg='des_ede_ecb', key=str_key, op=encrypt, iv='\0'*16)
    ciphertext = cipher.update(magic)
    ciphertext += cipher.final()

    return ciphertext
</code></pre>

<p>However when I try encrypting <code>""\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f""</code> using DES, I get the following result:</p>

<p>Key used to encrypt: <code>['0xfe', '0x9b', '0xd5', '0x16', '0xcd', '0x15', '0xc8', '0x49']</code></p>

<p>Challenge after encryption:</p>

<pre><code> Encrypted_server_challenge_using_key_1 : ['0x66', '0xf7', '0xa', '0xf8', '0xda', '0x4e', '0x7', '0xaa', '0x65', '0xc3', '0x8d', '0xaa', '0x48', '0xcc', '0x67', '0x57', '0xe2', '0xb0', '0x6e', '0x10', '0xb', '0x5e', '0xdd', '0xb4']
</code></pre>

<p>The above response was not accepted by the server</p>

<p>Tried using a tool called DEScalc.jar (http://www.unsw.adfa.edu.au/~lpb/src/DEScalc/index.html) and found that the encrypted result is: </p>

<pre><code>setKey(fe9bd516cd15c849)
encryptDES(0123456789abcdef)
  IP:   L0=cc00ccff, R0=f0aaf0aa
  Rnd1  f(R0=f0aaf0aa, SK1=0b 2c 23 12 33 1c 2b 09 ) = 988995a0
  Rnd2  f(R1=5489595f, SK2=21 15 0d 11 1c 1a 3b 38 ) = 63200664
  Rnd3  f(R2=938af6ce, SK3=01 35 2f 05 3e 19 30 1f ) = c206c318
  Rnd4  f(R3=968f9a47, SK4=06 37 07 01 03 37 1a 3e ) = bdf738ef
  Rnd5  f(R4=2e7dce21, SK5=06 14 17 29 0f 17 27 25 ) = 76c68d3d
  Rnd6  f(R5=e049177a, SK6=34 14 06 0d 28 2c 23 37 ) = c182a1c7
  Rnd7  f(R6=efff6fe6, SK7=04 18 2e 05 31 3a 3e 17 ) = c3e45497
  Rnd8  f(R7=23ad43ed, SK8=04 13 22 27 2f 30 1f 19 ) = 4977a92c
  Rnd9  f(R8=a688c6ca, SK9=12 0a 38 0c 3d 33 19 26 ) = 4975507e
  Rnd10 f(R9=6ad81393, SK10=10 0b 30 1e 1f 08 2f 2e ) = d52a9361
  Rnd11 f(R10=73a255ab, SK11=19 0a 31 22 05 0f 33 1f ) = 38b2a619
  Rnd12 f(R11=526ab58a, SK12=38 2e 30 22 1b 3b 13 31 ) = e9dec064
  Rnd13 f(R12=9a7c95cf, SK13=3a 0a 1c 12 2a 3e 35 2b ) = d88ee399
  Rnd14 f(R13=8ae45613, SK14=19 09 18 1b 0b 2d 3c 16 ) = 9de6ddb2
  Rnd15 f(R14=079a487d, SK15=19 39 01 12 37 14 17 36 ) = 5fb60a90
  Rnd16 f(R15=d5525c83, SK16=24 05 0d 39 31 1f 2d 34 ) = 6a40b6ea
  FP:   L=c337cd5c, R=bd44fc97
 returns c337cd5cbd44fc97
</code></pre>

<p>Noticed that the above result is accepted by the server</p>

<p>Is there a specific algorithm that is used by DEScalc.jar which I am missing, because of which I don't get the results obtained by DEScalc.jar</p>

<hr>

<p>Hi Everyone,
                 Thanks a lot for your help; The issue was with the way I represented the hexadecimal in python; I used the following function to convert ""0123456789abcdef"" to hex representation as Keith mentioned and it worked:</p>

<pre><code>def HexToByte( hexStr ):
    """"""
    Convert a string hex byte values into a byte string. The Hex Byte values may
    or may not be space separated.
    """"""
    # The list comprehension implementation is fractionally slower in this case    
    #
    #    hexStr = ''.join( hexStr.split("" "") )
    #    return ''.join( [""%c"" % chr( int ( hexStr[i:i+2],16 ) ) \
    #                                   for i in range(0, len( hexStr ), 2) ] )

    bytes = []

    hexStr = ''.join( hexStr.split("" "") )

    for i in range(0, len(hexStr), 2):
        bytes.append( chr( int (hexStr[i:i+2], 16 ) ) )

    return ''.join( bytes )
</code></pre>

<p>Thanks a lot</p>
","<p>The problem here is in your source (plaintext) string. You have each character expanded to two bytes, instead of one byte. The Java program will take the input ""0123456789abcdef"", and use internally the hex string of that. Using pycrypto and a properly encoded plaintext I get this.</p>

<pre><code>Python2&gt; from Crypto.Cipher import DES
Python2&gt; key
'\xfe\x9b\xd5\x16\xcd\x15\xc8I'
Python2&gt; pw
'\x01#Eg\x89\xab\xcd\xef'
Python2&gt; eng = DES.new(key, DES.MODE_ECB, ""\0""*8)
Python2&gt; hexdigest(eng.encrypt(pw))
'c337cd5cbd44fc97'
</code></pre>

<p>Which you can see is the same as the Java code.</p>
","1709","<python><des>","0","1","2","2011-07-28 10:05:46","","1","","866779","","2011-07-28 10:05:46","2011-07-28 06:50:06",""
"21341794","Data Encryption Standard test vectors","<p>Does anyone know where I can find test vectors for every component of 64bit DES algorithm(Key schedul, cipher function, etc)? For example I want to test 64bits key generation and to ckeck all 16 key generated. I am implementing the algorithm in VHDL so I need to check the comonents. My implementation is based on this <a href=""http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf"" rel=""nofollow"">paper</a>.</p>

<p>Thanks</p>
","<p>Originally there was NBS Special Publication 500-20, revised in 1980, Validating the Correctness of Hardware Implementations of the NBS Data Encryption Standard (The author has made it available at <a href=""https://archive.org/details/validatingcorrec00gait"" rel=""nofollow noreferrer"">https://archive.org/details/validatingcorrec00gait</a> ).</p>

<p>Then there is NIST Special PUB 800-17, Modes of Operation Validation System (MOVS):
Requirements and Procedures, covering FIPS PUB 46-2 (DES) as well as Skipjack. <a href=""http://csrc.nist.gov/publications/nistpubs/800-17/800-17.pdf"" rel=""nofollow noreferrer"">http://csrc.nist.gov/publications/nistpubs/800-17/800-17.pdf</a> .</p>

<p>There's also NIST Special PUB 800-20, Modes of Operation Validation System for the Triple Data Encryption Algorithm (TMOVS): Requirements and Procedures. <a href=""http://csrc.nist.gov/publications/nistpubs/800-20/800-20.pdf"" rel=""nofollow noreferrer"">http://csrc.nist.gov/publications/nistpubs/800-20/800-20.pdf</a> .</p>

<p>There may be other publications such as NIST Special Publication 800-67, Recommendation for the TripleData Encryption Algorithm (TDEA) Block Cipher, <a href=""http://csrc.nist.gov/publications/nistpubs/800-67-Rev1/SP-800-67-Rev1.pdf"" rel=""nofollow noreferrer"">http://csrc.nist.gov/publications/nistpubs/800-67-Rev1/SP-800-67-Rev1.pdf</a>, found at  <a href=""http://csrc.nist.gov/publications/PubsSPs.html"" rel=""nofollow noreferrer"">http://csrc.nist.gov/publications/PubsSPs.html</a> .</p>

<p>Having implemented DES numerous times in software and a couple of times in VHDL, it's in understanding that the DES standard originally described conformance to the hardware implementation patented by IBM in 1977. (see <a href=""https://www.dropbox.com/s/abjv929qo0kb90o/vhdl_des.tar.gz?dl=1"" rel=""nofollow noreferrer"">vhdl_des.tar.gz</a>, which is a simple implementation with an 8 bit interface.  There's a pdf file than includes a description of the I/O permutations.)</p>

<p>To save you the typing the test vectors from FIPS SP PUB 500-20 can be found here <a href=""https://www.dropbox.com/s/y72k3blly9b4j9w/des.test?dl=1"" rel=""nofollow noreferrer"">des.test</a>.   There may be a parity error in one of the keys, I can never keep track of which of these files is where (des -tv &lt; des.test, a software implementation).  Someone laboriously typed them in by hand from Numerical Recipes in C, where someone had gotten them from 500-20.</p>
","1704","<vhdl><des>","1","5","2","2017-07-16 12:20:15","21342945","0","","","","","2014-01-24 20:22:26",""
"21341794","Data Encryption Standard test vectors","<p>Does anyone know where I can find test vectors for every component of 64bit DES algorithm(Key schedul, cipher function, etc)? For example I want to test 64bits key generation and to ckeck all 16 key generated. I am implementing the algorithm in VHDL so I need to check the comonents. My implementation is based on this <a href=""http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf"" rel=""nofollow"">paper</a>.</p>

<p>Thanks</p>
","<p><a href=""https://styere.000webhostapp.com/JS-DES.html"" rel=""nofollow noreferrer"">https://styere.000webhostapp.com/JS-DES.html</a> (new link)</p>

<p>Enter key and data and it generates all intermediate values, for every step of the key schedule and for every step within every round.</p>
","1704","<vhdl><des>","1","0","2","2017-07-16 12:20:15","21342945","0","","","","","2014-01-24 20:22:26",""
"14456590","Store encrypted password in mysql and decrypt while fetching","<p>I am using <code>DES_ENCRYPT</code> method to store password to MySQL. This is working, but when I retrieve by <code>DES_DECRYPT</code> I get the HTML character references for certain symbols. For example I stored <code>&amp;</code> by encrypting, but while decrypting I get <code>&amp;amp;</code>. How to handle this so that I only get <code>&amp;</code> after decryption and not <code>&amp;amp;</code> If there is any other better direct method i can use that but in either case I need the real password stored.</p>
","<p>As @Carlos said <code>phpmyadmin</code> is probably html-encoding the html entities before showing is true. This is true. There is no problem with the function. When i decrypt from outside <code>phpmyadmin</code> the password is decrypted properly. I made the mistake earlier i tried to directly do it from the admin panel and now i am running it from the script outside the admin panel.</p>
","1681","<java><mysql><sql><des><password-encryption>","0","0","1","2013-02-07 04:43:38","14743710","8","","40342","","2013-01-22 14:27:04","2013-01-22 10:37:45",""
"31188313","How do I decrypt something encrypted with cbc_encrypt (Linux GCC)","<p>I want to do an encryption / decryption program in C based on something I did in perl. The compiled perl program is 2MB so I figure if I write it in C it will be a smaller executable size.</p>

<p>My problem is, while I get it to encrypt, I can't get it to decrypt. It's been literally ages since I last used C so I forgot a lot of stuff. Someone please enlighten me to what I'm doing wrong here? Thanks.</p>

<pre><code>/*
    ============================================================================
    Name        : test-c.c
    Description : Testing Project
                  Trying to do a C version of this perl code:
                    my $cipher = Crypt::CBC-&gt;new( -key =&gt; $salt_key, -cipher =&gt; 'DES' -header =&gt; 'none');
                    my $enc_text = $cipher-&gt;encrypt_hex($text);
    Requires    : -lcrypt
    References  :
      Function: cbc_crypt (char *key, char *blocks, unsigned len, unsigned mode, char *ivec)
      GNU C Library: DES Encryption (http://www.gnu.org/software/libc/manual/html_node/DES-Encryption.html#DES-Encryption)
      cbc_crypt (http://unix.derkeiler.com/Newsgroups/comp.unix.programmer/2012-10/msg00023.html)
    ============================================================================
    */

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;
    #include &lt;rpc/des_crypt.h&gt;

    int main(void) {
        char key[]     = ""aBcDeFg1"";
        char pass[]    = ""mypass1234test"";
        char encbuff[] = ""87654321"";
        char decbuff[] = ""87645321"";
        int buffsize;
        int result;

        des_setparity(key);

        /* Encrypt pass, result is in encbuff */
        buffsize = sizeof(pass);
        /* Add to pass to ensure size is divisable by 8. */
        while (buffsize % 8) {
            pass[buffsize++] = '\0';
        }

        printf(""Encrypted: "");
        result = cbc_crypt(key, pass, buffsize, DES_ENCRYPT | DES_SW, encbuff);
        if (DES_FAILED(result) || strcmp(encbuff, """") == 0) {
            if(strcmp(encbuff, """") == 0) {
                printf(""*** Null Output ***\n"");
            } else {
                printf(""*** Encryption Error ***\n"");
            }
        } else {
            printf(""%s\n"", encbuff);
        }

        /* Decrypt encbuff, result is in decbuff */

        /* FIXME: Decryption doesn't work:
            Encrypted: ,ï¿½7&amp;ï¿½ï¿½ï¿½8
            Decrypted: *** Decryption Error ***
        */
        buffsize = sizeof(encbuff);
        /* Add to pass to ensure size is divisable by 8. */
        while (buffsize % 8) {
            encbuff[buffsize++] = '\0';
        }

        printf(""Decrypted: "");
        result = cbc_crypt(key, encbuff, buffsize, DES_DECRYPT | DES_SW, decbuff);
        if(DES_FAILED(result) || strcmp(decbuff, """") == 0) {
            if(strcmp(encbuff, """") == 0) {
                printf(""*** Null Output ***\n"");
            } else {
                printf(""*** Decryption Error ***\n"");
            }
        } else {
            printf(""%s\n"", decbuff);
        }

        return 0;
    }
</code></pre>
","<p>As noticed by @Brian_Sidebotham , using <code>char str[10];buffsize=sizeof(str);...str[buffsize++]='\0'</code> is not a good thing in c. Writing beyond the end of an array may trigger undefined behavior. It could work or deliver wrong results or stop due to a segmentation fault. So the first thing to do is to work with larger buffers. For instance :</p>

<pre><code>char key[9];
sprintf(key,""12345678"");

char password[420];
sprintf(password,""i am not going to write my password here."");
</code></pre>

<p>Notice that it is 9, not 8, to leave some place for the null terminating character <code>\0</code> that is automatically added by <code>sprintf()</code> to build a valid c string. </p>

<p>Moreover, the last parameter of <a href=""http://linux.die.net/man/3/cbc_crypt"" rel=""nofollow noreferrer""><code>cbc_crypt()</code></a> is not the output. It is not the encrypted string but an 8-byte initialization vector for the chaining. That way, if you need to encrypt multiple strings, it prevents regularities in the clear text from appearing in the cipher text. As the cipher text is to be decrypted, the same initialization vector must be provided. Encryption is performed in place : the input string <code>pass</code> will be overwritten by the encrypted text.</p>

<p>Finally, make sure that your strings are large enough because the encrypted text seems to be slightly larger that the clear text.</p>

<p>The following code is expected to work. It is compiled by <code>gcc main.c -o main</code></p>

<pre><code>/*
    ============================================================================
    Name        : test-c.c
    Description : Testing Project
                  Trying to do a C version of this perl code:
                    my $cipher = Crypt::CBC-&gt;new( -key =&gt; $salt_key, -cipher =&gt; 'DES' -header =&gt; 'none');
                    my $enc_text = $cipher-&gt;encrypt_hex($text);
    Requires    : -lcrypt
    References  :
      Function: cbc_crypt (char *key, char *blocks, unsigned len, unsigned mode, char *ivec)
      GNU C Library: DES Encryption (http://www.gnu.org/software/libc/manual/html_node/DES-Encryption.html#DES-Encryption)
      cbc_crypt (http://unix.derkeiler.com/Newsgroups/comp.unix.programmer/2012-10/msg00023.html)
    ============================================================================
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;rpc/des_crypt.h&gt;

#define BUFFSIZE 420
int main(void) {
    //  char key[]     = ""aBcDeFg1"";
    char key[9];
    sprintf(key,""aBcDeFg1"");
    //char pass[]    = ""mypass1234test"";
    char pass[BUFFSIZE];
    sprintf(pass,""mypass1234test"");

    //  char encbuff[] = ""87654321"";
    char ivec[9];
    sprintf(ivec,""87654321"");
    //  char decbuff[] = ""87645321"";
    char ivectemp[9];
    strcpy(ivectemp,ivec);
    int buffsize;
    int result;

    des_setparity(key);

    /* Encrypt pass, result is in encbuff */
    buffsize = strlen(pass);
    printf(""buffsize is %d\n"",buffsize);
    /* Add to pass to ensure size is divisable by 8. */
    while (buffsize % 8 &amp;&amp; buffsize&lt;BUFFSIZE) {
        pass[buffsize++] = '\0';
    }
    printf(""pass is %s\n"",pass);
    printf(""buffsize is %d\n"",buffsize);
    printf(""Encrypted: "");
    result = cbc_crypt(key, pass, buffsize, DES_ENCRYPT | DES_SW, ivectemp);
    if (DES_FAILED(result) || strcmp(pass, """") == 0) {
        if(strcmp(pass, """") == 0) {
            printf(""*** Null Output ***\n"");
        } else {
            printf(""*** Encryption Error ***\n"");
        }
    } else {
        printf(""%s\n"", pass);
    }

    /* Decrypt encbuff, result is in decbuff */

    /* FIXME: Decryption doesn't work:
            Encrypted: ,ï¿½7&amp;ï¿½ï¿½ï¿½8
            Decrypted: *** Decryption Error ***
     */
    buffsize = strlen(pass);
    printf(""buffsize is %d\n"",buffsize);
    /* Add to pass to ensure size is divisable by 8. */
    while (buffsize % 8 &amp;&amp; buffsize&lt;BUFFSIZE) {
        pass[buffsize++] = '\0';
    }
    printf(""buffsize is %d\n"",buffsize);
    printf(""Decrypted: "");
    //keeping the same initialization vector for decrypting, encrypt has altered ivectemp
    strcpy(ivectemp,ivec);
    result = cbc_crypt(key, pass, buffsize, DES_DECRYPT | DES_SW, ivectemp);
    if(DES_FAILED(result) || strcmp(pass, """") == 0) {
        if(strcmp(pass, """") == 0) {
            printf(""*** Null Output ***\n"");
        } else {
            printf(""*** Decryption Error ***\n"");
        }
    } else {
        printf(""%s\n"",pass);
    }

    return 0;
}
</code></pre>

<p>Now... A few words about security... According to the <a href=""https://fr.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow noreferrer"">wikipedia page about the Data Encryption Standard NBS DES</a> :</p>

<blockquote>
  <p>DES is now considered to be insecure for many applications. This is mainly due to the 56-bit key size being too small; in January, 1999, distributed.net and the Electronic Frontier Foundation collaborated to publicly break a DES key in 22 hours and 15 minutes</p>
</blockquote>

<p>You may switch to the implementation of <a href=""https://fr.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a> by the openssl library for instance. See <a href=""https://stackoverflow.com/questions/9889492/how-to-do-encryption-using-aes-in-openssl"">How to do encryption using AES in Openssl</a> or <a href=""https://stackoverflow.com/questions/19889740/simple-aes-encryption-decryption-with-openssl-library-in-c"">Simple AES encryption decryption with openssl library in C</a> or <a href=""https://stackoverflow.com/questions/18152913/aes-aes-cbc-128-aes-cbc-192-aes-cbc-256-encryption-decryption-with-openssl-c"">AES (aes-cbc-128, aes-cbc-192, aes-cbc-256) encryption/decryption with openssl C</a> for instance.</p>
","1621","<c><gcc><encryption><des>","3","0","1","2015-07-02 16:58:09","31190517","2","1","1816580","","2015-07-02 15:43:09","2015-07-02 15:08:50",""
"23254181","DES Encryption and decryption of hex using hex key python","<p>How can I encrypt and decrypt hex text using 8 byte hex key using DES algorithm in python?</p>

<p>I have a hex text <code>0x3a3456abcd4ff5cd</code> to encrypt with hex keys so how can I convert these values to equivalent strings so that I can use existing libraries to work with them.</p>

<p>Here's what I've tried, but it represents 8 byte key to equivalent 13 byte string:</p>

<pre><code>from Crypto.Cipher import DES
text =(unichr(4).decode('utf-8')*8).encode('utf-8')

key1=(unichr(0x46)+unichr(0xb2)+unichr(0xc8)+unichr(0xb6)+unichr(0x28)+unichr(0x18)+unichr(0xf8)+unichr(0x84)).encode('utf-8')

key2=(unichr(0x4a)+unichr(0x5a)+unichr(0xa8)+unichr(0xd0)+unichr(0xba)+unichr(0x30)+unichr(0x58)+unichr(0x5a)).encode('utf-8')

des = DES.new(key1,DES.MODE_ECB)
cipher_text = des.encrypt(plain_text)
print 'the cipher text is ', cipher_text

des = DES.new(key2,DES.MODE_ECB)
print 'the decrypted text is: ', des.decrypt(cipher_text)
</code></pre>
","<p>To use the two keys in your example, assign them like this:</p>

<pre><code>key1 = '\x46\xb2\xc8\xb6\x28\x18\xf8\x84'

key2 = '\x4a\x5a\xa8\xd0\xba\x30\x58\x5a'
</code></pre>

<p>This will keep the keys at 8 bytes each, allowing you to use them in <code>DES.new</code>.</p>
","1583","<python><hex><des><pycrypto>","0","0","1","2018-06-26 09:02:06","","4","","1033581","","2018-06-26 09:02:06","2014-04-23 20:06:05",""
"5257870","DES. Weak Keys!","<p>I've been reading through the DES standard and part of the standard mentioned the bit parity &amp; weak keys. So I've been wondering about the merits of weak keys and their side affects. Some example of weakly formed keys were represented in Hexadecimal format. So part of my assessment relating to weak keys that the repetition of the same 8bit/4bit/2bit groupings throughout a key are classifiable as weak keys! Are my conclusions correct?</p>
","<p>Yes. For example classic weak key is <code>0x0101010101010101</code>. Problem with the selected permutations. <a href=""http://en.wikipedia.org/wiki/Weak_key"" rel=""nofollow"">Here is the detailed explanation.</a></p>
","1575","<c++><c><des>","2","4","1","2011-03-10 09:54:05","5257949","3","","","","","2011-03-10 09:47:15",""
"29129256","Java: DES/ECB encryption always results in same ciphertext","<p>I've recently wrote a simple java application experimenting with ECB CBC modes of encryption and I've noticed something strange with how my code works. For some reason my resulting ciphertext will always result in the same string of characters, and I am noticing very little difference in the resulting ciphertext between the ECB and CBC modes. I am unsure if this is normal behavior so if anyone could shed some light on this I would greatly appreciate it.</p>

<pre><code>import java.security.*;
import java.util.Scanner;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;

public class MainApp
{
    static Scanner sc = new Scanner(System.in);
    public KeyGenerator keygen;
    public SecretKey secKey;
    Cipher c;

    static SecureRandom rnd = new SecureRandom();
    static IvParameterSpec iv = new IvParameterSpec(rnd.generateSeed(8));

    public static void main(String[] args) throws Exception
    {
        MainApp theApp = new MainApp();
        theApp.start();
    }

    public void start() throws Exception
    {
        keygen = KeyGenerator.getInstance(""DES"");
        secKey = keygen.generateKey();

        System.out.println(secKey);

        boolean success = false;
        boolean success2 = false;
        boolean exit = false;
        int type = 0;

        do
        {
            do 
            {
                System.out.println(""Weclome to the DES Encryption/Decription zone!"");
                System.out.println(""What form of mode do you wish to use? [E]CB or [C]BC? Type [Q]uit to exit"");
                String input = sc.nextLine();

                    if(input.equalsIgnoreCase(""e"")){

                        type = 1;

                        do{
                            System.out.println(""Do you wish to use padding? [Y]es or [N]o?"");
                            input = sc.nextLine();

                            if(input.equalsIgnoreCase(""y"")){
                                c = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
                                success = true;
                                success2 = true;
                            }
                            else if(input.equalsIgnoreCase(""n"")){
                                c = Cipher.getInstance(""DES/ECB/NoPadding"");
                                success = true;
                                success2 = true;
                            }
                            else{
                                System.out.println(""Error - please enter a valid input"");
                                success = false;
                                success2 = false;
                            }
                        }while(!success2);

                    }
                    else if(input.equalsIgnoreCase(""c"")){

                        type = 2;

                        do{
                            System.out.println(""Do you wish to use padding? [Y]es or [N]o?"");
                            input = sc.nextLine();

                            if(input.equalsIgnoreCase(""y"")){
                                c = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
                                success = true;
                                success2 = true;
                            }
                            else if(input.equalsIgnoreCase(""n"")){
                                c = Cipher.getInstance(""DES/CBC/NoPadding"");
                                success = true;
                                success2 = true;
                            }
                            else{
                                System.out.println(""Error - please enter a valid input"");
                                success = false;
                                success2 = false;
                            }
                        }while(!success2);
                    }

                    else if(input.equalsIgnoreCase(""q"")){
                        System.out.println(""Thanks for using me!"");
                        System.exit(0);
                        success = true;
                        exit = true;
                    }
                    else{
                        System.out.println(""Error - please enter a valid input"");
                        success = false;
                    }
            }while(!success);


            System.out.println(""Input what you wish to encrypt"");
            String input = sc.nextLine();

            byte[] text = input.getBytes();

            System.out.println(type);

            System.out.println(""--------------------------------------------"");

            System.out.println(""Text : "" + new String(text));

            byte[] textEncrypted = encrypt(text, c, type);

            System.out.println(""Text Encrypted : "" + textEncrypted);

            byte[] textDecrypted = decrypt(textEncrypted, c, type);

            System.out.println(""Text Decrypted : "" + new String(textDecrypted));

            System.out.println(""--------------------------------------------"");

        }while(!exit);
    }

    public byte[] encrypt(byte[] b, Cipher c, int type) throws Exception
    {
        if(type == 1)
        {
        c.init(Cipher.ENCRYPT_MODE, secKey);
        }
        else if(type == 2)
        {   
            c.init(Cipher.ENCRYPT_MODE, secKey, iv);
        }
        byte[] encryptedText = null;
        try {
            encryptedText = c.doFinal(b);
        } catch (IllegalBlockSizeException e) {
            System.out.println(""ERROR - If you have selected to not automatically pad your plaintext it must be a mutiple of eight bytes to be accepted. Exiting program"");
            System.exit(0);
        } 

        return encryptedText;
    }

    public byte[] decrypt(byte[] b, Cipher c, int type) throws Exception
    {
        if(type == 1)
        {
        c.init(Cipher.DECRYPT_MODE, secKey);
        }
        else if(type == 2)
        {   
            c.init(Cipher.DECRYPT_MODE, secKey, iv);
        }

        byte[] decryptedText = c.doFinal(b);

        return decryptedText;

    }


}
</code></pre>

<p>Edit: Here is an example of my application output. On closer inspection it seems to cycle through a collection of a few different results occasionally, but I can tell they are being repeated for some reason. I've seen [B@3b2bad06 appear as the ciphertext before as well as [B@306c8343.</p>

<pre><code>com.sun.crypto.provider.DESKey@184ba
Weclome to the DES Encryption/Decription zone!
What form of mode do you wish to use? [E]CB or [C]BC? Type [Q]uit to exit
e
Do you wish to use padding? [Y]es or [N]o?
y
Input what you wish to encrypt
testtext
1
--------------------------------------------
Text : testtext
Text Encrypted : [B@2aa75818
Text Encrypted : [B@2aa75818
Text Decrypted : testtext
--------------------------------------------
Weclome to the DES Encryption/Decription zone!
What form of mode do you wish to use? [E]CB or [C]BC? Type [Q]uit to exit
e
Do you wish to use padding? [Y]es or [N]o?
y
Input what you wish to encrypt
testtext
1
--------------------------------------------
Text : testtext
Text Encrypted : [B@5088a588
Text Encrypted : [B@5088a588
Text Decrypted : testtext
--------------------------------------------
Weclome to the DES Encryption/Decription zone!
What form of mode do you wish to use? [E]CB or [C]BC? Type [Q]uit to exit
e
Do you wish to use padding? [Y]es or [N]o?
y
Input what you wish to encrypt
sometext
1
--------------------------------------------
Text : sometext
Text Encrypted : [B@3b2bad06
Text Encrypted : [B@3b2bad06
Text Decrypted : sometext
--------------------------------------------
Weclome to the DES Encryption/Decription zone!
What form of mode do you wish to use? [E]CB or [C]BC? Type [Q]uit to exit
e
Do you wish to use padding? [Y]es or [N]o?
y
Input what you wish to encrypt
sometext
1
--------------------------------------------
Text : sometext
Text Encrypted : [B@306c8343
Text Encrypted : [B@306c8343
Text Decrypted : sometext
--------------------------------------------
</code></pre>
","<p>Print your encrypted string after converting to hex:
<a href=""https://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java"">How to convert a byte array to a hex string in Java?</a></p>

<p>You are printing a hash representation of your encrypted byte array, not its contents. </p>
","1573","<java><encryption><des>","0","4","1","2015-03-18 18:51:05","29130366","0","2","2312727","","2015-03-18 18:07:32","2015-03-18 17:52:42",""
"8786407","Triple DES Decryption of plain text","<p>I have some plain text encrypted with Triple XOR and then Triple DES. I also have the key. How do I manage to uncover the plain text?</p>
","<p>Here is a handy tool: <a href=""http://www.tools4noobs.com/online_tools/decrypt/"" rel=""nofollow"">Online decrypt tool</a></p>
","1537","<xor><encryption><des>","0","1","1","2012-07-27 16:41:09","8786488","4","","","","","2012-01-09 09:42:12",""
"1755791","How do I use the DES Algorithm in .NET?","<p>How do I use <code>DES</code> in .NET?</p>

<p>Here's how I'd do it in Java:</p>

<pre><code>        public static String decrypt(byte[] pin, byte [] desKeyData ) throws Exception {
    //if (ISOConstantsLibrary.DEBUG) System.out.println(""original: "" + pin + "" key: "" + ISOUtil.bcd2str(desKeyData, 0, 2 * desKeyData.length, false) );
    String out = """";

    try {           
        SecretKeySpec desKey = new SecretKeySpec(desKeyData, ""DES"");
        Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");//DES/CBC/PKCS5Padding
        byte[] encrypted_password = pin;
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        byte[] decrypted_password = cipher.doFinal(encrypted_password);
        out = new String(decrypted_password);
        //if (ISOConstantsLibrary.DEBUG) System.out.println(""Decrypted Password "" + out);
    }
    catch (Exception e) {
        e.printStackTrace();
    }

    return out;
}
</code></pre>

<p>Is there a library for decrypting <code>DES</code> encryption in .NET? If so, how do I use it?</p>
","<p>You can use the DESCryptoServiceProvider. See this <a href=""http://support.microsoft.com/kb/307010"" rel=""nofollow noreferrer"">article</a>.</p>
","1523","<java><.net><des><encryption>","1","1","3","2009-11-18 13:42:23","1755887","0","3","16587","","2009-11-18 13:37:02","2009-11-18 12:55:26",""
"1755791","How do I use the DES Algorithm in .NET?","<p>How do I use <code>DES</code> in .NET?</p>

<p>Here's how I'd do it in Java:</p>

<pre><code>        public static String decrypt(byte[] pin, byte [] desKeyData ) throws Exception {
    //if (ISOConstantsLibrary.DEBUG) System.out.println(""original: "" + pin + "" key: "" + ISOUtil.bcd2str(desKeyData, 0, 2 * desKeyData.length, false) );
    String out = """";

    try {           
        SecretKeySpec desKey = new SecretKeySpec(desKeyData, ""DES"");
        Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");//DES/CBC/PKCS5Padding
        byte[] encrypted_password = pin;
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        byte[] decrypted_password = cipher.doFinal(encrypted_password);
        out = new String(decrypted_password);
        //if (ISOConstantsLibrary.DEBUG) System.out.println(""Decrypted Password "" + out);
    }
    catch (Exception e) {
        e.printStackTrace();
    }

    return out;
}
</code></pre>

<p>Is there a library for decrypting <code>DES</code> encryption in .NET? If so, how do I use it?</p>
","<p>Assuming your input is a stream</p>

<pre><code>using System.Security.Cryptography

string key;
Stream input;
string output;
DESCryptoServiceProvider DES = new DESCryptoServiceProvider();
//Set key and initialization vector for DES algorithm
DES.Key = ASCIIEncoding.ASCII.GetBytes(key);
DES.IV = ASCIIEncoding.ASCII.GetBytes(key);

//Create CryptoStream layer to decrypt input on reading
CryptoStream decryptStream = new CryptoStream(input, DES.CreateDecryptor(), CryptoStreamMode.Read);
//return decrypted
return new StreamReader(decryptStream ).ReadToEnd();
</code></pre>

<p>otherwise you can of course easily write the input into a stream.
For ECB mode you also need to set the Mode of the DES object to ECB:</p>

<pre><code>DES.Mode = CipherMode.ECB
</code></pre>
","1523","<java><.net><des><encryption>","1","1","3","2009-11-18 13:42:23","1755887","0","3","16587","","2009-11-18 13:37:02","2009-11-18 12:55:26",""
"1755791","How do I use the DES Algorithm in .NET?","<p>How do I use <code>DES</code> in .NET?</p>

<p>Here's how I'd do it in Java:</p>

<pre><code>        public static String decrypt(byte[] pin, byte [] desKeyData ) throws Exception {
    //if (ISOConstantsLibrary.DEBUG) System.out.println(""original: "" + pin + "" key: "" + ISOUtil.bcd2str(desKeyData, 0, 2 * desKeyData.length, false) );
    String out = """";

    try {           
        SecretKeySpec desKey = new SecretKeySpec(desKeyData, ""DES"");
        Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");//DES/CBC/PKCS5Padding
        byte[] encrypted_password = pin;
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        byte[] decrypted_password = cipher.doFinal(encrypted_password);
        out = new String(decrypted_password);
        //if (ISOConstantsLibrary.DEBUG) System.out.println(""Decrypted Password "" + out);
    }
    catch (Exception e) {
        e.printStackTrace();
    }

    return out;
}
</code></pre>

<p>Is there a library for decrypting <code>DES</code> encryption in .NET? If so, how do I use it?</p>
","<p>As a side note to complement the other answers. If you can, don't use it, use the <a href=""http://msdn.microsoft.com/es-es/library/system.security.cryptography.aescryptoserviceprovider.aspx"" rel=""nofollow noreferrer"">AESCryptoServiceProvider</a>.</p>

<blockquote>
  <p>DES is now considered to be insecure
  for many applications. This is chiefly
  due to the 56-bit key size being too
  small; in January, 1999,
  distributed.net and the Electronic
  Frontier Foundation collaborated to
  publicly break a DES key in 22 hours
  and 15 minutes</p>
</blockquote>
","1523","<java><.net><des><encryption>","1","1","3","2009-11-18 13:42:23","1755887","0","3","16587","","2009-11-18 13:37:02","2009-11-18 12:55:26",""
"19534916","DES implementation in Java. Can not get the plaintext","<p>I am working in a simple example for DES implementation using Java built-in libraries. This is my code:</p>

<pre><code>import it.sauronsoftware.base64.Base64;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;


public class DES {

    public static void main(String [] args) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException
    {
        String msg=""This is a secret message"";
        byte [] msgBytes=msg.getBytes();        
        byte [] keyBytes  = {(byte)0xFE, (byte)0xDC, (byte)0xBA, (byte)0x98, (byte)0x76, (byte)0x54, (byte)0x32, (byte)0x10};
        SecretKeySpec myDesKey = new SecretKeySpec(keyBytes, ""DES"");

        //to encrypt a message
        String cipher=encryptMsg(msgBytes, myDesKey);

        //to decrypt a message
        String plain = decryptMsg(cipher.getBytes(), myDesKey);

        System.out.println(""Original Message: ""+ msg);
        System.out.println(""Encrypted Message: ""+ cipher);
        System.out.println(""Decrypted Message: ""+ plain);

    } //end main

    //encryption function
    public static String encryptMsg(byte [] msgBytes, SecretKey myDesKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher desCipher;
        // Create the cipher 
        desCipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
        byte[] textEncrypted = desCipher.doFinal(msgBytes);

        // converts to base64 for easier display.
        byte[] base64Cipher = Base64.encode(textEncrypted);
        return new String(base64Cipher);
    } //end encryptMsg

    public static String decryptMsg(byte [] cipherBytes, SecretKey myDesKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher desCipher; 
        desCipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);
        byte[] textDecrypted=desCipher.doFinal(cipherBytes);

        // converts to base64 for easier display.
        byte[] base64Plain = Base64.encode(textDecrypted);
        return new String(base64Plain);
    } //end decryptMsg
} //end class
</code></pre>

<p>The output I am getting is:</p>

<pre><code>Original Message: This is a secret message
Encrypted Message: hNFgTAoz2TN9f6FcLdbjnEBe5DrsU4sm
Decrypted Message: RFdk1JK0gG0vv2zndHueS9rRe0Oux44ACGObsRHQ+4E=
</code></pre>

<p>I need my key to be a fixed (not random) value. That's why I defined it as array of bytes in the beginning. </p>

<p>My problem is that my decryption function does not return the original message. This means there is a problem in the code and probably the encryption is not proper. I am suspicious about the coding issue as the encryption / decryption is quite straight forward. Can you point the problems in my code?</p>

<p><strong>EDIT:</strong>
In the decryption, I changed the <code>encode</code> to <code>decode</code> as suggested by one of the comments. That does not work. I get:</p>

<pre><code>Exception in thread ""main"" java.lang.RuntimeException: Unexpected I/O error
    at it.sauronsoftware.base64.Base64.decode(Unknown Source)
    at DES.decryptMsg(DES.java:55)
    at DES.main(DES.java:25)
Caused by: java.io.IOException: Bad base64 stream
    at it.sauronsoftware.base64.Base64InputStream.acquire(Unknown Source)
    at it.sauronsoftware.base64.Base64InputStream.read(Unknown Source)
    at java.io.InputStream.read(Unknown Source)
    at java.io.InputStream.read(Unknown Source)
    at it.sauronsoftware.base64.Base64.copy(Unknown Source)
    at it.sauronsoftware.base64.Base64.decode(Unknown Source)
    ... 3 more
</code></pre>
","<p>You're not decoding the encryption of the original message; you're decoding the <em>base64 encoding</em> of the encryption original message.</p>

<p>Rather than passing <code>cipher.getBytes()</code>, you need <code>Base64.decode(cipher).getBytes()</code>, or, alternatively, have the method accept a base64 String and handle the decoding in the method.</p>

<p>Also, there's no need to base64 decode the decrypted content. It will already be in the original encoding. In other words, just return <code>new String(textDecrypted)</code>.</p>

<hr>

<p>The flow you're trying to do is: plaintext -> encrypted content -> base64 -> encrypted content -> plaintext. The flow you're doing is text -> encrypted content -> base64 -> decrypted base64 (nonsense) -> base64 (nonsense)</p>
","1508","<java><security><encryption><des>","0","1","1","2013-10-23 07:23:06","","1","2","2192774","","2013-10-23 07:14:42","2013-10-23 07:00:26",""
"17622859","Leading to same value on Decryption with DESede CBC NoPadding","<p>I am asked to verify if the encryption is working ok. I am given input hex text of 238 bytes. Asked to use DESede/CBC/NoPadding algorithm. I am also given encrypted value. Of course, I am given key also ( Given two bytes. Added third byte as copy of first byte to make it three bytes)</p>

<p>(238 bytes+ 2 bytes padding)</p>

<p>Problem is: Encrypted value from my code does not match completely with the given encrypted value ( only First 56 bytes are matching). </p>

<p>What I did is: Decrypted the given encrypted value and encrypted value produced from my code. Both of these decrypted values are matching with the given input.</p>

<p>That means, I have two encrypted values for which the decrypted value is the same. </p>

<p>Using InitialVector of Zeros.(8 zero bytes).</p>

<p>Can somebody throw some light? I am sure I am missing something. Thanks for any help. </p>

<p>Using javax.crypto.Cipher.getInstance for getting Cipher instance. Using SecretKeyFactory and DESedeKeySpec classes to generate key</p>

<p>Edited:</p>

<pre><code>public String encrypt(byte[] sourceDataInBytes, String keyInHex, String cryptoMode, String cryptoPadding)
    {
Cipher des3cipher = null;
IvParameterSpec ivParamSpec = null;
String transformation = ""DESede""+""/""+ cryptoMode+""/""+cryptoPadding;
byte[] encryptedDataInBytes = null;
try{
    des3cipher = Cipher.getInstance(transformation);
        Key key = generate3DESKey(keyInHex);
    if(cryptoMode.equalsIgnoreCase(""CBC""))  
        {
            ivParamSpec = new IvParameterSpec(INITIAL_VECTOR_SALT);
            des3cipher.init(CYPHER_ENCRYPT_MODE, key, (AlgorithmParameterSpec)ivParamSpec );
        }else{
        des3cipher.init(CYPHER_ENCRYPT_MODE, key);
        }

        if(cryptoPadding.equals(""NoPadding"")){'
    sourceDataInBytes = addPadding(sourceDataInBytes, 8);
    }
        encryptedDataInBytes = des3cipher.doFinal(sourceDataInBytes);
    }catch(Exception e){
e.printStackTrace();
    }
return encryptedDataInBytes ;
}

public Key generate3DESKey(String srcInHex)
{
Key key = null;
if(src != null)
{
    byte[] bk = null;
    try{
        bk = hexStringToByte(src + src.length==32 ? src.substring(0,16) : """"));

        DESedeKeySpec des3KeySpec = new DESedeKeySpec(bk);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DESede"");
        key =  keyFactory.generateSecret(des3KeySpec);

    }catch(Exception e){
        e,printStyackTrace();
    }

}
return key;
}
</code></pre>
","","1488","<java><encryption><des>","0","","0","2013-07-15 06:29:21","","6","","2153236","","2013-07-15 06:29:21","2013-07-12 19:43:58",""
"20798165","Simple DES ECB encryption and decryption in C#","<p>I am trying to do an exercise which includes to decrypt a given encrypted session key with a given shared key.  I have decrypted the session key and printed the byte array on screen. (Same result is printed when ever I run the program).   </p>

<p>Then to check my work I am trying to encrypt the decrypted session key again (obviously with the same shared key) but the result is different all the time it, when is supposed to give me back the original encrypted session key.</p>

<p>I cannot understand were is my mistake....</p>

<p>Thanks</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
using System.IO;

namespace Crypto
{
    public class Program
    {
        static void Main(string[] args)
        {

        //Shared Master Key
        byte[] mkByteArray = { 0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23 };

        //Encrypted Session Key
        byte[] eskByteArray = { 0x4a, 0x4d, 0xe6, 0x87, 0x82, 0x47, 0xd3, 0x7b };

        PrintByteArray(eskByteArray);

        DES des = new DESCryptoServiceProvider();
        des.Mode = CipherMode.ECB;
        des.Padding = PaddingMode.None;
        des.Key = mkByteArray;

        ICryptoTransform ct1 = des.CreateDecryptor();
        byte[] resultArray1 = ct1.TransformFinalBlock(eskByteArray, 0, eskByteArray.Length);
        des.Clear();
        PrintByteArray(resultArray1);

        ICryptoTransform ct2 = des.CreateEncryptor();
        byte[] resultArray2 = ct2.TransformFinalBlock(resultArray1, 0, resultArray1.Length);
        des.Clear();
        PrintByteArray(resultArray2);
        }

        //-----Method to print the byte array on screen-----
        public static void PrintByteArray(byte[] bytes)
        {
            var sb = new StringBuilder(""new byte[] { "");
            foreach (var b in bytes)
            {
                sb.Append(b + "", "");
            }
            sb.Append(""}"");
            Console.WriteLine(sb.ToString());
        }

    }
}
</code></pre>
","<p>I found your problem, but now I am checking why it occurs exactly.</p>

<p>You call <code>des.Clear();</code> between encrypting and decrypting, if you do not do this, the input and output is the same. </p>

<hr>

<p>From <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.clear%28v=vs.110%29.aspx"" rel=""nofollow"">Msdn</a>:</p>

<blockquote>
  <blockquote>
    <p>When called, the Clear method overwrites all sensitive data within the object with zeros</p>
  </blockquote>
</blockquote>

<p>Thus your masterkey in your DES object is set to zero which is why your output is different.</p>
","1443","<c#><encryption><console><des><ecb>","1","4","2","2013-12-27 09:56:14","20798523","0","1","","","","2013-12-27 09:32:18",""
"20798165","Simple DES ECB encryption and decryption in C#","<p>I am trying to do an exercise which includes to decrypt a given encrypted session key with a given shared key.  I have decrypted the session key and printed the byte array on screen. (Same result is printed when ever I run the program).   </p>

<p>Then to check my work I am trying to encrypt the decrypted session key again (obviously with the same shared key) but the result is different all the time it, when is supposed to give me back the original encrypted session key.</p>

<p>I cannot understand were is my mistake....</p>

<p>Thanks</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
using System.IO;

namespace Crypto
{
    public class Program
    {
        static void Main(string[] args)
        {

        //Shared Master Key
        byte[] mkByteArray = { 0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23 };

        //Encrypted Session Key
        byte[] eskByteArray = { 0x4a, 0x4d, 0xe6, 0x87, 0x82, 0x47, 0xd3, 0x7b };

        PrintByteArray(eskByteArray);

        DES des = new DESCryptoServiceProvider();
        des.Mode = CipherMode.ECB;
        des.Padding = PaddingMode.None;
        des.Key = mkByteArray;

        ICryptoTransform ct1 = des.CreateDecryptor();
        byte[] resultArray1 = ct1.TransformFinalBlock(eskByteArray, 0, eskByteArray.Length);
        des.Clear();
        PrintByteArray(resultArray1);

        ICryptoTransform ct2 = des.CreateEncryptor();
        byte[] resultArray2 = ct2.TransformFinalBlock(resultArray1, 0, resultArray1.Length);
        des.Clear();
        PrintByteArray(resultArray2);
        }

        //-----Method to print the byte array on screen-----
        public static void PrintByteArray(byte[] bytes)
        {
            var sb = new StringBuilder(""new byte[] { "");
            foreach (var b in bytes)
            {
                sb.Append(b + "", "");
            }
            sb.Append(""}"");
            Console.WriteLine(sb.ToString());
        }

    }
}
</code></pre>
","<p>This happens because of the <strong>Initialisation Vector</strong>. This behaviour is there by design. You don't want the encryption algorithm to produce exactly the same output for the same input. Such algorythm is susceptible to plain text attack, where attacker can potentially infer encryption key from the input and the produced output.</p>

<p>This happens in the line</p>

<pre><code>ICryptoTransform ct2 = des.CreateEncryptor();
</code></pre>

<p>According to <a href=""http://msdn.microsoft.com/en-us/library/09d0kyb3%28v=vs.110%29.aspx"" rel=""nofollow"">msdn</a></p>

<blockquote>
  <p>If the current IV property is null, 
  the GenerateIV method is called to create a new random IV.</p>
</blockquote>

<p>To fix this you need to set the IV for your encryptor. You would then store IV alongside the encrypted bytes and use it for decryption. IV, in simple words, is some initial random noise that allows encryption algorithm to produce different input. As a good practise, this noise must be different for each encryption call.</p>

<p>Obviously, DES is a really weak algorithm, you would want to use at least 3DES. But even 3DES is only used for legacy applications. Modern applications use AES.</p>
","1443","<c#><encryption><console><des><ecb>","1","0","2","2013-12-27 09:56:14","20798523","0","1","","","","2013-12-27 09:32:18",""
"14433705","Encrypting and Decrypting a text file in java maintaining first line as readable","<p>I need to encrypt and decrypt a text file.For encryption and decryption i may use DES/AES algorithms.I have a code for encrypt and decrypt text file but the problem is,the first line in file must be encrypted in such a way it should be understandable.using AES and DES iam getting non readable format after encryption.I need to read the first line of file after encryption.Please help me .Thanks in advance</p>
","<p>Why not add a user-readable magic number to the beginning of the file, and again after you're done with the text block?  Something like this:</p>

<pre><code>MagiKrypt

This file has been encrypted with MagiKrypt, and you will need the program at (URL HERE) to decrypt it.

MakiKrypt\x00\x01\x02\x03
(AES data here)
EOF
</code></pre>

<p>This way your program would easily be able to tell where is text, and where is AES data, and the user would be able to read the first part of the file.  It would still be a mess if they open it in a text editor, but at least they'd see the intro block.</p>
","1438","<java><aes><encryption><des>","0","1","3","2013-01-21 15:10:00","","2","","","","","2013-01-21 06:55:36",""
"14433705","Encrypting and Decrypting a text file in java maintaining first line as readable","<p>I need to encrypt and decrypt a text file.For encryption and decryption i may use DES/AES algorithms.I have a code for encrypt and decrypt text file but the problem is,the first line in file must be encrypted in such a way it should be understandable.using AES and DES iam getting non readable format after encryption.I need to read the first line of file after encryption.Please help me .Thanks in advance</p>
","<p>Its better to keep unecrypted the first line or you should cerate rules of your own and encrypt the first(and all) text.Its better to use SHAI algorithm for better encryptions.Other than SHA1 another choice is BTE encryption</p>
","1438","<java><aes><encryption><des>","0","-1","3","2013-01-21 15:10:00","","2","","","","","2013-01-21 06:55:36",""
"14433705","Encrypting and Decrypting a text file in java maintaining first line as readable","<p>I need to encrypt and decrypt a text file.For encryption and decryption i may use DES/AES algorithms.I have a code for encrypt and decrypt text file but the problem is,the first line in file must be encrypted in such a way it should be understandable.using AES and DES iam getting non readable format after encryption.I need to read the first line of file after encryption.Please help me .Thanks in advance</p>
","<p>Encryption produces bytes, not human readable characters.  To make your bytes human readable, you need to convert them to a different format.  I would suggest <a href=""https://stackoverflow.com/questions/469695/decode-base64-data-in-java"">Base64</a> as a common way to do this.</p>

<p>After you have encrypted your file, convert as much of it as you need to Base64 and display the Base64 part.  It will not make any sense, but it won't contain anything too weird.</p>
","1438","<java><aes><encryption><des>","0","0","3","2013-01-21 15:10:00","","2","","","","","2013-01-21 06:55:36",""
"18979978","How to encode TO a 4 digits number or nummerical string in JAVA?","<p>I am relatively new to java and i've been breaking my head the last few days in order to finish a task, and everything went good until this last ""quest"". </p>

<p>More Specific: </p>

<p>I want to create an encrypted/encoded 4 digits number out of 3 string fields. You can imagine it as trying to produce a 4 digit CVV number like in the credit cards, with the help of(in terms of depending from) the card number, the exp. date and the service code. To achive this, i first encrypted the card number using DES with random key, then encrypted(DES) the exp date using the encrypted card number as a key, and as last step, i encrypted(DES) service code using the encrypted exp date as a key. So far, so good, i can retrieve in every step the infoarmations needed. The problem is that the encrypted service code, which will be my final output, shall have the length 4 and shall contains only digits. After two days of researching in the net, after trying several attempts, like: </p>

<ul>
<li><strong>hashing</strong> : problem was there was no decode back from hash value to encrypted service code</li>
<li><strong>Base64 Transformation</strong> : couldn't achieve length and only digits</li>
<li><strong>padding</strong> : would loose vital information</li>
<li><strong>further encryption</strong> : couldn't find an algorithm producing such a short (in terms of length) key.</li>
</ul>

<p>Is there any other solution? </p>

<p>Here is the last 2 steps of the algorithm, just to get you an idea of how it is running.</p>

<p>desCipher.init(Cipher.ENCRYPT_MODE, myDesKey_2);</p>

<pre><code>        // Sensitive information - message to be encrypted
        byte[] date_of_exp = ""032019"".getBytes(); // Date of Expiration in form MMYYYY

        //System.out.println(""Card Number : "" + card_number); // Print original message

        // Encrypt the text
       byte[] date_of_expEncrypted = desCipher.doFinal(date_of_exp);

        System.out.println("""");
        System.out.println(""Date of Expiration Encrypted : "" + date_of_expEncrypted); // Print the encrypted message
        System.out.println("""");

        // Initialize the same cipher for decryption
        desCipher.init(Cipher.DECRYPT_MODE, myDesKey_2);

        String date_of_expEncrypted_;
        date_of_expEncrypted_ = DatatypeConverter.printBase64Binary(date_of_expEncrypted); 
        // SecretKey card_numberEncrypted_key;
        // card_numberEncrypted_key = stringToSecretKey (card_numberEncrypted_, ""DES"");
        SecretKey date_of_expEncrypted_key;
        date_of_expEncrypted_key = new SecretKeySpec(date_of_expEncrypted, 0, 8, ""DES"");
        System.out.println("""");
        System.out.println(""Date of expiration as secret key :"" + date_of_expEncrypted_key);
        System.out.println("""");

        // Decrypt the text
        byte[] date_of_expDecrypted = desCipher.doFinal(date_of_expEncrypted);

        System.out.println(""Original Date of Expiration (decrypted) : "" + new String(date_of_expDecrypted)); // Print the decrypted Text
        System.out.println("""");
        System.out.println("""");
        System.out.println(""-----------------------------------------------------------------------------------"");
        System.out.println(""Further to Step 3""); // Print the decrypted Text
        System.out.println(""-----------------------------------------------------------------------------------""); // Print the decrypted Text
        System.out.println("""");
        System.out.println("""");




    SecretKey myDesKey_3 = date_of_expEncrypted_key;

    //Cipher desCipher_2; // New Cipher for iteration 2

        // Create the cipher 
        //desCipher_2 = Cipher.getInstance(""DES/ECB/PKCS5Padding"");

        // Initialize the cipher for encryption
        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey_3);

        // Sensitive information - message to be encrypted
        byte[] service_code = ""318"".getBytes(); 

       // Encrypt the text
       byte[] service_codeEncrypted = desCipher.doFinal(service_code);
        System.out.println("""");
        System.out.println(""Service Code Encrypted : "" + service_codeEncrypted); // Print the encrypted message
        System.out.println("""");
        // Initialize the same cipher for decryption
        desCipher.init(Cipher.DECRYPT_MODE, myDesKey_3);

        // Decrypt the text
        byte[] service_codeDecrypted = desCipher.doFinal(service_codeEncrypted);

        System.out.println(""Service Code decrypted : "" + new String(service_codeDecrypted)); // Print the decrypted Text
        System.out.println("""");
        System.out.println("""");
        System.out.println(""-----------------------------------------------------------------------------------"");
        System.out.println(""Finish!!!""); // Print the decrypted Text
        System.out.println(""-----------------------------------------------------------------------------------""); // Print the decrypted Text
        System.out.println("""");
        System.out.println("""");


        //Integer bigInt = new Integer(""Bwwhw34"".getBytes());
        // int service_codeEncrypted_hashed = service_codeEncrypted.hashCode();
        // System.out.println(""hash code for Service Code Encrypted : "" + service_codeEncrypted_hashed);
        // int service_codeEncrypted_hashed_2 = service_codeEncrypted_hashed.hashCode();

        // byte[] service_code__ = service_codeEncrypted.getBytes(); 
        //  System.out.println(""hash code for Service Code Encrypted and baseD  : "" + service_code__);



    }catch(NoSuchAlgorithmException e){
        e.printStackTrace();
    }catch(NoSuchPaddingException e){
        e.printStackTrace();
    }catch(InvalidKeyException e){
        e.printStackTrace();
    }catch(IllegalBlockSizeException e){
        e.printStackTrace();
    }catch(BadPaddingException e){
        e.printStackTrace();
    } 

}
</code></pre>

<p>Output ""Service Code Encrypted"" would be in form [B@84abc9, wich is useless for my purposes. </p>

<p>Thanx in advance and sorry for my bad english!</p>
","<p>""I want to create an encrypted/encoded 4 digits number out of 3 string fields.""</p>

<p>Your only choice is a hash, otherwise you'll need Harry Potter to help you out. Or did you expect that you can transform 4 digits back into any 3 possible Strings? I'm afraid that kind of compression doesn't exist.</p>

<p>As for your ""[B@84abc9"". That's the default toString() for a byte array. You'll want to turn it into hexadecimal or Base64 before displaying it.</p>
","1411","<java><encryption><base64><encode><des>","0","1","1","2013-09-24 11:17:19","18980143","2","1","","","","2013-09-24 11:09:40",""
"12179929","Encrypt in C++ and decrypt in Python","<p>What libraries do you know that can be used to encrypt in C/C++ and decrypt in python for the RSA/AES/DES algorithms?</p>

<p>We are going to use one of the those algorithms to encrypt some parameters in URL.</p>

<p>We have already tried some libraries in C++:</p>

<ul>
<li>Crypto++</li>
<li><a href=""http://code.google.com/p/rsa/"" rel=""nofollow"">http://code.google.com/p/rsa/</a></li>
</ul>

<p>and in python</p>

<ul>
<li>pycryptopp</li>
<li>Python-RSA</li>
</ul>

<p>But unfortunantly I didn't manage to match the parameters/keys that those libraries use.</p>
","<p>Take a look at <a href=""http://www.keyczar.org/"" rel=""nofollow"">keyczar</a>, a cryptographic toolkit from Google. It is easy to use and it is not just a set of encrypt/decrypt funcions; it has other features (e.g. key management). It does not depends on a single encryption algorithm, as the developer can choose which one to use.</p>

<p>There are good docs here: <a href=""http://code.google.com/p/keyczar/w/list"" rel=""nofollow"">http://code.google.com/p/keyczar/w/list</a></p>
","1390","<c++><python><aes><rsa><des>","2","0","3","2012-08-29 15:21:35","12181298","1","","","","","2012-08-29 14:11:27",""
"12179929","Encrypt in C++ and decrypt in Python","<p>What libraries do you know that can be used to encrypt in C/C++ and decrypt in python for the RSA/AES/DES algorithms?</p>

<p>We are going to use one of the those algorithms to encrypt some parameters in URL.</p>

<p>We have already tried some libraries in C++:</p>

<ul>
<li>Crypto++</li>
<li><a href=""http://code.google.com/p/rsa/"" rel=""nofollow"">http://code.google.com/p/rsa/</a></li>
</ul>

<p>and in python</p>

<ul>
<li>pycryptopp</li>
<li>Python-RSA</li>
</ul>

<p>But unfortunantly I didn't manage to match the parameters/keys that those libraries use.</p>
","<p>Why not just use OpenSSL wrappers in each language? It is a very standardized method of encryption and there are many libraries that can ease in writing the code itself.</p>

<p><a href=""http://www.openssl.org/"" rel=""nofollow"">http://www.openssl.org/</a></p>

<p><a href=""https://launchpad.net/pyopenssl"" rel=""nofollow"">https://launchpad.net/pyopenssl</a></p>

<p><a href=""http://www.boost.org/doc/libs/1_49_0/boost/asio/ssl/detail/openssl_init.hpp"" rel=""nofollow"">http://www.boost.org/doc/libs/1_49_0/boost/asio/ssl/detail/openssl_init.hpp</a></p>

<p>This will allow for the greatest compatibility between the two languages and any other system you may need.</p>
","1390","<c++><python><aes><rsa><des>","2","1","3","2012-08-29 15:21:35","12181298","1","","","","","2012-08-29 14:11:27",""
"12179929","Encrypt in C++ and decrypt in Python","<p>What libraries do you know that can be used to encrypt in C/C++ and decrypt in python for the RSA/AES/DES algorithms?</p>

<p>We are going to use one of the those algorithms to encrypt some parameters in URL.</p>

<p>We have already tried some libraries in C++:</p>

<ul>
<li>Crypto++</li>
<li><a href=""http://code.google.com/p/rsa/"" rel=""nofollow"">http://code.google.com/p/rsa/</a></li>
</ul>

<p>and in python</p>

<ul>
<li>pycryptopp</li>
<li>Python-RSA</li>
</ul>

<p>But unfortunantly I didn't manage to match the parameters/keys that those libraries use.</p>
","<p>I use pycrypto  <a href=""http://pypi.python.org/pypi/pycrypto/2.6"" rel=""nofollow"">http://pypi.python.org/pypi/pycrypto/2.6</a></p>

<p>pycryptopp is just wrappers around Crypto++ , which means you're likely doing something wrong in Crypto , Python or both.</p>

<p>If you're just using payloads in URLs for web stuff, I wrote this library that handles all that crap</p>

<p><a href=""https://github.com/jvanasco/insecure_but_secure_enough/blob/master/insecure_but_secure_enough/"" rel=""nofollow"">https://github.com/jvanasco/insecure_but_secure_enough/blob/master/insecure_but_secure_enough/</a>__init__.py</p>
","1390","<c++><python><aes><rsa><des>","2","0","3","2012-08-29 15:21:35","12181298","1","","","","","2012-08-29 14:11:27",""
"7072108","DES encryption in PHP","<p>I am coding a Drupal payment method module and within this I need to generate a hash to send to a bank. Bank asks me to code certain strings into the DES/ECB hash. They also provide test environment and here comes my problem. With the string B7DC02D5D6F2689E and key 7465737465703031 I should get result hash 3627C7356B25922B (after bin2hex, of course). This is by the bank test page and I have also checked this on this page: <a href=""http://www.riscure.com/tech-corner/online-crypto-tools/des.html"" rel=""nofollow"">http://www.riscure.com/tech-corner/online-crypto-tools/des.html</a> (encryption java applet).</p>

<p>My problem is that whatever I do I cant get my PHP code to provide the correct result. This is a simple function I am trying to use:</p>

<pre><code>function encrypt($hash, $key)
{
$hash = strtoupper(substr(sha1($hash), 0, 16));
$key = strtoupper(bin2hex($key));

$block = mcrypt_get_block_size('des', 'ecb');
if (($pad = $block - (strlen($hash) % $block)) &lt; $block) {
  $hash .= str_repeat(chr($pad), $pad);
}

$sig = strtoupper(bin2hex(mcrypt_encrypt(MCRYPT_DES, $key, $hash, MCRYPT_MODE_ECB)));
return $sig;
}
</code></pre>

<p>and I have been trying sth like this as well:</p>

<pre><code>function encrypt( $value, $key) {
$hash = strtoupper(substr(sha1($value), 0, 16));
$key = strtoupper(substr(bin2hex($key), 0, 16));
// encrypt hash with key
if (function_exists('mcrypt_module_open')) {         // We have mcrypt 2.4.x
  $td = mcrypt_module_open(MCRYPT_DES, """", MCRYPT_MODE_ECB, """");
  $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size ($td), MCRYPT_RAND);
  mcrypt_generic_init($td, $key, $iv);
  $signature = strtoupper(bin2hex(mcrypt_generic ($td, $hash)));
  mcrypt_generic_end ($td);
}
else
{                        // We have 2.2.x only
$signature = strtoupper(bin2hex(mcrypt_ecb (MCRYPT_3DES, $key, $hash, MCRYPT_ENCRYPT)));
}
return $signature;
}
</code></pre>

<p>None of these gave the correct signature. Any idea what's wrong? For now I am dealing with this issue more than 3 hrs, so I appreciate any help. I am not very familiar with this encryption stuff. Thanks a lot.</p>

<p>Btw.: Those $hash and $key mentioned above are after the strtoupper, substr and bin2hex functions at the beginning of my code snippets.</p>
","<p>You plaintext, <code>B7DC02D5D6F2689E</code>, is 8 bytes = 64 bits.  This is an exact block for DES so you don't need any padding in ECB mode.  I suggest that you remove the padding code entirely.  All DEC-ECB needs in this case is the block to encrypt and the key; no padding and no IV.</p>
","1383","<php><drupal><encryption><des>","1","0","2","2011-08-16 00:35:13","7072382","2","1","","","","2011-08-15 23:52:46",""
"7072108","DES encryption in PHP","<p>I am coding a Drupal payment method module and within this I need to generate a hash to send to a bank. Bank asks me to code certain strings into the DES/ECB hash. They also provide test environment and here comes my problem. With the string B7DC02D5D6F2689E and key 7465737465703031 I should get result hash 3627C7356B25922B (after bin2hex, of course). This is by the bank test page and I have also checked this on this page: <a href=""http://www.riscure.com/tech-corner/online-crypto-tools/des.html"" rel=""nofollow"">http://www.riscure.com/tech-corner/online-crypto-tools/des.html</a> (encryption java applet).</p>

<p>My problem is that whatever I do I cant get my PHP code to provide the correct result. This is a simple function I am trying to use:</p>

<pre><code>function encrypt($hash, $key)
{
$hash = strtoupper(substr(sha1($hash), 0, 16));
$key = strtoupper(bin2hex($key));

$block = mcrypt_get_block_size('des', 'ecb');
if (($pad = $block - (strlen($hash) % $block)) &lt; $block) {
  $hash .= str_repeat(chr($pad), $pad);
}

$sig = strtoupper(bin2hex(mcrypt_encrypt(MCRYPT_DES, $key, $hash, MCRYPT_MODE_ECB)));
return $sig;
}
</code></pre>

<p>and I have been trying sth like this as well:</p>

<pre><code>function encrypt( $value, $key) {
$hash = strtoupper(substr(sha1($value), 0, 16));
$key = strtoupper(substr(bin2hex($key), 0, 16));
// encrypt hash with key
if (function_exists('mcrypt_module_open')) {         // We have mcrypt 2.4.x
  $td = mcrypt_module_open(MCRYPT_DES, """", MCRYPT_MODE_ECB, """");
  $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size ($td), MCRYPT_RAND);
  mcrypt_generic_init($td, $key, $iv);
  $signature = strtoupper(bin2hex(mcrypt_generic ($td, $hash)));
  mcrypt_generic_end ($td);
}
else
{                        // We have 2.2.x only
$signature = strtoupper(bin2hex(mcrypt_ecb (MCRYPT_3DES, $key, $hash, MCRYPT_ENCRYPT)));
}
return $signature;
}
</code></pre>

<p>None of these gave the correct signature. Any idea what's wrong? For now I am dealing with this issue more than 3 hrs, so I appreciate any help. I am not very familiar with this encryption stuff. Thanks a lot.</p>

<p>Btw.: Those $hash and $key mentioned above are after the strtoupper, substr and bin2hex functions at the beginning of my code snippets.</p>
","<p>Simple solution:</p>

<pre><code>function encrypt($hash, $key) {
    return mcrypt_encrypt(""des"", pack(""H*"", $key), pack(""H*"", $hash), ""ecb"");
}

print bin2hex(encrypt(""B7DC02D5D6F2689E"", ""7465737465703031""));
</code></pre>

<p>This prints <code>3627c7356b25922b</code> for me, so it looks like that's working.</p>

<p>You were on the right track with <code>bin2hex()</code>, but that was converting in the wrong direction. (There's unfortunately no <code>hex2bin()</code> function, so you have to use <code>pack()</code> instead.)</p>

<p>You also don't need an IV for a single-block encryption like this.</p>
","1383","<php><drupal><encryption><des>","1","1","2","2011-08-16 00:35:13","7072382","2","1","","","","2011-08-15 23:52:46",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>Probably a lookup table of an Array with 255 entries would be fastest ""In Ruby"" solution.</p>

<p>In C I would mask and shift. Or if I have SSE4 I would use the POPCNT instruction with inline assembler. If you need this to be high performance write a native extension in C which does either of the above.</p>

<p><a href=""http://en.wikipedia.org/wiki/SSE4"" rel=""nofollow"">http://en.wikipedia.org/wiki/SSE4</a></p>
","1381","<ruby><des><3des><parity>","6","3","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>Have you taken a look at the <a href=""http://github.com/robertsosinski/ruby-des"" rel=""nofollow"">RubyDES library</a>? That may remove the need to write your own implementation.</p>

<p>To calculate parity, you can use something like the following:</p>

<pre><code>require 'rubygems'
require 'inline'  # RubyInline (install with `gem install RubyInline`)

class Fixnum
  # native ruby version: simpler but slow
  # algorithm from: 
  #   http://graphics.stanford.edu/~seander/bithacks.html#ParityParallel      
  def parity_native
    (((self * 0x0101010101010101) &amp; 0x8040201008040201) % 0x1FF) &amp; 1
  end

  class &lt;&lt; self
    # inline c version using RubyInline to create c extension
    # 4-5 times faster than native version
    # use as class method: 
    #   Fixnum.parity(0xAB)
    inline :C do |builder|
      builder.c &lt;&lt;-EOC
      int parity_c(int num) {  
        return (
            ((num * 0x0101010101010101ULL) &amp; 0x8040201008040201ULL) % 0x1FF
          ) &amp; 1;
      }
      EOC
    end
  end

  def parity
    self.class.parity_c(self)
  end

  def parity_odd?
    1 == parity
  end
  def parity_even?
    0 == parity
  end
end

0xAB.parity        # =&gt; 1 
0xAB.parity_odd?   # =&gt; true 
0xAB.parity_even?  # =&gt; false
(0xAB + 1).parity  # =&gt; 0
</code></pre>

<p>According to simple benchmarks, the inline c version is 3-4 times faster than the native ruby version</p>

<pre><code>require 'benchmark'
n = 10000
Benchmark.bm do |x|
  x.report(""inline c"") do
    n.times do 
      (0..255).map{|num| num.parity}
    end
  end

  x.report(""native ruby"") do
    n.times do 
      (0..255).map{|num| num.parity_native}
    end
  end
end
# inline c     1.982326s
# native ruby  7.044330s
</code></pre>
","1381","<ruby><des><3des><parity>","6","4","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<pre><code>x = 'AB'.to_i(16)
p = 0
until x == 0
  p += x &amp; 1
  x = x &gt;&gt; 1
end
puts p # =&gt; 5
</code></pre>

<p>which can be shortened to</p>

<pre><code>x = 'AB'.to_i(16)
p = x &amp; 1
p += x &amp; 1 until (x &gt;&gt;= 1) == 0
</code></pre>

<p>if you want something that is unreadable ☺</p>
","1381","<ruby><des><3des><parity>","6","1","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>Unless what you have is not fast enough, keep it.  It's clear and succinct, and its performance is better than you think.</p>

<p>We'll benchmark everything against array lookup, the fastest method I tested:</p>

<pre><code>ODD_PARITY = [
  false,
  true,
  true,
  ...
  true,
  false,
]

def odd_parity?(hex_string)
  ODD_PARITY[hex_string.to_i(16)]
end
</code></pre>

<ul>
<li>Array lookup computes the parity at a rate of 640,000 bytes per second.</li>
<li>Bowsersenior's C code computes parity at a rate of 640,000 bytes per second.</li>
<li>Your code computes parity at a rate of 284,000 bytes per second.</li>
<li>Bowsersenior's native code computes parity at a rate of 171,000 bytes per second.</li>
<li>Theo's shortened code computes parity at a rate of 128,000 bytes per second.</li>
</ul>
","1381","<ruby><des><3des><parity>","6","7","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>How about using your original solution with memoization? This will only calculate once for each integer value.</p>

<pre><code>class Fixnum
  # Using a class variable for simplicity, and because subclasses of
  # Fixnum—while very uncommon—would likely want to share it. 
  @@parity = ::Hash.new{ |h,i| h[i] = i.to_s(2).count('1').odd? }
  def odd_parity?
    @@parity[self]
  end
  def even_parity?
    !@@parity[self]
  end
end

""AB"".to_i(16).odd_parity?
#=&gt; true
</code></pre>
","1381","<ruby><des><3des><parity>","6","2","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>I would construct a single table of 16 entries (as a 16 character table), corresponding to each nibble (half) of a bytes. Entries are 0,1,1,2,1,2,....4</p>

<p>To test your byte,</p>

<p>Mask out the left nibble and do a lookup, memorizing the number.
Do. a shift to the right by 4 and do a second lookup, adding the result number to the previous one to provide a sum.</p>

<p>Then test the low order bit from the sum.  If it is 1, the byte is odd, if it is a 0, the byte is even.  If result is even, you flip the high order bit, using the xor instruction.
THis lookup method is much faster than adding up the bits in a byte by single shifts.</p>

<p>email me for a simple function to do the parity for 8 bytes.  3DES uses 3 groups of 8 bytes.</p>
","1381","<ruby><des><3des><parity>","6","1","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"16293663","Convert Oracle PL/SQL code to C#","<p>Can someone guide me how to convert following Oracle PL/SQL code to C#, please?</p>

<pre><code>declare 
   l_encrypted raw (100);
   p_key raw (100);
   p_plain raw(100);
   l_mode number; 
begin
  l_mode := dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_PKCS5;
  p_key := 'A217B5BEF1477D1A';
  p_plain := '07253075';
  l_encrypted := dbms_crypto.encrypt(UTL_I18N.STRING_TO_RAW(p_plain, 'AL32UTF8'), l_mode, p_key);
  dbms_output.put_line(l_encrypted);
     --outputs this value: E4624E16DB69451A14BE265CDCC5B0AB
end;
</code></pre>

<p>My C# code is:</p>

<pre><code>        byte[] value = Encoding.UTF8.GetBytes(""07253075"");
        byte[] key = Encoding.UTF8.GetBytes(""A217B5BEF1477D1A"");
        DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider
        {
            Mode = CipherMode.CBC,
            Padding = PaddingMode.PKCS7,
        };
        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateEncryptor(key, key), CryptoStreamMode.Write);
        cryptoStream.Write(value, 0, value.Length);
        cryptoStream.Close();
        Byte[] encrypted = memoryStream.ToArray();
        MessageBox.Show(string.Join(string.Empty, Array.ConvertAll(encrypted, b =&gt; b.ToString(""X2""))));
</code></pre>

<p>However, it throws CryptographicException complaining of key size. I searched Internet and found out that key size for DES is 8 bytes, but how Oracle encrypted my text? And how can I change my code to get the same output as Oracle? </p>
","<p>DES traditionally accepts a 64 bit key where only 56 bits are used to encrypt the message. You could try setting the KeySize property of the DESCryptoServiceProvider to 128 and see how it goes.</p>

<p>Are you sure the whole key is used? the <a href=""http://docs.oracle.com/cd/B19306_01/appdev.102/b14258/d_crypto.htm"" rel=""nofollow"">doco</a> for this states:</p>

<blockquote>
  <p>ENCRYPT_DES
  Data Encryption Standard. Block cipher. Uses key length of 56 bits.</p>
</blockquote>

<p>I would assume that only the first 56 bits of the key are used (the first 7 characters). You could try running the encryption method in oracle with the first 7 characters and see if the output is the same compared to all 16.</p>

<p>If that's the case and you really want/need to to use 128 bit keys, you should move up to triple-DES or AES.</p>
","1373","<c#><encryption><plsql><des>","0","0","1","2018-11-12 01:14:48","","0","","","","","2013-04-30 06:33:27",""
"13983798","Encrypt and garble audio file using JAVA","<p>I'm currently working on a project to encrypt MP3 audio using JAVA and produce garbled sound from that encrypted MP3 file. So far, I can encrypt the whole MP3 file using DES encryption method. However, this encrypted file is not playable using MP3 player. I know that MP3 file has some structure (header and data, etc), but I have no idea to implement encryption on this file without breaking the whole MP3 structure.</p>

<p>How to make this encrypted MP3 file playable?</p>
","<p>Some more info about parsing and mp3 stream in java: <a href=""http://www.javazoom.net/javalayer/javalayer.html"" rel=""nofollow"">JavaLayer</a> is an mp3 decoder that naturally implements stream processing mostly with <code>javazoom.jl.decoder.Bitstream</code> class. It will skip all tag data and give you raw bytes for each frame.</p>

<p>Another library that does some mp3 stream parsing is <a href=""http://www.jthink.net/jaudiotagger/"" rel=""nofollow"">jaudiotagger</a>, maybe you can scavenge some code from there too.</p>

<p>Both of these libraries are distributed under LGPL, so just be aware of licensing issues.</p>
","1370","<java><audio><encryption><mp3><des>","4","1","1","2012-12-21 04:38:02","","3","1","","","","2012-12-21 03:13:08",""
"18850473","DES encrypt in C/C++ vs Java","<p>Just wondering why same plain text encrypted in Java and C doesn't generate same cipher text.
For DES algo I noticed </p>

<p>input <code>text = ""text"",  key = ""test""</code></p>

<p>C cipher text <code>len = 24</code>
Java generates cipher text <code>len = 8</code></p>

<p>For 256Bit AES I noticed similar difference<br>
C cipher text <code>len = 32</code>
Java generates cipher text <code>len = 16</code></p>

<p>here is my ""C"" code </p>

<pre class=""lang-c prettyprint-override""><code>char* enc(const char* text, const char* keyStr)
{
    EVP_CIPHER_CTX ctx;
    unsigned char key[32] = {0};
    unsigned char iv[16] = {0};
    unsigned char in[16] = {0};
    unsigned char out[32]; /* at least one block longer than in[] */
    memset(out, 0, 32);
    int outlen1, outlen2;

    memcpy(in, text, strlen(text));
    memcpy(key, keyStr, strlen(keyStr));

    EVP_EncryptInit(&amp;ctx, EVP_aes_256_cbc(), key, iv);    
    EVP_EncryptUpdate(&amp;ctx, out, &amp;outlen1, in, sizeof(in));
    EVP_EncryptFinal(&amp;ctx, out + outlen1, &amp;outlen2);

    char* ret  = (char*)malloc(outlen1 + outlen2+1);
    memset(ret, 0, outlen1 + outlen2+1);
    memcpy(ret, out, outlen1 + outlen2);

    EVP_CIPHER_CTX_cleanup(&amp;ctx);

    return ret;
}
</code></pre>

<p>Here is the ""Java"" code </p>

<pre class=""lang-java prettyprint-override""><code>public static byte[] enc(byte[] input, byte[] keyStr){
        byte[] output = null;

        try {           
            byte[] newKey = getByteArrays(keyStr, 0, 32);
            SecretKey secretKey = new SecretKeySpec(newKey, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");  
            //Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
            String ivStr = """";
            byte[] ivKey = getByteArrays(ivStr.getBytes(""UTF-8""), 0, 16);
            IvParameterSpec ips = new IvParameterSpec(ivKey);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ips, null);         
            output = cipher.doFinal(input);

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }       
        return output;
    }
</code></pre>

<p>I have list of entries encrypted using C , I want to decrypt those entries in Java.</p>

<p><b> UPDATED </b> <br>
following update helped to get same length , both in 'C' and 'JAVA'</p>

<p>EVP_EncryptUpdate(&amp;ctx, out, &amp;outlen1, in, strlen(text));</p>

<p>No Just wondering why ciphertext returned by ""C"" and ""JAVA"" are different for same text and key, I'm expecting them tobe same</p>
","<p>The reason the C code outputs 32 bytes of ciphertext is because you are padding your input string with zeros <strong>before</strong> passing it to the encryption function.</p>

<p>In this line:</p>

<pre><code>EVP_EncryptUpdate(&amp;ctx, out, &amp;outlen1, in, sizeof(in));
</code></pre>

<p>the function has no idea that you padded your data with zeros. Since <code>sizeof(in)</code> is 16, it takes 16 as the length of your plaintext. And with PKCS5 padding (and AES), 16 bytes will pad to 32  bytes.</p>

<p>In your Java code you didn't manually pad your input, you just passed it straight to the encryption function. So the encryption function sees your plaintext size as 4 bytes, which pads to 16 with PKCS5 padding.</p>

<p>So your solution is simple: don't manually pad your input in the C code. Just pass the plaintext directly to <code>EVP_EncryptUpdate</code>. It's already designed to handle unpadded plaintext.</p>
","1321","<java><c><encryption><aes><des>","2","1","1","2013-09-18 17:02:50","18855166","1","3","2787620","","2013-09-18 17:02:50","2013-09-17 12:54:52",""
"45004207","DES Encryption in android","<p>If i try encrypting ""123456"" with key ""qwertykey"" and got response as ""UVEXg9fgBxo="" in online tool <a href=""https://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow noreferrer"">https://www.tools4noobs.com/online_tools/encrypt/</a></p>

<p>But if i use android code i am getting ""2XQNkfXlN6E="" as encrypted value </p>

<p>my code is </p>

<pre><code>public String encrypt(String plainTextPassword){
String encrypted = """";
try{
DESKeySpec keySpec = new DESKeySpec(""qwertykey"".getBytes());
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
SecretKey key = keyFactory.generateSecret(keySpec);
byte[] cleartext = plainTextPassword.getBytes();

Cipher cipher = Cipher.getInstance(""DES""); // cipher is not thread safe
cipher.init(Cipher.ENCRYPT_MODE, key);
encrypted = Base64.encodeToString(cipher.doFinal(cleartext),Base64.DEFAULT);

}catch (Exception e){

}
return encrypted;
}
</code></pre>

<p>could anyone please help me in achieving this</p>
","<p>DES supports only a key size of 56 bit (64 bit with parity). So you cannot use a larger key with it. Mcrypt knows this and silently only uses the first 8 bytes. Mcrypt also doesn't implement proper padding. Instead it pads with 0x00 bytes. You should be able to use a similar, but not same, padding in BouncyCastle:</p>

<pre><code>Cipher.getInstance(""DES/ECB/ZeroBytePadding"", ""BC"");
</code></pre>

<p>Never use <a href=""https://crypto.stackexchange.com/questions/14487/can-someone-explain-the-ecb-penguin"">ECB mode</a>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like CBC or CTR. It is better to authenticate your ciphertexts so that attacks like a padding oracle attack are not possible. This can be done with authenticated modes like GCM or EAX, or with an encrypt-then-MAC scheme.</p>

<p><strong>NOTE</strong> DES should not be used at all for new developments.</p>
","1302","<android><des>","0","0","1","2017-07-10 06:41:47","45004367","4","2","","","","2017-07-10 05:16:29",""
"16607759","PHP DES Encryption compatible with Delphi - encryption function","<p>I am trying to create the encrypt PHP algorithm from this thread:</p>

<p><a href=""https://stackoverflow.com/questions/14995052/how-to-sync-encryption-between-delphi-and-php-using-dcpcrypt"">how to sync encryption between delphi and php using dcpcrypt</a> (see shunty's reply)</p>

<p>Here is what I have so far:</p>

<pre><code>function encrypt($str, $key)
{
    $keysize = mcrypt_get_key_size(MCRYPT_DES, MCRYPT_MODE_CBC);

    $ivbytes = array(72, 163, 99, 62, 219, 111, 163, 114);
    $iv = implode(array_map(""chr"", $ivbytes));

    $pad = ord($str[strlen($str) - 1]);
    $enc = substr($str, 0, strlen($str) - $pad);

    $enc = base64_encode($str);
    $k = mhash(MHASH_SHA1, $key);

    //return substr($dec, 0, strlen($dec) - $pad);
    $dec = mcrypt_encrypt(MCRYPT_DES, substr($k, 0, $keysize), $enc, MCRYPT_MODE_CBC, $iv);

    return $dec;
}
</code></pre>

<p>I'm not sure what I'm doing wrong but testing it with this:</p>

<pre><code>echo encrypt(""this is a test"", ""test"");
</code></pre>

<p>Gives the output:  =ž«RCdrç­b˜hý’¯á·OÊ
when it should give: WRaG/8xlxqqcTAJ5UAk4DA==</p>

<p>Can anyone help me out in explaining where I am going wrong, would really appreciate the help I can get.</p>

<p><strong>EDIT:</strong></p>

<pre><code>function encrypt_SO($str, $key)
    {
        $keysize = mcrypt_get_key_size(MCRYPT_DES, MCRYPT_MODE_CBC);

        $ivbytes = array(72, 163, 99, 62, 219, 111, 163, 114);
        $iv = implode(array_map(""chr"", $ivbytes));

        $pad = ord($str[strlen($str) - 1]);
        $enc = substr($str, 0, strlen($str) - $pad);
        $k = mhash(MHASH_SHA1, $key);

        //return substr($dec, 0, strlen($dec) - $pad);
        $dec = mcrypt_encrypt(MCRYPT_DES, substr($k, 0, $keysize), $enc, MCRYPT_MODE_CBC, $iv);

        return base64_encode($dec);
    }
</code></pre>

<p>Moved the encoding to the end.</p>

<p><strong>EDIT 2: Solution thanks to everyone's helpful posts:</strong></p>

<pre><code>function encrypt_SO($str, $key)
{
    $keysize = mcrypt_get_key_size(MCRYPT_DES, MCRYPT_MODE_CBC);

    $ivbytes = array(72, 163, 99, 62, 219, 111, 163, 114);
    $iv = implode(array_map(""chr"", $ivbytes));

    $k = mhash(MHASH_SHA1, $key);

    $blocksize = mcrypt_get_block_size(MCRYPT_DES, MCRYPT_MODE_CBC);
    $padsize = $blocksize - (strlen($str) % $blocksize);
    $str .= str_repeat(chr($padsize), $padsize);

    return base64_encode(mcrypt_encrypt(MCRYPT_DES, substr($k, 0, $keysize), $str, MCRYPT_MODE_CBC, $iv));
}
</code></pre>
","<p>To answer your comment above:</p>

<p>Encrypt:</p>

<ul>
<li>Get keysize and blocksize</li>
<li>Get IV - this should really be something random and properly generated but to work with DCPcrypt without specifying an IV manually you need to use the one provided.</li>
<li>Hash the key</li>
<li><p><strong>Add</strong> the padding - you've got this bit wrong. For this example you need something like:<br/></p>

<pre><code>$blocksize = mcrypt_get_block_size(MCRYPT_DES, MCRYPT_MODE_CBC);
$padsize = $blocksize - (strlen($str) % $blocksize);
$str .= str_repeat(chr($padsize), $padsize);
</code></pre></li>
<li><p>Encrypt</p></li>
<li>Base64 encode</li>
</ul>

<p>Decrypt:</p>

<ul>
<li>Get keysize </li>
<li>Get IV - as above (must be the same as the one used to encrypt but, again, should really be properly cryptographically generated). </li>
<li>Hash the key</li>
<li>Base64 decode</li>
<li>Decrypt</li>
<li><strong>Remove</strong> the padding</li>
</ul>
","1290","<php><delphi><encryption><des>","-1","1","1","2013-05-17 15:03:25","16611877","6","1","-1","","2017-05-23 12:18:51","2013-05-17 11:22:47",""
"39710936","PHP OpenSSL encrypt with DES-CBC algorithm unexpected output","<p>I want to change all the passwords of a given DB. All this passwords are cipher with DES CBC PKCS7, I have the key and the initialization vector. I've used the next web page <a href=""http://www.txtwizard.net/crypto"" rel=""nofollow"">http://www.txtwizard.net/crypto</a> to decrypt one password and the result was the expected (using options DES, CBC and PKCS7).</p>

<p><strong>key:</strong> RRZy0njZDzw=</p>

<p><strong>iv:</strong> p/34qWLNYfg=</p>

<p><strong>plain text</strong>  123123</p>

<p><strong>crypted text</strong> x541kJ4KvJo=</p>

<p>But when the next code written in PHP I can't replicate the result:</p>

<pre><code>&lt;?php
    $key = ""RRZy0njZDzw="";
    $iv = ""p/34qWLNYfg="";
    $data = ""123123"";
    $cipher='DES-CBC';
    var_dump(openssl_get_cipher_methods());
    $encrypted = openssl_encrypt($data,$cipher, $key,OPENSSL_RAW_DATA,$iv);
    echo base64_encode($encrypted);
?&gt;
</code></pre>

<p>The output of this code is:</p>

<pre><code>PHP Warning:  openssl_encrypt(): IV passed is 12 bytes long which is longer than the 8 expected by selected cipher, truncating in /home/sergio/Documents/DevEnvTest/siaf/aes2hash.php on line 7

Warning: openssl_encrypt(): IV passed is 12 bytes long which is longer than the 8 expected by selected cipher, truncating in /home/sergio/Documents/DevEnvTest/siaf/aes2hash.php on line 7
gB7ahDoYZqI=
</code></pre>

<p>Is there a way to get the same string that the online tool?</p>
","<p>You need to decode your key and IV from Base64:</p>

<pre><code>$key = base64_decode(""RRZy0njZDzw="");
$iv = base64_decode(""p/34qWLNYfg="");
</code></pre>
","1282","<php><des><php-openssl>","0","3","1","2016-09-26 23:10:11","39711055","0","","608639","","2016-09-26 23:10:11","2016-09-26 19:33:29",""
"27034374","How to implement DES encrypting with ('DES/CBC/PKCS5Padding' mode) in Ruby?","<p>I'v received on some DES encrypted stuff from a 3rd part company. I can't decrypt it in ruby. But it works in my java code. </p>

<hr>

<p>Here is java code:</p>

<pre><code>public class Main {

public static void main(String[] args) {
    try {
        System.out.println(encrypt(""12345678"", ""abc"", ""12345678""));
        //System.out.println(encrypt(""12345678"", ""ABC"", ""12345678""));


        System.out.println(decrypt(""12345678"", ""9YR6ZPdZufM="", ""12345678""));
        //System.out.println(decrypt(""12345678"", ""6rtTnrF34mPkJ5SO3RiaaQ=="", ""12345678""));

    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static String encrypt(String key, String str, String ivString) throws Exception {
    DESKeySpec desKeySpec = new DESKeySpec(key.getBytes());
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
    Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    Key secretKey = keyFactory.generateSecret(desKeySpec);

    IvParameterSpec iv = new IvParameterSpec(ivString.getBytes());
    cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);
    byte[] bytes = cipher.doFinal(str.getBytes());
    dumpHex(bytes);

    return Base64.encode(bytes);
}

public static void dumpHex(byte[] bytes) {
    for (byte b : bytes) {
        System.out.println(String.format(""%02x"",b&amp;0xff));
    }
    System.out.println(bytesToHex(bytes));
}

final protected static char[] hexArray = ""0123456789ABCDEF"".toCharArray();
public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for ( int j = 0; j &lt; bytes.length; j++ ) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}

public static String decrypt(String key, String str, String ivString) throws Exception {
    byte[] data = Base64.decode(str);
    dumpHex(data);
    DESKeySpec dks = new DESKeySpec(key.getBytes());
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
    Key secretKey = keyFactory.generateSecret(dks);
    Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    IvParameterSpec iv = new IvParameterSpec(ivString.getBytes());
    cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);
    byte[] decryptedBytes = cipher.doFinal(data);
    return new String(decryptedBytes, ""gb2312"");
}
</code></pre>

<p>}</p>

<p>I couldn't found the same DES mode ('DES/CBC/PKCS5Padding') in ruby. I got the different result when I try to encrypt the same string.</p>

<hr>

<p>Here is my ruby source code:</p>

<pre><code>class Des
  require 'openssl'
  require 'base64'
  ALG = 'DES-EDE3-CBC'
  KEY = ""12345678""
  DES_KEY = ""12345678""

  def encode(str)
    des = OpenSSL::Cipher::Cipher.new(ALG)
    des.pkcs5_keyivgen(KEY, DES_KEY)
    des.encrypt
    cipher = des.update(str) + des.final
    pp cipher.length
    pp cipher.unpack('H*')[0]
    return Base64.encode64(cipher)
  end

  def decode(str)
    str = Base64.decode64(str)
    pp str.unpack('H*')[0]
    des = OpenSSL::Cipher::Cipher.new(ALG)
    des.pkcs5_keyivgen(KEY, DES_KEY)
    des.decrypt
    des.update(str) + des.final
  end

  def KEY()
    pp KEY.length
    KEY
  end

  def DES_KEY()
    pp DES_KEY.length
    DES_KEY
  end
end
</code></pre>

<hr>

<p>I encrypt 'abc' with java, get ""9YR6ZPdZufM="". But get ""5SHCjTOrygg="" in ruby version.It confused me a lot.</p>
","<p>I change some config in ruby code, and it works. But I didn't know why...</p>

<pre><code>def DES
    ALG = 'DES-EDE-CBC'
    KEY = ""1234567812345678""
    DES_KEY = ""12345678""
</code></pre>
","1267","<ruby><encryption><des>","2","0","1","2014-11-21 05:29:19","","1","3","","","","2014-11-20 07:50:06",""
"7418007","JAVA DES/CBC/PKCS5Padding how encryption translated into iPhone?","<p>source:</p>

<pre><code>public static String encrypt(String src, String key) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

        DESKeySpec dks = new DESKeySpec(key.substring(0, 8).getBytes());

        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
        SecretKey securekey = keyFactory.generateSecret(dks);
        IvParameterSpec iv = new IvParameterSpec(key.substring(0, 8)
                .getBytes());

        cipher.init(Cipher.ENCRYPT_MODE, securekey, iv);
        StringBuilder builder = new StringBuilder();
        byte[] bytes = cipher.doFinal(src.getBytes(""UTF-8""));
        for (byte b : bytes) {
            System.out.println(b);
                            builder.append(b);
        }

        return builder.toString().toUpperCase();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return """";
}
</code></pre>

<p>Test:</p>

<pre><code>System.out.println(encrypt(""1995"", ""ijd.dif*""));
</code></pre>

<p>result:</p>

<p>101
113
87
110
44
8
62
-111</p>

<p>1011138711044862-111</p>

<p><strong>How the code above into objective c - iPhone？</strong></p>
","","1263","<iphone><objective-c><des><pkcs#5><cbc-mac>","2","","0","2011-09-15 00:24:50","","0","2","944808","","2011-09-15 00:24:50","2011-09-14 14:26:46",""
"15225389","How to mimic php crypt() on NODE.JS","<p>Please help with php -> javascript(node.js) conversion</p>

<pre><code>$key = crypt($key, $salt);
</code></pre>

<p>I'm rewriting php script with node.js, and I got stuck with hash signature generation in php, which is made using crypt() function with salt matching ""CRYPT_EXT_DES"" pattern </p>

<blockquote>
  <p>CRYPT_EXT_DES - Extended DES-based hash. The ""salt"" is a 9-character string consisting of an underscore followed by 4 bytes of iteration count and 4 bytes of salt. These are encoded as printable characters, 6 bits per character, least significant character first. The values 0 to 63 are encoded as ""./0-9A-Za-z"". Using invalid characters in the salt will cause crypt() to fail.</p>
</blockquote>

<p>I'm not really experienced with encryption, and studying node.js docs on crypto module didnt help. Please help how to implement this on node.js!</p>
","<p>If you're looking for an exact implementation of PHP's crypt() in JavaScript, you may want to take a look at:</p>

<p><a href=""http://phpjs.org/functions/get_extension_funcs/"" rel=""nofollow noreferrer"">http://phpjs.org/functions/get_extension_funcs/</a> - It's a project that tries to port all the PHP functions to JavaScript.</p>
","1233","<php><javascript><node.js><encryption><des>","3","-2","2","2019-06-14 02:13:43","","2","1","","","","2013-03-05 13:46:50",""
"15225389","How to mimic php crypt() on NODE.JS","<p>Please help with php -> javascript(node.js) conversion</p>

<pre><code>$key = crypt($key, $salt);
</code></pre>

<p>I'm rewriting php script with node.js, and I got stuck with hash signature generation in php, which is made using crypt() function with salt matching ""CRYPT_EXT_DES"" pattern </p>

<blockquote>
  <p>CRYPT_EXT_DES - Extended DES-based hash. The ""salt"" is a 9-character string consisting of an underscore followed by 4 bytes of iteration count and 4 bytes of salt. These are encoded as printable characters, 6 bits per character, least significant character first. The values 0 to 63 are encoded as ""./0-9A-Za-z"". Using invalid characters in the salt will cause crypt() to fail.</p>
</blockquote>

<p>I'm not really experienced with encryption, and studying node.js docs on crypto module didnt help. Please help how to implement this on node.js!</p>
","<p>It looks like the <a href=""https://github.com/sendanor/node-crypt3"" rel=""nofollow noreferrer"">crypt(3)</a> library should work.</p>

<p>E.g.:</p>

<pre><code>const crypt = require( 'crypt3/sync' ),
      key = ""password"",
      hash = crypt( key, crypt.createSalt( 'sha512' ) );
</code></pre>

<p>And then to test stored hash...</p>

<pre><code>const crypt = require( 'crypt3/sync' ),
      key = ""password"",
      hash = /* stored hash */;

if ( crypt( key, hash ) !== hash ) {
  // access denied
  return false;
}
</code></pre>

<p>(six year late, I know)</p>
","1233","<php><javascript><node.js><encryption><des>","3","0","2","2019-06-14 02:13:43","","2","1","","","","2013-03-05 13:46:50",""
"52159141","How to make ldap evaluate clear text password vs DES stored password","<p>I use openldap slapd 2.4.40 and postgresql9.2.23 as back-sql on CentoS 6.9</p>

<p>user and password for LDAP <code>uid</code> and <code>userPassword</code> are stored in postgresql by DES encoding.</p>

<p>Original clear text is <code>JacicFk5</code> </p>

<p>DES encoded/encrypted text is <code>IfjFxsltK/MPE</code> which stored in DB.</p>

<p>I can see the user information as the result of ldapseach by stored password.</p>

<pre><code>ldapsearch -x  -b ""dc=example,dc=com"" -D uid=""HDZZZ0R0N,ou=people,dc=example,dc=com"" -w IfjFxsltK/MPE '(&amp;(uid= HDZZZ0R0N)(objectClass=*))'          
# extended LDIF
#
# LDAPv3
# base &lt;dc=example,dc=com&gt; with scope subtree
# filter: (&amp;(uid= HDZZZ0R0N)(objectClass=*))
# requesting: ALL
#

# user01, people, example.com
dn: uid= HDZZZ0R0N,ou=people,dc=example,dc=com
objectClass: inetOrgPerson
cn:: W+aOkl3lia/nlKPnianjg6Hjg7Pjg4bjg4rjg7PjgrnvvIgzNu+8iVNURw==
sn:: W+aOkl3lia/nlKPnianjg6Hjg7Pjg4bjg4rjg7PjgrnvvIgzNu+8iVNURw==
uid: HDZZZ0R0N
userPassword:: SWZqRnhzbHRLL01QRQ==
</code></pre>

<p>However, I can’t do ldapsearch by original clear text password</p>

<pre><code>ldapsearch -x -b ""dc=example,dc=com"" -D uid=""HDZZZ0R0N,ou=people,dc=example,dc=com"" -w JacicFk5 '(&amp;(uid= HDZZZ0R0N)(objectClass=*))'
ldap_bind: Invalid credentials (49)
</code></pre>

<p>Does anyone tell me how to make ldapsearch to resolve given password by clear text and stored password by DES encoding?</p>

<p>I’d like to know is how to make plaintext <code>JacicFk5</code> from ldapseach command-line to hash <code>IfjFxsltK/MPE</code> and make it match against <code>IfjFxsltK/MPE</code> in DB as <code>userPassowrd</code>.</p>

<p>Is there suitable directive for <code>ldap.conf</code> or <code>slapd.conf</code>?</p>

<p>I've checked followings .</p>

<pre><code>echo ""SWZqRnhzbHRLL01QRQ=="" |perl -MMIME::Base64 -ne 'print decode_base64($_) . ""\n""'
</code></pre>

<p>it returns <code>IfjFxsltK/MPE</code></p>

<pre><code>perl -e 'print(""userPassword: {crypt}"".crypt(""JacicFk5"",""If"").""\n"");'
</code></pre>

<p>it returns <code>userPassword: {crypt}IfjFxsltK/MPE</code></p>

<p>One more info.
my ldapseach can solve password text for users stored in AD server via ownclod.</p>
","<p>What you want/need to have is a LDAP <em>simple authentication</em>.  Please first note that it is <strong>unsecure</strong> to store passwords in plaintext!</p>

<p>First you need to test what auth mechanisms you have supported/allowed.</p>

<p>An example:</p>

<pre><code>tukanos@localhost:~# ldapsearch -H ldap:// -x -LLL -s base -b """" supportedSASLMechanisms
dn:
supportedSASLMechanisms: DIGEST-MD5
supportedSASLMechanisms: CRAM-MD5
supportedSASLMechanisms: NTLM
</code></pre>

<p>Now you want to change the onfiguration via <code>ldapmodify</code>.  You prepare a LDIF file (LDIF stands for LDAP Data Interchangable Format)  with configuration.</p>

<p>Prepare your configuration file you can name it <code>olcSaslSecProps.ldif</code>:</p>

<pre><code>dn: cn=config
replace: olcSaslSecProps
olcSaslSecProps: noanonymous,minssf=0,passcred
</code></pre>

<p>What the properties mean: </p>

<pre><code>noanonymous ... no anonymous connection allowed
minssf=0 ... that defines your effective encryption strength (0 ... no encryption)
passcred ... that would allow password to work as for credentials
</code></pre>

<p>To quote the <a href=""http://www.openldap.org/doc/admin24/security.html"" rel=""nofollow noreferrer"">OpenLDAP security considerations</a></p>

<blockquote>
  <p>Security Strength Factors</p>
  
  <p>The server uses Security Strength Factors (SSF) to indicate the
  relative strength of protection. A SSF of zero (0) indicates no
  protections are in place. A SSF of one (1) indicates integrity
  protection are in place. A SSF greater than one (>1) roughly
  correlates to the effective encryption key length. For example, DES is
  56, 3DES is 112, and AES 128, 192, or 256.</p>
  
  <p>A number of administrative controls rely on SSFs associated with TLS
  and SASL protection in place on an LDAP session.</p>
  
  <p>security controls disallow operations when appropriate protections are
  not in place. For example:</p>

<pre><code>    security ssf=1 update_ssf=112
</code></pre>
  
  <p>requires integrity protection for all operations and encryption
  protection, 3DES equivalent, for update operations (e.g. add, delete,
  modify, etc.). See slapd.conf(5) for details.</p>
</blockquote>

<p>Now to apply the LDIF file:</p>

<pre><code>ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif
</code></pre>

<p>Now to restart the <code>slapd</code> daemon:</p>

<pre><code>systemctl restart slapd
</code></pre>

<p>If you check now your configuration you should get <code>LOGIN</code> and <code>PLAIN</code>:</p>

<pre><code>ldapsearch -H ldap:// -x -LLL -s base -b """" supportedSASLMechanisms
dn:
supportedSASLMechanisms: PLAIN
supportedSASLMechanisms: LOGIN
</code></pre>

<p>Now your search should work with plain test password:</p>

<pre><code>ldapsearch -x  -b ""dc=example,dc=com"" -D uid=""HDZZZ0R0N,ou=people,dc=example,dc=com"" -w JacicFk5 '(&amp;(uid= HDZZZ0R0N)(objectClass=*))'
</code></pre>
","1226","<hash><active-directory><openldap><des><crypt>","1","1","1","2018-09-12 10:02:07","52292525","6","","244811","","2018-09-10 23:46:23","2018-09-04 05:05:59",""
"10246083","Emulate 3DES EDE using only DES","<p>My device doesn't support full 3DES (EDE). How can I emulate one using standard DES? Encryption mode is CBC.</p>
","<p><a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">3DES</a> is just DES used three times on the plaintext:</p>

<pre><code>ciphertext = E_K3(D_K2(E_K1(plaintext)))
plaintext = D_K1(E_K2(D_K3(ciphertext)))

E_Kn = Encryption with Key number n.
D_Kn = Decryption with Key number n.
</code></pre>

<p>So you can easily ""emulate"" 3DES with just DES.</p>

<p>In CBC mode you'll need an IV to start with and then XOR the next plaintext block with the previous ciphertext block. If your device doesn't support CBC then this too is easily ""emulated"".</p>
","1207","<encryption><encryption-symmetric><des><3des>","1","0","3","2012-05-03 21:12:28","10246219","0","","468904","","2012-05-03 21:12:28","2012-04-20 12:17:05",""
"10246083","Emulate 3DES EDE using only DES","<p>My device doesn't support full 3DES (EDE). How can I emulate one using standard DES? Encryption mode is CBC.</p>
","<p>You start by picking three independent DES keys which are not related to each other in any way.</p>

<p>You will want to put DES into ECB mode, <strong>not CBC mode</strong>. You also need to ensure that each encryption and decryption operation is done only on 64-bit blocks and nothing more or less. Padding schemes and the likes will cause a vulnerability in the implementation and will lead to the discovery of the block content via brute force faster than a brute force against each key.</p>

<p>Using the first key, encrypt your plaintext. Using the second key, decrypt that value. Using the third key, encrypt the value for your full block. It looks like this:</p>

<p><code>Encrypt(k3, Decrypt(k2, Encrypt(k1, plaintext)))</code></p>

<p>Decryption is the other way around and looks like this:</p>

<p><code>Decrypt(k1, Encrypt(k2, Decrypt(k3, ciphertext)))</code></p>

<p>When you encrypt your blocks with 3DES you then need to apply your mode of operation like CBC or CTR and apply padding if needed.</p>

<p>Be careful.</p>
","1207","<encryption><encryption-symmetric><des><3des>","1","4","3","2012-05-03 21:12:28","10246219","0","","468904","","2012-05-03 21:12:28","2012-04-20 12:17:05",""
"10246083","Emulate 3DES EDE using only DES","<p>My device doesn't support full 3DES (EDE). How can I emulate one using standard DES? Encryption mode is CBC.</p>
","<h1>Block mode encryption</h1>

<p>What you do is that you split the key of size 128 bit (16 byte) or 168 bit (24 byte) in two or three pieces respectively. So for a 16 byte key K you would have two keys Ka and Kb, and for a 24 byte key you would have Ka, Kb and Kc. DES ABC keys have an <em>effective</em> strength of about 112 bits, DES ABA keys have an <em>effective</em> strength of about 80 bits.</p>

<p>To encrypt a single block of 8 bytes (the block size of both DES and 3DES) you would perform the following cryptographic operation: Cn = E(Ka, D(Kb, E(Kc, Mn))) where Mn is the n'th block of the plain text message and Cn the n'th block of the cipher text. If you don't have a Kc then you may use Ka (DES ABC key vs DES ABA key).</p>

<p>For this you need a single block DES encrypt, which is identical to a single block encrypt in ECB mode, or a single block encrypt with CBC and an IV consisting of 8 bytes valued 00h.</p>

<h1>CBC</h1>

<p>So that's the block encryption sorted, now you need some kind of encryption mode and padding mode. I'll explain CBC mode encryption here, ECB should not be used for encryption non-random data.</p>

<p>With CBC mode encryption you XOR a vector to the plain text. The vector is normally just the output of the last DESede encrypted block. As you don't have any preceding cipher text, you need to create the first vector yourself using random data. This vector is called the initialization vector or IV. See <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block%20chaining%20%28CBC%29"" rel=""nofollow"">wikipedia</a> for a clear picture.</p>

<h1>Padding</h1>

<p>Block cipher modes only allow full blocks of plain text to be encrypted. So you would need some kind of padding scheme. Although there are many padding modes, PKCS#5 padding is used most of the time. You should pad the plain text like this: pad with bytes valued 0Xh, where X is the number of padding bytes required to create a full block. X should be between 1 and 8: in other words, PKCS#5 padding is always used; this makes it possible to distinquish the padding bytes from the plain text.</p>

<p>If you use padding in an online protocol then you need to protect against padding oracle attacks. In this case it is highly recommended to use some form of integrity checks, e.g. by adding a HMAC over the cipher text using a separate key.</p>
","1207","<encryption><encryption-symmetric><des><3des>","1","1","3","2012-05-03 21:12:28","10246219","0","","468904","","2012-05-03 21:12:28","2012-04-20 12:17:05",""
"26228671","C# Have user input string to a key DES","<p>In my C# program I am encrypting/decrypting files. I copied this code from the Microsoft website to toy with it and dissect it. I'm asking if any of you know how I would have a pre-determined string act as the key for the encryption/decryption.</p>

<p>In my main method:</p>

<pre><code>string sSecretKey;
sSecretKey = GenerateKey();
</code></pre>

<p>GenerateKey:</p>

<pre><code>static string GenerateKey()
{
    DESCryptoServiceProvider desCrypto = 
                 (DESCryptoServiceProvider) DESCryptoServiceProvider.Create();
    return ASCIIEncoding.ASCII.GetString(desCrypto.Key);
}
</code></pre>

<p>This is in my encrypt and decrypt function: I have no idea what they do</p>

<pre><code>DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey);
DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey);
</code></pre>
","<p>This sort of depends on what you want to do. In the following line...</p>

<pre><code>ASCIIEncoding.ASCII.GetString(desCrypto.Key);
</code></pre>

<p>You are fetching an ascii representation of an automatically generated key for the encryption object. The property <code>DES.Key</code> though, has both a public <code>set</code> and a public <code>get</code>, so you can do:</p>

<pre><code>// Set key to a pre-determined set of bytes (of length 8):
desCrypto.Key = new byte[] {0x4b, 0x4a, 0x41, 0x52, 0x54, 0x41, 0x4e, 0x21};
</code></pre>

<p>Ofcourse the value of this, when the next line decodes <code>desCrypto.Key</code> into a string, the bytes will be ""decoded"" from hex into <a href=""http://www.asciitable.com/"" rel=""nofollow"">more readable ascii characters</a> (assuming you've provided some meaningful hex values to begin with, ofcourse).</p>
","1203","<c#><encryption><key><des>","0","0","1","2014-10-07 05:11:19","26228939","0","","336648","","2014-10-07 04:42:56","2014-10-07 04:42:06",""
"20688340","Decrypting DES using OpenSSL Qt, C++","<p>I'm writing a new version of program in C++ using Qt library, and want to maintain compatibility with the old version written in C#. </p>

<p>How can I convert this code to C++ / Qt?</p>

<pre><code>DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider();
emoryStream stream = new  MemoryStream(Convert.FromBase64String(p0));
CryptoStream stream2 = new CryptoStream(stream,     dESCryptoServiceProvider.CreateDecryptor(Encoding.ASCII.GetBytes(""B5B126C5""), 
Encoding.UTF32.GetBytes(""0907427F93EC3A3FCFDFEBE3CB55011"")), CryptoStreamMode.Read);
StreamReader streamReader = new StreamReader(stream2);
String text = streamReader.ReadToEnd();
</code></pre>

<p>My actually Qt/C++ code:</p>

<pre><code>        QByteArray encrypted = code.toLatin1();
        encrypted = QByteArray::fromBase64(encrypted);

     /////////////////////////////////////////////////////////////////////////////////////
        DES_cblock key = { 0x9, 0x7, 0x42, 0x7, 0xf9, 0x3e, 0xC3, 0xa3, 0xfC, 0xfd, 0xfe, 0xbe, 0x3c, 0xb5, 0x50, 0x85 };
                    //this key is too long...

    ///////////////////////////////////////////////////////////////////////////////////////
        DES_cblock iv = { 0xB5, 0xb1, 0x26, 0xc11 };

        DES_key_schedule schedule;
        unsigned char decrypted[encrypted.size()];

        DES_set_odd_parity(&amp;key);
        DES_set_key_checked(&amp;key, &amp;schedule);
        DES_ncbc_encrypt((unsigned char * )encrypted.constData(), (unsigned char * )decrypted, encrypted.size(), &amp;schedule, &amp;iv, DES_DECRYPT);
        unsigned int data_size = 0;

        QString text = QByteArray::fromRawData((char * )decrypted, data_size);
</code></pre>

<p>When I try to build receive an error:</p>

<pre><code>C:\Project1_Qt\trunk\Core\OldHashDecoder.cpp:1383: error: too many initializers for 'DES_cblock {aka unsigned char [8]}'
</code></pre>

<p>Please help
Best regards</p>
","<p>You have several issues here ongoing.</p>

<ul>
<li><p>It seems that you have a long key as you noted yourself in the comment. You will need to make that shorter.</p></li>
<li><p>DES keys are of fixed length as rightfully noted in the comment.</p></li>
<li><p>You cannot fix 0xc11 in one byte.</p></li>
</ul>

<p>As for the C# code, you pasted, I am not sure. I am not good at that language, but perhaps it may have truncated the length for you silently.</p>
","1176","<c++><qt><encryption><openssl><des>","2","1","1","2013-12-22 12:37:20","20729479","3","","3120149","","2013-12-20 11:01:04","2013-12-19 17:44:58",""
"14109915","What is Go's equivalent to Python's crypt.crypt?","<p>I am currently playing around with an example from the book Violent Python.  You can see my implementation <a href=""https://github.com/igniteflow/violent-python/blob/master/pwd-crackers/unix-pwd-crack.py"" rel=""nofollow"">here</a> </p>

<p>I am now trying to implement the same script in Go to compare performance, note I am completely new to Go.  Opening the file and iterating over the lines is fine, however I cannot figure out how to use the ""crypto"" library to hash the string in the same way as Python's crypt.crypt(str_to_hash, salt).  I thought it maybe something like</p>

<pre><code>import ""crypto/des""
des.NewCipher([]byte(""abcdefgh""))
</code></pre>

<p>However, no cigar.  Any help would be much appreciated as it'd be really interesting to compare Go's parallel performance to Python's multithreaded.  </p>

<p>Edit:
<a href=""http://docs.python.org/2/library/crypt.html"" rel=""nofollow"">Python docs for crypt.crypt</a> </p>
","<p>E.g.</p>

<pre><code>package main

import (
        ""crypto/des""
        ""fmt""
        ""log""
)

func main() {
        b, err := des.NewCipher([]byte(""abcdefgh""))
        if err != nil {
                log.Fatal(err)
        }

        msg := []byte(""Hello!?!"")
        fmt.Printf(""% 02x: %q\n"", msg, msg)
        b.Encrypt(msg, msg)
        fmt.Printf(""% 02x: %q\n"", msg, msg)
        b.Decrypt(msg, msg)
        fmt.Printf(""% 02x: %q\n"", msg, msg)
}
</code></pre>

<p>(Also: <a href=""http://play.golang.org/p/czYDRjtWNR"" rel=""nofollow"">http://play.golang.org/p/czYDRjtWNR</a>)</p>

<hr>

<p>Output:</p>

<pre><code>48 65 6c 6c 6f 21 3f 21: ""Hello!?!""
3e 41 67 99 2d 9a 72 b9: ""&gt;Ag\x99-\x9ar\xb9""
48 65 6c 6c 6f 21 3f 21: ""Hello!?!""
</code></pre>
","1161","<python><go><des><crypt>","5","2","4","2016-03-25 21:53:01","14113157","3","1","343223","","2013-01-01 14:04:29","2013-01-01 11:11:31",""
"14109915","What is Go's equivalent to Python's crypt.crypt?","<p>I am currently playing around with an example from the book Violent Python.  You can see my implementation <a href=""https://github.com/igniteflow/violent-python/blob/master/pwd-crackers/unix-pwd-crack.py"" rel=""nofollow"">here</a> </p>

<p>I am now trying to implement the same script in Go to compare performance, note I am completely new to Go.  Opening the file and iterating over the lines is fine, however I cannot figure out how to use the ""crypto"" library to hash the string in the same way as Python's crypt.crypt(str_to_hash, salt).  I thought it maybe something like</p>

<pre><code>import ""crypto/des""
des.NewCipher([]byte(""abcdefgh""))
</code></pre>

<p>However, no cigar.  Any help would be much appreciated as it'd be really interesting to compare Go's parallel performance to Python's multithreaded.  </p>

<p>Edit:
<a href=""http://docs.python.org/2/library/crypt.html"" rel=""nofollow"">Python docs for crypt.crypt</a> </p>
","<p>I believe there isn't currently any publicly available package for Go which implements the old-fashioned Unix ""salted"" DES based <code>crypt()</code> functionality. This is different from the normal symmetrical DES encryption/decryption which is implemented in the <code>""crypto/des""</code> package (as you have discovered).</p>

<p>You would have to implement it on your own. There are plenty of existing implementations in different languages (mostly C), for example in <a href=""http://svnweb.freebsd.org/base/head/secure/lib/libcrypt/crypt-des.c?view=markup"" rel=""nofollow"">FreeBSD sources</a> or in <a href=""https://www.gnu.org/software/libc/"" rel=""nofollow"">glibc</a>. If you implement it in Go, please publish it. :)</p>

<p>For new projects it is much better to use some stronger password hashing algorithm, such as <a href=""https://en.wikipedia.org/wiki/Bcrypt"" rel=""nofollow"">bcrypt</a>. A good implementation is available in the <a href=""https://code.google.com/p/go.crypto/"" rel=""nofollow"">go.crypto</a> repository. The documentation is available <a href=""http://godoc.org/code.google.com/p/go.crypto/bcrypt"" rel=""nofollow"">here</a>. Unfortunately this does not help if you need to work with pre-existing legacy password hashes.</p>

<p><em>Edited to add</em>: I  had a look at Python's <code>crypt.crypt()</code> implementation and found out that it is just a wrapper around the libc implementation. It would be simple to implement the same wrapper for Go. However your idea of comparing a Python implementation to a Go implementation is already ruined: you would have to implement <strong>both</strong> of them yourself to make any meaningful comparisons.</p>
","1161","<python><go><des><crypt>","5","3","4","2016-03-25 21:53:01","14113157","3","1","343223","","2013-01-01 14:04:29","2013-01-01 11:11:31",""
"14109915","What is Go's equivalent to Python's crypt.crypt?","<p>I am currently playing around with an example from the book Violent Python.  You can see my implementation <a href=""https://github.com/igniteflow/violent-python/blob/master/pwd-crackers/unix-pwd-crack.py"" rel=""nofollow"">here</a> </p>

<p>I am now trying to implement the same script in Go to compare performance, note I am completely new to Go.  Opening the file and iterating over the lines is fine, however I cannot figure out how to use the ""crypto"" library to hash the string in the same way as Python's crypt.crypt(str_to_hash, salt).  I thought it maybe something like</p>

<pre><code>import ""crypto/des""
des.NewCipher([]byte(""abcdefgh""))
</code></pre>

<p>However, no cigar.  Any help would be much appreciated as it'd be really interesting to compare Go's parallel performance to Python's multithreaded.  </p>

<p>Edit:
<a href=""http://docs.python.org/2/library/crypt.html"" rel=""nofollow"">Python docs for crypt.crypt</a> </p>
","<p><code>crypt</code> is very easy to wrap with cgo, eg</p>

<pre><code>package main

import (
    ""fmt""
    ""unsafe""
)

// #cgo LDFLAGS: -lcrypt
// #define _GNU_SOURCE
// #include &lt;crypt.h&gt;
// #include &lt;stdlib.h&gt;
import ""C""

// crypt wraps C library crypt_r
func crypt(key, salt string) string {
    data := C.struct_crypt_data{}
    ckey := C.CString(key)
    csalt := C.CString(salt)
    out := C.GoString(C.crypt_r(ckey, csalt, &amp;data))
    C.free(unsafe.Pointer(ckey))
    C.free(unsafe.Pointer(csalt))
    return out
}

func main() {
    fmt.Println(crypt(""abcdefg"", ""aa""))
}
</code></pre>

<p>Which produces this when run</p>

<pre><code>aaTcvO819w3js
</code></pre>

<p>Which is identical to python <code>crypt.crypt</code></p>

<pre><code>&gt;&gt;&gt; from crypt import crypt
&gt;&gt;&gt; crypt(""abcdefg"",""aa"")
'aaTcvO819w3js'
&gt;&gt;&gt; 
</code></pre>

<p>(Updated to free the CStrings - thanks @james-henstridge)</p>
","1161","<python><go><des><crypt>","5","3","4","2016-03-25 21:53:01","14113157","3","1","343223","","2013-01-01 14:04:29","2013-01-01 11:11:31",""
"14109915","What is Go's equivalent to Python's crypt.crypt?","<p>I am currently playing around with an example from the book Violent Python.  You can see my implementation <a href=""https://github.com/igniteflow/violent-python/blob/master/pwd-crackers/unix-pwd-crack.py"" rel=""nofollow"">here</a> </p>

<p>I am now trying to implement the same script in Go to compare performance, note I am completely new to Go.  Opening the file and iterating over the lines is fine, however I cannot figure out how to use the ""crypto"" library to hash the string in the same way as Python's crypt.crypt(str_to_hash, salt).  I thought it maybe something like</p>

<pre><code>import ""crypto/des""
des.NewCipher([]byte(""abcdefgh""))
</code></pre>

<p>However, no cigar.  Any help would be much appreciated as it'd be really interesting to compare Go's parallel performance to Python's multithreaded.  </p>

<p>Edit:
<a href=""http://docs.python.org/2/library/crypt.html"" rel=""nofollow"">Python docs for crypt.crypt</a> </p>
","<p>Good news! There's actually an open source implementation of what you're looking for. <a href=""https://github.com/kless/osutil"" rel=""nofollow"" title=""Osutil"">Osutil</a> has a crypt package that reimplements <code>crypt</code> in pure Go.</p>

<p><a href=""https://github.com/kless/osutil/tree/master/user/crypt"" rel=""nofollow"">https://github.com/kless/osutil/tree/master/user/crypt</a></p>
","1161","<python><go><des><crypt>","5","2","4","2016-03-25 21:53:01","14113157","3","1","343223","","2013-01-01 14:04:29","2013-01-01 11:11:31",""
"23027359","Encryption of file, problems with key size","<p>This is a sample code through which I'm trying to read a file and encrypt/decrypt (if key is known for correct decryption) problem is the code is locked to accept the key of length 8, anything above or below is issuing a runtime error stating :        </p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: Invalid key length: 11     bytes
at com.sun.crypto.provider.DESCipher.engineGetKeySize(DESCipher.java:373)
at javax.crypto.Cipher.passCryptoPermCheck(Cipher.java:1052)
at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1010)
at javax.crypto.Cipher.implInit(Cipher.java:786)
at javax.crypto.Cipher.chooseProvider(Cipher.java:849)
at javax.crypto.Cipher.init(Cipher.java:1213)
at javax.crypto.Cipher.init(Cipher.java:1153)
at custom_enc.Custom_enc.encrypt(Custom_enc.java:50)
at custom_enc.Custom_enc.main(Custom_enc.java:105)
Java Result: 1
</code></pre>

<p>Class:</p>

<pre><code>package custom_enc;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.Scanner;
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.spec.SecretKeySpec;
public class Custom_enc {

String ekey="""";
String algorithm="""";
String path1="""";
File f;

public void Custom_enc()
{
    System.out.println(""Enter the file name with extension and path : \n"");
    Scanner s = new Scanner(System.in);
    String path1 = s.nextLine();
    f = new File(path1);
    System.out.println(""Enter secret key : \n"");
    ekey = s.nextLine();
}

public void encrypt() throws Exception
{
   Custom_enc();
   this.algorithm=""DES/ECB/PKCS5Padding"";
    FileInputStream fis =new FileInputStream(f);
    f=new File(f.getAbsolutePath()+""_encrypted_file.txt"");
    FileOutputStream fos =new FileOutputStream(f);

    byte k[] = ekey.getBytes();
    SecretKeySpec key = new SecretKeySpec(k,""DES"");
    Cipher encrypt = Cipher.getInstance(algorithm);

    encrypt.init(Cipher.ENCRYPT_MODE, key);
    CipherOutputStream cout=new CipherOutputStream(fos, encrypt);
    byte[] buf = new byte[1024];
    int read;

    while((read=fis.read(buf))!=-1) //reading data
        cout.write(buf,0,read); //writing encrypted data

    fis.close();
    cout.flush();
    cout.close();
    System.out.println(""Encryption Done!!"");
    //exit();
}

public void decrypt() throws Exception
{
    Custom_enc();
    this.algorithm=""DES/ECB/PKCS5Padding"";
    FileInputStream fis =new FileInputStream(f);
    f=new File(f.getAbsolutePath()+""_decrypted_file.txt"");
    FileOutputStream fos =new FileOutputStream(f);

    byte k[] = ekey.getBytes();
    SecretKeySpec key = new SecretKeySpec(k,""DES"");

    Cipher decrypt = Cipher.getInstance(algorithm);
    decrypt.init(Cipher.DECRYPT_MODE, key);
    CipherInputStream cin=new CipherInputStream(fis, decrypt);

    byte[] buf = new byte[1024];
    int read=0;

    while((read=cin.read(buf))!=-1) //reading encrypted data
    {
        fos.write(buf,0,read); //writing decrypted data
    }

    cin.close();
    fos.flush();
    fos.close();

    System.out.println(""Encryption Done!!"");
    //1exit();

}

public static void main(String[] args) throws Exception,     java.security.InvalidKeyException {
    Custom_enc obj = new Custom_enc();
    System.out.println(""Enter your choice : \n 1 For Encryption \n 2 For Decryption"");
    Scanner s1 = new Scanner(System.in);
    int choice = s1.nextInt();
    if(choice==1)
    {
        System.out.println(""You've chosen to Encrypt\n"");
        obj.encrypt();
    }
    else if(choice==2)
    {
        System.out.println(""You've chosen to Decrypt\n"");
        obj.decrypt();
    }
    else
    {
        System.out.println(""Invalid Choice, Try again..."");
    }
}

}
</code></pre>
","<p>Yes, DES uses a 64-bit key (although the effective key size is only 56-bits). 64-bits is 8 bytes, so that's your key length.</p>

<p>You can for example hashing to shrink a longer password to 64-bits, and go with that.</p>
","1149","<java><encryption><des>","0","0","2","2014-04-12 16:15:03","","2","2","1430055","","2014-04-12 07:31:18","2014-04-12 07:08:06",""
"23027359","Encryption of file, problems with key size","<p>This is a sample code through which I'm trying to read a file and encrypt/decrypt (if key is known for correct decryption) problem is the code is locked to accept the key of length 8, anything above or below is issuing a runtime error stating :        </p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: Invalid key length: 11     bytes
at com.sun.crypto.provider.DESCipher.engineGetKeySize(DESCipher.java:373)
at javax.crypto.Cipher.passCryptoPermCheck(Cipher.java:1052)
at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1010)
at javax.crypto.Cipher.implInit(Cipher.java:786)
at javax.crypto.Cipher.chooseProvider(Cipher.java:849)
at javax.crypto.Cipher.init(Cipher.java:1213)
at javax.crypto.Cipher.init(Cipher.java:1153)
at custom_enc.Custom_enc.encrypt(Custom_enc.java:50)
at custom_enc.Custom_enc.main(Custom_enc.java:105)
Java Result: 1
</code></pre>

<p>Class:</p>

<pre><code>package custom_enc;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.Scanner;
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.spec.SecretKeySpec;
public class Custom_enc {

String ekey="""";
String algorithm="""";
String path1="""";
File f;

public void Custom_enc()
{
    System.out.println(""Enter the file name with extension and path : \n"");
    Scanner s = new Scanner(System.in);
    String path1 = s.nextLine();
    f = new File(path1);
    System.out.println(""Enter secret key : \n"");
    ekey = s.nextLine();
}

public void encrypt() throws Exception
{
   Custom_enc();
   this.algorithm=""DES/ECB/PKCS5Padding"";
    FileInputStream fis =new FileInputStream(f);
    f=new File(f.getAbsolutePath()+""_encrypted_file.txt"");
    FileOutputStream fos =new FileOutputStream(f);

    byte k[] = ekey.getBytes();
    SecretKeySpec key = new SecretKeySpec(k,""DES"");
    Cipher encrypt = Cipher.getInstance(algorithm);

    encrypt.init(Cipher.ENCRYPT_MODE, key);
    CipherOutputStream cout=new CipherOutputStream(fos, encrypt);
    byte[] buf = new byte[1024];
    int read;

    while((read=fis.read(buf))!=-1) //reading data
        cout.write(buf,0,read); //writing encrypted data

    fis.close();
    cout.flush();
    cout.close();
    System.out.println(""Encryption Done!!"");
    //exit();
}

public void decrypt() throws Exception
{
    Custom_enc();
    this.algorithm=""DES/ECB/PKCS5Padding"";
    FileInputStream fis =new FileInputStream(f);
    f=new File(f.getAbsolutePath()+""_decrypted_file.txt"");
    FileOutputStream fos =new FileOutputStream(f);

    byte k[] = ekey.getBytes();
    SecretKeySpec key = new SecretKeySpec(k,""DES"");

    Cipher decrypt = Cipher.getInstance(algorithm);
    decrypt.init(Cipher.DECRYPT_MODE, key);
    CipherInputStream cin=new CipherInputStream(fis, decrypt);

    byte[] buf = new byte[1024];
    int read=0;

    while((read=cin.read(buf))!=-1) //reading encrypted data
    {
        fos.write(buf,0,read); //writing decrypted data
    }

    cin.close();
    fos.flush();
    fos.close();

    System.out.println(""Encryption Done!!"");
    //1exit();

}

public static void main(String[] args) throws Exception,     java.security.InvalidKeyException {
    Custom_enc obj = new Custom_enc();
    System.out.println(""Enter your choice : \n 1 For Encryption \n 2 For Decryption"");
    Scanner s1 = new Scanner(System.in);
    int choice = s1.nextInt();
    if(choice==1)
    {
        System.out.println(""You've chosen to Encrypt\n"");
        obj.encrypt();
    }
    else if(choice==2)
    {
        System.out.println(""You've chosen to Decrypt\n"");
        obj.decrypt();
    }
    else
    {
        System.out.println(""Invalid Choice, Try again..."");
    }
}

}
</code></pre>
","<p>The problem is that you are confusing a password or pass phrase and a key; <em>a password is not a key</em>.</p>

<p>It is however possible to <strong>derive</strong> a password from a key. You should use a Password Based Key Derivation Function (PBKDF) to do so. There are a few of them that are safe to use: scrypt, bcrypt and PBKDF2. The latter is also present within the standard Oracle implementation of Java. It is part of the functions to support Password Based Encryption (PBE) in Java, as specified in the PKCS#5 standard.</p>

<p>See for instance the code <a href=""https://stackoverflow.com/questions/2375541/password-verification-with-pbkdf2-in-java"">in this question</a> on how to utilize PBKDF2. Note that you have to create a salt (a secure random value of 64 bits or more) and add store it with your ciphertext. </p>
","1149","<java><encryption><des>","0","0","2","2014-04-12 16:15:03","","2","2","1430055","","2014-04-12 07:31:18","2014-04-12 07:08:06",""
"35339305","Android DES decryption ECB mode","<p>I am trying to dectypt data,<br>
which was encrypted with mcrypt<br>
DES, ECB mode<br>
and then wrapped into Base64.
Here is my code: </p>

<pre><code>static {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
}
// ...

// Crypted input data and the key
String criptedInput = ""vsm1/sLWAUxW7JjKT/Amww=="";
final String KEY = ""jf7746yghndd"";

// Decoding base64
byte[] bytesDecoded = Base64.decodeBase64(criptedInput.getBytes());

SecretKeySpec key = new SecretKeySpec(KEY.getBytes(), ""DES"");

Cipher cipher = null;
String result = null;

try {
    cipher = Cipher.getInstance(""DES/ECB/PKCS7Padding"", ""BC"");

    // Initialize the cipher for decryption
    cipher.init(Cipher.DECRYPT_MODE, key);

    // Decrypt the text
    byte[] textDecrypted = cipher.doFinal(bytesDecoded);

    result = new String(textDecrypted);

} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
} catch (NoSuchProviderException e) {
    e.printStackTrace();
} catch (NoSuchPaddingException e) {
    e.printStackTrace();
} catch (IllegalBlockSizeException e) {
    e.printStackTrace();
} catch (BadPaddingException e) {
    e.printStackTrace();
} catch (InvalidKeyException e) {
    e.printStackTrace();
}
</code></pre>

<p>Now I am catching java.security.invalidkeyexception: des key too long - should be 8 bytes..</p>

<p>What is wrong?</p>
","<p>DES supports only a key size of 56 bit (64 bit with parity). So you cannot use a larger key with it. Mcrypt knows this and silently only uses the first 8 bytes. Mcrypt also doesn't implement proper padding. Instead it pads with 0x00 bytes. You should be able to use a similar, but not same, padding in BouncyCastle:</p>

<pre><code>Cipher.getInstance(""DES/ECB/ZeroBytePadding"", ""BC"");
</code></pre>

<hr>

<p><strong>Never use <a href=""https://crypto.stackexchange.com/q/14487/13022"">ECB mode</a></strong>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like <a href=""https://crypto.stackexchange.com/q/22260/13022"">CBC</a> or <a href=""https://crypto.stackexchange.com/a/2378/13022"">CTR</a>. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p>
","1146","<android><encryption><des>","0","2","1","2016-02-11 12:50:55","35339687","1","3","1816580","","2016-02-11 12:44:11","2016-02-11 12:25:28",""
"23734926","Size of key is too large for DES encryption","<p>I was given </p>

<pre><code>string: exchanges
key: exchanges1234
</code></pre>

<p>and need to encrypt it with 64-bit DES encryption.
I try to use php to enrypt it.</p>

<pre><code>mcrypt_encrypt(MCRYPT_DES, $key, $str, MCRYPT_MODE_ECB)
</code></pre>

<p>But it return </p>

<blockquote>
  <p>PHP Warning:  mcrypt_encrypt(): Size of key is too large for this algorithm in</p>
</blockquote>

<p>Why is it so?</p>
","<p>""Size of key is too large for this algorithm"" is because you're using too big of a key. :)</p>

<p>A 64-bit key means you need a 64-bit key. With 8 bits per byte, this means 64/8 = 8, so your key needs to be exactly 8 bytes long.</p>
","1141","<php><encryption><des>","-1","0","1","2014-05-19 10:36:18","","1","","445517","","2014-05-19 10:36:18","2014-05-19 10:04:46",""
"41825573","What is the Key Length of the des-ede-cbc cipher?","<p>I know that DES has a key length of 56, but what does the ede mean and does it effect the key length?</p>

<p>Openssl<br>
des-ede-cbc</p>
","<p>Triple DES, DES-EDE or TDEA (formally speaking) can be used with no less than 3 key sizes.</p>

<p>The most logical form uses 3 separate keys for each of the phases (Encrypt, Decrypt and then Encrypt again, which is the meaning of EDE). It has a key size of 3 times 56 bits or 168 bits, but those are usually encoded with parity bits (the least significant bit of each byte), making 192 bits in total. Due to a meet-in-the-middle attack (already known at the design phase) the security is only around 112 bits, so don't be fooled by the key size alone.</p>

<p>The two key DES-EDE uses the same keys for the Encrypt phases. The key size is therefore 112 bits, encoded as 128 bits and a security of just around 80 bits, due to various attacks. 80 bits is probably just a bit on the short side nowadays.</p>

<p>Finally single key DES-EDE is mainly used for backwards compatibility. The first encrypt and decrypt cancel each other out so you're left with just one encrypt. You can guess the key sizes; single key TDES is never used in software and may not be supported (it just makes sense in hardware, where you don't want to supply a separate implementation of DES in addition to DES-EDE).</p>

<hr>

<p>DES-EDE is much slower than a good implementation of AES, and AES has a security of around 126,8 for a key size of 128 bits (using a very complicated attack). So if you have any chance, choose AES instead.</p>
","1140","<encryption><openssl><key><aes><des>","1","2","1","2018-09-23 03:42:52","","1","","214143","","2018-09-23 03:42:52","2017-01-24 10:19:40",""
"20860772","DES and ICryptoTransform","<p>This method works fine in a program I've made. However I cannot really understand what is happening and where the encryption is actually performed. I read the related description from MSDN but not much information is given.
Can someone explain what is happening in general especially in line 8 and 9 please.</p>

<pre><code> public byte[] Decrypt(byte[] input, byte[] key, byte[] iv)
    {
        DES des = new DESCryptoServiceProvider();
        des.Mode = CipherMode.ECB;
        des.Padding = PaddingMode.None;
        des.Key = key;

        ICryptoTransform ct = des.CreateDecryptor(key, iv);
        byte[] result = ct.TransformFinalBlock(input, 0, input.Length);

        return result;
    }
</code></pre>
","<p>If you want to understand what is going on, you should read about block cipher operations here:</p>

<p><a href=""http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29"" rel=""nofollow"">http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29</a></p>

<p>In a nutshell, block ciphers chaining causes the input of one block operation to be fed into the next block operation. This obscures any block-level patterns in the ciphertext. Since there is a chaining structure, the last block gets an input from the second last block, and so on... until the second block gets an input from the first block. Now the first block needs to get an input from something, but there are no preceding blocks. So we use something called an Initialization Vector (iv) to start it off. This IV does not need to be secret like the key, but it does need to have a low probability of re-use (otherwise the attacker can use it to correlate the first blocks of all your ciphertexts). Typically random numbers are used, or sometimes increasing sequence numbers.</p>

<p>In regard to the specific call:</p>

<p>Your method works to decrypt a single block using DES. (Which is nowadays considered out of date and insecure, by the way, please consider using AES instead - the block cipher structures remain the same so all you need to do is swap the library). Anyway,</p>

<p>Since you're using a cipher in ECB mode, each block is decrypted independently with the same initialization vector, which is provided to your Decrypt method call. The call to CreateDecryptor initializes a decryption object using the provided secret key and initialization vector.</p>

<p>The actual decryption is performed using the call to TransformFinalBlock. The arguments are the input byte array, and then an offset and a length parameter (used for when you don't want to decrypt the entire byte array). In this case you do want to use the entire byte array so the starting offset is 0 and the size is the length of the whole byte array.</p>

<p>One thing you should probably add is to check that the input byte array is the correct block size for your cipher, otherwise it will throw an exception. In the case of DES, this is 64 bits. If you switch to AES as I recommended it will be 128 bits.</p>
","1133","<transform><des><cryptoapi><crypt>","0","1","1","2017-07-10 23:03:08","","1","","407105","","2017-07-10 23:03:08","2013-12-31 17:04:42",""
"33595350","Brute-force crack time for 56 bits and 64 bits (DES)","<p>I've been looking online for a simple way to calculate the average time it would take a computer to crack a 56 bit and 64-bit key using a brute-force but I can't find any simple explanation for it or a formula to calculate it. </p>

<p>Is there a way I can calculate how long it would take to brute-force 56-bits and how would I calculate how much the time would increase by if i increase the key by 1 bit?</p>
","<p>It strongly depends on an algorithm implementation (raw or heavily optimized) and hardware which this implementation will be run on (CPU (multicore?), GPU or FPGA, ASIC). 
However, you can check some benchmarks of oclhashcat (GPU) and john the ripper (CPU), and then divide keyspace size 2^56 or 2^64 by number of combinations these crackers do per second. Then you can easily convert it to minutes, hours and so on...</p>
","1121","<security><aes><brute-force><des>","0","1","1","2015-11-08 19:50:51","","3","","4534197","","2015-11-08 15:07:22","2015-11-08 15:01:46","2015-11-09 03:12:35"
"11271671","is this possible to encrypt and decrypt a zip file using DES algorithm in java","<p>I have to encrypt and decrypt a zip file using DES Algorithm by using a KEY which is stored in a text file.Both Encrypt and Decrypt algorithm takes key from the text file to do the corresponding functionalities.</p>

<p>Is there any built-in packages available for doing DES algorithm in java...</p>

<p>Please Guide me to get out of this issue...</p>
","<p>you could use stuff from javax.crypto package:</p>

<pre><code>        // read the key
    FileInputStream fis = new FileInputStream(keyFile);
    byte[] keyBytes = new byte[fis.available()];
    fis.read(keyBytes);
    SecretKeySpec spec = new SecretKeySpec(keyBytes, ""DES"");

    // encrypt
    Cipher encCipher = Cipher.getInstance(""DES"");
    encCipher.init(Cipher.ENCRYPT_MODE, spec);

    CipherInputStream cipherIn = new CipherInputStream(new FileInputStream(zipFile), encCipher);
    FileChannel out = new FileOutputStream(encZipFile).getChannel();
    out.transferFrom(Channels.newChannel(cipherIn), 0, Long.MAX_VALUE);

    // decrypt
    Cipher decCipher = Cipher.getInstance(""DES"");
    decCipher.init(Cipher.DECRYPT_MODE, spec);

    cipherIn = new CipherInputStream(new FileInputStream(encZipFile), decCipher);
    out = new FileOutputStream(decZipFile).getChannel();
    out.transferFrom(Channels.newChannel(cipherIn), 0, Long.MAX_VALUE);
</code></pre>
","1100","<java><des>","0","4","2","2012-07-26 05:01:19","11271845","2","3","","","","2012-06-30 05:22:14",""
"11271671","is this possible to encrypt and decrypt a zip file using DES algorithm in java","<p>I have to encrypt and decrypt a zip file using DES Algorithm by using a KEY which is stored in a text file.Both Encrypt and Decrypt algorithm takes key from the text file to do the corresponding functionalities.</p>

<p>Is there any built-in packages available for doing DES algorithm in java...</p>

<p>Please Guide me to get out of this issue...</p>
","<p>It is possible.Better u go for bouncy castly.They provide the API for that.</p>
","1100","<java><des>","0","0","2","2012-07-26 05:01:19","11271845","2","3","","","","2012-06-30 05:22:14",""
"11004378","Difference between .NET and PHP encryption","<p>I have the following c# code that generates keys:</p>

<pre><code>    public static byte[] Encrypt(byte[] plainData, string salt)
    {
        DESCryptoServiceProvider DES = new DESCryptoServiceProvider();
        DES.Key = ASCIIEncoding.ASCII.GetBytes(salt);
        DES.IV = ASCIIEncoding.ASCII.GetBytes(salt);
        ICryptoTransform desencrypt = DES.CreateEncryptor();
        byte[] encryptedData = desencrypt.TransformFinalBlock(plainData, 0, plainData.Length);
        return encryptedData;
    }

    private string GetEncryptedKey(string key)
    {
        return BitConverter.ToString(KeyGeneratorForm.Encrypt(ASCIIEncoding.ASCII.GetBytes(key), ""abcdefgh"")).Replace(""-"", """");
    }
</code></pre>

<p>I'm trying to perform the same thing in PHP:</p>

<pre><code>function get_encrypted_key($key){
    $salt = ""abcdefgh"";
    return bin2hex(mcrypt_encrypt(MCRYPT_DES, $salt, $key, MCRYPT_MODE_CBC, $salt));
}
</code></pre>

<p>However, there is a small discrepency in the results, as the last 16 chars are always different:</p>

<pre><code>With key ""Benjamin Franklin"":
C# : 0B3C6E5DF5D747FB3C50DE952FECE3999768F35B890BC391
PHP: 0B3C6E5DF5D747FB3C50DE952FECE3993A881F9AF348C64D

With key ""President Franklin D Roosevelt"":
C# : C119B50A5A7F8C905A86A43F5694B4D7DD1E8D0577F1CEB32A86FABCEA5711E1
PHP: C119B50A5A7F8C905A86A43F5694B4D7DD1E8D0577F1CEB37ACBE60BB1D21F3F
</code></pre>

<p>I've also tried to perform the padding transform to my key using the following code:</p>

<pre><code>function get_encrypted_key($key){
    $salt = ""abcdefgh"";

    $extra = 8 - (strlen($key) % 8);
    if($extra &gt; 0) {
        for($i = 0; $i &lt; $extra; $i++) {
            $key.= ""\0"";
        }
    }

    return bin2hex(mcrypt_encrypt(MCRYPT_DES, $salt, $key, MCRYPT_MODE_CBC, $salt));
}
</code></pre>

<p>But I end up with the same results as without padding.</p>

<p>If you have any clue as to what's going on, I'd be glad to hear about it! :)</p>

<p>Thanks</p>
","<p>You mentioned trying a ""classic"" padding snippet. The following quick adaptation of the snippet posted on the <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow""><code>mcrypt_encrypt</code> documentation</a> gives the same results you were getting from C#.</p>

<p>PKCS #7 (the default padding scheme used by C#'s <code>SymmetricAlgorithm</code>) pads with bytes where each padding byte's value is the same as the number of bytes of padding, not with zero bytes.</p>

<pre><code>function get_encrypted_key($key)
{
    $salt = 'abcdefgh';
    $block = mcrypt_get_block_size('des', 'cbc');
    $pad = $block - (strlen($key) % $block);
    $key .= str_repeat(chr($pad), $pad);

    return bin2hex(mcrypt_encrypt(MCRYPT_DES, $salt, $key, MCRYPT_MODE_CBC, $salt));
}
</code></pre>

<p>Test output:</p>

<pre class=""lang-none prettyprint-override""><code>php &gt; echo get_encrypted_key('Benjamin Franklin');
0b3c6e5df5d747fb3c50de952fece3999768f35b890bc391
php &gt; echo get_encrypted_key('President Franklin D Roosevelt');
c119b50a5a7f8c905a86a43f5694b4d7dd1e8d0577f1ceb32a86fabcea5711e1
</code></pre>
","1096","<php><.net><encryption><des>","7","4","1","2012-06-12 21:02:43","11004670","5","","25152","","2012-06-12 20:47:32","2012-06-12 20:30:44",""
"26161027","Python 2 - Decrypt Java's PBEWithMD5AndDES","<p>This question is related to this one: <a href=""https://stackoverflow.com/questions/24168246/replicate-javas-pbewithmd5anddes-in-python-2-7"">Replicate Java&#39;s PBEWithMD5AndDES in Python 2.7</a>
<hr>
This was the answer of the question (Python code):</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES

_password = 'q1w2e3r4t5y6'
_salt = '\x80\x40\xe0\x10\xf8\x04\xfe\x01'
_iterations = 50

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    print ""Enter the password to encrypt:"",
    plaintext_to_encrypt = raw_input()

    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    # Pad plaintext per RFC 2898 Section 6.1
    padding = 8 - len(plaintext_to_encrypt) % 8
    plaintext_to_encrypt += chr(padding) * padding

    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])
    encrypted = encoder.encrypt(plaintext_to_encrypt)

    print encrypted.encode('base64')
</code></pre>

<p>I'm now trying to do the reverse operation (<strong>decrypt</strong>) with knowing the <em>_password</em>, <em>_salt</em> and <em>_iterations</em> variables, of course.</p>

<p><code>print encoder.decrypt(encrypted)</code> doesn't match the initial password.</p>

<p>I don't know what to do next. I read the §6.1.2 of the <a href=""http://tools.ietf.org/html/rfc2898#section-6.1"" rel=""nofollow noreferrer"">rfc2898</a> but it didn't help me. Can anyone guide me to the right answer?</p>

<p><strong>EDIT :</strong><br>
Seems like the following is needed:</p>

<pre><code>encoder2 = DES.new(result[:8], DES.MODE_CBC, result[8:16])
print encoder2.decrypt(encrypted)
</code></pre>

<p>Why do I have to use <code>DES.new()</code> again? How can I get rid of the padding?<br>
Actual decrypted output for ""123456"" is <code>123456☻☻</code></p>
","<p>Just take the last byte and remove as many characters as it encodes (including the last byte).</p>

<p>Beware that you should add an authentication tag if you are vulnerable to error oracles such as padding oracles.</p>
","1089","<python><python-2.7><encryption><md5><des>","2","0","2","2017-06-14 09:17:36","","0","","-1","","2017-05-23 12:23:44","2014-10-02 12:40:57",""
"26161027","Python 2 - Decrypt Java's PBEWithMD5AndDES","<p>This question is related to this one: <a href=""https://stackoverflow.com/questions/24168246/replicate-javas-pbewithmd5anddes-in-python-2-7"">Replicate Java&#39;s PBEWithMD5AndDES in Python 2.7</a>
<hr>
This was the answer of the question (Python code):</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES

_password = 'q1w2e3r4t5y6'
_salt = '\x80\x40\xe0\x10\xf8\x04\xfe\x01'
_iterations = 50

if ""__main__"" == __name__:

    """"""Mimic Java's PBEWithMD5AndDES algorithm to produce a DES key""""""
    print ""Enter the password to encrypt:"",
    plaintext_to_encrypt = raw_input()

    hasher = MD5.new()
    hasher.update(_password)
    hasher.update(_salt)
    result = hasher.digest()

    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    # Pad plaintext per RFC 2898 Section 6.1
    padding = 8 - len(plaintext_to_encrypt) % 8
    plaintext_to_encrypt += chr(padding) * padding

    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])
    encrypted = encoder.encrypt(plaintext_to_encrypt)

    print encrypted.encode('base64')
</code></pre>

<p>I'm now trying to do the reverse operation (<strong>decrypt</strong>) with knowing the <em>_password</em>, <em>_salt</em> and <em>_iterations</em> variables, of course.</p>

<p><code>print encoder.decrypt(encrypted)</code> doesn't match the initial password.</p>

<p>I don't know what to do next. I read the §6.1.2 of the <a href=""http://tools.ietf.org/html/rfc2898#section-6.1"" rel=""nofollow noreferrer"">rfc2898</a> but it didn't help me. Can anyone guide me to the right answer?</p>

<p><strong>EDIT :</strong><br>
Seems like the following is needed:</p>

<pre><code>encoder2 = DES.new(result[:8], DES.MODE_CBC, result[8:16])
print encoder2.decrypt(encrypted)
</code></pre>

<p>Why do I have to use <code>DES.new()</code> again? How can I get rid of the padding?<br>
Actual decrypted output for ""123456"" is <code>123456☻☻</code></p>
","<p>Do like this</p>

<pre><code>    decrypted = encoder2.decrypt(encrypted)
    print decrypted.rstrip('\2,\1,\3,\4,\5,\6,\7')
</code></pre>

<p>Length of ""123456"" is 6 and the decrypter outputs 8 bytes. The remaining position is filled with a default byte, so the <code>rstrip</code> strips the bytes and gives the string.</p>

<p>EDIT: I have created a gist refer this
<a href=""https://gist.github.com/rohitshampur/da5f79c34260150aafc1"" rel=""nofollow noreferrer"">Link</a></p>
","1089","<python><python-2.7><encryption><md5><des>","2","1","2","2017-06-14 09:17:36","","0","","-1","","2017-05-23 12:23:44","2014-10-02 12:40:57",""
"31992205","C++ des encrypt with ecb","<p>I have this line code in C++</p>

<pre><code>ecb_crypt((char *)&amp;pKey-&gt;left, (char *)pResult, 8, DES_ENCRYPT);
</code></pre>

<p>I have to use this but.. I don't know how! I mean, someone gave me this and said ""Please note that ecb_crypt comes from a standard encryption library (e.g. openSSL)."".</p>

<p>Ok, so I've installed openSSL, but I can't find this function. I found something similar, but with different arguments (AES_ecb_encrypt).</p>

<p>So, I try to ask you: do you know where I can find ecb_encrypt with those arguments? Where? Is it in openSSL?</p>

<p>It is used, for example, in this way:</p>

<pre><code>void DesEncrypt3Des(void *pResult, const void *pData, KEY_3DES *pKey)
{
    memcpy(pResult, pData, 8);
    ecb_crypt((char *)&amp;pKey-&gt;left, (char *)pResult, 8, DES_ENCRYPT);
    ecb_crypt((char *)&amp;pKey-&gt;right, (char *)pResult, 8, DES_DECRYPT);
    ecb_crypt((char *)&amp;pKey-&gt;left, (char *)pResult, 8, DES_ENCRYPT);
}
</code></pre>

<p>Further, I don't have any idea what is DES_ENCRYPT in the parameter. I think it is a constant I have to define, but with which value?</p>

<p><strong>UPDATE</strong> --> I'm using this in Visual Studio 2013</p>
","","1089","<c++><algorithm><encryption><openssl><des>","0","","0","2015-08-13 15:18:04","","12","","819161","","2015-08-13 15:18:04","2015-08-13 15:13:18",""
"21717596","Generating DES Subkeys from 64b Master Key","<p>Trying to generate DES sub-keys from master key. I have this so far. Not sure why it produces incorrect results. I have looked over everything and I'm pretty sure I have the right idea, although this is a difficult thing to tst for correctness. Am I fundamentally misunderstanding something or is it just sloppy coding?</p>

<pre><code>def main():
master = input(""Hexidecimal key (omit 0x): "")

# Convert to binary
scale = 16 
num_of_bits = 64
master_bin = bin(int(master, scale))[2:].zfill(num_of_bits)

PC1 = [57, 49, 41, 33, 25, 17, 9,
       1, 58, 50, 42, 34, 26, 18,
       10, 2, 59, 51, 43, 35, 27,
       19, 11, 3, 60, 52, 44, 36,
       63, 55, 47, 39, 31, 23, 15,
       7, 62, 54, 46, 38, 30, 22,
       14, 6, 61, 53, 45, 37, 29,
       21, 13, 5, 28, 20, 12, 4]

PC2 = [14, 17, 11, 24, 1, 5,
       3, 28, 15, 6, 21, 10,
       23, 19, 12, 4, 26, 8,
       16, 7, 27, 20, 13, 2,
       41, 52, 31, 37, 47, 55,
       30, 40, 51, 45, 33, 48,
       44, 49, 39, 56, 34, 53,
       46, 42, 50, 36, 29, 32]

# Do PC1
key_after_PC1 = []
for bit in PC1:
    key_after_PC1.append(master_bin[bit-1])

CL = []
CR = []

for j in range(28):
    CL.append(key_after_PC1[j])
    CR.append(key_after_PC1[j+28])

# Do 16 Rounds
for i in range(16):

    # Do Shifts
    if (i == 0 or i == 1 or i == 8 or i == 15):
        CL.append(CL[0])
        CL.pop(0)
        CR.append(CR[0])
        CR.pop(0)
    else:
        CL.append(CL[0])
        CL.append(CL[1])
        CL.pop(0)
        CL.pop(0)
        CR.append(CR[0])
        CR.append(CR[1])
        CR.pop(0)
        CR.pop(0)

    # Put Lists Back Together
    SK = []
    for bit in CL:
        SK.append(bit)
    for bit in CR:
        SK.append(bit)

    # Do PC2
    subkey_after_PC2 = []
    for bit in PC2:
        subkey_after_PC2.append(SK[bit-1])


    # Print Subkey as String
    subkey = """"
    for bit in subkey_after_PC2: 
        subkey += bit
    hex_subkey = hex(int(subkey, 2))
    print (""Subkey "" + str(i+1) + "": "" + hex_subkey)    

    if __name__ == '__main__':
        main()
</code></pre>
","<p>I'm no python coder, but if you fill an integer array with the input block bit index value instead of using some binary bit values you can generate something verifiable.</p>

<pre><code>keytab -b

Table of Input Block selected key bits


  Bit  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
KS
   1  10 51 34 60 49 17 33 57  2  9 19 42  3 35 26 25 44 58 59  1 36 27 18 41
   2   2 43 26 52 41  9 25 49 59  1 11 34 60 27 18 17 36 50 51 58 57 19 10 33
   3  51 27 10 36 25 58  9 33 43 50 60 18 44 11  2  1 49 34 35 42 41  3 59 17
   4  35 11 59 49  9 42 58 17 27 34 44  2 57 60 51 50 33 18 19 26 25 52 43  1
   5  19 60 43 33 58 26 42  1 11 18 57 51 41 44 35 34 17  2  3 10  9 36 27 50
   6   3 44 27 17 42 10 26 50 60  2 41 35 25 57 19 18  1 51 52 59 58 49 11 34
   7  52 57 11  1 26 59 10 34 44 51 25 19  9 41  3  2 50 35 36 43 42 33 60 18
   8  36 41 60 50 10 43 59 18 57 35  9  3 58 25 52 51 34 19 49 27 26 17 44  2
   9  57 33 52 42  2 35 51 10 49 27  1 60 50 17 44 43 26 11 41 19 18  9 36 59
  10  41 17 36 26 51 19 35 59 33 11 50 44 34  1 57 27 10 60 25  3  2 58 49 43
  11  25  1 49 10 35  3 19 43 17 60 34 57 18 50 41 11 59 44  9 52 51 42 33 27
  12   9 50 33 59 19 52  3 27  1 44 18 41  2 34 25 60 43 57 58 36 35 26 17 11
  13  58 34 17 43  3 36 52 11 50 57  2 25 51 18  9 44 27 41 42 49 19 10  1 60
  14  42 18  1 27 52 49 36 60 34 41 51  9 35  2 58 57 11 25 26 33  3 59 50 44
  15  26  2 50 11 36 33 49 44 18 25 35 58 19 51 42 41 60  9 10 17 52 43 34 57
  16  18 59 42  3 57 25 41 36 10 17 27 50 11 43 34 33 52  1  2  9 44 35 26 49

  Bit 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
KS
   1  22 28 39 54 37  4 47 30  5 53 23 29 61 21 38 63 15 20 45 14 13 62 55 31
   2  14 20 31 46 29 63 39 22 28 45 15 21 53 13 30 55  7 12 37  6  5 54 47 23
   3  61  4 15 30 13 47 23  6 12 29 62  5 37 28 14 39 54 63 21 53 20 38 31  7
   4  45 55 62 14 28 31  7 53 63 13 46 20 21 12 61 23 38 47  5 37  4 22 15 54
   5  29 39 46 61 12 15 54 37 47 28 30  4  5 63 45  7 22 31 20 21 55  6 62 38
   6  13 23 30 45 63 62 38 21 31 12 14 55 20 47 29 54  6 15  4  5 39 53 46 22
   7  28  7 14 29 47 46 22  5 15 63 61 39  4 31 13 38 53 62 55 20 23 37 30  6
   8  12 54 61 13 31 30  6 20 62 47 45 23 55 15 28 22 37 46 39  4  7 21 14 53
   9   4 46 53  5 23 22 61 12 54 39 37 15 47  7 20 14 29 38 31 63 62 13  6 45
  10  55 30 37 20  7  6 45 63 38 23 21 62 31 54  4 61 13 22 15 47 46 28 53 29
  11  39 14 21  4 54 53 29 47 22  7  5 46 15 38 55 45 28  6 62 31 30 12 37 13
  12  23 61  5 55 38 37 13 31  6 54 20 30 62 22 39 29 12 53 46 15 14 63 21 28
  13   7 45 20 39 22 21 28 15 53 38  4 14 46  6 23 13 63 37 30 62 61 47  5 12
  14  54 29  4 23  6  5 12 62 37 22 55 61 30 53  7 28 47 21 14 46 45 31 20 63
  15  38 13 55  7 53 20 63 46 21  6 39 45 14 37 54 12 31  5 61 30 29 15  4 47
  16  30  5 47 62 45 12 55 38 13 61 31 37  6 29 46  4 23 28 53 22 21  7 63 39
</code></pre>

<p>This essentially shows the C register as input block bits followed by the D register for input block bits for the 16 selected keys (by PC2).  This table is from the Meyers/Metyas book <strong>Cryptography</strong> generated by a C program I wrote in the '90s, validating various tables in the book.</p>

<p>There's another table generated by the -s option that shows the selected keys as a function of C and D register bits.</p>

<pre><code>keytab -s

Table of CD Reg selected key bits


  Bit  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
KS
   1  15 18 12 25  2  6  4  1 16  7 22 11 24 20 13  5 27  9 17  8 28 21 14  3
   2  16 19 13 26  3  7  5  2 17  8 23 12 25 21 14  6 28 10 18  9  1 22 15  4
   3  18 21 15 28  5  9  7  4 19 10 25 14 27 23 16  8  2 12 20 11  3 24 17  6
   4  20 23 17  2  7 11  9  6 21 12 27 16  1 25 18 10  4 14 22 13  5 26 19  8
   5  22 25 19  4  9 13 11  8 23 14  1 18  3 27 20 12  6 16 24 15  7 28 21 10
   6  24 27 21  6 11 15 13 10 25 16  3 20  5  1 22 14  8 18 26 17  9  2 23 12
   7  26  1 23  8 13 17 15 12 27 18  5 22  7  3 24 16 10 20 28 19 11  4 25 14
   8  28  3 25 10 15 19 17 14  1 20  7 24  9  5 26 18 12 22  2 21 13  6 27 16
   9   1  4 26 11 16 20 18 15  2 21  8 25 10  6 27 19 13 23  3 22 14  7 28 17
  10   3  6 28 13 18 22 20 17  4 23 10 27 12  8  1 21 15 25  5 24 16  9  2 19
  11   5  8  2 15 20 24 22 19  6 25 12  1 14 10  3 23 17 27  7 26 18 11  4 21
  12   7 10  4 17 22 26 24 21  8 27 14  3 16 12  5 25 19  1  9 28 20 13  6 23
  13   9 12  6 19 24 28 26 23 10  1 16  5 18 14  7 27 21  3 11  2 22 15  8 25
  14  11 14  8 21 26  2 28 25 12  3 18  7 20 16  9  1 23  5 13  4 24 17 10 27
  15  13 16 10 23 28  4  2 27 14  5 20  9 22 18 11  3 25  7 15  6 26 19 12  1
  16  14 17 11 24  1  5  3 28 15  6 21 10 23 19 12  4 26  8 16  7 27 20 13  2

  Bit 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
KS
   1  42 53 32 38 48 56 31 41 52 46 34 49 45 50 40 29 35 54 47 43 51 37 30 33
   2  43 54 33 39 49 29 32 42 53 47 35 50 46 51 41 30 36 55 48 44 52 38 31 34
   3  45 56 35 41 51 31 34 44 55 49 37 52 48 53 43 32 38 29 50 46 54 40 33 36
   4  47 30 37 43 53 33 36 46 29 51 39 54 50 55 45 34 40 31 52 48 56 42 35 38
   5  49 32 39 45 55 35 38 48 31 53 41 56 52 29 47 36 42 33 54 50 30 44 37 40
   6  51 34 41 47 29 37 40 50 33 55 43 30 54 31 49 38 44 35 56 52 32 46 39 42
   7  53 36 43 49 31 39 42 52 35 29 45 32 56 33 51 40 46 37 30 54 34 48 41 44
   8  55 38 45 51 33 41 44 54 37 31 47 34 30 35 53 42 48 39 32 56 36 50 43 46
   9  56 39 46 52 34 42 45 55 38 32 48 35 31 36 54 43 49 40 33 29 37 51 44 47
  10  30 41 48 54 36 44 47 29 40 34 50 37 33 38 56 45 51 42 35 31 39 53 46 49
  11  32 43 50 56 38 46 49 31 42 36 52 39 35 40 30 47 53 44 37 33 41 55 48 51
  12  34 45 52 30 40 48 51 33 44 38 54 41 37 42 32 49 55 46 39 35 43 29 50 53
  13  36 47 54 32 42 50 53 35 46 40 56 43 39 44 34 51 29 48 41 37 45 31 52 55
  14  38 49 56 34 44 52 55 37 48 42 30 45 41 46 36 53 31 50 43 39 47 33 54 29
  15  40 51 30 36 46 54 29 39 50 44 32 47 43 48 38 55 33 52 45 41 49 35 56 31
  16  41 52 31 37 47 55 30 40 51 45 33 48 44 49 39 56 34 53 46 42 50 36 29 32
</code></pre>

<p>You could note KS 16 happens to reflect PC2.  Which tells us when right shifting C and D for decryption to reverse the selected key order shifts occur after using the round key while during encryption (and as you have shown) the left shifts are applied before using the round key.  If you tabularize the round keys you'd tend to use the encode method and select them backward for decryption.</p>

<p>What distinguishes the keytab program from yours appears to only reside in having PC1 and PC2 permutations bifurcated for the C and D registers separately.</p>

<p>keytab.c:  (should be fairly highly portable)</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

/* PC1 maps input bytes to C and D registers  */

static int PC1_C[] = {      
                57,49,41,33,25,17, 9,
                1,58,50,42,34,26,18,
                10, 2,59,51,43,35,27,
                19,11, 3,60,52,44,36
};

static int PC1_D[] = {      
                63,55,47,39,31,23,15,
                7,62,54,46,38,30,22,
                14, 6,61,53,45,37,29,
                21,13, 5,28,20,12, 4
};

/* key shift schedule */

static int shifts[] = { 1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 };


/* PC2  selects CD bits to generate selected key */

static int PC2_C[] = {
    14,17,11,24, 1, 5,
     3,28,15, 6,21,10,
    23,19,12, 4,26, 8,
    16, 7,27,20,13, 2
};

static int PC2_D[] = {
    41,52,31,37,47,55,
    30,40,51,45,33,48,
    44,49,39,56,34,53,
    46,42,50,36,29,32
};

/* The C and D arrays used to calculate the key schedule */

static int C[28];
static int D[28];

static int input[16][64];   /* Input key bits used in each KS */
static int corre[16][16];   /* correlation between keys */
static int c[28];
static int d[28];
static int cd_bits[16][48];

/* The scheduled keys, indexed by round */

static int KS[16][48];

/* Fill the key schedule */

void key_sched() {

register int index, round, shift_sched;
int temp;
int     tempcd;

/* Load C and D with input block bit values */

    for(index = 0; index &lt; 28; index++) {
    C[index] = PC1_C[index];
    c[index] = index+1;
    D[index] = PC1_D[index];
    d[index] = index+28+1;
    }

/* Rotate C and D according to key schedule apply PC2 */

    for( round = 0; round &lt; 16; round++) {

    /* first rotate */

    for(shift_sched=0;shift_sched &lt; shifts[round];shift_sched++) {
        temp = C[0];
        tempcd = c[0];
        for(index = 0; index &lt; 28-1; index++) {
        C[index] = C[index+1];
        c[index] = c[index+1];
        }
        C[27] = temp;
        c[27] = tempcd;
        temp = D[0];
        tempcd = d[0];
        for(index = 0; index &lt; 28-1; index++) {
        D[index] = D[index+1];
        d[index] = d[index+1];
        }
        D[27] = temp;
        d[27] = tempcd;
    }

    /* Apply PC2 and store in selected key */

    for(index = 0; index &lt; 24; index++) {
        KS[round][index] = C[PC2_C[index]-1];
        cd_bits[round][index] = c[PC2_C[index]-1];;
        KS[round][index+24] = D[PC2_D[index]-28-1];
        cd_bits[round][index+24] = d[PC2_D[index]-28-1];
    }
    }
}

void key_input() {
int index;
int round;

     for ( round = 0; round &lt; 16; round++ )
         for (index = 0; index &lt; 48; index++) {
             input[round][KS[round][index]] = 1; /* mark those used */
         }
}

void key_core() {
int key1,key2;
int keybit;
    for (key1 = 0; key1 &lt; 16; key1++)  
        for (key2 = 0; key2 &lt; 16; key2++) {
            corre[key1][key2] = 0;
        for (keybit = 0; keybit &lt; 64; keybit++) 
            if (input[key1][keybit] &amp; input[key2][keybit])
                corre[key1][key2]+= 1;
        }
    printf(""\n\nKS  "");
    for (key1 = 0; key1 &lt; 16; key1++)
        printf(""%2d "",key1+1);
    printf(""\n\n"");

    for (key1 = 0; key1 &lt; 16; key1++) {
        printf(""%2d  "",key1+1);
        for (key2 = 0; key2 &lt; 16; key2++) {
            if (corre[key1][key2] == 48)
                printf(""   "");
            else
                printf(""%2d "",corre[key1][key2]);
        }
        printf(""\n"");
    }
    printf(""\n"");
}

#define MAX_STR 2048
int main (argc,argv) 
int argc;
char *argv[];
{
int round;
int keybit;
extern int getopt();
extern char *optarg;
extern int optind, opterr;
char *ofile;
int input_block = 0;
int input_bit = 0;
int input_corre = 0;
int cd_bit = 0;
int i;

    while ( (i=getopt(argc,argv,""cibso:"")) != -1 )  {
        switch (i) {
        case 'c':
            input_corre = 1;
    break;
        case 'i':
            input_bit = 1;
    break;
        case 'b':
            input_block = 1;
    break;
    case 's':
        cd_bit = 1;
    break;
        case 'o':
            ofile = optarg;
            if(freopen(optarg,""w"",stdout) == NULL) {
                fprintf(stderr,""ERROR:%s, can't open %s for output\n"",
                        argv[0],optarg);
                exit(-1);
            }
        break;
        case '?':
            fprintf(stderr,""usage: %s [-i][-c][-b][-o outfile] \n"",argv[0]);
            fprintf(stderr,""\t-i shows which input block bits are used in each round\n"");
            fprintf(stderr,""\t-c shows number of key bits in common between rounds\n"");
            fprintf(stderr,""\t-b outputs key tables shown as input block bits\n""); 
            fprintf(stderr,""\t-s outputs key tables shown as CD reg bits\n""); 
            exit (-1);
        break;
        }
    }

    key_sched();

    if (cd_bit) {
        printf(""\nTable of CD Reg selected key bits\n\n"");
        printf(""\n  Bit "");
        for ( keybit = 0; keybit &lt; 24 ; keybit++)
            printf(""%2d "",keybit+1);

        printf(""\nKS\n"");

        for ( round = 0; round &lt; 16; round++) {
            printf(""  %2d  "",round+1);
            for (keybit = 0; keybit &lt; 24; keybit++) 
                printf(""%2d "",cd_bits[round][keybit]);
        printf(""\n"");
        }

        printf(""\n  Bit "");
        for ( keybit = 24; keybit &lt; 48 ; keybit++)
            printf(""%2d "",keybit+1);

        printf(""\nKS\n"");

        for ( round = 0; round &lt; 16; round++) {
            printf(""  %2d  "",round+1);
            for (keybit = 24; keybit &lt; 48; keybit++) 
                printf(""%2d "",cd_bits[round][keybit]);
            printf(""\n"");
        }
        printf(""\n%c"",'\014');
    }


    if (input_block) {
        printf(""\nTable of Input Block selected key bits\n\n"");
        printf(""\n  Bit "");
        for ( keybit = 0; keybit &lt; 24 ; keybit++)
            printf(""%2d "",keybit+1);

        printf(""\nKS\n"");

        for ( round = 0; round &lt; 16; round++) {
            printf(""  %2d  "",round+1);
            for (keybit = 0; keybit &lt; 24; keybit++) 
                printf(""%2d "",KS[round][keybit]);
        printf(""\n"");
        }

        printf(""\n  Bit "");
        for ( keybit = 24; keybit &lt; 48 ; keybit++)
            printf(""%2d "",keybit+1);

        printf(""\nKS\n"");

        for ( round = 0; round &lt; 16; round++) {
            printf(""  %2d  "",round+1);
            for (keybit = 24; keybit &lt; 48; keybit++) 
                printf(""%2d "",KS[round][keybit]);
            printf(""\n"");
        }
        printf(""\n%c"",'\014');
    }

    key_input();

    if (input_bit) {
        printf(""\n  Bit "");
        for ( keybit = 0; keybit &lt; 24 ; keybit++)
            printf(""%2d "",keybit+1);

        printf(""\nKey\n"");

        for ( round = 0; round &lt; 16; round++) {
            printf(""  %2d  "",round+1);
            for (keybit = 0; keybit &lt; 24; keybit++) 
                printf("" %c "",(input[round][keybit])?'X':'.');
        printf(""\n"");
        }

        printf(""\n  Bit "");
        for ( keybit = 24; keybit &lt; 48 ; keybit++)
            printf(""%2d "",keybit+1);

        printf(""\nKey\n"");

        for ( round = 0; round &lt; 16; round++) {
            printf(""  %2d  "",round+1);
            for (keybit = 24; keybit &lt; 48; keybit++) 
                printf("" %c "",(input[round][keybit])?'X':'.');
            printf(""\n"");
        }
        printf(""\n"");
        printf(""\n  Bit "");
        for ( keybit = 48; keybit &lt; 64 ; keybit++)
            printf(""%2d "",keybit+1);

        printf(""\nKey\n"");

        for ( round = 0; round &lt; 16; round++) {
            printf(""  %2d  "",round+1);
            for (keybit = 48; keybit &lt; 64; keybit++) 
                printf("" %c "",(input[round][keybit])?'X':'.');
        printf(""\n"");
        }
    }    
    if (input_corre) 
        key_core();
    exit (0);
}
</code></pre>

<p>There's also a javascript DES implementation floating around that's been disabled to prevent it from using arbitrary keys in an educational environment.  Capturing the page you can actual undo the disable allowing it to use arbitrary keys.  See <a href=""http://people.eku.edu/styere/Encrypt/JS-DES.html"" rel=""nofollow"">http://people.eku.edu/styere/Encrypt/JS-DES.html</a>.  The value here is in showing off internal values for each round.</p>

<p>[A copy of JS-DES.html with writable keys can be found at <a href=""http://dpades.googlecode.com/svn/trunk/simu_js/JS-DES.html"" rel=""nofollow"">http://dpades.googlecode.com/svn/trunk/simu_js/JS-DES.html</a>, the project home page (<a href=""http://code.google.com/p/dpades/"" rel=""nofollow"">http://code.google.com/p/dpades/</a>) says it's GPLv2.]</p>
","1082","<python><encryption><des>","0","0","1","2015-09-06 23:40:37","","0","1","","","","2014-02-12 02:48:38",""
"13552369","can SSL encrypt and decrypt with one key in java","<p>I have project to transfer data from client to server and I use ssl in java and I use one key to encrypt and decryption 
I use keytool to create the key </p>

<p>server
Security.addProvider(new Provider());</p>

<pre><code>        //Specifying the Keystore details
        System.setProperty(""javax.net.ssl.keyStore"",""testkeystore.ks"");
        System.setProperty(""javax.net.ssl.keyStorePassword"",""mypass"");

        // Enable debugging to view the handshake and communication which happens between the SSLClient and the SSLServer
        // System.setProperty(""javax.net.debug"",""all"");
    }


            // Initialize the Server Socket
            SSLServerSocketFactory sslServerSocketfactory = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
            sslServerSocket = (SSLServerSocket)sslServerSocketfactory.createServerSocket(intSSLport);
</code></pre>

<p>client
 System.setProperty(""javax.net.ssl.trustStore"", ""/home/lap/NetBeansProjects/Dionaea-001/testkeystore.ks"");</p>

<pre><code>    {
        // Registering the JSSE provider
        Security.addProvider(new Provider());
    }

    try {
        // Creating Client Sockets
        SSLSocketFactory sslsocketfactory = (SSLSocketFactory)SSLSocketFactory.getDefault();
        SSLSocket sslSocket = (SSLSocket)sslsocketfactory.createSocket(strServerName,intSSLport);
</code></pre>

<p>my questions 
it is possible to use one key in SSL?
how I can know the type of encryption AES or DES? </p>
","<p>The certificate and private key in your server keystore are only used for authenticating the server.</p>

<p>With SSL/TLS, the encryption keys are shared keys negotiated during the handshake.</p>

<p>You can see which encryption algorithm from the <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider"" rel=""nofollow"">cipher suites</a> that is used, which you can get from the <code>SSLSession</code> once you've established the connection. (You can get the session from the <code>SSLSocket</code>.)</p>
","1060","<java><ssl><aes><des>","0","1","1","2012-11-25 19:17:20","","0","","","","","2012-11-25 15:21:20",""
"11279195","Simple Discrete event simulation library (C++) for process/task scheduling?","<p>Simple question:
I built a quasi-processor simulator that takes a precedence graph, determines priorities (and ""ready"" instructions), schedules the tasks on available functional units, etc.  Pretty much a very basic simulator.  </p>

<p>But I realized I should have built it on top of a DES engine, as I have no capacity (other than setting a flag and checking every node on every ""clock tick"") for saying things like ""In 10 cycles, do this"" (i.e. raising signals at pre-defined times and handling events that are supposed to happen in the future or when predetermined criteria have been met).  </p>

<p>I could obviously implement this myself; built an ""event"" class, stick them on a queue, and at the end (or beginning) of every cycle, check the queue and see what's on there, but I figure there's no point in reinventing the wheel.</p>

<p>So complex network simulators are obviously WAY overkill.  I don't need fancy modeling, or queuing or anything like that.  All I need is a built in clock, and the ability to set events to happen, raise flags when things happen, etc, as I described above.</p>

<p>Freeware and C++ would be great.</p>

<p>Anyone have any ideas?  (The closest I've come -- thanks to some other somewhat related questions -- is something called SIMLIB.)</p>

<p>Thank you so much!</p>
","<p>You could try Open Virtual Platforms (<a href=""http://www.ovpworld.org/"" rel=""nofollow"">OVP</a>). It seems to provide the type of simulator that you are looking for.</p>
","1056","<c++><events><simulation><scheduler><des>","5","0","2","2012-07-12 09:09:56","","3","2","","","","2012-07-01 02:45:58",""
"11279195","Simple Discrete event simulation library (C++) for process/task scheduling?","<p>Simple question:
I built a quasi-processor simulator that takes a precedence graph, determines priorities (and ""ready"" instructions), schedules the tasks on available functional units, etc.  Pretty much a very basic simulator.  </p>

<p>But I realized I should have built it on top of a DES engine, as I have no capacity (other than setting a flag and checking every node on every ""clock tick"") for saying things like ""In 10 cycles, do this"" (i.e. raising signals at pre-defined times and handling events that are supposed to happen in the future or when predetermined criteria have been met).  </p>

<p>I could obviously implement this myself; built an ""event"" class, stick them on a queue, and at the end (or beginning) of every cycle, check the queue and see what's on there, but I figure there's no point in reinventing the wheel.</p>

<p>So complex network simulators are obviously WAY overkill.  I don't need fancy modeling, or queuing or anything like that.  All I need is a built in clock, and the ability to set events to happen, raise flags when things happen, etc, as I described above.</p>

<p>Freeware and C++ would be great.</p>

<p>Anyone have any ideas?  (The closest I've come -- thanks to some other somewhat related questions -- is something called SIMLIB.)</p>

<p>Thank you so much!</p>
","<p>Try SystemC, it's a freeware library. I'd warn though that it's not ""open-source"" since the license is not FOSS-compatible.</p>
","1056","<c++><events><simulation><scheduler><des>","5","0","2","2012-07-12 09:09:56","","3","2","","","","2012-07-01 02:45:58",""
"22231051","Encrypting a XML file in Java with a password","<p>I'm doing this project for a client and the part i'm currently stuck on involves taking a XML String and encrypting it - this doesn't need to be state of the art, it just needs to encrypt it and decrypt it using a password.</p>

<p>So far the user enters a password which i've hashed using SHA-256, I then try and encrypt it by doing this:</p>

<pre><code>public static String encryptString(String password, String source, String fileName, String fileDir) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, FileNotFoundException, IOException {
    FileOutputStream fos = null;
    CipherInputStream cis;

    byte key[] = password.getBytes();
    SecretKeySpec secretKey = new SecretKeySpec(key, ""DES"");

    Cipher encrypt = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    encrypt.init(Cipher.ENCRYPT_MODE, secretKey);

    InputStream fileInputStream = new ByteArrayInputStream(source.getBytes());//Here I am getting file data as byte array. You can convert your file data to InputStream  by other way too.

    File dataFile = new File(fileDir, fileName); //dataDir is location where my file is stored
    if (!dataFile.exists()) {
        cis = new CipherInputStream(fileInputStream, encrypt);
        try {
            fos = new FileOutputStream(dataFile);
            byte[] b = new byte[32];
            int i;
            while ((i = cis.read(b)) != -1) {
                fos.write(b, 0, i);
            }
            return fileName;
        } finally {
            try {
                if (fos != null) {
                    fos.flush();
                    fos.close();
                }
                cis.close();
                fileInputStream.close();
            } catch (IOException e) {
                //IOException
            }
        }
    }
    return """";
}
</code></pre>

<p>The password being passed in is the hashed password - from here I try and run it but I get a:</p>

<p>java.security.InvalidKeyException: Invalid key length: 64 bytes exception.</p>

<p>Can someone help please?</p>

<p>Or tell me of a better way to encrypt an XML file with a password?</p>

<p>Thanks</p>
","<p>From the docs.</p>

<blockquote>
  <p>If this cipher requires any algorithm parameters that cannot be
  derived from the given key, the underlying cipher implementation is
  supposed to generate the required parameters itself (using
  provider-specific default or random values) if it is being initialized
  for encryption or key wrapping, and <strong>raise an InvalidKeyException if it
  is being initialized for decryption or key unwrapping</strong>. The generated
  parameters can be retrieved using getParameters or getIV (if the
  parameter is an IV).</p>
</blockquote>

<p>A very simple way of encrypting is taking your hash and XOR it with the bytes in the file in a loop (256 bits at a time). It's kind of a low-level approach but you won't need to debug the API. You should be able to implement this with very minimal code.</p>
","1046","<java><xml><encryption><sha256><des>","0","0","1","2014-03-06 17:07:33","22231229","0","2","","","","2014-03-06 16:59:05",""
"19494578","how to generate des (semi-) weak keys?","<p><p>Recently, i am learning about des algorithm, i know there are weak and semi-weak keys in des. we can get the (semi-) weak keys at <a href=""http://www.umich.edu/~x509/ssleay/des-weak.html"" rel=""nofollow"">http://www.umich.edu/~x509/ssleay/des-weak.html</a>.
<p>But what confused me is that how people get the (semi-)key list, we have 2^64 possible keys, my pc is 2.5GHz Duo i5, it may take hundreds years to Brute force the (semi-)key list.
<p>So, my question is how do i effectively generate all the (semi-)key in my pc in several hours or days. Plus, i need to implement it with C or other languages. 
Thanks.</p>
","","1039","<des>","0","","0","2013-10-21 12:30:25","","6","1","","","","2013-10-21 12:30:25",""
"14706384","Pyocrypt DES3 file encryption, decryption missing sections of text","<p>I'm using a 3DES encryption from this <a href=""https://www.laurentluce.com/posts/python-and-cryptography-with-pycrypto/"" rel=""nofollow noreferrer"">blog</a> (under header <em>Applications</em>) in python with <a href=""https://sourceforge.net/projects/cryptopy/"" rel=""nofollow noreferrer"">Crypto</a>, And I've been testing it on the <a href=""https://github.com/GiovanniMoretti/159251-directoryTreeOfFunFiles"" rel=""nofollow noreferrer"">Tree of Fun Files</a>, as an example for this question the <a href=""https://github.com/GiovanniMoretti/159251-directoryTreeOfFunFiles/blob/master/An%20Accountant%20and%20his%20Frog.txt"" rel=""nofollow noreferrer"">An Accountant and his Frog.txt</a> among many other files (file size varies greatly, for example <a href=""https://github.com/GiovanniMoretti/159251-directoryTreeOfFunFiles/blob/master/TOASTERS.TXT"" rel=""nofollow noreferrer"">TOASTERS</a>).</p>

<p><strong>pyencrypt</strong></p>

<pre><code>import os
from Crypto.Cipher import DES3

def encrypt_file(in_filename, out_filename, chunk_size, key, iv):
    des3 = DES3.new(key, DES3.MODE_CFB, iv)
    with open(in_filename, 'r') as in_file:
        with open(out_filename, 'w') as out_file:
            while True:
                chunk = in_file.read(chunk_size)
                if len(chunk) == 0:
                    break
                elif len(chunk) % 16 != 0:
                    chunk += ' ' * (16 - len(chunk) % 16)
                out_file.write(des3.encrypt(chunk))

def decrypt_file(in_filename, out_filename, chunk_size, key, iv):
    des3 = DES3.new(key, DES3.MODE_CFB, iv)

    with open(in_filename, 'r') as in_file:
        with open(out_filename, 'w') as out_file:
            while True:
                chunk = in_file.read(chunk_size)
                if len(chunk) == 0:
                    break
                out_file.write(des3.decrypt(chunk))
</code></pre>

<p><strong>Usage</strong></p>

<pre><code>import pyencrypt, md5
from Crypto import Random
iv = Random.get_random_bytes(8)
m = md5.new()
m.update(""encryptionkey"")
key =  m.digest()
.encrypt_file(""C:\\treeoffunfiles\\Accountant and his frog.txt"", 'C:\\treeoffun\\to_enc.enc', 8192, key, iv)
pyencrypt.decrypt_file('C:\\treeoffunfiles\\to_enc.enc', 'C:\\treeoffunfiles\\to_enc.dec', 8192, key, iv)
</code></pre>

<p>And the encryption of files is great (no complaints there)! but the <a href=""http://pastebin.com/s4CmJC5y"" rel=""nofollow noreferrer"">decryption</a> of the file isn't as great. Here is an <a href=""https://www.diffnow.com/v1?report=m8hzi"" rel=""nofollow noreferrer"">comparison</a> output between the original file and the decrypted file from <a href=""https://sourceforge.net/projects/npp-compare/"" rel=""nofollow noreferrer"">notepad++</a>.</p>

<p><a href=""https://i.stack.imgur.com/uRYP5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uRYP5.png"" alt=""notepad++""></a><br>
<sub>(source: <a href=""http://iforce.co.nz/i/3qnyhvzf.b5w.png"" rel=""nofollow noreferrer"">iforce.co.nz</a>)</sub>  </p>

<p>Any ideas on why the decrypted file is missing content from the original? and how can I make the decryption (and encryption if necessary) more accurate (across files that may vary in size)?</p>
","<p>The suggested answer was posted in the comments by <a href=""https://stackoverflow.com/users/487339/dsm"">DSM</a> (I've been waiting for him to post answer, this can stay for the meantime).</p>

<blockquote>
  <p>This works for me, but then I'm not on Windows. Could you open the files in binary mode (""rb""/""wb"") instead and see if that helps? – DSM</p>
</blockquote>

<p>The problem was that the original implementation of the 3DES encryption was ran on a <code>unix</code> machine. Whereas the results on a <code>windows</code> system differ.</p>

<p>In order to fix the <code>chunks</code> of missing data, DSM suggested to change the file input/output to binary instead of regular reading/writting, which has given the desired output as seen <a href=""http://www.diffnow.com/?report=vdtrs"" rel=""nofollow noreferrer"">here</a>.</p>

<p>fyi diffnow only stores the results for 1 month.</p>
","1034","<python><encryption><io><des>","2","1","1","2019-08-30 11:05:01","14742933","5","1","4751173","","2019-08-30 11:05:01","2013-02-05 11:23:52",""
"17538237","PHP's crypt function (STD_DES) in javascript","<p>Is there an implementation of the <code>crypt</code> function in PHP written in javascript?</p>

<p>I only need the STD_DES version eg.</p>

<p>PHP:</p>

<pre><code>&lt;?php
    echo crypt('test', 'SO') . ""\n"";
    // SOVYikZv1wMH.
?&gt;
</code></pre>

<p>JS:</p>

<pre><code>console.log(PHP_crypt('test', 'SO'));
// SOVYikZv1wMH.
</code></pre>

<p>I have tried to use <a href=""https://code.google.com/p/crypto-js"" rel=""nofollow"">CryptoJS</a>, but it doesn't seem to work the same way:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/tripledes.js""&gt;
&lt;/script&gt;
&lt;script&gt;
    var encrypted = CryptoJS.DES.encrypt('test', 'SO');
    console.log(encrypted.toString());
    // U2FsdGVkX1/VopEwWoWNH8SrvmdvM1O9
&lt;/script&gt;
</code></pre>

<p><strong>Note:</strong> I know DES is not secure, I shouldn't use it and X is way more secure than DES.</p>
","<p>I have copied the relevant part of the code from http://dmr.ath.cx/misc/pwd/pwd.js, where it is implemented.</p>

<p>Usage:</p>

<pre><code>des_init();
console.log(descrypt('test', 'SO')); // =&gt; SOVYikZv1wMH.
</code></pre>

<p>The code can be found <a href=""https://gist.github.com/Tyilo/5954072"" rel=""nofollow"">here</a>.</p>
","1004","<javascript><des><crypt>","1","3","1","2013-07-11 14:43:15","17596444","7","","","","","2013-07-09 00:49:09",""
"12329508","IOS DES encryption & PHP decryption not working reliably","<p>I'm encrypting a string in iOS using the method below</p>

<pre><code>
-(NSString *) encrypt:(NSString *) data 
{

    const void *vplainText;
    size_t plainTextBufferSize = [data length];
    vplainText = (const void *) [data UTF8String];
    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSizeDES) & ~(kCCBlockSizeDES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    Byte iv [] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef};

    NSString *key = @""complexkey"";
    const void *vkey = (const void *) [key UTF8String];

    ccStatus = CCCrypt(kCCEncrypt,
                       kCCAlgorithmDES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       vkey,
                       kCCKeySizeDES,
                       iv,
                       vplainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &movedBytes);

    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    NSString *result = [myData base64Encoding];

    // url encode the result
    return (__bridge NSString *) CFURLCreateStringByAddingPercentEscapes(NULL,
                                        (__bridge CFStringRef) result,
                                        NULL,
                                        (__bridge CFStringRef) @""!*'();:@&=+$,/?%#[]"",
                                        kCFStringEncodingUTF8);
}
</code></pre>

<p>And on php, I'm decrypting the string as follows -</p>

<pre><code>
$decrypted = mcrypt_decrypt(MCRYPT_DES, 'complexkey', base64_decode(urldecode($encrypted)), MCRYPT_MODE_ECB);
</code></pre>

<p>This seems to work correctly 75% of the time and I'm not sure why it fails at other times. Any clues? Thanks for the help!</p>
","<p>It's probably the padding, it is the only thing that is not synchronized between the two methods. Unfortunately, you may have to create your own unpadding form mcrypt, as that library does not perform PKCS#5 padding (same as PKCS#7 padding really). Fortunately that is rather simple: decrypt, then use the value of the last byte to strip of the last  bytes.</p>

<p>Other security related notes:</p>

<ul>
<li>DES is not safe, use 3DES (or officially TDEA) as a minimum;</li>
<li>ECB mode is not safe, use CBC (which does use an IV);</li>
<li>ECB mode does not use an IV;</li>
<li>for client/server authentication you need to be aware of padding oracle attacks.</li>
</ul>
","995","<php><ios><encryption><des>","0","0","2","2012-09-08 22:50:28","12333800","2","","","","","2012-09-08 09:12:54",""
"12329508","IOS DES encryption & PHP decryption not working reliably","<p>I'm encrypting a string in iOS using the method below</p>

<pre><code>
-(NSString *) encrypt:(NSString *) data 
{

    const void *vplainText;
    size_t plainTextBufferSize = [data length];
    vplainText = (const void *) [data UTF8String];
    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSizeDES) & ~(kCCBlockSizeDES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    Byte iv [] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef};

    NSString *key = @""complexkey"";
    const void *vkey = (const void *) [key UTF8String];

    ccStatus = CCCrypt(kCCEncrypt,
                       kCCAlgorithmDES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       vkey,
                       kCCKeySizeDES,
                       iv,
                       vplainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &movedBytes);

    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    NSString *result = [myData base64Encoding];

    // url encode the result
    return (__bridge NSString *) CFURLCreateStringByAddingPercentEscapes(NULL,
                                        (__bridge CFStringRef) result,
                                        NULL,
                                        (__bridge CFStringRef) @""!*'();:@&=+$,/?%#[]"",
                                        kCFStringEncodingUTF8);
}
</code></pre>

<p>And on php, I'm decrypting the string as follows -</p>

<pre><code>
$decrypted = mcrypt_decrypt(MCRYPT_DES, 'complexkey', base64_decode(urldecode($encrypted)), MCRYPT_MODE_ECB);
</code></pre>

<p>This seems to work correctly 75% of the time and I'm not sure why it fails at other times. Any clues? Thanks for the help!</p>
","<p>It turns out that there was nothing wrong in the encryption/decryption I was doing. Rather the issue was that urldecode() in PHP wasn't decoding '%2B' to '+' (but instead to ' '). I switched from urldecode() to rawurldecode() in PHP and everything is working fine now!</p>
","995","<php><ios><encryption><des>","0","0","2","2012-09-08 22:50:28","12333800","2","","","","","2012-09-08 09:12:54",""
"40210451","javax.crypto.BadPaddingException : pad block corrupted","<p>While decrypting a string value we are sometimes seeing this BadPaddingException. Not all the time for exactly the same values but just sometimes. The encryption seems to work just fine... Seems like other have had the same issues sometimes as well, although their answers didn't work for me...</p>

<pre><code>private String encrypt(String value) {
    try {
        final byte[] bytes = value != null ? value.getBytes(UTF8) : new byte[0];
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));
        Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
        pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID).getBytes(UTF8), 20));
        return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP), UTF8);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
private String decrypt(String value) {
    try {
        final byte[] bytes = value != null ? Base64.decode(value, Base64.DEFAULT) : new byte[0];
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));
        Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
        pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID).getBytes(UTF8), 20));
        return new String(pbeCipher.doFinal(bytes), UTF8);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
</code></pre>
","","969","<java><android><encryption><md5><des>","1","","0","2016-10-24 05:14:36","","1","3","1816580","","2016-10-24 05:14:36","2016-10-24 03:53:51",""
"10703704","How to store a Secret Key for Encryption","<p>I am building an authentication system in which some information is being stored encrypted so that it can't be human readable. Because it is encrypted, I need to use the <code>generateSecretKey()</code> function (as I'm not using the CFMX_COMPAT method). I am nervous of just creating this when a user is registered in the system and using it for all time and so I thought about creating a new one every time the user logs in, but wasn't sure if that is really necessary. I am already calling a method to update the users login timestamp on each login so adding a new secret key isn't bad, but I wanted to make sure that I didn't go overboard, so my question is this:</p>

<blockquote>
  <p>When generating secret keys for users to encrypt information is it best to create a new one every time they login or just create one on registration and use it for all time?</p>
</blockquote>
","<p>Your answer (as the elves said to Frodo) is both yes and no. Or perhaps in the words of Bob Dole when asked if he wore boxers or breifs... ""depends"".  </p>

<p>What you are asking about is tied stringently to the requirements. Ostensibly the second choice - ""generating a new key"" - would be <em>more secure</em> than reusing the same key. In the first case you have one key per user. In the second your key is more ephemeral and disappears after a session. So the real question is, what level of security is <em>enough</em> for your requirements. </p>

<p>The trade off is that the code is slightly more complicated, the server has to work a bit harder, and you can't persist sessions (because restarting the server is going to kill your keys presumably). It might also make things like audit reporting more difficult since it sounds like you are encrypting some log type or audit trail type information. </p>

<p>I would add that if you store these keys along with the data you might as well not bother with generating new ones. You've already degraded whatever benefit you might have garnered by putting the key under the welcome mat ;)</p>

<p>Hope this helps... sorry to be vague.</p>
","959","<encryption><coldfusion><coldfusion-9><des>","1","1","1","2012-05-22 16:27:35","10705866","0","","","","","2012-05-22 14:05:50",""
"11882379","emulate pbewithmd5anddes in javascript","<p>I made a password generating program some time ago in java.
it generated passwords based on an input string and password.
it used: pbewithMD5andDES</p>

<p>now i'm making a new version of this for mobile devices in javascript.
i found the library crypto-js witch allows me to generate MD5-hashes and encrypt using DES</p>

<p>but i can't seem to generate identical passwords</p>

<p>what am i doing wrong?</p>

<p>java version:</p>

<pre><code> public static String generate(String password, String passphase) throws Exception {
    try {
        PBEKeySpec pbeKeySpec = new PBEKeySpec(passphase.toCharArray());
        PBEParameterSpec pbeParamSpec;
        SecretKeyFactory keyFac;
        // Salt
        byte[] salt = {(byte) 0xc8, (byte) 0x73, (byte) 0x61, (byte) 0x1d, (byte) 0x1a, (byte) 0xf2, (byte) 0xa8, (byte) 0x99};
        // Iteration count
        int count = 20;
        // Create PBE parameter set
        pbeParamSpec = new PBEParameterSpec(salt, count);
        keyFac = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
        SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);
        // Create PBE Cipher
        Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
        // Initialize PBE Cipher with key and parameters
        pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);
        // Our cleartext
        byte[] cleartext = password.getBytes();
        // Encrypt the cleartext
        byte[] ciphertext = pbeCipher.doFinal(cleartext);
        return byteArrayToHexString(ciphertext).substring(0, 12);
    } catch (Exception ex) {
        throw new Exception(ex.getMessage());
    }
}

public static String byteArrayToHexString(byte[] b){
    StringBuilder sb = new StringBuilder(b.length * 2);
    for (int i = 0; i &lt; b.length; i++){
        int v = b[i] &amp; 0xff;
        if (v &lt; 16) {
            sb.append('0');
        }
        sb.append(Integer.toHexString(v));
    }
    return sb.toString().toUpperCase();
}
</code></pre>

<p>the new javascript version (not compete): (i tried both orders: first hashing then DES, and the oher way around)</p>

<pre><code>var hashedPassword = CryptoJS.MD5(password);
var encryptedPassword = CryptoJS.DES.encrypt(hashedPassword, passphrase).toString();
var result = encryptedPassword.toString().substring(0, 12).toUpperCase();
</code></pre>

<p>am i on the right way?</p>
","","950","<java><javascript><encryption><md5><des>","1","","0","2012-08-09 11:27:34","","4","2","","","","2012-08-09 11:27:34",""
"40583676","Mifare Desfire Wrapped Mode: How to calculate CMAC?","<p>When using Desfire native wrapped APDUs to communicate with the card, which parts of the command and response must be used to calculate CMAC? </p>

<p>After successful authentication, I have the following session key:</p>

<pre><code>Session Key: 7CCEBF73356F21C9191E87472F9D0EA2
</code></pre>

<p>Then when I send a GetKeyVersion command, card returns the following CMAC which I'm trying to verify:</p>

<pre><code>&lt;&lt; 90 64 00 00 01 00 00
&gt;&gt; 00 3376289145DA8C27 9100
</code></pre>

<p>I have implemented CMAC algorithm according to ""NIST special publication 800-38B"" and made sure it is correct. But I don't know which parts of command and response APDUs must be used to calculate CMAC.</p>

<p>I am using TDES, so MAC is 8 bytes.</p>
","<p>I have been looking at the exact same issue for the last few days and I think I can at least give you some pointers. Getting everything 'just so' has taken some time and the documentation from NXP (assuming you have access) is a little difficult to interpret in some cases.</p>

<p>So, as you probably know, you need to calculate the CMAC (and update your init vec) on transmit as well as receive. You need to save the CMAC each time you calculate it as the init vec for the next crypto operation (whether CMAC or encryption etc).</p>

<p>When calculating the CMAC for your example the data to feed into your CMAC algorithm is the INS byte (<code>0x64</code>) and the command data (<code>0x00</code>). Of course this will be padded etc as specified by CMAC. Note, however, that you do <em>not</em> calculate the CMAC across the entire APDU wrapping (i.e. <code>90 64 00 00 01 00 00</code>) just the INS byte and data payload is used.</p>

<p>On receive you need to take the data (<code>0x00</code>) and the second status byte (also <code>0x00</code>) and calculate the CMAC over that. It's not important in this example but order is important here. You use the response body (excluding the CMAC) then SW2.</p>

<p>Note that only half of the CMAC is actually sent - CMAC should yield 16 bytes and the card is sending the first 8 bytes.</p>

<p>There were a few other things that held me up including:</p>

<ul>
<li>I was calculating the session key incorrectly - it is worth double checking this if things are not coming out as you'd expect</li>
<li>I interpreted the documentation to say that the entire APDU structure is used to calculate the CMAC (hard to read them any other way tbh)</li>
</ul>

<p>I am still working on calculating the response from a Write Data command correctly. The command succeeds but I can't validate the CMAC. I do know that Write Data is not padded with CMAC padding but just zeros - not yet sure what else I've missed.</p>

<p>Finally, here is a real example from communicating with a card from my logs:</p>

<ol>
<li><p>Authentication is complete (AES) and the session key is determined to be <code>F92E48F9A6C34722A90EA29CFA0C3D12</code>; init vec is zeros</p></li>
<li><p>I'm going to send the Get Key Version command (as in your example) so I calculate CMAC over <code>6400</code> and get <code>1200551CA7E2F49514A1324B7E3428F1</code> (which is now my init vec for the next calculation)</p></li>
<li><p>Send <code>90640000010000</code> to the card and receive <code>00C929939C467434A8</code> (status is 9100).</p></li>
<li><p>Calculate CMAC over <code>00 00</code> and get <code>C929939C467434A8A29AB2C40B977B83</code> (and update init vec for next calculation)</p></li>
<li><p>The first half of our CMAC from step #4 matches the 8 byte received from the card in step #3</p></li>
</ol>
","932","<mifare><des><apdu><message-authentication-code>","3","1","2","2017-12-15 19:17:16","","4","3","387076","","2017-10-16 21:44:20","2016-11-14 07:21:08",""
"40583676","Mifare Desfire Wrapped Mode: How to calculate CMAC?","<p>When using Desfire native wrapped APDUs to communicate with the card, which parts of the command and response must be used to calculate CMAC? </p>

<p>After successful authentication, I have the following session key:</p>

<pre><code>Session Key: 7CCEBF73356F21C9191E87472F9D0EA2
</code></pre>

<p>Then when I send a GetKeyVersion command, card returns the following CMAC which I'm trying to verify:</p>

<pre><code>&lt;&lt; 90 64 00 00 01 00 00
&gt;&gt; 00 3376289145DA8C27 9100
</code></pre>

<p>I have implemented CMAC algorithm according to ""NIST special publication 800-38B"" and made sure it is correct. But I don't know which parts of command and response APDUs must be used to calculate CMAC.</p>

<p>I am using TDES, so MAC is 8 bytes.</p>
","<p>Sry for my English,- its terrible :) but it's not my native language. I'm Russian.</p>

<p>Check first MSB (7 - bit) of array[0] and then shiffting this to the left. And then XOR if MSB 7 bit was == 1;
Or save first MSB bit of array[0] and after shiffting put this bit at the end of array[15] at the end (LSB bit).</p>

<p>Just proof it's here:
<a href=""https://www.nxp.com/docs/en/application-note/AN10922.pdf"" rel=""nofollow noreferrer"">https://www.nxp.com/docs/en/application-note/AN10922.pdf</a></p>

<p>Try this way:</p>

<blockquote>
  <p>Zeros &lt;- 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>
  
  <p>SessionKey &lt;- 00 01 02 03 E3 27 64 0C 0C 0D 0E 0F 5C 5D B9 D5</p>
  
  <p>Data &lt;- 6F 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>
</blockquote>

<p>First u have to encrypt 16 bytes (zeros) with SesionKey;</p>

<pre><code>enc_aes_128_ecb(Zeros);
</code></pre>

<p>And u get EncryptedData.</p>

<blockquote>
  <p>EncryptedData &lt;- 3D 08 A2 49 D9 71 58 EA 75 73 18 F2 FA 6A 27 AC</p>
</blockquote>

<p>Check bit 7 [MSB - LSB] of EncryptedData[0] == 1? switch i to true;</p>

<pre><code> bool i = false;
  if (EncryptedData[0] &amp; 0x80){
    i = true;
  }
</code></pre>

<p>Then do Shiffting of all EncryptedData to 1 bit &lt;&lt;.</p>

<pre><code>ShiftLeft(EncryptedData,16);
</code></pre>

<p>And now, when i == true - XOR the last byte [15] with 0x87</p>

<pre><code>if (i){
    ShiftedEncryptedData[15] ^= 0x87;
  }
</code></pre>

<blockquote>
  <p>7A 11 44 93 B2 E2 B1 D4 EA E6 31 E5 F4 D4 4F 58 </p>
</blockquote>

<p>Save it as KEY_1.</p>

<p>Try bit 7 [MSB - LSB] of ShiftedEncryptedData[0] == 1?</p>

<pre><code> i = false;
  if (ShiftedEncryptedData[0] &amp; 0x80){
    i = true;
  }
</code></pre>

<p>Then do Shiffting of all ShiftedEncryptedData to 1 bit &lt;&lt;.</p>

<pre><code>ShiftLeft(ShiftedEncryptedData,16);
</code></pre>

<p>And now, when i == true - XOR the last byte [15] with 0x87</p>

<pre><code>if (i){
   ShiftedEncryptedData[15] ^= 0x87;
}
</code></pre>

<blockquote>
  <p>F4 22 89 27 65 C5 63 A9 D5 CC 63 CB E9 A8 9E B0</p>
</blockquote>

<p>Save it as KEY_2.</p>

<p>Now we take our Data (6F <strong>80 00 00 00 00 00 00 00 00 00 00 00 00 00 00</strong>) </p>

<p>As Michael say's - pad command with 0x80 0x00...</p>

<p>XOR Data with KEY_2 - if command was padded, or KEY_1 if don't.
If we have more like 16 bytes (32 for example) u have to XOR just last 16 bytes.</p>

<p>Then encrypt it:</p>

<pre><code>enc_aes_128_ecb(Data);
</code></pre>

<p>Now u have a CMAC.</p>

<blockquote>
  <p>CD C0 52 62 6D F6 60 CA 9B C1 09 FF EF 64 1A E3</p>
</blockquote>

<hr>

<blockquote>
  <p>Zeros &lt;- 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>
  
  <p>SessionKey &lt;- 00 01 02 03 E3 27 64 0C 0C 0D 0E 0F 5C 5D B9 D5</p>
  
  <p>Key_1 &lt;- 7A 11 44 93 B2 E2 B1 D4 EA E6 31 E5 F4 D4 4F 58</p>
  
  <p>Key_2 &lt;- F4 22 89 27 65 C5 63 A9 D5 CC 63 CB E9 A8 9E B0</p>
  
  <p>Data &lt;- 6F 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>
  
  <p>CMAC &lt;- CD C0 52 62 6D F6 60 CA 9B C1 09 FF EF 64 1A E3</p>
</blockquote>

<p>C/C++ function:</p>

<pre><code>void ShiftLeft(byte *data, byte dataLen){
  for (int n = 0; n &lt; dataLen - 1; n++) {
   data[n] = ((data[n] &lt;&lt; 1) | ((data[n+1] &gt;&gt; 7)&amp;0x01));
  }
  data[dataLen - 1] &lt;&lt;= 1;
}   
</code></pre>

<p>Have a nice day :)</p>
","932","<mifare><des><apdu><message-authentication-code>","3","0","2","2017-12-15 19:17:16","","4","3","387076","","2017-10-16 21:44:20","2016-11-14 07:21:08",""
"14618865","Forget Password link using gwt","<p>In my site i have a link <strong>Forgot Password</strong> when i click on this link a page will come so we fill emailId and send mail to particular gmailid(in this mail we have to generate a link). when we have click on generated link page open for reset password(like new password ar confirm password).</p>

<p>My problem is that i am successfully able to send mail but when click on link not able to find emailId
for reset password. 
<strong>Gmail Link :</strong></p>

<pre><code>http://127.0.0.1:8888/abc.html?gwt.codesvr=127.0.0.1:9997#forgetPassword
</code></pre>

<p><strong>client Code</strong></p>

<pre><code>sendButton.addClickHandler(new ClickHandler() {

    @Override
    public void onClick(ClickEvent event) {
        // TODO Auto-generated method stub

        greetServer.mailLinkSend(emailId.getText(),""http://""+Window.Location.getHost()+Window.Location.getPath()+Window.Location.getQueryString()+""#forgetPassword"", new AsyncCallback&lt;String&gt;() {

            @Override
            public void onSuccess(String result) {
                // TODO Auto-generated method stub
                System.out.println(""success""+result);
            }

            @Override
            public void onFailure(Throwable caught) {
                // TODO Auto-generated method stub
                System.out.println(""fail"");
            }
        });
    }
});
</code></pre>

<p><strong>on server</strong></p>

<pre><code>public String mailLinkSend(String emailText, String link) {
               SecretKey key = KeyGenerator.getInstance(""DES"").generateKey(); 
</code></pre>

<p>// Create encrypter/decrypter class 
DesEncrypter encrypter = new DesEncrypter(key); </p>

<p>// Encrypt 
encrypted = encrypter.encrypt(emailText); </p>

<p>// Decrypt 
String decrypted = encrypter.decrypt(encrypted);</p>

<pre><code>    String ss = ""true"";

            String emailMsgTxt = ""Hi"" + emailText + ""\n"" + ""\n""
            + ""Your Password Change Link\n"" + link + ""?id="" + encrypted
            + ""\n Click on the above link to Reset your Password"";
    String emailSubjectTxt = ""Change Password Link"";
    String emailFromAddress = ""abc@gmail.com"";
    String receipentList = emailText;

    try {
        MailUtility smtpMailSender = new MailUtility();
        smtpMailSender.postMail(receipentList, emailSubjectTxt,emailMsgTxt,   emailFromAddress);

    } catch (MessagingException messagingException) {}


    return ss;
}
</code></pre>

<p>MailUtility class</p>

<pre><code>public class MailUtility {
    public String postMail(String recipients, String subject,
            String message, String from) throws MessagingException {
</code></pre>

<p>some code....
}</p>

<p>i have send emailId in encrypted form but i don't know how to save key for decrypted and also how to expire link after one time use and 48 hrs.</p>
","<p>So your problem with encryption and decryption  </p>

<p>So the below code will help you </p>

<p>Note  Constants.GWT_DES_KEY will be same on server and client </p>

<p>for example :</p>

<p>private final static byte[] GWT_DES_KEY = new byte[] {
        -110, 121, -65, 22, -60, 61, -22, -60, 21, -122, 41, -89, -89, -68, -8,
        41, -119, -51, -12, -36, 19, -8, -17, 47
    };</p>

<p>on the server:</p>

<pre><code>  TripleDesCipher cipher = new TripleDesCipher();
    cipher.setKey(Constants.GWT_DES_KEY);
    try {
    enc = cipher.encrypt(String.valueOf(value));
    } catch (DataLengthException e1) {
    e1.printStackTrace();
    } catch (IllegalStateException e1) {
    e1.printStackTrace();
    } catch (InvalidCipherTextException e1) {
    e1.printStackTrace();
    }

On the client, make sure you inherit the module:
&lt;inherits name='com.googlecode.gwt.crypto.Crypto'/&gt;
Then:

  TripleDesCipher cipher = new TripleDesCipher();
    cipher.setKey(Constants.GWT_DES_KEY);
    String dec ="""";
    try {
    dec = cipher.decrypt(enc);
    } catch (DataLengthException e) {
    e.printStackTrace();
    } catch (IllegalStateException e) {
    e.printStackTrace();
    } catch (InvalidCipherTextException e) {
    e.printStackTrace();
    }
</code></pre>
","928","<gwt><gmail><des><gwt-ext>","2","1","1","2013-01-31 08:09:47","","6","","672792","","2013-01-31 06:55:24","2013-01-31 05:07:19",""
"6580775","Updating LDAP encrypted password via JNDI","<p>I need some pointers how to update an encrypted password in an LDAP (OpenLDAP) of a user within an LDAP tree. The passwords in the LDAP server are prefixed with {crypt} which I suppose indicates that it is encrypted (with DES?)</p>

<p>I need to write a method which updates a user's passwords. What is the right way to do this? Do I need to prefix the string with {crypt} myself? How do I encrypt the password for {crypt}?</p>

<p>UPDATE:</p>

<p>Just to clarify what I need is the Java code to encrypt the attribute so that it works with {crypt}. I also don't know if I have to prefix the attribute with the string {crypt} myself.</p>
","<p>No, you just need to update the attribute, just like any other attribute, but remembering that unlike most attributes it is a byte[] not a String.</p>

<p>There is also an ExtendedOperation for password modification in association with the Password Policy IETF draft, but you haven't mentioned you're using that.</p>
","928","<java><ldap><jndi><des><crypt>","3","1","2","2017-08-04 17:41:26","","0","2","1033581","","2017-08-04 17:41:26","2011-07-05 09:52:39",""
"6580775","Updating LDAP encrypted password via JNDI","<p>I need some pointers how to update an encrypted password in an LDAP (OpenLDAP) of a user within an LDAP tree. The passwords in the LDAP server are prefixed with {crypt} which I suppose indicates that it is encrypted (with DES?)</p>

<p>I need to write a method which updates a user's passwords. What is the right way to do this? Do I need to prefix the string with {crypt} myself? How do I encrypt the password for {crypt}?</p>

<p>UPDATE:</p>

<p>Just to clarify what I need is the Java code to encrypt the attribute so that it works with {crypt}. I also don't know if I have to prefix the attribute with the string {crypt} myself.</p>
","<p>In some cases, using a pre-encoded password might prevent the directory server from enforcing password quality checks.</p>
","928","<java><ldap><jndi><des><crypt>","3","0","2","2017-08-04 17:41:26","","0","2","1033581","","2017-08-04 17:41:26","2011-07-05 09:52:39",""
"25144304","EncryptByPassPhrase key given in bytes","<p>Friends,</p>

<p>I want to use <code>EncryptByPassPhrase</code> in SQL SERVER (which I found here <a href=""http://msdn.microsoft.com/en-us/library/ms190357.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms190357.aspx</a>) to update existing values in a table by encrypting them. However, the passphrase (or key) is given in bytes such as:</p>

<pre><code>private static readonly byte[] TrippleDesKey = new byte[] { 0xF1, 0x07, 0xE6, 0x13, 0xBA, 0x85, 0x7F, 0xDC, 0x6D, 0x85, 0x67, 0x9B, 0x68, 0x7A, 0xC7, 0x1F, 0x10, 0xBA, 0xB0, 0x2F, 0xA2, 0xAE, 0xDA, 0xEA };
</code></pre>

<p>I want to apply <code>EncryptByPassPhrase</code> using the <code>TrippleDesKey</code> variable. </p>

<p>Any suggestions on how I can do that? I assume if I convert the <code>TrippleDesKey</code> variable into string I could just simple use it <code>EncryptByPassPhrase</code>.</p>

<p>I tried converting the <code>TrippleDesKey</code> variable such as</p>

<pre><code>string result = System.Text.Encoding.UTF8.GetString(TrippleDesKey); 
Console.WriteLine(result);
</code></pre>

<p>and the ouptut was ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½gï¿½hzï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½</p>

<p>I used ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½gï¿½hzï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½ in EncryptByPassPhrase but no value is encrypted i.e., an empty string is returned.</p>
","<p>EncryptByPassPhrase can accept a binary (byte) value as the passphrase, so you should be able to pass the TrippleDesKey as a parameter to a stored procedure or statement. I threw this together as an example, but it should be close... </p>

<pre><code>string commandText = ""UPDATE MyTable SET EncryptedData = EncryptByPassPhrase(@DesKey, EncryptedData ) WHERE CustomerID = @ID"";

using (SqlConnection connection = new SqlConnection(connectionString))
{
    SqlCommand command = new SqlCommand(commandText, connection);
    command.Parameters.Add(""@DesKey"", SqlDbType.VarBinary);
    command.Parameters[""@DesKey""].Value = TrippleDesKey;

    command.Parameters.Add(""@ID"", SqlDbType.Int);
    command.Parameters[""@ID""].Value = customerID;

    try
    {
        connection.Open();
        Int32 rowsAffected = command.ExecuteNonQuery();
        Console.WriteLine(""RowsAffected: {0}"", rowsAffected);
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}
</code></pre>
","925","<c#><sql-server-2008><des><encryption-symmetric>","0","0","2","2014-08-05 17:31:57","25144897","2","","","","","2014-08-05 16:54:21",""
"25144304","EncryptByPassPhrase key given in bytes","<p>Friends,</p>

<p>I want to use <code>EncryptByPassPhrase</code> in SQL SERVER (which I found here <a href=""http://msdn.microsoft.com/en-us/library/ms190357.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms190357.aspx</a>) to update existing values in a table by encrypting them. However, the passphrase (or key) is given in bytes such as:</p>

<pre><code>private static readonly byte[] TrippleDesKey = new byte[] { 0xF1, 0x07, 0xE6, 0x13, 0xBA, 0x85, 0x7F, 0xDC, 0x6D, 0x85, 0x67, 0x9B, 0x68, 0x7A, 0xC7, 0x1F, 0x10, 0xBA, 0xB0, 0x2F, 0xA2, 0xAE, 0xDA, 0xEA };
</code></pre>

<p>I want to apply <code>EncryptByPassPhrase</code> using the <code>TrippleDesKey</code> variable. </p>

<p>Any suggestions on how I can do that? I assume if I convert the <code>TrippleDesKey</code> variable into string I could just simple use it <code>EncryptByPassPhrase</code>.</p>

<p>I tried converting the <code>TrippleDesKey</code> variable such as</p>

<pre><code>string result = System.Text.Encoding.UTF8.GetString(TrippleDesKey); 
Console.WriteLine(result);
</code></pre>

<p>and the ouptut was ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½gï¿½hzï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½</p>

<p>I used ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½gï¿½hzï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½ in EncryptByPassPhrase but no value is encrypted i.e., an empty string is returned.</p>
","<p>You can just join the bytes hex values in only one value and use it:</p>

<pre><code>new byte[] { 0xF1, 0x07, 0xE6, 0x13, 0xBA, 0x85, 0x7F, 0xDC, 0x6D, 0x85, 0x67, 0x9B, 0x68, 0x7A, 0xC7, 0x1F, 0x10, 0xBA, 0xB0, 0x2F, 0xA2, 0xAE, 0xDA, 0xEA } = 0xF107E613BA857FDC6D85679B687AC71F10BAB02FA2AEDAEA
</code></pre>

<p>Then use it like this: </p>

<pre><code>EncryptByPassPhrase( 0xF107E613BA857FDC6D85679B687AC71F10BAB02FA2AEDAEA, 'test')
</code></pre>
","925","<c#><sql-server-2008><des><encryption-symmetric>","0","0","2","2014-08-05 17:31:57","25144897","2","","","","","2014-08-05 16:54:21",""
"15782110","SecretKey generation for DESede/CBC/PKCS5Padding","<p>I'm having problems when encrypting data to be sent to a SOAP service.</p>

<p>I suppose the problem is in the SecretKey generation, because the response is still the same with an incorrect password.</p>

<p>The current code is:</p>

<pre><code>WServiceSoap ws = new WService().getWServiceSoap();
MessageDigest md = MessageDigest.getInstance(""md5"");

byte[] digestOfPassword = md.digest(""12345678"".getBytes(""utf-8""));

final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
for (int j = 0, k = 16; j &lt; 8;) {
  keyBytes[k++] = keyBytes[j++];
}

SecretKey opKey = new SecretKeySpec(keyBytes, ""DESede"");        
byte[] opIV = { 0, 0, 0, 1, 2, 3, 4, 5 };       
Cipher c = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");

c.init(Cipher.ENCRYPT_MODE, opKey, new IvParameterSpec(opIV));

byte[] encrypted = c.doFinal(
    ClientDirectOperacionCTMS.DATOS_OPERACION.getBytes(""UTF-8""));

String encryptedDatosOperacion= Base64.encodeBase64String(encrypted);
String result= ws.operacionCTMS(encryptedDatosOperacion);
System.out.println(result);
</code></pre>

<p>, and the exception is</p>

<pre><code>Exception in thread ""main"" javax.xml.ws.soap.SOAPFaultException: Server was unable to process request. ---&gt; La operación de pago con tarjeta no ha sido satisfactoria. ---&gt; Additional non-parsable characters are at the end of the string.
at com.sun.xml.internal.ws.fault.SOAP11Fault.getProtocolException(SOAP11Fault.java:178)
at com.sun.xml.internal.ws.fault.SOAPFaultBuilder.createException(SOAPFaultBuilder.java:111)
at com.sun.xml.internal.ws.client.sei.SyncMethodHandler.invoke(SyncMethodHandler.java:108)
at com.sun.xml.internal.ws.client.sei.SyncMethodHandler.invoke(SyncMethodHandler.java:78)
at com.sun.xml.internal.ws.client.sei.SEIStub.invoke(SEIStub.java:107)
</code></pre>

<p>I have also tried this code without success:</p>

<pre><code>final byte[] keyBytes = Arrays.copyOf(Base64.decodeBase64(""12345678""), 24);
SecretKey opKey = new SecretKeySpec(keyBytes, ""DESede"");        
</code></pre>

<p>The decryption done by the server is</p>

<pre><code>CheckKey(ref rgbKey);
cryptoProvider = new TripleDESCryptoServiceProvider();
cryptoTransform = cryptoProvider.CreateDecryptor(rgbKey, s_rgbIV);
memoryStream = new MemoryStream();
using (CryptoStream cryptoStream = new CryptoStream(
    memoryStream, cryptoTransform, CryptoStreamMode.Write))
{
    cryptoStream.Write(rgbEncryptedText, 0, rgbEncryptedText.Length);
}

originalText = Encoding.UTF8.GetString(memoryStream.ToArray());
</code></pre>

<p>, where CheckKey is</p>

<pre><code>        private static void CheckKey(ref Byte[] rgbKey)
    {
        if (rgbKey.Length &gt; KEY_MAX_LENGTH)
        {
            Array.Resize(ref rgbKey, KEY_MAX_LENGTH);
        }
        else if (rgbKey.Length &lt; KEY_MAX_LENGTH)
        {
            Byte fill = 0x41;
            Int32 offset = rgbKey.Length;

            Array.Resize(ref rgbKey, KEY_MAX_LENGTH);

            for (Int32 index = offset; index &lt; KEY_MAX_LENGTH; index++)
            {
                rgbKey[index] = fill++;
            }
        }
    }
</code></pre>
","","915","<c#><java><encryption><des>","0","","0","2013-04-03 15:10:11","","3","2","1156156","","2013-04-03 15:10:11","2013-04-03 08:13:50",""
"51298371","DES Encryption in Node.js","<p>I've been trying to port this Java Program to Node.js. I've tried a few ways and still unable to get this done so far. Could be due to my limited knowledge in Cryptography.</p>

<p>The Node.js Program I've written is this.</p>

<pre><code>var crypto = require('crypto');

var iv = crypto.randomBytes(8);

var encrypt = function(data, key) {
    var decodeKey = crypto.createHash('sha512').update(key, 'utf-8').digest().slice(0, 24);
    var cipher = crypto.createCipheriv('des-ede-cbc', decodeKey, iv);
    return cipher.update(data, 'utf8', 'hex') + cipher.final('hex');
};

var data = 'abc101'
var key = '1785851816255252-8887772';

var cipher = encrypt(data, key);
console.log(cipher);
</code></pre>

<p>I keep receiving the following error:</p>

<pre><code>Error: Invalid key length
</code></pre>

<p>The original program I am trying to port is this:</p>

<pre><code>import java.security.MessageDigest;
import java.security.spec.KeySpec;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class PasswordEncryptor {

    public static void main(String[] args) {

        String passwd = ""abc101"";
        String msgId = ""1785851816255252-8887772"";

        String result = """";

        try {
            if (passwd == null &amp;&amp; passwd.equals("""") &amp;&amp; msgId == null &amp;&amp; msgId.equals("""")) {
                System.out.println(""Wrong Inputs"");
            } else {
                result = PasswordEncryptor.encryptPassword(msgId, passwd);
            }
            System.out.println(result);
        } catch (Exception e) {
            System.out.println(""Exception in PasswordEncryption  ::: "" + e);
        }

    }

    public static String encryptPassword(String msgId, String password) {
        String finalValue = """";
        try {
            MessageDigest mDigest = MessageDigest.getInstance(""SHA-512"");
            byte[] digestSeed = mDigest.digest(msgId.getBytes());
            byte[] seedEncArray = Arrays.copyOf(digestSeed, 24);
            Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            SecretKeySpec skspec = new SecretKeySpec(seedEncArray, ""DESede"");
            IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            cipher.init(Cipher.ENCRYPT_MODE, skspec, iv);
            byte[] finalByteArray = cipher.doFinal(password.getBytes());
            finalValue = new String(Base64.encodeBase64(finalByteArray));
        } catch (Exception e) {
            System.out.println(""Exception in encryptPassword ::::"" + e);
        }
        return finalValue;
    }
}
</code></pre>

<p>Any help is appreciated. Thank you.</p>
","<p>nodejs calls OpenSSL, whose naming schemes have some odd warts due to hysterical raisins. <code>des-ede-$mode</code> in OpenSSL is actually <a href=""https://en.wikipedia.org/wiki/Triple_DES#Keying_options"" rel=""nofollow noreferrer"">Keying Option 2</a>, aka 2-key TDEA. For 'real' 3-key TDEA you must ask for <code>des-ede3-$mode</code> in this case <code>des-ede3-cbc</code>. </p>

<p>Also the Java code uses <code>new byte[8]</code> for the IV value, which is 8 bytes all zero, but your nodejs code uses random bytes. Random is actually better cryptographically, but if your goal is to produce the same results as the Java code you need to replicate its mistake.</p>

<p>Finally the Java code encodes the result in base64 while your nodejs code uses hex. These are semantically equivalent and easily interconvertible, but are not the same. If you do want the same, nodejs does support base64.</p>

<p>Aside: the attempted error check in the Java code </p>

<pre><code> if (passwd == null &amp;&amp; passwd.equals("""") &amp;&amp; msgId == null &amp;&amp; msgId.equals(""""))
</code></pre>

<p>is just stupid; no Java <code>String</code> can be <code>== null</code> and <code>.equals("""")</code> simultaneously. All those <code>&amp;&amp;</code> log-and should be <code>||</code> log-or. This code has clearly not been written <em>or</em> tested <em>or</em> reviewed competently; if I were you (which I'm not) I would avoid having anything to do with it.</p>
","890","<java><node.js><encryption><des>","1","0","1","2018-07-12 16:40:21","","0","","485343","","2018-07-12 09:47:27","2018-07-12 06:08:30",""
"5274927","Cocoa Convert NSArray/NSString of octals to NSData?","<p>I'm trying to covert this bit of C code to Cocoa and I'm struggling to figure out how.</p>

<pre><code>  char *deskey = ""123 456 789 101 112 131 415 161"";
  unsigned char key[16];
  memset(key, 0, sizeof(key));
  sscanf(deskey, ""%o %o %o %o %o %o %o %o"",
    (int*)&amp;key[0], (int*)&amp;key[1], (int*)&amp;key[2],
    (int*)&amp;key[3], (int*)&amp;key[4], (int*)&amp;key[5],
    (int*)&amp;key[6], (int*)&amp;key[7]);
</code></pre>

<p>I've tried using NSMutableArray and NSData but having no luck.  I was able to scan the string and pull out the numbers, but I'm not sure how to store into NSData after that.</p>

<pre><code>  NSMutableArray *enckey = [[[NSMutableArray alloc] init] autorelease];
  NSScanner *scanner = [NSScanner scannerWithString:self.deskey];
  int pos = 0;

  while ([scanner isAtEnd] == NO) {
    if ([scanner scanInt:&amp;pos]) {
      [enckey addObject:[NSString stringWithFormat:@""%o"", pos]];
    }
    else {
      NSLog(@""Your DES key appears to be invalid."");
      return;
    }
  }
</code></pre>

<p>Basically trying to convert ascii DES key to string to use for Triple DES encryption. Any help is greatly appreciated, thank you!</p>
","<p>The quick and dirty method is to take your original code</p>

<pre><code>char *deskey = ""123 456 789 101 112 131 415 161"";
unsigned char key[16];
memset(key, 0, sizeof(key));
sscanf(deskey, ""%o %o %o %o %o %o %o %o"",
       (int*)&amp;key[0], (int*)&amp;key[1], (int*)&amp;key[2],
       (int*)&amp;key[3], (int*)&amp;key[4], (int*)&amp;key[5],
       (int*)&amp;key[6], (int*)&amp;key[7]);
</code></pre>

<p>And add the following line:</p>

<pre><code>NSData* keyData = [NSData dataWithBytes: key length: sizeof key];
</code></pre>

<p>Except that your sscanf looks very wrong.  Elements of key are chars, not ints.</p>
","886","<cocoa><nsarray><nsdata><des>","0","0","3","2011-03-12 07:01:31","5279445","0","","","","","2011-03-11 15:35:17",""
"5274927","Cocoa Convert NSArray/NSString of octals to NSData?","<p>I'm trying to covert this bit of C code to Cocoa and I'm struggling to figure out how.</p>

<pre><code>  char *deskey = ""123 456 789 101 112 131 415 161"";
  unsigned char key[16];
  memset(key, 0, sizeof(key));
  sscanf(deskey, ""%o %o %o %o %o %o %o %o"",
    (int*)&amp;key[0], (int*)&amp;key[1], (int*)&amp;key[2],
    (int*)&amp;key[3], (int*)&amp;key[4], (int*)&amp;key[5],
    (int*)&amp;key[6], (int*)&amp;key[7]);
</code></pre>

<p>I've tried using NSMutableArray and NSData but having no luck.  I was able to scan the string and pull out the numbers, but I'm not sure how to store into NSData after that.</p>

<pre><code>  NSMutableArray *enckey = [[[NSMutableArray alloc] init] autorelease];
  NSScanner *scanner = [NSScanner scannerWithString:self.deskey];
  int pos = 0;

  while ([scanner isAtEnd] == NO) {
    if ([scanner scanInt:&amp;pos]) {
      [enckey addObject:[NSString stringWithFormat:@""%o"", pos]];
    }
    else {
      NSLog(@""Your DES key appears to be invalid."");
      return;
    }
  }
</code></pre>

<p>Basically trying to convert ascii DES key to string to use for Triple DES encryption. Any help is greatly appreciated, thank you!</p>
","<p>@Keenan ""I was hoping to avoid using sscanf and char* in place of the Cocoa classes"". Well you can do that, but what are you hoping to produce? If you want a <em>byte array</em> as the result then you need to stick to <code>unsigned char[]</code>, and that begs the question why you'd do the parsing on <code>NSString</code> in the first place.</p>

<p>Here is an Objective-C translation of your C code. Note that octal is seen as ancient history by Cocoa so its parsing classes only deal with decimal and hexadecimal, so you need to write your own or use a standard C function (<code>strtol</code> below).</p>

<p>This example produces both a <code>unsigned char[]</code> and an <code>NSMutableArray</code> - pick one.</p>

<pre><code>// There are no checks in the code, like in the original...
// BTW 789 is not an octal number...
NSString *descKey = @""123 456 789 101 112 131 415 161"";         //    char *deskey = ""123 456 789 101 112 131 415 161"";
// pick one...
NSMutableArray *keyObjC = [NSMutableArray new];                 //    unsigned char key[16];
unsigned char keyC[16];
//    memset(key, 0, sizeof(key));

// As @JeremyP has pointed out the sscanf is wrong as %o produces a 4-byte value and you only want a 1-byte one.
// In C you would therefore need key to be an array of ints and then assign each element to a byte (unsigned char),
// or parse a different way.

unsigned ix = 0;    // for keyC choice only
NSArray *numbers = [descKey componentsSeparatedByString:@"" ""];  //    sscanf(deskey, ""%o %o %o %o %o %o %o %o"",
for (NSString *aNumber in numbers)                              //           (int*)&amp;key[0], (int*)&amp;key[1], (int*)&amp;key[2],
{                                                               //           (int*)&amp;key[3], (int*)&amp;key[4], (int*)&amp;key[5],
                                                                //           (int*)&amp;key[6], (int*)&amp;key[7]);
    unsigned char next = (unsigned char)strtol([aNumber UTF8String], NULL, 8);
    keyC[ix++] = next;                                          // for keyC choice
    [keyObjC addObject:[NSNumber numberWithUnsignedChar:next]]; // keyObjC choice
}
</code></pre>

<p>If you want to approach the one line of your Python just compress the iteration to:</p>

<pre><code>for (NSString *aNumber in [descKey componentsSeparatedByString:@"" ""]) { [keyObjC addObject:[NSNumber numberWithUnsignedChar:(unsigned char)strtol([aNumber UTF8String], NULL, 8)]]; }
</code></pre>

<p>but it is still longer of course!</p>
","886","<cocoa><nsarray><nsdata><des>","0","1","3","2011-03-12 07:01:31","5279445","0","","","","","2011-03-11 15:35:17",""
"5274927","Cocoa Convert NSArray/NSString of octals to NSData?","<p>I'm trying to covert this bit of C code to Cocoa and I'm struggling to figure out how.</p>

<pre><code>  char *deskey = ""123 456 789 101 112 131 415 161"";
  unsigned char key[16];
  memset(key, 0, sizeof(key));
  sscanf(deskey, ""%o %o %o %o %o %o %o %o"",
    (int*)&amp;key[0], (int*)&amp;key[1], (int*)&amp;key[2],
    (int*)&amp;key[3], (int*)&amp;key[4], (int*)&amp;key[5],
    (int*)&amp;key[6], (int*)&amp;key[7]);
</code></pre>

<p>I've tried using NSMutableArray and NSData but having no luck.  I was able to scan the string and pull out the numbers, but I'm not sure how to store into NSData after that.</p>

<pre><code>  NSMutableArray *enckey = [[[NSMutableArray alloc] init] autorelease];
  NSScanner *scanner = [NSScanner scannerWithString:self.deskey];
  int pos = 0;

  while ([scanner isAtEnd] == NO) {
    if ([scanner scanInt:&amp;pos]) {
      [enckey addObject:[NSString stringWithFormat:@""%o"", pos]];
    }
    else {
      NSLog(@""Your DES key appears to be invalid."");
      return;
    }
  }
</code></pre>

<p>Basically trying to convert ascii DES key to string to use for Triple DES encryption. Any help is greatly appreciated, thank you!</p>
","<p>As CRD has already done a good job of showing you a correct solution, I'll use my answer to explain why your solutions didn't work.</p>

<blockquote>
<pre><code>  unsigned char key[16];
  memset(key, 0, sizeof(key));
  sscanf(deskey, ""%o %o %o %o %o %o %o %o"",
    (int*)&amp;key[0], (int*)&amp;key[1], (int*)&amp;key[2],
    (int*)&amp;key[3], (int*)&amp;key[4], (int*)&amp;key[5],
    (int*)&amp;key[6], (int*)&amp;key[7]);
</code></pre>
</blockquote>

<p>Lying to the compiler never solves problems.</p>

<p><code>key</code> is an array of <code>unsigned char</code>s. Telling the compiler, in your function call to <code>sscanf</code>, that your pointers into the array are pointers to <code>int</code>s does not make them so; the storage each one points to is still storage for an <code>unsigned char</code>, and no more.</p>

<p>The result of this is that each attempt to store one <code>int</code> at an address you provided overwrites three-quarters of the previous <code>int</code>. The result of <em>that</em> is that the <code>sscanf</code> amounts to little more than a harder way of doing the same thing as the <code>memset</code>.</p>

<p>I say “little more” and not “no more” for a reason: The <code>sscanf</code> call also writes <code>sizeof(int) - sizeof(unsigned char)</code> bytes beyond the end of the array, so you are also smashing the stack and setting up for a potential crash.</p>

<blockquote>
<pre><code>    if ([scanner scanInt:&amp;pos]) {
      [enckey addObject:[NSString stringWithFormat:@""%o"", pos]];
</code></pre>
</blockquote>

<p><code>scanInt:</code> parses the number from the string in decimal. <code>stringWithFormat:</code> likewise does what its name says: It creates a string. With the format you gave it, it converts a number to a string, not the other way around.</p>

<p>Thus, you use <code>scanInt:</code> to parse the number in decimal, and <code>stringWithFormat:</code> to convert it to octal (and encode it back into a string). Assuming, from the <code>sscanf</code>-based code, that the input was in octal, this is the opposite of what you want.</p>

<p>This code will certainly give you numbers, but it will give you wrong numbers, which is almost as bad as the <code>sscanf</code> code that gave you all zeroes plus a crash.</p>

<p>You cannot use NSScanner to scan octal numbers.</p>

<p>I'm also not sure why you called this variable <code>pos</code>, as it does not appear to be a position. Certainly that's not what <code>scanInt:</code> gives you.</p>

<blockquote>
  <p>I was able to scan the string and pull out the numbers, but I'm not sure how to store into NSData after that.</p>
</blockquote>

<p>See <a href=""http://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/"" rel=""nofollow"">the NSData documentation</a>.</p>

<blockquote>
  <p>I've tried using NSMutableArray and NSData but having no luck.</p>
</blockquote>

<p>That has nothing to do with the problem, which is parsing the input data.</p>

<p>I'm not sure whether an NSArray or a C array (the latter optionally wrapped in an NSData) would be the correct place to put the result. It depends on where you want to pass the numbers once you have them parsed.</p>
","886","<cocoa><nsarray><nsdata><des>","0","0","3","2011-03-12 07:01:31","5279445","0","","","","","2011-03-11 15:35:17",""
"26796439","DES Encryption is not working C#","<p>I have wrote DES in C# from scratch, and I will post the whole code here, for me it seems right but when I'm trying an example it is not. Here is my entire code.</p>

<p>Des Class:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class DES
    {
        string leftSide = """";
        string rightSide = """";
        string tempLeft = """";

        F_Function f = new F_Function();
        Key_Scheduler k = new Key_Scheduler();

        public string DESEncryption(string input, string Key)
        {
            input = String.Join(String.Empty,
  input.Select(
    c =&gt; Convert.ToString(Convert.ToInt32(c.ToString(), 16), 2).PadLeft(4, '0')
  )
);
            Key = String.Join(String.Empty,
  Key.Select(
    c =&gt; Convert.ToString(Convert.ToInt32(c.ToString(), 16), 2).PadLeft(4, '0')
  )
);
            // input = strtoBin(input);
            string chunk = """";
            string finalPerm = """";
            string result = """";
            string[] subKeys;

            //split the string into blocks of 64 bits
            IEnumerable&lt;string&gt; output = Enumerable.Range(0, input.Length / 64)
   .Select(x =&gt; input.Substring(x * 64, 64));
            string[] newInput = output.ToArray();

            //for each block 
            for (int i = 0; i &lt; newInput.Length; i++)
            {
                //Initial Permutation
                chunk = initalPermutation(newInput[i]);

                //split the chunk in two halves 32 bit each
                leftSide = chunk.Substring(0, chunk.Length / 2);
                rightSide = chunk.Substring(chunk.Length / 2, chunk.Length / 2);
                subKeys = k.keySched(Key);

                for (int j = 0; j &lt; 16; j++)
                {

                    //F Function on the right side
                    tempLeft = leftSide;
                    leftSide = rightSide;
                    rightSide = f.f_function(rightSide, subKeys[j]);
                    rightSide = XOR(tempLeft, rightSide);

                }

                finalPerm = rightSide + leftSide;
                finalPerm = finalPermutation(finalPerm);
                result = result + finalPerm;
            }
            result = BinaryStringToHexString(result);
            return result;
        }

        private string initalPermutation(string block)
        {


            char[] tempBlock ={block[57],block[49],block[41],block[33],block[25],block[17],block[9],block[1],
                             block[59],block[51],block[43],block[35],block[27],block[19],block[11],block[3],
                             block[61],block[53],block[45],block[37],block[29],block[21],block[13],block[5],
                             block[63],block[55],block[47],block[39],block[31],block[23],block[15],block[7],
                             block[56],block[48],block[40],block[32],block[24],block[16],block[8],block[0],
                             block[58],block[50],block[42],block[34],block[26],block[18],block[10],block[2],
                             block[60],block[52],block[44],block[36],block[28],block[20],block[12],block[4],
                             block[62],block[54],block[46],block[38],block[30],block[22],block[14],block[6]};
            string res = new string(tempBlock);
            return res;
        }

        private string finalPermutation(string block)
        {

            char[] tempBlock ={block[39],block[7],block[47],block[15],block[55],block[23],block[63],block[31],
                             block[38],block[6],block[46],block[14],block[54],block[22],block[62],block[30],
                             block[37],block[5],block[45],block[13],block[53],block[21],block[61],block[29],
                             block[36],block[4],block[44],block[12],block[52],block[20],block[60],block[28],
                             block[35],block[3],block[43],block[11],block[51],block[19],block[59],block[27],
                             block[34],block[2],block[42],block[10],block[50],block[18],block[58],block[26],
                             block[33],block[1],block[41],block[9],block[49],block[17],block[57],block[25],
                             block[32],block[0],block[40],block[8],block[48],block[16],block[56],block[24]};
            string res = new string(tempBlock);
            return res;
        }

        //convert string to binary function
        private string strtoBin(string input)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char L in input)
            {
                sb.Append(Convert.ToString(L, 2).PadLeft(8, '0'));

            }

            return sb.ToString();
        }

        private string XOR(string expanedArray, string key)
        {
            string[] result = new string[key.Length];
            string res;
            char[] a = expanedArray.ToCharArray();
            char[] b = key.ToCharArray();

            for (int i = 0; i &lt; key.Length; i++)
            {
                result[i] = (a[i] ^ b[i]).ToString();

            }
            res = string.Join("""", result);
            return res;
        }
        private static string BinaryStringToHexString(string binary)
        {
            StringBuilder result = new StringBuilder(binary.Length / 8 + 1);

            // TODO: check all 1's or 0's... Will throw otherwise

            int mod4Len = binary.Length % 8;
            if (mod4Len != 0)
            {
                // pad to length multiple of 8
                binary = binary.PadLeft(((binary.Length / 8) + 1) * 8, '0');
            }

            for (int i = 0; i &lt; binary.Length; i += 8)
            {
                string eightBits = binary.Substring(i, 8);
                result.AppendFormat(""{0:X2}"", Convert.ToByte(eightBits, 2));
            }

            return result.ToString();
        }

}
}
</code></pre>

<p>Key Class:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class Key_Scheduler
    {
        public static String c0 = """";
        public static String d0 = """";
        public string[] keySched(string key)
        {

                string[] keys = new string[16];
                string  perm1 = """";

                    //Permutation Choice - 1
                    perm1 = permuatedchoice1(key);

                    //split the key in two halves 28 bit each
                    c0 = perm1.Substring(0, perm1.Length / 2);
                    d0 = perm1.Substring(perm1.Length / 2, perm1.Length / 2);

                    for (int i = 0; i &lt; 16; i++)
                    {
                        keys[i] = GenerateKeys(c0, d0, i);

                    }

                    return keys;
            }

        private string GenerateKeys(string L, string R,int i)
        {
            string key;
            if (i == 0 || i == 1 || i == 8 || i == 15)
            {
                c0 = rotateShift(L, 1);
                d0 = rotateShift(R, 1);

                key = L + R;
                key = permuatedchoice2(key);
                return key;
            }

            else
            {
                c0 = rotateShift(L, 2);
                d0 = rotateShift(R, 2);

                key = L + R;
                key = permuatedchoice2(key);
                return key;
            }


        }

        private string rotateShift(string key, int shift)
        {
            string res="""";
            string[] result = new string[key.Length];
            char[] a = key.ToCharArray();
            int index = 0;
            for (int i = shift;  index &lt; a.Length; i++)
            {
                result[index++] = a[i % a.Length].ToString();
            }
            res = string.Join("""", result);
            return res;
        }
        private string permuatedchoice1(string key)
        {
            string res;
            char[] tempArr ={key[56],key[48],key[40],key[32],key[24],key[16],key[8],key[0],
                            key[57],key[49],key[41],key[33],key[25],key[17],key[9],key[1],
                            key[58],key[50],key[42],key[34],key[26],key[18],key[10],key[2],
                            key[59],key[51],key[43],key[35],key[62],key[54],key[46],key[38],
                            key[30],key[22],key[14],key[6],key[61],key[53],key[45],key[37],
                            key[29],key[21],key[13],key[5],key[60],key[52],key[44],key[36],
                            key[28],key[20],key[12],key[4],key[27],key[19],key[11],key[3]};

            res = new string(tempArr);
            return res;
        }

        private string permuatedchoice2(string key)
        {
            string res;
            char[] tempArr ={key[13],key[16],key[10],key[23],key[0],key[4],key[2],key[27],
                            key[14],key[5],key[20],key[9],key[22],key[18],key[11],key[3],
                            key[25],key[7],key[15],key[6],key[26],key[19],key[12],key[1],
                            key[40],key[51],key[30],key[36],key[46],key[54],key[29],key[39],
                            key[50],key[44],key[32],key[47],key[43],key[48],key[38],key[55],
                            key[33],key[52],key[45],key[41],key[49],key[35],key[28],key[31]};

            res = new string(tempArr);
            return res;
        }

    }
}
</code></pre>

<p>And Finally, the F Function Class: </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class F_Function
    {
        #region SBoxes definition
        int[,] s1Box = {{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},
                     {0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},
                     {4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},
                     {15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}};

        int[,] s2Box = {{15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},
                       {3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},
                       {0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},
                       {13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}};

        int[,] s3Box = {{10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},
                       {13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},
                       {13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},
                       {1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}};

        int[,] s4Box = {{7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},
                       {13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},
                       {10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},
                       {3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}};

        int[,] s5Box = {{2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},
                      {14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},
                      {4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},
                      {11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}};

        int[,] s6Box = {{12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},
                      {10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},
                      {9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},
                      {4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}};

        int[,] s7Box = {{4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},
                       {13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},
                       {1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},
                       {6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}};

        int[,] s8Box = {{13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},
                       {1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},
                       {7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},
                       {2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}};
        #endregion
        int[] expanstionArr = new int[48] { 31, 0, 1, 2, 3, 4,
                                            3, 4, 5, 6, 7, 8, 
                                            7, 8, 9, 10, 11, 12,
                                            11, 12, 13, 14, 15, 16,
                                            15, 16, 17, 18, 19, 20, 
                                            19, 20, 21, 22, 23, 24,
                                            23, 24, 25, 26, 27, 28, 
                                            27, 28, 29, 30, 31, 1 };

        int[] permutationMatrix = new int[32] { 15, 6, 19, 20, 28, 11, 27, 16,
                                                0, 14, 22, 25, 4, 17, 30, 9, 
                                                1, 7, 23, 13, 31, 26, 2, 8, 
                                                18, 12, 29, 5, 21, 10, 3, 24 };

        Key_Scheduler key = new Key_Scheduler();
        public string f_function(string input, string mainKey)
        {
            string res, exp, xor, sboxsub, perm;
            exp = expansion(input);
            //subKey =key.keySched(mainKey);
            int a = mainKey.Length - exp.Length;
            xor=XORwithKey(exp,mainKey);
            sboxsub = SBoxSubstitution(xor);
            perm = permutation(sboxsub);
            res = perm;
            return res;
        }
        private string expansion (string rightSide )
        {
            char[] arr = new char[48];
            int len = rightSide.Length;

            for (int i = 0; i &lt; arr.Length; i++)
            {
                arr[i] = rightSide[expanstionArr[i]];

            }
            string res = new string(arr);
            return res;
        }
        private string XORwithKey(string expanedArray,string key)
        {
            string[] result = new string[key.Length];
            string res;
            char[] a = expanedArray.ToCharArray();
            char[] b = key.ToCharArray();

            for (int i = 0; i &lt; key.Length; i++)
            {
                result[i] = (a[i] ^ b[i]).ToString();

            }
            res = string.Join("""", result);
            return res;
        }

        private string SBoxSubstitution(string input)
        {
            string res="""";
            string r;
            int row, col, s1, s2, s3, s4, s5, s6, s7, s8;
            string c;
            char[] temp;
            IEnumerable&lt;string&gt; output = Enumerable.Range(0, input.Length / 6)
              .Select(x =&gt; input.Substring(x * 6, 6));
            string[] newInput = output.ToArray();

            for (int i = 0; i &lt; newInput.Length; i++)
            {
                temp = newInput[i].ToCharArray();
                r = temp[0].ToString()+temp[5].ToString();
                row = Convert.ToInt32(r,2);
                c = temp[1].ToString() + temp[2].ToString() + temp[3].ToString() + temp[4].ToString();
                col = Convert.ToInt32(c,2);
                if (i == 0)
                {
                    s1 = SBoxSearch(row, col, s1Box);
                    res += s1.ToString();
                }
                else if (i == 1)
                {
                    s2 = SBoxSearch(row, col, s2Box);
                    res += s2.ToString();
                }
                else if (i == 2)
                {
                    s3 = SBoxSearch(row, col, s3Box);
                    res += s3.ToString();
                }
                else if (i == 3)
                {
                    s4 = SBoxSearch(row, col, s4Box);
                    res += s4.ToString();
                }
                else if (i == 4)
                {
                    s5 = SBoxSearch(row, col, s5Box);
                    res += s5.ToString();
                }
                else if (i == 5)
                {
                    s6 = SBoxSearch(row, col, s6Box);
                    res += s6.ToString();
                }
                else if (i == 6)
                {
                    s7 = SBoxSearch(row, col, s7Box);
                    res += s7.ToString();
                }
                else
                {
                    s8 = SBoxSearch(row, col, s8Box);
                    res += s8.ToString();
                }
            }

            res = strtoBin(res);
            return res;
        }

        private string permutation(string input)
        {
            char[] arr = new char[32];

            for (int i = 0; i &lt; arr.Length; i++)
            {
                arr[i] = input[permutationMatrix[i]];

            }
            string res = new string(arr);

            return res;
        }

        private int SBoxSearch(int row, int col, int[,] sBox)
        {
            int res=0;
            for (int i = 0; i &lt; 4; i++)
            {
                if (i == row)
                {
                    for (int j = 0; j &lt; 16; j++)
                    {
                        if (j == col)
                        { 
                            res = sBox[i, j];
                            break;
                        }
                        else continue;
                    }
                    break;
                }
                else continue;
            }
            return res;
        }

        private string strtoBin(string input)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char L in input)
            {
                sb.Append(Convert.ToString(L, 2).PadLeft(8, '0'));

            }

            return sb.ToString();
        }


    }
}
</code></pre>

<p>When I'm testing it, btw all inputs are in hex, my input is:
02468aceeca86420</p>

<p>Used key is: </p>

<p>0f1571c947d9e859</p>

<p>the encryption output should be:</p>

<p>da02ce3a89ecac3b</p>

<p>But I'm getting this output instead:</p>

<p>019945B853663D50</p>

<p>I double checked everything and I really don't know what I did wrong here ... Pardon me for the messy code but it was written in less than a day :/ </p>

<p>Thank you for any tip </p>
","<p>This is the implementation of the DES algorithm, as specified by the NIST in publication FIPS PUB 197, availible on the NIST website, <a href=""http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf"" rel=""nofollow"">here</a>. The algorithm takes 64 bit blocks and encrypts them using a 56 bit key, producing a 64 bit output in the classic case with no padding or zero padding. Your implementation should use bitwise operations over 8 byte arrays, not hex string representations of length 16, or <code>char[32]</code> like you do in your permutations. Obviously permutations, shifts or rotations of char arrays of size 16 or 32 are not idempotent with same operations over 64 bit values described in the algorithm and adjustments should be made. Not only this approach is bug prone, but it is also much slower. Answering this would mean debugging and fixing your code which is beyond the purpose of this site imho, and since this looks like a homework to me (prove me wrong) I am going to preach this small <code>DESCryptoServiceProvider</code> wrapper.</p>

<pre><code>static class DesCsp
{

  public static byte[] EncryptBytes(byte[] input, byte[] desKey, byte[] desIV)
  {
    DES des = new DESCryptoServiceProvider();
    des.Padding = PaddingMode.None;
    var enc = des.CreateEncryptor(desKey, desIV);
    return enc.TransformFinalBlock (input, 0, input.Length);    
  }

  public static byte[] DecryptBytes(byte[] encryptedOutput, byte[] desKey, byte[] desIV)
  {
    DES des = new DESCryptoServiceProvider();
    des.Padding = PaddingMode.None;
    var dec = des.CreateDecryptor(desKey, desIV);
    return dec.TransformFinalBlock(encryptedOutput, 0, encryptedOutput.Length);
  }

  public static string EncryptHexStrings(string input, byte[] desKey, byte[] desIV)
  {
    byte[] bytes = HexStringToByteArray(input);
    byte[] encBytes = EncryptBytes (bytes,desKey,desIV);
    return ByteArrayToHexString(encBytes);
  }

  public static string DecryptHexStrings(string encryptedOutput, byte[] desKey, byte[] desIV)
  {
    byte[] bytes = HexStringToByteArray(encryptedOutput);
    byte[] decBytes = DecryptBytes(bytes,desKey,desIV);
    return ByteArrayToHexString(decBytes);
  }

  public static string EncryptHexStrings(string input, string desKey, string desIV)
  {
    byte[] key = HexStringToByteArray(desKey);
    byte[] iv = HexStringToByteArray(desIV);
    return EncryptHexStrings(input, key, iv);
  }

  public static string DecryptHexStrings(string encryptedOutput, string desKey, string desIV)
  {
    byte[] key = HexStringToByteArray(desKey);
    byte[] iv = HexStringToByteArray(desIV);
    return DecryptHexStrings(encryptedOutput,key,iv);
  }

  public static byte[] HexStringToByteArray(string s)
  {
    byte[] ret = new byte[s.Length / 2];
    for (int i=0; i&lt;s.Length; i+=2)
    {
      ret[i/2] = Convert.ToByte (s.Substring (i,2), 16);      
    }
    return ret;
  }

  public static string ByteArrayToHexString(byte[] bytes)
  {
    StringBuilder sb = new StringBuilder();
    foreach (byte b in bytes)
      sb.AppendFormat(""{0:X2}"", b);
    return sb.ToString();
  }

}
</code></pre>

<p>Check it like this, with your data:</p>

<pre><code>// the encryption output should be: da02ce3a89ecac3b
// But I'm getting this output instead: 019945B853663D50
string inputString = ""02468aceeca86420"";
string stringkey = ""0f1571c947d9e859"";
string encryptedReference = ""da02ce3a89ecac3b"";
string siv = ""0000000000000000"";
encryptedString = DesCsp.EncryptHexStrings(inputString, stringkey, siv);
decryptedString = DesCsp.DecryptHexStrings(encryptedString, stringkey, siv);
Debug.Assert(inputString.ToUpper() == decryptedString.ToUpper());
Debug.Assert(encryptedString.ToUpper() == encryptedReference.ToUpper());
</code></pre>

<p>The symmetric encryption algorithms in <code>System.Security.Cryptography</code> also have an initialization vector, but you needn't worry about that. Just like this wrapper
you could use your <code>EncryptBytes(byte[] input, byte[] desKey)</code> method all over the place. For your <code>public static string EncryptHexStrings(string input, string desKey)</code> you'd adapt the input string to a byte array, encrypt it as bytes, make a hex string out of the encrypted bytes on return.</p>
","885","<c#><encryption><des>","2","0","3","2019-02-28 18:12:55","26811149","6","2","","","","2014-11-07 07:44:58",""
"26796439","DES Encryption is not working C#","<p>I have wrote DES in C# from scratch, and I will post the whole code here, for me it seems right but when I'm trying an example it is not. Here is my entire code.</p>

<p>Des Class:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class DES
    {
        string leftSide = """";
        string rightSide = """";
        string tempLeft = """";

        F_Function f = new F_Function();
        Key_Scheduler k = new Key_Scheduler();

        public string DESEncryption(string input, string Key)
        {
            input = String.Join(String.Empty,
  input.Select(
    c =&gt; Convert.ToString(Convert.ToInt32(c.ToString(), 16), 2).PadLeft(4, '0')
  )
);
            Key = String.Join(String.Empty,
  Key.Select(
    c =&gt; Convert.ToString(Convert.ToInt32(c.ToString(), 16), 2).PadLeft(4, '0')
  )
);
            // input = strtoBin(input);
            string chunk = """";
            string finalPerm = """";
            string result = """";
            string[] subKeys;

            //split the string into blocks of 64 bits
            IEnumerable&lt;string&gt; output = Enumerable.Range(0, input.Length / 64)
   .Select(x =&gt; input.Substring(x * 64, 64));
            string[] newInput = output.ToArray();

            //for each block 
            for (int i = 0; i &lt; newInput.Length; i++)
            {
                //Initial Permutation
                chunk = initalPermutation(newInput[i]);

                //split the chunk in two halves 32 bit each
                leftSide = chunk.Substring(0, chunk.Length / 2);
                rightSide = chunk.Substring(chunk.Length / 2, chunk.Length / 2);
                subKeys = k.keySched(Key);

                for (int j = 0; j &lt; 16; j++)
                {

                    //F Function on the right side
                    tempLeft = leftSide;
                    leftSide = rightSide;
                    rightSide = f.f_function(rightSide, subKeys[j]);
                    rightSide = XOR(tempLeft, rightSide);

                }

                finalPerm = rightSide + leftSide;
                finalPerm = finalPermutation(finalPerm);
                result = result + finalPerm;
            }
            result = BinaryStringToHexString(result);
            return result;
        }

        private string initalPermutation(string block)
        {


            char[] tempBlock ={block[57],block[49],block[41],block[33],block[25],block[17],block[9],block[1],
                             block[59],block[51],block[43],block[35],block[27],block[19],block[11],block[3],
                             block[61],block[53],block[45],block[37],block[29],block[21],block[13],block[5],
                             block[63],block[55],block[47],block[39],block[31],block[23],block[15],block[7],
                             block[56],block[48],block[40],block[32],block[24],block[16],block[8],block[0],
                             block[58],block[50],block[42],block[34],block[26],block[18],block[10],block[2],
                             block[60],block[52],block[44],block[36],block[28],block[20],block[12],block[4],
                             block[62],block[54],block[46],block[38],block[30],block[22],block[14],block[6]};
            string res = new string(tempBlock);
            return res;
        }

        private string finalPermutation(string block)
        {

            char[] tempBlock ={block[39],block[7],block[47],block[15],block[55],block[23],block[63],block[31],
                             block[38],block[6],block[46],block[14],block[54],block[22],block[62],block[30],
                             block[37],block[5],block[45],block[13],block[53],block[21],block[61],block[29],
                             block[36],block[4],block[44],block[12],block[52],block[20],block[60],block[28],
                             block[35],block[3],block[43],block[11],block[51],block[19],block[59],block[27],
                             block[34],block[2],block[42],block[10],block[50],block[18],block[58],block[26],
                             block[33],block[1],block[41],block[9],block[49],block[17],block[57],block[25],
                             block[32],block[0],block[40],block[8],block[48],block[16],block[56],block[24]};
            string res = new string(tempBlock);
            return res;
        }

        //convert string to binary function
        private string strtoBin(string input)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char L in input)
            {
                sb.Append(Convert.ToString(L, 2).PadLeft(8, '0'));

            }

            return sb.ToString();
        }

        private string XOR(string expanedArray, string key)
        {
            string[] result = new string[key.Length];
            string res;
            char[] a = expanedArray.ToCharArray();
            char[] b = key.ToCharArray();

            for (int i = 0; i &lt; key.Length; i++)
            {
                result[i] = (a[i] ^ b[i]).ToString();

            }
            res = string.Join("""", result);
            return res;
        }
        private static string BinaryStringToHexString(string binary)
        {
            StringBuilder result = new StringBuilder(binary.Length / 8 + 1);

            // TODO: check all 1's or 0's... Will throw otherwise

            int mod4Len = binary.Length % 8;
            if (mod4Len != 0)
            {
                // pad to length multiple of 8
                binary = binary.PadLeft(((binary.Length / 8) + 1) * 8, '0');
            }

            for (int i = 0; i &lt; binary.Length; i += 8)
            {
                string eightBits = binary.Substring(i, 8);
                result.AppendFormat(""{0:X2}"", Convert.ToByte(eightBits, 2));
            }

            return result.ToString();
        }

}
}
</code></pre>

<p>Key Class:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class Key_Scheduler
    {
        public static String c0 = """";
        public static String d0 = """";
        public string[] keySched(string key)
        {

                string[] keys = new string[16];
                string  perm1 = """";

                    //Permutation Choice - 1
                    perm1 = permuatedchoice1(key);

                    //split the key in two halves 28 bit each
                    c0 = perm1.Substring(0, perm1.Length / 2);
                    d0 = perm1.Substring(perm1.Length / 2, perm1.Length / 2);

                    for (int i = 0; i &lt; 16; i++)
                    {
                        keys[i] = GenerateKeys(c0, d0, i);

                    }

                    return keys;
            }

        private string GenerateKeys(string L, string R,int i)
        {
            string key;
            if (i == 0 || i == 1 || i == 8 || i == 15)
            {
                c0 = rotateShift(L, 1);
                d0 = rotateShift(R, 1);

                key = L + R;
                key = permuatedchoice2(key);
                return key;
            }

            else
            {
                c0 = rotateShift(L, 2);
                d0 = rotateShift(R, 2);

                key = L + R;
                key = permuatedchoice2(key);
                return key;
            }


        }

        private string rotateShift(string key, int shift)
        {
            string res="""";
            string[] result = new string[key.Length];
            char[] a = key.ToCharArray();
            int index = 0;
            for (int i = shift;  index &lt; a.Length; i++)
            {
                result[index++] = a[i % a.Length].ToString();
            }
            res = string.Join("""", result);
            return res;
        }
        private string permuatedchoice1(string key)
        {
            string res;
            char[] tempArr ={key[56],key[48],key[40],key[32],key[24],key[16],key[8],key[0],
                            key[57],key[49],key[41],key[33],key[25],key[17],key[9],key[1],
                            key[58],key[50],key[42],key[34],key[26],key[18],key[10],key[2],
                            key[59],key[51],key[43],key[35],key[62],key[54],key[46],key[38],
                            key[30],key[22],key[14],key[6],key[61],key[53],key[45],key[37],
                            key[29],key[21],key[13],key[5],key[60],key[52],key[44],key[36],
                            key[28],key[20],key[12],key[4],key[27],key[19],key[11],key[3]};

            res = new string(tempArr);
            return res;
        }

        private string permuatedchoice2(string key)
        {
            string res;
            char[] tempArr ={key[13],key[16],key[10],key[23],key[0],key[4],key[2],key[27],
                            key[14],key[5],key[20],key[9],key[22],key[18],key[11],key[3],
                            key[25],key[7],key[15],key[6],key[26],key[19],key[12],key[1],
                            key[40],key[51],key[30],key[36],key[46],key[54],key[29],key[39],
                            key[50],key[44],key[32],key[47],key[43],key[48],key[38],key[55],
                            key[33],key[52],key[45],key[41],key[49],key[35],key[28],key[31]};

            res = new string(tempArr);
            return res;
        }

    }
}
</code></pre>

<p>And Finally, the F Function Class: </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class F_Function
    {
        #region SBoxes definition
        int[,] s1Box = {{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},
                     {0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},
                     {4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},
                     {15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}};

        int[,] s2Box = {{15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},
                       {3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},
                       {0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},
                       {13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}};

        int[,] s3Box = {{10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},
                       {13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},
                       {13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},
                       {1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}};

        int[,] s4Box = {{7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},
                       {13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},
                       {10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},
                       {3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}};

        int[,] s5Box = {{2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},
                      {14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},
                      {4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},
                      {11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}};

        int[,] s6Box = {{12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},
                      {10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},
                      {9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},
                      {4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}};

        int[,] s7Box = {{4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},
                       {13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},
                       {1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},
                       {6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}};

        int[,] s8Box = {{13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},
                       {1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},
                       {7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},
                       {2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}};
        #endregion
        int[] expanstionArr = new int[48] { 31, 0, 1, 2, 3, 4,
                                            3, 4, 5, 6, 7, 8, 
                                            7, 8, 9, 10, 11, 12,
                                            11, 12, 13, 14, 15, 16,
                                            15, 16, 17, 18, 19, 20, 
                                            19, 20, 21, 22, 23, 24,
                                            23, 24, 25, 26, 27, 28, 
                                            27, 28, 29, 30, 31, 1 };

        int[] permutationMatrix = new int[32] { 15, 6, 19, 20, 28, 11, 27, 16,
                                                0, 14, 22, 25, 4, 17, 30, 9, 
                                                1, 7, 23, 13, 31, 26, 2, 8, 
                                                18, 12, 29, 5, 21, 10, 3, 24 };

        Key_Scheduler key = new Key_Scheduler();
        public string f_function(string input, string mainKey)
        {
            string res, exp, xor, sboxsub, perm;
            exp = expansion(input);
            //subKey =key.keySched(mainKey);
            int a = mainKey.Length - exp.Length;
            xor=XORwithKey(exp,mainKey);
            sboxsub = SBoxSubstitution(xor);
            perm = permutation(sboxsub);
            res = perm;
            return res;
        }
        private string expansion (string rightSide )
        {
            char[] arr = new char[48];
            int len = rightSide.Length;

            for (int i = 0; i &lt; arr.Length; i++)
            {
                arr[i] = rightSide[expanstionArr[i]];

            }
            string res = new string(arr);
            return res;
        }
        private string XORwithKey(string expanedArray,string key)
        {
            string[] result = new string[key.Length];
            string res;
            char[] a = expanedArray.ToCharArray();
            char[] b = key.ToCharArray();

            for (int i = 0; i &lt; key.Length; i++)
            {
                result[i] = (a[i] ^ b[i]).ToString();

            }
            res = string.Join("""", result);
            return res;
        }

        private string SBoxSubstitution(string input)
        {
            string res="""";
            string r;
            int row, col, s1, s2, s3, s4, s5, s6, s7, s8;
            string c;
            char[] temp;
            IEnumerable&lt;string&gt; output = Enumerable.Range(0, input.Length / 6)
              .Select(x =&gt; input.Substring(x * 6, 6));
            string[] newInput = output.ToArray();

            for (int i = 0; i &lt; newInput.Length; i++)
            {
                temp = newInput[i].ToCharArray();
                r = temp[0].ToString()+temp[5].ToString();
                row = Convert.ToInt32(r,2);
                c = temp[1].ToString() + temp[2].ToString() + temp[3].ToString() + temp[4].ToString();
                col = Convert.ToInt32(c,2);
                if (i == 0)
                {
                    s1 = SBoxSearch(row, col, s1Box);
                    res += s1.ToString();
                }
                else if (i == 1)
                {
                    s2 = SBoxSearch(row, col, s2Box);
                    res += s2.ToString();
                }
                else if (i == 2)
                {
                    s3 = SBoxSearch(row, col, s3Box);
                    res += s3.ToString();
                }
                else if (i == 3)
                {
                    s4 = SBoxSearch(row, col, s4Box);
                    res += s4.ToString();
                }
                else if (i == 4)
                {
                    s5 = SBoxSearch(row, col, s5Box);
                    res += s5.ToString();
                }
                else if (i == 5)
                {
                    s6 = SBoxSearch(row, col, s6Box);
                    res += s6.ToString();
                }
                else if (i == 6)
                {
                    s7 = SBoxSearch(row, col, s7Box);
                    res += s7.ToString();
                }
                else
                {
                    s8 = SBoxSearch(row, col, s8Box);
                    res += s8.ToString();
                }
            }

            res = strtoBin(res);
            return res;
        }

        private string permutation(string input)
        {
            char[] arr = new char[32];

            for (int i = 0; i &lt; arr.Length; i++)
            {
                arr[i] = input[permutationMatrix[i]];

            }
            string res = new string(arr);

            return res;
        }

        private int SBoxSearch(int row, int col, int[,] sBox)
        {
            int res=0;
            for (int i = 0; i &lt; 4; i++)
            {
                if (i == row)
                {
                    for (int j = 0; j &lt; 16; j++)
                    {
                        if (j == col)
                        { 
                            res = sBox[i, j];
                            break;
                        }
                        else continue;
                    }
                    break;
                }
                else continue;
            }
            return res;
        }

        private string strtoBin(string input)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char L in input)
            {
                sb.Append(Convert.ToString(L, 2).PadLeft(8, '0'));

            }

            return sb.ToString();
        }


    }
}
</code></pre>

<p>When I'm testing it, btw all inputs are in hex, my input is:
02468aceeca86420</p>

<p>Used key is: </p>

<p>0f1571c947d9e859</p>

<p>the encryption output should be:</p>

<p>da02ce3a89ecac3b</p>

<p>But I'm getting this output instead:</p>

<p>019945B853663D50</p>

<p>I double checked everything and I really don't know what I did wrong here ... Pardon me for the messy code but it was written in less than a day :/ </p>

<p>Thank you for any tip </p>
","<p>The encrypt test vector (0F1571C947D9E859 02468ACEECA86420 DA02CE3A89ECAC3B) is valid, I checked against standard compliant implementation.</p>

<p>The way to trouble shoot a new DES implementation is to compare round values against a known implementation, such as using a <a href=""http://seit.unsw.adfa.edu.au/staff/sites/lpb/src/DEScalc/"" rel=""nofollow"">DES Calculator</a> that produces round values. You could likewise copy a known good implementation and modify it to output round values. It also means producing the same values for your implementation each round.  </p>

<p>The failure will show up in your implementation of one or more of the permutations, the  key schedule or it's shift direction, or programming language syntax or semantics.</p>

<p>It's easier to compare binary results when you're dealing with strings of 1's and 0's.</p>

<p>There's also a javascript implementation of DES found on google code:
<a href=""https://code.google.com/p/dpades/source/browse/trunk/simu_js/JS-DES.html"" rel=""nofollow"">JS-DES.html</a>, and if you want the missing images from the bottom of the page they can be found at <a href=""https://code.google.com/p/dpades/source/browse/trunk/simu_js/JS-DES_fichiers"" rel=""nofollow"">JS-DES_fichiers</a>.  Save the images in a sub directory named JS-DES_fichiers.</p>

<p>This is what it produces for </p>

<p>Key: 0F1571C947D9E859<br>
Input: 02468ACEECA86420<br>
(Expected output: DA02CE3A89ECAC3B)  </p>

<pre><code>Input bits: 00000010 01000110 10001010 11001110 11101100 10101000 01100100 00100000
Key bits: 00001111 00010101 01110001 11001001 01000111 11011001 11101000 01011001
CD[0]:  0110100 0111111 0001000 1001010 0001000 1000100 1111101 0010110
CD[1]:  1101000 1111110 0010001 0010100 0010001 0001001 1111010 0101100
KS[1]:  011110 000011 001111 000011 001000 001101 101001 110000
CD[2]:  1010001 1111100 0100010 0101001 0100010 0010011 1110100 1011000
KS[2]:  001010 110001 101001 110100 110010 100100 100011 011000
CD[3]:  1000111 1110001 0001001 0100110 0001000 1001111 1010010 1100001
KS[3]:  100011 000111 100011 011000 100000 011101 001100 011101
CD[4]:  0011111 1000100 0100101 0011010 0100010 0111110 1001011 0000100
KS[4]:  000101 100110 011101 111000 100100 110001 011010 100000
CD[5]:  1111110 0010001 0010100 1101000 0001001 1111010 0101100 0010001
KS[5]:  110011 100101 110100 000001 110110 000000 101100 100101
CD[6]:  1111000 1000100 1010011 0100011 0100111 1101001 0110000 1000100
KS[6]:  010010 111010 101101 001101 000100 100110 101010 011100
CD[7]:  1100010 0010010 1001101 0001111 0011111 0100101 1000010 0010001
KS[7]:  000010 011111 010010 001011 011100 010011 000110 010001
CD[8]:  0001000 1001010 0110100 0111111 1111101 0010110 0001000 1000100
KS[8]:  011100 010000 110111 101010 101000 110010 000000 101011
CD[9]:  0010001 0010100 1101000 1111110 1111010 0101100 0010001 0001001
KS[9]:  000100 101001 101010 111000 001100 110100 011111 000011
CD[10]:  1000100 1010011 0100011 1111000 1101001 0110000 1000100 0100111
KS[10]:  100111 000011 100001 100110 000111 101000 000100 000011
CD[11]:  0010010 1001101 0001111 1100010 0100101 1000010 0010001 0011111
KS[11]:  101000 100110 111001 001100 110001 100110 010101 000100
CD[12]:  1001010 0110100 0111111 0001000 0010110 0001000 1000100 1111101
KS[12]:  010010 000111 011100 100100 011010 001010 001111 001000
CD[13]:  0101001 1010001 1111100 0100010 1011000 0100010 0010011 1110100
KS[13]:  110000 001001 110101 111001 111100 001101 010000 001011
CD[14]:  0100110 1000111 1110001 0001001 1100001 0001000 1001111 1010010
KS[14]:  110001 011110 001001 100011 010011 100001 011000 101010
CD[15]:  0011010 0011111 1000100 0100101 0000100 0100010 0111110 1001011
KS[15]:  101000 111101 111110 000010 100111 000111 100101 101000
CD[16]:  0110100 0111111 0001000 1001010 0001000 1000100 1111101 0010110
KS[16]:  101001 100001 001000 001011 010011 010100 110000 100101
L[0]:  01011010 00000000 01011010 00000000
R[0]:  00111100 11110000 00111100 00001111
Round 1
E   :  100111 111001 011110 100000 000111 111000 000001 011110
KS  :  011110 000011 001111 000011 001000 001101 101001 110000
E xor KS:  111001 111010 010001 100011 001111 110101 101000 101110
Sbox:  1010 0011 0010 1111 0001 0001 1100 0010
P   : 11100000 11010010 01110010 01000101
L[i]: 00111100 11110000 00111100 00001111
R[i]: 10111010 11010010 00101000 01000101
Round 2
E   :  110111 110101 011010 100100 000101 010000 001000 001011
KS  :  001010 110001 101001 110100 110010 100100 100011 011000
E xor KS:  111101 000100 110011 010000 110111 110100 101011 010011
Sbox:  0110 1000 1111 0001 1001 0100 0100 0101
P   : 10100101 00011001 10001011 00101100
L[i]: 10111010 11010010 00101000 01000101
R[i]: 10011001 11101001 10110111 00100011
Round 3
E   :  110011 110011 111101 010011 110110 101110 100100 000111
KS  :  100011 000111 100011 011000 100000 011101 001100 011101
E xor KS:  010000 110100 011110 001011 010110 110011 101000 011010
Sbox:  0011 1100 1000 1111 1111 1110 1100 0000
P   : 10110001 01111100 00010011 11011011
L[i]: 10011001 11101001 10110111 00100011
R[i]: 00001011 10101110 00111011 10011110
Round 4
E   :  000001 010111 110101 011100 000111 110111 110011 111100
KS  :  000101 100110 011101 111000 100100 110001 011010 100000
E xor KS:  000100 110001 101000 100100 100011 000110 101001 011100
Sbox:  1101 1011 1000 1001 1000 1111 0001 1100
P   : 11011011 10101000 11100001 01101010
L[i]: 00001011 10101110 00111011 10011110
R[i]: 01000010 01000001 01010110 01001001
Round 5
E   :  101000 000100 001000 000010 101010 101100 001001 010010
KS  :  110011 100101 110100 000001 110110 000000 101100 100101
E xor KS:  011011 100001 111100 000011 011100 101100 100101 110111
Sbox:  0101 1101 1110 1000 1110 1100 1101 0000
P   : 00010011 00011101 11000001 11011111
L[i]: 01000010 01000001 01010110 01001001
R[i]: 00011000 10110011 11111010 01000001
Round 6
E   :  100011 110001 010110 100111 111111 110100 001000 000010
KS  :  010010 111010 101101 001101 000100 100110 101010 011100
E xor KS:  110001 001011 111011 101010 111011 010010 100010 011110
Sbox:  0101 0010 0101 1011 0100 1101 0100 0111
P   : 11010100 01010111 10101000 01101010
L[i]: 00011000 10110011 11111010 01000001
R[i]: 10010110 00010110 11111110 00100011
Round 7
E   :  110010 101100 000010 101101 011111 111100 000100 000111
KS  :  000010 011111 010010 001011 011100 010011 000110 010001
E xor KS:  110000 110011 010000 100110 000011 101111 000010 010110
Sbox:  1111 0110 0001 0000 1011 1010 1011 1110
P   : 01111111 10100010 10000110 10110011
L[i]: 10010110 00010110 11111110 00100011
R[i]: 01100111 00010001 01111100 11110010
Round 8
E   :  001100 001110 100010 100010 101111 111001 011110 100100
KS  :  011100 010000 110111 101010 101000 110010 000000 101011
E xor KS:  010000 011110 010101 001000 000111 001011 011110 001111
Sbox:  0011 1010 0101 0000 1100 1100 0001 0100
P   : 01010111 00001101 00000010 00101010
L[i]: 01100111 00010001 01111100 11110010
R[i]: 11000001 00011011 11111100 00001001
Round 9
E   :  111000 000010 100011 110111 111111 111000 000001 010011
KS  :  000100 101001 101010 111000 001100 110100 011111 000011
E xor KS:  111100 101011 001001 001111 110011 001100 011110 010000
Sbox:  0101 1111 0011 0011 1111 0110 0001 1010
P   : 11101111 01101110 11000000 10011110
L[i]: 11000001 00011011 11111100 00001001
R[i]: 10001000 01111111 10111100 01101100
Round 10
E   :  010001 010000 001111 111111 110111 111000 001101 011001
KS  :  100111 000011 100001 100110 000111 101000 000100 000011
E xor KS:  110110 010011 101110 011001 110000 010000 001001 011010
Sbox:  0111 0000 0000 0001 1111 0000 0100 0000
P   : 10100001 00010100 10000010 10000010
L[i]: 10001000 01111111 10111100 01101100
R[i]: 01100000 00001111 01111110 10001011
Round 11
E   :  101100 000000 000001 011110 101111 111101 010001 010110
KS  :  101000 100110 111001 001100 110001 100110 010101 000100
E xor KS:  000100 100110 111000 010010 011110 011011 000100 010010
Sbox:  1101 1011 0101 0010 1001 1011 0010 1001
P   : 01111101 11101001 11101100 00000010
L[i]: 01100000 00001111 01111110 10001011
R[i]: 11110101 10010110 01010000 01101110
Round 12
E   :  011110 101011 110010 101100 001010 100000 001101 011101
KS  :  010010 000111 011100 100100 011010 001010 001111 001000
E xor KS:  001100 101100 101110 001000 010000 101010 000010 010101
Sbox:  1011 1101 0000 0000 1000 1000 1011 0110
P   : 00010011 10001010 01000110 00110011
L[i]: 11110101 10010110 01010000 01101110
R[i]: 01110011 10000101 00111000 10111000
Round 13
E   :  001110 100111 110000 001010 100111 110001 010111 110000
KS  :  110000 001001 110101 111001 111100 001101 010000 001011
E xor KS:  111110 101110 000101 110011 011011 111100 000111 111011
Sbox:  0000 0001 0000 0100 1001 1011 0111 0101
P   : 00110011 00110000 01111100 00100000
L[i]: 01110011 10000101 00111000 10111000
R[i]: 11000110 10100110 00101100 01001110
Round 14
E   :  011000 001101 010100 001100 000101 011000 001001 011101
KS  :  110001 011110 001001 100011 010011 100001 011000 101010
E xor KS:  101001 010011 011101 101111 010110 111001 010001 110111
Sbox:  0100 0000 1111 1000 1111 0110 1110 0000
P   : 00100101 00110101 10000101 11001101
L[i]: 11000110 10100110 00101100 01001110
R[i]: 01010110 10110000 10111101 01110101
Round 15
E   :  101010 101101 010110 100001 010111 111010 101110 101010
KS  :  101000 111101 111110 000010 100111 000111 100101 101000
E xor KS:  000010 010000 101000 100011 110000 111101 001011 000010
Sbox:  0100 1001 1000 1111 1111 1000 1001 0010
P   : 10110011 01001110 11010001 11000001
L[i]: 01010110 10110000 10111101 01110101
R[i]: 01110101 11101000 11111101 10001111
Round 16
E   :  101110 101011 111101 010001 011111 111011 110001 011110
KS  :  101001 100001 001000 001011 010011 010100 110000 100101
E xor KS:  000111 001010 110101 011010 001100 101111 000001 111011
Sbox:  0100 1011 1110 1100 1011 1010 1101 0101
P   : 01110011 00111001 11011001 11100101
L[i]: 01110101 11101000 11111101 10001111
R[i]: 00100101 10001001 01100100 10010000
LR[16]  00100101 10001001 01100100 10010000 01110101 11101000 11111101 10001111
Output  11011010 00000010 11001110 00111010 10001001 11101100 10101100 00111011
</code></pre>

<p>Output message da02ce3a89ecac3b</p>
","885","<c#><encryption><des>","2","1","3","2019-02-28 18:12:55","26811149","6","2","","","","2014-11-07 07:44:58",""
"26796439","DES Encryption is not working C#","<p>I have wrote DES in C# from scratch, and I will post the whole code here, for me it seems right but when I'm trying an example it is not. Here is my entire code.</p>

<p>Des Class:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class DES
    {
        string leftSide = """";
        string rightSide = """";
        string tempLeft = """";

        F_Function f = new F_Function();
        Key_Scheduler k = new Key_Scheduler();

        public string DESEncryption(string input, string Key)
        {
            input = String.Join(String.Empty,
  input.Select(
    c =&gt; Convert.ToString(Convert.ToInt32(c.ToString(), 16), 2).PadLeft(4, '0')
  )
);
            Key = String.Join(String.Empty,
  Key.Select(
    c =&gt; Convert.ToString(Convert.ToInt32(c.ToString(), 16), 2).PadLeft(4, '0')
  )
);
            // input = strtoBin(input);
            string chunk = """";
            string finalPerm = """";
            string result = """";
            string[] subKeys;

            //split the string into blocks of 64 bits
            IEnumerable&lt;string&gt; output = Enumerable.Range(0, input.Length / 64)
   .Select(x =&gt; input.Substring(x * 64, 64));
            string[] newInput = output.ToArray();

            //for each block 
            for (int i = 0; i &lt; newInput.Length; i++)
            {
                //Initial Permutation
                chunk = initalPermutation(newInput[i]);

                //split the chunk in two halves 32 bit each
                leftSide = chunk.Substring(0, chunk.Length / 2);
                rightSide = chunk.Substring(chunk.Length / 2, chunk.Length / 2);
                subKeys = k.keySched(Key);

                for (int j = 0; j &lt; 16; j++)
                {

                    //F Function on the right side
                    tempLeft = leftSide;
                    leftSide = rightSide;
                    rightSide = f.f_function(rightSide, subKeys[j]);
                    rightSide = XOR(tempLeft, rightSide);

                }

                finalPerm = rightSide + leftSide;
                finalPerm = finalPermutation(finalPerm);
                result = result + finalPerm;
            }
            result = BinaryStringToHexString(result);
            return result;
        }

        private string initalPermutation(string block)
        {


            char[] tempBlock ={block[57],block[49],block[41],block[33],block[25],block[17],block[9],block[1],
                             block[59],block[51],block[43],block[35],block[27],block[19],block[11],block[3],
                             block[61],block[53],block[45],block[37],block[29],block[21],block[13],block[5],
                             block[63],block[55],block[47],block[39],block[31],block[23],block[15],block[7],
                             block[56],block[48],block[40],block[32],block[24],block[16],block[8],block[0],
                             block[58],block[50],block[42],block[34],block[26],block[18],block[10],block[2],
                             block[60],block[52],block[44],block[36],block[28],block[20],block[12],block[4],
                             block[62],block[54],block[46],block[38],block[30],block[22],block[14],block[6]};
            string res = new string(tempBlock);
            return res;
        }

        private string finalPermutation(string block)
        {

            char[] tempBlock ={block[39],block[7],block[47],block[15],block[55],block[23],block[63],block[31],
                             block[38],block[6],block[46],block[14],block[54],block[22],block[62],block[30],
                             block[37],block[5],block[45],block[13],block[53],block[21],block[61],block[29],
                             block[36],block[4],block[44],block[12],block[52],block[20],block[60],block[28],
                             block[35],block[3],block[43],block[11],block[51],block[19],block[59],block[27],
                             block[34],block[2],block[42],block[10],block[50],block[18],block[58],block[26],
                             block[33],block[1],block[41],block[9],block[49],block[17],block[57],block[25],
                             block[32],block[0],block[40],block[8],block[48],block[16],block[56],block[24]};
            string res = new string(tempBlock);
            return res;
        }

        //convert string to binary function
        private string strtoBin(string input)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char L in input)
            {
                sb.Append(Convert.ToString(L, 2).PadLeft(8, '0'));

            }

            return sb.ToString();
        }

        private string XOR(string expanedArray, string key)
        {
            string[] result = new string[key.Length];
            string res;
            char[] a = expanedArray.ToCharArray();
            char[] b = key.ToCharArray();

            for (int i = 0; i &lt; key.Length; i++)
            {
                result[i] = (a[i] ^ b[i]).ToString();

            }
            res = string.Join("""", result);
            return res;
        }
        private static string BinaryStringToHexString(string binary)
        {
            StringBuilder result = new StringBuilder(binary.Length / 8 + 1);

            // TODO: check all 1's or 0's... Will throw otherwise

            int mod4Len = binary.Length % 8;
            if (mod4Len != 0)
            {
                // pad to length multiple of 8
                binary = binary.PadLeft(((binary.Length / 8) + 1) * 8, '0');
            }

            for (int i = 0; i &lt; binary.Length; i += 8)
            {
                string eightBits = binary.Substring(i, 8);
                result.AppendFormat(""{0:X2}"", Convert.ToByte(eightBits, 2));
            }

            return result.ToString();
        }

}
}
</code></pre>

<p>Key Class:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class Key_Scheduler
    {
        public static String c0 = """";
        public static String d0 = """";
        public string[] keySched(string key)
        {

                string[] keys = new string[16];
                string  perm1 = """";

                    //Permutation Choice - 1
                    perm1 = permuatedchoice1(key);

                    //split the key in two halves 28 bit each
                    c0 = perm1.Substring(0, perm1.Length / 2);
                    d0 = perm1.Substring(perm1.Length / 2, perm1.Length / 2);

                    for (int i = 0; i &lt; 16; i++)
                    {
                        keys[i] = GenerateKeys(c0, d0, i);

                    }

                    return keys;
            }

        private string GenerateKeys(string L, string R,int i)
        {
            string key;
            if (i == 0 || i == 1 || i == 8 || i == 15)
            {
                c0 = rotateShift(L, 1);
                d0 = rotateShift(R, 1);

                key = L + R;
                key = permuatedchoice2(key);
                return key;
            }

            else
            {
                c0 = rotateShift(L, 2);
                d0 = rotateShift(R, 2);

                key = L + R;
                key = permuatedchoice2(key);
                return key;
            }


        }

        private string rotateShift(string key, int shift)
        {
            string res="""";
            string[] result = new string[key.Length];
            char[] a = key.ToCharArray();
            int index = 0;
            for (int i = shift;  index &lt; a.Length; i++)
            {
                result[index++] = a[i % a.Length].ToString();
            }
            res = string.Join("""", result);
            return res;
        }
        private string permuatedchoice1(string key)
        {
            string res;
            char[] tempArr ={key[56],key[48],key[40],key[32],key[24],key[16],key[8],key[0],
                            key[57],key[49],key[41],key[33],key[25],key[17],key[9],key[1],
                            key[58],key[50],key[42],key[34],key[26],key[18],key[10],key[2],
                            key[59],key[51],key[43],key[35],key[62],key[54],key[46],key[38],
                            key[30],key[22],key[14],key[6],key[61],key[53],key[45],key[37],
                            key[29],key[21],key[13],key[5],key[60],key[52],key[44],key[36],
                            key[28],key[20],key[12],key[4],key[27],key[19],key[11],key[3]};

            res = new string(tempArr);
            return res;
        }

        private string permuatedchoice2(string key)
        {
            string res;
            char[] tempArr ={key[13],key[16],key[10],key[23],key[0],key[4],key[2],key[27],
                            key[14],key[5],key[20],key[9],key[22],key[18],key[11],key[3],
                            key[25],key[7],key[15],key[6],key[26],key[19],key[12],key[1],
                            key[40],key[51],key[30],key[36],key[46],key[54],key[29],key[39],
                            key[50],key[44],key[32],key[47],key[43],key[48],key[38],key[55],
                            key[33],key[52],key[45],key[41],key[49],key[35],key[28],key[31]};

            res = new string(tempArr);
            return res;
        }

    }
}
</code></pre>

<p>And Finally, the F Function Class: </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DES_Cipher
{
    class F_Function
    {
        #region SBoxes definition
        int[,] s1Box = {{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},
                     {0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},
                     {4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},
                     {15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}};

        int[,] s2Box = {{15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},
                       {3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},
                       {0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},
                       {13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}};

        int[,] s3Box = {{10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},
                       {13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},
                       {13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},
                       {1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}};

        int[,] s4Box = {{7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},
                       {13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},
                       {10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},
                       {3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}};

        int[,] s5Box = {{2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},
                      {14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},
                      {4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},
                      {11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}};

        int[,] s6Box = {{12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},
                      {10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},
                      {9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},
                      {4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}};

        int[,] s7Box = {{4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},
                       {13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},
                       {1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},
                       {6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}};

        int[,] s8Box = {{13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},
                       {1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},
                       {7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},
                       {2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}};
        #endregion
        int[] expanstionArr = new int[48] { 31, 0, 1, 2, 3, 4,
                                            3, 4, 5, 6, 7, 8, 
                                            7, 8, 9, 10, 11, 12,
                                            11, 12, 13, 14, 15, 16,
                                            15, 16, 17, 18, 19, 20, 
                                            19, 20, 21, 22, 23, 24,
                                            23, 24, 25, 26, 27, 28, 
                                            27, 28, 29, 30, 31, 1 };

        int[] permutationMatrix = new int[32] { 15, 6, 19, 20, 28, 11, 27, 16,
                                                0, 14, 22, 25, 4, 17, 30, 9, 
                                                1, 7, 23, 13, 31, 26, 2, 8, 
                                                18, 12, 29, 5, 21, 10, 3, 24 };

        Key_Scheduler key = new Key_Scheduler();
        public string f_function(string input, string mainKey)
        {
            string res, exp, xor, sboxsub, perm;
            exp = expansion(input);
            //subKey =key.keySched(mainKey);
            int a = mainKey.Length - exp.Length;
            xor=XORwithKey(exp,mainKey);
            sboxsub = SBoxSubstitution(xor);
            perm = permutation(sboxsub);
            res = perm;
            return res;
        }
        private string expansion (string rightSide )
        {
            char[] arr = new char[48];
            int len = rightSide.Length;

            for (int i = 0; i &lt; arr.Length; i++)
            {
                arr[i] = rightSide[expanstionArr[i]];

            }
            string res = new string(arr);
            return res;
        }
        private string XORwithKey(string expanedArray,string key)
        {
            string[] result = new string[key.Length];
            string res;
            char[] a = expanedArray.ToCharArray();
            char[] b = key.ToCharArray();

            for (int i = 0; i &lt; key.Length; i++)
            {
                result[i] = (a[i] ^ b[i]).ToString();

            }
            res = string.Join("""", result);
            return res;
        }

        private string SBoxSubstitution(string input)
        {
            string res="""";
            string r;
            int row, col, s1, s2, s3, s4, s5, s6, s7, s8;
            string c;
            char[] temp;
            IEnumerable&lt;string&gt; output = Enumerable.Range(0, input.Length / 6)
              .Select(x =&gt; input.Substring(x * 6, 6));
            string[] newInput = output.ToArray();

            for (int i = 0; i &lt; newInput.Length; i++)
            {
                temp = newInput[i].ToCharArray();
                r = temp[0].ToString()+temp[5].ToString();
                row = Convert.ToInt32(r,2);
                c = temp[1].ToString() + temp[2].ToString() + temp[3].ToString() + temp[4].ToString();
                col = Convert.ToInt32(c,2);
                if (i == 0)
                {
                    s1 = SBoxSearch(row, col, s1Box);
                    res += s1.ToString();
                }
                else if (i == 1)
                {
                    s2 = SBoxSearch(row, col, s2Box);
                    res += s2.ToString();
                }
                else if (i == 2)
                {
                    s3 = SBoxSearch(row, col, s3Box);
                    res += s3.ToString();
                }
                else if (i == 3)
                {
                    s4 = SBoxSearch(row, col, s4Box);
                    res += s4.ToString();
                }
                else if (i == 4)
                {
                    s5 = SBoxSearch(row, col, s5Box);
                    res += s5.ToString();
                }
                else if (i == 5)
                {
                    s6 = SBoxSearch(row, col, s6Box);
                    res += s6.ToString();
                }
                else if (i == 6)
                {
                    s7 = SBoxSearch(row, col, s7Box);
                    res += s7.ToString();
                }
                else
                {
                    s8 = SBoxSearch(row, col, s8Box);
                    res += s8.ToString();
                }
            }

            res = strtoBin(res);
            return res;
        }

        private string permutation(string input)
        {
            char[] arr = new char[32];

            for (int i = 0; i &lt; arr.Length; i++)
            {
                arr[i] = input[permutationMatrix[i]];

            }
            string res = new string(arr);

            return res;
        }

        private int SBoxSearch(int row, int col, int[,] sBox)
        {
            int res=0;
            for (int i = 0; i &lt; 4; i++)
            {
                if (i == row)
                {
                    for (int j = 0; j &lt; 16; j++)
                    {
                        if (j == col)
                        { 
                            res = sBox[i, j];
                            break;
                        }
                        else continue;
                    }
                    break;
                }
                else continue;
            }
            return res;
        }

        private string strtoBin(string input)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char L in input)
            {
                sb.Append(Convert.ToString(L, 2).PadLeft(8, '0'));

            }

            return sb.ToString();
        }


    }
}
</code></pre>

<p>When I'm testing it, btw all inputs are in hex, my input is:
02468aceeca86420</p>

<p>Used key is: </p>

<p>0f1571c947d9e859</p>

<p>the encryption output should be:</p>

<p>da02ce3a89ecac3b</p>

<p>But I'm getting this output instead:</p>

<p>019945B853663D50</p>

<p>I double checked everything and I really don't know what I did wrong here ... Pardon me for the messy code but it was written in less than a day :/ </p>

<p>Thank you for any tip </p>
","<p>This is almost complete code for beginner like me to start learning to use DES. How about making some corrections so everyone don't need to follow the same debugging and fixing job (or better if they do this). Some of helping links are gone but something useful is out there. I was using
<a href=""http://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm"" rel=""nofollow"">http://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm</a>
and
<a href=""http://people.eku.edu/styere/Encrypt/JS-DES.html"" rel=""nofollow"">http://people.eku.edu/styere/Encrypt/JS-DES.html</a> (with modified not readonly)</p>

<ul>
<li>first key must be the last <strong>keys[15]</strong> and every next is <strong>keys[i-1]</strong></li>
<li><strong>strtoBin</strong> is very wrong there. After discarding it there is better output directly binarray from <strong>SBoxSubstitution</strong> by forming output <strong>res</strong> like <code>res += Convert.ToString(s1, 2).PadLeft(4, '0');</code> in first <strong>if (i == 1)</strong> and so on</li>
<li>last number in <strong>expanstionArr</strong> must be 0 of course</li>
</ul>

<p>After those 3 modifications I got the <strong>DESEncryption</strong> working.</p>

<p>And what you know... decrypting is working too without any other repair :) For that you copy whole <strong>DESEncryption</strong> to <strong>""DESDecryption""</strong> and change only <code>(int j = 0; j &lt; 16; j++)</code> to <code>for (int j = 15; j &gt;= 0; j--)</code></p>
","885","<c#><encryption><des>","2","0","3","2019-02-28 18:12:55","26811149","6","2","","","","2014-11-07 07:44:58",""
"15534982","Which iteration rules apply on crypt() using CRYPT_EXT_DES?","<p>My testcase as follows:</p>

<pre><code>echo crypt('string', '_....salt');//error
echo crypt('string', '_A...salt');//fast
echo crypt('string', '_AAAAsalt');//slow
</code></pre>

<p>Explanation as stated at <a href=""http://www.php.net/manual/en/function.crypt.php"" rel=""nofollow"">http://www.php.net/manual/en/function.crypt.php</a>:</p>

<blockquote>
  <p>CRYPT_EXT_DES - Extended DES-based hash. The ""salt"" is a 9-character
  string consisting of an underscore followed by 4 bytes of iteration
  count and 4 bytes of salt. These are encoded as printable characters,
  6 bits per character, least significant character first. The values 0
  to 63 are encoded as ""./0-9A-Za-z"". Using invalid characters in the
  salt will cause crypt() to fail.</p>
</blockquote>

<p>A dot is a printable character so why does it return an error? And which ""order"" applies on the used characters resulting ""AAAA"" more iterations than ""A...""?</p>
","<p>It says all in the quoted paragraph:
 - least significant character first
 - The values 0 to 63 are encoded as ""./0-9A-Za-z""</p>

<p>So in your example ""_....salt"" would mean 0 rounds which obviously can't work.
and ""_A...salt"" is less than ""_AAAAsalt"" considering the least significant character comes first.</p>

<p>""_...Asalt"" would also be more than ""_A...salt""</p>
","884","<php><des><crypt>","4","1","4","2017-12-11 17:18:54","16124304","0","","","","","2013-03-20 21:21:49",""
"15534982","Which iteration rules apply on crypt() using CRYPT_EXT_DES?","<p>My testcase as follows:</p>

<pre><code>echo crypt('string', '_....salt');//error
echo crypt('string', '_A...salt');//fast
echo crypt('string', '_AAAAsalt');//slow
</code></pre>

<p>Explanation as stated at <a href=""http://www.php.net/manual/en/function.crypt.php"" rel=""nofollow"">http://www.php.net/manual/en/function.crypt.php</a>:</p>

<blockquote>
  <p>CRYPT_EXT_DES - Extended DES-based hash. The ""salt"" is a 9-character
  string consisting of an underscore followed by 4 bytes of iteration
  count and 4 bytes of salt. These are encoded as printable characters,
  6 bits per character, least significant character first. The values 0
  to 63 are encoded as ""./0-9A-Za-z"". Using invalid characters in the
  salt will cause crypt() to fail.</p>
</blockquote>

<p>A dot is a printable character so why does it return an error? And which ""order"" applies on the used characters resulting ""AAAA"" more iterations than ""A...""?</p>
","<p>This question is a bit old, however i found this when trying to wrap my head around how to create a hashing class for internal use here, and i came up with this little function which will base64 encode an integer with the appropriate characters/significance to be used as the 4 character 'iteration count'. Possible values are from 1 to 16,777,215</p>

<pre><code>private function base64_int_encode($num){
    $alphabet_raw = ""./0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    $alphabet = str_split($alphabet_raw);
    $arr = array();
    $base = sizeof($alphabet);
    while($num){
        $rem = $num % $base;
        $num = (int)($num / $base);
        $arr[]=$alphabet[$rem];
    }

    $arr = array_reverse($arr);
    $string = implode($arr);

    return str_pad($string, 4, '.', STR_PAD_LEFT);
}
</code></pre>

<p>Hope it helps someone!</p>
","884","<php><des><crypt>","4","1","4","2017-12-11 17:18:54","16124304","0","","","","","2013-03-20 21:21:49",""
"15534982","Which iteration rules apply on crypt() using CRYPT_EXT_DES?","<p>My testcase as follows:</p>

<pre><code>echo crypt('string', '_....salt');//error
echo crypt('string', '_A...salt');//fast
echo crypt('string', '_AAAAsalt');//slow
</code></pre>

<p>Explanation as stated at <a href=""http://www.php.net/manual/en/function.crypt.php"" rel=""nofollow"">http://www.php.net/manual/en/function.crypt.php</a>:</p>

<blockquote>
  <p>CRYPT_EXT_DES - Extended DES-based hash. The ""salt"" is a 9-character
  string consisting of an underscore followed by 4 bytes of iteration
  count and 4 bytes of salt. These are encoded as printable characters,
  6 bits per character, least significant character first. The values 0
  to 63 are encoded as ""./0-9A-Za-z"". Using invalid characters in the
  salt will cause crypt() to fail.</p>
</blockquote>

<p>A dot is a printable character so why does it return an error? And which ""order"" applies on the used characters resulting ""AAAA"" more iterations than ""A...""?</p>
","<p>The code of Klathmon is nice but has some mistakes:</p>

<p><strong>First - alphabet</strong></p>

<pre><code>It is:
./0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
Should be:
./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
</code></pre>

<p><strong>Second - order of characters/digits</strong></p>

<pre><code>It generates for example: ...z
But it should generate: z...
</code></pre>

<p><strong>The improved code:</strong></p>

<pre><code>function base64_int_encode($num) {
  $alphabet_raw='./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  $alphabet=str_split($alphabet_raw);
  $arr=array();
  $base=sizeof($alphabet);
  while($num) {
    $rem=$num % $base;
    $num=(int)($num / $base);
    $arr[]=$alphabet[$rem];
  }

  $string=implode($arr);

  return str_pad($string, 4, '.', STR_PAD_RIGHT);
}
</code></pre>
","884","<php><des><crypt>","4","0","4","2017-12-11 17:18:54","16124304","0","","","","","2013-03-20 21:21:49",""
"15534982","Which iteration rules apply on crypt() using CRYPT_EXT_DES?","<p>My testcase as follows:</p>

<pre><code>echo crypt('string', '_....salt');//error
echo crypt('string', '_A...salt');//fast
echo crypt('string', '_AAAAsalt');//slow
</code></pre>

<p>Explanation as stated at <a href=""http://www.php.net/manual/en/function.crypt.php"" rel=""nofollow"">http://www.php.net/manual/en/function.crypt.php</a>:</p>

<blockquote>
  <p>CRYPT_EXT_DES - Extended DES-based hash. The ""salt"" is a 9-character
  string consisting of an underscore followed by 4 bytes of iteration
  count and 4 bytes of salt. These are encoded as printable characters,
  6 bits per character, least significant character first. The values 0
  to 63 are encoded as ""./0-9A-Za-z"". Using invalid characters in the
  salt will cause crypt() to fail.</p>
</blockquote>

<p>A dot is a printable character so why does it return an error? And which ""order"" applies on the used characters resulting ""AAAA"" more iterations than ""A...""?</p>
","<p>A number system used in Extended DES:</p>

<pre><code>.... - 0 (Extended DES error)
/... - 1
0... - 2
1... - 3
2... - 4
3... - 5
4... - 6
5... - 7
6... - 8
7... - 9
8... - 10

z... - 63
./.. - 64
//.. - 65
0/.. - 66
1/.. - 67

Y/.. - 100
61.. - 200
g2.. - 300
E4.. - 400
o5.. - 500
M7.. - 600
w8.. - 700
UA.. - 800
2C.. - 900
cD.. - 1000

zz.. - 4095
../. - 4096
/./. - 4097
0./. - 4098
1./. - 4099

xzzz - 16 777 213
yzzz - 16 777 214
zzzz - 16 777 215
</code></pre>

<p>And in connection with salt:</p>

<pre><code>_/...salt - 1
_0...salt - 2
_1...salt - 3
_2...salt - 4
_3...salt - 5
_4...salt - 6
_5...salt - 7
_6...salt - 8
_7...salt - 9
_8...salt - 10

_z...salt - 63
_./..salt - 64
_//..salt - 65
_0/..salt - 66
_1/..salt - 67

_Y/..salt - 100
_61..salt - 200
_g2..salt - 300
_E4..salt - 400
_o5..salt - 500
_M7..salt - 600
_w8..salt - 700
_UA..salt - 800
_2C..salt - 900
_cD..salt - 1000

_zz..salt - 4095
_../.salt - 4096
_/./.salt - 4097
_0./.salt - 4098
_1./.salt - 4099

_xzzzsalt - 16 777 213
_yzzzsalt - 16 777 214
_zzzzsalt - 16 777 215
</code></pre>
","884","<php><des><crypt>","4","0","4","2017-12-11 17:18:54","16124304","0","","","","","2013-03-20 21:21:49",""
"40015660","DES ECB encryption with PHP","<p><a href=""https://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow"">https://www.tools4noobs.com/online_tools/encrypt/</a> gives ""a67a318c98a0307502ba81caade2f3a9"" as a DES ECB result for the key ""1234567890abcdef"" and payload ""encrypt this"".</p>

<p>The PHP code</p>

<pre><code>echo bin2hex(mcrypt_encrypt(
    MCRYPT_DES,
    hex2bin(""1234567890abcdef""),
    ""encrypt this"",
    MCRYPT_MODE_ECB)) . ""\n"";
</code></pre>

<p>prints out ""1a29ee87f2ad67644ff28450c676a664"".</p>

<p>What's wrong with the code?</p>
","<p>The <em>noobs4tools</em> website strips out the <code>hex2bin</code> function and truncates the key length to 8 characters(as Yoshi stated in comments).</p>

<p>With a keysize of <code>12345678</code> the output of both the website and the PHP code is consistent. </p>

<p>The DES keysize is stated in the manual as being 56 bits. Read below some useful background on DES specific keysizes.</p>

<p><a href=""https://stackoverflow.com/q/965500/3536236"">How should I create my DES key? Why is an 7-character string not enough?</a>  </p>

<p>Key Used by the <em>noobs4tools</em> website:</p>

<pre><code>""12345678""
</code></pre>

<p>Key Used by your code:</p>

<pre><code> hex2bin(""1234567890abcdef""); // 4Vx����
</code></pre>

<p>This difference then gives you the different outputs.</p>

<p>So the website does not translate the <em>key</em> into any other number- or data- form. It expects you to provide an already correctly formatted value in the page script.  </p>
","878","<php><encryption><des><ecb>","3","2","1","2016-10-13 19:09:25","40016221","1","","1816580","","2016-10-13 19:09:25","2016-10-13 08:14:27",""
"7715932","Getting ""Bad Data"" exception on DES decrypt in .NET","<p>In C#.NET, I want to decrypt some data that has been encrypted by DES algorithm before, and just have a key but no IV!
I get exception when reading from stream.
what should i write? here is my code:</p>

<pre><code>byte[] byaText = new byte[] { 0x91, 0x6e , 0x6e , 0x75, 0x76 , 0xa5 , 0x73 , 0x55 };
byte[] byaKey = new byte[] { 0x9B, 0x43, 0xBF, 0x66, 0x98, 0xDE, 0x67, 0xFB };
DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
cryptoProvider.Mode = CipherMode.ECB; // even when remarking this line exception occures
MemoryStream memoryStream = new MemoryStream(byaRes);
ICryptoTransform ict = cryptoProvider.CreateDecryptor(byaKey, byaKey); // even ""new byte[] {0,0,0,0,0,0,0,0}"" as IV, exception occures
CryptoStream cryptoStream = new CryptoStream(memoryStream,
    ict, CryptoStreamMode.Read);
StreamReader reader = new StreamReader(cryptoStream);
string decrypted = reader.ReadToEnd(); // here the exception 'Bad Data' occures
</code></pre>
","<p>You may have a padding exception. Check what padding the sender is using, possibly PKCS5, and ensure that your decrypt function is expecting the same padding.</p>

<p>ECB mode is not secure.  If at all possible change to CBC mode of CTR mode.  There is a good illustration (literally) of why ECB mode is insecure on Wikipedia: <a href=""http://en.wikipedia.org/wiki/Encryption_mode#Electronic_codebook_.28ECB.29"" rel=""nofollow"">Electronic codebook (ECB)</a></p>
","858","<.net><encryption><des>","0","0","1","2011-10-10 16:58:32","","3","","","","","2011-10-10 16:37:29",""
"20154596","Triple DES initialization vector","<p>I have a working code to generate encrypt data using php:</p>

<pre><code>$cipher_alg = MCRYPT_TRIPLEDES;
$iv = mcrypt_create_iv(mcrypt_get_iv_size($cipher_alg,MCRYPT_MODE_ECB), MCRYPT_RAND); 
$encrypted_string = mcrypt_encrypt($cipher_alg, $pKey, $string, MCRYPT_MODE_ECB, $iv); 
</code></pre>

<p>Question is, I run this code multiple time, if the same inputs and always give me the same output for <code>$encrypted_string</code> and a different output for <code>$iv</code>. 
So why my encrypt data is always the same if the IV changes?</p>

<p>Thanks in advanced.</p>
","<p><a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29"" rel=""nofollow"">ECB mode</a> does not use an IV, so it doesn't matter what you pass in or that it's different every time. The documentation for <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow""><code>mcrypt_encrypt</code></a> itself indirectly says so:</p>

<blockquote>
  <p><strong><code>iv</code></strong></p>
  
  <p>Used for the initialization in CBC, CFB, OFB modes, and in some algorithms in STREAM mode. If you do not supply an IV, while it is
  needed for an algorithm, the function issues a warning and uses an IV
  with all its bytes set to ""\0"".</p>
</blockquote>

<p>You would need to use a chainable mode (CBC etc) to see different results on each iteration -- and in general, ECB mode is a very bad choice. Don't use it.</p>
","843","<php><aes><des><tripledes>","0","1","1","2013-11-22 21:15:40","20154629","0","1","","","","2013-11-22 21:13:21",""
"43132393","Why the same result both DES Encrypt and DESede Encrypt?","<p>I'm try to be compatible Encrypt/Decrypt both C# and Java.</p>

<p>As I know the default mode is 'ecb/pkcs5' in Java, and 'cbc/pkcs7' in C#.</p>

<p>So I match these things.</p>

<p><strong>1st question is that PKCS7 and PKCS5 are compatible each other??</strong>, </p>

<p>there is no PKCS7 in Java so I use PKCS5. but I can get same encrypted data [even the padding-way is different ,pkcs7/pkcs5,] Is it possible? or these are compatible?</p>

<p><strong>2nd question is that Why I get same result even though the mode, way are all different?</strong></p>

<p>I compare 'DES-ECB / DES-CBC / TripleDES-ECB' these things. and C# is working well, results are all different.</p>

<p>Input > HELLO Output > (ECB)/dZf3gUY150=  (CBC) V17s5QLzynM= (Triple)sWGS0GMe1jE</p>

<p>but I get same reulst in Java ..</p>

<p>Input > HELLO Output > (ECB)/dZf3gUY150= (CBC)/dZf3gUY150= (Triple)/dZf3gUY150=</p>

<p>When debugging the flow is right.</p>

<p>Here is my code.</p>

<p><strong>C#</strong></p>

<pre><code>public static string Encrypt_DES(string originalString, byte[] key, string mode)
    {
        DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();

        if (mode.Equals(""ECB""))
            cryptoProvider.Mode = CipherMode.ECB;
        else if (mode.Equals(""CBC""))
        {
            cryptoProvider.Mode = CipherMode.CBC;
            cryptoProvider.IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 };
        }

        cryptoProvider.Padding = PaddingMode.PKCS7;
        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateEncryptor(key, key), CryptoStreamMode.Write);
        StreamWriter writer = new StreamWriter(cryptoStream);
        writer.Write(originalString);
        writer.Flush();
        cryptoStream.FlushFinalBlock();
        writer.Flush();
        return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
    }

public static string Encrypt_TripleDES(string source, string key)
    {
        TripleDESCryptoServiceProvider desCryptoProvider = new TripleDESCryptoServiceProvider();
        MD5CryptoServiceProvider hashMD5Provider = new MD5CryptoServiceProvider();

        byte[] byteHash;
        byte[] byteBuff;

        byteHash = hashMD5Provider.ComputeHash(Encoding.UTF8.GetBytes(key));
        desCryptoProvider.Key = byteHash;
        desCryptoProvider.Mode = CipherMode.ECB; //CBC, CFB
        desCryptoProvider.Padding = PaddingMode.PKCS7;
        byteBuff = Encoding.UTF8.GetBytes(source);

        string encoded = Convert.ToBase64String(desCryptoProvider.CreateEncryptor().TransformFinalBlock(byteBuff, 0, byteBuff.Length));
        return encoded;
    }
</code></pre>

<p><strong>Java(Android)</strong></p>

<pre><code>public String Encrypt(String str, String desKey, String mode) {
    try {
        KeySpec keySpec = null;
        SecretKey key = null;
        Cipher ecipher = null;
        if (desKey.length() == 8) {
            keySpec = new DESKeySpec(desKey.getBytes(""UTF8""));
            key = SecretKeyFactory.getInstance(""DES"").generateSecret(keySpec);
            if(mode.equals(ECB)){
                ecipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
                ecipher.init(Cipher.ENCRYPT_MODE, key);
            }else if (mode.equals(CBC)){
                ecipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
                AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
                ecipher.init(Cipher.ENCRYPT_MODE, key,ivSpec);
            }
        } else if (desKey.length() == 24) {
            keySpec = new DESedeKeySpec(desKey.getBytes(""UTF8""));
            key = SecretKeyFactory.getInstance(""DESede"").generateSecret(keySpec);
            ecipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
            ecipher.init(Cipher.ENCRYPT_MODE, key);
        }

        byte[] data = str.getBytes(""UTF-8"");
        byte[] crypt = ecipher.doFinal(data);

        return Base64.encodeToString(crypt, 0);
    } catch (Exception ex) {
        Log.d(""ZVM"", ex.getMessage());
    }
    return null;
}
</code></pre>

<ul>
<li>As I understand 'IV' is for CBC, When making password, it is mixed with IV(not the key but like key). Is it right? </li>
</ul>

<p>Thanks.</p>
","<blockquote>
  <p>PKCS7 and PKCS5 are compatible each other</p>
</blockquote>

<p>PKCS#5 and PKCS#7 paddings are compatible (equal) for DES. For AES, Java actually uses PKCS#7 padding even though you would write <code>AES/xyz/PKCS5Padding</code>.</p>

<blockquote>
  <p>Why I get same result even though the mode, way are all different?</p>
</blockquote>

<p>First, let's see how Java behaves. The ciphertexts for DES-ECB, DES-CBC and DESede-ECB are all equal. This is correct <strong>if</strong> </p>

<ol>
<li>the key is the same (DES supports only 8 byte keys, but Triple DES supports 8, 16 and 24 byte keys where non-24 byte keys are expanded to 24 byte keys), </li>
<li>the plaintext is the same,</li>
<li>the plaintext is less than 8 bytes long (block size of DES/Triple DES) and</li>
<li>the IV is an all 0x00 bytes IV.</li>
</ol>

<p>Those are all true in the Java code. If you have trouble grasping that, combine the encryption routines for the <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">ECB and CBC modes of operation</a>. </p>

<p>The result of Triple DES might be a bit confusing. I <em>assume</em> that you've taken your 8 byte key for DES and replicated it either twice or thrice for use in Triple DES. This is an issue, because Triple DES encryption consists of three steps of normal DES: EDE means Encryption + Decryption + Encryption. If all the three subkeys are the same, the one of the Encryption steps cancels out with the Decryption step and the whole thing is equivalent to a single DES encryption.</p>

<p>Let's see why C# behaves differently:</p>

<p>The ciphertext from DES-CBC is different from DES-ECB, because the IV is not an all 0x00 bytes IV. <code>cryptoProvider.CreateEncryptor(key, key)</code> creates an Encryptor with the IV set to <code>key</code> (the second argument). That's not what you want. Just use <code>cryptoProvider.CreateEncryptor()</code> instead.</p>

<p>The ciphertext from DESede-ECB is different from DES-ECB, because you're running the key through a hash function. The key is therefore different.</p>

<hr>

<p><strong>Don't use DES nowadays.</strong> It only provides 56 bit of security. AES would be a much better, because it's more secure with the lowest key size of 128 bit. There is also a practical limit on the maximum ciphertext size with DES. See <a href=""https://security.stackexchange.com/q/26179/45523"">Security comparison of 3DES and AES</a>.</p>
","839","<java><c#><android><encryption><des>","1","2","1","2017-04-01 17:07:27","43159714","4","2","7526629","","2017-03-31 08:24:45","2017-03-31 04:19:28",""
"5475717","56 bit encryption in iPhone app to avoid export limitations by BIS","<p>I need a push in the right direction - preferably with code samples/links - for how to encrypt an NSString using DES encryption algorithm. Knowing that it is not that secure, but a possible candidate for avoiding to file a CCATS.
Could commoncrypt be the solution?
Or would using the key chain or sqlcypher be able to provide encryption and avoid the CCATS paper work.</p>

<p>In my app, i dont see any issue with 56 bit security and i dont assume any issue with a symmetric key solution.</p>

<p>In short: 
I can't find any good example of how to use <strong>56bit DES symmetric</strong> encryption for my ios 4.2 app (This is to avoid the CCATS hassle)</p>
","<p>Why don't you use the <a href=""https://developer.apple.com/library/ios/#documentation/Security/Conceptual/Security_Overview/Introduction/Introduction.html"" rel=""nofollow"">Security.framework</a>?</p>
","835","<iphone><xcode><encryption><des>","0","4","1","2011-04-09 09:42:50","5475781","0","","619856","","2011-04-09 09:42:50","2011-03-29 16:21:12",""
"41490851","Golang: How do I encrypt plain text that is 5 characters long with DES and CBC?","<p>Currently trying to encrypt plaintext that is 5 characters long into a 12 character encrypted string. I want to be able to specify a unique IV (not randomly generated), a unique key, and use DES. My current <a href=""https://play.golang.org/p/2JfiwG8gOF"" rel=""nofollow noreferrer"">code</a> requires the plaintext to be 8 characters long (5 character name plus 3 spaces). </p>
","<p>I have already faced this problem. This is because of padding issue. The code you wanted is a</p>

<p><a href=""https://play.golang.org/p/B9J123SCUz"" rel=""nofollow noreferrer"">Code link</a> You Can test it at go playground.</p>

<pre><code>  package main

  import (
    ""crypto/cipher""
    ""crypto/des""
    ""encoding/base64""
    ""fmt""
    ""bytes""
  )

  func main() {
    originalText := ""yolan""
    fmt.Println(originalText)

    key := []byte{0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC}

    // encrypt value to base64
    cryptoText := encrypt(key, originalText)
    fmt.Println(cryptoText)

  }

  // encrypt string to base64 crypto using des
  func encrypt(key []byte, text string) string {
    plaintext := []byte(text)

    block, err := des.NewCipher(key)
    if err != nil {
        panic(err)
    }

    iv := []byte{0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC}

    blockSize := block.BlockSize()
    origData := PKCS5Padding(plaintext, blockSize)
    blockMode := cipher.NewCBCEncrypter(block, iv)
    cryted := make([]byte, len(origData))
    blockMode.CryptBlocks(cryted, origData)

    return base64.URLEncoding.EncodeToString(cryted)
  }

  func PKCS5Padding(src []byte, blockSize int) []byte {
    padding := blockSize - len(src)%blockSize
    padtext := bytes.Repeat([]byte{byte(padding)}, padding)
    return append(src, padtext...)
  }

  func PKCS5UnPadding(src []byte) []byte {
    length := len(src)
    unpadding := int(src[length-1])
    return src[:(length - unpadding)]
  }
</code></pre>
","822","<go><base64><des><cbc-mode>","0","1","1","2017-01-06 05:43:29","41499640","5","3","","","","2017-01-05 17:11:51",""
"3950486","how to load an rsa privated key encrypted with des in java","<p>in my job i was assigned a task in which i have to programmatically load a private and public keys from files and then store them in a .jks file,the private key was generated using openssl, its an rsa des encrypted key in der format,i have no problem loading the public key, however,i haven't found a way to load the private key in its original form, the only way i found consist in decrypt the key and then convert it to a pk8 file, its  there any other way to do it without decrypting the private key?</p>
","<p>OpenSSL's standard way to save keys is to use PEM format (PEM header and footer and base64-encoded DER key inside). Private key is additionally encrypted (encryption algorithm is specified in header). JKS doesn't use DER for encryption of the private key, so you can't just take the encrypted DER sequence and put it to JKS. To add the keypair to JKS you need to get both public and private key in DER format and the private key must be decrypted.</p>
","820","<java><rsa><keystore><des><jks>","0","0","1","2010-10-16 20:26:13","3950634","0","","","","","2010-10-16 19:47:06",""
"19391556","Python Crypto\Cipher\_DES.pyc DLL load failed, how can I tell whic DLL?","<p>I am building a python application using the <a href=""http://ftp.dlitz.net/pub/dlitz/crypto/pycrypto/pycrypto-2.6.tar.gz"" rel=""nofollow"">http://ftp.dlitz.net/pub/dlitz/crypto/pycrypto/pycrypto-2.6.tar.gz</a> package, building it as a 32 bit application on a Windows 7 64-bit platform using MS Visual Studio 2010, and am exporting it as an executable using py2exe.
The executable runs fine on my Windows 7 platform.  However, when I try to run it on Windows Server 2008, I get the following error:</p>

<p>Traceback (most recent call last):</p>

<ul>
<li>File ""Crypto\Cipher\DES.pyc"", line 54, in </li>
<li>File ""Crypto\Cipher_DES.pyc"", line 12, in </li>
<li>File ""Crypto\Cipher_DES.pyc"", line 10, in __load</li>
</ul>

<p>ImportError: DLL load failed: The specified module could not be found.</p>

<p>The first problem that I want to overcome is that the pycrypto package does not include uncompiled python for _DES.pyc, so I have no idea what module it is trying to load.  Is there any way to find this out?  Note that if I comment out the calls to the Crypto routines, it also works fine, except that the functionality I want is missing :-)</p>
","<p>The solution to my problem was to use pyDes instead, a pure python encryption package available at <a href=""http://twhiteman.netfirms.com/des.html"" rel=""nofollow"">http://twhiteman.netfirms.com/des.html</a>.</p>
","810","<python><dll><des><pycrypto>","1","0","1","2013-10-16 17:32:34","","1","","","user2625787","2013-10-15 22:10:28","2013-10-15 21:36:29",""
"28350390","How do I play a DES encrypted File using ExoPlayer","<p>I am using ExoPlayer to play Media files(mp4s .h264 encoded) from the SD card of a device.  Some of the files are DES encrypted.  I can decrypt the files and get back an inputStream, but then I am unsure of how to play this inputStream using ExoPlayer.  Any help would be appreciated.  </p>

<pre><code>protected void playVideo(File file) {
        InputStream is;
        if (file.getName().endsWith("".DES"")) {
            is = FileManager.decryptFile(file);
            //what to do with this input stream?
        }

        Uri uri = Uri.parse(file.getAbsolutePath());

        if (mPlayer != null) {
            mPlayer.release();
        }

        mPlayer = new VideoPlayer(getRendererBuilder(uri));
        mPlayer.addListener(this);
        if (mLastPosition &gt; 0) {
            mPlayer.seekTo(mLastPosition);
        }

        mPlayer.prepare();
        mPlayer.setSurface(mSurface);
        mPlayer.setPlayWhenReady(true);
    }
</code></pre>
","<p>You can write a custom DataSource that accepts an InputStream: for DataSource, you just implement open(DataSpec), close(), and read(byte[] buffer, int offset, int readLength). What astonishes me is that there doesn't seem to be any implementation already available in ExoPlayer. It would seem like an obvious blade for their swiss army knife.</p>
","808","<java><android><encryption><des>","6","1","1","2015-12-11 11:37:16","34222677","2","2","","","","2015-02-05 17:30:55",""
"10748798","Decrypt the url in python which is encoded in java using DES","<p>i got it.... :)</p>

<pre><code>In Python 


    from Crypto.Cipher import DES
    from datetime import datetime, timedelta
    import sys
    import re
    import base64

    #used for decryting the cipher text
    def parseToken(str):
      cipher = DES.new('oldhouse',DES.MODE_CFB, 'houseold')
      resolved=cipher.decrypt(base64.b64decode(str))
      return resolved
</code></pre>

<p>In java</p>

<pre><code>    protected String encrypt(String token) throws Exception {
            // Instantiate the cipher
            final SecretKeySpec key = new SecretKeySpec(""oldhouse"".getBytes(""ISO-8859-1""), ""DES"");
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(""houseold"".getBytes());

    //function used to encrypt
    protected String encrypt(String token) throws Exception {
            // Instantiate the cipher
            final SecretKeySpec key = new SecretKeySpec(""oldhouse"".getBytes(""ISO-8859-1""), ""DES"");
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(""houseold"".getBytes());

            Cipher cipher = Cipher.getInstance(""DES/CFB8/NoPadding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            byte[] binaryData = cipher.doFinal(token.getBytes(""ISO-8859-1""));

            return new String(org.apache.commons.codec.binary.Base64.encodeBase64(binaryData), ""ISO-8859-1"");

        }
</code></pre>

<p>try this u will get.....</p>
","<blockquote>
  <p>Is it possible with out giving the encryption key we can get the actual data?</p>
</blockquote>

<p>I suspect that if you could, that would defeat the purpose of encryption.  To put that a different way.  If you can find a way to do it, you'd have determined the encryption algorithm was easily crackable, and therefore useless.</p>
","792","<java><python><security><encryption><des>","-3","1","1","2012-05-25 11:29:41","","4","2","238704","","2012-05-25 11:29:41","2012-05-25 05:15:12","2012-05-25 13:12:33"
"38772211","C++ Des encryption with 16 bytes key","<p>I'm trying to encrypt in DES a text with dynamic length with a 16 bytes key, but there is a problem with the block size of the key and text, i'm using openssl library for DES encryption. How can I use keys with 16 bytes of length.</p>

<p>Here my example:</p>

<pre><code>char * Encrypt( char Key, char *Msg, int size) { 
      static char*    Res;
      DES_cblock      Key2;
      DES_key_schedule schedule;

      Res = ( char * ) malloc( size );

      memcpy(Key2, Key, 8);
      DES_set_odd_parity( &amp;Key2 );
      DES_set_key_checked( &amp;Key2, &amp;schedule );

      unsigned char buf[9];    
      buf[8] = 0;

      DES_ecb_encrypt(( DES_cblock  ) &amp;Msg, ( DES_cblock  ) &amp;buf, &amp;schedule, DES_ENCRYPT );    
      memcpy(Res, buf, sizeof(buf));    
      return (Res);
}

int main(int argc, char const *argv[]) {
      char key[] = ""password"";
      char clear[] = ""This is a secret message"";
      char *encrypted;

      encrypted = (char *) malloc(sizeof(clear));

      printf(""Clear text\t : %s \n"",clear); 

      memcpy(encrypted, Encrypt(key, clear, sizeof(clear)), sizeof(clear));

      printf(""Encrypted text\t : %s \n"",encrypted);
      return 0;
}
</code></pre>
","<ol>
<li><p>DES has a 8-byte 56-bit key (the LSB is not used as part of the key, it is for parity) so you can't use a 16-byte key (parity is generally ignored).</p></li>
<li><p>Don't use DES, it is not secure and has been replaced with AES.</p></li>
<li><p>Don't use ECB mode, it is insecure, see <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29"" rel=""nofollow"">ECB mode</a>, scroll down to the Penguin.</p></li>
</ol>

<p>AES allows 128, 192 and 256 bit keys.</p>
","785","<c++><des>","2","4","1","2016-08-04 16:10:24","38772450","5","","440558","","2016-08-04 16:00:38","2016-08-04 15:59:37",""
"8328759","IPHONE Objective-C program using OPENSSL perform DES Encryption","<p>I have found an example about OPENSSL DES, when I applied this example into Objective-C program, the decrypted text was not equal to what I have input.</p>

<p>textField.text is the input textbox</p>

<p>Can anyone help me? Many thanks!!!</p>

<p>for e.g, </p>

<pre><code>     when I input ""test"", the decrypted text =""test&amp;\264""    
     when I input ""Enter an Text here"", the decrypted text =""Ente""    
     when I input ""1234567890"", the decrypted text =""1234h&amp;\311""         
//ENCRYPTION
char* desen(char *clear, int size)    
{
    printf(""Encrypted text\t  %s \n"",clear);    
    char *encrypted;    
    char key[]=""password"";    
    encrypted=(char*)malloc(sizeof(clear));    
    static char*    Res;    
    int             n=0;    
    DES_cblock      Key2;    
    DES_key_schedule schedule;    

    Res = ( char * ) malloc( sizeof(clear) );    
    // Prepare the key for use with DES_cfb64_encrypt /    

    memcpy( Key2, key,8);    
    DES_set_odd_parity( &amp;Key2 );    
    DES_set_key_checked( &amp;Key2, &amp;schedule );    


    // Encryption occurs here /    
    DES_cfb64_encrypt( ( unsigned char * ) clear, ( unsigned char * ) Res,    
      sizeof(clear), &amp;schedule, &amp;Key2, &amp;n, DES_ENCRYPT );    

    memcpy(encrypted,Res, sizeof(clear));    
    printf(""Key:%s\n"",encrypted);    
    return encrypted;    
}     
//------------------------------------------------    
//DECRYPTION-------------------------------    
char* desde(char *clear, int size)    
{    
    char *decrypted;    
    char key[]=""password"";    
    decrypted=(char*)malloc(sizeof(clear));    

    static char* Res;    
    int n=0;    
    DES_cblock Key2;    
    DES_key_schedule schedule;    
    Res = ( char * ) malloc( sizeof(clear) );    
    // Prepare the key for use with DES_cfb64_encrypt /    
    memcpy( Key2, key,8);    
    DES_set_odd_parity( &amp;Key2 );    
    DES_set_key_checked( &amp;Key2, &amp;schedule );    

    // Encryption occurs here /    
    DES_cfb64_encrypt( ( unsigned char * ) clear, ( unsigned char * ) Res,    
      sizeof(clear), &amp;schedule, &amp;Key2, &amp;n, DES_DECRYPT );    

    memcpy(decrypted,Res, sizeof(clear));    

    printf(""Key:%s\n"",decrypted);    
    return decrypted;    
}    
    //------------------------------------------------    
    //----------Button------------------------------    
- (IBAction)calculateDES_ENCRYPT:(id)sender    
{    

    char key[]=""password"";    
    char *en;    
    char *de;    
    NSString *string =  textField.text;    
    const char *temp=[string fileSystemRepresentation];    
    int len=strlen(temp);    
    char clear[len+1];    
    //char clear[50];    
    strcpy(clear,temp);    

    en=desen( clear,len+1);    
    de= desde(en, len+1);    
}    
------------------------------------------------    
</code></pre>
","<p>This line</p>

<pre><code>encrypted=(char*)malloc(sizeof(clear));  
</code></pre>

<p>doesn't do what you think.  On a 32 bit system, sizeof(clear) will be 4 because it is the size of the pointer, not the length of the data pointed to.  So you are probably only encrypting/decrypting 4 bytes and you are printing out those 4 bytes plus some garbage. </p>
","772","<iphone><objective-c><openssl><des>","0","0","1","2011-11-30 16:23:27","","1","","","","","2011-11-30 15:49:17",""
"29741887","What should I do first? Decrypt or Decompress? Python","<p>I'm trying to decrypt Bloomberg data files that I know are DES encrypted.</p>

<p><code>FileName = 'comdty_option_namr.out.gz.enc'</code></p>

<p>What is the right order to do things: Open the file and decompress and then decrypt or vice-versa?</p>
","<p>Well, it all depends on the way the file was transformed, and there are two possible ways (in your case is #1):</p>

<ol>
<li>first create the zip, then encrypt the zip</li>
<li>first encrypt the file, then zip it</li>
</ol>

<p>The extension of the file tells you the order of operations, by reading them from left to right: </p>

<ol>
<li><code>comdty_option_namr.out</code> is the name of the file </li>
<li>the file got <code>gzipped</code>, thus getting to <code>comdty_option_namr.out.gz</code></li>
<li>after which the <code>gzip</code> archive to encrypted, resulting the file <code>comdty_option_namr.out.gz.enc</code></li>
</ol>
","764","<python><encryption><des><gzip>","0","0","1","2015-04-20 08:05:10","","4","","4797660","","2015-04-20 08:05:10","2015-04-20 07:40:54",""
"14672146","des file encryption corrupts file","<p>i have written a class in vb.net to encrypt/decrypt files, but when i decrypt files like images or zips or office files, they look corrupted. But if i open the decrypted and original file in notepad they are exactly the same. What can i do to stop this?</p>

<pre><code>Imports System
Imports System.IO
Imports System.Security
Imports System.Security.Cryptography
Imports System.Text

Public Class Encrytion
Shared Sub EncryptFile(ByVal sInputFilename As String, ByVal sOutputFilename As String, ByVal sKey As String)

    Dim fsInput As New FileStream(sInputFilename, _
                                FileMode.Open, FileAccess.Read)
    Dim fsEncrypted As New FileStream(sOutputFilename, _
                                FileMode.Create, FileAccess.Write)

    Dim DES As New DESCryptoServiceProvider()

    DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey)

    DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey)

    Dim desencrypt As ICryptoTransform = DES.CreateEncryptor()

    Dim cryptostream As New CryptoStream(fsEncrypted, _
                                        desencrypt, _
                                        CryptoStreamMode.Write)


    Dim bytearrayinput(fsInput.Length - 1) As Byte
    fsInput.Read(bytearrayinput, 0, bytearrayinput.Length)

    cryptostream.Write(bytearrayinput, 0, bytearrayinput.Length)
    cryptostream.Close()
End Sub

Shared Sub DecryptFile(ByVal sInputFilename As String, ByVal sOutputFilename As String, ByVal sKey As String)

    Dim DES As New DESCryptoServiceProvider()

    DES.Key() = ASCIIEncoding.ASCII.GetBytes(sKey)

    DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey)

    Dim fsread As New FileStream(sInputFilename, FileMode.Open, FileAccess.Read)

    Dim desdecrypt As ICryptoTransform = DES.CreateDecryptor()

    Dim cryptostreamDecr As New CryptoStream(fsread, desdecrypt, CryptoStreamMode.Read)

    Dim fsDecrypted As New StreamWriter(sOutputFilename)
    fsDecrypted.Write(New StreamReader(cryptostreamDecr).ReadToEnd)
    fsDecrypted.Flush()
    fsDecrypted.Close()
End Sub

End Class
</code></pre>
","<p>I found <a href=""https://stackoverflow.com/a/11057010/493055"">this answer</a> to solve this problem.  In short, the Encrypt and Decrypt functions should be exactly the same, outside of the <code>CreateEncryptor</code>/<code>CreateDecryptor</code> calls:</p>

<pre><code>Shared Sub EncryptFile(ByVal sInputFilename As String, ByVal sOutputFilename As String, ByVal sKey As String)

    Dim fsInput As New FileStream(sInputFilename, _
                                FileMode.Open, FileAccess.Read)
    Dim fsEncrypted As New FileStream(sOutputFilename, _
                                FileMode.Create, FileAccess.Write)

    Dim DES As New DESCryptoServiceProvider()

    DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey)

    DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey)

    Dim desencrypt As ICryptoTransform = DES.CreateEncryptor(DES.Key, DES.IV)

    Dim cryptostream As New CryptoStream(fsEncrypted, _
                                        desencrypt, _
                                        CryptoStreamMode.Write)


    Dim bytearrayinput(fsInput.Length - 1) As Byte
    fsInput.Read(bytearrayinput, 0, bytearrayinput.Length)

    cryptostream.Write(bytearrayinput, 0, bytearrayinput.Length)
    cryptostream.Flush()

    cryptostream.Close()
End Sub

Shared Sub DecryptFile(ByVal sInputFilename As String, ByVal sOutputFilename As String, ByVal sKey As String)
    Dim fsInput As New FileStream(sInputFilename, _
                        FileMode.Open, FileAccess.Read)
    Dim fsEncrypted As New FileStream(sOutputFilename, _
                                FileMode.Create, FileAccess.Write)

    Dim DES As New DESCryptoServiceProvider()

    DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey)

    DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey)

    Dim desencrypt As ICryptoTransform = DES.CreateDecryptor(DES.Key, DES.IV)

    Dim cryptostream As New CryptoStream(fsEncrypted, _
                                        desencrypt, _
                                        CryptoStreamMode.Write)


    Dim bytearrayinput(fsInput.Length - 1) As Byte
    fsInput.Read(bytearrayinput, 0, bytearrayinput.Length)

    cryptostream.Write(bytearrayinput, 0, bytearrayinput.Length)
    cryptostream.Flush()

    cryptostream.Close()
End Sub
</code></pre>
","763","<vb.net><encryption><des>","2","1","1","2013-06-10 22:36:16","17033928","6","","2036990","","2013-02-04 18:39:30","2013-02-03 11:49:34",""
"22851693","ios decrypt base64 encoded string using des ecb","<p>I am trying to decrypt a string that was first encrypted using des in ecb mode, and then encoded in base64. </p>

<p>This is my code:</p>

<pre><code>+ (NSString *)decrypt:(NSString *)encryptedText
{
    NSString *key = @""12345678"";
    NSData *decodedData = [[NSData alloc] initWithBase64EncodedString:encryptedText options:0];
    size_t numBytesDecrypted = 0;
    size_t bufferSize = [decodedData length] + kCCBlockSizeDES;
    void *buffer = malloc(bufferSize);
    char keyPtr[kCCKeySizeDES+1]; // room for terminator (unused)
    bzero(keyPtr, sizeof(keyPtr));
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];


    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,
                                      kCCAlgorithmDES,
                                      kCCOptionPKCS7Padding | kCCOptionECBMode,
                                      keyPtr,
                                      kCCKeySizeAES256,
                                      NULL /* initialization vector (optional) */,
                                      [decodedData bytes], [decodedData length], /* input */
                                      buffer,       bufferSize, /* output */
                                      &amp;numBytesDecrypted);

    NSData *val = [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];
    return [[NSString alloc] initWithData:val encoding:NSUTF8StringEncoding];
}
</code></pre>

<p>However I am getting a nil string in return...any ideas? </p>
","<p>You are using DES but are specifying the key size as: <code>kCCKeySizeAES256</code> in the call to: <code>CCCrypt</code>.</p>

<p>There are so many things wrong with this code from a security standpoint, don't use this in a real app. This is no longer best practice. Among other things the password should be converted to key with a Password-Based Key Derivation Function such as PBKDF2. Also using DES and ECB mode is a weaknesses.</p>
","756","<ios><encryption><base64><des><ecb>","1","1","1","2014-04-04 03:37:42","22852865","3","","2680879","","2014-04-04 01:16:03","2014-04-04 01:01:04",""
"27718277","Xor bits in python","<p>Well I have an assignment to implement DES and I chose python, only problem is I can't figure out how to XOR bits of a String or Byte String, I can manually XOR them if only I can manage to read the 1s and 0s in them.</p>

<p>Example: </p>

<pre><code>s1 = b'abc'
s2 = b'efg'

s3 = XOR(s1,s2) // my own method
</code></pre>

<p>How can I XOR them or how can I get the binary values of 1s and 0s that represent them?</p>

<p>If you use any python methods explain them, I'm relatively new to this language.</p>
","<pre><code>&gt;&gt;&gt; b''.join(chr(ord(a) ^ ord(b)) for a, b in zip(b'abc', b'efg'))
'\x04\x04\x04'
</code></pre>
","755","<python><string><xor><bits><des>","1","3","3","2015-01-01 00:23:42","27718332","2","","4400284","","2015-01-01 00:23:42","2014-12-31 08:23:33","2014-12-31 10:40:41"
"27718277","Xor bits in python","<p>Well I have an assignment to implement DES and I chose python, only problem is I can't figure out how to XOR bits of a String or Byte String, I can manually XOR them if only I can manage to read the 1s and 0s in them.</p>

<p>Example: </p>

<pre><code>s1 = b'abc'
s2 = b'efg'

s3 = XOR(s1,s2) // my own method
</code></pre>

<p>How can I XOR them or how can I get the binary values of 1s and 0s that represent them?</p>

<p>If you use any python methods explain them, I'm relatively new to this language.</p>
","<p>First you need to <code>zip</code> your strings then use <code>ord</code> (in <code>python 2</code>) and <code>^</code> for each of characters :</p>

<pre><code>&gt;&gt;&gt; s1 = b'abc'
&gt;&gt;&gt; s2 = b'efg'
&gt;&gt;&gt; ''.join(chr(ord(i)^ord(j)) for i,j in zip(s1,s2))
'\x04\x04\x04'
</code></pre>

<p>the <a href=""https://docs.python.org/2/library/functions.html#ord"" rel=""nofollow""><code>ord()</code></a> function retuen value of the byte when the argument is an 8-bit string.But if you are using <code>python 3</code> you dont need <code>ord</code> :</p>

<pre><code>&gt;&gt;&gt; ''.join(chr(i^j) for i,j in zip(s1,s2))
'\x04\x04\x04'
</code></pre>

<blockquote>
  <p>Since bytes objects are sequences of integers (akin to a tuple), for a bytes object b, <code>b[0]</code> will be an integer, while <code>b[0:1]</code> will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1)</p>
</blockquote>

<pre><code>example :

&gt;&gt;&gt; s1[0]
97
&gt;&gt;&gt; s1[0:1]
b'a'
</code></pre>

<hr>

<p>and if you want to convert back your strings you need to firs convert the <code>XOR</code>ed string to binary you can do it by <code>binascii.a2b_qp</code> function :</p>

<pre><code>&gt;&gt;&gt; import binascii 
&gt;&gt;&gt; s=''.join(chr(i^j) for i,j in zip(s1,s2))
&gt;&gt;&gt; s4=binascii.a2b_qp(s)
&gt;&gt;&gt; ''.join(chr(i^j) for i,j in zip(s1,s4))
'efg'
</code></pre>
","755","<python><string><xor><bits><des>","1","2","3","2015-01-01 00:23:42","27718332","2","","4400284","","2015-01-01 00:23:42","2014-12-31 08:23:33","2014-12-31 10:40:41"
"27718277","Xor bits in python","<p>Well I have an assignment to implement DES and I chose python, only problem is I can't figure out how to XOR bits of a String or Byte String, I can manually XOR them if only I can manage to read the 1s and 0s in them.</p>

<p>Example: </p>

<pre><code>s1 = b'abc'
s2 = b'efg'

s3 = XOR(s1,s2) // my own method
</code></pre>

<p>How can I XOR them or how can I get the binary values of 1s and 0s that represent them?</p>

<p>If you use any python methods explain them, I'm relatively new to this language.</p>
","<p>Not really efficient, but this should work.</p>

<pre><code>s1 = b'abc'
s2 = b'efg'
s3= b''
for c1,c2 in zip(s1, s2):
    s3 += chr( ord(c1) ^ ord(c2) )

&gt;&gt;&gt; s3
'\x04\x04\x04'
</code></pre>
","755","<python><string><xor><bits><des>","1","1","3","2015-01-01 00:23:42","27718332","2","","4400284","","2015-01-01 00:23:42","2014-12-31 08:23:33","2014-12-31 10:40:41"
"43200983","DES/ECB/NoPadding in swift 3.1 using Common Crypto","<p>I would like to encrypt and decrypt strings in my iOS app using DES (yes I know DES isn't safe anymore but the app receives and send messages to a BLE module that uses it).
I successfully created a bridging header for Common Crypto and I found this for encryption and adapted it for DES and swift 3 <a href=""https://stackoverflow.com/questions/29222642/asynchronous-encryption-in-swift/29230965#29230965"">Asynchronous encryption in Swift</a>:</p>

<pre><code>func testCrypt(data:NSData, keyData:NSData, ivData:NSData, operation:CCOperation) -&gt; NSData? {

    let keyBytes = keyData.bytes.assumingMemoryBound(to: UInt8.self)
    print(""keyLength   = \(keyData.length), keyData   = \(keyData)"")

    let ivBytes = ivData.bytes.assumingMemoryBound(to: UInt8.self)
    print(""ivLength    = \(ivData.length), ivData    = \(ivData)"")

    let dataLength = Int(data.length)

    let dataBytes = data.bytes.assumingMemoryBound(to: UInt8.self)
    print(""dataLength  = \(dataLength), data      = \(data)"")

    let cryptData: NSMutableData! = NSMutableData(length: Int(dataLength) + kCCBlockSizeDES)

    let cryptPointer = cryptData.mutableBytes.assumingMemoryBound(to: UInt8.self)
    let cryptLength  = size_t(cryptData.length)

    let keyLength              = size_t(kCCKeySizeDES)
    let algoritm:  CCAlgorithm = UInt32(kCCAlgorithmDES)
    let options:   CCOptions   = UInt32(kCCOptionECBMode)

    var numBytesEncrypted :size_t = 0

    let cryptStatus = CCCrypt(operation,
                              algoritm,
                              options,
                              keyBytes, keyLength,
                              ivBytes,
                              dataBytes, dataLength,
                              cryptPointer, cryptLength,
                              &amp;numBytesEncrypted)

    return cryptData;
}
</code></pre>

<p>Function call and parameters:</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    let ivString = ""Use a random iv!""
    let ivData = (ivString as NSString).data(using: String.Encoding.utf8.rawValue) as NSData!

    let key = Data.init(bytes: [0x23, 0x12, 0x4d, 0x89, 0x88, 0x34, 0xCf, 0x50])
    let keyData = NSData.init(data: key)

    let message = ""Don´t try to read this text. Top Secret Stuff""
    let data = (message as NSString).data(using: String.Encoding.utf8.rawValue) as NSData!

    print(""data: \(data)"")
    if let encryptedData = testCrypt(data: data!, keyData:keyData, ivData: ivData!, operation:UInt32(kCCEncrypt)) {
        print(""encryptedData: \(encryptedData)"")
        if let decryptedData = testCrypt(data: encryptedData, keyData:keyData, ivData: ivData!, operation:UInt32(kCCDecrypt)) {
            let dec = Data.init(referencing: decryptedData)
            print(""decryptedData: \(decryptedData))"")
        }
    }
}
</code></pre>

<p>Expected result = &lt;446f6ec2 b4742074 72792074 6f207265 61642074 68697320 74657874 2e20546f 70205365 63726574 20537475 6666></p>

<p>encryptedData: &lt;6081ada9 0487c0a5 35e542bd e9600861 4250a693 65573337 39df5525 66c40cd8 b358bf6a d9837f9c 00000000 00000000 00000000 0000></p>

<p>decryptedData = &lt;446f6ec2 b4742074 72792074 6f207265 61642074 68697320 74657874 2e20546f 70205365 63726574 e0456e88 3f896b9b 00000000 00000000 00000000 0000></p>

<p>Why decryption returns a right result only in part?</p>
","<p>So it seems like there's no NoPadding options available, in the end I just removed '+ kCCBlockSizeDES' from 'cryptData' initialization and added '0' characters to my string before encrypting it to reach a right size (for example a length multiple of 8) and then after decryption I just removed the zeros to get the original string.</p>
","754","<ios><encryption><swift3><des><commoncrypto>","2","0","1","2017-04-06 07:49:22","43248924","2","","-1","","2017-05-23 11:54:18","2017-04-04 07:34:23",""
"39128103","How do I decrypt a Java-DES-encrypted message using openssl?","<p>Since the question title is self-explaining, please consider the following code:</p>

<pre class=""lang-java prettyprint-override""><code>private static final String ALGORITHM = ""DES"";
private static final String MESSAGE = ""This is an extremely secret message"";
private static final byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7 };

...

// Do encryption
final Cipher cipher = Cipher.getInstance(ALGORITHM);
cipher.init(ENCRYPT_MODE, new SecretKeySpec(key, ALGORITHM));
final byte[] encrypted = cipher.doFinal(MESSAGE.getBytes());

// Copy the encrypted message to a file
final InputStream inputStream = new ByteArrayInputStream(encrypted);
final OutputStream outputStream = new FileOutputStream(""___SECRET"");
copy(inputStream, outputStream);
</code></pre>

<p>Now I'm trying to decrypt the <code>___SECRET</code> file with the following command:</p>

<pre><code>openssl enc -d -des -K 0001020304050607 -iv 0 -in ___SECRET -out ___OPEN
</code></pre>

<p>which results in:</p>

<pre><code>bad decrypt
3073636028:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:evp_enc.c:539:
</code></pre>

<p>just decrypting the very first block (8 bytes) leaving the rest in trash state (OEM encoding):</p>

<pre><code>This is MЕ$S6%@╢Т√°ў╝°╢]∙iь
</code></pre>

<p>What am I doing wrong and how do I decrypt the encrypted message using <code>openssl</code>?</p>
","<p>On Java you use DES in ECB mode and on OpenSSL you use DES in CBC mode (IV is present).</p>

<p>This is a significant difference as in CBC the blocks are chained - therefore the first block is decrypted correctly but all following blocks are scrambled.</p>

<p>You can change the Java part to use ""DES/CBC"" mode instead and provide an IV or change the openssl part and use <code>-des-ecb</code> instead of <code>-des</code>.</p>
","749","<java><openssl><des>","1","2","1","2016-08-25 01:34:45","39128445","3","2","","","","2016-08-24 16:03:24",""
"26648469","How to Convert a byte array to DSA private key?","<p>As a part of project implementation, i have done the following things: 
1. Generete DSA keys
2. Encrypt the private key using AES
3. Save into the file
4. Open the file and read the encrypted private key
5. I tried to convert the read value into primary key format but error comes here.
I am attaching the code of the above steps here : </p>

<pre><code>public class Pgm {
public static void main(String[] args) { 
try {
            KeyPairGenerator dsa =  KeyPairGenerator.getInstance(""DSA"");
            SecureRandom random = new SecureRandom();
            dsa.initialize(1024, random);
            KeyPair keypair = dsa.generateKeyPair();
            PrivateKey privateKey = (PrivateKey) keypair.getPrivate();
            byte[] key = ""�u���1Ù�iw&amp;a"".getBytes();
            Key aesKey = new SecretKeySpec(key, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            String currentDir = System.getProperty(""user.dir""); 
            // encrypt the text
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] abc = privateKey.getEncoded();

            byte[] encrypted = cipher.doFinal(abc);
            // System.out.println(""len=""+encrypted.length());
            File dir=new File(currentDir);
            File private_file=new File(dir,""privatekey.txt"");
            if(!private_file.exists()){
                private_file.createNewFile();
            }
            FileOutputStream fileos = new FileOutputStream(private_file); 
            ObjectOutputStream objectos = new ObjectOutputStream(fileos);
            objectos.writeObject(encrypted);
            objectos.close();
            fileos.close();

            File file_private = new File(dir,""privatekey.txt"");
            FileInputStream fileo = new FileInputStream(file_private); 
            ObjectInputStream objos = new ObjectInputStream(fileo);
            Object obj = objos.readObject();
            byte[] encrypted1= (byte[] )obj;
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            String decrypted = new String(cipher.doFinal(encrypted1));
            if (decrypted.equals(new String(abc)))
               System.out.println(""true"");
            else
               System.out.println(""false"");
            Signature tosign = Signature.getInstance(""DSA"");
            byte[] val =  decrypted.getBytes();
            PrivateKey privatekey1 = (PrivateKey)val;
            tosign.initSign(privatekey1);   

      }
      catch(Exception e)
      {
            e.printStackTrace();
      }
  }
</code></pre>

<p>}</p>

<p>'
     <code>PrivateKey privatekey1 = (PrivateKey)val;</code></p>

<p>shows the error as  inconvertible types </p>
","<p>What if you replace explicit casting with this:</p>

<pre><code>PrivateKey privateKey1 = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(val));
</code></pre>
","744","<java><encryption><aes><des>","0","0","2","2014-10-30 09:08:58","26648886","2","2","","","","2014-10-30 08:44:39",""
"26648469","How to Convert a byte array to DSA private key?","<p>As a part of project implementation, i have done the following things: 
1. Generete DSA keys
2. Encrypt the private key using AES
3. Save into the file
4. Open the file and read the encrypted private key
5. I tried to convert the read value into primary key format but error comes here.
I am attaching the code of the above steps here : </p>

<pre><code>public class Pgm {
public static void main(String[] args) { 
try {
            KeyPairGenerator dsa =  KeyPairGenerator.getInstance(""DSA"");
            SecureRandom random = new SecureRandom();
            dsa.initialize(1024, random);
            KeyPair keypair = dsa.generateKeyPair();
            PrivateKey privateKey = (PrivateKey) keypair.getPrivate();
            byte[] key = ""�u���1Ù�iw&amp;a"".getBytes();
            Key aesKey = new SecretKeySpec(key, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            String currentDir = System.getProperty(""user.dir""); 
            // encrypt the text
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] abc = privateKey.getEncoded();

            byte[] encrypted = cipher.doFinal(abc);
            // System.out.println(""len=""+encrypted.length());
            File dir=new File(currentDir);
            File private_file=new File(dir,""privatekey.txt"");
            if(!private_file.exists()){
                private_file.createNewFile();
            }
            FileOutputStream fileos = new FileOutputStream(private_file); 
            ObjectOutputStream objectos = new ObjectOutputStream(fileos);
            objectos.writeObject(encrypted);
            objectos.close();
            fileos.close();

            File file_private = new File(dir,""privatekey.txt"");
            FileInputStream fileo = new FileInputStream(file_private); 
            ObjectInputStream objos = new ObjectInputStream(fileo);
            Object obj = objos.readObject();
            byte[] encrypted1= (byte[] )obj;
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            String decrypted = new String(cipher.doFinal(encrypted1));
            if (decrypted.equals(new String(abc)))
               System.out.println(""true"");
            else
               System.out.println(""false"");
            Signature tosign = Signature.getInstance(""DSA"");
            byte[] val =  decrypted.getBytes();
            PrivateKey privatekey1 = (PrivateKey)val;
            tosign.initSign(privatekey1);   

      }
      catch(Exception e)
      {
            e.printStackTrace();
      }
  }
</code></pre>

<p>}</p>

<p>'
     <code>PrivateKey privatekey1 = (PrivateKey)val;</code></p>

<p>shows the error as  inconvertible types </p>
","<p>You can't simple convert byte array to PrivateKey instance.
You can generate keys by <a href=""http://docs.oracle.com/javase/7/docs/api/java/security/KeyFactory.html"" rel=""nofollow"">KeyFactory</a></p>
","744","<java><encryption><aes><des>","0","2","2","2014-10-30 09:08:58","26648886","2","2","","","","2014-10-30 08:44:39",""
"49996855","Encryption key size DES Java","<p>I want to encrypt a challenge (like 162236fe0bec620827958c8fdf7e4bc7 ) using this key C6864E7696C686 with the DES algorithm.</p>

<p>Here is my code :</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.xml.bind.DatatypeConverter;
import javax.crypto.spec.DESKeySpec;


def data = prev.getResponseData();
String challenge = javax.xml.bind.DatatypeConverter.printHexBinary(data);
final String strPassPhrase = ""C6864E7696C686"";

String param = challenge;
System.out.println(""Text : "" + param);

SecretKeyFactory factory = SecretKeyFactory.getInstance(""DES"");
SecretKey key = factory.generateSecret(new   DESKeySpec(hexStringToByteArray(strPassPhrase)));
Cipher cipher = Cipher.getInstance(""DES"");

cipher.init(Cipher.ENCRYPT_MODE, key);
String str = DatatypeConverter.printBase64Binary(cipher.doFinal(param.getBytes()));
System.out.println(""Text Encryted : "" + str);
cipher.init(Cipher.DECRYPT_MODE, key);
String str2 = new String(cipher.doFinal(DatatypeConverter.parseBase64Binary(str)));
System.out.println(""Text Decryted : "" + str2);
</code></pre>

<p>But i get this exception : </p>

<pre><code>java.security.InvalidKeyException: Wrong key size
</code></pre>

<p><strong>Edit :</strong> 
I have copy this function to convert my hex string to bytes :</p>

<pre><code>public static byte[] hexStringToByteArray(String s) {
int len = s.length();
byte[] data = new byte[len / 2];
for (int i = 0; i &lt; len; i += 2) {
    data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                         + Character.digit(s.charAt(i+1), 16));
}
return data;
}
</code></pre>

<p>But I get the same exception ...</p>
","<p>Your DES key should be 8 bytes (56 bits + 8 parity bits).</p>

<p>The string you're using as a key looks like a hexadecimal representation of 7 bytes, but instead of decoding it as hex, you're getting the bytes for the characters in the hex string.</p>

<p>Since there are 14 characters, you will most likely (depending on your encoding) end up with 14 bytes, which is too long for DES.</p>

<p>There are a couple of approaches described in <a href=""https://stackoverflow.com/questions/140131/convert-a-string-representation-of-a-hex-dump-to-a-byte-array-using-java"">this question</a> that explain how to convert the hex string to a byte array.</p>

<p>That will however only get you so far, because you're still one byte short. A traditional approach seems to be to take the 56 bits you have and spread them out over 8 bytes, adding one parity bit to each byte. A Java example of how to do that is described in <a href=""https://crypto.stackexchange.com/a/15812"">this answer</a>. Another approach could be to just add a <code>null</code> byte at the end of the key. Which approach you should take depends on the key's intended usage, especially the way it is used by the other parties you're exchanging information with.</p>
","732","<java><exception><encryption><des>","2","4","1","2018-04-24 10:05:48","49996950","4","","9685127","","2018-04-24 08:47:11","2018-04-24 08:28:31",""
"25399785","Encrypt complete object with triple des","<p>I need to encrypt a complete java object. I am having a code which i have seen on internet which shows how to encrypt and decrypt text not the java object. So i was confused whether this is possible to encrypt complete java object. The code which i am using is below.</p>

<pre><code>package security;

import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/**
 * This class defines methods for encrypting and decrypting using the Triple DES
 * algorithm and for generating, reading and writing Triple DES keys. It also
 * defines a main() method that allows these methods to be used from the command
 * line.
 */
public class TripleDesEncryptionDecryption {
  /**
   * The program. The first argument must be -e, -d, or -g to encrypt,
   * decrypt, or generate a key. The second argument is the name of a file
   * from which the key is read or to which it is written for -g. The -e and
   * -d arguments cause the program to read from standard input and encrypt or
   * decrypt to standard output.
   */
    private static final String UNICODE_FORMAT = ""UTF8"";
    public static final String DESEDE_ENCRYPTION_SCHEME = ""DES/ECB/NoPadding"";
    private KeySpec myKeySpec;
    private SecretKeyFactory mySecretKeyFactory;
    private Cipher cipher;
    byte[] keyAsBytes;
    private String myEncryptionKey;
    private String myEncryptionScheme;
    SecretKey key;
    static String stringToEncrypt="""";

    public void setKey(String myKey) throws Exception
    {
        myEncryptionKey = myKey ;
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        myKeySpec = new DESedeKeySpec(keyAsBytes);
        mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = mySecretKeyFactory.generateSecret(myKeySpec);
    }

    /**
     * Method To Encrypt The String
     */
    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            BASE64Encoder base64encoder = new BASE64Encoder();
            encryptedString = base64encoder.encode(encryptedText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }
    /**
     * Method To Decrypt An Ecrypted String
     */
    public String decrypt(String encryptedString) {
        String decryptedText=null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            BASE64Decoder base64decoder = new BASE64Decoder();

            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }
    /**
     * Returns String From An Array Of Bytes
     */
    private static String bytes2String(byte[] bytes) {
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            stringBuffer.append((char) bytes[i]);
        }
        return stringBuffer.toString();
    }

    /**
     * Testing The DESede Encryption And Decryption Technique
    */
    public static void main(String args []) throws Exception
    {
        TripleDesEncryptionDecryption myEncryptor= new TripleDesEncryptionDecryption();

        String encrypted=myEncryptor.encrypt(stringToEncrypt);
        String decrypted=myEncryptor.decrypt(encrypted);

        System.out.println(""String To Encrypt: ""+stringToEncrypt);
        System.out.println(""Encrypted Value :"" + encrypted);
        System.out.println(""Decrypted Value :""+decrypted);
    }
}
</code></pre>
","<p>You can encrypt bytes. Text is bytes, you can serialize a Java object to bytes, so technically it's possible (for example with an <code>ObjectOutputStream</code> connected to a <code>ByteArrayOutputStream</code>).</p>

<p>However it sounds strange, why do you think you need to encrypt an object, instead of the essential data inside an object?</p>
","731","<java><encryption><des><tripledes>","0","2","2","2014-08-20 09:11:56","25400892","0","2","","","","2014-08-20 08:11:17",""
"25399785","Encrypt complete object with triple des","<p>I need to encrypt a complete java object. I am having a code which i have seen on internet which shows how to encrypt and decrypt text not the java object. So i was confused whether this is possible to encrypt complete java object. The code which i am using is below.</p>

<pre><code>package security;

import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/**
 * This class defines methods for encrypting and decrypting using the Triple DES
 * algorithm and for generating, reading and writing Triple DES keys. It also
 * defines a main() method that allows these methods to be used from the command
 * line.
 */
public class TripleDesEncryptionDecryption {
  /**
   * The program. The first argument must be -e, -d, or -g to encrypt,
   * decrypt, or generate a key. The second argument is the name of a file
   * from which the key is read or to which it is written for -g. The -e and
   * -d arguments cause the program to read from standard input and encrypt or
   * decrypt to standard output.
   */
    private static final String UNICODE_FORMAT = ""UTF8"";
    public static final String DESEDE_ENCRYPTION_SCHEME = ""DES/ECB/NoPadding"";
    private KeySpec myKeySpec;
    private SecretKeyFactory mySecretKeyFactory;
    private Cipher cipher;
    byte[] keyAsBytes;
    private String myEncryptionKey;
    private String myEncryptionScheme;
    SecretKey key;
    static String stringToEncrypt="""";

    public void setKey(String myKey) throws Exception
    {
        myEncryptionKey = myKey ;
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        myKeySpec = new DESedeKeySpec(keyAsBytes);
        mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = mySecretKeyFactory.generateSecret(myKeySpec);
    }

    /**
     * Method To Encrypt The String
     */
    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            BASE64Encoder base64encoder = new BASE64Encoder();
            encryptedString = base64encoder.encode(encryptedText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }
    /**
     * Method To Decrypt An Ecrypted String
     */
    public String decrypt(String encryptedString) {
        String decryptedText=null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            BASE64Decoder base64decoder = new BASE64Decoder();

            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }
    /**
     * Returns String From An Array Of Bytes
     */
    private static String bytes2String(byte[] bytes) {
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            stringBuffer.append((char) bytes[i]);
        }
        return stringBuffer.toString();
    }

    /**
     * Testing The DESede Encryption And Decryption Technique
    */
    public static void main(String args []) throws Exception
    {
        TripleDesEncryptionDecryption myEncryptor= new TripleDesEncryptionDecryption();

        String encrypted=myEncryptor.encrypt(stringToEncrypt);
        String decrypted=myEncryptor.decrypt(encrypted);

        System.out.println(""String To Encrypt: ""+stringToEncrypt);
        System.out.println(""Encrypted Value :"" + encrypted);
        System.out.println(""Decrypted Value :""+decrypted);
    }
}
</code></pre>
","<p>There is a Java-class called <code>SealedObject</code> (<a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/SealedObject.html"" rel=""nofollow"">doc</a>) which exactly does what you want to achieve.</p>

<blockquote>
  <p>This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm. </p>
</blockquote>

<p>There is only one restriction for the Object to encrypt, it must be <code>Serializable</code>.</p>

<pre><code>MyObject myObj = new MyObject(); // must be serializable

Cipher cipher;
/* initialize fully with IV, key and Cipher.ENCRYPT_MODE */

/* encrypt `myObj` */
SealedObject sealedObj = new SealedObject(myObj, cipher);

/* decrypt `sealedObj` */
MyObjct decryptedObj = (MyObject) sealedObj.get(key); // `key` = encryption-key
</code></pre>

<p>Basically this class does the serialization with <code>ObjectOutputStream</code> and <code>ByteArrayOutputStream</code> for you and automatically tracks the algorithm used for encryption.</p>
","731","<java><encryption><des><tripledes>","0","3","2","2014-08-20 09:11:56","25400892","0","2","","","","2014-08-20 08:11:17",""
"43504123","Recursively iterating over every character combination","<p><strong>Expected result:</strong></p>

<p>The program takes a hashed password as input; this is passed to the decrypt function.
The function iterates over every mixed-case n-letter combination, hashing each such string.
If it finds a match to the input, it prints out the un-hashed password ; otherwise, it exits.</p>

<p><strong>Actual result:</strong></p>

<p>Function iterates over every mixed-case letter only for last letter in current iteration.</p>

<p><strong>Description of the problem:</strong> </p>

<p>I'm trying to implement a simple brute-force DES-crypted password-cracker in Python. I did an implementation for 4-character passwords using a lot of for loops, but now I want to refactor it for a range of lengths, using recursion.
How can I iterate over every character combination, starting from 1-char combination up to 4-character string combination?</p>

<p>I wanted to use this line:</p>

<pre><code>            password[i] = string.ascii_letters[j]
</code></pre>

<p>But I get this error:</p>

<pre><code>TypeError: 'str' object does not support item assignment
</code></pre>

<p><strong>Code snippet:</strong></p>

<pre><code>def decrypt(encryptedText):
    # reference global variable
    global password
    # check curr password guess length
    pwdlen = len(password)

    if pwdlen &gt;= 4:
        print(""Password is longer than 4 characters, exiting..."")
        exit(2)

    # debug lines
    print(""password is {}"".format(password))
    print(""length: {}"".format(pwdlen))
    time.sleep(2)

    # first two characters is salt
    salt = encryptedText[:2]

    # Check hashes for every combination of strings and compare them
    # starts with last char
    for i in range(pwdlen, 0, -1):
        for j in range(0, len(string.ascii_letters)):
            password = string.ascii_letters[:pwdlen] + string.ascii_letters[j]
            hashed = crypt.crypt(password, salt)

            # debug line
            print(password)

            # if found - print password and exit
            if hashed == encryptedText:
                print(password)
                exit(0)

    # this makes recursion go through +1 char combinations on every iteration
    password = (pwdlen + 1) * 'a'

    return decrypt(encryptedText)
</code></pre>
","<p>Strings are immutable.  You can't assign a new value to part of the string.  Instead, you have to build a new value and assign that to the original variable.  For instance:</p>

<pre><code># password[i] = string.ascii_letters[j]
password = password[:i] + string.ascii_letters[j] + password[i+1:]
</code></pre>

<p>Second, you can probably do much better by using the <a href=""https://docs.python.org/2/library/itertools.html"" rel=""noreferrer"">itertools</a> package to generate all of the permutations you want.  For instance, generate the product of <strong>asci_letters</strong> as many times as you want, and step through the <strong>join</strong> of those letter sequences.</p>
","716","<python><string><recursion><des><crypt>","3","6","1","2017-04-20 00:09:55","43504244","1","","4785185","","2017-04-20 00:09:55","2017-04-19 19:08:21",""
"22287627","Why does PHP crypt function use DES encryption algorithm?","<p>Given that the rule of thumb is to store salted hashes of the password string, not the encrypted form of it, why does the PHP <a href=""http://in3.php.net/crypt"" rel=""nofollow""><code>crypt()</code></a> function use the DES-based algorithms? Isn't DES an encryption algorithm? The manual says </p>

<blockquote>
  <p>... crypt() will return a hashed string using the standard Unix DES-based algorithm or alternative algorithms that may be available on the system ...</p>
</blockquote>

<p>What I understand from here is that <code>crypt()</code> only uses the algorithm as implemented by the system. And surely DES is implemented as an encryption algorithm rather than a custom hashing algorithm for crypt. </p>

<p>PS - I know that DES was way back in the past and nobody should use it anymore. </p>
","<p>The idea of DES-based password hashing is, basically, to encrypt a block of zeroes with the password and passed salt for some number of rounds. Any half-decent encryption makes key recovery hard even in the face of known plaintext, so that’s why it’s possible to make strong password hashes out of encryption functions.</p>

<p>I <em>think</em> the PHP default is compatible with <a href=""https://en.wikipedia.org/wiki/Crypt_%28C%29#Traditional_DES-based_scheme"" rel=""nofollow"">this scheme</a>.</p>
","702","<php><encryption><hash><des><crypt>","4","3","1","2014-03-09 20:45:21","22287935","3","","1438393","","2014-03-09 20:28:40","2014-03-09 20:21:29",""
"34493652","Given final block not properly padded DES","<p>I have used DES encryption to encrypt/decrypt a data. This code was working fine. But now this code is failing on Linux box with padding error, on Windows box I am not seeing this issue. 
These are my observations</p>

<ul>
<li>The older encryption key are working fine. The newer ones generated is causing the problem</li>
<li>Runs on Windows machine not on Linux machine</li>
</ul>

<p>Can anyone let me know what might be causing this issue?</p>

<p>Here is my code</p>

<pre><code> /**
 * Generate the private key using the passed string.
 * 
 * @param keyGeneratorString
 *            : The string which is to be used to generate the private key.
 * @return : SecretKey else null.
 */
public SecretKey getKey(String keyGeneratorString) {
    SecretKeyFactory keyFactory = null;
    DESKeySpec keySpec = null;
    try {
        // only the first 8 Bytes of the constructor argument are used
        // as material for generating the keySpec
        keySpec = new DESKeySpec(keyGeneratorString.getBytes(""UTF-8""));
        // Get the DES encryption standard instance
        keyFactory = SecretKeyFactory.getInstance(""DES"");
        // Generate and return the key.
        return keyFactory.generateSecret(keySpec);
    } catch (UnsupportedEncodingException uee) {
        logger.error(""****** Error while generating key : ""
                + uee.getMessage());
    } catch (InvalidKeyException ike) {
        logger.error(""****** Error while generating key : ""
                + ike.getMessage());
    } catch (NoSuchAlgorithmException e) {
        logger.error(""****** Error while generating key : ""
                + e.getMessage());
    } catch (InvalidKeySpecException e) {
        logger.error(""****** Error while generating key : ""
                + e.getMessage());
    }
    // There was error while generating the key hence return null.
    return null;
}

/**
 * Encrypt the string using the SecretKey.
 * 
 * @param stringToBeEncrypted
 *            : The String to be encrypted.
 * @param key
 *            : The secret key to be used for encryption.
 * @return : Encrypted byte[] or null.
 */
public byte[] encrypt(String stringToBeEncrypted, SecretKey key) {
    Cipher cipherInst;
    try {
        cipherInst = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipherInst.init(Cipher.ENCRYPT_MODE, key);// cipher is not thread
                                                    // safe
        byte[] encrypted = cipherInst.doFinal(stringToBeEncrypted
                .getBytes());
        return encrypted;
    } catch (NoSuchAlgorithmException e) {
        logger.error(""****** Error while encrypting : ""
                + e.getMessage());
    } catch (NoSuchPaddingException e) {
        logger.error(""****** Error while encrypting : ""
                + e.getMessage());
    } catch (InvalidKeyException e) {
        logger.error(""****** Error while encrypting : ""
                + e.getMessage());
    } catch (IllegalBlockSizeException e) {
        logger.error(""****** Error while encrypting : ""
                + e.getMessage());
    } catch (BadPaddingException e) {
        logger.error(""****** Error while encrypting : ""
                + e.getMessage());
    }
    return null;
}

/**
 * Decrypt the string using the SecretKey.
 * 
 * @param stringToBeDecrypted : byte[] to be decrypted.
 * @param key : The secret key to be used for decryption.
 * @return : Decrypted byte[] or null.
 */
public byte[] decrypt(byte[] stringToBeDecrypted, SecretKey key) {
    Cipher cipherInst;
    try {
        cipherInst = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipherInst.init(Cipher.DECRYPT_MODE, key);
        byte[] original = cipherInst
                .doFinal(stringToBeDecrypted);
        return original;
    } catch (NoSuchAlgorithmException e) {
        logger.error(""****** Error while decrypting : ""
                + e.getMessage());
    } catch (NoSuchPaddingException e) {
        logger.error(""****** Error while decrypting : ""
                + e.getMessage());
    } catch (InvalidKeyException e) {
        logger.error(""****** Error while decrypting : ""
                + e.getMessage());
    } catch (IllegalBlockSizeException e) {
        logger.error(""****** Error while decrypting : ""
                + e.getMessage());
    } catch (BadPaddingException e) {
        logger.error(""****** Error while decrypting : ""
                + e.getMessage());
    }
    return null;
}
</code></pre>
","<p>Be careful when converting Strings to bytes that you always use the same encoding.  This line</p>

<pre><code>byte[] encrypted = cipherInst.doFinal(stringToBeEncrypted
            .getBytes());
</code></pre>

<p>uses the default character encoding for your machine which may well be different between Linux and Windows.  Use a consistent encoding like ""UTF8"" as you do for generating the <code>keySpec</code>.</p>

<pre><code>byte[] encrypted = cipherInst.doFinal(stringToBeEncrypted
            .getBytes(""UTF-8""));
</code></pre>

<p>Note that a ""padding error"" is usually no such thing; it's a very misleading error message.</p>
","692","<java><encryption><des>","-1","2","1","2015-12-28 12:58:00","","2","2","","","","2015-12-28 12:35:34",""
"10534235","Does the DUKPT algorithm generate weak DES keys?","<p>I'm using the DUKPT algorithm to generate keys for the DES encryption algorithm. The C# implementation of DES throws an exception when you attempt to use a weak key.</p>

<p>Is it possible for the DUKPT algorithm to generate weak keys, or does it avoid them? What can I do if it does generate a weak key?</p>
","<p>Possible, but very unlikely. The DUKPT algorithm gives a unique key for every transaction, and all bits at any time can be set or not, therefore it is possible for it to generate a ""weak"" key of all 0s. Depending on the size of your key it becomes much less likely to happen of course, and you want to be careful about arbitrarily throwing out ""weak"" keys, as that weakens the other keys as well.</p>

<p>An all zero key happens 1 time out of 2^(N) where N is the number of bits in your key, so for your 64 bit key: 1/(2^64)...needless to say, not very often. Since the DUKPT generates a unique key per transaction, you should be fine using it without checking for that case in DES since you'll presumably be doing all 16 rounds anyways.</p>
","684","<c#><.net><des><weak>","2","4","1","2012-05-10 13:11:07","","5","","8446","","2012-05-10 13:11:07","2012-05-10 12:41:26",""
"34892524","Using DESCryptoServiceProvider in Universal Windows Platform (UWP) app","<p>I have an UWP app that communicate with my web service, and for using some methods my app must encrypt parameters.
For decryption we have used <code>DESCryptoServiceProvider and CryptoStream</code> in </p>

<pre><code>System.Security.Cryptography
</code></pre>

<p>but UWP does not have the <code>System.Security.Cryptography,</code> and <code>Windows.Security.Cryptography</code> does not contain <code>DESCryptoServiceProvider and CryptoStream</code>!!!</p>

<p>Please help me Thanks.</p>
","<p>In Universal Windows apps, you have to use the <a href=""https://msdn.microsoft.com/en-us/library/windows/apps/windows.security.cryptography.core.cryptographicengine.aspx"" rel=""nofollow""><code>CryptographicEngine</code></a> for encrypt and decrypt operations.</p>

<p>For your decryption use-case, you'd use the <a href=""https://msdn.microsoft.com/en-us/library/windows/apps/windows.security.cryptography.core.cryptographicengine.decryptasync.aspx"" rel=""nofollow""><code>DecryptAsync</code></a> method, which requires - beside the encrypted data and the IV - a key to perform the operation.</p>

<p>The key you require will be created by the <a href=""https://msdn.microsoft.com/en-us/library/windows/apps/windows.security.cryptography.core.symmetrickeyalgorithmprovider.aspx"" rel=""nofollow""><code>SymmetricKeyAlgorithmProvider</code></a> class. Therefore, initialize a new instance by opening the <a href=""https://msdn.microsoft.com/en-us/library/windows/apps/windows.security.cryptography.core.symmetricalgorithmnames.aspx"" rel=""nofollow"">desired algorithm</a> and create the key.</p>

<p>For example:</p>

<pre class=""lang-cs prettyprint-override""><code>// Static method call, ""SymmetricAlgorithmNames"" has several DES algorithms,
// so choose the correct one
var provider = SymmetricKeyAlgorithmProvider
                   .OpenAlgorithm(SymmetricAlgorithmNames.DesEcbPkcs7);
var key = provider.CreateSymmetricKey(myKeyMaterial);
</code></pre>
","681","<uwp><des>","1","1","1","2016-01-20 08:27:05","34894384","0","","","","","2016-01-20 05:56:05",""
"23098659","VB.NET DES Decryption going wrong","<p>I'm trying to decrypt an encrypted string in a simple program I created in VB.NET but it seems like the Decryption Part isn't working properly.</p>

<p>Here's my code:</p>

<pre><code>Imports System.Security.Cryptography

 Module Module1
 Dim data As String = ""1234567887654321""
 Dim key As String = ""1111222233334444""
 Dim output As String
 Dim bData() As Byte
 Dim bKey() As Byte
 Dim bEncrypted(7) As Byte
 Dim bDecrypted(7) As Byte
 Dim nullIV(7) As Byte
 Dim desprovider As New DESCryptoServiceProvider()

 Sub Main()
    bData = HexStringToBytes(data)
    bKey = HexStringToBytes(key)
    Console.WriteLine(""Data: "" + data)
    Console.WriteLine(""Key: "" + key)
    Encrypt()
    Console.WriteLine(""Encryption Result :"" + GetHexString(bEncrypted))
    Decrypt()
    Console.WriteLine(""Decryption Result :"" + GetHexString(bDecrypted))
    Console.ReadLine()
 End Sub

 Private Function GetHexString(ByVal bytes() As Byte, Optional ByVal len As Integer = -1, Optional ByVal spaces As Boolean = False) As String
    If len = -1 Then len = bytes.Length
    Dim i As Integer
    Dim s As String = """"
    For i = 0 To len - 1
        s += bytes(i).ToString(""x2"")
        If spaces Then s += "" ""
    Next
    If spaces Then s = s.TrimEnd()
    Return s
 End Function

 Function HexStringToBytes(ByVal hexstring As String) As Byte()
    Dim out((hexstring.Length / 2) - 1) As Byte
    For i = 0 To (hexstring.Length / 2) - 1
        out(i) = Convert.ToByte(hexstring.Substring(i * 2, 2), 16)
    Next
    Return out
 End Function

 Sub Encrypt()
    Dim icryptT As ICryptoTransform = desprovider.CreateEncryptor(bKey, nullIV)
    icryptT.TransformBlock(bData, 0, bData.Length, bEncrypted, 0)
 End Sub

 Sub Decrypt()
    Dim icryptT As ICryptoTransform = desprovider.CreateDecryptor(bKey, nullIV)
    icryptT.TransformBlock(bEncrypted, 0, bEncrypted.Length, bDecrypted, 0)
 End Sub

End Module
</code></pre>

<p>Here's the output:</p>

<p>Data: 1234567887654321</p>

<p>Key: 1111222233334444</p>

<p>Encryption Result :cb8304b91ce6f9a1</p>

<p>Decryption Result :0000000000000000</p>

<p>As you can see in the output, the Encrypt() subroutine works just fine but it all goes wrong with the decryption part. The decryption is supposed to return my original data but it seems like there's nothing happening in the Decrypt() subroutine of the program.</p>
","<p>The <code>ICryptoTransform</code> provides a separate function: <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.icryptotransform.transformfinalblock%28v=vs.110%29.aspx"" rel=""nofollow""><code>TransformFinalBlock</code></a> that should be used when encrypting/decrypting the buffer that contains the last block of data, and ensures that necessary padding is added. Since you are only working with a single block, you should be using this method rather than <code>TransformBlock</code>. Note that <em>returns</em> the encrypted/decrypted data, rather than placing it in a buffer you pass as a parameter.</p>

<p>No answer regarding DES would be complete without mentioning that DES it's insecure, and more generally, that you should be using a unique, random IV each time the data is encrypted, but I'll assume this is mainly for practice, rather than intended for use protecting anything actually sensitive.</p>
","681","<vb.net><encryption><des>","1","1","1","2014-09-11 11:21:19","23101961","0","1","","","","2014-04-16 03:52:16",""
"17925215","Encrypt with node and Decrypt with Java","<p>I use DES to encrypt a String parameter in nodeJs, but how do i use DES decrypt  that properly in Java.</p>

<p>In nodejs I use this method to encrypt: <a href=""https://github.com/ElmerZhang/ezcrypto/blob/master/lib/des.js"" rel=""nofollow"">https://github.com/ElmerZhang/ezcrypto/blob/master/lib/des.js</a></p>

<pre><code>var DES = C.DES = {
_blockSize : 2,

_keyschedule : null,

_state : new State(),

_init : function(k) {
    this._keyschedule = new KeySchedule(k);
},

encrypt : function(message, password, options) {

    options = options || {};

    // Determine mode
    var mode = options.mode || new C.mode.OFB;

    // Allow mode to override options
    if (mode.fixOptions)
        mode.fixOptions(options);

    var
    // Convert to bytes if message is a string
    m = (message.constructor == String ? UTF8.stringToBytes(message)
            : message),

    // Generate random IV
    iv = options.iv || util.randomBytes(8),

    // Generate key
    k = (password.constructor == String ?
    // Derive key from passphrase
    C.PBKDF2(password, iv, 8, {
        asBytes : true
    }) :
    // else, assume byte array representing cryptographic key
    password);

    // Create key schedule
    this._keyschedule = new KeySchedule(k);

    // Encrypt
    mode.encrypt(DES, m, iv);

    // Return ciphertext
    m = options.iv ? m : iv.concat(m);
    return (options &amp;&amp; options.asBytes) ? m : util.bytesToBase64(m);
},

_encryptBlock : function(message, offset) {
    this._state.initialPerm(message, offset);
    for ( var i = 0; i &lt;= 15; i++) {
        this._state.round(this._keyschedule.getKey(i));
    }
    this._state.finalPerm(message, offset);
}

};
</code></pre>

<p>and  this is my des decrypt in java:</p>

<pre><code>public class DES {

  private static byte[] iv = {1,2,3,4,5,6,7,8};

  public static String encryptDES(String encryptString, String encryptKey) throws Exception {
    IvParameterSpec zeroIv = new IvParameterSpec(iv);
    SecretKeySpec key = new SecretKeySpec(encryptKey.getBytes(), ""DES"");
    Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, zeroIv);
    byte[] encryptedData = cipher.doFinal(encryptString.getBytes());

    return Base64.encode(encryptedData);
  }

  public static String decryptDES(String decryptString, String decryptKey) throws Exception {
    byte[] byteMi = new Base64().decode(decryptString);
    IvParameterSpec zeroIv = new IvParameterSpec(iv);
    SecretKeySpec key = new SecretKeySpec(decryptKey.getBytes(), ""DES"");
    Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, key, zeroIv);
    byte decryptedData[] = cipher.doFinal(byteMi);

    return new String(decryptedData);
  }
}
</code></pre>
","","678","<java><node.js><encryption><des>","0","","0","2013-07-30 06:52:44","","6","2","474189","","2013-07-30 06:52:44","2013-07-29 13:21:19",""
"4756847","LNK2019 error when compiling code","<p>I have some sample code that I was editing in Visual Studio 2010 to encrypt and decrypt using DES. For some reason, when I compile the code i keep getting these two LNK2019 errors that are referring to the des_encrypt1() function and the des_set_key_checked() function.  As seen in my code, I made sure to include the des.h file and that file lists the definitions for both of those functions. I am new to C so I am not sure if it is something simple that I am overlooking but any help would be greatly appreciated.  I'm not sure how to correctly attach code here so sorry if the format looks weird but the bolded include below should say #include des.h.</p>

<pre><code>#include &lt;des.h&gt;


#define ENC 1
#define DEC 0

//extern des_encrypt1(DES_LONG *data,DES_key_schedule *ks, int enc);

//void des_set_key_checked(const_des_block *key, des_key_schedule *schedule)



int main()
{

int k;
long    in[2];
static unsigned char cbc_key[8] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
des_key_schedule key;
//struct timeval start, end;
//double t1, t2, t3, t4;

if ((k = des_set_key_checked(&amp;cbc_key,key)) != 0)
    printf(""\nkey error\n"");

in[0] = 3212314;
in[1] = 1231233;

printf(""DES Clear Text: %ld%ld\n"",in[0],in[1]);
//gettimeofday(&amp;start, NULL);
//t1=start.tv_sec+(start.tv_usec/1000000.0);
des_encrypt1(in,key,ENC);
//gettimeofday(&amp;end, NULL);
//t2=end.tv_sec+(end.tv_usec/1000000.0);
//printf(""Time for Encryption\n"", t2-t1);

printf(""DES Encryption: %u%u\n"",in[0],in[1]);
//gettimeofday(&amp;start, NULL);
//t3=start.tv_sec+(start.tv_usec/1000000.0);
des_encrypt1(in,key,DEC);
//gettimeofday(&amp;end, NULL);
//t4=end.tv_sec+(end.tv_usec/1000000.0);
//printf(""Time for Decryption\n"", t4-t3);
}
</code></pre>
","<p>If you are compiling the code as C++, but the header is written for C, you need to include it as follows:</p>

<pre><code>extern ""C"" {
    #include ""des.h""
}
</code></pre>
","665","<c><des><lnk2019>","1","0","2","2013-05-08 11:55:28","","2","","584178","","2011-01-21 09:14:52","2011-01-21 08:42:05",""
"4756847","LNK2019 error when compiling code","<p>I have some sample code that I was editing in Visual Studio 2010 to encrypt and decrypt using DES. For some reason, when I compile the code i keep getting these two LNK2019 errors that are referring to the des_encrypt1() function and the des_set_key_checked() function.  As seen in my code, I made sure to include the des.h file and that file lists the definitions for both of those functions. I am new to C so I am not sure if it is something simple that I am overlooking but any help would be greatly appreciated.  I'm not sure how to correctly attach code here so sorry if the format looks weird but the bolded include below should say #include des.h.</p>

<pre><code>#include &lt;des.h&gt;


#define ENC 1
#define DEC 0

//extern des_encrypt1(DES_LONG *data,DES_key_schedule *ks, int enc);

//void des_set_key_checked(const_des_block *key, des_key_schedule *schedule)



int main()
{

int k;
long    in[2];
static unsigned char cbc_key[8] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
des_key_schedule key;
//struct timeval start, end;
//double t1, t2, t3, t4;

if ((k = des_set_key_checked(&amp;cbc_key,key)) != 0)
    printf(""\nkey error\n"");

in[0] = 3212314;
in[1] = 1231233;

printf(""DES Clear Text: %ld%ld\n"",in[0],in[1]);
//gettimeofday(&amp;start, NULL);
//t1=start.tv_sec+(start.tv_usec/1000000.0);
des_encrypt1(in,key,ENC);
//gettimeofday(&amp;end, NULL);
//t2=end.tv_sec+(end.tv_usec/1000000.0);
//printf(""Time for Encryption\n"", t2-t1);

printf(""DES Encryption: %u%u\n"",in[0],in[1]);
//gettimeofday(&amp;start, NULL);
//t3=start.tv_sec+(start.tv_usec/1000000.0);
des_encrypt1(in,key,DEC);
//gettimeofday(&amp;end, NULL);
//t4=end.tv_sec+(end.tv_usec/1000000.0);
//printf(""Time for Decryption\n"", t4-t3);
}
</code></pre>
","<p>you need to include des.h from openssl/</p>

<pre><code>#include &lt;openssl/des.h&gt;
</code></pre>
","665","<c><des><lnk2019>","1","0","2","2013-05-08 11:55:28","","2","","584178","","2011-01-21 09:14:52","2011-01-21 08:42:05",""
"21901520","Perl DES CBC encryption results in more bytes","<p>I am using Perl to perform CBC DES encryption using the Crypt::CBC library:</p>

<pre><code>#!/usr/bin/perl
use Crypt::CBC;
$key  = ""\x4A\x6F\xC2\x2A\x44\xE2\xA4\x48""; 
$iv   = ""\x00\x00\x00\x00\x00\x00\x00\x00"";
$data = ""\x51\x55\x45\x53\x54\x49\x4F\x4E"";

print ""TXT-&gt;"", $data, ""\n"";
print ""HEX-&gt;"", unpack(""H*"", $data), ""\n"";
$cipher = Crypt::CBC-&gt;new(-literal_key =&gt; 1,
                    -key         =&gt; $key,
                    -iv          =&gt; $iv,
                    -header      =&gt; 'none');

$ciphertext = $cipher-&gt;encrypt($data);
print ""ENC-&gt;"", unpack(""H*"", $ciphertext), ""\n"";
</code></pre>

<p>The output of the code is:</p>

<pre><code>TXT-&gt;QUESTION
HEX-&gt;5155455354494f4e
ENC-&gt;8220553e09f1b31ba7691f3f7fb52416
</code></pre>

<p>My data is conveniently of size 64bits (16 hex digits) which is in accordance with the DES standard. According to Wikipedia </p>

<blockquote>
  <p>DES is the archetypal block cipher — an algorithm that takes a fixed-length string of plaintext bits and transforms it through a series of complicated operations into another ciphertext bitstring of the <strong>same length</strong></p>
</blockquote>

<p>Why is it that the encoded output is of longer byte length than the original input?</p>

<p>Thanks.</p>
","<p>The encrypted message is longer because it includes the IV. BTW, a fixed IV does not make sense, it should be random and newly generated for each message.</p>
","663","<perl><encryption><des><cbc-mode>","1","0","2","2014-04-04 12:29:15","21903543","0","","","","","2014-02-20 07:54:55",""
"21901520","Perl DES CBC encryption results in more bytes","<p>I am using Perl to perform CBC DES encryption using the Crypt::CBC library:</p>

<pre><code>#!/usr/bin/perl
use Crypt::CBC;
$key  = ""\x4A\x6F\xC2\x2A\x44\xE2\xA4\x48""; 
$iv   = ""\x00\x00\x00\x00\x00\x00\x00\x00"";
$data = ""\x51\x55\x45\x53\x54\x49\x4F\x4E"";

print ""TXT-&gt;"", $data, ""\n"";
print ""HEX-&gt;"", unpack(""H*"", $data), ""\n"";
$cipher = Crypt::CBC-&gt;new(-literal_key =&gt; 1,
                    -key         =&gt; $key,
                    -iv          =&gt; $iv,
                    -header      =&gt; 'none');

$ciphertext = $cipher-&gt;encrypt($data);
print ""ENC-&gt;"", unpack(""H*"", $ciphertext), ""\n"";
</code></pre>

<p>The output of the code is:</p>

<pre><code>TXT-&gt;QUESTION
HEX-&gt;5155455354494f4e
ENC-&gt;8220553e09f1b31ba7691f3f7fb52416
</code></pre>

<p>My data is conveniently of size 64bits (16 hex digits) which is in accordance with the DES standard. According to Wikipedia </p>

<blockquote>
  <p>DES is the archetypal block cipher — an algorithm that takes a fixed-length string of plaintext bits and transforms it through a series of complicated operations into another ciphertext bitstring of the <strong>same length</strong></p>
</blockquote>

<p>Why is it that the encoded output is of longer byte length than the original input?</p>

<p>Thanks.</p>
","<p>Working backward from the second block (a7691f3f7fb52416) gives 8a285d3601f9bb13, and XORed with the first block (8220553e09f1b31b) gives 0808080808080808 (HEX).  Something is producing the block value of 0808080808080808 as a second input block value.</p>

<p><img src=""https://i.stack.imgur.com/h6MXA.jpg"" alt=""CBC Values""></p>

<p>So all you have to do is figure out where the backspace characters came from as a second block input.</p>

<p>See <a href=""https://metacpan.org/pod/Crypt::CBC"" rel=""nofollow noreferrer"">https://metacpan.org/pod/Crypt::CBC</a></p>

<p>This:</p>

<pre><code>#!/usr/bin/perl

use Crypt::CBC;
$key  = ""\x4A\x6F\xC2\x2A\x44\xE2\xA4\x48""; 
$iv   = ""\x00\x00\x00\x00\x00\x00\x00\x00"";
$data = ""\x51\x55\x45\x53\x54\x49\x4F\x4E"";

print ""TXT-&gt;"", $data, ""\n"";
print ""HEX-&gt;"", unpack(""H*"", $data), ""\n"";
$cipher = Crypt::CBC-&gt;new(-literal_key =&gt; 1,
                    -key         =&gt; $key,
                    -iv          =&gt; $iv,
                    -header      =&gt; 'none',
                    -padding     =&gt; 'null');

$ciphertext = $cipher-&gt;encrypt($data);

print ""ENC-&gt;"", unpack(""H*"", $ciphertext), ""\n"";
</code></pre>

<p>Gave:</p>

<blockquote>
  <p>david_koontz@Macbook: cbc_des<br>
  TXT->QUESTION<br>
  HEX->5155455354494f4e<br>
  ENC->8220553e09f1b31b<br>
  david_koontz@Macbook:  </p>
</blockquote>

<p>I made the mistake poking around because I know a fair bit about DES, not so much perl.</p>

<p>Adding the padding null seemed to do the trick, after I learned how to add Crypt::CBC and Crypt::DES to a perl library.</p>

<p>I used <a href=""http://code.google.com/p/dpades/source/browse/trunk/simu_js/JS-DES.html"" rel=""nofollow noreferrer"">http://code.google.com/p/dpades/source/browse/trunk/simu_js/JS-DES.html</a> to do the encryptions and decryptions necessary to figure out what's going on.  Use the view raw file button and save JS-DES.html locally, open it with a browser.</p>
","663","<perl><encryption><des><cbc-mode>","1","3","2","2014-04-04 12:29:15","21903543","0","","","","","2014-02-20 07:54:55",""
"42707419","C - crypt() - Code takes longer to execute with 5 loops or more than with 4 loops but using the same parameter/hash","<p>I'm taking an edx course called CS50. Maybe some of you are familiar with it.</p>

<p>One of the problems set asks you to implement an algorithm to crack a password that was hashed using des-based encryption and is up to 4 characters. </p>

<p>So far, so good. I've done it.</p>

<p>But I decided to improve it a little bit and make it possible to crack passwords that are up to 8 characters, which is the maximum for des-based encryption.</p>

<p>And the problem is, when I add the possibility of the fifth character (or more), my code doesn't work anymore.</p>

<p>Here are my codes</p>

<p>This one is working: </p>

<pre><code>#define _XOPEN_SOURCE

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

/*
    Use this to compile 

    clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wshadow crack4.c -lcrypt -lm -o crack4

*/


int main(int argc, char *argv[])
{
    if (argc != 2) //Checks if number of command-line arguments is valid
    {
        printf (""usage: ./crack + hash \n"");
        return 1; //Retuns 1 (error)
    }

    char *hash = argv[1]; //Gets hash passed as argument

    char salt[3]; //Gets the salt
    salt[0] = hash[0];
    salt[1] = hash[1];
    salt[2] = '\0';


    //All possible characters used in a DES-based hashed password (taken from gnu library)
    const char *const seedchars = "" ./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""; 

    char text[9] = ""\0""; //Text that is gonna be tried with crypt()




    for (int d = 0; d &lt;= 64 ; d++) //To check for passwords of up to 4 characters
    {
        printf(""d %d \n"", d);
        if(d &gt; 0)
        {
            text[4] = '\0'; //Defining null-terminator at index 4    
            text[3] = seedchars[d]; //Iterates through the seedchars list at index 3
        }

        for (int c = 0; c &lt;= 64 ; c++) //To check for passwords of up to 3 characters
        {
            if(c &gt; 0) 
            {
                if (d == 0)
                {
                    text[3] = '\0'; //Defining null-terminator at index 3
                }
                text[2] = seedchars[c]; //Iterates through the seedchars list at index 2
            }

            for (int b = 0; b &lt;= 64 ; b++) //To check for passwords of up to 2 characters
            {
                if(b &gt; 0)
                {
                    if (c == 0 &amp;&amp; d == 0)
                    {
                        text[2] = '\0'; //Defining null-terminator at index 2
                    }
                    text[1] = seedchars[b]; //Iterates through the seedchars list at index 1
                }

                for (int a = 0; a &lt;= 64 ; a++) //To check for passwords of up to 1 character
                {
                    if(b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0)
                    {
                        text[1] = '\0'; //Defining null-terminator at index 1
                    }

                    text[0] = seedchars[a]; //Iterates through the seedchars list at index 0

                    char *password = crypt(text, salt); //Hash var text and save it to var password

                    if (strcmp(hash, password) == 0)  //Compares the hash passed as argv with created above
                    {
                        printf(""%s\n"", text); //prints the text that led to said hash
                        return 0; //Returns 0 (okay)
                    }
                }   
            }   
        }
    }

    return 1; //Retuns 1 (error)
}
</code></pre>

<p>This one isn't working: </p>

<pre><code>#define _XOPEN_SOURCE

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

/*
    Use this to compile 

    clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wshadow crack.c -lcrypt -lm -o crack

*/


int main(int argc, char *argv[])
{
    if (argc != 2) //Checks if number of command-line arguments is valid
    {
        printf (""usage: ./crack + hash \n"");
        return 1; //Retuns 1 (error)
    }

    char *hash = argv[1]; //Gets hash passed as argument

    char salt[3]; //Gets the salt
    salt[0] = hash[0];
    salt[1] = hash[1];
    salt[2] = '\0';


    //All possible characters used in a DES-based hashed password (taken from gnu library)
    const char *const seedchars = ""./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""; 

    char text[9] = ""\0""; //Text that is gonna be tried with crypt()

    for (int h = 0; h &lt;= 64 ; h++) //To check for passwords of up to 8 characters
    {
        if(h &gt; 0)
        {
            text[8] = '\0'; //Defining null-terminator at index 8    
            text[7] = seedchars[h]; //Iterates through the seedchars list at index 7
        }

        for (int g = 0; g &lt;= 64 ; g++) //To check for passwords of up to 7 characters
        {
            if(g &gt; 0)
            {
                if (h == 0)
                {
                    text[7] = '\0'; //Defining null-terminator at index 7    
                }
                text[6] = seedchars[g]; //Iterates through the seedchars list at index 6
            }

            for (int f = 0; f &lt;= 64 ; f++) //To check for passwords of up to 6 characters
            {
                if(f &gt; 0)
                {
                    if (g == 0 &amp;&amp; h == 0)
                    {
                        text[6] = '\0'; //Defining null-terminator at index 6    
                    }
                    text[5] = seedchars[f]; //Iterates through the seedchars list at index 5
                }

                for (int e = 0; e &lt;= 64 ; e++) //To check for passwords of up to 5 characters
                {
                    if(e &gt; 0)
                    {
                        if (f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                        {
                            text[5] = '\0'; //Defining null-terminator at index 5    
                        }
                        text[4] = seedchars[e]; //Iterates through the seedchars list at index 4

                        for (int d = 0; d &lt;= 64 ; d++) //To check for passwords of up to 4 characters
                        {
                            printf(""d %d \n"", d);
                            if(d &gt; 0)
                            {
                                if (e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                                {
                                    text[4] = '\0'; //Defining null-terminator at index 4    
                                }
                                text[3] = seedchars[d]; //Iterates through the seedchars list at index 3
                            }

                            for (int c = 0; c &lt;= 64 ; c++) //To check for passwords of up to 3 characters
                            {
                                if(c &gt; 0) 
                                {
                                    if (d == 0 &amp;&amp; e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                                    {
                                        text[3] = '\0'; //Defining null-terminator at index 3
                                    }
                                    text[2] = seedchars[c]; //Iterates through the seedchars list at index 2
                                }

                                for (int b = 0; b &lt;= 64 ; b++) //To check for passwords of up to 2 characters
                                {
                                    if(b &gt; 0)
                                    {
                                        if (c == 0 &amp;&amp; d == 0 &amp;&amp; e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0) 
                                        {
                                            text[2] = '\0'; //Defining null-terminator at index 2
                                        }
                                        text[1] = seedchars[b]; //Iterates through the seedchars list at index 1
                                    }

                                    for (int a = 0; a &lt;= 64 ; a++) //To check for passwords of up to 1 character
                                    {                                   
                                        if(b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0 &amp;&amp; e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                                        {
                                            text[1] = '\0'; //Defining null-terminator at index 1
                                        }

                                        text[0] = seedchars[a]; //Iterates through the seedchars list at index 0

                                        char *password = crypt(text, salt); //Hash var text and save it to var password

                                        if (strcmp(hash, password) == 0)  //Compares the hash passed as argv with created above
                                        {
                                            printf(""%s\n"", text); //prints the text that led to said hash
                                            return 0; //Returns 0 (okay)
                                        }
                                    }   
                                }   
                            }
                        }
                    }
                }
            }
        }
    }
    return 1; //Retuns 1 (error)
}
</code></pre>

<p>I'm using the hash below in both codes but it doesn't work on the second code.</p>

<pre><code>hash - 50fkUxYHbnXGw
text - rofl  
</code></pre>

<p>Can someone please help me understand why is it not working?</p>

<p>Thanks.</p>

<p>Edit:</p>

<p>The second code just finished running and it actually is working but it's taking way longer to crack the password. Here's a screenshot:</p>

<p>I'm not being able to post it as a image for some reason, so here's the link <a href=""https://imgur.com/a/GVWar"" rel=""nofollow noreferrer"">http://imgur.com/a/GVWar</a> </p>

<p>Edit 2: adding link to image and fixing title</p>

<p>Edit 3: re-fixing title</p>
","<p>In the first case, for 4 characters, you have 4 nested loops. Which ""for"" will execute up to 64 times. So your code may run 64 ^ 4 = 16 million times.</p>

<p>In the second case, for 8 characters, you have 8 nested loops. That makes 64 ^ 8 = 281 trillion times.</p>

<p>The time your computer takes to execute the algoritm is proportional to that amount of loops.</p>

<p>It grows so fast because your algorithm is exponential on the number of characters. If you want to learn more, search for ""algorithm asymptotic notation"".</p>
","660","<c><hash><des><cs50><crypt>","-1","3","2","2017-03-19 01:39:34","","4","","7158475","","2017-03-10 14:06:51","2017-03-09 23:22:18",""
"42707419","C - crypt() - Code takes longer to execute with 5 loops or more than with 4 loops but using the same parameter/hash","<p>I'm taking an edx course called CS50. Maybe some of you are familiar with it.</p>

<p>One of the problems set asks you to implement an algorithm to crack a password that was hashed using des-based encryption and is up to 4 characters. </p>

<p>So far, so good. I've done it.</p>

<p>But I decided to improve it a little bit and make it possible to crack passwords that are up to 8 characters, which is the maximum for des-based encryption.</p>

<p>And the problem is, when I add the possibility of the fifth character (or more), my code doesn't work anymore.</p>

<p>Here are my codes</p>

<p>This one is working: </p>

<pre><code>#define _XOPEN_SOURCE

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

/*
    Use this to compile 

    clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wshadow crack4.c -lcrypt -lm -o crack4

*/


int main(int argc, char *argv[])
{
    if (argc != 2) //Checks if number of command-line arguments is valid
    {
        printf (""usage: ./crack + hash \n"");
        return 1; //Retuns 1 (error)
    }

    char *hash = argv[1]; //Gets hash passed as argument

    char salt[3]; //Gets the salt
    salt[0] = hash[0];
    salt[1] = hash[1];
    salt[2] = '\0';


    //All possible characters used in a DES-based hashed password (taken from gnu library)
    const char *const seedchars = "" ./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""; 

    char text[9] = ""\0""; //Text that is gonna be tried with crypt()




    for (int d = 0; d &lt;= 64 ; d++) //To check for passwords of up to 4 characters
    {
        printf(""d %d \n"", d);
        if(d &gt; 0)
        {
            text[4] = '\0'; //Defining null-terminator at index 4    
            text[3] = seedchars[d]; //Iterates through the seedchars list at index 3
        }

        for (int c = 0; c &lt;= 64 ; c++) //To check for passwords of up to 3 characters
        {
            if(c &gt; 0) 
            {
                if (d == 0)
                {
                    text[3] = '\0'; //Defining null-terminator at index 3
                }
                text[2] = seedchars[c]; //Iterates through the seedchars list at index 2
            }

            for (int b = 0; b &lt;= 64 ; b++) //To check for passwords of up to 2 characters
            {
                if(b &gt; 0)
                {
                    if (c == 0 &amp;&amp; d == 0)
                    {
                        text[2] = '\0'; //Defining null-terminator at index 2
                    }
                    text[1] = seedchars[b]; //Iterates through the seedchars list at index 1
                }

                for (int a = 0; a &lt;= 64 ; a++) //To check for passwords of up to 1 character
                {
                    if(b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0)
                    {
                        text[1] = '\0'; //Defining null-terminator at index 1
                    }

                    text[0] = seedchars[a]; //Iterates through the seedchars list at index 0

                    char *password = crypt(text, salt); //Hash var text and save it to var password

                    if (strcmp(hash, password) == 0)  //Compares the hash passed as argv with created above
                    {
                        printf(""%s\n"", text); //prints the text that led to said hash
                        return 0; //Returns 0 (okay)
                    }
                }   
            }   
        }
    }

    return 1; //Retuns 1 (error)
}
</code></pre>

<p>This one isn't working: </p>

<pre><code>#define _XOPEN_SOURCE

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

/*
    Use this to compile 

    clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wshadow crack.c -lcrypt -lm -o crack

*/


int main(int argc, char *argv[])
{
    if (argc != 2) //Checks if number of command-line arguments is valid
    {
        printf (""usage: ./crack + hash \n"");
        return 1; //Retuns 1 (error)
    }

    char *hash = argv[1]; //Gets hash passed as argument

    char salt[3]; //Gets the salt
    salt[0] = hash[0];
    salt[1] = hash[1];
    salt[2] = '\0';


    //All possible characters used in a DES-based hashed password (taken from gnu library)
    const char *const seedchars = ""./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""; 

    char text[9] = ""\0""; //Text that is gonna be tried with crypt()

    for (int h = 0; h &lt;= 64 ; h++) //To check for passwords of up to 8 characters
    {
        if(h &gt; 0)
        {
            text[8] = '\0'; //Defining null-terminator at index 8    
            text[7] = seedchars[h]; //Iterates through the seedchars list at index 7
        }

        for (int g = 0; g &lt;= 64 ; g++) //To check for passwords of up to 7 characters
        {
            if(g &gt; 0)
            {
                if (h == 0)
                {
                    text[7] = '\0'; //Defining null-terminator at index 7    
                }
                text[6] = seedchars[g]; //Iterates through the seedchars list at index 6
            }

            for (int f = 0; f &lt;= 64 ; f++) //To check for passwords of up to 6 characters
            {
                if(f &gt; 0)
                {
                    if (g == 0 &amp;&amp; h == 0)
                    {
                        text[6] = '\0'; //Defining null-terminator at index 6    
                    }
                    text[5] = seedchars[f]; //Iterates through the seedchars list at index 5
                }

                for (int e = 0; e &lt;= 64 ; e++) //To check for passwords of up to 5 characters
                {
                    if(e &gt; 0)
                    {
                        if (f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                        {
                            text[5] = '\0'; //Defining null-terminator at index 5    
                        }
                        text[4] = seedchars[e]; //Iterates through the seedchars list at index 4

                        for (int d = 0; d &lt;= 64 ; d++) //To check for passwords of up to 4 characters
                        {
                            printf(""d %d \n"", d);
                            if(d &gt; 0)
                            {
                                if (e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                                {
                                    text[4] = '\0'; //Defining null-terminator at index 4    
                                }
                                text[3] = seedchars[d]; //Iterates through the seedchars list at index 3
                            }

                            for (int c = 0; c &lt;= 64 ; c++) //To check for passwords of up to 3 characters
                            {
                                if(c &gt; 0) 
                                {
                                    if (d == 0 &amp;&amp; e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                                    {
                                        text[3] = '\0'; //Defining null-terminator at index 3
                                    }
                                    text[2] = seedchars[c]; //Iterates through the seedchars list at index 2
                                }

                                for (int b = 0; b &lt;= 64 ; b++) //To check for passwords of up to 2 characters
                                {
                                    if(b &gt; 0)
                                    {
                                        if (c == 0 &amp;&amp; d == 0 &amp;&amp; e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0) 
                                        {
                                            text[2] = '\0'; //Defining null-terminator at index 2
                                        }
                                        text[1] = seedchars[b]; //Iterates through the seedchars list at index 1
                                    }

                                    for (int a = 0; a &lt;= 64 ; a++) //To check for passwords of up to 1 character
                                    {                                   
                                        if(b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0 &amp;&amp; e == 0 &amp;&amp; f == 0 &amp;&amp; g == 0 &amp;&amp; h == 0)
                                        {
                                            text[1] = '\0'; //Defining null-terminator at index 1
                                        }

                                        text[0] = seedchars[a]; //Iterates through the seedchars list at index 0

                                        char *password = crypt(text, salt); //Hash var text and save it to var password

                                        if (strcmp(hash, password) == 0)  //Compares the hash passed as argv with created above
                                        {
                                            printf(""%s\n"", text); //prints the text that led to said hash
                                            return 0; //Returns 0 (okay)
                                        }
                                    }   
                                }   
                            }
                        }
                    }
                }
            }
        }
    }
    return 1; //Retuns 1 (error)
}
</code></pre>

<p>I'm using the hash below in both codes but it doesn't work on the second code.</p>

<pre><code>hash - 50fkUxYHbnXGw
text - rofl  
</code></pre>

<p>Can someone please help me understand why is it not working?</p>

<p>Thanks.</p>

<p>Edit:</p>

<p>The second code just finished running and it actually is working but it's taking way longer to crack the password. Here's a screenshot:</p>

<p>I'm not being able to post it as a image for some reason, so here's the link <a href=""https://imgur.com/a/GVWar"" rel=""nofollow noreferrer"">http://imgur.com/a/GVWar</a> </p>

<p>Edit 2: adding link to image and fixing title</p>

<p>Edit 3: re-fixing title</p>
","<p>You can think of a - h as wheels of comprised of 65 characters, with indexes 0 through 64. The last character is a line terminator from the declared value.</p>

<p>If you were to add a printf for the value of e:</p>

<pre><code>crack08 50fkUxYHbnXGw
e 1
d 0
d 1
d 2
d 3
d 4
d 5
d 6
d 7
d 8
d 9
d 10
d 11
d 12
d 13
d 14
d 15
d 16
d 17
d 18
d 19
d 20
d 21
d 22
d 23
...
d 63
d 64
e 2
d 0
d 1
d 2
...
</code></pre>

<p>You'd see we'd skip over the first value of e because h - f are 0.</p>

<p>Finding a 4 character match is then deferred until e = 64 (the 65th index the '\0' string terminator).</p>

<p>That represents more than 65 times longer before finding a 4 character password.</p>

<p>Getting rid of the extra passes involves reorganizing the 'wheel' of characters used, adding a '\0' character as the first character, using that as string terminator for the first pass and skipping over it for subsequent passes:</p>

<pre><code>#define _XOPEN_SOURCE

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[])
{
    if (argc != 2) {
        printf (""usage: ./crack  hash\n"");
        return 1; //Retuns 1 (error)
    }
    char *hash = argv[1];
    char salt[3];
    salt[0] = hash[0];
    salt[1] = hash[1];
    salt[2] = '\0';

# define WHEEL_SIZE 65  // all possible password characters 
                        // plus null character for shorter strings

    char seedchars[WHEEL_SIZE] = 
        ""@./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";
    char text[9];    // Text that is gonna be tried with crypt()
    text[8] = '\0';  // for h &gt; 0
    seedchars[0] = '\0';  // test for short strings first
    int a_first = 0;
    int b_first = 0;
    int c_first = 0;
    int d_first = 0;
    int e_first = 0;
    int f_first = 0;
    int g_first = 0;

    for (int h = 0; h &lt;= WHEEL_SIZE - 1 ; h++) {
        text[7] = seedchars[h];

        for (int g = g_first ; g &lt;= WHEEL_SIZE - 1; g++) {
            text[6] = seedchars[g];

            for (int f = f_first; f &lt;= WHEEL_SIZE -1; f++) {
                text[5] = seedchars[f];

                for (int e = e_first; e &lt;= WHEEL_SIZE - 1; e++) {
                     printf(""e %2d\n"", e);
                    text[4] = seedchars[e];

                        for (int d = d_first; d &lt;= WHEEL_SIZE - 1; d++) {
                            printf(""d %2d\n"", d);
                            text[3] = seedchars[d];

                            for (int c = c_first; c &lt;= WHEEL_SIZE - 1; c++) {
                                if (c &gt; 0) 
                                    b_first = 1;
                                text[2] = seedchars[c];
                                for (int b = b_first; b &lt;= WHEEL_SIZE - 1; b++) {
                                        text[1] = seedchars[b];
                                    for (int a = a_first; a &lt;= WHEEL_SIZE - 1; a++) {
                                        text[0] = seedchars[a];

                                        char *password = crypt(text, salt); 
                                        if (strcmp(hash, password) == 0) {
                                            printf(""%s\n"", text);
                                            return 0;
                                        }
                                    }
                                    b_first = 1;   
                                }
                                c_first = 1;
                            }
                            c_first = 1;
                        }
                        d_first = 1;
                    }
                    e_first = 1;
                }
                f_first = 1;
            }
            g_first = 1;
        }
    return 1;
}
</code></pre>

<p>And that gives us the answer in the minimum time:</p>

<pre><code>crack 50fkUxYHbnXGw
e  0
d  0
d  1
d  2
d  3
d  4
d  5
d  6
d  7
d  8
d  9
d 10
d 11
d 12
d 13
d 14
d 15
d 16
d 17
d 18
d 19
d 20
d 21
d 22
d 23
d 24
d 25
d 26
d 27
d 28
d 29
d 30
d 31
d 32
d 33
d 34
d 35
d 36
d 37
d 38
d 39
d 40
d 41
d 42
d 43
d 44
d 45
d 46
d 47
d 48
d 49
d 50
rofl
</code></pre>

<p>A much more satisfactory answer.</p>
","660","<c><hash><des><cs50><crypt>","-1","0","2","2017-03-19 01:39:34","","4","","7158475","","2017-03-10 14:06:51","2017-03-09 23:22:18",""
"39904818","encryption/decryption of multiple keys","<p>whether there are adequate ways to make the encryption / decryption of files using several different keys? That is, it is possible to make a group of n keys so that any of the group key could encrypt file and also with any of the group key to decrypt the file? (Of course, provided that no other key, in addition to these n group keys to decrypt the file could not be?)</p>
","<p>There isn't a way to encrypt with only one key, and be able to decrypt with several other keys individually.</p>

<p>You could have a group key that is encrypted by several keys, so those keys can decrypt the group key as needed, and the group key can be used to encrypt/decrypt data that is shared between users with different keys.</p>

<p>You could do the same thing with the data itself, but this means all keys need to be available for encryption, which doesn't seem to meet your use case.</p>
","654","<encryption><aes><des>","0","2","1","2017-07-25 13:46:30","45305263","6","","","","","2016-10-06 20:09:10",""
"19803505","Is 3DES = DES do 3 times?","<p>I have done a DES Util class according to <a href=""http://www.mkyong.com/java/jce-encryption-data-encryption-standard-des-tutorial/"" rel=""nofollow"">mkyong's JCE Encryption – Data Encryption Standard (DES) Tutorial</a></p>

<p>Here's my class:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import tw.com.januarytc.android.singularsdk.lib.JsLib;
import android.util.Log;

public class DESUtil
{
  private KeyGenerator keyGen=null;
  private SecretKey sKey=null;
  private Cipher desCip=null;

  /**
   * Init. DES utility class
   * @return boolean
   */
  public boolean init()
  {
    boolean b=false;

    try
    {
      keyGen=KeyGenerator.getInstance(""DES"");
      sKey=keyGen.generateKey();
      desCip=Cipher.getInstance(""DES/ECB/PKCS5Padding"");
      b=true;
    }
    catch(Exception e)
    {
      Log.d(JsLib.TAG, ""Init DESUtil failed: ""+e.toString());
      e.printStackTrace();
      b=false;
    }
    return b;
  }

  /**
   * Encrypt string with DES
   * @param str - Original string
   * @return java.lang.String DES encrypted string
   * @throws IllegalStateException
   */
  public String encryptString(String str) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.ENCRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(str.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }

  /**
   * Decrypt string which encrypted by DES
   * @param str - DES encrypted string
   * @return java.lang.String Original string
   * @throws IllegalStateException
   */
  public String decryptString(String strDes) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.DECRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(strDes.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }
}
</code></pre>

<p>And as WiKi said:</p>

<p>In cryptography, Triple DES is the common name for the Triple Data Encryption Algorithm (TDEA or Triple DEA) block cipher, which <strong>applies the Data Encryption Standard (DES) cipher algorithm three times to each data block</strong>.</p>

<p>I'm just wondering what if I encrypt a string with DES for 3 times...Will it equals 3DES ?</p>

<p>Thanks for suggestions, and sorry for my poor english~</p>
","<p><code>3DES</code> does perform <code>DES</code> 3 times, but with three different keys. This algorithm was designed to get around DES's inherent lack of security associated with the original key size.</p>
","649","<java><android><des><3des>","1","3","2","2013-11-06 03:35:40","19803613","0","3","","","","2013-11-06 03:21:55",""
"19803505","Is 3DES = DES do 3 times?","<p>I have done a DES Util class according to <a href=""http://www.mkyong.com/java/jce-encryption-data-encryption-standard-des-tutorial/"" rel=""nofollow"">mkyong's JCE Encryption – Data Encryption Standard (DES) Tutorial</a></p>

<p>Here's my class:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import tw.com.januarytc.android.singularsdk.lib.JsLib;
import android.util.Log;

public class DESUtil
{
  private KeyGenerator keyGen=null;
  private SecretKey sKey=null;
  private Cipher desCip=null;

  /**
   * Init. DES utility class
   * @return boolean
   */
  public boolean init()
  {
    boolean b=false;

    try
    {
      keyGen=KeyGenerator.getInstance(""DES"");
      sKey=keyGen.generateKey();
      desCip=Cipher.getInstance(""DES/ECB/PKCS5Padding"");
      b=true;
    }
    catch(Exception e)
    {
      Log.d(JsLib.TAG, ""Init DESUtil failed: ""+e.toString());
      e.printStackTrace();
      b=false;
    }
    return b;
  }

  /**
   * Encrypt string with DES
   * @param str - Original string
   * @return java.lang.String DES encrypted string
   * @throws IllegalStateException
   */
  public String encryptString(String str) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.ENCRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(str.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }

  /**
   * Decrypt string which encrypted by DES
   * @param str - DES encrypted string
   * @return java.lang.String Original string
   * @throws IllegalStateException
   */
  public String decryptString(String strDes) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.DECRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(strDes.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }
}
</code></pre>

<p>And as WiKi said:</p>

<p>In cryptography, Triple DES is the common name for the Triple Data Encryption Algorithm (TDEA or Triple DEA) block cipher, which <strong>applies the Data Encryption Standard (DES) cipher algorithm three times to each data block</strong>.</p>

<p>I'm just wondering what if I encrypt a string with DES for 3 times...Will it equals 3DES ?</p>

<p>Thanks for suggestions, and sorry for my poor english~</p>
","<p>DES uses a short 56 bit key, which was vulnerable to brute force attacks. 3DES uses 168 bit keys (56x3), and performs the encryption like so:</p>

<ol>
<li>Encrypt clear text using the 1st 56 bits of the key, produce output1</li>
<li><strong>Decrypt</strong> output1 using the 2nd 56 bits of the key, produce output2</li>
<li>Encrypt output2 using the 3rd 56 bits of they, produce encrypted text.</li>
</ol>

<p>Her's a reference:
<a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">http://en.wikipedia.org/wiki/Triple_DES</a></p>
","649","<java><android><des><3des>","1","4","2","2013-11-06 03:35:40","19803613","0","3","","","","2013-11-06 03:21:55",""
"21551514","DES decryption issue","<p>I am using DES decryption with ECB mode. I am using the following code for decryption :</p>

<pre><code>NSString *token = @""kRAz86UoZd5tFKf0xv8TKg=="";
NSString *key = @""meristem"";

const void *vplainText;
size_t plainTextBufferSize;

NSData *EncryptData = [[NSData alloc] initWithBase64EncodedString:token options:0];
plainTextBufferSize = [EncryptData length];
vplainText = [EncryptData bytes];

//plainTextBufferSize = [token length];
//vplainText = (const void *) [token UTF8String];

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

NSString *initVec = @""init Vec"";
const void *vkey = (const void *) [key UTF8String];
const void *vinitVec;
vinitVec = (const void *) [initVec UTF8String];

ccStatus = CCCrypt(kCCDecrypt,
                   kCCAlgorithmDES,
                   kCCOptionPKCS7Padding | kCCOptionECBMode,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySizeDES,
                   NULL,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
NSString *decodedString = [[NSString alloc] initWithData:myData encoding:NSUTF8StringEncoding];
NSLog(@""dis is data %@"",decodedString);
</code></pre>

<p>Here, you can see that my encrypted string is <strong>kRAz86UoZd5tFKf0xv8TKg==</strong> and its result is <strong>vishal thakur</strong>. But by using the above code for decryption, I am getting only <strong>vishal t</strong>. I cant understand why am not getting the full string. Please can anyone tell me what I am doing wrong.</p>
","<p><strong>Edited:</strong>
I think it has something to do with <code>plainTextBufferSize</code>, and this cause the problem as you call it in your <code>CCCrypt</code> function.</p>

<p>Try changing its value before <code>CCCrypt</code> function.</p>
","649","<ios><iphone><objective-c><encryption><des>","4","1","2","2014-02-18 19:06:48","21552316","2","1","2311023","","2014-02-18 19:06:48","2014-02-04 11:41:28",""
"21551514","DES decryption issue","<p>I am using DES decryption with ECB mode. I am using the following code for decryption :</p>

<pre><code>NSString *token = @""kRAz86UoZd5tFKf0xv8TKg=="";
NSString *key = @""meristem"";

const void *vplainText;
size_t plainTextBufferSize;

NSData *EncryptData = [[NSData alloc] initWithBase64EncodedString:token options:0];
plainTextBufferSize = [EncryptData length];
vplainText = [EncryptData bytes];

//plainTextBufferSize = [token length];
//vplainText = (const void *) [token UTF8String];

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

NSString *initVec = @""init Vec"";
const void *vkey = (const void *) [key UTF8String];
const void *vinitVec;
vinitVec = (const void *) [initVec UTF8String];

ccStatus = CCCrypt(kCCDecrypt,
                   kCCAlgorithmDES,
                   kCCOptionPKCS7Padding | kCCOptionECBMode,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySizeDES,
                   NULL,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
NSString *decodedString = [[NSString alloc] initWithData:myData encoding:NSUTF8StringEncoding];
NSLog(@""dis is data %@"",decodedString);
</code></pre>

<p>Here, you can see that my encrypted string is <strong>kRAz86UoZd5tFKf0xv8TKg==</strong> and its result is <strong>vishal thakur</strong>. But by using the above code for decryption, I am getting only <strong>vishal t</strong>. I cant understand why am not getting the full string. Please can anyone tell me what I am doing wrong.</p>
","<p>I have solved my issue by replacing this line </p>

<pre><code>plainTextBufferSize = [EncryptData length];  
</code></pre>

<p>into </p>

<pre><code>plainTextBufferSize = [EncryptData length]+1;
</code></pre>
","649","<ios><iphone><objective-c><encryption><des>","4","2","2","2014-02-18 19:06:48","21552316","2","1","2311023","","2014-02-18 19:06:48","2014-02-04 11:41:28",""
"15813372","ODI | Decrypt a file Using DES","<p>I have a file encrypted using DES algorithm. I want to decrypt the file in ODI (Oracle data integrator) by writing procedure in Jython. I have explored the built-in functions, but I am unable to find one for decryption. 
How can I do this?</p>
","<p>You can use Python based libraries.</p>

<p>pyDes: <a href=""http://twhiteman.netfirms.com/des.html"" rel=""nofollow noreferrer"">http://twhiteman.netfirms.com/des.html</a></p>

<p>pycrypto: <a href=""https://www.dlitz.net/software/pycrypto/"" rel=""nofollow noreferrer"">https://www.dlitz.net/software/pycrypto/</a></p>

<p><a href=""https://stackoverflow.com/questions/2435283/using-des-3des-with-python"">using DES/3DES with python</a></p>
","641","<jython><des>","0","0","1","2013-05-09 14:06:58","","0","","","","","2013-04-04 13:57:33",""
"3884899","VB, DES and MD5","<p>Hello guys I am trying to migrate a Java code to VB, now I need to duplicate the DES encryption but I am having trouble with this part.</p>

<p>I admit I haven't done encryption since college.</p>

<p>This encrypt the key using MD5, and send it to a function for the DES encryption, seems I got a clue of the error, the key must be a 8 digit key and I am sending a 16 length key.</p>

<pre><code>Dim MD5 As New MD5CryptoServiceProvider()
        Dim dataHash() As Byte = MD5.ComputeHash(Encoding.UTF8.GetBytes(challenge + password))
        Dim sb As New StringBuilder
        Dim b As Byte
        For Each b In dataHash
            sb.Append(b.ToString(""x2"").ToLower())
        Next
        Dim md5Key As String = sb.ToString
        ''Dim md5Key As String = digestUtils.md5Hex(challenge + password)
        Dim geoEncrypt As New GeoEncriptamiento
        Dim challengeAnswer As String = geoEncrypt.EncryptFile(challenge, md5Key)
</code></pre>

<p>This is the code that does the encryption</p>

<pre><code>Function EncryptFile(ByVal esquema As String, ByVal llave As String) As String

    Dim DES As New DESCryptoServiceProvider()

    'Establecer la clave secreta para el algoritmo DES.
    'Se necesita una clave de 64 bits y IV para este proveedor
    DES.Key = UTF8Encoding.UTF8.GetBytes(llave)
    DES.IV = UTF8Encoding.UTF8.GetBytes(llave)
    Try
        Dim inputByteArray() As Byte = Encoding.UTF8.GetBytes(esquema)
        Dim ms As New MemoryStream
        Dim cs As New CryptoStream(MS, DES.CreateEncryptor(DES.Key, DES.IV), CryptoStreamMode.Write)
        cs.Write(inputByteArray, 0, inputByteArray.Length)
        cs.FlushFinalBlock()
        Return Convert.ToBase64String(ms.ToArray())
    Catch ex As Exception
        Return ""Error""
    End Try
End Function
</code></pre>

<p>The error is when I try to parse the MD5 to the DES.Key</p>
","<p>I'd check your use of UTF8Encoding.UTF8.GetBytes(llave)
That's likely converting the incoming 16 byte key into a format createencryptor isn't expecting.</p>

<p>createencryptor expects to see a key the same size as the BLOCKSIZE, which, according to the docs, is 64 BITS, or 8 bytes.</p>

<p>You're passing in a key of 16 bytes, because of this loop
        For Each b In dataHash
            sb.Append(b.ToString(""x2"").ToLower())
        Next</p>

<p>Also note that the computehash function returns an array of 16 bytes, not 8 bytes
""The ComputeHash methods of the MD5  class return the hash as an array of 16 bytes. Note that some MD5 implementations produce a 32-character, hexadecimal-formatted hash. To interoperate with such implementations, format the return value of the ComputeHash methods as a hexadecimal value.""</p>

<p>Looks like you'll either need to use a different hash, or only use part of the 16 byte hash.</p>
","635","<vb.net><md5><des>","0","1","2","2013-12-22 20:45:49","3885921","0","","759866","","2013-12-22 20:45:49","2010-10-07 18:56:06",""
"3884899","VB, DES and MD5","<p>Hello guys I am trying to migrate a Java code to VB, now I need to duplicate the DES encryption but I am having trouble with this part.</p>

<p>I admit I haven't done encryption since college.</p>

<p>This encrypt the key using MD5, and send it to a function for the DES encryption, seems I got a clue of the error, the key must be a 8 digit key and I am sending a 16 length key.</p>

<pre><code>Dim MD5 As New MD5CryptoServiceProvider()
        Dim dataHash() As Byte = MD5.ComputeHash(Encoding.UTF8.GetBytes(challenge + password))
        Dim sb As New StringBuilder
        Dim b As Byte
        For Each b In dataHash
            sb.Append(b.ToString(""x2"").ToLower())
        Next
        Dim md5Key As String = sb.ToString
        ''Dim md5Key As String = digestUtils.md5Hex(challenge + password)
        Dim geoEncrypt As New GeoEncriptamiento
        Dim challengeAnswer As String = geoEncrypt.EncryptFile(challenge, md5Key)
</code></pre>

<p>This is the code that does the encryption</p>

<pre><code>Function EncryptFile(ByVal esquema As String, ByVal llave As String) As String

    Dim DES As New DESCryptoServiceProvider()

    'Establecer la clave secreta para el algoritmo DES.
    'Se necesita una clave de 64 bits y IV para este proveedor
    DES.Key = UTF8Encoding.UTF8.GetBytes(llave)
    DES.IV = UTF8Encoding.UTF8.GetBytes(llave)
    Try
        Dim inputByteArray() As Byte = Encoding.UTF8.GetBytes(esquema)
        Dim ms As New MemoryStream
        Dim cs As New CryptoStream(MS, DES.CreateEncryptor(DES.Key, DES.IV), CryptoStreamMode.Write)
        cs.Write(inputByteArray, 0, inputByteArray.Length)
        cs.FlushFinalBlock()
        Return Convert.ToBase64String(ms.ToArray())
    Catch ex As Exception
        Return ""Error""
    End Try
End Function
</code></pre>

<p>The error is when I try to parse the MD5 to the DES.Key</p>
","<p>The solution was simple, first we need to cut the string to just 8 positions (The 8 bytes it can get), and lastly to make it compatible add the cyphermode. Here is the code </p>

<pre><code>   Function EncryptFile(ByVal esquema As String, ByVal llave As String) As String
    Dim DES As New DESCryptoServiceProvider()
    DES.Mode = CipherMode.ECB
    Dim md5 As New MD5CryptoServiceProvider()
    DES.Key = UTF8Encoding.UTF8.GetBytes(llave.Substring(0, 8))
    DES.IV = UTF8Encoding.UTF8.GetBytes(llave.Substring(0, 8))
    Try
        Dim inputByteArray() As Byte = Encoding.UTF8.GetBytes(esquema)
        Dim ms As New MemoryStream
        Dim cs As New CryptoStream(ms, DES.CreateEncryptor(DES.Key, DES.IV), CryptoStreamMode.Write)
        cs.Write(inputByteArray, 0, inputByteArray.Length)
        cs.FlushFinalBlock()
        Return Convert.ToBase64String(ms.ToArray())
    Catch ex As Exception
        Return ""Error""
    End Try
End Function
</code></pre>
","635","<vb.net><md5><des>","0","0","2","2013-12-22 20:45:49","3885921","0","","759866","","2013-12-22 20:45:49","2010-10-07 18:56:06",""
"35580510","Padding exception in java 7:Caused by: javax.crypto.BadPaddingException: Given final block not properly padded","<p>Hi I am using tripedes key to read from input stream and write to output stream.
Getting this execption in java7/8:Caused by: javax.crypto.BadPaddingException: Given final block not properly padded</p>

<pre><code>byte[] passwd = Base64Util.decode(pwd);
bais = new ByteArrayInputStream(passwd);
baos = new ByteArrayOutputStream();
Cipher cipher = Cipher.getInstance(""DESede"");
cipher.init(Cipher.DECRYPT_MODE, key);
// Read bytes, decrypt, and write them out.
byte[] buffer = new byte[2048];
int bytesRead;
while ((bytesRead = bais.read(buffer)) != -1) {
    out.write(cipher.update(buffer, 0, bytesRead));
}
// Write out the final bunch of decrypted bytes
out.write(cipher.doFinal());
out.flush();
</code></pre>

<p>Can anyone please tell me what might be error in cipher.doFinal?</p>

<p>Update, encryption code copied from comment:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""DESede"");
cipher.init(Cipher.ENCRYPT_MODE, key);

// Create a special output stream to do the work for us
CipherOutputStream cos = new CipherOutputStream(out, cipher);

// Read from the input and write to the encrypting output stream
byte[] buffer = new byte[2048];
int bytesRead;
while ((bytesRead = in.read(buffer)) != -1) {
    cos.write(buffer, 0, bytesRead);
}
cos.close();
</code></pre>
","<p>If the input data is not always a multiple of the block size then padding must be added to the input data; specify padding, PKCS#5 is the preferred padding for DES/3DES.</p>

<p>The <code>getInstance</code> call is not fully specified, missing are the mode and padding options. Add the full specification such as: ""DESede/ECB/PKCS5Padding (168)"". See <a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html"" rel=""nofollow"">Class Cipher documentation</a>.</p>

<p>Do not use 3DES in new code, it is insecure and also do not use ECB mode, it too is insecure, see <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29"" rel=""nofollow"">ECB mode</a>, scroll down to the Penguin.</p>
","630","<java><encryption><des><badpaddingexception>","0","0","1","2016-02-23 15:48:43","35582013","2","2","451475","","2016-02-23 15:40:04","2016-02-23 14:44:21",""
"8196910","PHP blank space with 3DES Encrypt","<p>I have a problem (server side) when i encrypt data from a client and i send to webserver with Post Method.</p>

<p>i Use this Method to Encrypt from a C# Client</p>

<pre><code>public string Encrypt3DES(string strString)
    {
        DESCryptoServiceProvider DES = new DESCryptoServiceProvider();

        DES.Key = Encoding.GetBytes(this.Key);
        DES.Mode = CipherMode.ECB;
        DES.Padding = PaddingMode.Zeros;

        ICryptoTransform DESEncrypt = DES.CreateEncryptor();

        byte[] Buffer = encoding.GetBytes(strString);

        return Convert.ToBase64String(DESEncrypt.TransformFinalBlock(Buffer, 0, Buffer.Length));
    }
</code></pre>

<p>When i send ecrypted String to PHP if there was a + in that string,  php read it with a blank space. If instead there'isnt any '+' i haven't any problem.</p>

<p>For Example this is a Encrypted String 4aY+na42iaPg+aep== in C# when i read in php it's 
4aY a42iaPg aep== so if i decrypt if dont match with the correct word.</p>

<p>i use this script to start read method post</p>

<pre><code>   if (isset($_POST['doConvalid'])){    
if ($_POST['doConvalid']=='Convalid')
{
    foreach($_POST as $keys =&gt; $values) {
    $data[$keys] =($values); // post variables are filtered
}

$cheking=$data['check'];
echo(""Show checking = $checking""); //Here i read string with blank space instead +
</code></pre>

<p>Is there a way to fix it?</p>
","<p>You could replace the '+' with a different character (something not used by base64) for sending. Then replace that character back to '+' for decoding.</p>
","628","<php><encryption><des>","0","0","2","2011-11-19 20:22:50","8197009","0","","","","","2011-11-19 20:07:32",""
"8196910","PHP blank space with 3DES Encrypt","<p>I have a problem (server side) when i encrypt data from a client and i send to webserver with Post Method.</p>

<p>i Use this Method to Encrypt from a C# Client</p>

<pre><code>public string Encrypt3DES(string strString)
    {
        DESCryptoServiceProvider DES = new DESCryptoServiceProvider();

        DES.Key = Encoding.GetBytes(this.Key);
        DES.Mode = CipherMode.ECB;
        DES.Padding = PaddingMode.Zeros;

        ICryptoTransform DESEncrypt = DES.CreateEncryptor();

        byte[] Buffer = encoding.GetBytes(strString);

        return Convert.ToBase64String(DESEncrypt.TransformFinalBlock(Buffer, 0, Buffer.Length));
    }
</code></pre>

<p>When i send ecrypted String to PHP if there was a + in that string,  php read it with a blank space. If instead there'isnt any '+' i haven't any problem.</p>

<p>For Example this is a Encrypted String 4aY+na42iaPg+aep== in C# when i read in php it's 
4aY a42iaPg aep== so if i decrypt if dont match with the correct word.</p>

<p>i use this script to start read method post</p>

<pre><code>   if (isset($_POST['doConvalid'])){    
if ($_POST['doConvalid']=='Convalid')
{
    foreach($_POST as $keys =&gt; $values) {
    $data[$keys] =($values); // post variables are filtered
}

$cheking=$data['check'];
echo(""Show checking = $checking""); //Here i read string with blank space instead +
</code></pre>

<p>Is there a way to fix it?</p>
","<p>Yes base64 decodes + to space use this:</p>

<pre><code>echo str_replace("" "",""+"",$_POST['string']);
</code></pre>

<p><a href=""http://en.wikipedia.org/wiki/Base64#URL_applications"" rel=""nofollow"">http://en.wikipedia.org/wiki/Base64#URL_applications</a></p>
","628","<php><encryption><des>","0","0","2","2011-11-19 20:22:50","8197009","0","","","","","2011-11-19 20:07:32",""
"38364798","DES encrypt but Fortify report Weak Encryption on PHP 5.5.22","<p>I want to DES encrypt and decrypt, but Fortify report say they are Weak Encryption
how can I solve this problem?</p>

<p>encrypt</p>

<pre><code>    function encrypt($key, $encrypt)
    {   
        $size = mcrypt_get_block_size(MCRYPT_DES, MCRYPT_MODE_CBC);
        $pad = $size - (strlen($encrypt) % $size);
        $encrypt = $encrypt . str_repeat(chr($pad), $pad);
        $data = mcrypt_encrypt(MCRYPT_DES, $key, $encrypt, MCRYPT_MODE_CBC, $key);

        return base64_encode($data);
    }
</code></pre>

<p>decrypt</p>

<pre><code>    function decrypt($key, $decrypt)
    {
        $decrypt = base64_decode($decrypt);
        $decrypt = mcrypt_decrypt(MCRYPT_DES, $key, $decrypt, MCRYPT_MODE_CBC, $key);
        $pad = ord($decrypt{strlen($decrypt) - 1});

        if ($pad &gt; strlen($decrypt)) {
            return false;
        }

        if (strspn($decrypt, chr($pad), strlen($decrypt) - $pad) != $pad) {
            return false;
        }

        return substr($decrypt, 0, -1 * $pad);
    }
</code></pre>

<p>report
IssueGroup  Weak Encryption</p>

<pre><code>    }

    $size = mcrypt_get_block_size(MCRYPT_DES, MCRYPT_MODE_CBC);
    $pad = $size - (strlen($encrypt) % $size);
    $encrypt = $encrypt . str_repeat(chr($pad), $pad);
</code></pre>

<p>and </p>

<pre><code>    {
        $decrypt = base64_decode($decrypt);
        $decrypt = mcrypt_decrypt(MCRYPT_DES, $key, $decrypt, MCRYPT_MODE_CBC, $key);
        $pad = ord($decrypt{strlen($decrypt) - 1});
</code></pre>
","<p>DES <em>is</em>, in fact, weak encryption. It was publicly broken in the 90's in under 24 hours - the problem is that its key is too short, it's possible to crack it with a brute-force attack. It's no longer suitable as a defense against motivated attackers. There are a number of better options available, such as 3DES, AES, and Twofish.</p>

<p><strong>Edit:</strong> 3DES is better than DES in the sense that it's significantly more secure (but still less secure than AES), but its performance is of necessity significantly worse than AES, DES, or Twofish (because you're essentially applying DES three times). 3DES is rarely used for new implementations.</p>
","618","<php><encryption><des><php-5.5>","0","1","1","2016-07-25 18:03:35","","4","","","","","2016-07-14 03:00:29",""
"51684190","How to enable a disabled cipher by default in openssl 1.1.0g for my python client","<p>I am using python ssl library which is built on openssl. I use Ubuntu which has OpenSSL 1.1.0g. </p>

<p>In OpenSSL 1.1.0g the following cipher <code>DES-CBC3-SHA</code> is disabled by default. I need to configure my client with this cipher enabled. I need it for testing. In SSL context, I found some ways that allow enabling some disabled options by default. For example, in this <a href=""https://docs.python.org/3.6/library/ssl.html"" rel=""nofollow noreferrer"">documentation</a> the following negate SSL 3.0 which is disabled by default: </p>

<pre><code>ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)
ctx.options &amp;= ~ssl.OP_NO_SSLv3
</code></pre>

<p>How can I enable the cipher I need? I used:</p>

<pre><code>ctx.set_cipher(myciphers)
</code></pre>

<p>Where myciphers contains list of ciphers. But this did not help. Because the cipher is disabled by OpenSSL. </p>

<p>How to enable disabled ciphersuites in OpenSSL? </p>

<p><strong>EDIT:</strong>
Additionally, the python <a href=""https://docs.python.org/3.6/library/ssl.html"" rel=""nofollow noreferrer"">ssl module</a> documentation state 3DES is not enabled by default since version 3.4, and I amusing 3.6:</p>

<blockquote>
  <p>3DES was dropped from the default cipher string.</p>
</blockquote>

<p>I need to enable a 3DES cipher for my client purpose. How to do this? is there any way to do this using the ssl context options?</p>
","","612","<python><ssl><openssl><tls1.2><des>","0","","0","2018-08-04 11:03:22","","4","","9371654","","2018-08-04 11:03:22","2018-08-04 09:20:10",""
"34923084","Data Encryption Standard (DES) + a SPRING BOOT authentication","<p>I am migrating from php platform to Java. I have Database full of users with stored passwords in Data Encryption Standard (DES). I would usually do something like this with custom authenticationService: </p>

<pre><code>@Autowired
private AuthenticationServiceImpl authenticationService;

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(authenticationService)
        .passwordEncoder(new BCryptPasswordEncoder());
}
</code></pre>

<p>Obviously not gonna work with bCrypt. Any suggestions?</p>
","<p>You need to write your own <a href=""http://docs.spring.io/spring-security/site/docs/3.1.x/apidocs/org/springframework/security/crypto/password/PasswordEncoder.html"" rel=""nofollow"">PasswordEncoder</a> which uses DES. It shouldn't be difficult and you can search how to decrypt/encrypt data with DES (as an <a href=""http://www.avajava.com/tutorials/lessons/how-do-i-encrypt-and-decrypt-files-using-des.html"" rel=""nofollow"">example</a>).</p>

<p>Just to let you know, <em>encrypting</em> passwords is a very, very, very bad practice (I would suggest that it borders being criminal), as if your DB and the key are exfiltrated, an attacker can very easily get access to the plain text passwords and try to re-use the login details on other sites.</p>

<p>Since you do have access to the plain text passwords, please consider to convert them to bcrypt and removing the DES encrypted password (from your DB and hopefully from any backups you might have)</p>
","610","<spring><encryption><spring-boot><des>","0","1","1","2016-01-21 12:11:10","34923380","1","","","","","2016-01-21 11:52:40",""
"41453800","Android application: DES or RSA?","<p>i created an Android Application that reads data from sensors mounted onto smartphone and sent this data in JSON format to an application server.</p>

<p>I configured server and android app to work over https protocol and to authenticate themselves with a mutual autentication (made up with self-signed certificates).</p>

<p>Now, I was asked to add, in the Android application, the encryption before the client and the server start the authentication process.</p>

<p>In this regard, I want to understand what is the best algorithm between DES and AES from resource consumption point of view.</p>

<p>I don't find anything on web. Can you redirect me to some resource where i can understand more about this argument?</p>
","<p>DES is deprecated in almost all legitimate uses of symmetric encryption (it is obsolete and easily brute-forceable). AES (Rijndael with block size of 128 bits) is the standard symmetric encryption solution, while Blowfish, Twofish, RC4 (also not suggested), and 3DES/TDES are other options. AES is universally supported and will be your best solution in this case. Android has support for AES encryption through native <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html"" rel=""nofollow noreferrer"">Java JCA (formerly JCE)</a> libraries as well as <a href=""https://rtyley.github.io/spongycastle/"" rel=""nofollow noreferrer"">SpongyCastle</a> -- a modified version of BouncyCastle designed for Android). </p>

<p>If you need something more substantial to back this up, there are plenty of resources:</p>

<ul>
<li><a href=""https://stackoverflow.com/a/5559132/70465"">Thomas Pornin discusses the differences between DES and AES</a></li>
<li><a href=""https://stackoverflow.com/a/3938726/70465"">Thomas Pornin again</a></li>
<li><a href=""https://security.stackexchange.com/a/26181/16485"">Christian Dobre</a></li>
<li><a href=""https://security.stackexchange.com/a/26185/16485"">Thomas Pornin on speed differences between AES and 3DES</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Advanced_Encryption_Standard#Performance"" rel=""nofollow noreferrer"">Summary (and additional links) of AES performance</a></li>
</ul>

<p>You should use a strong (128 or 256 bit) key generated from a CSPRNG (or securely derived from a strong passphrase via PBKDF2, bcrypt, or scrypt with high work factor/iterations), a unique and non-predictable IV for each encryption operation, and (preferably) an authenticated encryption with associated data (AEAD) <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">cipher block mode of operation</a> like GCM or EAX, or failing that, a HMAC-based message authentication code (MAC) <em>over the cipher text</em> and verify it with a constant-time equality check <em>before</em> performing any decryption. </p>
","604","<android><encryption><rsa><des>","1","3","3","2017-01-04 05:11:53","","0","","","","","2017-01-03 23:13:55",""
"41453800","Android application: DES or RSA?","<p>i created an Android Application that reads data from sensors mounted onto smartphone and sent this data in JSON format to an application server.</p>

<p>I configured server and android app to work over https protocol and to authenticate themselves with a mutual autentication (made up with self-signed certificates).</p>

<p>Now, I was asked to add, in the Android application, the encryption before the client and the server start the authentication process.</p>

<p>In this regard, I want to understand what is the best algorithm between DES and AES from resource consumption point of view.</p>

<p>I don't find anything on web. Can you redirect me to some resource where i can understand more about this argument?</p>
","<p>Don't ever use DES. It's positively antique (over 40 years old) and the short key length (56 bits) means it can nowadays be cracked quite quickly with modest hardware.</p>

<p>Its weakness was recognized some time ago, which is why <a href=""https://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow noreferrer"">Triple DES (3DES)</a> was introduced to offer better security (increasing the key length to 112 bits). However, this came at the expense of increased computation times, since the algorithm has to do considerably more work to encrypt each block of data.</p>

<p>AES beats 3DES in every respect. By design, <a href=""https://en.wikipedia.org/wiki/Advanced_Encryption_Standard#Performance"" rel=""nofollow noreferrer"">it is able to operate at high speed with low memory requirements</a>. Furthermore, the latest processors (including Intel x86 and ARM architectures) have <a href=""https://en.wikipedia.org/wiki/AES_instruction_set"" rel=""nofollow noreferrer"">built-in AES instructions</a> that allow encryption and decryption to be performed in hardware, resulting in speeds that are orders of magnitude higher than would be possible with 3DES.</p>
","604","<android><encryption><rsa><des>","1","2","3","2017-01-04 05:11:53","","0","","","","","2017-01-03 23:13:55",""
"41453800","Android application: DES or RSA?","<p>i created an Android Application that reads data from sensors mounted onto smartphone and sent this data in JSON format to an application server.</p>

<p>I configured server and android app to work over https protocol and to authenticate themselves with a mutual autentication (made up with self-signed certificates).</p>

<p>Now, I was asked to add, in the Android application, the encryption before the client and the server start the authentication process.</p>

<p>In this regard, I want to understand what is the best algorithm between DES and AES from resource consumption point of view.</p>

<p>I don't find anything on web. Can you redirect me to some resource where i can understand more about this argument?</p>
","<p>I have to agree with the other answers as regards DES - it provides little defense against a motivated attacker.</p>

<p>In terms of RSA (the other algorithm you mention in your title), public-key encryption algorithms are generally considerably slower (by a magnitude of about 1000 based on what I've read, although I've never personally timed it).</p>

<p>It's also arguably less secure to use public-key cryptography for exchanging long messages.</p>

<p>As some background, public-key cryptography generally depends on some kind of a <a href=""https://en.wikipedia.org/wiki/Trapdoor_function"" rel=""nofollow noreferrer"">trap-door function</a> (i.e. a function that is relatively easy to compute but is difficult to find the inverse for). It turns out that those functions are remarkably difficult to find; one of the most common ones now (which is what RSA is based on) is <a href=""https://en.wikipedia.org/wiki/Integer_factorization"" rel=""nofollow noreferrer"">integer factorization</a>, which is <a href=""https://en.wikipedia.org/wiki/NP-intermediate"" rel=""nofollow noreferrer"">NP-Intermediate</a> on ""standard"" computers (but is <a href=""https://en.wikipedia.org/wiki/Shor%27s_algorithm"" rel=""nofollow noreferrer"">broken</a> for quantum computers).</p>

<p>First, the fact that integer factorization is NP-intermediate is at least a theoretical weakness in RSA - technically, no one's actually <em>proven</em> that NP-intermediate problems are intrinsically more ""difficult"" than polynomial-time algorithms (although it's widely believed that they are) because that would entail solving the <a href=""https://en.wikipedia.org/wiki/P_versus_NP_problem"" rel=""nofollow noreferrer"">P vs. NP problem</a>, which is one of the major outstanding questions in computer science.</p>

<p>It turns out that many of the trap-door functions aren't quite as difficult to find inverses for as it is to break a good symmetric-key algorithm like AES or Twofish - i.e. the best public cryptanalysis for public-key encryption algorithms tend to be at least somewhat more feasible than the ones for symmetric-key algorithms. (There's a good <a href=""http://www.eetimes.com/document.asp?doc_id=1279619"" rel=""nofollow noreferrer"">article</a> here on why it's completely infeasible to ""break"" AES with brute force, and the known attacks against it aren't even close to feasible either).</p>

<p>For this reason, public-key cryptography's often used for things like key exchange, at which point both parties switch to symmetric-key cryptography.</p>

<p>All that to say that the other people are right - use AES :).</p>
","604","<android><encryption><rsa><des>","1","1","3","2017-01-04 05:11:53","","0","","","","","2017-01-03 23:13:55",""
"28780845","Covert a DES 96 bit key to 64 bit","<p>How can I convert a 96 bit key to a 64 bit key? I have a DES key that is <strong>96 bits long (i.e 745347651281)</strong> . I want to <strong>convert this to 64 bit</strong> which I will use to decrypt a DES ciphertext.</p>

<p><strong>Update:</strong></p>

<ol>
<li>There was an ""original key"" encrypted by RSA</li>
<li>The ""original key"" was decrypted using RSA to give us this (i.e 745347651281) </li>
<li>This (i.e 745347651281) is now supposed to be used to decryped a DES
file.</li>
</ol>

<p>Note : The ""original key"" was in hex format which I converted to integer(base 16) before doing RSA decryption.</p>
","<p>The key you have displayed is 48 bits in size, not 96 bits in size - if it is considered to be specified hexadecimals. A DES key without parity would be 56 bits in size. This means that you have to create the parity bits that are missing. The parity of DES is described as such:</p>

<blockquote>
  <p>One bit in each 8-bit byte of the KEY may be utilized for error detection in key generation, distribution, and storage. Bits 8, 16,..., 64 are for use in ensuring that each byte is of odd parity.</p>
</blockquote>

<p>Note that the bits are numbered starting at the left with value 1, meaning that the <em>least</em> significant bit of each byte is used for parity. So you have to distribute the bits you have been given over the bytes, and then adjust the parity of each byte by possibly flipping the least significant bit (using XOR with 1).</p>

<p>Usually libraries have support for this kind of operation. In Java you can do this by generating the DES key using <code>SecretKeyFactory</code> for instance.</p>
","593","<encryption><des>","0","1","1","2015-03-01 09:18:32","","7","","3646342","","2015-03-01 09:18:32","2015-02-28 10:48:59",""
"14599289","DES Decryption objectiveC Similar to C# Decryption","<p>In my project I got a DES Encrypted Key from Server I need to Decrypt it in my iOS Application.</p>

<p><strong>Here is the code used in server,</strong></p>

<pre><code>public static string DecryptLicenseKey(string EncryptedLicense)
{
    string str;
    byte[] rgbIV = new byte[] { 10, 20, 30, 40, 50, 60, 70, 80 };
    byte[] buffer = new byte[EncryptedLicense.Length + 1];

    try
    {
        //Decrypt the license
        //-----------------------------------
        byte[] bytes = Encoding.UTF8.GetBytes(""!$@$%^%&amp;"");
        DESCryptoServiceProvider provider = new DESCryptoServiceProvider();
        buffer = Convert.FromBase64String(EncryptedLicense);
        MemoryStream stream2 = new MemoryStream();
        CryptoStream stream = new CryptoStream(stream2, provider.CreateDecryptor(bytes, rgbIV), CryptoStreamMode.Write);
        stream.Write(buffer, 0, buffer.Length);
        stream.FlushFinalBlock();
        str = Encoding.UTF8.GetString(stream2.ToArray());
        //-----------------------------------
    }
    catch (Exception ex)
    {
        return null;
    }

    return str;
}
</code></pre>

<p><strong>Here is the code I try,</strong></p>

<pre><code>- (void)DESDecrypt {
    if (!self.key) {
        self.key = @""!$@$%^%&amp;"";
    }

    const void *constkey = (const void *) [self.key UTF8String];

    self.inputData = [Base64Converter decode:self.inputString];
    const void *dataIn = (const void *) self.inputData;
    size_t dataInLength = [self.inputData length];

    uint8_t *dataOut = NULL;

    size_t dataOutAvailable = 0;
    size_t dataOutMoved = 0;

    dataOutAvailable = (dataInLength + kCCBlockSizeDES) &amp; ~(kCCBlockSizeDES - 1);
    dataOut = malloc( dataOutAvailable * sizeof(uint8_t));
    memset((void *)dataOut, 0x0, dataOutAvailable);

    Byte iv [] = {10, 20, 30, 40, 50, 60, 70, 80};

    //    CCCryptorStatus CCCrypt(
    //                            CCOperation op,         /* kCCEncrypt, etc. */
    //                            CCAlgorithm alg,        /* kCCAlgorithmAES128, etc. */
    //                            CCOptions options,      /* kCCOptionPKCS7Padding, etc. */
    //                            const void *key,
    //                            size_t keyLength,
    //                            const void *iv,         /* optional initialization vector */
    //                            const void *dataIn,     /* optional per op and alg */
    //                            size_t dataInLength,
    //                            void *dataOut,          /* data RETURNED here */
    //                            size_t dataOutAvailable,
    //                            size_t *dataOutMoved)
    //    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);

    CCCryptorStatus ccStatus = CCCrypt(kCCDecrypt,
                                       kCCAlgorithmDES,
                                       kCCOptionECBMode,
                                       constkey,
                                       kCCKeySizeDES,
                                       iv,
                                       dataIn,
                                       dataInLength,
                                       (void *)dataOut,
                                       dataOutAvailable,
                                       &amp;dataOutMoved);

    NSLog(@""CCStatus : %d"",ccStatus);
    if (ccStatus == kCCSuccess) {
        self.outputData = [NSData dataWithBytes:(const void *)dataOut length:(NSUInteger)dataOutAvailable];
        self.outputString = [[NSString alloc] initWithBytes:dataOut length:dataOutAvailable encoding:NSUTF8StringEncoding];
    }
}
</code></pre>

<p>I got the CCStatus Success And data received is  (self.outputData), self.outputString is empty. Where I got wrong,</p>

<p>thanks in advance</p>
","","591","<iphone><ios><objective-c><encryption><des>","0","","0","2013-01-30 08:10:38","","6","1","","","","2013-01-30 08:10:38",""
"29733861","How can I create the program that encrypts file with 2DES (doubleDES)?","<p>I know doubleDES is not used sine of Meet-in-the-middle Attack but i need to create a program that does that kind of encryption. I tried this but i think im stuck and just cannot figure out what am i missing..</p>

<pre><code>DESCryptoServiceProvider DES = new DESCryptoServiceProvider();

DES.Mode = CipherMode.ECB;
DES.Padding = PaddingMode.Zeros;
// *****ENKRIPTIMI*****
DES.Key = utf8.GetBytes(textBox1.Text.Substring(0, 8));
StreamReader sr = new StreamReader(textBox2.Text);
string permbajtja = sr.ReadToEnd();
sr.Close();
FileStream fs1 = new FileStream(textBox2.Text, FileMode.Create, FileAccess.Write);
CryptoStream cs = new CryptoStream(fs1, DES.CreateEncryptor(), CryptoStreamMode.Write);
StreamWriter sw = new StreamWriter(cs);
sw.Write(permbajtja); sw.Flush();
sw.Close();
StreamReader stream = new StreamReader(textBox2.Text);
string msg = stream.ReadToEnd();
stream.Close();
MessageBox.Show(msg);



//*****DEKRIPTIMI*****

DES.Key = utf8.GetBytes(textBox1.Text.Substring(8, 8));
FileStream fs2 = new FileStream(textBox2.Text, FileMode.Open, FileAccess.Read);
CryptoStream cs1 = new CryptoStream(fs2, DES.CreateDecryptor(), CryptoStreamMode.Read);
StreamReader sr1 = new StreamReader(cs1);
string permbajtja1 = sr1.ReadToEnd();
//    MessageBox.Show(permbajtja1);
sr1.Close();
fs2.Dispose();
fs2.Close();


StreamWriter sw1 = new StreamWriter(textBox2.Text);
sw1.Write(permbajtja1);
sw1.Flush();
sw1.Close();
</code></pre>

<h2>**** THE PART ABOVE IS JUST FOR ENCRYPTING *****</h2>

<p>The decryption part</p>

<pre><code>DESCryptoServiceProvider DES = new DESCryptoServiceProvider();

DES.Mode = CipherMode.ECB;
DES.Padding = PaddingMode.Zeros;
// *****ENKRIPTIMI*****
DES.Key = utf8.GetBytes(textBox1.Text.Substring(8,8));
StreamReader sr = new StreamReader(textBox2.Text);
string permbajtja = sr.ReadToEnd();
sr.Close();
FileStream fs1 = new FileStream(textBox2.Text, FileMode.Create, FileAccess.Write);
CryptoStream cs = new CryptoStream(fs1, DES.CreateEncryptor(), CryptoStreamMode.Write);
StreamWriter sw = new StreamWriter(cs);
sw.Write(permbajtja); sw.Flush();
sw.Close();
StreamReader lexo = new StreamReader(textBox2.Text);
MessageBox.Show(lexo.ReadToEnd());
lexo.Close();

////*****DEKRIPTIMI*****

DES.Key = utf8.GetBytes(textBox1.Text.Substring(0, 8));
FileStream fs2 = new FileStream(textBox2.Text, FileMode.Open, FileAccess.Read);
CryptoStream cs1 = new CryptoStream(fs2, DES.CreateDecryptor(), CryptoStreamMode.Read);
StreamReader sr1 = new StreamReader(cs1);
string permbajtja1 = sr1.ReadToEnd();
MessageBox.Show(permbajtja1);
sr1.Close();
fs2.Dispose();
fs2.Close();


StreamWriter sw1 = new StreamWriter(textBox2.Text);
sw1.Write(permbajtja1);
sw1.Flush();
sw1.Close();
</code></pre>
","<p>First of all you should write the encrypt and the decrypt method:</p>

<pre><code>public static string Encrypt(string originalString, byte[] key)
{
    DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
    MemoryStream memoryStream = new MemoryStream();
    CryptoStream cryptoStream = new CryptoStream(memoryStream,
        cryptoServiceProvider.CreateEncryptor(key, key),
        CryptoStreamMode.Write);

    using (StreamWriter streamWriter = new StreamWriter(cryptoStream))
    {
        streamWriter.Write(originalString);
        streamWriter.Flush();
        cryptoStream.FlushFinalBlock();
        streamWriter.Flush();

        return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
    }
}

public static string Decrypt(string cryptedString, byte[] key)
{
    DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
    MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(cryptedString));
    CryptoStream cryptoStream = new CryptoStream(memoryStream,
        cryptoServiceProvider.CreateDecryptor(key, key),
        CryptoStreamMode.Read);

    using (StreamReader streamReader = new StreamReader(cryptoStream))
    {
        return streamReader.ReadToEnd();
    }
}
</code></pre>

<p>Now you can apply twice the encryption method (and of course twice the decryption one) to your string:</p>

<pre><code>byte[] key1 = ASCIIEncoding.ASCII.GetBytes(""12345678"");
byte[] key2 = ASCIIEncoding.ASCII.GetBytes(""abcdefgh"");

string originalString = ""A secret string"";
string cryptedString = Encrypt(Encrypt(originalString, key1), key2);
Console.WriteLine(""Encrypt message: {0}"", cryptedString);
Console.WriteLine(""Decrypt message: {0}"", Decrypt(Decrypt(cryptedString, key2), key1));
</code></pre>

<p>Take a look to my code, it may help you.</p>
","578","<c#><.net><encryption><des>","0","2","1","2015-04-22 13:37:10","","4","","3651607","","2015-04-22 13:37:10","2015-04-19 18:15:25",""
"21577989","Bad Data: CryptographicException was unhandled during DES decryption","<p>With the below Encrypt method I am succesfully able to encrypt the xml files, but for to decrypt those xml files when I inspect into DESDecrypt method, It throws error</p>

<pre><code>const string DESKey = ""AQWSEDRF"";
const string DESIV = ""HGFEDCBA"";


public static string DESDecrypt(string stringToDecrypt)//Decrypt the content
{

    byte[] key;
    byte[] IV;

    byte[] inputByteArray;
    try
    {

        key = Convert2ByteArray(DESKey);

        IV = Convert2ByteArray(DESIV);

        stringToDecrypt = stringToDecrypt.Replace("" "", ""+"");

        int len = stringToDecrypt.Length; inputByteArray = Convert.FromBase64String(stringToDecrypt);


        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        MemoryStream ms = new MemoryStream();

        CryptoStream cs = new CryptoStream(ms, des.CreateDecryptor(key, IV), CryptoStreamMode.Write);
        cs.Write(inputByteArray, 0, inputByteArray.Length);

        cs.FlushFinalBlock();

        Encoding encoding = Encoding.UTF8; return encoding.GetString(ms.ToArray());
    }

    catch (System.Exception ex)
    {

        throw ex;
    }

}

public static string DESEncrypt(string stringToEncrypt)// Encrypt the content
{

    byte[] key;
    byte[] IV;

    byte[] inputByteArray;
    try
    {

        key = Convert2ByteArray(DESKey);

        IV = Convert2ByteArray(DESIV);

        inputByteArray = Encoding.UTF8.GetBytes(stringToEncrypt);
        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        MemoryStream ms = new MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(key, IV), CryptoStreamMode.Write);
        cs.Write(inputByteArray, 0, inputByteArray.Length);

        cs.FlushFinalBlock();

        return Convert.ToBase64String(ms.ToArray());
    }

    catch (System.Exception ex)
    {
        throw ex;
    }

}

static byte[] Convert2ByteArray(string strInput)
{

    int intCounter; char[] arrChar;
    arrChar = strInput.ToCharArray();

    byte[] arrByte = new byte[arrChar.Length];

    for (intCounter = 0; intCounter &lt;= arrByte.Length - 1; intCounter++)
        arrByte[intCounter] = Convert.ToByte(arrChar[intCounter]);

    return arrByte;
}
</code></pre>

<p>It throws exception, ""Bad Data"".   CryptographicException was unhandled.  How can this error be resolved,  Any help would be appreciated.   </p>
","","571","<c#><wpf><exception><encryption><des>","1","","0","2014-02-05 12:58:37","","2","","","","","2014-02-05 12:58:37",""
"12517098","Trying to get the length of an encrypted string","<p>I am using the following function to encrypt a string:</p>

<pre><code>public string Encrypt(string stringToEncrypt, string SEncryptionKey)
{
try {
    key = System.Text.Encoding.UTF8.GetBytes(Strings.Left(SEncryptionKey, 8));
    DESCryptoServiceProvider des = new DESCryptoServiceProvider();
    byte[] inputByteArray = Encoding.UTF8.GetBytes(stringToEncrypt);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(key, IV), CryptoStreamMode.Write);
    cs.Write(inputByteArray, 0, inputByteArray.Length);
    cs.FlushFinalBlock();
    return Convert.ToBase64String(ms.ToArray());
} catch (Exception e) {
    return e.Message;
    }
}
</code></pre>

<p>I am wondering if there is some kind of mathematical algorithm that will allow me to determine, in advance, what the length of the Base64 encrypted string length will be. So if my string is 15 characters long, what will the length of the Base64 encrypted string be?</p>
","<p>A 15 character string will be at least 15 bytes. It could become 20 or even 30 if you have a lot of non-ASCII characters.</p>

<p>The Encryption will round it up to a multiple of the <strike>key</strike> block size, lets say 64 bytes.</p>

<p>Then Base64 goes to encode 8 bit bytes into  6 bit tokens, so you get (64 *  8) / 6 tokens (chars). </p>
","565","<c#><encryption><base64><des>","2","3","2","2012-09-20 17:21:46","12517291","8","","","","","2012-09-20 16:41:57",""
"12517098","Trying to get the length of an encrypted string","<p>I am using the following function to encrypt a string:</p>

<pre><code>public string Encrypt(string stringToEncrypt, string SEncryptionKey)
{
try {
    key = System.Text.Encoding.UTF8.GetBytes(Strings.Left(SEncryptionKey, 8));
    DESCryptoServiceProvider des = new DESCryptoServiceProvider();
    byte[] inputByteArray = Encoding.UTF8.GetBytes(stringToEncrypt);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(key, IV), CryptoStreamMode.Write);
    cs.Write(inputByteArray, 0, inputByteArray.Length);
    cs.FlushFinalBlock();
    return Convert.ToBase64String(ms.ToArray());
} catch (Exception e) {
    return e.Message;
    }
}
</code></pre>

<p>I am wondering if there is some kind of mathematical algorithm that will allow me to determine, in advance, what the length of the Base64 encrypted string length will be. So if my string is 15 characters long, what will the length of the Base64 encrypted string be?</p>
","<p>Yes. You can calculate that.</p>

<p>a) DES encryption uses blocks. As I remember it's 8 bytes. So, if you encrypt anything, it will become rounded to the block sizes. </p>

<ul>
<li>As example, you encrypt 1 byte, it will be come 8 bytes.</li>
<li>You encrypt 8 bytes, it will become 8 bytes</li>
<li>You encrypt 9 bytes, it will become 16 bytes (minimum amount of block to fit original data)</li>
</ul>

<p>So, the formale <strong>encryptedLength = ceiling (originalLength /8) * 8</strong></p>

<p>b) Base64 has also something very similar to block size. And it's block size is 4. Each original 3 bytes will be converted to 4 bytes block</p>

<p>So, for Base64  <strong>encodedLength = ceiling (originalLength/3)*4</strong></p>

<p>So, the final formula is</p>

<p><strong>encodedEncryptedLength = ceiling(ceiling(originalLength/8)*8/3)*4</strong></p>

<p>originalLength here is number of bytes (!!! not characters !!!) in the text which you plan to encrypt.</p>
","565","<c#><encryption><base64><des>","2","2","2","2012-09-20 17:21:46","12517291","8","","","","","2012-09-20 16:41:57",""
"6764276","Does Ghostscript use AES or DES encryption method when encrypting PDFs?","<p>Does Ghostscript use AES or DES  encryption method when encrypting PDFs?<br>
Do I need to specify a specific -dEncriptionR=# value (# can be 2, 3, 4, 5, etc) to use AES as opposed to DES on the Ghostscript command line?</p>
","<p>The pdfwrite device in Ghostscript does not support AES or DES when encrypting output, it only supports the Standard method.</p>

<p>The EncryptionR switch only controls which revision of the standard security handler is used and it has only two values 2 or 3, as described in gs/ps2pdf.htm and in the PDF reference manual (Table 3.19 on p 122 in my copy of the 1.7 reference)</p>
","561","<pdf><encryption><aes><ghostscript><des>","2","1","1","2011-07-21 07:26:14","","0","1","","","","2011-07-20 15:18:01",""
"12468835","Errors when including DES.pyd in python 2.6 solution","<p>I have installed Python 2.7 on my windows 7 x64 system with PyCrypto 2.5 compiled and built in. In my install path of <code>D:\Python27\Lib\site-packages\Crypto\Cipher</code> I see <code>DES.pyd</code>. I have opened it with dependency walker and ensured it had <code>initDES</code> as its only export.</p>

<p>What I wanted to do was copy/paste <code>DES.pyd</code> out now that it's built and use it in my code. So now I have my project folder <code>D:\project</code> containing <code>test.py</code> and <code>DES.pyd</code>.</p>

<p><code>test.py</code> contains the code:</p>

<pre><code>import sys
sys.path.append(""D:\\project\\"")
import DES
print 'hi'
</code></pre>

<p>when running <code>test.py</code>, i receive the following error:</p>

<pre><code>Traceback (most recent call last):
  File ""test.py"", line 3, in &lt;module&gt;
    import DES
SystemError: dynamic module not initialized properly&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>The purpose of this exercise is to be able to send <code>DES.pyd</code> and <code>test.py</code> to my friend without having them require to build and install pycrypto (a PITA). I fully understand my code above does absolutely nothing involving DES, the fact that it cannot import it is my main curiosity. Real code using DES will follow. </p>

<p>Also, if I import <code>DES.pyd</code> directly from the python path like <code>from Crypto.Cipher import DES</code> works just fine.</p>

<p>Thanks!</p>
","<p>Take a look at the source code at <a href=""https://github.com/dlitz/pycrypto/blob/master/src/block_template.c#L801"" rel=""nofollow"">https://github.com/dlitz/pycrypto/blob/master/src/block_template.c#L801</a>. The module name is hard coded to <code>Crypto.Cipher._DES</code>. Initialization will fail if <code>_DES.pyd</code> is not in the <code>Crypto.Cipher</code> package directory.</p>
","556","<python><des><pycrypto><pyd>","0","0","1","2012-09-18 12:23:35","12471049","0","","1491200","","2012-09-18 12:23:35","2012-09-18 00:23:52",""
"17510277","OpenSSL encrypt , Pydes decrypt","<p>I'm using OpenSSL API to encrypt my string,but I can't decrypt it used by pydes.Then I used different methods encrypt the same string, but does not get the same results.</p>

<p>C++ code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/des.h&gt;
#include &lt;openssl/rand.h&gt;

int Encrypt( char ** Out,char *Key1,char *Key2,char *Key3, char *Msg, int size)
{

    unsigned char*    Res;

    DES_cblock key1, key2, key3;

    DES_cblock ivsetup = {'\0', '\0', '\0', '\0', '\0','\0', '\0', '\0'};
    DES_cblock ivec;
    DES_key_schedule ks1, ks2, ks3;


    DES_string_to_key (Key1, &amp;key1);
    DES_string_to_key (Key2, &amp;key2);
    DES_string_to_key (Key3, &amp;key3);

    DES_set_key((DES_cblock *)key1, &amp;ks1);
    DES_set_key((DES_cblock *)key2, &amp;ks2);
    DES_set_key((DES_cblock *)key3, &amp;ks3);

    int len =size ;
    short spure=len%8;

    if(spure!=0  ){
        len=(len+8-spure);
    }

    Res=( char * ) malloc(len*sizeof(char));
    bzero( Res, len);

    unsigned char * InBuffer=( char * ) malloc(len*sizeof(char));
    bzero( InBuffer, len);
    memcpy( InBuffer,Msg,size );
    memcpy(ivec, ivsetup, sizeof(ivsetup));
    DES_ede3_cbc_encrypt(InBuffer, Res, len, &amp;ks1, &amp;ks2, &amp;ks3, &amp;ivec, DES_ENCRYPT);
    free( InBuffer );
    *Out=Res;
    return len;
}

int main(void)
{
    char key1[]=""12345678""; // 
    char key2[]=""12345678""; //         
    char key3[]=""12345678""; //16

    char clear[]=""1234567887654321"";


    char *decrypted;

    FILE *fp;
    printf(""In Main, Plain text\t : %s %d\n"",clear,strlen( clear ));

    int len=Encrypt(&amp;encrypted,key1,key2,key3,clear,strlen(clear));


    if((fp=fopen( ""./test.des.en"",""wb""))!=NULL  ){
        fwrite(encrypted,len,1,fp );
        fclose( fp );
    }


    free( encrypted );

    exit(0);
}
</code></pre>

<p>And I get hex content [3d 90 07 5d 36 3e ba 0b d1 72 68 e0 30 20 74 f0] in  test.des.en file.</p>

<p>I'm using Pydes to encrypt the same string.</p>

<p>Python code:</p>

<pre><code> #coding:utf-8
 from pyDes import *
 k = triple_des(""123456781234567812345678"", CBC, ""\0\0\0\0\0\0\0\0"", pad='\0', padmode=PAD_NORMAL)
 d = k.encrypt(""1234567887654321"")
 outfile = open('./test.des.en1','wb')
 outfile.write(d)
</code></pre>

<p>The hex content is [96 d0 02 88 78 d5 8c 89 68 ea 5b c0 69 b1 20 97]  in test.des.en1 file.</p>

<p>What's wrong? Can someone help me? Thanks!.</p>
","","548","<python><openssl><des>","1","","0","2013-07-07 09:12:21","","1","","2557626","","2013-07-07 09:12:21","2013-07-07 07:57:26",""
"37481692","Python: DES-ECB encryption with two different keys result in the same ciphertext","<p>I'am trying to encrypt the plaintext <code>6d65737361676531</code> (which is in hexadecimal) with the keys <code>0000000000000000</code> and <code>0000000000000001</code> (both in hexadecimal) using the DES cipher in ECB mode from Crypto.Cipher. But for some reason both <code>ciphertext1_hex</code> and <code>ciphertext2_hex</code> are equal <code>3bd2ac43547a7961</code>, i.e. they result in the same ciphertext. Does anyone have any idea about why this is the case?</p>

<pre><code>from Crypto.Cipher import DES

key1_hex = ""0000000000000000""
key2_hex = ""0000000000000001""

key1 = key1_hex.decode(""hex"")
key2 = key2_hex.decode(""hex"")

des1 = DES.new(key1, DES.MODE_ECB)
des2 = DES.new(key2, DES.MODE_ECB)

plaintext_hex = ""6d65737361676531""
plaintext = plaintext_hex.decode(""hex"")

ciphertext1 = des1.encrypt(plaintext)
ciphertext2 = des2.encrypt(plaintext)

ciphertext1_hex = ciphertext1.encode(""hex"")
ciphertext2_hex = ciphertext2.encode(""hex"")
</code></pre>
","<p>In a DES key it's only the first 7 bits of each byte that are actual key material (giving a DES key of 56 bit)  .. the last bit of each byte is a parity bit. So the two keys are actually the same key. Some implementations would complain if the parity bit ain't correct. But this one apparently don't.</p>
","545","<python><encryption><des>","0","3","1","2016-05-27 12:49:27","37484019","2","","","","","2016-05-27 10:57:00",""
"29695473","DES.MODE_OFB doesn't recover the plaintext","<p>Consider the two codes below (based on <a href=""http://pythonhosted.org//pycrypto/"" rel=""nofollow"">http://pythonhosted.org//pycrypto/</a>):</p>

<p>1) DES.MODE_ECB </p>

<pre><code>from Crypto.Cipher import DES    
from Crypto import Random    
key = b'Eight888'    
cipher = DES.new(key, DES.MODE_ECB)    
plaintext = b'sona si latine loqueris '    
msg = cipher.encrypt(plaintext)    
msgback= cipher.decrypt(msg)
</code></pre>

<p>2) DES.MODE_OFB</p>

<pre><code>from Crypto.Cipher import DES
from Crypto import Random
key = b'Eight888'
iv = Random.new().read(DES.block_size)
cipher = DES.new(key, DES.MODE_OFB, iv)
plaintext = b'sona si latine loqueris '
msg = iv + cipher.encrypt(plaintext)
msgback= cipher.decrypt(msg)
</code></pre>

<p>Why is that code 1) recovers the original plaintext and 2) doesn't?</p>
","<p>You have to slice off the IV before decrypting, because it is not part of the ciphertext.</p>

<pre><code>decCipher = DES.new(key, DES.MODE_OFB, msg[:DES.block_size])
msgback = decCipher.decrypt(msg[DES.block_size:])
</code></pre>

<p>Unlike CBC where decrypting with the IV recovers at least a part of the plaintext, OFB is a streaming mode. If the alignment between actual ciphertext and generated stream (based in IV and key) is not perfect, the original plaintext cannot be recovered.</p>
","542","<python><encryption><des><pycrypto>","1","2","1","2015-04-17 09:58:18","29695641","3","","1816580","","2015-04-17 09:45:07","2015-04-17 09:33:16",""
"26769631","Implement DES in C#","<p>In the Microsoft page they have a tutorial how to use DES using the built in library:</p>

<pre><code>private static void EncryptData(String inName, String outName, byte[] desKey, byte[] desIV)
{
    //Create the file streams to handle the input and output files.
    FileStream fin = new FileStream(inName, FileMode.Open, FileAccess.Read);
    FileStream fout = new FileStream(outName, FileMode.OpenOrCreate, FileAccess.Write);
    fout.SetLength(0);

    //Create variables to help with read and write. 
    byte[] bin = new byte[100]; //This is intermediate storage for the encryption. 
    long rdlen = 0;              //This is the total number of bytes written. 
    long totlen = fin.Length;    //This is the total length of the input file. 
    int len;                     //This is the number of bytes to be written at a time.

    DESCryptoServiceProvider des = new DESCryptoServiceProvider();
    CryptoStream encStream = new CryptoStream(fout, des.CreateEncryptor(desKey, desIV), CryptoStreamMode.Write);

    Console.WriteLine(""Encrypting..."");

    //Read from the input file, then encrypt and write to the output file. 
    while (rdlen &lt; totlen)
    {
        len = fin.Read(bin, 0, 100);
        encStream.Write(bin, 0, len);
        rdlen = rdlen + len;
        Console.WriteLine(""{0} bytes processed"", rdlen);
    }

    encStream.Close();
    fout.Close();
    fin.Close();
}
</code></pre>

<p>Well I got the most of it, but i didn't understand what is desIV and how can I call the function to test it.. 
Can someone help please?</p>
","<p>It might not be a very technical explanation, but I guess a very good way to understand that is thinking about passwords.</p>

<p>Imagine that an attacker could download your whole database of logins and could retrieve everyone's passwords along with their e-mail accounts. But before that, he decides to create some accounts (with some passwords he knows).</p>

<p>If the encryption used just a key, maybe someone could try to 'decode' your key just by having some sample pairs of unencrypted passwords and encrypted ones (using the accounts he created before) and then use the key + the algorithm to decipher every password in the whole database. A worse scenario would be several users with the same password having the same resulted encryption - the attacker wouldn't need even to decipher the key to use other accounts. He would only have to be a good ""known passwords"" guesser.</p>

<p>Now let's suppose you could introduce some 'ramdom' code at the begging of your encryption/decryption. I.E.: when a user chooses password '12345' instead of encrypting this, you encrypt his e-mail also concatenated 'test@gmail.test12345' and then encrypt. Since there's no way to have two different login e-mails, even if a lot of users choose to use the same password, the resulted encryption would be different. Plus, an attacker would never know what kind of pseudorandom information you have input. This is called 'Salting'.</p>

<p>Salting is not very different than initialization vector, but uses different conventions - this one is array of bytes, but it would mean a string. Some engineers even generate random strings as salt and stores it along the encrypted password. As unrepeatable the the salt is, as difficult to decrypt.</p>
","530","<c#><des>","-1","-1","1","2014-11-06 02:41:51","26770796","5","","","","","2014-11-06 00:15:38",""
"10494617","How to test encrypting algorithms?","<p>We have to implement the DES algorithm. We want to code some functions, but we don't know how to test our DES algorithm.</p>

<p>Are there any well-known tools/libraries that we can use to test our encrypting and decrypting functions? We need a 3rd party tool to tell people that our version really works.</p>
","<p>I assume that you are using DES as part of 3DES and for 3DES the National Institute of Standards and Technology (NIST) has published a large number of test vectors that can be used for verifying your implementation:</p>

<p><a href=""http://csrc.nist.gov/groups/STM/cavp/index.html"" rel=""nofollow"">http://csrc.nist.gov/groups/STM/cavp/index.html</a></p>

<p>Additionally you can test interoperability (encryption/decryption) with other known libraries such as OpenSSL. If the encrypted ciphertext respectively decrypted plaintext is identically the possibility that your implementation is correct is high.</p>
","526","<c++><c><algorithm><encryption><des>","-2","3","2","2012-05-08 13:37:53","","1","2","366904","","2012-05-08 09:05:54","2012-05-08 07:43:04",""
"10494617","How to test encrypting algorithms?","<p>We have to implement the DES algorithm. We want to code some functions, but we don't know how to test our DES algorithm.</p>

<p>Are there any well-known tools/libraries that we can use to test our encrypting and decrypting functions? We need a 3rd party tool to tell people that our version really works.</p>
","<p>Java has a lot of security algorithms implemented:
<a href=""http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html"" rel=""nofollow"">http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html</a></p>

<pre><code>Cipher desCipher = Cipher.getInstance(""DES/CBC/NoPadding"");
DESKeySpec desSpec = new DESKeySpec(desKey);
SecretKey des = SecretKeyFactory.getInstance(""DES"").generateSecret(desSpec);
desCipher.init(Cipher.ENCRYPT_MODE, des , ivSpec);
</code></pre>
","526","<c++><c><algorithm><encryption><des>","-2","-1","2","2012-05-08 13:37:53","","1","2","366904","","2012-05-08 09:05:54","2012-05-08 07:43:04",""
"43829039","Triple DES implementation by DES","<p>I'm trying to implement 3Des by using a DES API as below:</p>

<pre><code>des(input, output, key, mode)
</code></pre>

<p>which input, output and key are 8 bytes each one and mode identifies encryption and decryption type.
I'm wondering if it's possible to have a 3Des algorithm with variable output length?</p>

<p>This is the code I've written in C to create 3des with more than 8 bytes key by using this API.</p>

<p>But I have no idea if it's working OK or if it's possible to change output bytes.</p>

<pre><code>unsigned char TripleDes(uchar *input, uchar *output,uchar *deskey, int mode)
{
    uchar tt[100];
    uchar tmpInput[100];
    uchar tmpOutput[100];
    int i=0, j=0;

    memset(tt, 0, sizeof(tt));
    memset(tmpInput, 0, sizeof(tmpInput));
    memset(tmpOutput, 0, sizeof(tmpOutput));

    j =  strlen(input);
    memcpy(tmpInput, input, j);
    while(j/8!=0){
        j-=8;
        if (mode) { //Encrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey,1);
            des(tmpOutput+i*8, tt, deskey+8, 0);
            des(tt,tmpOutput+i*8, deskey, 1);
        }
        else { //Decrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey, 0);
            des(tmpOutput+i*8, tt, deskey+8, 1);
            des(tt, tmpOutput+i*8, deskey, 0);
        }
        i++;
    }

    strcpy(output, tmpOutput);
    return;
}
</code></pre>

<p>Any idea?</p>
","<pre><code>des(tmpInput+i*8, tmpOutput+i*8, deskey,1); // step1: encrypting 8 bytes of input with first 8 bytes of key
des(tmpOutput+i*8, tt, deskey+8, 0);// step2: decrypting result of step1 with last 8 bytes of key
des(tt,tmpOutput+i*8, deskey, 1);// step3: encrypting result of step2 with first 8 bytes of key
</code></pre>

<p>Assuming you have used 16 bytes key and if des api is doing what I have mentioned in comments, its doing 3DES properly</p>

<p>The length of output data is same as input data, if input data is multiple of 8 bytes.
If length of input data is not multiple of 8, its padded with trailing zeros to make it multiple of 8, and then encrypted
eg
If length of your input data is 10, length of output data will be 16</p>
","521","<c><des><3des><tripledes>","0","-1","2","2017-05-08 04:31:14","","4","1","","","","2017-05-07 07:44:13",""
"43829039","Triple DES implementation by DES","<p>I'm trying to implement 3Des by using a DES API as below:</p>

<pre><code>des(input, output, key, mode)
</code></pre>

<p>which input, output and key are 8 bytes each one and mode identifies encryption and decryption type.
I'm wondering if it's possible to have a 3Des algorithm with variable output length?</p>

<p>This is the code I've written in C to create 3des with more than 8 bytes key by using this API.</p>

<p>But I have no idea if it's working OK or if it's possible to change output bytes.</p>

<pre><code>unsigned char TripleDes(uchar *input, uchar *output,uchar *deskey, int mode)
{
    uchar tt[100];
    uchar tmpInput[100];
    uchar tmpOutput[100];
    int i=0, j=0;

    memset(tt, 0, sizeof(tt));
    memset(tmpInput, 0, sizeof(tmpInput));
    memset(tmpOutput, 0, sizeof(tmpOutput));

    j =  strlen(input);
    memcpy(tmpInput, input, j);
    while(j/8!=0){
        j-=8;
        if (mode) { //Encrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey,1);
            des(tmpOutput+i*8, tt, deskey+8, 0);
            des(tt,tmpOutput+i*8, deskey, 1);
        }
        else { //Decrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey, 0);
            des(tmpOutput+i*8, tt, deskey+8, 1);
            des(tt, tmpOutput+i*8, deskey, 0);
        }
        i++;
    }

    strcpy(output, tmpOutput);
    return;
}
</code></pre>

<p>Any idea?</p>
","<p>I finally could solve this problem not by using this API but with the methods are mentiond in the class in below link:</p>

<p><a href=""https://github.com/petricek/eternity-service/blob/master/Common/RSARef/source/desc.c"" rel=""nofollow noreferrer"">https://github.com/petricek/eternity-service/blob/master/Common/RSARef/source/desc.c</a></p>

<p>I needed a triple des class in CBC mode with 16 key length. I changed these classes and thos works fine:</p>

<pre><code> DES3_CBCInit
    {
     .....
      deskey(context-&gt;subkeys[0], key, encrypt);
      deskey(context-&gt;subkeys[1], &amp;key[8], !encrypt);
    }

 DES3_CBCUpdate
  {
    .....

    DESFunction (work, context-&gt;subkeys[0]);
    DESFunction (work, context-&gt;subkeys[1]);
    DESFunction (work, context-&gt;subkeys[0]);

    ......
   }
</code></pre>
","521","<c><des><3des><tripledes>","0","0","2","2017-05-08 04:31:14","","4","1","","","","2017-05-07 07:44:13",""
"19016174","Which AVX registers should I use to avoid 3-byte VEX prefixes?","<p>I am currently working on an implementation of Bitslice DES for x64, and I would like to know how I could avoid 3-byte VEX prefixes as much as possible with the following AVX instructions:</p>

<pre><code>vpor
vpxor
vpand
vpandn
</code></pre>

<p>I was told I should use 2-byte VEX prefixes as much as possible instead of 3-byte ones to make the code smaller and faster, but I don't know exactly how to do so. I read somewhere that I should use xmm[0-7] instead of xmm[89] and xmm1[0-5], but I don't know which combinations of operands would give me 2-byte VEX prefixes as opposed to 3-byte ones. These instructions are used with 2 or 3 operands as shown in the following snippet:</p>

<pre><code>%macro sbox1 4
vmovdqa xmm7,  xmm4
vpandn  xmm4,  xmm0
vpor    xmm10, xmm5,  xmm2
vpxor   xmm13, xmm2,  xmm0
vpxor   xmm11, xmm5,  xmm7
vpxor   xmm14, xmm4,  xmm3
vpandn  xmm12, xmm13, xmm11
vpand   xmm13, xmm10
vpxor   xmm15, xmm11, xmm2
vpxor   xmm8,  xmm13, xmm3
vpandn  xmm9,  xmm14, xmm8
vpor    xmm13, xmm5
vpor    xmm5,  xmm0
vpandn  xmm8,  xmm7
vpandn  xmm15, xmm14
vpxor   xmm13, xmm15
vpor    xmm6,  xmm5,  xmm13
vpandn  xmm5,  xmm3
vpandn  xmm15, xmm9,  xmm13
vmovdqa xmm3,  xmm8 
vpxor   xmm8,  xmm6
vpxor   xmm5,  xmm3
vpand   xmm13, xmm10
vpandn  xmm4,  xmm2
vpxor   xmm2,  xmm6,  xmm14
vpxor   xmm6,  xmm10
vpandn  xmm4,  xmm2
vpxor   xmm2,  xmm4,  pnot
vpxor   xmm4,  xmm11
vpxor   xmm13, xmm2
vpor    xmm4,  xmm3
vpandn  xmm2,  xmm1,  xmm8
vpor    xmm14, xmm7
vpxor   xmm4,  xmm10
vpor    xmm9,  xmm1
vpxor   xmm2,  xmm13
vpxor   xmm4,  xmm0
vpxor   xmm13, xmm4
vpxor   xmm9,  xmm13
vpor    xmm5,  xmm12
vpxor   xmm9,  %1

vmovdqa %1,    xmm9
vpor    xmm6,  xmm5
vpor    xmm13, xmm11
vpxor   xmm6,  xmm4
vpor    xmm0,  xmm1,  xmm15
vpxor   xmm13, xmm6
vpxor   xmm2,  %3
vmovdqa %3,    xmm2
vpxor   xmm13, %2
vpand   xmm4,  xmm15
vpandn  xmm6,  xmm14
vpxor   xmm13, xmm0
vmovdqa %2,    xmm13
vpxor   xmm4,  xmm6
vpor    xmm4,  xmm1
vpxor   xmm4,  xmm5
vpxor   xmm4,  %4
vmovdqa %4,    xmm4
%endmacro
</code></pre>
","<p>You should stick to registers <code>xmm0...xmm7</code>. This also holds true for general purpose registers, the encoding of instructions involving <code>eax,ebx...ebp</code> is most of the time one byte shorter than instructions using <code>r8d...r15d</code>.</p>
","519","<assembly><64-bit><des><avx><yasm>","2","2","2","2013-10-12 04:17:42","19330492","3","","","","","2013-09-25 22:22:24",""
"19016174","Which AVX registers should I use to avoid 3-byte VEX prefixes?","<p>I am currently working on an implementation of Bitslice DES for x64, and I would like to know how I could avoid 3-byte VEX prefixes as much as possible with the following AVX instructions:</p>

<pre><code>vpor
vpxor
vpand
vpandn
</code></pre>

<p>I was told I should use 2-byte VEX prefixes as much as possible instead of 3-byte ones to make the code smaller and faster, but I don't know exactly how to do so. I read somewhere that I should use xmm[0-7] instead of xmm[89] and xmm1[0-5], but I don't know which combinations of operands would give me 2-byte VEX prefixes as opposed to 3-byte ones. These instructions are used with 2 or 3 operands as shown in the following snippet:</p>

<pre><code>%macro sbox1 4
vmovdqa xmm7,  xmm4
vpandn  xmm4,  xmm0
vpor    xmm10, xmm5,  xmm2
vpxor   xmm13, xmm2,  xmm0
vpxor   xmm11, xmm5,  xmm7
vpxor   xmm14, xmm4,  xmm3
vpandn  xmm12, xmm13, xmm11
vpand   xmm13, xmm10
vpxor   xmm15, xmm11, xmm2
vpxor   xmm8,  xmm13, xmm3
vpandn  xmm9,  xmm14, xmm8
vpor    xmm13, xmm5
vpor    xmm5,  xmm0
vpandn  xmm8,  xmm7
vpandn  xmm15, xmm14
vpxor   xmm13, xmm15
vpor    xmm6,  xmm5,  xmm13
vpandn  xmm5,  xmm3
vpandn  xmm15, xmm9,  xmm13
vmovdqa xmm3,  xmm8 
vpxor   xmm8,  xmm6
vpxor   xmm5,  xmm3
vpand   xmm13, xmm10
vpandn  xmm4,  xmm2
vpxor   xmm2,  xmm6,  xmm14
vpxor   xmm6,  xmm10
vpandn  xmm4,  xmm2
vpxor   xmm2,  xmm4,  pnot
vpxor   xmm4,  xmm11
vpxor   xmm13, xmm2
vpor    xmm4,  xmm3
vpandn  xmm2,  xmm1,  xmm8
vpor    xmm14, xmm7
vpxor   xmm4,  xmm10
vpor    xmm9,  xmm1
vpxor   xmm2,  xmm13
vpxor   xmm4,  xmm0
vpxor   xmm13, xmm4
vpxor   xmm9,  xmm13
vpor    xmm5,  xmm12
vpxor   xmm9,  %1

vmovdqa %1,    xmm9
vpor    xmm6,  xmm5
vpor    xmm13, xmm11
vpxor   xmm6,  xmm4
vpor    xmm0,  xmm1,  xmm15
vpxor   xmm13, xmm6
vpxor   xmm2,  %3
vmovdqa %3,    xmm2
vpxor   xmm13, %2
vpand   xmm4,  xmm15
vpandn  xmm6,  xmm14
vpxor   xmm13, xmm0
vmovdqa %2,    xmm13
vpxor   xmm4,  xmm6
vpor    xmm4,  xmm1
vpxor   xmm4,  xmm5
vpxor   xmm4,  %4
vmovdqa %4,    xmm4
%endmacro
</code></pre>
","<p>It turned out that I just needed to use xmm0...xmm7 <strong>as the last operand</strong> to have the instruction encoded with a 2-byte VEX prefix.</p>
","519","<assembly><64-bit><des><avx><yasm>","2","2","2","2013-10-12 04:17:42","19330492","3","","","","","2013-09-25 22:22:24",""
"25344235","C crypt_r really 32 times slower than crypt?","<p>I'm doing a proof of concept descrypt bruteforcer, and have the single threaded version working nicely at around 190k hashes/s with a single core of i-7 860 cpu.</p>

<p>I am now trying to make a multithreaded version of this program (my first time playing with threads, so I'm hoping that I'm doing something wrong here).</p>

<p>I first attempted to use crypt directly, this was fast but resulted in mangled hashes, as the threads were contesting the crypt function.</p>

<p>Using mutex lock and unlock on the function helped, but this reduced the speed of the program to just a few percent higher than the single threaded version.</p>

<p>I then managed to google up crypt_r which was advertised to be threadsafe.
Modified both the singlethreaded version to use crypt_r (with single thread)
and the multithreaded version to use it instead of crypt, and the performance in singlethreaded version dropped to around 3.6k h/s and to around 7.7k h/s in the multithreaded version when using two cores at 99.9% utilization.</p>

<p>So the question is, should it be this slow?</p>
","<p>The problem was, that the function I was calling when executing the crypt_r function also contained the code for initializing the struct that it requires.</p>

<p>The solution was to move the initialization out of the function that is called when hashing is done.</p>

<p>simplified example <strong>incorrect</strong> way:</p>

<pre><code>for (int i = 0; i &lt; 200000; i++)
{
    struct crypt_data data;
    data.initialized = 0;

    char* hash = crypt_r(""password"", ""sa"", &amp;data);
    printf(""%i %s"", i, hash);
}
</code></pre>

<p>correct way:</p>

<pre><code>struct crypt_data data;
data.initialized = 0;

for (int i = 0; i &lt; 200000; i++)
{
    char* hash = crypt_r(""password"", ""sa"", &amp;data);
    printf(""%i %s"", i, hash);
}
</code></pre>
","508","<c><multithreading><performance><des><crypt>","3","0","1","2014-08-17 22:12:04","","7","","","","","2014-08-16 21:37:29",""
"40613557","Encrypting with DES with user input password","<p>I'm still studying cryptography. I'm trying to create a simple static function in C# that encrypts string to DES (with a Base64 ouput). I learned that DES use 8-Byte as its key. I want the user to input string of any length, use it as the key to encrypt the message, then convert it to Base64. Example is in this <a href=""https://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow noreferrer"">site</a>.</p>

<pre><code>public static string EncryptDES(string phrase, string key)
{
    string encrypted = """";

    byte[] phraseBytes = System.Text.ASCIIEncoding.ASCII.GetBytes(phrase);
    byte[] keyBytes = System.Text.Encoding.UTF8.GetBytes(key);

    System.Security.Cryptography.MD5CryptoServiceProvider hashMD5Provider 
                                = new System.Security.Cryptography.MD5CryptoServiceProvider();
    System.Security.Cryptography.DESCryptoServiceProvider provider 
                                = new System.Security.Cryptography.DESCryptoServiceProvider();

    provider.Mode = System.Security.Cryptography.CipherMode.CBC;

    System.Security.Cryptography.ICryptoTransform transform 
                                = provider.CreateEncryptor(keyBytes, keyBytes);
    System.Security.Cryptography.CryptoStreamMode mode 
                                = System.Security.Cryptography.CryptoStreamMode.Write;



    System.IO.MemoryStream memStream = new System.IO.MemoryStream();
    System.Security.Cryptography.CryptoStream cryptoStream 
                                = new System.Security.Cryptography.CryptoStream(memStream, transform, mode);
    cryptoStream.Write(phraseBytes, 0, phraseBytes.Length);
    cryptoStream.FlushFinalBlock();

    byte[] encryptedMessageBytes = new byte[memStream.Length];
    memStream.Position = 0;
    memStream.Read(encryptedMessageBytes, 0, encryptedMessageBytes.Length);

    encrypted = System.Convert.ToBase64String(encryptedMessageBytes);

    return (encrypted);
} // private static string EncryptDES(string phrase, string key) { }
</code></pre>

<p>Then call it like this in Main:</p>

<pre><code>SimpleEncryption.EncryptDES(""A message regarding some secure 512-bit  encryption"", ""AnUltimatelyVeryVeryLongPassword"");
</code></pre>

<p>When a user inputs a random number of string length (whether greater than or less than 8 characters), a cryptographic exception always happens in this line:</p>

<pre><code>System.Security.Cryptography.ICryptoTransform transform = provider.CreateEncryptor(keyBytes, keyBytes);
</code></pre>

<p>It says <code>Specified key is not a valid size for this algorithm.</code></p>

<p>Removing parts of the key to fit in the length of 8 characters (with or without hashing) doesn't seems to be a secure solution (there might be a high rate of collision).</p>

<p>How can I implement DES (not 3DES) with a user input string?</p>
","<p>You need to generate a hash from the user's password and take only 8 bytes to use as your key.</p>

<pre><code>var fullHash = hashMD5Provider.ComputeHash(System.Text.Encoding.ASCII.GetBytes(key));
var keyBytes = new byte[8];
Array.Copy(fullHash , keyBytes, 8);
</code></pre>

<p>Your question expressed concern about hash collisions from throwing away part of the hash; yes, that certainly does increase the risk, but (assuming your hash algorithm is good) you're no worse off than if you just used a hash algorithm that only produced 8 bytes to begin with.  A good hash algorithm should distribute the entropy evenly.</p>
","506","<c#><encryption><des>","2","0","1","2016-11-16 16:18:14","","4","","5174519","","2016-11-15 15:55:50","2016-11-15 15:23:21",""
"49066575","Proper way to decrypt CryptoJS DES encoded string using Java?","<p>In JavaScript side I use:</p>

<pre><code>CryptoJS.DES.encrypt('Content', 'password').toString()
</code></pre>

<p>The result:</p>

<pre><code>U2FsdGVkX1/25rW2q0X7/pOtExFyP7MD
</code></pre>

<p>In Java side I try to decrypt it:</p>

<pre><code>public static void main(String[] args) throws Exception {

String password = ""password"";
String encryptedString = ""U2FsdGVkX1/25rW2q0X7/pOtExFyP7MD"";

DESKeySpec key = new DESKeySpec(password.getBytes());
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");

Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

SecureRandom secureRandom = new SecureRandom();
byte[] ivspec = new byte[cipher.getBlockSize()];
secureRandom.nextBytes(ivspec);

IvParameterSpec iv = new IvParameterSpec(ivspec);

    cipher.init(Cipher.DECRYPT_MODE, keyFactory.generateSecret(key), iv);
    byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedString.getBytes()));

    System.out.println(new String(Base64.getEncoder().encode(decryptedBytes)));
}
</code></pre>

<p>But I'm getting the bad padding error:</p>

<pre><code>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.
</code></pre>

<p>Can anyone tell me what went wrong and what is the proper way to decrypt it? Assuming that the JavaScript side code cannot be changed (i.e the way to encrypt the string using DES). Thank you very much.</p>
","<p>The IV must be the same for both encryption  and decryption. in the example a new random IV is being created for decryption: <code>secureRandom.nextBytes(ivspec);</code>.</p>

<p>You need to carefully and fully review the <code>CryptoJS</code> documentation to determine how the IV is being handled. Often the IV is prepended to the encrypted data for use during decryption.</p>

<p>The <code>encryptedString</code> seems to be Base64 encoded and the decoded length is 32-bytes, just right for a 16-byte IV and 16-byte encrypted data+padding.</p>
","495","<javascript><java><encryption><cryptojs><des>","-1","1","1","2018-03-02 11:51:29","","5","0","","","","2018-03-02 09:47:06",""
"11360889","JAVA - Decipher ""DES"" encrypted random number","<p>I would like to know how i could decipher a random number DES/CBC-enciphered with a specific Key.</p>

<p>My protocol states the following:
I am sending a KeyNo (eg. 0x00)
After the KeyNo is sent i get a 8byte (DES) random number. This random number is enciphered with the selected key.</p>

<p>My question would be how do i decipher the data i receive, to find the random number using Cipher</p>

<p>Thank you.</p>
","<p>To decrypt a DES encrypted stream, simply do :</p>

<pre><code>Key key = SecretKeyFactory.getInstance(""DES"").generateSecret(new DESKeySpec(bytesOfThe Key)); // bytesOfTheKey should be 8 bytes long
Cipher cipher = Cipher.getInstance(""DES"");
cipher.init(Cipher.DECRYPT_MODE, key);
return new CipherInputStream(inputStream, cipher);
</code></pre>

<p>You may also be interested in the <a href=""http://docs.oracle.com/javase/6/docs/api/javax/crypto/Cipher.html#doFinal%28java.nio.ByteBuffer,%20java.nio.ByteBuffer%29"" rel=""nofollow"">doFinal</a> method which works on byteBuffers.</p>
","495","<java><encryption><des>","1","3","1","2012-07-06 11:31:03","11360924","1","2","263525","","2012-07-06 11:31:03","2012-07-06 10:56:55",""
"39565130","DES in python can't get the correct encoded data using pycrypto","<p>I hava a algorithm to encrypt data in java ,I want to rewrite it in python.But the two algorithm can't get the same encoded data.
java code is :</p>

<pre><code>String strDefaultKey = ""QabC-+50"";
Key key = new SecretKeySpec(strDefaultKey.getBytes(""UTF-8""), ""DES"");
encryptCipher = Cipher.getInstance(DES_ECB);
encryptCipher.init(Cipher.ENCRYPT_MODE, key);
String seed = ""2016-09-19 05:11"";
MessageDigest md5 = MessageDigest.getInstance(""MD5"");
md5.update(seed.getBytes());
byte[] m = md5.digest();
encryptCipher.doFinal(m);
byte[] encodeUrl = Base64.encodeBase64(sEncription.encrypt(m));
String finalUrl = new String(encodeUrl);
finalResult = finalUrl.substring(2, 8) + finalUrl.substring(10, 13);
</code></pre>

<p>my python code is:</p>

<pre><code>m = 'QabC-+50'
text = '2016-09-19 05:11'
md5 = MD5.new()
md5.update(text)
text = md5.hexdigest()

cipher = DES.new(m, DES.MODE_ECB)
text_temp = cipher.encrypt(text)
final_str = base64.b64encode(text_temp)
print final_str
print final_str[2:8] + final_str[10:13]
print type(text_temp)
</code></pre>

<p>The two version codes can't get the same final string. Does anybody know why?</p>
","<p>You crypto logic is ok,the difference between the two methods is their <code>MD5</code> result.</p>

<p>Without the <code>MD5</code> step:</p>

<p>Java code(I don't know what your <code>sEncription</code> is,remove it):</p>

<pre><code>import java.security.Key;
import java.security.MessageDigest;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;


public class H {
    public static void main(String args[]){
        try{
        String strDefaultKey = ""QabC-+50"";
        Key key = new SecretKeySpec(strDefaultKey.getBytes(""UTF-8""), ""DES"");
        Cipher encryptCipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        encryptCipher.init(Cipher.ENCRYPT_MODE, key);
        String seed = ""2016-09-19 05:11"";
        byte[] a = encryptCipher.doFinal(seed.getBytes());
        byte[] encodeUrl = Base64.getEncoder().encode(a);
//      byte[] encodeUrl = Base64.encodeBase64(sEncription.encrypt(m));
        String finalUrl = new String(encodeUrl);
        String finalResult = finalUrl.substring(2, 8) + finalUrl.substring(10, 13);
        System.out.println(finalUrl);
        System.out.println(finalResult);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>OUTPUT:</p>

<pre><code>Wm+DLy8m9G2BJnH2wvtKvA==
+DLy8m2BJ
</code></pre>

<p>Python Code:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES
import base64

m = 'QabC-+50'
text = '2016-09-19 05:11'
md5 = MD5.new()
md5.update(text)
# text = md5.hexdigest()
cipher = DES.new(m, DES.MODE_ECB)
text_temp = cipher.encrypt(text)
print 'text_temp is ', text_temp
final_str = base64.b64encode(text_temp)
print final_str
print final_str[2:8] + final_str[10:13]
</code></pre>

<p>OUTPUT:</p>

<pre><code>Wm+DLy8m9G2BJnH2wvtKvA==
+DLy8m2BJ
</code></pre>

<p>So without the <code>MD5</code> step,the java code and the python code have the some output.</p>

<p>What does matter is the MD5 method in the java code, it is not a right way to get the MD5 value of a string.</p>

<p>Code below contains the right way to get the string's MD5 value:</p>

<pre><code>import java.security.Key;
import java.security.MessageDigest;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;


public class H {
    public static void main(String args[]){
        try{
        String strDefaultKey = ""QabC-+50"";
        Key key = new SecretKeySpec(strDefaultKey.getBytes(""UTF-8""), ""DES"");
        Cipher encryptCipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        encryptCipher.init(Cipher.ENCRYPT_MODE, key);
        String seed = ""2016-09-19 05:11"";
        String seedMd5 = MD5(seed);
        byte[] a = encryptCipher.doFinal(seedMd5.getBytes());
        byte[] encodeUrl = Base64.getEncoder().encode(a);
        String finalUrl = new String(encodeUrl);
        String finalResult = finalUrl.substring(2, 8) + finalUrl.substring(10, 13);
        System.out.println(finalUrl);
        System.out.println(finalResult);
        }catch(Exception e){
            e.printStackTrace();
        }
    }

    static String MD5(String src) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance(""MD5"");
            StringBuffer deviceIDString = new StringBuffer(src);
            src = convertToHex(md.digest(deviceIDString.toString().getBytes()));
        } catch (Exception e) {
            src = ""00000000000000000000000000000000"";
        }
        return src;
    }

    private static String convertToHex(byte[] data) {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i &lt; data.length; i++) {
            int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
            int two_halfs = 0;
            do {
                if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9))
                    buf.append((char) ('0' + halfbyte));
                else
                    buf.append((char) ('a' + (halfbyte - 10)));
                halfbyte = data[i] &amp; 0x0F;
            } while (two_halfs++ &lt; 1);
        }
        return buf.toString();
    }
}
</code></pre>

<p>OUTPUT:</p>

<pre><code>c/C16RAE1fADZXNi2H0YlevNhuucGYYHGVQ7v0Eoo9w=
C16RAEADZ
</code></pre>

<p>Python Code:</p>

<pre><code>from Crypto.Hash import MD5
from Crypto.Cipher import DES
import base64

m = 'QabC-+50'
text = '2016-09-19 05:11'
md5 = MD5.new()
md5.update(text)
text = md5.hexdigest()
cipher = DES.new(m, DES.MODE_ECB)
text_temp = cipher.encrypt(text)
final_str = base64.b64encode(text_temp)
print final_str
print final_str[2:8] + final_str[10:13]
</code></pre>

<p>OUTPUT:</p>

<pre><code>c/C16RAE1fADZXNi2H0YlevNhuucGYYHGVQ7v0Eoo9w=
C16RAEADZ
</code></pre>

<p>Now everything is ok! :)</p>
","494","<java><python-2.7><encryption><des>","2","2","1","2016-09-19 05:23:53","39565618","1","2","1816580","","2016-09-19 05:23:53","2016-09-19 03:57:21",""
"29984798","EXC_BAD_ACCESS Code 2 on CCCrypt","<p>I am trying to use <code>DES</code> encryption to encrypt passwords (Don't ask why DES, I know it's less secure). I am doing it for the first time in iOS, thus had to rely on another post about how to do it. </p>

<p>When I run the encryption it returns null, same with decrypting an already encrypted string(I used an online tool to encrypt). When I put a breakpoint to see what is going on, it stopped at <code>CCCrypt</code> mentioning <code>EXC_BAD_ACCESS (Code 2)</code>.</p>

<p>I tried using different CCOptions, but it returns the same thing always. 
Any hint what's going wrong? Is iv string required?</p>

<p>I have used the following NSString category to encrypt or decrypt Strings - </p>

<pre><code>#import ""NSString+DES.h""

@implementation NSString(DES)

- (NSString*) encryptDES: (NSString *) key
{
    const void *vplainText;
    size_t plainTextBufferSize;

    plainTextBufferSize = [self length];
    vplainText = (const void *) [self UTF8String];

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t *movedBytes;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));


    //NSString *initVec = @""init Vec"";
    const void *vkey = (const void *) [key UTF8String];
    //const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(kCCEncrypt,
                       kCCAlgorithmDES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       vkey,
                       kCCKeySizeDES,
                       NULL,
                       vplainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       movedBytes);

    NSString *result;
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    result = [myData base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
    return result;
}

- (NSString *) decryptDES: (NSString *) key
{
    const void *vplainText;
    size_t plainTextBufferSize;

    plainTextBufferSize = [self length];
    vplainText = (const void *) [self UTF8String];

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t *movedBytes;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));


    //NSString *initVec = @""init Vec"";
    const void *vkey = (const void *) [key UTF8String];
    //const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(kCCDecrypt,
                       kCCAlgorithmDES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       vkey, //""123456789012345678901234"", //key
                       kCCKeySizeDES,
                       NULL,// vinitVec, //""init Vec"", //iv,
                       vplainText, //""Your Name"", //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       movedBytes);

    NSString *result;
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    result = [myData base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
    return result;
}

@end
</code></pre>

<p><strong>Update:</strong></p>

<p>I have checked few more places and changed the code a little bit, the encryption works but doesn't get decrypted with correct value.</p>

<p>For example when I use <code>YourName</code> as string and <code>12345</code> as the key, I get <code>Fu2sK61e7l5rkXRhAKjPWA==</code> as the encrypted code, but the decryption returns <code>+54qWCYTB5LkdARDZjAow==</code> and not <code>YourName</code>.</p>

<p><strong>Updated Code:</strong> </p>

<pre><code>#import ""NSString+DES.h""

@implementation NSString(DES)

- (NSString*) encryptDES: (NSString *) key
{
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    NSData *stringData = [self dataUsingEncoding:NSUTF8StringEncoding];
    size_t numBytesEncrypted = 0;
    size_t bufferSize = stringData.length + kCCBlockSizeDES;
    void *buffer = malloc(bufferSize);

    CCCryptorStatus result = CCCrypt( kCCEncrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding,
                                     keyData.bytes, kCCKeySizeDES,
                                     NULL,
                                     stringData.bytes, stringData.length,
                                     buffer, bufferSize,
                                     &amp;numBytesEncrypted);
    NSData *output = [NSData dataWithBytes:buffer length:numBytesEncrypted];
    free(buffer);
    if( result == kCCSuccess )
    {
        NSString *resultStr = [output base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
        return resultStr;
    } else {
        NSLog(@""Failed DES encrypt..."");
        return nil;
    }

}

- (NSString *) decryptDES: (NSString *) key
{
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    NSData *stringData = [[NSData alloc] initWithBase64EncodedString:self options:0];

    size_t numBytesEncrypted = 0;
    size_t bufferSize = stringData.length + kCCBlockSizeDES;
    void *buffer = malloc(bufferSize);

    CCCryptorStatus result = CCCrypt( kCCDecrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding,
                                     keyData.bytes, kCCKeySizeDES,
                                     NULL,
                                     stringData.bytes, stringData.length,
                                     buffer, bufferSize,
                                     &amp;numBytesEncrypted);
    NSData *output = [NSData dataWithBytes:buffer length:numBytesEncrypted];
    free(buffer);
    if( result == kCCSuccess )
    {
        NSString *resultStr = [output base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
        return resultStr;
    } else {
        NSLog(@""Failed DES decrypt..."");
        return nil;
    }
}

@end
</code></pre>
","<p>There seems to be general confusion about the algorithm, DES or 3DES, a mix is being used but the key is 3DES (24-bytes). The key needs to be changed to 8-bytes. The block size constant should also be changed to <code>kCCBlockSizeDES</code> but that does not cause an error since it is the same value.</p>

<p>For the method:</p>

<pre><code>- (NSString *) decryptDES: (NSString *) key
</code></pre>

<p>The bad access error is caused because no storage is allocated for <code>movedBytes</code>, just a pointer. Change the declaration to:</p>

<pre><code>size_t movedBytes;
</code></pre>

<p>Change the reference to <code>movedBytes</code> in <code>CCCrypt</code> to <code>&amp;movedBytes</code>.</p>

<p>Test output for encryption:  </p>

<blockquote>
  <p>string: ""Your Name""<br>
  key: ""12345678""  </p>
  
  <p>movedBytes: 16<br>
  myData: 136142f6 6cd98e01 af1eef46 28d36499<br>
  result: E2FC9mzZjgGvHu9GKNNkmQ==  </p>
</blockquote>

<p>Notes from comments by request:  </p>

<p>ECB mode does not use an iv. </p>

<p>The key needs to be exactly 8-bytes for DES, if it is to short the result will be undefined. In the updated code the key is 5-bytes but the length is given as 8-bytes (<code>kCCKeySizeDES</code>) so the three missing key bytes will be whatever bytes follow <code>keyData</code>.   </p>

<p>The updated answer did not specify ECB mode, the default is CBC mode. Add <code>kCCOptionECBMode</code>.   </p>

<p>In decrypt do not use Base64 encode, convert the data to a <code>NSString</code>:</p>

<pre><code>NSString * resultStr = [[NSString alloc] initWithData:output encoding:NSUTF8StringEncoding];  
</code></pre>

<p>If using an online encryption that uses the php mcrypt function the last block of the data will be incorrect because mcrypt does not support PKCS#7 padding, it uses non-standard and insecure null padding.</p>
","493","<ios><encryption><ios7.1><des>","4","1","1","2015-05-02 12:44:35","29986592","10","","1079901","","2015-05-01 14:01:52","2015-05-01 09:56:16",""
"32741739","DES-Encrypt a byte array, java","<p>I'm using this code for DES-encryption: <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a></p>

<p>Now, I want to encrypt a byte array with this. How can I do that?</p>

<p>I have changed the name of algo from <code>DESede</code> to <code>DES</code> and am obviously using an 8-byte key (not 24).</p>
","<p><code>Cipher#doFinal</code> takes and returns <code>byte[]</code>. The only thing that you need to do is removing the additional encoding steps like</p>

<pre><code>message.getBytes(""utf-8"") // before encryption
</code></pre>

<p>and </p>

<pre><code>new String(plainText, ""UTF-8"") // after decryption
</code></pre>

<p>Obviously, you need to change the method signature from <code>String</code> to <code>byte[]</code> for both encryption and decryption.</p>
","486","<java><encryption><encoding><des>","1","0","1","2015-09-23 14:25:05","32742043","2","","-1","","2017-05-23 11:44:26","2015-09-23 14:01:18",""
"19590327","Getting invalid character in a Base-64 string","<p>I have a 16byte hex key ""<strong>F81AFDEA26D680BF</strong>"" and also a <strong>16byte encrypted text</strong> in hex as ""<strong>3508D26A7064CF68</strong>"".
I need to use DES to decrypt the above text. i'm getting an error ""invalid character in a Base-64 string"". The code Im using is </p>

<pre><code>static byte[] bytes = Encoding.ASCII.GetBytes(KeyHexAscii(""F81AFDEA26D680BF""));
public static string Decrypt(string cryptedString)
    {
        if (String.IsNullOrEmpty(cryptedString))
        {
            throw new ArgumentNullException(""The string which needs to be decrypted can not be null."");
        }

        DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
        MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(cryptedString));
        CryptoStream cryptoStream = new CryptoStream(memoryStream,  cryptoProvider.CreateDecryptor(bytes, bytes), CryptoStreamMode.Read);
        StreamReader reader = new StreamReader(cryptoStream);

        return reader.ReadToEnd();
    }

  public static string Encrypt(string originalString)
    {
        if (String.IsNullOrEmpty(originalString))
        {
            throw new ArgumentNullException(""The string which needs to be encrypted can not be null."");
        }

        DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateEncryptor(bytes, bytes), CryptoStreamMode.Write);

        StreamWriter writer = new StreamWriter(cryptoStream);
        writer.Write(originalString);
        writer.Flush();
        cryptoStream.FlushFinalBlock();
        writer.Flush();

        return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
    }
</code></pre>
","<p>None of your data appears to be Base-64 encoded, so that's not the function you want to use.  It seems you already have a <code>KeyHexAscii</code> function, you'll want to use whatever function you've written that reverses that.</p>

<p>Ideally, you would write your crypto interfaces to operate on byte arrays.  It shouldn't be involved in encoding and decoding data.  You should handle reading data and converting it to bytes somewhere else.</p>
","484","<c#><base64><des>","0","1","1","2013-10-25 16:43:36","","2","","1306322","","2013-10-25 13:35:43","2013-10-25 12:48:37",""
"23272959","Is there any library or code for DES which take 7 byte key?","<p>Do we have any library or any mechanism where we can use true 7 byte key for DES instead of 8 byte key. I need it for keys  analysis in DES and 8 byte key requirement for associated library is creating problem in getting actual keys analysis.</p>
","<p>As explained in <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">http://en.wikipedia.org/wiki/Data_Encryption_Standard</a>, the 8-byte key for DES is just a 56-bit key in 8 bytes with odd parity check added:</p>

<p>The key is nominally stored or transmitted as 8 bytes, each with odd parity. According to ANSI X3.92-1981, section 3.5:</p>

<pre><code>One bit in each 8-bit byte of the KEY may be utilized for error detection in key generation, distribution, and storage. Bits 8, 16,..., 64 are for use in ensuring that each byte is of odd parity.
</code></pre>

<p>(end quote)</p>

<p>So given an 8-byte key I can generate a 7-byte key by dropping the parity check bits and reformatting, and given a 7-byte key I can generate an 8-byte key by reformatting and adding parity check bits. It should therefore be easy to produce wrappers to make a library for one key format look like a library for another - or are you having some other problem I haven't noticed?</p>
","483","<algorithm><openssl><key><des><pycrypto>","0","2","3","2014-04-24 20:25:46","23277594","0","","3559830","","2014-04-24 16:41:02","2014-04-24 15:14:14","2014-04-26 06:58:09"
"23272959","Is there any library or code for DES which take 7 byte key?","<p>Do we have any library or any mechanism where we can use true 7 byte key for DES instead of 8 byte key. I need it for keys  analysis in DES and 8 byte key requirement for associated library is creating problem in getting actual keys analysis.</p>
","<p>In DES a key is comprised of 8 bytes with the LSB a parity bit, a nice and regular structure.  There's an implication there for the relationship between input bytes and Permuted Choice 1, which loads the two 28 bit C and D Registers. </p>

<p>In parlance of the NBS standard a Permuted Choice is a selection permutation not using all the values of a greater whole.</p>

<p>Historically any DES implementation that used 7 bytes wasn't compatible where there are several FIPS/Nist pubs specifying key/ciphertext/plaintext triplets.</p>

<p>If you have a need for a 56 bit number representing a key there's an implication you're using or storing them in a tabular fashion.  Otherwise you could simply guarantee the parity bit is either correct or say '0'.  'Packed' keys are only of interest for saving storage space.</p>

<p>All that said and done if you need a 56 bit number representing a key you could represent 8 bytes of key in a 64 bit value and after identifying the parity bit locations with respect to endian-ness, shift the 64 bit array value obliterating the parity bits one at a time in 8 operations on a 64 bit machine, leaving 56 'effective' key bits.</p>

<p>On a 32 bit or smaller machine you'd also have to track byte position to keep track of bit shift offsets and would have to deal with bits moving between bytes to pack bits into 7 bytes.</p>

<p>For a 32 bit machine you could pack two 32 bit values into 28 bits in opposite directions then merge the proper 4 bits of the second one into the first followed by shifting the second value down 8 bits.</p>

<p>For a big-endian bit in byte numbering system 1 to 8 with bit 8 the LSB (from the standard)
Bits 1-4 go to the C register, with only four  bit 4 values from 8 successive bytes of an input key (described as an input array of bits).  The D block shares bit 4 and uses bits 5-7 to derived 28 bits:</p>

<p><img src=""https://i.stack.imgur.com/byExT.jpg"" alt=""Permuted Choice 1""></p>

<p>The bigger issue here may be the ability to communicate any interesting finding in terms of keys useful to those dealing with an 8 byte key representation.  It may be handy to have an inverse function available as well.</p>

<p>There's also a relationship between round keys and the C and D concatenated block, shown in Carl Meyers and Stephen Metyas book ""Cryptography, A New Dimension in Computer Security', subtitled 'A Guide for the Design and Implementation of Secure Systems', Wiley Interscience, 1982, ISBN-0-471- 04892-5.</p>

<p>I recreated the table using a derivative of the original BSD libcrypt source.  The significance of this is that C and D bits don't mix in the two 24 bit values derived from Permuted Choice 2 (which is visible in selected key (KS) in round 16 of the table).</p>

<pre><code>  Bit  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  
KS  
   1  15 18 12 25  2  6  4  1 16  7 22 11 24 20 13  5 27  9 17  8 28 21 14  3  
   2  16 19 13 26  3  7  5  2 17  8 23 12 25 21 14  6 28 10 18  9  1 22 15  4  
   3  18 21 15 28  5  9  7  4 19 10 25 14 27 23 16  8  2 12 20 11  3 24 17  6  
   4  20 23 17  2  7 11  9  6 21 12 27 16  1 25 18 10  4 14 22 13  5 26 19  8  
   5  22 25 19  4  9 13 11  8 23 14  1 18  3 27 20 12  6 16 24 15  7 28 21 10  
   6  24 27 21  6 11 15 13 10 25 16  3 20  5  1 22 14  8 18 26 17  9  2 23 12  
   7  26  1 23  8 13 17 15 12 27 18  5 22  7  3 24 16 10 20 28 19 11  4 25 14  
   8  28  3 25 10 15 19 17 14  1 20  7 24  9  5 26 18 12 22  2 21 13  6 27 16  
   9   1  4 26 11 16 20 18 15  2 21  8 25 10  6 27 19 13 23  3 22 14  7 28 17  
  10   3  6 28 13 18 22 20 17  4 23 10 27 12  8  1 21 15 25  5 24 16  9  2 19  
  11   5  8  2 15 20 24 22 19  6 25 12  1 14 10  3 23 17 27  7 26 18 11  4 21  
  12   7 10  4 17 22 26 24 21  8 27 14  3 16 12  5 25 19  1  9 28 20 13  6 23  
  13   9 12  6 19 24 28 26 23 10  1 16  5 18 14  7 27 21  3 11  2 22 15  8 25  
  14  11 14  8 21 26  2 28 25 12  3 18  7 20 16  9  1 23  5 13  4 24 17 10 27  
  15  13 16 10 23 28  4  2 27 14  5 20  9 22 18 11  3 25  7 15  6 26 19 12  1  
  16  14 17 11 24  1  5  3 28 15  6 21 10 23 19 12  4 26  8 16  7 27 20 13  2  

  Bit 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  
KS  
   1  42 53 32 38 48 56 31 41 52 46 34 49 45 50 40 29 35 54 47 43 51 37 30 33  
   2  43 54 33 39 49 29 32 42 53 47 35 50 46 51 41 30 36 55 48 44 52 38 31 34  
   3  45 56 35 41 51 31 34 44 55 49 37 52 48 53 43 32 38 29 50 46 54 40 33 36  
   4  47 30 37 43 53 33 36 46 29 51 39 54 50 55 45 34 40 31 52 48 56 42 35 38  
   5  49 32 39 45 55 35 38 48 31 53 41 56 52 29 47 36 42 33 54 50 30 44 37 40  
   6  51 34 41 47 29 37 40 50 33 55 43 30 54 31 49 38 44 35 56 52 32 46 39 42  
   7  53 36 43 49 31 39 42 52 35 29 45 32 56 33 51 40 46 37 30 54 34 48 41 44  
   8  55 38 45 51 33 41 44 54 37 31 47 34 30 35 53 42 48 39 32 56 36 50 43 46  
   9  56 39 46 52 34 42 45 55 38 32 48 35 31 36 54 43 49 40 33 29 37 51 44 47  
  10  30 41 48 54 36 44 47 29 40 34 50 37 33 38 56 45 51 42 35 31 39 53 46 49  
  11  32 43 50 56 38 46 49 31 42 36 52 39 35 40 30 47 53 44 37 33 41 55 48 51  
  12  34 45 52 30 40 48 51 33 44 38 54 41 37 42 32 49 55 46 39 35 43 29 50 53  
  13  36 47 54 32 42 50 53 35 46 40 56 43 39 44 34 51 29 48 41 37 45 31 52 55  
  14  38 49 56 34 44 52 55 37 48 42 30 45 41 46 36 53 31 50 43 39 47 33 54 29  
  15  40 51 30 36 46 54 29 39 50 44 32 47 43 48 38 55 33 52 45 41 49 35 56 31  
  16  41 52 31 37 47 55 30 40 51 45 33 48 44 49 39 56 34 53 46 42 50 36 29 32  
</code></pre>

<p>This almost says your 56 bit number should be concatenated from the C and D Register values so there's a discernible relationship with round keys while allowing you to index based on C and/or D values.</p>
","483","<algorithm><openssl><key><des><pycrypto>","0","1","3","2014-04-24 20:25:46","23277594","0","","3559830","","2014-04-24 16:41:02","2014-04-24 15:14:14","2014-04-26 06:58:09"
"23272959","Is there any library or code for DES which take 7 byte key?","<p>Do we have any library or any mechanism where we can use true 7 byte key for DES instead of 8 byte key. I need it for keys  analysis in DES and 8 byte key requirement for associated library is creating problem in getting actual keys analysis.</p>
","<p>I tried editing pyDes library code I just took 7 byte key and converted back to 64 bits by padding '0' to every multiple of 8th positions of bits.  so the analysis on 7 byte-key actually required for algorithm hopefully is gained and the the parity bits are taken as 0 (that is not associated to my key now)  :) . please comment if my key still is not solely for DES algorithm.. </p>
","483","<algorithm><openssl><key><des><pycrypto>","0","0","3","2014-04-24 20:25:46","23277594","0","","3559830","","2014-04-24 16:41:02","2014-04-24 15:14:14","2014-04-26 06:58:09"
"14439555","ENCRYPTION :""DES"" with ""PBKDF2WithHmacSHA1""","<p>Could I use ""PBKDF2WithHmacSHA1"" algorithm with ""DES"" encryption.</p>
","<p>you are probably using <code>PBKDF2WithHmacSHA1</code> to generate a key with 128 bits or more, which won't work with <code>DES</code> since it uses a 56 bit key. </p>

<p>I don't know what language you are trying to generate a key in, but there should be a parameter to specify key length.  make sure its specified to output a 56-bit key.</p>

<p>the 56 bit key length for DES is also why you shouldn't use DES.  your key will be brute forcable in under a day.  Use AES. </p>
","473","<encryption><des>","-6","0","1","2013-01-21 17:25:04","14443998","6","","1103872","","2013-01-21 14:03:49","2013-01-21 13:18:43","2013-01-22 01:57:20"
"23655064","Can we implement 512 key size with Triple Des algorithm","<p>My question is can we extend key length of Triple DES to 512 instead of 168?</p>

<p>How to prove that there is no 512 bits Triple DES and if I want to use very secure algorithm what is the maximum key length I can use in triple DES. How can I justify key size choice. </p>

<p>I found that link in Oracle that refer to the key size of triple DES as star * but I don't know what that mean?</p>

<p><a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html"" rel=""nofollow"">http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html</a></p>
","<p><a href=""https://en.wikipedia.org/wiki/Triple_des"" rel=""nofollow"">Triple DES</a> is by definition 168 bits (although dependent on the selected option, the key (excluding parity bits) may actually only be 56 or 112 bits instead of 168 bits). There is no way to extend the key length. If you need a longer key length, then you should use an encryption algorithm that supports that key length.</p>

<p>There is no need to ""prove"" this as you ask, as it is described in the standard documents.</p>

<p>Also note that by today standards, DES is considered very weak and Triple DES is considered relatively weak (especially with keying option 2 and 3). I'd suggest you go for a more modern and stronger algorithm like AES.</p>
","470","<java><algorithm><encryption><des>","-1","3","2","2014-05-15 07:30:02","","2","","409172","","2014-05-15 00:04:34","2014-05-14 12:40:55",""
"23655064","Can we implement 512 key size with Triple Des algorithm","<p>My question is can we extend key length of Triple DES to 512 instead of 168?</p>

<p>How to prove that there is no 512 bits Triple DES and if I want to use very secure algorithm what is the maximum key length I can use in triple DES. How can I justify key size choice. </p>

<p>I found that link in Oracle that refer to the key size of triple DES as star * but I don't know what that mean?</p>

<p><a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html"" rel=""nofollow"">http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html</a></p>
","<p>No because triple DES means 3 times DES with 3 different keys, or with 2 keys if one key is reused. So the size in bits is either 128 bits or 192 bits - if you count the parity bits as part of the key, 112 or 168 bits - if you do not count the parity and even lower values - if you look at the security strength of 3DES.</p>

<p>The key size of 3DES is not its main weakness. The main weakness is the whole construction with weak keys and the 8 byte blocksize. Furthermore, 3DES is much <em>slower</em> than e.g. AES. Just upgrading the key size will only get you much lower performance, without much benefit to security.</p>

<p>The * in the Oracle provider means ""any"", but that * is only present in the table that displays the key sizes you can use without downloading the unlimited crypto files. The actual key sizes that are supported <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider"" rel=""nofollow"">are listed for the SunJCE provider</a>. That table shows the actual bits in the key used for cryptographic calculations by the way (112 &amp; 168); the encoding will still be 16 or 24 bytes. Note that old(er) Java versions only allow 24 byte keys (which means you have to do some copying of bytes if you have a 16 byte key as input).</p>

<p>Don't use DES, and leave 3DES alone except for backwards compatibility.</p>
","470","<java><algorithm><encryption><des>","-1","2","2","2014-05-15 07:30:02","","2","","409172","","2014-05-15 00:04:34","2014-05-14 12:40:55",""
"6690311","DES encryption in Java and PHP","<p>I need to create a class that will encrypt the text and sends that to PHP server. Then PHP server Decode that.</p>

<p><em>But problem is that, I don't know PHP so I can not write code with same logic (as I used in Java) to decrypt the text, so I am fully dependent on codes those are at Internet, but I am unable to find those code with same logic(Same in Java and PHP). I need only DES encryption.</em> </p>

<p>Can you provide me some links or codes, please?</p>
","<p>The mcrypt-extension is what you want to use. You will find plenty of examples in the <a href=""http://de3.php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">documentatin</a> and the comments.</p>
","469","<java><php><des>","1","2","1","2011-07-14 08:23:54","6690394","4","","","","","2011-07-14 08:14:50",""
"8239109","Clarification on PRNG Algorithm as per ANSI X9.31","<p>Newbee question:</p>

<p>I am studying ANSI X9.31 -1998 for implementing PRNG as per section 2.4. I am not able to properly understand the representation of varibles used - like ""ede"". </p>

<ul>
<li>Is the ""ede"" an operation or a variable ?</li>
<li>Why a * is used before X? Is it some kind of a standard representation? </li>
<li>Is there any specific document which describes all these?</li>
</ul>

<p>""A.2.4 Generating Pseudo Random Numbers Using the DEA</p>

<p>Let ede*X(Y) represent the DEA multiple encryption of Y under the key *X. </p>

<p>Let *K be a DEA key pair reserved only for the generation of pseudo random numbers, let V be a 64-bit seed value which is also kept secret, and let XOR be the exclusive-or operator. Let DT be a date/time vector which is updated on each iteration. I is an intermediate value. A 64-bit vector R is generated as follows: </p>

<p>I = ede*K(DT)</p>

<p>R = ede*K(I XOR V) and a new V is generated by V = ede*K(R XOR I).</p>

<p>Successive values of R may be concatenated to produce a pseudo random number of the desired length."" </p>
","<p>EDE means <em>Encrypt, Decrypt, Encrypt</em>, the usual protocol when using <a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">Triple DES</a>.</p>

<p>The use of <code>*</code> looks a lot like the more usual subscription common to cryptography articles:</p>

<p>EDE<sub>X</sub>(Y) to mean using X as the key for the algorithm EDE.</p>
","461","<encryption><random><des>","0","1","1","2011-11-23 08:38:28","8239198","1","","","","","2011-11-23 08:28:57",""
"10978630","Java DES encryption with random padding","<p>I have a requirement to encrypt and decrypt a file using DES algorithm in java, I need to pad some random charatcters in between the file words during encryption and I need to remove them during decryption using program, so that even if somebody gets the secret key and encryted file , they will not be able to get the content, without using my program,is there any way available. to achieve this.</p>

<p>would appreciate your suggestions.</p>
","<p>Random padding can only be removed if the length of either the file, or the padding, is known.</p>

<p>You will have to ensure that one or the other is known to whoever decrypts the file, and hidden from all others.  This is far from trivial.  It is also not needed, since you will have to keep the key secret anyway, so adding a length just makes for extra work.  Use PKCS7 for padding, and concentrate your efforts on keeping the key secret.</p>
","459","<java><encryption><des>","0","2","1","2012-06-12 03:43:10","10978701","3","","948535","","2012-06-12 03:43:10","2012-06-11 10:45:10",""
"16495524","PKCS#11 Soft Token for supporting symmetric function","<p>For testing my codes, I need a PKCS#11 soft token which support symmetric functions like AES, DES, ...
Which PKCS#11 soft token support at least one symmetric function?</p>
","<p>I found OpenCryptokey:</p>

<p><a href=""http://www.ibm.com/developerworks/linux/library/s-pkcs/"" rel=""nofollow"">http://www.ibm.com/developerworks/linux/library/s-pkcs/</a></p>

<p>This Soft Token has symmetric functions.</p>
","456","<aes><des><encryption-symmetric><pkcs#11>","0","0","1","2013-05-11 12:54:37","16497306","0","","","","","2013-05-11 09:06:02",""
"15259979","Trouble with DES_ENCRYPT in AWS RDS","<p>I am having trouble with DES_ENCRYPT on the Amazon Web Services RDS MySQL database - the AWS RDS is SSL so it should support the DES_ENCRYPTION - in particular, WHEN I Run the SQL query from php_myadmin or the cli, with commands like  - </p>

<pre><code> SELECT `ID`,  DES_ENCRYPT( `Name`,'xxxxxxxxxxxxxxxxxxxxxx') FROM names; 
</code></pre>

<p>it works, and I see a list of ids and encrypted names
But if I run </p>

<pre><code>'UPDATE names SET `Name` = DES_ENCRYPT( `Name`,'xxxxxxxxxxxxxxxxxxxxxx'); 
</code></pre>

<p>the query looks like it works, but the <code>Name</code> column just contains blanks - Any suggestions would be appreciated...</p>
","","450","<mysql><encryption><amazon-web-services><des><rds>","0","","0","2013-03-06 23:10:31","","7","","998158","","2013-03-06 23:10:31","2013-03-06 23:07:37",""
"42420098","How to extract the IV vector generated by encrypt method from encrypted_strings","<p>I'm having troubles to extract the IV generated with the <code>encrypt</code> method from <code>encrypted_strings</code> library for a specific password I provide. From the documentation, I see that this method generates a key and iv based on a password using a C library that calls the same method as openssl to generate the key and iv: EVP_BytesToKey.</p>

<p>What I'm trying to do is to be able to print the IV for any password I specify so I can port the encryption to another language.</p>

<p>Can you think of any method to extract/print this IV vector from a password?</p>

<p>These are the details of the algorithm, mode and padding this library uses:</p>

<ul>
<li>ALGO: DES-EDE3 </li>
<li>MODE: CBC  </li>
<li>PADDING: PKCS5</li>
</ul>

<p>The ruby script below prints out the encrypted message but no clue which iv was used.</p>

<pre><code>#!/usr/bin/ruby
require 'encrypted_strings'

data = 'Whackabad'
password = 'bAJLyifeUJUBFWdHzVbykfDmPHtLKLMzViHW9aHGmyTLD8hGYZ'

encrypted_data = data.encrypt(:symmetric, :password =&gt; password)
printf ""Data: #{data}\n""
printf ""Encrypted Data: #{encrypted_data}""
</code></pre>

<p>I tried to use <code>openssl</code> as it allows me to print the iv and key generated using <code>-p</code> option but it uses a <code>PKCS7</code> padding instead of <code>PKCS5</code>. So if I run the command below, doesn't print the same encrypted string as the ruby code above.</p>

<pre><code>echo -n 'Whackabad' | openssl enc -des-ede3-cbc -nosalt -a -k bAJLyifeUJUBFWdHzVbykfDmPHtLKLMzViHW9aHGmyTLD8hGYZ
</code></pre>

<p>NOTE:
-a: base64 encode, -k: password, and echo -n: removes the new line from the string so its exactly the same size as the ruby in string.</p>

<p>If I add <code>-nopad</code> option, I don't know how to pad the output to get exactly the same encrypted result. </p>

<p>Any help would be much appreciated</p>
","<p>PKCS7 padding is basically the same as PKCS5. The reason you get a different result on the command line is that it only uses a single hash iteration, where the function used by <code>encrypted_strings</code> <a href=""http://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html#method-i-pkcs5_keyivgen"" rel=""nofollow noreferrer"">does 2048 iterations by default</a>.</p>

<p>The function used, <a href=""https://wiki.openssl.org/index.php/Manual:EVP_BytesToKey(3)"" rel=""nofollow noreferrer""><code>EVP_BytesToKey</code> is described in the OpenSSL wiki</a>, which include details of the algorithm. Reproducing it in Ruby might look something like this (using MD5 and 2048 iterations):</p>

<pre><code>def hash(d, count)
  count.times do
    d = OpenSSL::Digest.digest('md5', d)
  end
  d
end

password = 'bAJLyifeUJUBFWdHzVbykfDmPHtLKLMzViHW9aHGmyTLD8hGYZ'

bytes = ''
last = ''

# For des-ede3-cbc, 24 byte key + 8 byte IV = 32 bytes.
while bytes.length &lt; 32
  last = hash(last + password, 2048)
  bytes &lt;&lt; last
end

key = bytes[0...24]
iv = bytes[24..-1]
</code></pre>

<p>You can use these values to decrypt the result of your code (add <code>require 'base64'</code> first):</p>

<pre><code># This is the result of your code:
encrypted_data = ""AEsDXVcgh2jsTjlDgh+REg==""

# enrypted_strings produces base64 encoded results, so we decode first
encrypted_data = Base64.decode64(encrypted_data)

cipher = OpenSSL::Cipher.new('des-ede3-cbc')
cipher.decrypt
cipher.key = key
cipher.iv = iv

plain = cipher.update(encrypted_data) + cipher.final

puts plain #=&gt; ""Whackabad""
</code></pre>
","449","<ruby><encryption><openssl><des><pkcs#5>","0","3","1","2017-02-23 19:00:15","42422932","2","","1045346","","2017-02-23 16:33:42","2017-02-23 15:37:59",""
"41398026","PyDES with Bloomberg data","<p>I am trying to decrypt DES encoded Bloomberg financial data with PyDES. The file ends in gz.enc, I am able to read the file to a binary, reload the binary back in to a variable (the variable has data)  and then use the following decryption on it.</p>

<pre><code>k = pyDes.des(password, pyDes.ECB, padmode=pyDes.PAD_PKCS5)
released = k.decrypt(encrypted_data)
</code></pre>

<p>The problem is I get an empty string for 'released'. I unfortunately  cannot share the file nor the password due to privacy laws. I cannot use the bloomberg decryption as they do not support Ubuntu nor Mac. </p>
","","449","<python-3.x><encryption><des><bloomberg>","2","","0","2016-12-30 14:42:59","","3","1","","","","2016-12-30 14:42:59",""
"49234934","How can I encrypt string with DES algorithm in Javascript?","<p>I have the following shell script which uses openssl to encrypt string:</p>

<pre><code>encrypt() {
STRING_TO_BE_ENCRYPTED=$1
DATE_STRING=$2

MD5=$(/bin/echo -n ${DATE_STRING} | openssl md5)
MD5=${MD5#*=\ }

key=${MD5:0:8}
iv=${MD5:24:8}

key=$(/bin/echo -n ""${key}"" |od -A n -t x1|sed s/\ //g)
iv=$(/bin/echo -n ""${iv}"" |od -A n -t x1|sed s/\ //g)

/bin/echo -n ""${STRING_TO_BE_ENCRYPTED}"" | openssl des -e -nosalt -K ${key} -iv ${iv} -a
}
</code></pre>

<p>I am trying to make the same function in javascript(to use it in postman). At the moment I have the following code:</p>

<pre><code>var DATE_STRING = ""Tue, 6 Mar 2018 11:47:23 EET"";
var STRING_TO_BE_ENCRYPTED = ""somestring"";

//MD5=$(/bin/echo -n ${DATE_STRING} | openssl md5)
//MD5=${MD5#*=\ }
var MD5 = CryptoJS.MD5(DATE_STRING).toString();

//key=${MD5:0:8}
var key=MD5.substring(0, 8);
//iv=${MD5:24:8}
var iv=MD5.substring(MD5.length - 8);

//key=$(/bin/echo -n ""${key}"" |od -A n -t x1|sed s/\ //g)
var keyHex = toHex(key);
//iv=$(/bin/echo -n ""${iv}"" |od -A n -t x1|sed s/\ //g)
var ivHex = toHex(iv);
And the only issue that I have is the last string from my shell script:

// /bin/echo -n ""${STRING_TO_BE_ENCRYPTED}"" | openssl des -e -nosalt -K ${key} -iv ${iv} -a
</code></pre>

<p>I completely stuck with encrypting using ""des"". Could some please help me with converting the last string to javascript?</p>
","<p>Ok, so I played little bit more with my code and now I have the working one:</p>

<pre><code>var DATE_STRING = ""Tue, 6 Mar 2018 11:47:23 EET"";
var str=""somestring"";
var MD5 = CryptoJS.MD5(DATE_STRING).toString();

var key=MD5.substring(0, 8);
var iv=MD5.substring(MD5.length - 8);    

var keyHex = CryptoJS.enc.Utf8.parse(key);
var ivHex = CryptoJS.enc.Hex.parse(CryptoJS.enc.Utf8.parse(iv).toString(CryptoJS.enc.Hex));

var encrypted = CryptoJS.DES.encrypt(str, keyHex, { iv: ivHex, mode: CryptoJS.mode.CBC });
var result = encrypted.toString();
</code></pre>

<p>So this code produces the same result as my shell script with openssl</p>
","447","<javascript><encryption><des>","1","0","1","2018-03-12 13:40:14","49236680","3","","","","","2018-03-12 12:10:33",""
"36895793","Text encryption/decryption methods Java","<p>I am working on Android project where I have to use both encryption and decryption methods. scenario as below:</p>

<ol>
<li>User type password in SignupActivity</li>
<li>user's password is encrypted</li>
<li>in Login Activity password is retrieved from data base and decrypt method is called </li>
</ol>

<p>my problem  is in step 3 it always return null from decryption.</p>

<p>Code sample:</p>

<p>SignUpActivity:</p>

<pre><code>    String name_data = name.getText().toString();
    String email_data = email.getText().toString();
    String password_data = password.getText().toString();

    password_data = enc.getEncryptedText(password_data);
</code></pre>

<p>LoginActivity</p>

<pre><code>            String password_in_database = helper.searchPassword(email_data);
            password_in_database = enc.getDecryptedText(password_in_database);
</code></pre>

<p>Encryption/Decryption class</p>

<pre><code>public class EncryptDecryptStringWithDES {

    public static Cipher ecipher;
    public static Cipher dcipher;

    public static SecretKey key;


    public static String getEncryptedText(String sty) throws Exception {

        // generate secret key using DES algorithm
        key = KeyGenerator.getInstance(""DES"").generateKey();
        ecipher = Cipher.getInstance(""DES"");


        // initialize the ciphers with the given key

        ecipher.init(Cipher.ENCRYPT_MODE, key);




        sty = encrypt(sty);

        return sty;
    }

    public static String getDecryptedText(String sty) throws Exception {
   key = KeyGenerator.getInstance(""DES"").generateKey();

        dcipher = Cipher.getInstance(""DES"");
        dcipher.init(Cipher.DECRYPT_MODE, key);
        sty = decrypt(sty);

        return sty;

    }


    public static String encrypt(String str) {

        try {

            // encode the string into a sequence of bytes using the named charset

            // storing the result into a new byte array.

            byte[] utf8 = str.getBytes(""UTF8"");

            byte[] enc = ecipher.doFinal(utf8);

// encode to base64

            enc = BASE64EncoderStream.encode(enc);

            return new String(enc);

        } catch (Exception e) {

            e.printStackTrace();

        }

        return null;

    }

    public static String decrypt(String str) {

        try {

            // decode with base64 to get bytes

            byte[] dec = BASE64DecoderStream.decode(str.getBytes());

            byte[] utf8 = dcipher.doFinal(dec);

// create new string based on the specified charset

            return new String(utf8, ""UTF8"");

        } catch (Exception e) {

            e.printStackTrace();

        }

        return null;

    }
</code></pre>
","<p>First of all, don't use DES, use AES. </p>

<p>The best you can do is not saving the password. Instead, use the password as the key to AES. That's means your user will have to type in the password on each boot, but it's the most secure solution.</p>

<p>If you have to save the password locally, you need a consistent key - your code generate a new key each function call. Generate a new key on signup and store it encrypted with a fixed key on shared preferences.</p>
","442","<android><encryption><des>","0","0","1","2016-04-27 19:56:47","","2","2","","","","2016-04-27 16:36:41",""
"14482375","What's the benefit of using a well-known encryption algorithm?","<p>I can easily handcraft my own encryption algorithm like the following:</p>

<pre><code>// make sure the private key is long enough
byte key[] = {0x3e, 0x33, 0x7e, 0x02, 0x48, 0x2a, 0x4e, ...};
byte data[] = ""a string to be encrypted"".getBytes(""utf-8"");
for (int i = 0, j = 0; i &lt; data.length; ++i, ++j) {
    data[i] ^= key[j];
    if (j + 1 == key.length)
        j = 0;
}
</code></pre>

<p>With the above algorithm, if I don't give away the private key, I find no easy way of breaking the encryption(or I am too naive?), if an encryption algorithm can be created easily like this, what's the point in creating the standard? what's the benefit of using those well-known algorithms?</p>
","<p>The main benefit of using a well known algorithm is that it will be reviewed and analyzed for defects and weaknesses.  If you roll your own, you don't get the benefit of community review.  Moreover, it's probably almost as easy, or just as easy, to use built in encryption, depending on your platform.  </p>

<p>I'm no expert in cryptanalysis, but something this simple probably isn't that secure. </p>

<p>Besides, if it were this easy, wouldn't everyone do it? </p>
","440","<encryption><des>","-2","1","3","2013-01-23 15:25:36","14482839","2","1","","","","2013-01-23 14:44:49",""
"14482375","What's the benefit of using a well-known encryption algorithm?","<p>I can easily handcraft my own encryption algorithm like the following:</p>

<pre><code>// make sure the private key is long enough
byte key[] = {0x3e, 0x33, 0x7e, 0x02, 0x48, 0x2a, 0x4e, ...};
byte data[] = ""a string to be encrypted"".getBytes(""utf-8"");
for (int i = 0, j = 0; i &lt; data.length; ++i, ++j) {
    data[i] ^= key[j];
    if (j + 1 == key.length)
        j = 0;
}
</code></pre>

<p>With the above algorithm, if I don't give away the private key, I find no easy way of breaking the encryption(or I am too naive?), if an encryption algorithm can be created easily like this, what's the point in creating the standard? what's the benefit of using those well-known algorithms?</p>
","<p>speaking directly to your proposed algorithm, there are a couple of major problems with it:</p>

<ol>
<li><p>If your data is longer than your key, then it will become very easy to recover your key, because it becomes like a Vigenere Cipher.</p></li>
<li><p>you can only use a key to encrypt a single message.  Encrypting two or more messages with the same key causes the same problems that reusing the key within a message does, but even worse.</p></li>
<li><p>Because your key has to be as long as the message to actually be secure, you have a key management nightmare.  How do you store the key that is as long as the message? how do you communicate it securely to whomever wants to read it? What if you want to encrypt a 1GB file? you now need 2GB of storage for your encrypted version</p></li>
<li><p>Your key has to be perfectly random.  Any flaws in your random number generator will expose information about your message and key.  Admittedly, this is an issue with algorithms like AES too, but while a bad RNG will reduce the effort to break an AES message/key, it is not nearly as bad as it would be for your scheme</p></li>
</ol>

<p>Well known algorithms like AES address these sorts of issues, using short keys to get more security.  a single 256 bit key can be used to encrypt a huge number of messages before it becomes unsafe to use, and managing and storing a 256 bit key is much easier than a 1GB one.</p>
","440","<encryption><des>","-2","3","3","2013-01-23 15:25:36","14482839","2","1","","","","2013-01-23 14:44:49",""
"14482375","What's the benefit of using a well-known encryption algorithm?","<p>I can easily handcraft my own encryption algorithm like the following:</p>

<pre><code>// make sure the private key is long enough
byte key[] = {0x3e, 0x33, 0x7e, 0x02, 0x48, 0x2a, 0x4e, ...};
byte data[] = ""a string to be encrypted"".getBytes(""utf-8"");
for (int i = 0, j = 0; i &lt; data.length; ++i, ++j) {
    data[i] ^= key[j];
    if (j + 1 == key.length)
        j = 0;
}
</code></pre>

<p>With the above algorithm, if I don't give away the private key, I find no easy way of breaking the encryption(or I am too naive?), if an encryption algorithm can be created easily like this, what's the point in creating the standard? what's the benefit of using those well-known algorithms?</p>
","<p>You use a well-known algorithm in order to <a href=""https://security.stackexchange.com/questions/25585/is-my-developers-home-brew-password-security-right-or-wrong-and-why/"">not become Dave</a>.</p>

<p><a href=""https://www.schneier.com/blog/archives/2011/04/schneiers_law.html"" rel=""nofollow noreferrer"">Schneier's Law</a> states that ""any person can invent a security system so clever that she or he can't think of how to break it.""</p>

<p>Which basically means: an security system (encryption algorithm, authentication system, ...) can't be assumed to be secure because <em>the creator</em> says it's secure. Other experts on the topic <strong>must review it</strong> (and usually review it for a long time) before it can be considered secure.</p>
","440","<encryption><des>","-2","3","3","2013-01-23 15:25:36","14482839","2","1","","","","2013-01-23 14:44:49",""
"46738664","Decrypting DESede cipher with NoPadding","<p>For a Crypto class we've been given a DESede ciphertext using ECB with no padding => ""6t8Z5bKl5ybJL+MiFerNBmiTDS7wlTEUdWNwJJApWmQ=="" which is in base64 form.
We were given clues about the key and so I constructed all possible keys (where all are in an ASCII format).</p>

<pre><code>            String strToDecrypt=""6t8Z5bKl5ybJL+MiFerNBmiTDS7wlTEUdWNwJJApWmQ=="";
            byte[] input = strToDecrypt.getBytes();

            //Decrypt
            Cipher b = Cipher.getInstance(""DESede/ECB/NoPadding"");
            b.init(Cipher.DECRYPT_MODE, keySpec);
            byte output[] = b.doFinal(input);
            String out = new String(output);
            System.out.println(new String(out));
</code></pre>

<p>When I run this code using my keys, I get an IllegalBlockSizeException as my input isn't a multiple of 8 bytes.
I'm confused as to which ""bases"" to use. As I've said above, the ciphertext is in base64 so When running Cipher.DECRYPT should I be giving keys in a certain ""base"" or the string I want to decrypt in a certain base.</p>
","<p>Don't make the key generation harder than it needs to be. You want to try each possible value for the first byte of the variable section. But what if that value is 0xFB? Subsequent values would be 0xFC, 0xFD, 0xFE, and 0xFF. But what about the last value? You can assume that they wrap around, to 0x00.</p>

<p>If that's the case, something like this should work to find the correct key:</p>

<pre><code>static byte[] search(byte[] ciphertext) throws GeneralSecurityException {
  byte[] key = template(); /* Initialize the fixed bytes of ""key"" */
  Cipher nopadding = ... ; /* Create the correct cipher */
  for (long xy = 0; xy &lt; 256; ++xy) { /* Iterate over possible values */
    for (long wz = 0; wz &lt; 256; ++wz) { /* Is there another range? */
      for (int off = 0; off &lt; 6; ++off) {
        key[8 + off] = (byte) (xy + off); /* Set the first range */
      }
      for (int off = 0; off &lt; 6; ++off) {
        key[16 + off] = (byte) (wz + off); /* Set the second range */
      }
      nopadding.init(/* Initialize the cipher with your key */);
      byte[] plaintext = nopadding.doFinal(ciphertext);
      String str = new String(plaintext, StandardCharsets.US_ASCII);
      /* Return the key if it produced valid text */
      if (str.indexOf('\uFFFD') &lt; 0) return key;
    }
  }
  throw new IllegalArgumentException(); /* No key found */
}
</code></pre>
","439","<java><des><3des>","-1","1","1","2017-10-16 04:02:27","","10","2","","","","2017-10-13 22:10:45",""
"52787147","Using CTR mode in DES algorithm (in python)","<p>I want to use CTR mode in DES algorithm in python by using PyCryptodome package. My code presented at the end of this post. However I got this error: ""TypeError: Impossible to create a safe nonce for short block sizes"". It is worth to mention that, this code work well for AES algorithm but it does not work for DES, DES3 , Blowfish and etc (with 64 block size). To my knowledge CTR mode can be applied in the 64 block cipher algorithms.</p>

<pre><code>from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes
data = b'My plain text'
key = get_random_bytes(8)
cipher = DES.new(key, DES.MODE_CTR)
ct_bytes = cipher.encrypt(data)
nonce = cipher.nonce
cipher = DES.new(key, DES.MODE_CTR, nonce=nonce)
pt = cipher.decrypt(ct_bytes)
print(""The message was: "", pt)
</code></pre>

<p>Thanks alot.</p>
","<pre><code>bs = DES.block_size
plen = bs - len(plaintext) % bs
padding = [plen] * plen
padding = pack('b' * plen, *padding)
key = get_random_bytes(8)
nonce = Random.get_random_bytes(4)
ctr = Counter.new(32, prefix=nonce)
cipher = DES.new(key, DES.MODE_CTR,counter=ctr)
ciphertext = cipher.encrypt(plaintext+padding)
</code></pre>
","432","<encryption><des><block-cipher><pycryptodome><ctr-mode>","1","0","2","2018-10-15 08:28:56","","2","","","","","2018-10-12 21:21:52",""
"52787147","Using CTR mode in DES algorithm (in python)","<p>I want to use CTR mode in DES algorithm in python by using PyCryptodome package. My code presented at the end of this post. However I got this error: ""TypeError: Impossible to create a safe nonce for short block sizes"". It is worth to mention that, this code work well for AES algorithm but it does not work for DES, DES3 , Blowfish and etc (with 64 block size). To my knowledge CTR mode can be applied in the 64 block cipher algorithms.</p>

<pre><code>from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes
data = b'My plain text'
key = get_random_bytes(8)
cipher = DES.new(key, DES.MODE_CTR)
ct_bytes = cipher.encrypt(data)
nonce = cipher.nonce
cipher = DES.new(key, DES.MODE_CTR, nonce=nonce)
pt = cipher.decrypt(ct_bytes)
print(""The message was: "", pt)
</code></pre>

<p>Thanks alot.</p>
","<p>The library <a href=""https://www.pycryptodome.org/en/latest/src/cipher/classic.html#ctr-mode"" rel=""nofollow noreferrer"">defines the nonce</a>
as that part of the counter block that is not incremented.</p>

<p>Since the block is only 64 bits long, it is hard to securely define how long that nonce should be,
given the danger of wraparound (if you encrypt a lot of blocks) or nonce reuse (if you generate the nonce randomly).</p>

<p>You can instead decide that the nonce is not present, the counter takes the full 64 bits and a random initial value.</p>

<pre><code>iv = get_random_bytes(8)
cipher = DES.new(key, nonce=b'', initial_value=iv)
</code></pre>

<p>Finally, I guess that this is only an exercise.
DES is a very weak cipher, with a key length of only 56 bits and a block size of only 64 bits.
Use AES instead.</p>
","432","<encryption><des><block-cipher><pycryptodome><ctr-mode>","1","1","2","2018-10-15 08:28:56","","2","","","","","2018-10-12 21:21:52",""
"22085107","perl CBC DES equivalent in java","<p>We are migrating some code from perl to java/scala and we hit a roadblock.</p>

<p>We're trying to figure out how to do this in Java/scala:</p>

<pre><code>use Crypt::CBC;
$aesKey         = ""some key""
$cipher = new Crypt::CBC($aesKey, ""DES"");
$encrypted = $cipher-&gt;encrypt(""hello world"");
print $encrypted    // prints:  Salted__�,%�8XL�/1�&amp;�n;����쀍c
$decrypted = $cipher-&gt;decrypt($encrypted);
print $decrypted    // prints: hello world
</code></pre>

<p>I tried a few things in scala but didn't really get it right, for example something like this:</p>

<pre><code>  val secretKey = new SecretKeySpec(""some key"".getBytes(""UTF-8""), ""DES"")
  val encipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
  encipher.init(Cipher.ENCRYPT_MODE, secretKey)
  val encrypted = encipher.doFinal(bytes)

  println(""BYTES:"" + bytes)
  println(""ENCRYPTED!!!!!!: "" + encrypted)
  println(toString(encrypted))
</code></pre>

<p>Any help or direction in Java/scala would very much be appreciated</p>
","<p>Assuming that Crypt module is the one I find at <a href=""https://metacpan.org/pod/Crypt::CBC"" rel=""nofollow"">https://metacpan.org/pod/Crypt::CBC</a> it is documented as by default doing (the same as) openssl, apparently meaning commandline 'enc' (openssl library has MANY other options). That is not encryption 
with the specified key (and IV) directly, but instead 'password-based' encryption (PBE) with a key and IV derived from the specified 'key' (really passphrase) plus (transmitted) salt, using a twist on the original (now unrecommended) PKCS#5 v1.5 algorithm, retronymed PBKDF1. See <a href=""http://www.openssl.org/docs/crypto/EVP_BytesToKey.html"" rel=""nofollow"">http://www.openssl.org/docs/crypto/EVP_BytesToKey.html</a> (or the man page on a Unix system with openssl installed) and rfc2898 (or the original RSA Labs PKCS documents now somewhere at EMC).</p>

<p>You say you cannot change the perl sender. I hope the users/owners/whoever realize that original DES, 
retronymed single-DES for clarity, has been practically brute-forceable for well over a decade, and 
PBE-1DES may be even weaker; the openssl twist doesn't iterate as PKCS#5 (both KDF1 and KDF2) should.</p>

<p>Java (with the Suncle providers) does implement PBEWithMD5AndDES, which initted with PBEParameterSpec (salt, 1)
does successfully decrypt data from 'openssl enc -des-cbc', and thus I expect also your perl sender (not tested). 
FWIW if you could change to triple-DES, Java implements PBEWithMD5AndTripleDES using an apparently nonstandard 
extension of PBKDF1 (beyond hash size) that is quite unlike openssl's nonstandard extension, and thus incompatible if the perl module is in fact following openssl.
You would have to do the key-derivation yourself and then direct 3DES-CBC-pad, which isn't very hard.</p>

<p>Also note encrypted data from any modern computer algorithm is binary. ""Printing"" it as if it were text 
in perl, or Java or nearly anything else, is likely to cause data corruption if you try to use it again.
If you are only looking to see 'is there any output at all, and is it visibly not the plaintext' you're okay.</p>
","431","<java><aes><des>","1","0","1","2014-04-08 15:32:54","","5","2","","","","2014-02-27 19:39:16",""
"2204700","Are there any really compact DES implementation in ARM assembler?","<p>I have a bootloader limited to 32K Bytes, when the DES is added (about 6384 Bytes), it exceeds the limit. So anybody know any DES implementation in ARM assembler as small as possible? </p>

<p>thanks!</p>
","<p>Why do you need this in the bootloader ? You want to crypt/trust your main software ?
Anyway, one solution might be to add a lightweight decompressor, and compress a part of your bootloader code, and uncompress at runtime.</p>

<p>Adding more software to the blob might sound strange, but you should evaluate this option.</p>

<p>On <a href=""http://www.oberhumer.com/opensource/ucl/"" rel=""nofollow noreferrer"">this page</a>, they claim to have a very small decompressor, which fit in 200 bytes of code. I guess they mean i386 code, but it looks quite small anyway.</p>
","430","<assembly><arm><des>","2","1","2","2010-02-06 04:12:37","2207895","2","","49246","","2010-02-05 20:05:02","2010-02-05 02:33:41",""
"2204700","Are there any really compact DES implementation in ARM assembler?","<p>I have a bootloader limited to 32K Bytes, when the DES is added (about 6384 Bytes), it exceeds the limit. So anybody know any DES implementation in ARM assembler as small as possible? </p>

<p>thanks!</p>
","<p>Assembler isnt necessarily going to make it smaller or faster.  Have you tried compiling in thumb mode?  Are you using a processor that supports thumb mode?</p>
","430","<assembly><arm><des>","2","0","2","2010-02-06 04:12:37","2207895","2","","49246","","2010-02-05 20:05:02","2010-02-05 02:33:41",""
"13175147","Java Cipher DES weird results","<p>I have a problem I have been trying to solve for last three days. I have to use DES to encrypt an array of bytes to get a specific result. The default implementation of DES in Java (Javax.crypto.cipher, JDK 7, provider SunJCE version 1.7), however, seemingly does not work.
When I have the following code:</p>

<pre>
<code>
    private void testDES() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        byte[] keyByte = convertStringToBytes(""00 00 00 00 00 00 00 00"");
        byte[] data = convertStringToBytes(""00 00 00 00 00 00 00 00"");
        Key key = new SecretKeySpec(keyByte, ""DES"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        System.out.println(hexadecimalString(cipher.doFinal(data)));
    }
</code>
</pre>

<p>It prints F4 DA 4D 97 BF CF 23 D9 instead of the correct result 8C A6 4D E9 C1 B1 23 A7 (according to the test vectors : <a href=""http://common-lisp.net/project/clbuild/mirror/ironclad/test-vectors/des.testvec"" rel=""nofollow"">http://common-lisp.net/project/clbuild/mirror/ironclad/test-vectors/des.testvec</a>)
The methods hexadecimalString and convertStringToBytes just transform byte to hexa and vice versa. 
Could anyone please help me? After searching for a rather long time, I just don't know what to do. Thanks in advance. Joe</p>
","<p>I think the problem is with either convertStringToBytes or hexadecimalString.</p>

<p>You can replace:</p>

<pre><code>byte[] keyByte = convertStringToBytes(""00 00 00 00 00 00 00 00"");
byte[] data = convertStringToBytes(""00 00 00 00 00 00 00 00"");
</code></pre>

<p>with:</p>

<pre><code>byte[] keyByte = new byte[8];
byte[] data = new byte[8];
</code></pre>

<p>... because in Java, arrays are initialised to zero.</p>

<p>When I run the same code, but with the above (and not convertStringToBytes), then I get the expected result (8C A6 ...)</p>

<p><strong>Edit:</strong>
Since you're still having problems, here's a full program. The output for me is:</p>

<pre><code>8c a6 4d e9 c1 b1 23 a7 
</code></pre>

<p>Code below:</p>

<pre><code>public class Main {
    public static void main(String[] args) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        byte[] keyByte = new byte[8];
        byte[] data = new byte[8];
        Key key = new SecretKeySpec(keyByte, ""DES"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] result = cipher.doFinal(data);
        StringBuilder str = new StringBuilder();
        for (byte b : result) {
             str.append(Integer.toHexString(0xff &amp; b)).append(' ');
        }
        System.out.println(str);
    }
}
</code></pre>
","416","<java><encryption><des>","0","1","1","2012-11-01 11:07:06","13175598","1","2","1791010","","2012-11-01 10:49:30","2012-11-01 10:28:21",""
"43909824","ValueError: Input strings must be a multiple of 8 in length when input utf-8 in python 3.6","<pre><code>def get_encrypt_param(params):
    _salt = b""\xA9\x9B\xC8\x32\x56\x35\xE3\x03""
    _iterations = 2
    data = []
    for i in params:
        data.append(""{}={}"".format(i, params[i]))
    str_param = ""&amp;"".join(data)
    print(str_param)
    padding = 8 - len(str_param) % 8
    str_param += chr(padding) * padding
    print(str_param)
    hasher = MD5.new()
    hasher.update(apikey.encode())
    hasher.update(_salt)
    result = hasher.digest()
    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()
    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])

    encrypted = encoder.encrypt(str_param)
    encryptParam = base64.b64encode(encrypted)
    return res
</code></pre>

<p>When I input chinese character, </p>

<pre><code>params = {
    ""name"": u""张三"",
    ""idCard"": ""123456199001011233"",
    ""mobile"": ""13800138000""
}
print(get_encrypt_param(params))
</code></pre>

<p>ValueError: Input strings must be a multiple of 8 in length.
But it' ok when I input english character.
Please help me.
I try to :</p>

<pre><code>for i in params:
    data.append(""{}={}"".format(i, params[i].encode(""utf-8"")))
</code></pre>

<p>But the str_param is :</p>

<pre><code>mobile=b'13800138000'&amp;name=b'\xe5\xbc\xa0\xe4\xb8\x89'&amp;cardno=b'123456199001011233'
</code></pre>

<p>it's bytes and others can't recognise the decrypt params.</p>
","<p>use another package：pyDes</p>

<p>Code：</p>

<pre><code>import pyDes


def get_encrypt_param(params):
    """"""对参数进行加密封装""""""
    _salt = b""\xA9\x9B\xC8\x32\x56\x35\xE3\x03""
    _iterations = 2
    data = []
    for i in params:
        data.append(""{}={}"".format(i, params[i]))
    str_param = ""&amp;"".join(data)

    hasher = MD5.new()
    hasher.update(apikey.encode())
    hasher.update(_salt)
    result = hasher.digest()
    for i in range(1, _iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    despy = pyDes.des(result[:8], pyDes.CBC, padmode=pyDes.PAD_PKCS5, IV=result[8:16])
    encrypt_data = despy.encrypt(str_param.encode())
    return base64.b64encode(encrypt_data）
</code></pre>

<p>so you can encrypt chinese character without encoding(""utf-8).</p>
","408","<python><utf-8><des>","0","0","1","2017-05-15 09:47:24","","0","","7796335","","2017-05-15 09:47:24","2017-05-11 08:07:29",""
"46440718","Triple DES Encryption of String To 8 byte hex","<p>I have to encrypt a string to an 8 byte hex using TDES. Below are the values (modified for reference)</p>

<pre><code>key = 636948778095358323114731
pin=1234
</code></pre>

<p>Code for encryption :</p>

<pre><code>function encryptText_3des($plainText, $key) {
  $key = hash(""md5"", $key, TRUE); 
  for ($x=0;$x&lt;8;$x++) {
      $key = $key.substr($key, $x, 1);
  }
  $padded = pkcs5_pad($plainText,mcrypt_get_block_size(MCRYPT_3DES, MCRYPT_MODE_CBC));
  $encrypted = base64_encode(mcrypt_encrypt(MCRYPT_3DES, $key, $padded, MCRYPT_MODE_CBC));
  return $encrypted;
}

function pkcs5_pad ($text, $blocksize) {
  $pad = $blocksize - (strlen($text) % $blocksize);
  return $text . str_repeat(chr($pad), $pad);
}
</code></pre>

<p>However when i do this : </p>

<pre><code>//outputs 3des encrypted data
echo encryptText_3des($data, $encryption_key);
</code></pre>

<p>I get this error : </p>

<pre><code>   Warning: mcrypt_encrypt(): Encryption mode requires an initialization 
vector of size 8 
</code></pre>

<p>How can i get the value ?..(please i also need it as a 8 byte hex..)
Thanks</p>
","<p>You miss initialization vector for encryption function:</p>

<pre><code>function encryptText_3des($plainText, $key)
{
    $key = hash(""md5"", $key, TRUE);
    for ($x = 0; $x &lt; 8; $x++) {
        $key = $key . substr($key, $x, 1);
    }
    $padded = pkcs5_pad($plainText,mcrypt_get_block_size(MCRYPT_3DES, MCRYPT_MODE_CBC));

    // CBC initialization vector
    $iv_size = mcrypt_get_iv_size(MCRYPT_3DES, MCRYPT_MODE_CBC);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);

    $encrypted = base64_encode(mcrypt_encrypt(MCRYPT_3DES, $key, $padded, MCRYPT_MODE_CBC, $iv));

    return $encrypted;
}
</code></pre>

<p>Also do not forget to save <code>$iv</code> string somewhere (include in encrypted string for example), because IV bytes are required for TDES decryption procedure later.</p>

<p><a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow noreferrer"">See also</a></p>
","406","<php><encryption><des>","1","1","1","2017-09-27 07:36:37","46441559","0","","380331","","2017-09-27 07:02:26","2017-09-27 06:17:48",""
"35772093","3des in ios providing different encrypted value each time on load?","<p>can any one suggest me why 3des in ios results different encoded string each time onload in ios? initially i am converting ""key"" into md5 formatted string and then used the same as a key in 3des to generate the encoded value.</p>

<p>here is my code:</p>

<pre><code>-(NSData *)tripleDesEncryptString:(NSString *)input key:(NSString* )key error:(NSError **)error{
    //TDES
    NSParameterAssert(input);
    NSParameterAssert(key);
    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    size_t outLength;
    //NSAssert(keyData.length == kCCKeySize3DES, @""the keyData is an invalid size"");
    NSMutableData *outputData = [NSMutableData dataWithLength:(inputData.length  +  kCCBlockSize3DES)];
    CCCryptorStatus result = CCCrypt(
        kCCEncrypt, // operation
        kCCAlgorithm3DES, // Algorithm
        kCCOptionECBMode | kCCOptionPKCS7Padding, // options
        keyData.bytes, // key
        keyData.length, // keylength
        nil, // iv
        inputData.bytes, // dataIn
        inputData.length, // dataInLength,
        outputData.mutableBytes, // dataOut
        outputData.length, // dataOutAvailable
        &amp;outLength // dataOutMoved
    );

    if (result != kCCSuccess) {
        if (error != NULL) {
            *error = [NSError errorWithDomain:@""com.your_domain.your_project_name.your_class_name."" code:result userInfo:nil];
        }
        return nil;
    }
    [outputData setLength:outLength];
    return outputData;
}

-(void) testEncryptionAndDecryption {
    NSString *str =@""ker!@#$%^&amp;*()"";
    id md5data =[str MD5];
    NSString *md5dataString =(NSString *)md5data;
    NSData *encrypted = [self tripleDesEncryptString:@""abcdef@dd.com:123"" key:md5dataString error:nil];
    NSString *strData = [encrypted  base64EncodedStringWithOptions:0];
    NSLog(@""encrypted data length: %@"",strData);
    NSString *str2 = [[NSString alloc] initWithData:encrypted encoding:NSUTF8StringEncoding];
    NSLog(@""%@"",str2);
}
</code></pre>
","<p>The test code is flawed.</p>

<pre><code>NSString *str =@""ker!@#$%^&amp;*()"";
id md5data =[str MD5];
NSString *md5dataString =(NSString *)md5data;
</code></pre>

<p>It is unclear what <code>MD5</code> is, probably a category?</p>

<p>The <code>MD5</code> function produces a 16-byte result but 3DES requires a 24-byte key.</p>

<p><code>NSString *str2 = [[NSString alloc] initWithData:encrypted encoding:NSUTF8StringEncoding];</code>  will fail because arbitrary data can bot be represented as a string. That is why Base64 is used.   </p>

<p>It really is best to write an encryption method that takes and returns <code>NSData</code> arguments and a do any string operation outside of it. That creates single responsibility methods.</p>

<p>Here is a refactored version--but still insecure:</p>

<pre><code>-(NSData *)tripleDesEncryptData:(NSData *)data
                            key:(NSData* )key
                          error:(NSError **)error {
    NSParameterAssert(data);
    NSParameterAssert(key);
    NSAssert(key.length == kCCKeySize3DES, @""the keyData is an invalid size"");

    size_t outLength;
    NSMutableData *outputData = [NSMutableData dataWithLength:(data.length  +  kCCBlockSize3DES)];

    CCCryptorStatus
    result = CCCrypt(kCCEncrypt, // operation
                     kCCAlgorithm3DES, // Algorithm
                     kCCOptionECBMode | kCCOptionPKCS7Padding , // options
                     key.bytes, // key
                     key.length, // keylength
                     nil,// iv
                     data.bytes, // dataIn
                     data.length, // dataInLength,
                     outputData.mutableBytes, // dataOut
                     outputData.length, // dataOutAvailable
                     &amp;outLength); // dataOutMoved

    if (result != kCCSuccess) {
        if (error != NULL) {
            *error = [NSError errorWithDomain:@""com.your_domain.your_project_name.your_class_name.""
                                         code:result
                                     userInfo:nil];
        }
        return nil;
    }
    [outputData setLength:outLength];
    return outputData;
}

- (NSData *)hash192String:(NSString *)inputString {
    NSData *inputData = [inputString dataUsingEncoding:NSUTF8StringEncoding];
    NSMutableData *hash = [NSMutableData dataWithLength:CC_SHA256_DIGEST_LENGTH];

    CC_SHA256(inputData.bytes, (unsigned int)inputData.length, hash.mutableBytes);

    return [hash subdataWithRange:NSMakeRange(0, 24)];
}


-(void) testEncryptionAndDecryption {
    NSString *md5String  = @""ker!@#$%^&amp;*()"";
    NSString *stringData = @""abcdef@dd.com:123"";

    NSData *keyData   = [self hash192String:md5String];
    NSData *data      = [stringData dataUsingEncoding:NSUTF8StringEncoding];
    NSData *encrypted = [self tripleDesEncryptData:data key:keyData error:nil];

    NSString *encryptedBase64 = [encrypted  base64EncodedStringWithOptions:0];

    NSLog(@""encrypted base64\nlength: %lu\nstring: %@"", (unsigned long)encryptedBase64.length, encryptedBase64);
}
</code></pre>

<p>Output:  </p>

<blockquote>
  <p>encrypted base64<br>
  length: 32<br>
  string: +VSdzF4BmAMnGITAWFqaY2mgp8Nr8I13  </p>
</blockquote>
","393","<ios><objective-c><iphone><ipad><des>","-1","2","2","2017-10-09 10:58:28","","4","1","954312","","2016-03-04 08:21:20","2016-03-03 12:22:09",""
"35772093","3des in ios providing different encrypted value each time on load?","<p>can any one suggest me why 3des in ios results different encoded string each time onload in ios? initially i am converting ""key"" into md5 formatted string and then used the same as a key in 3des to generate the encoded value.</p>

<p>here is my code:</p>

<pre><code>-(NSData *)tripleDesEncryptString:(NSString *)input key:(NSString* )key error:(NSError **)error{
    //TDES
    NSParameterAssert(input);
    NSParameterAssert(key);
    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    size_t outLength;
    //NSAssert(keyData.length == kCCKeySize3DES, @""the keyData is an invalid size"");
    NSMutableData *outputData = [NSMutableData dataWithLength:(inputData.length  +  kCCBlockSize3DES)];
    CCCryptorStatus result = CCCrypt(
        kCCEncrypt, // operation
        kCCAlgorithm3DES, // Algorithm
        kCCOptionECBMode | kCCOptionPKCS7Padding, // options
        keyData.bytes, // key
        keyData.length, // keylength
        nil, // iv
        inputData.bytes, // dataIn
        inputData.length, // dataInLength,
        outputData.mutableBytes, // dataOut
        outputData.length, // dataOutAvailable
        &amp;outLength // dataOutMoved
    );

    if (result != kCCSuccess) {
        if (error != NULL) {
            *error = [NSError errorWithDomain:@""com.your_domain.your_project_name.your_class_name."" code:result userInfo:nil];
        }
        return nil;
    }
    [outputData setLength:outLength];
    return outputData;
}

-(void) testEncryptionAndDecryption {
    NSString *str =@""ker!@#$%^&amp;*()"";
    id md5data =[str MD5];
    NSString *md5dataString =(NSString *)md5data;
    NSData *encrypted = [self tripleDesEncryptString:@""abcdef@dd.com:123"" key:md5dataString error:nil];
    NSString *strData = [encrypted  base64EncodedStringWithOptions:0];
    NSLog(@""encrypted data length: %@"",strData);
    NSString *str2 = [[NSString alloc] initWithData:encrypted encoding:NSUTF8StringEncoding];
    NSLog(@""%@"",str2);
}
</code></pre>
","<pre><code>func testCrypt(data:NSData, keyData:NSData, ivData:NSData) -&gt; String {

    var base64cryptString = String()
    let cryptData    = NSMutableData(length: Int(data.length) + kCCBlockSizeAES128)!
    let keyLength              = size_t(kCCKeySizeAES128)
    let operation: CCOperation = UInt32(kCCEncrypt)
    let algoritm:  CCAlgorithm = UInt32(kCCAlgorithmAES128)
    let options:   CCOptions   = UInt32(kCCOptionPKCS7Padding)

    var numBytesEncrypted :size_t = 0
    let cryptStatus = CCCrypt(operation,
                              algoritm,
                              options,
                              keyData.bytes, keyLength,
                              ivData.bytes,
                              data.bytes, data.length,
                              cryptData.mutableBytes, cryptData.length,
                              &amp;numBytesEncrypted)

    if UInt32(cryptStatus) == UInt32(kCCSuccess) {
        cryptData.length = Int(numBytesEncrypted)
        base64cryptString = cryptData.base64EncodedString(options: .endLineWithLineFeed)
    }
    return base64cryptString
}
</code></pre>

<p>You can call <code>func testCrypt(data:NSData, keyData:NSData, ivData:NSData)</code> by passing the data which needs to be encrypted and the key and value in NSData format. </p>

<p>For example:</p>

<pre><code>let data: NSData! = message.data(using: .utf8) as NSData!; 
let keyData: NSData! = keyValue.data(using: .utf8) as NSData!; 
let ivData: NSData! = ivValue.data(using: .utf8) as NSData!;
var base64cryptString = self.testCrypt(data: data, keyData: keyData, ivData: ivData)
</code></pre>
","393","<ios><objective-c><iphone><ipad><des>","-1","0","2","2017-10-09 10:58:28","","4","1","954312","","2016-03-04 08:21:20","2016-03-03 12:22:09",""
"30991960","Problems with Dictionary key-lookups. No match when there should be","<p>I'm trying to simulate a Meet-in-the-Middle attack on Double DES which works as follows:</p>

<p><img src=""https://i.stack.imgur.com/3g6jG.png"" alt=""""></p>

<p>So I'm performing the MitM attack by first encrypting a known plaintext m and with all possible values of k1, and then subsequently I decrypt a known ciphertext c with all possible values of k2. Then there should be a match inbetween which gives me k1, and k2. I'm using a cut-down key size of 20 bits instead of 56bit (or 64bit which is what the DES implementation actually wants as input). I just pad with zeroes after 20bits.</p>

<p>I've implemented what I think is a right solution but not getting any matches. </p>

<p><strong>My two hashtables:</strong></p>

<pre><code>Dictionary&lt;string, string&gt; hashTable = new Dictionary&lt;string, string&gt;();       
Dictionary&lt;string, string&gt; matches = new Dictionary&lt;string, string&gt;();
</code></pre>

<p><strong>Encrypting</strong>:</p>

<p>Since I'm using a reduced 20bit key, there can be 2<sup>20</sup> different combinations of 20bits. So for each iteration, I take the counter <code>i</code>, convert it to a binary string representation, then I pad 0s until it makes a 64bit binary value. Then I convert this string to a byte array and encrypt the plaintext with the key. I'm storing the output (intermediary cipher) as the <code>key</code> in the <code>hashTable</code> and the actual key used to get that cipher, as the <code>value</code>.</p>

<pre><code>//First generate all possible intermediary values
for(int i=0; i&lt; Math.Pow(2,20); i++)
{ 
    string key1 = ToBin(i, 20);
    string paddedKey1 = ToBin(i, 20).PadRight(64, '0');

    //First encryption of plaintext1 using key1
    string intermediaryCipher = 
               DESWrapper.DES_Encrypt(plaintext1, ConvertBinaryStringToByteArray(paddedKey1));


    hashTable.Add(intermediaryCipher, key1);

    //Show the current iteration in binary
    Console.WriteLine(ToBin(i, 20));
}
</code></pre>

<p><strong>DESWrapper.DES_Encrypt method:</strong></p>

<pre><code>public static string DES_Encrypt(string input, byte[] key)
{
    DESCryptoServiceProvider desCryptoService = new DESCryptoServiceProvider();

    //Reflection necessary otherwise it complains about a weak key, so bypassing that check
    MethodInfo mi = desCryptoService.GetType().GetMethod(""_NewEncryptor"", BindingFlags.NonPublic | BindingFlags.Instance);
    object[] Par = { key, desCryptoService.Mode, key, desCryptoService.FeedbackSize, 0 };

    ICryptoTransform trans = mi.Invoke(desCryptoService, Par) as ICryptoTransform;

    byte[] resultArray = trans.TransformFinalBlock(Encoding.Default.GetBytes(input), 0, Encoding.Default.GetBytes(input).Length);
    desCryptoService.Clear();
    return Convert.ToBase64String(resultArray, 0, resultArray.Length);
}
</code></pre>

<p>After the encryption I have a hastable with 2<sup>20</sup> entries. The next thing I do is to make the decryption:</p>

<p><strong>Decrypting:</strong></p>

<p>When I'm decrypting <code>ciphertext1</code> with the current padded key, the result, if it is the correct key, will be an intermediary cipher which already exists in the <code>hashTable</code> as a <code>Key</code>. So I perform this lookup. If it exists I save the two keys to another hashtable <code>matches</code>. If it doesn't exist I move on.</p>

<pre><code>for (int i = 0; i &lt; Math.Pow(2, 20); i++)
{
     string key2 = ToBin(i, 20);
     string paddedKey2 = ToBin(i, 20).PadRight(64, '0');

    //Decrypting ciphertext1 with key2 (64bit padded)
    string intermediaryCipher =
    DESWrapper.DES_Decrypt(ciphertext1,   ConvertBinaryStringToByteArray(paddedKey2));

    var temp = hashTable.FirstOrDefault(x =&gt; x.Key == intermediaryCipher);
    if(temp.Key != null)
    {
        matches.Add(temp.Value, key2);
        Console.WriteLine(""Found match!"");
        Console.ReadKey();
    }

    //Show the current iteration in binary
    Console.WriteLine(ToBin(i, 20));
}
</code></pre>

<p><strong>DESWrapper.DES_Decrypt:</strong></p>

<pre><code>public static string DES_Decrypt(string input, byte[] key)
{
    DESCryptoServiceProvider desCryptoService = new  DESCryptoServiceProvider();

    //Again have to use reflection..
    MethodInfo mi = desCryptoService.GetType().GetMethod(""_NewEncryptor"", BindingFlags.NonPublic | BindingFlags.Instance);
    object[] Par = { key, desCryptoService.Mode, key, desCryptoService.FeedbackSize, 0 };
    ICryptoTransform trans = mi.Invoke(desCryptoService, Par) as ICryptoTransform;

    byte[] resultArray = trans.TransformFinalBlock(Encoding.Default.GetBytes(input), 0, Encoding.Default.GetBytes(input).Length);
    desCryptoService.Clear();
    return Convert.ToBase64String(resultArray);
}
</code></pre>

<p><strong>The problem:</strong></p>

<p>I never get a match, so the hashtable lookup always returns an empty key-value pair. I don't understand why. Eventually it should match but it doesn't.</p>

<p>Could the problem be in the way I'm trying to look up the values in the <code>hashTable</code>?</p>

<hr>

<p><strong>Other information:</strong></p>

<p>To encrypt the intial plaintext and ciphertext I use a fabricated key which the 17th bit set to 1 and all other 63 bits set to 0. This is done for both keys.</p>

<p>In this way I should get the match quite fast when I'm doing the decryption, but I'm not sure if the problem is here. Including the code anyway:</p>

<pre><code>        private static void GeneratePlaintextCiphertextPairs(out string plainText1, out string plainText2, out string cipherText1, out string cipherText2)
    {
        Random rnd = new Random(Guid.NewGuid().GetHashCode());

        //Generate two random keys of 20 bits padded with 0s to reach 64 bits
        //We need 64 bits because the implementation of DES requires it. Internally,
        //it will only use 56 bits
        byte[] key1 = GenerateRandom64BitPaddedKey(rnd);
        byte[] key2 = GenerateRandom64BitPaddedKey(rnd);

        plainText1 = ""Hello Dear World"";

        //Perform double DES encryption
        cipherText1 = DESWrapper.DES_Encrypt(
                                DESWrapper.DES_Encrypt(plainText1, key1),
                                key2);

        plainText2 = ""Hello Evil World"";

        //Perform double DES encryption
        cipherText2 = DESWrapper.DES_Encrypt(
                                DESWrapper.DES_Encrypt(plainText2, key1),
                                key2);
    }

    private static byte[] GenerateRandom64BitPaddedKey(Random rnd)
    {
        short keySize = 64;

        //The first 20bits are of interest, the rest is padded with 0s
        BitArray bitArray = new BitArray(keySize);

        for (int i=0; i&lt;keySize; i++)
        {
            //if(i &lt; 20) { bitArray[i] = rnd.NextDouble() &gt; 0.5; }
            //else { bitArray[i] = false; }
            if (i == 17) { bitArray[i] = true; }
            else { bitArray[i] = false; }
        }

        //Console.WriteLine(""In Binary: "" + ToDigitString(bitArray));
        byte[] key = new byte[8];
        ReverseBitArray(ref bitArray);     
        bitArray.CopyTo(key, 0);
        return key;            
    }
</code></pre>
","","388","<c#><dictionary><encryption><hashtable><des>","1","","0","2016-06-15 10:05:37","","2","2","","","","2015-06-23 00:27:14",""
"16613293","Chyper SharedPreferences GSON objetcs","<p>I want to store an encrypted Profile object in <code>SharedPreferences</code> using gson.</p>

<p>Here's my code:</p>

<pre><code>public void saveProfile(Profile newProfile) {
  try {
    Log.i(C.TAG, newProfile.toString());

    SharedPreferences.Editor editor = prefs.edit();
    String profileJSONfied = new Gson().toJson(newProfile);
    Log.i(C.TAG, profileJSONfied);

    byte[] cleartext = profileJSONfied.getBytes(HTTP.UTF_8);
    Log.i(C.TAG, cleartext.toString());

    Cipher cipher = Cipher.getInstance(""DES"");
    cipher.init(Cipher.ENCRYPT_MODE, key);
    String encrypedProfile = Base64.encodeToString(cipher.doFinal(cleartext), Base64.DEFAULT);
    Log.i(C.TAG, encrypedProfile);

    editor.putString(PROFILE, encrypedProfile);
    editor.commit();
    profile = newProfile;
  } catch (Exception e) {
    Log.i(C.TAG, e.getMessage());
  }
}

public Profile loadProfile() {
  try {
    Cipher cipher = Cipher.getInstance(""DES"");
    cipher.init(Cipher.DECRYPT_MODE, key);

    Log.i(C.TAG, prefs.getString(PROFILE, null));

    // byte[] plainTextProfileBytes = Base64.decode(cipher.doFinal(prefs.getString(PROFILE, null).getBytes(HTTP.UTF_8)), Base64.DEFAULT);
    byte[] plainTextProfileBytes = Base64.decode(prefs.getString(PROFILE, null).getBytes(HTTP.UTF_8), Base64.DEFAULT);
    Log.i(C.TAG, new String(plainTextProfileBytes, HTTP.UTF_8));

    profile = new Gson().fromJson(new String(plainTextProfileBytes, HTTP.UTF_8), PROFILE_TYPE);
    Log.i(C.TAG, profile.toString());

  } catch (Exception e) {
    Log.i(C.TAG, e.getMessage());
  }
  return profile;
}
</code></pre>

<p>Here's an output example (ordered by Log's order):</p>

<p><strong>saveProfile:</strong><br>
Profile@4146a1d8<br><br>
{""email"":""aaa"",""firstName"":""aaa"",""lastName"":""aaa"",""postal"":""aaa"", etc etc...}<br><br>
[B@414819b0<br><br>
+nLS7XhRoIFPBeC11/h6mMz6hFfc8js03QJ8VwVZH+dPBeC11/h6mJ448CLGPNzz+bU669XpAI8VXchYQJr7mgDwHpeoSrP4BMACydjKpC8Q9atbk9xz6HNqDpNOiqaa75hFM+r9pzm55/E2E2tdjz4s5OzNNppAPzmtS69tZAZLPuYt1kvnJehHa6fDt2o5UCv6VukCwvVgt+UDcCqCKvF22Iv6vdMXWTcm
<br><br><br>
At this point I think everything went as expected. The problem lies below, decipher operation<br><br><br>
<strong>loadProfile:(backward process)</strong> <br>
+nLS7XhRoIFPBeC11/h6mMz6hFfc8js03QJ8VwVZH+dPBeC11/h6mJ448CLGPNzz+bU669XpAI8VXchYQJr7mgDwHpeoSrP4BMACydjKpC8Q9atbk9xz6HNqDpNOiqaa75hFM+r9pzm55/E2E2tdjz4s5OzNNppAPzmtS69tZAZLPuYt1kvnJehHa6fDt2o5UCv6VukCwvVgt+UDcCqCKvF22Iv6vdMXWTcm<br><br>
�r��xQ��O���z���W��;4�|WY�O���z��8�""�&lt;���:������]�X@�������J�����ʤ/�[��s�sj�N����E3��9���6k]�>,���6�@?9�K�mdK>�-�K�%�Gk�÷j9P+�V���`��p*�*�v؋��Y7&amp;���-A</p>

<p><code>java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 1 column 21</code></p>

<p>If I instead of:</p>

<pre><code>byte[] plainTextProfileBytes = Base64.decode(prefs.getString(PROFILE,null).getBytes(HTTP.UTF_8), Base64.DEFAULT);
</code></pre>

<p>I use:</p>

<pre><code>byte[] plainTextProfileBytes = Base64.decode(cipher.doFinal(prefs.getString(PROFILE, null).getBytes(HTTP.UTF_8)), Base64.DEFAULT);
</code></pre>

<p>The error will be:</p>

<pre><code>pad block corrupted
</code></pre>

<p>What am I missing here?<br>
Thanks for your time.</p>
","<p>So, I've found a solution!<br>
 For starters I've changed a bit of my code. I've created a myPBEkey class with two methods, encrypt and decrypt, both return a Cipher object with the respective ""opmode"":
<br><br>
Then I've changed my saveProfile and loadProfile methos code to:</p>

<pre><code>public void saveProfile(Profile newProfile) {
    try {
            SharedPreferences.Editor editor = prefs.edit();

            String profileJSONfied = new Gson().toJson(newProfile);             
            byte[] encryptedProfile = pbeKey.encrypt().doFinal(profileJSONfied.getBytes(HTTP.UTF_8));       
            byte[] encryptedProfileBase64 = Base64.encode(encryptedProfile, Base64.DEFAULT);            

            editor.putString(PROFILE, new String(encryptedProfileBase64, HTTP.UTF_8));
            editor.commit();
            profile = newProfile;
    } catch (Exception e) {
            Log.i(C.TAG, e.getMessage());
    }
}
</code></pre>

<p><br></p>

<pre><code>public Profile loadProfile() {
    if (profile == null) {
        try {                   
            byte[] decodedProfileBase64 = Base64.decode(prefs.getString(PROFILE, null), Base64.DEFAULT);
            byte[] plainTextProfileBytes = pbeKey.decrypt().doFinal(decodedProfileBase64);

            profile = new Gson().fromJson(new String(plainTextProfileBytes, HTTP.UTF_8), PROFILE_TYPE);

        } catch (Exception e) {
            Log.i(C.TAG, e.getMessage());
    }
return profile;
</code></pre>

<p>I think what solved the problem was separating the encrypt/decrypt from <code>Base64</code> encode/decode, so first we encrypt and then encode the encrypted <code>byte[]</code> and finally store it. The same goes when decrypting, first we decode the encrypted base64 profile and then decrypt the decoded  <code>byte[]</code>.   Voilà!<br><br>
Thanks for your time, hope it helps you.</p>
","376","<android><encryption><sharedpreferences><gson><des>","1","1","1","2015-05-22 22:59:00","16647474","0","3","1423773","","2015-05-22 22:59:00","2013-05-17 15:52:31",""
"5189006","DES Example invalid?","<p>The practical example provided on the following web page, does it contain mistakes or is their some unique step that needs to be followed?</p>

<p><a href=""http://www.eventid.net/docs/desexample.asp#Example"" rel=""nofollow"">http://www.eventid.net/docs/desexample.asp#Example</a></p>

<p>The results from the 56-bit key does not match values in the permuted 56-bit key.
Following positions: 51, 43, 35, 27 (do no match the same bits)</p>

<p>Could someone confirm this anomaly?</p>

<p>Please do not inform me that DES has been broken, cause I know.</p>
","<p>Don't have that problem in my code with my issued question. So I consider it resolved.
My Key Schedule works like a charm.</p>
","375","<c++><des>","0","0","1","2011-03-06 23:44:51","5214322","2","","","","","2011-03-04 02:26:56",""
"36358399","Error during encrypt a file using Mcrypt DES in php","<p>i want to encrypt a text file. below is my code.But i am getting function error during run.</p>

<pre><code>&lt;?php

 $key = '123456';
 $plain_text = pkcs5_pad(file_get_contents('yourFile.txt'));

 /* Open module, and create IV */
 $td = mcrypt_module_open(MCRYPT_DES, '', MCRYPT_MODE_CBC, '');
 $key = substr($key, 0, mcrypt_enc_get_key_size($td));
 $iv_size = mcrypt_enc_get_iv_size($td);
 $iv = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM);

 /* Initialize encryption handle */
 mcrypt_generic_init($td, $key, $iv);

/* Encrypt data */
$encrypted = mcrypt_generic($td, $plain_text);
mcrypt_generic_deinit($td);
file_put_contents('yourFile.txt.enc', $encrypted);
?&gt;
</code></pre>

<p>i am getting below error..please help me to solve this.</p>

<pre><code>Fatal error: Call to undefined function pkcs5_pad() in C:\xampp\htdocs\data\encrypt.php on line 4
</code></pre>
","<p>You need to make sure that you have the mcrypt module installed, configured, and enabled before you can use the <code>pkcs5_pad</code> function.  Installation and configuration will be different depending on your platform, so please see <a href=""http://php.net/manual/en/mcrypt.setup.php"" rel=""nofollow"">the documentation</a> for assistance.</p>
","367","<php><encryption><mcrypt><encryption-symmetric><des>","-1","0","1","2016-04-18 00:18:28","","5","","2224584","","2016-04-18 00:18:28","2016-04-01 14:04:53",""
"51511161","DES encryption and decryption using 2048 bit java","<p>Is there any way of encryption and decryption using DEC/ECB 2048 bit and can we generate 2048 bit key using DES.
I found that DES supports 64 bit, AES support 256 bits and If you want 2048 bit we can use RSA encryption and decryption. Also, I know that we use triple DES but it supports 168-bit encryption and decryption. </p>

<p>But I want to know that is it possible 2048 bit encryption and decryption Using DES.</p>

<p>Can anyone please suggest me on this or any different approach for this?</p>
","<p>No.
DES allows only 56-bit keys, but is insecure due to the short key.
Triple DES (3DES) is also judged insecure. (Source: <a href=""https://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow noreferrer"">Wikipedia</a>)
There is no provision in DES for other key lengths. </p>

<p>If you want a secure symmetric cipher scheme, I suggest you look into modern ciphers like <a href=""https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES-256</a> instead of pursuing old, insecure, ciphers.</p>

<p>Possibly, your demand for a bigger encryption key stems from a misunderstanding of how crypto works. SSL uses the RSA cipher because it is a good <a href=""https://en.wikipedia.org/wiki/RSA_(cryptosystem)"" rel=""nofollow noreferrer"">public-key cryptosystem</a>. This is useful in other situations than a symmetric cipher like DES. To quote Wikipedia:</p>

<blockquote>
  <p>RSA is a relatively slow algorithm, and because of this, it is less commonly used to directly encrypt user data. More often, RSA passes encrypted shared keys for symmetric key cryptography which in turn can perform bulk encryption-decryption operations at much higher speed. </p>
</blockquote>

<p>So, after the key exchange is done using RSA, both parties have a shared secret key which may be used for a block cipher like AES to transmit the bulk data rapidly .</p>
","364","<java><security><aes><rsa><des>","-1","1","1","2018-07-25 11:45:16","51517982","6","0","","","","2018-07-25 05:07:42",""
"24078346","Unclear pointer defect in program","<p>Im trying to build modified example of usage of DES CBC EDE on openssl. Im using gcc version 4.4.6 (Buildroot 2012.02) compiling for arm (not my choise of compiler) on ubuntu 10.04. Here is a problem: when pointer declaration is uncommented - everything is normal. Test message deciphers. But when pointer declaration gets commented - test message shows only 2 first letters after deciphering. I just can not understand what could do a declaration of an unused pointer. Here is code:</p>

<pre><code>#include &lt;openssl/des.h&gt;
#include &lt;cstring&gt;

#define BUFSIZE 512

using namespace std;

int main(int argc, char *argv[]) {


    unsigned char in[BUFSIZE] = {};
    unsigned char out[BUFSIZE] = {};
    unsigned char back[BUFSIZE] = {};
    unsigned char *strangePointer = &amp;out[0];  // what is wrong with it?
    int len;

    DES_cblock key1, key2, key3;
    DES_cblock ivsetup = {0xE1, 0xE2, 0xE3, 0xD4, 0xD5, 0xC6, 0xC7, 0xA8};
    DES_cblock ivecLocal;
    DES_key_schedule ks1, ks2, ks3;

    const char* key = ""0A0A0B0B0C0C0A0A0B0B0C0C"";

    memcpy(&amp;key1,key,8);
    memcpy(&amp;key2,key + 8,8);
    memcpy(&amp;key2,key + 16,8);

    DES_set_odd_parity(&amp;key1);
    DES_set_odd_parity(&amp;key2);
    DES_set_odd_parity(&amp;key3);

    DES_set_key((C_Block *)key1, &amp;ks1);
    DES_set_key((C_Block *)key2, &amp;ks2);
    DES_set_key((C_Block *)key3, &amp;ks3);

    const char* message = ""Now is the time for all men to stand up and be counted"";
    /* 64 bytes of plaintext */
    len = strlen(message);
    memcpy(in,message,len);

    printf(""Plaintext: [%s]\n"", in);

    memcpy(ivecLocal, ivsetup, sizeof(ivsetup));
    DES_ede3_cbc_encrypt(in, out, len, &amp;ks1, &amp;ks2, &amp;ks3, &amp;ivecLocal, DES_ENCRYPT);

    int lenout = 0;
    while(out[lenout] != '\0') ++lenout;

    memcpy(ivecLocal, ivsetup, sizeof(ivsetup));
    DES_ede3_cbc_encrypt(out, back, lenout, &amp;ks1, &amp;ks2, &amp;ks3, &amp;ivecLocal, DES_DECRYPT);

    printf(""Decrypted Text: [%s]\n"", back);

    return 0;
}
</code></pre>
","<p>You are most probably experiencing a buffer overflow. The declaration of <code>len</code> comes after <code>back</code> on the stack. If <code>back</code> overflows, then <code>len</code> will be overwritten. Adding another variable (<code>strangePointer</code>) in between adds a gap on the stack that stops len getting overwritten.</p>

<p>Probably increasing <code>BUFSIZE</code> should solve your issue.</p>
","361","<c++><gcc><openssl><des>","1","0","2","2014-06-10 11:43:04","24079470","4","","981959","","2014-06-06 10:54:54","2014-06-06 09:21:56",""
"24078346","Unclear pointer defect in program","<p>Im trying to build modified example of usage of DES CBC EDE on openssl. Im using gcc version 4.4.6 (Buildroot 2012.02) compiling for arm (not my choise of compiler) on ubuntu 10.04. Here is a problem: when pointer declaration is uncommented - everything is normal. Test message deciphers. But when pointer declaration gets commented - test message shows only 2 first letters after deciphering. I just can not understand what could do a declaration of an unused pointer. Here is code:</p>

<pre><code>#include &lt;openssl/des.h&gt;
#include &lt;cstring&gt;

#define BUFSIZE 512

using namespace std;

int main(int argc, char *argv[]) {


    unsigned char in[BUFSIZE] = {};
    unsigned char out[BUFSIZE] = {};
    unsigned char back[BUFSIZE] = {};
    unsigned char *strangePointer = &amp;out[0];  // what is wrong with it?
    int len;

    DES_cblock key1, key2, key3;
    DES_cblock ivsetup = {0xE1, 0xE2, 0xE3, 0xD4, 0xD5, 0xC6, 0xC7, 0xA8};
    DES_cblock ivecLocal;
    DES_key_schedule ks1, ks2, ks3;

    const char* key = ""0A0A0B0B0C0C0A0A0B0B0C0C"";

    memcpy(&amp;key1,key,8);
    memcpy(&amp;key2,key + 8,8);
    memcpy(&amp;key2,key + 16,8);

    DES_set_odd_parity(&amp;key1);
    DES_set_odd_parity(&amp;key2);
    DES_set_odd_parity(&amp;key3);

    DES_set_key((C_Block *)key1, &amp;ks1);
    DES_set_key((C_Block *)key2, &amp;ks2);
    DES_set_key((C_Block *)key3, &amp;ks3);

    const char* message = ""Now is the time for all men to stand up and be counted"";
    /* 64 bytes of plaintext */
    len = strlen(message);
    memcpy(in,message,len);

    printf(""Plaintext: [%s]\n"", in);

    memcpy(ivecLocal, ivsetup, sizeof(ivsetup));
    DES_ede3_cbc_encrypt(in, out, len, &amp;ks1, &amp;ks2, &amp;ks3, &amp;ivecLocal, DES_ENCRYPT);

    int lenout = 0;
    while(out[lenout] != '\0') ++lenout;

    memcpy(ivecLocal, ivsetup, sizeof(ivsetup));
    DES_ede3_cbc_encrypt(out, back, lenout, &amp;ks1, &amp;ks2, &amp;ks3, &amp;ivecLocal, DES_DECRYPT);

    printf(""Decrypted Text: [%s]\n"", back);

    return 0;
}
</code></pre>
","<p>You have several things incorrect in your code. I'll start with the simple answer first:</p>

<p>Your third key isn't even populated with key data. It is random data on the local activation stack. </p>

<pre><code>memcpy(&amp;key1,key,8);
memcpy(&amp;key2,key + 8,8);
memcpy(&amp;key2,key + 16,8); // &lt;&lt;=== NOTE still key2
</code></pre>

<p>Oh, copy-paste, ye are a cruel and heartless wench. Anyway, by <em>removing</em> the variable you're commenting out, this key is moving further up (or down, depending on your implementation) the stack in memory, and the result is a different value . But the bottom line, you're using indeterminate data for your third key.</p>

<p>But that isn't the entire problem. That change in key exposes <em>another</em> issue, you're output length calculation, which is also flat-wrong. This:</p>

<pre><code>int lenout = 0;
while(out[lenout] != '\0') ++lenout;
</code></pre>

<p>assumes the length of the output cipher can be found by searching for a <code>0</code>-byte. The DES algorithm can easily emit such a byte <em>anywhere</em> in an encryption block.  This is plain wrong. The size of the output of a <code>DES_ede3_cbc_encrypt</code> encryption operation is always a multiple of the block size, which for DES is 8 bytes (not coincidentally the size of a <code>DES_cblock</code>), The correct calculation of your output buffer size is:</p>

<pre><code>int lenout = ((len + sizeof(DES_cblock) - 1)/sizeof(DES_cblock))*sizeof(DES_cblock);
</code></pre>

<p>which may seem like a helluva lot, but in the end all this does is round up to the nearest multiple of the block length. Further, you don't even <em>need</em> the <code>input</code> buffer. The API will do the calculation for you if you simply pass your input data message and its true length. But I leave that for you to finish (hint: just remove <code>input</code> and pass <code>message</code>).</p>

<p>the result is:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;openssl/des.h&gt;

#define BUFSIZE 512

int main(int argc, char *argv[])
{
    unsigned char in[BUFSIZE] = {};
    unsigned char out[BUFSIZE] = {};
    unsigned char back[BUFSIZE] = {};
    int len;

    DES_cblock key1, key2, key3;
    DES_cblock ivsetup = {0xE1, 0xE2, 0xE3, 0xD4, 0xD5, 0xC6, 0xC7, 0xA8};
    DES_cblock ivecLocal;
    DES_key_schedule ks1, ks2, ks3;

    const char* key = ""0A0A0B0B0C0C0A0A0B0B0C0C"";

    memcpy(&amp;key1,key,8);
    memcpy(&amp;key2,key + 8,8);
    memcpy(&amp;key3,key + 16,8);

    DES_set_odd_parity(&amp;key1);
    DES_set_odd_parity(&amp;key2);
    DES_set_odd_parity(&amp;key3);

    DES_set_key(&amp;key1, &amp;ks1);
    DES_set_key(&amp;key2, &amp;ks2);
    DES_set_key(&amp;key3, &amp;ks3);

    const char* message = ""Now is the time for all men to stand up and be counted"";
    len = strlen(message);
    memcpy(in,message,len);

    printf(""Plaintext: [%s]\n"", in);

    memcpy(ivecLocal, ivsetup, sizeof(ivsetup));
    DES_ede3_cbc_encrypt(in, out, len, &amp;ks1, &amp;ks2, &amp;ks3, &amp;ivecLocal, DES_ENCRYPT);

    int lenout = ((len + sizeof(DES_cblock) - 1)/sizeof(DES_cblock))*sizeof(DES_cblock);

    memcpy(ivecLocal, ivsetup, sizeof(ivsetup));
    DES_ede3_cbc_encrypt(out, back, lenout, &amp;ks1, &amp;ks2, &amp;ks3, &amp;ivecLocal, DES_DECRYPT);

    printf(""Decrypted Text: [%s]\n"", back);

    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>Plaintext: [Now is the time for all men to stand up and be counted]
Decrypted Text: [Now is the time for all men to stand up and be counted]
</code></pre>
","361","<c++><gcc><openssl><des>","1","3","2","2014-06-10 11:43:04","24079470","4","","981959","","2014-06-06 10:54:54","2014-06-06 09:21:56",""
"13430722","Key Permutation in DES System using Java","<p>Assume I have a (8*8) bit block (64-bit block).. and I need to permute it according to a given Permutation table . The Permutation table (8*7) the location of each bit in the 64 bit block to be permuted.</p>

<pre><code> Example:
(64=bits)        Permutation Tbale (8*7)
0 0 1 0 ..       57 49 41 ...
0 1 1 0 ..  AND  1  58 50 ..
1 0 0 1 ..       10 2 59 ...
. .  
</code></pre>

<p>So from the Permutation Table.. the number 57 identifies that the bit 57 from the 64-bit block is be placed as the first bit (Place of 57 in permutation Table) of the new (8*7) Array. Is there some way using the number 57 to identify the exact row and coloumn of the 57th bit ? Thanks</p>
","<p>Assuming the indices all start at 0, <code>57 / 8 = 7</code>, so row with index 7 (8th row). <code>57 % 8 = 1</code>, so column with index 1 (2nd column).</p>
","361","<java><permutation><des>","0","0","1","2012-11-17 12:56:08","","0","","","","","2012-11-17 12:48:15",""
"22213483","Java CipherOutputStream not returning all bytes","<p>I'm new to cryptography but I'm planning on using it in some later applications.  </p>

<p>I would like to know if there is some component I am missing in this short demo program I've made.  </p>

<p>I know I'm making an assumption with the 300 bytes, if there is a way to get around guessing array size I would like to know,</p>

<pre><code>import java.io.*;
import java.security.GeneralSecurityException;
import java.security.spec.KeySpec;
import java.util.Arrays;


import javax.crypto.*;
import javax.crypto.spec.DESKeySpec;

public class CipherStreamDemo {
private static final byte[] salt={
    (byte)0xC9, (byte)0xEF, (byte)0x7D, (byte)0xFA,
    (byte)0xBA, (byte)0xDD, (byte)0x24, (byte)0xA9
};
private Cipher cipher;
private final SecretKey key;
public CipherStreamDemo() throws GeneralSecurityException, IOException{
    SecretKeyFactory kf=SecretKeyFactory.getInstance(""DES"");
    KeySpec spec=new DESKeySpec(salt);
    key=kf.generateSecret(spec);
    cipher=Cipher.getInstance(""DES"");
}
public void encrypt(byte[] buf) throws IOException, GeneralSecurityException{
    cipher.init(Cipher.ENCRYPT_MODE,key);
    OutputStream out=new CipherOutputStream(new FileOutputStream(""crypt.dat""), cipher);
    out.write(buf);
    out.close();
}
public byte[] decrypt() throws IOException, GeneralSecurityException{
    cipher.init(Cipher.DECRYPT_MODE, key);
    InputStream in=new CipherInputStream(new FileInputStream(""crypt.dat""), cipher);
    byte[] buf=new byte[300];
    int bytes=in.read(buf);
    buf=Arrays.copyOf(buf, bytes);
    in.close();
    return buf;
}
public static void main(String[] args) {
    try{
        CipherStreamDemo csd=new CipherStreamDemo();
        String pass=""thisisasecretpassword"";
        csd.encrypt(pass.getBytes());
        System.out.println(new String(csd.decrypt()));
        }catch(Exception e){
            e.printStackTrace();
        }
}
}
//Output: thisisasecretpass
</code></pre>
","<p>You're assuming that the input is going to be exactly 300 bytes, and you're also assuming you've read it all, in a single read. You need to keep reading until read() returns -1.</p>

<p>I don't see any point in the object streams. They're only adding overhead. Remove them.</p>
","360","<java><encryption><des>","0","2","2","2014-10-20 05:31:36","22213533","0","2","3187949","","2014-03-06 02:21:03","2014-03-06 02:11:48",""
"22213483","Java CipherOutputStream not returning all bytes","<p>I'm new to cryptography but I'm planning on using it in some later applications.  </p>

<p>I would like to know if there is some component I am missing in this short demo program I've made.  </p>

<p>I know I'm making an assumption with the 300 bytes, if there is a way to get around guessing array size I would like to know,</p>

<pre><code>import java.io.*;
import java.security.GeneralSecurityException;
import java.security.spec.KeySpec;
import java.util.Arrays;


import javax.crypto.*;
import javax.crypto.spec.DESKeySpec;

public class CipherStreamDemo {
private static final byte[] salt={
    (byte)0xC9, (byte)0xEF, (byte)0x7D, (byte)0xFA,
    (byte)0xBA, (byte)0xDD, (byte)0x24, (byte)0xA9
};
private Cipher cipher;
private final SecretKey key;
public CipherStreamDemo() throws GeneralSecurityException, IOException{
    SecretKeyFactory kf=SecretKeyFactory.getInstance(""DES"");
    KeySpec spec=new DESKeySpec(salt);
    key=kf.generateSecret(spec);
    cipher=Cipher.getInstance(""DES"");
}
public void encrypt(byte[] buf) throws IOException, GeneralSecurityException{
    cipher.init(Cipher.ENCRYPT_MODE,key);
    OutputStream out=new CipherOutputStream(new FileOutputStream(""crypt.dat""), cipher);
    out.write(buf);
    out.close();
}
public byte[] decrypt() throws IOException, GeneralSecurityException{
    cipher.init(Cipher.DECRYPT_MODE, key);
    InputStream in=new CipherInputStream(new FileInputStream(""crypt.dat""), cipher);
    byte[] buf=new byte[300];
    int bytes=in.read(buf);
    buf=Arrays.copyOf(buf, bytes);
    in.close();
    return buf;
}
public static void main(String[] args) {
    try{
        CipherStreamDemo csd=new CipherStreamDemo();
        String pass=""thisisasecretpassword"";
        csd.encrypt(pass.getBytes());
        System.out.println(new String(csd.decrypt()));
        }catch(Exception e){
            e.printStackTrace();
        }
}
}
//Output: thisisasecretpass
</code></pre>
","<p>This</p>

<pre><code>int bytes=in.read(buf);
</code></pre>

<p>is almost always wrong and should be done like</p>

<pre><code>for(int total = bytes.length; total &gt; 0;)
{
    final int read = in.read(buf, buf.length - total, total);

    if (read &lt; 0)
    {
        throw new EOFException(""Unexpected end of input."");
    }

    total -= read;
}
</code></pre>
","360","<java><encryption><des>","0","0","2","2014-10-20 05:31:36","22213533","0","2","3187949","","2014-03-06 02:21:03","2014-03-06 02:11:48",""
"19113095","c# des decrypt using Rfc2898DeriveBytes?","<p>I attempts to decrypt des in c #. Have a question. Need help.</p>

<ol>
<li>The key should be 8 digits in length?
<ul>
- 
</ul></li>
<li>Use the key to create Rfc2898DeriveBytes?
<ul>
<li>In Java KeySpec keySpec, SecretKey key is used. in c#?</li>
</ul></li>
</ol>
","","359","<c#><des>","0","","0","2013-10-01 09:51:02","","3","","","","","2013-10-01 09:51:02",""
"38915753","C# Triple DES in ECB Decrypt Issues","<p>I have this PHP script which we need to convert to C# to decode a result from an API post request, but I am experiencing issues with my C# implementation.</p>

<p>We get the result fine while running the PHP script which is <code>XXXX-XXXX-XXXX</code> but get different errors.</p>

<p>Values are:</p>

<pre><code>encodedText = ""U8Q+m2zpFMLa/3gYILHx5w==""
key = ""examplesecret""
keyHash = ""6315046b2c085bbeeab87c65""
</code></pre>

<p>Php Script:</p>

<pre><code>&lt;?php
$secret = 'examplesecret';
$encrypted_code = 'U8Q+m2zpFMLa/3gYILHx5w==';
// Base64
// Decode
$encrypted_code = base64_decode( $encrypted_code );
// Create decryption module
$cipher = mcrypt_module_open( 'tripledes', '', 'ecb', '' );
$keysize = mcrypt_enc_get_key_size( $cipher ); // = 24
// Generate key
$hash = md5( $secret );
$key = substr( $hash, 0, $keysize );
// Initialise decrypter
$iv = mcrypt_create_iv( mcrypt_enc_get_iv_size( $cipher ),
MCRYPT_DEV_RANDOM );
mcrypt_generic_init( $cipher, $key, $iv );
// Decrypt code
$decrypted = mdecrypt_generic( $cipher, $encrypted_code );
// Output decrypted code
echo $decrypted;
?&gt;
</code></pre>

<p>C# Script</p>

<pre><code>public static string Decrypt(string encodedText, string key)
{
    TripleDESCryptoServiceProvider desCryptoProvider = new TripleDESCryptoServiceProvider();
    MD5CryptoServiceProvider hashMD5Provider = new MD5CryptoServiceProvider();

    byte[] byteHash;
    byte[] byteBuff;

    byteHash = hashMD5Provider.ComputeHash(Encoding.UTF8.GetBytes(key));
    desCryptoProvider.Key = byteHash;
    desCryptoProvider.Padding = PaddingMode.None;
    desCryptoProvider.Mode = CipherMode.ECB; //CBC, CFB
    byteBuff = Convert.FromBase64String(encodedText);

    var byteHex = BitConverter.ToString(byteBuff).Replace(""-"", "" "");

    string plaintext = Encoding.UTF8.GetString(desCryptoProvider.CreateDecryptor().TransformFinalBlock(byteHex, 0, byteHex.Length));
    return plaintext;
}
</code></pre>
","<p>A couple of things I see:</p>

<ol>
<li>You derive <code>$key</code> via a substr in PHP; but just take the output of MD5 in C#, are they the same? (e.g. if PHP's value was a hex string, then the 16 bytes of MD5 are 32 characters, which gets trunctated to 24 characters, being a 12-byte (96-bit) value; in C# it's 16 bytes)</li>
<li>Speaking of the keys, if you're using PHP before 5.6, a deficient key was 0-padded (per the documentation of <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">mcrypt_encrypt</a>; C# won't do that for you.  So that's another thing to check.</li>
<li>You have an IV in the PHP code, but ECB doesn't use an IV. That won't be causing your problem here, but it's less than ideal.</li>
<li>Of course, I should at this point warn that ECB is ""too stable"" and doesn't hide patterns in encrypted data, and doesn't hide that you're sending the same message again.</li>
<li>TransformFinalBlock takes bytes, but you seem to be giving it a string here.  Since C# is a strongly typed language, this can't really be the code you're running.</li>
<li>You should avoid talking about the specific implementations of algorithms.  <code>TripleDES.Create()</code> is preferred to <code>new TripleDESCryptoServiceProvider()</code>, <code>MD5.Create()</code> over <code>new MD5CryptoServiceProvider()</code>; and type the variables as just TripleDES and MD5.</li>
<li>The TripleDES object, the MD5 object, and the output of CreateDecryptor() are all IDisposable, so you should really wrap them in a using statement to be more efficient with your native resources.</li>
</ol>

<p>The most likely culprit for your problem, though, is that you're not generating the same key in both languages.</p>
","358","<c#><php><encryption><des><ecb>","0","2","1","2016-08-12 16:19:24","","10","1","1663001","","2016-08-12 10:49:19","2016-08-12 10:29:03",""
"14854133","Encrypting on PHP but can't decrypt on C#","<p>I have a test.php with the following:
    

<pre><code>echo encrypt(""something"");

function encrypt($str)
{
        $enc_key = ""my key is 8 char long"";
        $ivArray=array( 0x10, 0x12, 5, 0x11, 0x23, 1, 0x55, 0x43 );
        $iv=null;
        foreach ($ivArray as $element)
                $iv.=CHR($element);

        return strtoupper(bin2hex(base64_encode(mcrypt_encrypt(MCRYPT_DES, $enc_key, $str, MCRYPT_MODE_CBC, $iv))));
}
</code></pre>

<hr>

<p>Then on my C# code I have:</p>

<pre><code>private static byte[] iv = new byte[] { 0x10, 0x12, 5, 0x11, 0x23, 1, 0x55, 0x43 };

public string ConvertString(string input, string myKey)
{
    try
    {
        input = byteArrayString(input);
        byte[] bytes = Encoding.UTF8.GetBytes(myKey);
        byte[] buffer = Convert.FromBase64String(input);
        DESCryptoServiceProvider provider = new DESCryptoServiceProvider();
        MemoryStream stream = new MemoryStream();
        CryptoStream stream2 = new CryptoStream(stream, provider.CreateDecryptor(bytes, iv), CryptoStreamMode.Write);
        stream2.Write(buffer, 0, buffer.Length);
        stream2.FlushFinalBlock();
        return Encoding.UTF8.GetString(stream.ToArray());
    }
    catch
    {
        return string.Empty;
    }
}

private string byteArrayString(string input)
{
    byte[] buffer = new byte[input.Length / 2];
    for (int i = 0; i &lt; input.Length; i += 2)
    {
        if (i &lt; input.Length)
        {
            buffer[i / 2] = (byte)((Uri.FromHex(input[i]) * 0x10) + Uri.FromHex(input[i + 1]));
        }
    }

    return Encoding.UTF8.GetString(buffer);
}
</code></pre>

<hr>

<p>If I do it all on C# it works the difference from the PHP to the C# is 12 bytes on the resulting encryption from the PHP.</p>

<p><strong>What am I doing wrong at the PHP side to match the encryption ?</strong></p>

<hr>

<p>Update (PKCS7):</p>

<pre><code>$block = mcrypt_get_block_size('des', 'cbc');
$len = strlen($str);
$padding = $block - ($len % $block);
$str .= str_repeat(chr($padding),$padding);
</code></pre>
","<p>With CodesInChaos help I've solved it with the below code on the php side to correctly pad it.</p>

<p>CodesInChaos if u feel like posting a reply I will mark it as the right answer otherwise I will mark this one instead.</p>

<pre><code>$block = mcrypt_get_block_size('des', 'cbc');
$len = strlen($str);
$padding = $block - ($len % $block);
$str .= str_repeat(chr($padding),$padding);
</code></pre>
","352","<c#><php><encryption><des>","4","1","1","2013-02-14 14:10:56","14876712","7","1","450121","","2013-02-13 13:21:30","2013-02-13 12:57:31",""
"44040903","How to generate DES key in Swift 3","<p>I want to decrypt a DES encrypted String with CommonCrypto and therefore i have to generate a key from a given passphrase.</p>

<p>I found the following function in Apple's API reference: <a href=""https://developer.apple.com/reference/security/1401861-seckeygeneratesymmetric/"" rel=""nofollow noreferrer"">SecKeyGenerateSymmetric</a></p>

<p>But when I import Security in my swift file this function is not available while other functions of the framework are available (eg. SecKeyGeneratePair).</p>

<p>Has this function been replaced by some other?</p>

<p>Or is there any other way to generate a DES key in Swift 3?</p>
","<p>In order to use Common Crypto with Swift it is necessary to add a bridging header:</p>

<pre><code>#import &lt;CommonCrypto/CommonCrypto.h&gt;
</code></pre>

<p>Add the <code>Security.framework</code> to the project.</p>

<blockquote>
  <p>Note:</p>
</blockquote>

<p>When generating a key from a password (key derivation) the same method and parameters ned to be used. There are several such methods commonly used, PBKDF2 is one often used and suggested by NIST. Do you know the method and parameters used for the key derivation?</p>
","339","<swift><xcode><swift3><des>","0","1","1","2017-05-18 08:40:35","","1","","7990095","","2017-05-18 07:55:40","2017-05-18 07:08:09",""
"30820686","Java/Clojure BouncyCastle reports wrong key size, but key size is right","<p>i'm trying to generate a MAC using the ISO9797 Alghrythm 3.
I do this in Clojure, but I guess I'm having more of a Java Problem here. I run this code:</p>

<pre><code>(defn mac2 [key message]
  (let [engine (org.bouncycastle.crypto.engines.DESedeEngine.)
        mac (org.bouncycastle.crypto.macs.ISO9797Alg3Mac. engine)
        bytes (byte-array (.getMacSize mac))
        key (-&gt;bytes key)
        msg (-&gt;bytes E-IFD)]
    (prn key (count key))
    (.init mac (org.bouncycastle.crypto.params.DESedeParameters. key))
    (.update mac msg 0 (count msg))
    (.doFinal mac bytes 0)
    (-&gt;hex-string bytes)))
</code></pre>

<p>And get this output (the exception is thrown at (.init mac ...):</p>

<pre><code>#&lt;byte[] [B@65e47e28&gt; 16
IllegalArgumentException key size must be 16 or 24 bytes.  org.bouncycastle.crypto.engines.DESedeEngine.init (:-1)
</code></pre>

<p>Now you see, the prn ist printing put the key-length, which is 16. 
But BouncyCastle complains, that it is not 16 or 24 (changing the key to a key with the length of 24 does not help either)</p>

<p>Also when i run this code, there is no Problem:</p>

<pre><code>(defn mac1 [key message]
  (let [engine (org.bouncycastle.crypto.engines.DESedeEngine.)
        mac (org.bouncycastle.crypto.macs.CMac. engine)
        bytes (byte-array (.getMacSize mac))
        msg (-&gt;bytes E-IFD)]
    (.init mac (org.bouncycastle.crypto.params.DESedeParameters. (-&gt;bytes key)))
    (.update mac msg 0 (count msg))
    (.doFinal mac bytes 0)
    (-&gt;hex-string bytes)))
</code></pre>
","<p>Alright, I post the working code here. The problem was that I was passing <code>org.bouncycastle.crypto.engines.DESedeEngine</code> instead of <code>org.bouncycastle.crypto.engines.DESEngine</code>.</p>

<p><code>org.bouncycastle.crypto.macs.ISO9797Alg3Mac</code> splits the key into 3 pieces and passes then the first one to its Engine. Hence <code>DESedeEngine</code> reports a wrong key size, although the original key had the right size.</p>

<pre><code>(defn mac2 [key message]
  (let [engine (org.bouncycastle.crypto.engines.DESEngine.)
        mac (org.bouncycastle.crypto.macs.ISO9797Alg3Mac. engine)
        bytes (byte-array (.getMacSize mac))
        key (-&gt;bytes key)
        msg (-&gt;bytes E-IFD)]
    (prn key (count key))
    (.init mac (org.bouncycastle.crypto.params.DESedeParameters. key))
    (.update mac msg 0 (count msg))
    (.doFinal mac bytes 0)
    (-&gt;hex-string bytes)))
</code></pre>
","339","<java><clojure><bouncycastle><des>","1","2","1","2015-06-13 18:36:56","30821288","0","","","","","2015-06-13 16:00:53",""
"23038151","Implement initial vector (IV) in CBC mode by DES","<p>I don't understand how to use the Initial Vector into the DES. I have read how the formula of the Initial Vector with CBC mode <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Initialization_vector_.28IV.29"" rel=""nofollow"">Block cipher mode of operation</a>. How to implement my plaintext into the formula.
Can i have exemplified</p>

<blockquote>
  <p>plaintext = COMPUTER, Binary = 01000011 01001111 01001101 01010000
  01010101 01010100 01000101 01010010, hex = 43 4F 4D 50 55 54 45 52|
  Key = ENCRYPTT, Binary = 01000101 01001110 01000011 01010010 01011001
  01010000 01010100 01010100, hex = 45 4E 43 52 59 50 54 54</p>
</blockquote>

<p>Thanks</p>

<p><strong>UPDATE :</strong></p>

<p>I have two DES Encrypt project. The first project uses a library and the second project  without a library. The first project using the library, using the CBC encryption mode and the second project without library and no encryption mode. Cipertext of encryption results in the first and second different program. the problem is what should I add to the second program that cipertext same result. How the addition of CBC mode on my second program without a library. </p>

<p>First Project Code with library :</p>

<pre><code>DES.Key = ASCIIEncoding.ASCII.GetBytes(sKey);
DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey);
DES.Mode = CipherMode.CBC;
</code></pre>

<p>Second Project Code without library :</p>

<pre><code>public void getAll_RL() 
{
            string proses = """";
            List&lt;string&gt; R = new List&lt;string&gt;();
            List&lt;string&gt; L = new List&lt;string&gt;();
            R.Add(txtR0.Text);
            R.Add(txtR1.Text);
            L.Add(txtL0.Text);
            L.Add(txtL1.Text);
            L.Add(txtR1.Text);
            for (int x = 2; x &lt;= 16; x++)
            {
                txtProses.Text = string.Empty;
                string resultEks = string.Empty;
                cp.Table(R[x - 1], ""E"", ref resultEks); //Tabel Ekspansi
                string resultXOR = string.Empty;
                string subKey = (string)DGVSubKey.Rows[x - 1].Cells[1].Value;
                cp.XOR(resultEks, subKey, ref resultXOR);
                string resultSBOX = string.Empty;
                cp.SBOX(resultXOR, ref resultSBOX);
                string resultPBOX = string.Empty;
                cp.Table(resultSBOX, ""PBOX"", ref resultPBOX);
                string resultXOR2 = string.Empty;
                cp.XOR(resultPBOX, L[x - 1], ref resultXOR2);
                R.Add(resultXOR2);
                L.Add(resultXOR2);
            }
            txtL16.Text = L[16];
            txtR16.Text = R[16];
            txtRL16.Text = R[16] + L[16] ;
 }

public void getIP1() 
        {
            string RL16 = txtRL16.Text;
            if (RL16.Length == 64)
            {
                string result = string.Empty;
                cp.Table(RL16, ""IP1"", ref result);
                txtIP1.Text = result;
            }
        }

public void getHexResult() 
        {
            string IP1 = txtIP1.Text;
            if (IP1.Length == 64)
            {
                List&lt;string&gt; AllBinary = new List&lt;string&gt;();
                string Hex = string.Empty;
                string ResultHex = string.Empty;
                for (int x = 0; x &lt; 8; x++)
                {
                    string string8 = IP1.Substring(8 * x, 8);
                   AllBinary.Add(string8);
                    string hex = Convert.ToInt64(AllBinary[x], 2).ToString(""X"");
                    Hex += hex + "" "";
                }
                string[] hexSplit = Hex.TrimEnd().Split(' ');
                for (int x = 0; x &lt; 8; x++) 
                {
                    if (hexSplit[x].Length == 1)
                    {
                        ResultHex += ""0"" + hexSplit[x] +"" "";
                    }
                    else 
                    { 
                        ResultHex += hexSplit[x] + "" ""; 
                    }
                }
                txtHexResult.Text = ResultHex.TrimEnd();
            } 
        }
</code></pre>

<p>Result Cipertext in hex :</p>

<blockquote>
  <p>First Project : 2B B7 4F 52 A8 0E 9F 0F,
  Second Project : A6 53 62 DD FD 25 A0 C5</p>
</blockquote>
","","336","<c#><des><cbc-mode>","0","","0","2014-04-13 12:33:05","","7","","3425817","","2014-04-13 12:33:05","2014-04-13 01:37:59",""
"22185728","Encrypted Data with DES - JAVA","<p>Given the following example:</p>

<pre><code>String f=""A000000000000000"";
FileInputStream fis = new FileInputStream(""C:\\Users\\original.txt"");
byte[] bytes = DatatypeConverter.parseHexBinary(f);
SecretKey key = new SecretKeySpec(bytes, 0, bytes.length, ""DES"");

String strDataToEncrypt = new String();
String strCipherText = new String();
String strDecryptedText = new String();

    try{

    Cipher desCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    desCipher.init(Cipher.ENCRYPT_MODE,key);

            //read from file and transform to String
            try{
            builder = new StringBuilder();
            int ch;
            while((ch = fis.read()) != -1){
            builder.append((char)ch);
            }
            }catch (IOException e){

            }

    byte[] byteDataToEncrypt = builder.toString().getBytes();
    byte[] byteCipherText = desCipher.doFinal(byteDataToEncrypt); 
    strCipherText = new BASE64Encoder().encode(byteCipherText);

    System.out.println(strCipherText);
</code></pre>

<p>the encrypted  data is different everytime I compile with the same key value i , i tried different codes and the encrypted data was always the same , what's wrong here ?</p>
","<p>The <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#init%28int,%20java.security.Key%29"" rel=""nofollow"">documentation for javax.crypto.Cipher.init</a> says, in part:</p>

<blockquote>
  <p>If this cipher requires any algorithm parameters that cannot be
  derived from the given key, the underlying cipher implementation is
  supposed to generate the required parameters itself (using
  provider-specific default or random values)</p>
</blockquote>

<p>DES CBC (Cipher Block Chaining) mode requires an Initialization Vector (IV). If you do not provide one (and you should not, because it opens you up to <a href=""https://www.owasp.org/index.php/Not_using_a_random_initialization_vector_with_cipher_block_chaining_mode"" rel=""nofollow"">dictionary attacks</a>), a random one will be generated.</p>

<p>But if you want the encrypted data to be the same every time, you need to specify the IV using an <code>IvParameterSpec</code>:</p>

<pre><code>byte[] iv = DatatypeConverter.parseHexBinary(""0000000000000000"");
IvParameterSpec ips = new IvParameterSpec(iv);
desCipher.init(Cipher.ENCRYPT_MODE, key, iv);
</code></pre>

<p>If you do let it generate a random IV, you can retrieve the generated IV with <code>desCipher.getIV()</code>.</p>
","334","<java><encryption><des>","0","2","1","2014-03-05 17:18:50","22186221","2","2","1860545","","2014-03-05 00:04:48","2014-03-04 23:54:13",""
"32882406","Des and 3Des with ecb in C# (from C)","<p>I've this C code and I have to write it in C#.</p>

<p>How can I write these ecb des and 3des functions in C#?</p>

<pre><code>/**
* Simple Single-Des Encryption procedure.
* Does not modify the input data.
* Encrypted result is returned in a separate buffer.
*
* @param pResult    (out) Result of the encrypted byte
* @param pData      (in)  One byte of input data
* @param pKey       (in)  The DES-key
*/

void DesEncrypt(void *pResult, const void *pData, KEY_1DES *pKey)
{
    memcpy(pResult, pData, 8);
    DES_key_schedule k;
    DES_set_key_unchecked((const_DES_cblock *)&amp;pKey, &amp;k);
    DES_ecb_encrypt((const_DES_cblock *)pData, (const_DES_cblock *)pResult, &amp;k, DES_ENCRYPT);
}


/**
* Encrypts a byte using double length 3DES
*
* @param pResult    (out) Result of the decryption
* @param pData      (in)  One byte of input data
* @param pKey       (in)  The 3DES-key
*/

void DesEncrypt3Des(void *pResult, const void *pData, KEY_3DES *pKey)
{
    memcpy(pResult, pData, 8);
    //DES_set_key_checked()
    DES_key_schedule left;
    DES_set_key_unchecked((const_DES_cblock *)&amp;pKey-&gt;left, &amp;left);
    DES_key_schedule right;
    DES_set_key_unchecked((const_DES_cblock *)&amp;pKey-&gt;right, &amp;right);
    DES_ecb3_encrypt((const_DES_cblock *)pData, (const_DES_cblock *)pResult, &amp;left, &amp;right, &amp;left, DES_ENCRYPT);
}
</code></pre>

<p>I'm asking this because there are a lot of way to do this and I have to be sure to use the same encrypt parameters.</p>
","<p>Why don't you just use <code>TripleDESCryptoServiceProvider</code> from <code>System.Security.Cryptography</code>?</p>

<pre><code>public static string Encrypt(string data, string pKey)
{
    TripleDESCryptoServiceProvider cryptor = new TripleDESCryptoServiceProvider();
    byte[] array = null;
    cryptor.Key = pKey;
    cryptor.Mode = CipherMode.ECB;
    ICryptoTransform encrypt = cryptor.CreateEncryptor();
    array = ASCIIEncoding.ASCII.GetBytes(data);
    string retVal = """";
    retVal = Convert.ToBase64String(encrypt.TransformFinalBlock(array, 0, array.Length));
    return retVal;
}
</code></pre>

<p>And for decryption use the same logic but instead call <code>CreateDecryptor()</code></p>
","328","<c#><c><converter><des><3des>","-1","0","1","2015-10-07 14:41:25","32995260","0","","","","","2015-10-01 08:02:49",""
"10097757","Pseudo random number generator using TEA","<p>Hi im trying to get a uniform random number generator using a crypto algorithm as the engine . DES is possible to be used but in this case i have used TEA according to this <a href=""http://myweb.tiscali.co.uk/jgrimbleby/random.htm"" rel=""nofollow"">http://myweb.tiscali.co.uk/jgrimbleby/random.htm</a> porting the code from c++ to python.The problem im having is i need the range to be between 0 and 1 .currently the values im getting are very large 10^76 range.Any idea if its a transcription error on my part or if theres any addition i can put in to get the desired range.</p>

<pre><code>class psrTEA:

def __init__(self):

    self.m = 4294967296.0
    self.d = 0X09E3779B9L
    self.k0 = 0X0C7D7A8B4L
    self.k1 = 0X09ABFB3B6L
    self.k2 = 0X073DC1683L
    self.k3 = 0X017B7BE73L

    self.y = 123456789L
    self.z = 987654321L

def rnd(self):
    s = 0
    self.y = long(time.time())
    self.z = long(time.clock())

    for n in range(31):
        s += self.d
        self.y += (self.z &lt;&lt; 4) + self.k0 ^ self.z + s ^ (self.z &gt;&gt; 5) + self.k1
        self.z += (self.y &lt;&lt; 4) + self.k2 ^ self.y + s ^ (self.y &gt;&gt; 5) + self.k3

    return ((self.z + self.y / self.m)/ self.m)
</code></pre>
","<p>Compute your highest value (or compute lots of values, take the max, maybe guess a little bit based on a power of 2 or something).</p>

<p>Then divide each of your large results by a float version of the highest value.  That should scale things to 0..1.</p>
","322","<python><random><des>","0","1","1","2012-04-11 00:32:00","10098353","0","0","1112118","","2012-04-10 23:20:56","2012-04-10 23:12:50",""
"16262219","Most efficient way of using Java's DES implementation to encrypt a single (64 bit) block?","<p>I have a method that encrypts a single (64 bit) block using Java's DES implementation.</p>

<pre><code>public BitSet encrypt(BitSet plaintextBlock, BitSet key)
{
    try {
        Cipher c = Cipher.getInstance(""DES/ECB/NoPadding"");
        SecretKeyFactory sf = SecretKeyFactory.getInstance(""DES"");
        Key desKey = sf.generateSecret(new DESKeySpec(key.toByteArray()));
        c.init(Cipher.ENCRYPT_MODE, desKey);
        byte[] input = plaintextBlock.toByteArray();
        byte[] encrypted = c.doFinal(input);

        return BitSet.valueOf(encrypted);
    } catch (Exception e) { /* Exception handling omitted */ }
}
</code></pre>

<p>The <code>plainTextBlock</code> will always be less than or equal to 64 bits. Padding and Chaining are implemented separately. This works fine, but turns out to run very slowly.</p>

<p>So my question is: <strong>Is there a more efficient way of encrypting a single block with Java's DES?</strong></p>
","","318","<java><performance><des>","0","","0","2013-04-28 11:58:37","","2","2","1280997","","2013-04-28 11:58:37","2013-04-28 11:08:57",""
"30924804","Getting variable encryption results with VB.Net and DES","<p>I'm working on an semi-internal encryption process for somewhat sensitive information. Email addresses and the like. I'm working with a few other developers at some sister companies on the project, and the requirements are that everyone's encryption can talk to everyone else's. We use a global password, encrypt and decrypt information onsite, and that's about it.</p>

<p>My problem is that my encryption procedure, while matching theirs, is giving me variable results. I'm currently polling our SQL server for the strings to be encrypted in question, iterating through the array of results, and updating the server with the encrypted strings.</p>

<p>The problem is that the first string is always different from all subsequent strings, and isn't recognized as valid by the testing software we're supposed to be basing our solution off of. The second and all subsequent strings come through just fine.</p>

<p>Example:</p>

<pre><code>test@test.com - BrPURPlWW7+VYrR5puJ/JHXoIp/MV5WR
test@test.com - BrPURPlWW79h+n4Tgot0xRmM7SdWQQsy
test@test.com - BrPURPlWW79h+n4Tgot0xRmM7SdWQQsy
</code></pre>

<p>I can't quite figure out what's going on, because I can encrypt and decrypt back and forth on my own machine with no issues. Any advice would be lovely.</p>

<p>My encryption function follows:</p>

<pre><code>Private TripleDES As New DESCryptoServiceProvider     
Sub New(ByVal key As String)        
    Dim ivHash(), keyHash() As Byte

    keyHash = System.Text.Encoding.UTF8.GetBytes(key)
    ReDim Preserve keyHash(7)
    TripleDES.Key = keyHash

    ivHash = System.Text.Encoding.UTF8.GetBytes(String.Empty)
    ReDim Preserve ivHash(7)
    TripleDES.IV = ivHash
End Sub

Public Function EncryptData(ByVal Plaintext As String) As String
    Dim PlaintextBytes() As Byte = System.Text.Encoding.UTF8.GetBytes(Plaintext)
    Dim ms As New System.IO.MemoryStream
    Dim encStream As New CryptoStream(ms, TripleDES.CreateEncryptor(), System.Security.Cryptography.CryptoStreamMode.Write)

    TripleDES.Mode = CipherMode.ECB

    encStream.Write(PlaintextBytes, 0, PlaintextBytes.Length)
    encStream.FlushFinalBlock()

    Return Convert.ToBase64String(ms.ToArray)
End Function

Public Function DecryptData(ByVal EncryptedText As String) As String
    Dim EncryptedBytes() As Byte = Convert.FromBase64String(EncryptedText)
    Dim ms As New System.IO.MemoryStream
    Dim decStream As New CryptoStream(ms, TripleDES.CreateDecryptor(), System.Security.Cryptography.CryptoStreamMode.Write)

    TripleDES.Mode = CipherMode.ECB

    decStream.Write(EncryptedBytes, 0, EncryptedBytes.Length)
    decStream.FlushFinalBlock()

    Return System.Text.Encoding.UTF8.GetString(ms.ToArray)

End Function
</code></pre>
","<p>You are setting <code>TripleDES.Mode = CipherMode.ECB</code> after you have called <code>TripleDES.CreateEncryptor()</code>, so the first encryption is using the default value of <code>CipherMode.CBC</code>.  Since <code>TripleDES</code> is reused, after the first call to <code>EncryptData</code> its <code>Mode</code> is set correctly.</p>

<p>Move <code>TripleDES.Mode = CipherMode.ECB</code> into <code>New</code> and it should work consistently.</p>
","315","<vb.net><encryption><des>","0","0","1","2015-06-18 20:32:55","30925290","0","","","","","2015-06-18 20:05:58",""
"28846702","What type of encryption do I need?","<p>Ok, the original task is to track users among 2 ""friendly"" web-sites who are able to share users cookies (lets say, I have example.com and my friend has mysite.com and also he has a domain simple.example.com so he can set cookies on .example.com).</p>

<p>To track users activity we want to set unique cookie, this cookie should be unique and 32 bytes long (ascii). Quite simple from this point of view and can be implemented as such:</p>

<pre><code>md5(microtime)
</code></pre>

<p>and that's it, but now we have new <strong>constraints</strong>:</p>

<ol>
<li><p>we should be able to tell who exactly has set the cookie: exmaple.com engine or mysite.com engine</p></li>
<li><p>32 bytes longs is a must, still</p></li>
<li><p>we should be able to encrypt timestamp (when cookies was issued)</p></li>
<li><p>first and last character of the resulting cookie value should be different so we can do A/B testing basing on the cookie (so we could always say if last character of the cookie is ""> K"", show this users ""feature A"")</p></li>
</ol>

<p>Given that the resulting string should always be 32 or less characters long and data should be encrypted and decrypted (not by users, of course) and the string should be unique for the users, it makes the task quite complex.</p>

<p>My thought and questions:</p>

<ul>
<li><p>we should use symmetric key encryption (solves <em>constraints</em> 1 and 3), but it this case how do we ensure that resulting string is no longer than 32 chars (<em>constraint</em> 2)?</p></li>
<li><p>is there other solution on the problem given that amount of data we need to encrypt is: timestamp and microseconds (14 bytes), site-issuer flag (1 byte) = 15 bytes total</p></li>
</ul>

<p>My first take was to pack data into binary string and than base64-encode it. The result would be 8-chars long base64-encoded string:</p>

<pre><code>def encode():
    base64( pack('Lv', timestamp, microseconds) )
</code></pre>

<p>Add site-issuer flag and chars at the beginning and the end:</p>

<pre><code>def getCookie():
    rand('a'...'Z') + encode() + issuerFlagChar() + rand('a'...'Z')
</code></pre>

<p>So, the result is 11 chars long and we meet <em>constraint 2</em> easily.</p>

<p>But the problem is: this algorithm is not secure for sure, I'm not sure if the resulting string for millions of websites users is unique.</p>

<p>I wonder if I could use DES or AES for this purpose but I'm not sure that the resulting string will always meet <em>constraint 2</em> (resulting string should be no longer than 32 ascii chars).</p>

<p>Is there symmetric key algorithms that ensure something like ""if you encrypt N bytes with M-bytes key you will have resulting data length of Math.Ceil(N*2+1/M) bytes""? So the resulting length would be predictable?</p>
","<p>Setting aside the fact that you should indeed consult a security consultant, the actual question you pose can easily be answered:</p>

<blockquote>
  <p>Is there symmetric key algorithms that ensure something like ""if you encrypt N bytes with M-bytes key you will have resulting data length of Math.Ceil(N*2+1/M) bytes""? So the resulting length would be predictable?</p>
</blockquote>

<p>Yes there are. And they are called <a href=""http://en.wikipedia.org/wiki/Block_cipher"" rel=""noreferrer"">Block Ciphers</a>. </p>

<p>By definition, every block cipher has the property that <em>the length of the ciphertext is equal to the length of the plain text</em>. In practice most block ciphers (inclusing DES and AES) cheat a bit because they require the plaintext to be <a href=""http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""noreferrer"">padded to the length of the block</a> before they start encrypting. </p>

<p>In other words, given a plaintext of <code>N</code> bytes and a block size of <code>B</code>, the ciphertext will have a length of <code>B*(Math.ceil(N/B))</code> bytes.</p>

<p>Note how I am talking about the <em>block size</em>, which is different from the <em>key size</em>. The key size is actually irrelevant in this case.</p>

<p>For example, <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">AES uses a block size of 128 bits</a>, or 16 bytes. This means that if your plain text is between 17 and 32 bytes long, AES will guarantee that your ciphertext is 32 bytes long. This is independent from the key size you choose, which can be one of 128, 192 or 256 bits (16, 24 or 32 bytes). </p>
","314","<encryption><aes><des><encryption-symmetric>","1","6","2","2015-03-17 05:03:07","29091631","6","0","","","","2015-03-04 04:30:56",""
"28846702","What type of encryption do I need?","<p>Ok, the original task is to track users among 2 ""friendly"" web-sites who are able to share users cookies (lets say, I have example.com and my friend has mysite.com and also he has a domain simple.example.com so he can set cookies on .example.com).</p>

<p>To track users activity we want to set unique cookie, this cookie should be unique and 32 bytes long (ascii). Quite simple from this point of view and can be implemented as such:</p>

<pre><code>md5(microtime)
</code></pre>

<p>and that's it, but now we have new <strong>constraints</strong>:</p>

<ol>
<li><p>we should be able to tell who exactly has set the cookie: exmaple.com engine or mysite.com engine</p></li>
<li><p>32 bytes longs is a must, still</p></li>
<li><p>we should be able to encrypt timestamp (when cookies was issued)</p></li>
<li><p>first and last character of the resulting cookie value should be different so we can do A/B testing basing on the cookie (so we could always say if last character of the cookie is ""> K"", show this users ""feature A"")</p></li>
</ol>

<p>Given that the resulting string should always be 32 or less characters long and data should be encrypted and decrypted (not by users, of course) and the string should be unique for the users, it makes the task quite complex.</p>

<p>My thought and questions:</p>

<ul>
<li><p>we should use symmetric key encryption (solves <em>constraints</em> 1 and 3), but it this case how do we ensure that resulting string is no longer than 32 chars (<em>constraint</em> 2)?</p></li>
<li><p>is there other solution on the problem given that amount of data we need to encrypt is: timestamp and microseconds (14 bytes), site-issuer flag (1 byte) = 15 bytes total</p></li>
</ul>

<p>My first take was to pack data into binary string and than base64-encode it. The result would be 8-chars long base64-encoded string:</p>

<pre><code>def encode():
    base64( pack('Lv', timestamp, microseconds) )
</code></pre>

<p>Add site-issuer flag and chars at the beginning and the end:</p>

<pre><code>def getCookie():
    rand('a'...'Z') + encode() + issuerFlagChar() + rand('a'...'Z')
</code></pre>

<p>So, the result is 11 chars long and we meet <em>constraint 2</em> easily.</p>

<p>But the problem is: this algorithm is not secure for sure, I'm not sure if the resulting string for millions of websites users is unique.</p>

<p>I wonder if I could use DES or AES for this purpose but I'm not sure that the resulting string will always meet <em>constraint 2</em> (resulting string should be no longer than 32 ascii chars).</p>

<p>Is there symmetric key algorithms that ensure something like ""if you encrypt N bytes with M-bytes key you will have resulting data length of Math.Ceil(N*2+1/M) bytes""? So the resulting length would be predictable?</p>
","<p>First of all, you need to know whether you want to <em>encrypt</em> or <em>sign</em> the data.</p>

<p>Encrypting will prevent users from <em>seeing</em> the data, but they are still able to modify it in some ways depending on the encryption type. For example, decrypting a modified ciphertext will simply give corrupted data, it won't fail. </p>

<p>Signing, on the other hand, will prevent users from <em>modifying</em> the data, that is, your code will be able to detect the data has been modified. A simple algorithm for this is <a href=""https://en.wikipedia.org/wiki/Hash-based_message_authentication_code"" rel=""nofollow"">HMAC</a>.</p>

<p>I'll assume you want both. My solution below does both.</p>

<p>Your cookie must be 32 bytes long, which is 256 bits. We are going to use 128 bits for encrypted data and 128 bits for the HMAC. </p>

<p>For the data, I will encode the timestamp as a 64bit integer (more than enough even if you want to store it to microsecond precision). The site that issued the cookie can be stored as 1 bit if you have two sites, but I'll store it in a 32bit integer because we have plenty of space. Same for a tag you can use for a/b testing.</p>

<p>All the data is exactly 128 bits, 16 bytes. This is the exact size of an AES block. So, we will encrypt it with AES!</p>

<p>The other 16 bytes will be a MAC of the ciphertext (<a href=""https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac"">Encrypt then MAC</a>). I used HMAC-SHA256, which has 256bits of output. We only have room for 128bits, so I have truncated it. In theory this makes it less secure, but in practice 128bit is big enough to make a brute-force attempt impossible.</p>

<p>Decrypting the cookie is the reverse process: calculate the HMAC of the given ciphertext and check it matches the given MAC. If so, proceeed to decrypt the ciphertext and unpack the data.</p>

<p>Here's the code:</p>

<pre><code>from struct import pack, unpack
from Crypto.Cipher import AES
import hashlib
import hmac


AES_KEY = hashlib.sha256(b""secret key 1 asdfasdf"").digest()
HMAC_KEY = hashlib.sha256(b""secret key 2 asdfasdf"").digest()

# timestamp: 64bit unix timestamp
# site: 32bit integer, which site issued the cookie
# tag: 32bit integer, tag used for a/b testing.
def encrypt_cookie(timestamp, site, tag):

    # Pack the data
    data = pack('QII', timestamp, site, tag)

    # Encrypt it
    aes = AES.new(AES_KEY, AES.MODE_ECB, 'This is an IV456')
    ciphertext = aes.encrypt(data)

    # Do HMAC of the ciphertext
    sig = hmac.new(HMAC_KEY, ciphertext, hashlib.sha256).digest()
    sig = sig[:16]   # Truncate to only first 16 bytes.

    return ciphertext + sig

def decrypt_cookie(cookie):

    # Do HMAC of the ciphertext
    sig = hmac.new(HMAC_KEY, cookie[:16], hashlib.sha256).digest()
    sig = sig[:16]   # Truncate to only first 16 bytes.

    # Check the HMAC is ok
    if sig != cookie[16:]:
        raise Exception(""Cookie has been tampered with"")

    # Decrypt it
    aes = AES.new(AES_KEY, AES.MODE_ECB, 'This is an IV456')
    data = aes.decrypt(cookie[:16])

    # unPack the data
    timestamp, site, tag = unpack('QII', data)

    return timestamp, site, tag

cookie = encrypt_cookie(1, 2, 3)
print(len(cookie))  # prints: 32
print(decrypt_cookie(cookie))  # prints: 1, 2, 3

# Change a single byte in the cookie, the last one
cookie = cookie[:31] + b'0'
print(decrypt_cookie(cookie))  # raises the exception
</code></pre>

<p>I'm curious to know why the cookie must be 32bytes though. Seems a weird requirement, and if you didn't have it, you'd be able to use many libraries that are designed to solve exactly this problem, such as <a href=""https://docs.djangoproject.com/en/1.7/topics/signing/"" rel=""nofollow"">Django signing</a> if you're using Django.</p>
","314","<encryption><aes><des><encryption-symmetric>","1","3","2","2015-03-17 05:03:07","29091631","6","0","","","","2015-03-04 04:30:56",""
"43270291","How can I ensure correct padding in DES encryption?","<p>I am trying to implement a basic Diffie-Hellman protocol and the code succeeds up to the point when it needs to decrypt the sent value using DES. I have looked at a lot of examples in which it was a matter of the keys not matching up, but I am printing their values on both ends of the connection and they are both exactly the same. I have also tried multiple padding schemes as well as changing how the keys were generated.</p>

<p>My last attempt was in adding the parameter IvParameterSpec to the cipher init, but that only solved one of the errors.</p>

<p>I am running this on a single machine where the socket is connecting over the localhost and I have been checking for any issues on either side with the sent data not exactly matching the received data, but nothing is altered in the sending. I did notice, however, that when printing each of the byte arrays on either side of the socket that the client side is much longer than the server with what appears to be padding(?)</p>

<p>The error I am getting is saying that the final block is padded incorrectly and so decryption fails</p>

<p>My Server code (the side that is not working as intended):</p>

<pre><code>public static void main(String[] args) {
    ServerSocket welcomeSocket = null;

    // Creates a connectable socket on port 6789
    try {
        welcomeSocket = new ServerSocket(6789);
    } catch (IOException e) {
        e.printStackTrace();
    }
    while(true){
        try{
            double k2, B, A;
            double n = 13;
            double g = 61;
            long y = 7;
            B = (Math.pow(g, y))%n;

            System.out.println(""Accepting connections"");
            // Accept an incoming connection on the socket server
            Socket connectionSocket = welcomeSocket.accept();
            // Creates a read and write stream for that client
            DataInputStream inFromClient = new DataInputStream(connectionSocket.getInputStream());
            DataOutputStream outToClient = new DataOutputStream(connectionSocket.getOutputStream());

            // Sends the double to the client
            outToClient.writeDouble(B);
            System.out.println(""Sent "" + B);
            // Reads the number sent by the Client
            A = inFromClient.readDouble();
            System.out.println(""Received "" + A);

            // Modifies the number
            k2 = (Math.pow(A, y))%n;
            System.out.println(""DES key seed = "" + k2);
            byte[] deskeydata = toByteArray(k2);

            // Turns the bytes of the modified number into a DES key spec
            DESKeySpec deskeyspec = new DESKeySpec(deskeydata);

            // Makes a secret key (DES)
            SecretKeyFactory keyF = SecretKeyFactory.getInstance(""DES"");
            SecretKey keystuff = keyF.generateSecret(deskeyspec);
            System.out.println(keystuff.toString());

            // Gets an incoming string from the client and turns it into binary
            byte[] incomingBytes = new byte[128];
            try{
                inFromClient.readFully(incomingBytes);
            } catch(EOFException eof){
                System.out.println(""Finished reading"");
            }
            System.out.println(new String(incomingBytes));
            Cipher c = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

            // Decrypts the string using the shared secret key
            c.init(Cipher.DECRYPT_MODE, keystuff, new IvParameterSpec(new byte[8]));
            byte[] ct2 = c.doFinal(incomingBytes);

            // Decode it from base 64
            //byte[] decodedBytes = Base64.getDecoder().decode(ct2);

            // Prints the received string
            System.out.println(""Received: "" + new String(ct2));

            inFromClient.close();
            outToClient.close();

        } catch(Exception e){
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>My Client code:</p>

<pre><code>public static void main(String[] args) {

    // Creates a socket to the local host on port 6789
    Socket clientSocket = null;
    try {
        clientSocket = new Socket(""localhost"", 6789);
    } catch (IOException e1) {
        e1.printStackTrace();
    }
    try{
        double k1, B, A;
        double n = 13;
        double g = 61;
        long x = 3;

        // Sends an unencrypted number to the server
        A = (Math.pow(g, x))%n;
        DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());
        DataInputStream inFromServer = new DataInputStream(clientSocket.getInputStream());  

        // Transforms A into a byte array and sends it over
        outToServer.writeDouble(A);
        outToServer.flush();
        System.out.println(""Sending "" + A);

        // Reads the incoming data from the server
        B = inFromServer.readDouble();
        System.out.println(""Recieved "" + B);

        // Modifies the data to create the number for des key
        k1 = (Math.pow(B, x))%n;
        System.out.println(""DES key seed = "" + k1);
        byte[] deskeydata = toByteArray(k1);

        // Turns the bytes of the modified number into a DES key spec
        DESKeySpec deskeyspec = new DESKeySpec(deskeydata);

        // Makes a secret key (DES)
        SecretKeyFactory keyF = SecretKeyFactory.getInstance(""DES"");
        SecretKey keystuff = keyF.generateSecret(deskeyspec);
        System.out.println(keystuff.toString());

        // Takes in input from the user and turns it into binary
        BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(""Enter a message:"");

        String sentence = inFromUser.readLine();
        byte[] str2 = sentence.getBytes();
        byte[] encodedMessage = Base64.getEncoder().encode(str2);

        Cipher c = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

        // Encrypts the user's input with the secret key
        c.init(Cipher.ENCRYPT_MODE, keystuff, new IvParameterSpec(new byte[8]));
        byte[] ct2 = c.doFinal(encodedMessage);
        System.out.println(""Initted the cipher and moving forward with "" + new String(ct2));

        // Writes the encrypted message to the user
        outToServer.write(ct2);
        outToServer.flush();


        inFromServer.close();
        outToServer.close();
    } catch(Exception e){
        e.printStackTrace();
    }

}
</code></pre>

<p>Anything that could help me in getting this working would be immensely welcome since I have been working on this error alone for quite some time.</p>
","<p>I managed to figure out a way to solve this (though I suspect it is very inefficient). The issue was due to the readFully method on the server side. I was reading the answer into a 128 byte array and the decrypt function saw the empty slots in the byte array as something instead of nothing. </p>

<p>To solve this I replaced the input section with the following, which reads each individual byte and creates an array of bytes with the exact length of the incoming message.</p>

<pre><code>            ArrayList&lt;Byte&gt; totalBytes = new ArrayList&lt;Byte&gt;();
            while(true){
                try{
                    byte in = inFromClient.readByte();
                    totalBytes.add(in);
                } catch(EOFException eof){
                    System.out.println(""Finished reading"");
                    break;
                }
            }
            int incomingSize = totalBytes.size();
            byte[] receivedBytes = new byte[incomingSize];
            for(int i = 0; i &lt; incomingSize; i++){
                receivedBytes[i] = totalBytes.get(i);
            }
</code></pre>
","314","<java><sockets><encryption><des>","0","0","1","2017-04-07 17:44:07","","6","3","1816580","","2017-04-07 17:44:07","2017-04-07 05:25:39",""
"15398193","How to read DES encrypted file contents (Created with C#) on Android devices","<p>We have a bunch of contents which were already DES encrypted using C# on the desktop side. We want to decrypt them on the android application. Trying almost every encodings, we could not get the exact decrypted values on the android side. Could you please tell us what is wrong in android side? By the way, we know that DES is not the best solution for encryption. But, the contents were previously created and we have no option to use another mechanism.</p>

<p><strong>Here is the encryption code written with C#.</strong></p>

<pre><code>using (FileStream outputStream = new FileStream(strOutputFileName, FileMode.OpenOrCreate, FileAccess.ReadWrite))
{
    DESCryptoServiceProvider cryptic = new DESCryptoServiceProvider();
    cryptic.Key = ASCIIEncoding.ASCII.GetBytes(passKey);
    cryptic.IV = ASCIIEncoding.ASCII.GetBytes(passKey);
    CryptoStream crStream = new CryptoStream(outputStream, cryptic.CreateEncryptor(), CryptoStreamMode.Write);
    crStream.Write(fileBuffer, 0, fileBuffer.Length);
    crStream.Close();
}
</code></pre>

<p><strong>Here is the decryption part on the Android side</strong></p>

<pre><code>String CIPHER_ALGORITHM = ""DES/CFB8/NoPadding"";
SecretKeySpec key5= new SecretKeySpec(""passkey*"".getBytes(""UTF-8""), 
    CIPHER_ALGORITHM);

String ivString = ""passkey*"";
byte[] ivByte = ivString.getBytes(""UTF-8"");
IvParameterSpec iv5 = new IvParameterSpec(ivByte);  

Cipher c = Cipher.getInstance(CIPHER_ALGORITHM);
c.init(Cipher.DECRYPT_MODE, key5, iv5);

CipherInputStream cis = new CipherInputStream(
    new FileInputStream(""/sdcard/test_folder/test.file""), c);

BufferedReader br = new BufferedReader(new InputStreamReader(cis));
Log.d(""SONUC2"", "" "" +br.readLine());
</code></pre>
","<p>""Thanks for your help. Changing the CIPHER_ALGORITHM to ""DES/CBC/NoPadding solved my problem.</p>
","313","<c#><android><encryption><des>","0","0","1","2018-06-26 08:50:26","","4","3","1033581","","2018-06-26 08:50:26","2013-03-13 23:03:49",""
"56774274","openssl 3des with c++","<p>I want to use the <code>openssl</code> library in <code>C++</code> to decrypt data.</p>

<p>I have the key and IV and the encoded base64 string.</p>

<p>I couldn't make it through the documentation, all decryption methods in the header file (<code>openssl/des.h</code>) take 3 keys.</p>

<p>I've managed to achieve the result with the following python code.</p>

<pre><code>from pyDes import *
import base64

key = base64.b64decode(""****"")
iv = base64.b64decode(""***"")
enc = base64.b64decode(""******"")
encryptor = triple_des(key, CBC, iv)
plain = encryptor.decrypt(enc)
print(plain.decode(""utf-8""))
</code></pre>

<p>I want to get the same result using C++ code and OpenSSL library.</p>
","<p>3DES uses three keys. The python function you are using probably derives three keys from the key argument you pass, probably splitting it in three parts.</p>

<p>To use the OpenSSL function, you have to generate 3 keys with 8 bytes each (or a 24 bytes key split in 3).</p>

<p>I adapted the code I found <a href=""http://www.firmcodes.com/triple-des-cbc-mode-encryption-example-c-programming-openssl/"" rel=""nofollow noreferrer"">here</a> to use ECB instead of CBC. But, for security reasons, you should consider using CBC, or even AES encryption instead of 3DES.</p>

<p>The example only shows how to use the <code>DES_ecb3_encrypt</code> function with hard coded keys. In a final solution, you have to generate your own keys, using a good RNG.</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;openssl/des.h&gt;

/* Triple DES key for Encryption and Decryption */
DES_cblock Key1 = { 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11 };
DES_cblock Key2 = { 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22 };
DES_cblock Key3 = { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33 };
DES_key_schedule SchKey1,SchKey2,SchKey3;

/* Print Encrypted and Decrypted data packets */
void print_data(const char *tittle, const void* data, int len);

int main()
{
    /* Input data to encrypt */
    DES_cblock input_data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x6, 0x7, 0x8};

    /* Check for Weak key generation */
    if ( -2 == (DES_set_key_checked(&amp;Key1, &amp;SchKey1) || DES_set_key_checked(&amp;Key2, &amp;SchKey2) || DES_set_key_checked(&amp;Key3, &amp;SchKey3)))
    {
        printf("" Weak key ....\n"");
        return 1;
    }

    /* Buffers for Encryption and Decryption */
    DES_cblock cipher;
    DES_cblock text;

    /* Triple-DES ECB Encryption */
    DES_ecb3_encrypt(&amp;input_data, &amp;cipher, &amp;SchKey1, &amp;SchKey2, &amp;SchKey3, DES_ENCRYPT);

    /* Triple-DES ECB Decryption */
    DES_ecb3_encrypt(&amp;cipher, &amp;text, &amp;SchKey1, &amp;SchKey2, &amp;SchKey3, DES_DECRYPT);

    /* Printing and Verifying */
    print_data(""\n Original "", (const void*) input_data, sizeof(input_data));
    print_data(""\n Encrypted"", (const void*) cipher, sizeof(input_data));
    print_data(""\n Decrypted"", (const void*) text, sizeof(input_data));

    return 0;
}
void print_data(const char *tittle, const void* data, int len)
{
    printf(""%s : "",tittle);
    const unsigned char * p = (const unsigned char*)data;
    int i = 0;

    for (; i&lt;len;++i)
        printf(""%02X "", *p++);

    printf(""\n"");
}
</code></pre>

<p><a href=""https://www.openssl.org/docs/man1.0.2/man3/DES_ecb3_encrypt.html"" rel=""nofollow noreferrer"">OpenSSL reference</a>:</p>

<pre class=""lang-c prettyprint-override""><code>void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, 
        DES_key_schedule *ks1, DES_key_schedule *ks2, 
        DES_key_schedule *ks3, int enc);
</code></pre>

<blockquote>
  <p>DES_ecb3_encrypt() encrypts/decrypts the input block by using three-key Triple-DES encryption in ECB mode. This involves encrypting the input with ks1, decrypting with the key schedule ks2, and then encrypting with ks3. This routine greatly reduces the chances of brute force breaking of DES and has the advantage of if ks1, ks2 and ks3 are the same, it is equivalent to just encryption using ECB mode and ks1 as the key.</p>
</blockquote>
","313","<c++><openssl><des><tripledes>","3","2","1","2019-06-26 18:38:55","56779180","0","","","","","2019-06-26 13:41:25",""
"25112140","DES Decryption issue for objective c","<p>I have to decrypt a data in Objective C. The decryption scheme is DES/ECB/NoPadding  with following input data = 741DCDDF1C216EEF and key = D9C44F6D2589255E and output should be 34160D6EADAD6D86 with the following code am getting output as aec6f702 5b4619e1 064db829 925a10d7</p>

<p>i am passing input as</p>

<pre><code>uint8_t ksn10[16] = { 0x0D, 0x09, 0x0C, 0x04, 0x04, 0x0F, 0x06, 0x0D,
    0x02, 0x05, 0x08, 0x09, 0x02, 0x05, 0x05, 0x0E};
uint8_t bytes32[16] = { 0x07, 0x04, 0x01, 0x0D, 0x0C, 0x0D, 0x0D, 0x0F,
    0x01, 0x0C, 0x02, 0x01, 0x06, 0x0E, 0x0E, 0x0F};

NSData *TMKKey = [NSData dataWithBytes:ksn10 length:16];
NSData *SessionKey = [NSData dataWithBytes:bytes32 length:16];
</code></pre>

<p>method definition:</p>

<pre><code>NSData *encoded_data=  [self DESCrypto:(NSData*)TMKKey:(NSData*)SessionKey:kCCDecrypt:     [SessionKey length]:kCCAlgorithmDES:kCCKeySizeDES:kCCOptionECBMode|0x0000];

NSLog(@""%@"", encoded_data);
</code></pre>

<p>method call :</p>

<pre><code>-(NSData*)DESCrypto :(NSData *)key :(NSData*)dataIn :(CCOperation)CryptOperation :(int)inlength :(CCAlgorithm)type :(size_t)keysize :(CCOptions)mode
</code></pre>

<p>{</p>

<pre><code>char dataOut[16000];
bzero(dataOut, sizeof(dataOut));
size_t numBytesEncryptedorDecrypted=0;
char iv[8]={0};
CCCryptorStatus result =CCCrypt(CryptOperation,type,mode,[key bytes],keysize,iv,[dataIn bytes],inlength, dataOut, sizeof(dataOut), &amp;numBytesEncryptedorDecrypted);

NSLog(@""CryptoStatus:%d"",result);



NSData *data=[[NSData alloc]initWithBytes:dataOut length:numBytesEncryptedorDecrypted];

return data;
</code></pre>

<p>}</p>

<p>but am not getting  correct output. please help me to get 34160D6EADAD6D86 as output and let me know what is wrong in this code.</p>
","<p>Change the data and key to the correct hex representation and the decryption does produce the correct value:</p>

<pre><code>input data: 741DCDDF1C216EEF
key:        D9C44F6D2589255E
output:     34160D6EADAD6D86 
</code></pre>

<p>Test (no error checking, all inputs assumed correct):</p>

<pre><code>uint8_t dataInBytes[8] = { 0x74, 0x1D, 0xCD, 0xDF, 0x1C, 0x21, 0x6E, 0xEF };
int dataLength = 8;
uint8_t keyBytes[8] = { 0xD9, 0xC4, 0x4F, 0x6D, 0x25, 0x89, 0x25, 0x5E };
uint8_t *dataOutBytes = calloc(1, dataLength);

CCCrypt(kCCDecrypt,
        kCCAlgorithmDES, kCCOptionECBMode,
        keyBytes, kCCKeySizeDES,
        NULL,
        dataInBytes,  dataLength,
        dataOutBytes, dataLength,
        NULL);

NSString *s = @""dataOutBytes: "";
for (int i=0; i&lt;8; i++) {s = [s stringByAppendingFormat:@""%02X"", dataOutBytes[i]];}
NSLog(@""%@"", s);
</code></pre>

<p>output:  </p>

<pre><code>dataOutBytes: 34160D6EADAD6D86
</code></pre>
","308","<ios><objective-c><encryption><des>","0","0","1","2014-08-04 14:38:04","","2","","","","","2014-08-04 05:15:36",""
"33622590","Tinkering with pyDes mode of operation","<p>So, in <a href=""https://twhiteman.netfirms.com/des.html"" rel=""nofollow"">pyDes</a>, a cryptographic library of DES, there is an API, which goes like this <code>pyDes.des(key, [mode], [IV], [pad], [padmode])</code>. An usage of it goes like this <code>k = des(""DESCRYPT"", CBC, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)</code> - where I can either use CBC or ECB mode of encryption.However, as an assignment from my professor, I am told to encrypt using pyDes library, but using CBC and Counter Mode manually. </p>

<p>I managed to do CBC mode fine, unfortunately I am stuck with the counter mode.
Using the given api of <code>des(key, CBC, IV ...)</code> I can only use IV when I use CBC or ECB mode of operation. I can not use it something like <code>des(""hello"", mode = None, ""foo"",....)</code> where ""foo"" is my IV.( I am supposed to implement Counter mode of operation and the iv is random in every single iteration)
So, my question is did anyone faced this issue, and tried to overcome it.</p>
","<p>The main operation that you need to isolate in order to implement some mode is the actual block cipher without a mode of operation or padding. pyDes doesn't seem to provide direct access to the block cipher directly, but you can emulate it easily with the ECB mode. ECB is a simple execution of the block cipher on all input blocks in the same way. </p>

<p>The idea would be to create a counter input stream, execute ECB on the input stream to get the key stream and then XOR every byte of the plaintext with the corresponding byte in the key stream.</p>

<p>Steps for <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_.28CTR.29"" rel=""nofollow"">CTR mode</a>:</p>

<ol>
<li><p>Generate a random nonce (IV) in the range of <code>0</code> to <code>1&lt;&lt;64</code> (DES block size) which is the starting counter:</p>

<pre><code>import random
r = random.SystemRandom()
nonce = r.randrange(0, 1&lt;&lt;64)
</code></pre></li>
<li><p>Convert the counter for each block of the plaintext to bytes with <a href=""https://docs.python.org/2/library/struct.html#struct.pack"" rel=""nofollow""><code>struct.pack('&gt;Q', counter)</code></a> and increase the counter by one</p></li>
<li>Repeat until you have at least as much bytes in the counter stream as in the plaintext</li>
<li>Encrypt the counter input stream with ECB mode and any available padding</li>
<li>XOR the key stream and the plaintext and throw away the rest of the key stream (if any)</li>
</ol>

<p>Since CTR mode is a stream cipher, you can use the exact same operation for decrypting with the only difference that the nonce must be supplied from outside. You can prepend the nonce to the ciphertext so that it can be used for decryption. It doesn't have to be secret, but it needs to be unique if the same key is used. </p>

<p>Note that the block size of DES and 3DES doesn't permit to encrypt many ciphertexts or long ciphertexts with CTR under the same key. If you do then you need to change to a block cipher with a bigger block size like AES.</p>
","305","<python><encryption><des><ctr-mode>","0","1","1","2015-11-10 09:44:13","","0","","1816580","","2015-11-10 09:38:45","2015-11-10 03:54:09",""
"42522434","C# implementation for identity based encryption(IBE)","<p>I am a student and I want to implement Identity based encryption by using c#.</p>

<p><strong>Example:</strong> I want to encrypt a message by using receivers email address(Public Key) and sender will send this message to receiver. Once receiver receives this encrypted message, he will decry-pt this message by using his private key.</p>

<p>This looks okay theoretically, but I am struggling to do this practically.</p>

<p><strong>I don't know</strong> </p>

<ol>
<li>how to encrypt a message by using receivers email address </li>
<li>how receiver will decry-pt encrypted message? </li>
<li>how receiver will get his private key?</li>
</ol>

<p><strong>I am expecting help from this platform, as I already spent a lot of time on searching this.</strong></p>

<p><strong>What I have tried:</strong></p>

<p>I tried encryption and decryption by using RSA algorithm, but the problem here is RSA generates his own public and private key pair. And I can not use receivers email address as a public key to encrypt message.</p>

<p>Thank you in advance.
Ashok</p>
","<p>You can generate secure symmetric keys from an email address, any string for that matter, with a key derivation function such as <code>PBKDF2</code> (aka <code>Rfc2898DeriveBytes</code>).</p>

<p>RSA is asymmetric encryption with separate keys for encryption and decryption, symmetric encryption such as AES uses one key for both encryption and decryption.</p>

<p>Asymmetric encryption  such as RSA has the advantage of two keys where the encryption key can be publicly known. But it is very slow and the data size, the keys are large (2048-bits is a currently secure size) and the data length is limited to the key size, it is generally used to encrypt symmetric keys. There is no control over symmetric key pair creation other than length.  Use asymmetric encryption only when a public/private key pair must be used.</p>

<p>Asymmetric encryption such as AES is fast, has smaller keys with 128-bits common and secure and can handle data of essentially any length.</p>
","301","<c#-4.0><rsa><public-key-encryption><des><encryption-asymmetric>","0","1","1","2017-03-01 13:00:12","","3","","","","","2017-03-01 03:04:29",""
"24848823","Not able to decrypt an encrypted file using DES in java from a different class","<p>Basically, I'm able to create an encrypted file to store user's credentials. Now my requirement is to use that file for future reference to get the credentials by decrypting it and use it for verification of the user. I'm creating a windows based desktop application. I got few codes that decrypts successfully within the same class, but didn't get how to decrypt it from a different class.
Below is the identical code I used for encrypting. I got it from the net which ran successfully. Please tell me how to decrypt it now from a new class.</p>

<pre><code>import java.security.*;
import javax.crypto.*;
public class PrivateExample 
{
 public static void main (String[] args) throws Exception 
{
    String text=new String();
    text=""This is an encryption test"";
    byte[] plainText = text.getBytes(""UTF8"");
    System.out.println( ""\nStart generating DES key"" );
    KeyGenerator keyGen = KeyGenerator.getInstance(""DES"");
    keyGen.init(56);
    Key key = keyGen.generateKey();
    System.out.println( ""Finish generating DES key"" );

    // get a DES cipher object and print the provider
    Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    System.out.println( ""\n"" + cipher.getProvider().getInfo() );
    //
   // encrypt using the key and the plaintext
    System.out.println( ""\nStart encryption"" );
    cipher.init(Cipher.ENCRYPT_MODE, key);
    byte[] cipherText = cipher.doFinal(plainText);
    System.out.println( ""Finish encryption: "" );
    System.out.println( new String(cipherText, ""UTF8"") );

   //Now writing to an ouput file the cipherText
   try{
       FileOutputStream fs=new FileOutputStream(""c:/test.txt"");
      fs.write(cipherText);
     }catch(Exception e){
       e.printStackTrace();
     }

}
}
</code></pre>
","<p>You can decrypt it with Cipher.doFinal() method after reading the textEncrypted from the file that you save. Also check this <a href=""https://stackoverflow.com/questions/16390526/using-des-to-encrypt-and-decrypt-a-file-in-java"">question</a>, Using DES to encrypt and decrypt a file in Java, this will help while working with files.</p>

<pre><code>desCipher.init(Cipher.DECRYPT_MODE, myDesKey);
byte[] textDecrypted = desCipher.doFinal(textEncrypted);
</code></pre>
","298","<java><encryption><des>","-1","0","2","2014-07-28 04:46:48","","1","2","3857455","","2014-07-20 08:52:09","2014-07-20 08:44:52",""
"24848823","Not able to decrypt an encrypted file using DES in java from a different class","<p>Basically, I'm able to create an encrypted file to store user's credentials. Now my requirement is to use that file for future reference to get the credentials by decrypting it and use it for verification of the user. I'm creating a windows based desktop application. I got few codes that decrypts successfully within the same class, but didn't get how to decrypt it from a different class.
Below is the identical code I used for encrypting. I got it from the net which ran successfully. Please tell me how to decrypt it now from a new class.</p>

<pre><code>import java.security.*;
import javax.crypto.*;
public class PrivateExample 
{
 public static void main (String[] args) throws Exception 
{
    String text=new String();
    text=""This is an encryption test"";
    byte[] plainText = text.getBytes(""UTF8"");
    System.out.println( ""\nStart generating DES key"" );
    KeyGenerator keyGen = KeyGenerator.getInstance(""DES"");
    keyGen.init(56);
    Key key = keyGen.generateKey();
    System.out.println( ""Finish generating DES key"" );

    // get a DES cipher object and print the provider
    Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    System.out.println( ""\n"" + cipher.getProvider().getInfo() );
    //
   // encrypt using the key and the plaintext
    System.out.println( ""\nStart encryption"" );
    cipher.init(Cipher.ENCRYPT_MODE, key);
    byte[] cipherText = cipher.doFinal(plainText);
    System.out.println( ""Finish encryption: "" );
    System.out.println( new String(cipherText, ""UTF8"") );

   //Now writing to an ouput file the cipherText
   try{
       FileOutputStream fs=new FileOutputStream(""c:/test.txt"");
      fs.write(cipherText);
     }catch(Exception e){
       e.printStackTrace();
     }

}
}
</code></pre>
","<p>There is no class, there is just one method. And that method generates a new random key each time you use it. The symmetric key needs to be the same for both encryption and decryption. </p>
","298","<java><encryption><des>","-1","0","2","2014-07-28 04:46:48","","1","2","3857455","","2014-07-20 08:52:09","2014-07-20 08:44:52",""
"9918176","Why does my one decryption method run way faster than another?","<p>I created encryption decryption methods to encrypt images and videos. I'm partially encrypting the videos, 1 MB to be exact.  The more complicated decrypt method take way to long to decrypts the content on the android device. However the img_decrypt doesn take long at all. Not sure why they do.  </p>

<p>here is the one
.This one can decrypt fully encryptes videos or images.  Decrypts full images in ms how ever does not work to decrypt partially encrypted videos.</p>

<pre><code>  public void img_decrypt(InputStream in, OutputStream out) {
    try {
        // Bytes read from in will be decrypted
        in = new CipherInputStream(in, dcipher);

        // Read in the decrypted bytes and write the cleartext to out
        int numRead = 0;


        while ((numRead = in.read(buf)) &gt;= 0 ) {

            out.write(buf, 0, numRead);
        }


        out.close();
    } catch (java.io.IOException e) {
    }
} 
</code></pre>

<p>And here is the other. This takes forever to run. Will decrypt fully encrypted images or partially encrypted videos.</p>

<pre><code>    public void decrypt(InputStream in, OutputStream out) {
    try {
        // Bytes written to out will be decrypted
        AppendableOutputStream out_append = new AppendableOutputStream(out);
        System.out.println(ecipher.getOutputSize(1024*1024));
        OutputStream out_d = new CipherOutputStream(out_append, dcipher);

        // Read in the decrypted bytes and write the cleartext to out
        int numRead = 0;
        int count = 0;
        int max = 1024;
        boolean out_d_closed = false;

        while ((numRead = in.read(buf, 0, max)) &gt; 0) {
            count += numRead;
            if(count &lt;= ecipher.getOutputSize(1024*1024)){
                out_d.write(buf, 0, numRead);
                out_d_closed = false;
                // last encryption pass, close buffer and fix max
                if(count == ecipher.getOutputSize(1024*1024)){
                    // fix reading 1k in case max was decreased
                    max = 1024;
                    out_d.close();
                    out_d_closed = true;
                }
                // if next read will go over a meg, read less than 1k
                else if(count + max &gt; ecipher.getOutputSize(1024*1024))
                    max = ecipher.getOutputSize(1024*1024) - count;
            }
            // past the first meg, don't decrypt
            else{
                out.write(buf, 0, numRead);
            }

        }
        if(!out_d_closed){

            out_d.close();

        }
        out.close();
    } catch (java.io.IOException e) {

        e.printStackTrace();

    }
}
</code></pre>

<p>Because the decrypt() method takes SOOOOOO long to decrypt a 100KB file, the device asks me to abort or wait.</p>

<p>If I use img_decrypt() it works in not time at all. Which to me makes no sense they are doing the same thing.</p>

<p>Im trying to use decrypt() to decrypt the first MB of the video.</p>

<p>On the computer everything works fine.</p>

<p>Any thoughts might be helpful.</p>

<p>Both methods work for decrypting a fully encrypted file, decrypt() take way too long though.</p>

<p>One more thing. decrypt() decrypts the data on the write. img_decrypt() decrypts the data on the read. No idea if that effects anything.</p>

<p>Thanks</p>
","<p>If anyone cares. FilterOutputStream is implemented wrong. Sun wrote the write method wrong. Have to override the write for it to work properly.</p>
","287","<java><android><outputstream><des>","0","0","1","2012-03-29 14:40:30","","5","1","1086377","","2012-03-29 02:10:20","2012-03-29 02:04:29",""
"6397874","Should encryption algorithms like DES be applied on bits or bytes?","<p>I've found some code samples on the internet which are encrypting bytes using CipherInputStream or something...What if I had a file containing like a 1000 bits, how can I apply DES on it?? I'm doing it in java </p>
","<p>Java has no primitive type that allows you access to anything lesser than a byte. You'll therefore need to work on bytes, and not bits in Java.</p>

<blockquote>
  <p>What if I had a file containing like a 1000 bits, how can I apply DES on it?</p>
</blockquote>

<p>Use bytes. The <a href=""http://download.oracle.com/javase/6/docs/api/javax/crypto/Cipher.html#update%28byte%5B%5D%29"" rel=""nofollow"">Cipher.doUpdate</a> and <a href=""http://download.oracle.com/javase/6/docs/api/javax/crypto/Cipher.html#doFinal%28byte%5B%5D%29"" rel=""nofollow"">Cipher.doFinal</a> methods use bytes, rather an array of them. Use a suitable padding scheme to account for any unpadded data.</p>
","287","<java><encryption><des>","-4","1","2","2011-06-19 08:21:33","","3","","","","","2011-06-18 18:02:35",""
"6397874","Should encryption algorithms like DES be applied on bits or bytes?","<p>I've found some code samples on the internet which are encrypting bytes using CipherInputStream or something...What if I had a file containing like a 1000 bits, how can I apply DES on it?? I'm doing it in java </p>
","<p>This is quite a reasonable question, despite the down-votes.</p>

<p>Many encryption modes (such as CBC) require that the input is a multiple of the block size of the underlying cipher (.e.g. 16 bytes for AES or 8 bytes for DES). To achieve this one uses a padding scheme.
Whether you can encrypt a plaintext with an arbitrary bit-length depends on what padding scheme you use.</p>

<p>The most commonly used padding scheme (i.e. PKCS #5 padding) prepends n bytes of value n to the plaintext.
This obviously requires that the plaintext is in bytes. But there are lesser known padding schemes that allow arbitrary inputs. For example, the so called ""bit padding"" appends a single 1 bit to your plaintext and the appends as many 0 bits as necessary until the length of your input is a multiple of the block size of your cipher. For example, the ISO/IEC 9797-1 standard is proposing this.</p>

<p>When deciding, whether you want to support arbitrary bit-lengths in your application you also have to consider the crypto libraries that you want to use. While some crypto algorithms have been standarized to allow inputs of arbitrary sizes in bits, it may not be implemented by your crypto library.
E.g. the hash function SHA-1 is well defined for inputs such as the 4-bit string '0101', but you
might have some trouble finding a library that can actually compute this hash.</p>
","287","<java><encryption><des>","-4","1","2","2011-06-19 08:21:33","","3","","","","","2011-06-18 18:02:35",""
"30712614","DES Encryption and Decryption in PHP","<p>Please help. How do I make an array in encrypt and decrypt?</p>

<pre><code>&lt;?php
    class DES{

        function encrypt($plainText, $cipherKey){
            //plainText
            $result = $this-&gt;toBiner($plainText);
            $result = $this-&gt;InitialPermutation($result);
            //key
            $key = $this-&gt;toBiner($cipherKey);
            $key = $this-&gt;kompresBit($key);
            $arrLeftShift = $this-&gt;LeftShift($key);
            //final
            $result = $this-&gt;keyExpansion($result, $arrLeftShift);
            return $result;
        }

        function decrypt($encryptedText, $cipherKey){
            $key = $this-&gt;toBiner($cipherKey);
            $key = $this-&gt;kompresBit($key);
            $arrLeftShift = $this-&gt;LeftShift($key);

            $result = $this-&gt;reverseKeyExpansion($encryptedText, $arrLeftShift);
            $result = $this-&gt;revInitialPermutation($result);
</code></pre>
","<p>I don't know much on encryption but from what I understand, DES isn't a recommended encryption standard:<a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Data_Encryption_Standard</a></p>

<p>If you're after something more secure, have a look at the question <a href=""https://stackoverflow.com/questions/28814737/encrypting-member-data-with-keyfiles"">here</a> that includes a encryption/decryption functions that work</p>
","286","<php><arrays><des>","-2","1","1","2015-06-11 11:30:54","","1","","3160747","","2015-06-11 11:30:54","2015-06-08 15:00:41",""
"31002848","DES decryption only working when the key is 0s","<p>I'm experiencing a weird behaviour here. Whenever I set the DES key to 0s the decryption works, but if I set the key to anything else then the decryption returns an unreadable string:</p>

<p><strong>Main method:</strong></p>

<pre><code>static void Main(string[] args)     
{
    //Decryption works!
    byte[] key0 = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; 

    //Decryption doesn't work!
    byte[] key1 = new byte[] { 0x00, 0xFF, 0xFF, 0xAF, 0x12, 0x14, 0x15, 0xEC };

    SimpleDES des = new SimpleDES(key1);
    byte[] data = Encoding.ASCII.GetBytes(""12345678"");
    byte[] encrypted = des.Encrypt(data);

    byte[] decrypted = des.Decrypt(encrypted);
    string decryptedString = Encoding.ASCII.GetString(decrypted);

    //Only shows original plaintext if key0 is used.
    Console.WriteLine(""Decrypted string: {0}"", decryptedString);
    Console.ReadKey();
}
</code></pre>

<p><strong>SimpleDES class:</strong></p>

<pre><code>public class SimpleDES
{
    private readonly byte[] IV = new byte[8] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    private byte[] mKey;
    private DESCryptoServiceProvider des;

    public SimpleDES(byte[] aKey)
    {
        if (aKey.Length != 8)
            throw new Exception(""Key size must be 8 bytes"");
        mKey = aKey;
        des = new DESCryptoServiceProvider();
        des.BlockSize = 64;
        des.KeySize = 64;
        des.Padding = PaddingMode.None;
    }

    public byte[] Encrypt(byte[] data)
    {
        if (data.Length != 8)
            throw new Exception(""Data size must be 8 bytes"");

        ICryptoTransform encryptor = des.CreateWeakEncryptor(mKey, IV);
        return encryptor.TransformFinalBlock(data, 0, data.Length);
    }

    public byte[] Decrypt(byte[] data)
    {
        if (data.Length != 8)
            throw new Exception(""Data size must be 8 bytes"");
        ICryptoTransform decryptor = des.CreateWeakDecryptor(mKey, IV);
        return decryptor.TransformFinalBlock(data, 0, data.Length);
    }
}
</code></pre>

<p><strong>DESCryptoExtensions class:</strong></p>

<pre><code>public static class DESCryptoExtensions
{
    public static ICryptoTransform CreateWeakEncryptor(this DESCryptoServiceProvider cryptoProvider, byte[] key, byte[] iv)
    {
        // reflective way of doing what CreateEncryptor() does, bypassing the check for weak keys
        MethodInfo mi = cryptoProvider.GetType().GetMethod(""_NewEncryptor"", BindingFlags.NonPublic | BindingFlags.Instance);
        object[] Par = { key, cryptoProvider.Mode, iv, cryptoProvider.FeedbackSize, 0 };
        ICryptoTransform trans = mi.Invoke(cryptoProvider, Par) as ICryptoTransform;
        return trans;
    }

    public static ICryptoTransform CreateWeakEncryptor(this DESCryptoServiceProvider cryptoProvider)
    {
        return CreateWeakEncryptor(cryptoProvider, cryptoProvider.Key, cryptoProvider.IV);
    }

    public static ICryptoTransform CreateWeakDecryptor(this DESCryptoServiceProvider cryptoProvider, byte[] key, byte[] iv)
    {
        return CreateWeakEncryptor(cryptoProvider, key, iv);
    }

    public static ICryptoTransform CreateWeakDecryptor(this DESCryptoServiceProvider cryptoProvider)
    {
        return CreateWeakDecryptor(cryptoProvider, cryptoProvider.Key, cryptoProvider.IV);
    }
}
</code></pre>

<p><strong>key0 output:</strong>
<img src=""https://i.stack.imgur.com/XRCCf.png"" alt=""enter image description here"">
<strong>key1 output:</strong>
<img src=""https://i.stack.imgur.com/uzZs2.png"" alt=""enter image description here""></p>
","<p>There is a <code>CryptoAPITransformMode</code> parameter in <code>_NewEncryptor</code> (the last one) that you forgot. You put it ""fixed"" at 0, but it can be 0 or 1 (<code>Encrypt</code> or <code>Decrypt</code>). It is internal, but in the end passing an <code>int</code> is ok.</p>

<pre><code>public static class DESCryptoExtensions
{
    // Mode = 0 encrypt, 1 decrypt
    public static ICryptoTransform CreateWeakEncryptor(this DESCryptoServiceProvider cryptoProvider, byte[] key, byte[] iv, int mode = 0)
    {
        // reflective way of doing what CreateEncryptor() does, bypassing the check for weak keys
        MethodInfo mi = cryptoProvider.GetType().GetMethod(""_NewEncryptor"", BindingFlags.NonPublic | BindingFlags.Instance);
        object[] Par = { key, cryptoProvider.Mode, iv, cryptoProvider.FeedbackSize, mode };
        ICryptoTransform trans = mi.Invoke(cryptoProvider, Par) as ICryptoTransform;
        return trans;
    }

    public static ICryptoTransform CreateWeakEncryptor(this DESCryptoServiceProvider cryptoProvider)
    {
        return CreateWeakEncryptor(cryptoProvider, cryptoProvider.Key, cryptoProvider.IV);
    }

    public static ICryptoTransform CreateWeakDecryptor(this DESCryptoServiceProvider cryptoProvider, byte[] key, byte[] iv)
    {
        return CreateWeakEncryptor(cryptoProvider, key, iv, 1);
    }

    public static ICryptoTransform CreateWeakDecryptor(this DESCryptoServiceProvider cryptoProvider)
    {
        return CreateWeakDecryptor(cryptoProvider, cryptoProvider.Key, cryptoProvider.IV);
    }
}
</code></pre>
","284","<c#><encryption><des>","2","2","1","2015-06-23 12:44:01","31003131","3","1","","","","2015-06-23 12:29:25",""
"37704483","DES Encryption from C# to PHP not working as expected","<p>I have to recreate things from c# to php.
I dont really know what to do cuz I never really had to deal with things like encryption or something.</p>

<p>In c# I got this:</p>

<pre><code>public static byte[] decrypt(byte[] data, byte[] key)
    {
        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        des.Key = key;
        des.Mode = CipherMode.ECB;
        des.Padding = PaddingMode.None;

        return des.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
    }

public static byte[] encrypt(byte[] data, byte[] key)
    {
        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        des.Key = key;
        des.Mode = CipherMode.ECB;
        des.Padding = PaddingMode.None;

        return des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
    }

public static byte[] get8byte(string input)
    {
        byte[] ByteArray = new byte[8];
        string tmp = string.Empty;
        int j = 0;
        for (int i = 0; i &lt; 16; i++)
        {
            tmp = """" + input[i];
            tmp = tmp + input[i + 1];
            ByteArray[j] = byte.Parse(tmp, System.Globalization.NumberStyles.HexNumber);
            j++;
            i++;
        }
        return ByteArray;
    }
</code></pre>

<p>and the key i have to use is encrypted like the following:</p>

<pre><code>var Buffer = new char[16];
var cMasterKey = new byte[8];
byte[] Key = {
       (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5',
       (byte) '6', (byte) '7', (byte) '8'
}; 
cMasterKey = DESUtils.get8byte(new string(Buffer));
MasterKey = DESUtils.decrypt(cMasterKey, Key);
</code></pre>

<p>The ""Buffer"" comes from an USB Drive which has a File on it which contains a Masterkey of 16 Chars.
I really don't know how to realize it in PHP. I tried a lot of things like pack('C*', $var) and things like that but I didnt get the same result.
Is there anyone here who knows how to handle it? I dont know if I'm on the right way but I tried things like this:</p>

<pre><code>$key = pack('C*', 1, 2, 3, 4, 5, 6, 7, 8);
$masterbyte = pack('C*', $buffer);
$decmasterkey = mcrypt_decrypt(MCRYPT_DES, $key, $masterbyte, MCRYPT_MODE_ECB);
</code></pre>
","<p><code>'1'</code> in C# is a character literal. Characters can be directly cast to a byte under the default ASCII assumption. So <code>'1'</code> is actually a 0x31 byte and not a 0x01 byte like you have in PHP.</p>

<p>You ""want"":</p>

<pre><code>$key = ""12345678"";
</code></pre>

<p>Whether the decoding of <code>$buffer</code> is correct depends on its content and how you read it.</p>

<hr>

<p>Some notes:</p>

<ul>
<li><p><strong>Don't use DES nowadays.</strong> It's really insecure. AES is a better alternative.</p></li>
<li><p><strong>Never use <a href=""https://crypto.stackexchange.com/q/14487/13022"">ECB mode</a></strong>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like <a href=""https://crypto.stackexchange.com/q/22260/13022"">CBC</a> or <a href=""https://crypto.stackexchange.com/a/2378/13022"">CTR</a>. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p></li>
</ul>
","278","<c#><php><encryption><mcrypt><des>","0","1","1","2016-06-08 14:03:07","","1","","","","","2016-06-08 13:51:38",""
"43883684","Assembly 8086: DES encryption binary shifts","<p>so I working on DES encryption program in assembly 8086 and I got to the part when I have to do the permuted key-k+, split it and then do some shift every iteration.
The problem  is every half of k+ is 28 bits so I can't put the in a var and do ""shl"". How can I solve it?</p>

<p>Thanks in Advance.</p>
","<p><code>RCL r/m, 1</code> or <code>RCR r/m, 1</code> are the instructions to shift several combined registers/variables:</p>

<pre><code>.MODEL small
.STACK

.DATA
    k dd 12345678h      ; 00010010 00110100 01010110 01111000

.CODE
main PROC
    mov ax, @data
    mov ds, ax

    mov ax, k + 0
    mov dx, k + 2

    shl ax, 1           ; Shift out leftmost bit into Carry, shift in 0
    rcl dx, 1           ; Shift in Carry

    mov k + 0, ax       ; 00100100 01101000 10101100 11110000
    mov k + 2, dx


    mov ax, 4C00h
    int 21h
main ENDP

END main
</code></pre>
","277","<assembly><encryption><bit-shift><des><emu8086>","0","2","2","2019-05-15 05:54:53","","0","","","","","2017-05-10 04:37:59",""
"43883684","Assembly 8086: DES encryption binary shifts","<p>so I working on DES encryption program in assembly 8086 and I got to the part when I have to do the permuted key-k+, split it and then do some shift every iteration.
The problem  is every half of k+ is 28 bits so I can't put the in a var and do ""shl"". How can I solve it?</p>

<p>Thanks in Advance.</p>
","<p>What I'm doing is getting to the last byte of the key and I'm using RCL. Then I'm doing it on the byte before, until I get to the first byte. What I am doing is using RCL as normal but then I'm JC and if the carry flag equals 1, use the OR operation on the last byte of the key and turn on the right bit.</p>

<p><img src=""https://i.stack.imgur.com/gy9ie.png"" alt=""enter image description here""></p>
","277","<assembly><encryption><bit-shift><des><emu8086>","0","0","2","2019-05-15 05:54:53","","0","","","","","2017-05-10 04:37:59",""
"42962637","DES implementation","<p>I'm trying to programm the Data Encyption Standard on my own and I'm struggling to Programm the SBoxes. I know there is already a module to encrypt and decrypt with the DES but my teacher asked to programm it myself, so here is what i have:</p>

<pre><code>import random
from re import findall

class DES:
    def __init__(self):
        self. Eingabe=""""
        self.Schluessel=""""
        self.NachrichtBinaer=""""
        self.Bitslinks=""""
        self.Bitsrechts=""""
        self.Teil1=""""
        self.Teil2=""""
        self.Subkey=""""
        self.pcschluessel=""""
        self.subkeyliste=[]
        self.initialpermutation=""""
        self.liste1=[]
        self.Bits48=""""
        self.ausgabesbox=[]
        self.liste2=[]


    def EingabeNachricht(self):
        self.Eingabe=input(""Geben Sie ein Wort ein:"")
        print (""Eingegebenes Wort: "",self.Eingabe)

    def Bitumwandlung(self):
        for i in range(0,len(self.Eingabe)):
            self.NachrichtBinaer=self.NachrichtBinaer+bin(ord(self.Eingabe[i]))
            self.NachrichtBinaer=self.NachrichtBinaer.replace(""b"","""")
        if len(self.NachrichtBinaer)&lt;64:
            self.NachrichtBinaer=self.NachrichtBinaer.rjust(64,""0"")
            self.NachrichtBinaer=""0000000100100011010001010110011110001001101010111100110111101111""
        print (""Nachricht in Binaer: "",self.NachrichtBinaer)

    def Teilen(self):
        self.Bitslinks=self.initialpermutation[:int(len(self.initialpermutation)/2)]
        self.Bitsrechts=self.initialpermutation[int(len(self.initialpermutation)/2):]
        print (""Teil links: "",self.Bitslinks)
        print (""Teil rechts: "",self.Bitsrechts)

    def SchluesselGenerieren(self):
        #self.Schluessel= getrandbits(64)
        self.Schluessel=""0001001100110100010101110111100110011011101111001101111111110001""

    def ippermutation(self):
        ip = [57, 49, 41, 33, 25, 17, 9,1,
        59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5,
        63, 55, 47, 39, 31, 23, 15, 7,
        56, 48, 40, 32, 24, 16, 8,  0,
        58, 50, 42, 34, 26, 18, 10, 2,
        60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6
        ]
        for i in ip:
            self.initialpermutation=self.initialpermutation+self.NachrichtBinaer[i]
        print (""Erste Permutation: "",self.initialpermutation)



    def Expandieren(self):

        ExpandierenTabelle = [
        31,0,1,2,3,4,
        3,4,5,6,7,8,
        7,8,9,10,11,12,
        11,12,13,14,15,16,
        15,16,17,18,19,20,
        9,20,21,22,23,24,
        3,24,25,26,27,28,
        27,28,29,30,31,0]

        for Elemente in ExpandierenTabelle:
            self.Bits48 = self.Bits48 + self.Bitsrechts[Elemente]
        print (""expandiert: "",self.Bits48)

    def XOR(self,wert1,wert2):
        antwort=wert1^wert2
        return antwort

    def SBox(self):
        self.sbox=[
        [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],

        # S2
        [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],

        # S3
        [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],

        # S4
        [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],

        # S5
        [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],

        # S6
        [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],

        # S7
        [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],

        # S8
        [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]
        ]

        for z in range(len(self.sbox)):
            for y in range(len(self.sbox[z])):
                for x in range(len(self.sbox[z][y])):
                    ausserebits=self.liste2[x][z][0]+self.liste2[x][z][-1]
                    innerebits=self.liste2[x][z][1:5]
                    print (""innere: "",innerebits)
                    print (""aussere: "",ausserebits)



    def pc1undteilen(self):
        pc1 = [56,48,40,32,24,16,8,
            0,57,49,41,33,25,17,
            9,1,58,50,42,34,26,
            18,19,2,59,51,43,35,
            62,54,46,38,30,22,14,
            6,61,53,45,37,29,21,
            13,5,60,52,44,36,28,
            20,2,4,27,19,11,3]

        #Subkey = """"

        for j in pc1:
            self.Subkey = self.Subkey+self.Schluessel[j]

        self.Teil1=self.Subkey[:int(len(self.Subkey)/2)]
        self.Teil2=self.Subkey[int(len(self.Subkey)/2):]
        print(""Schluessel64 :"",self.Subkey)
        print(""SchluesselTeil1 :"",self.Teil1)
        print(""SchluesselTeil2 :"",self.Teil2)

    def rotationundpc2(self):
        pc2 = [
        13, 16, 10, 23,  0,  4,
         2, 27, 14,  5, 20,  9,
        22, 18, 11,  3, 25,  7,
        15,  6, 26, 19, 12,  1,
        40, 51, 30, 36, 46, 54,
        29, 39, 50, 44, 32, 47,
        43, 48, 38, 55, 33, 52,
        45, 41, 49, 35, 28, 31]

        rotation = [
        1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]


        k=0
        #schluesselliste

        self.Teil1=list(self.Teil1)
        self.Teil2=list(self.Teil2)
        while k&lt;16:
            #rotation
            u=0
            while u &lt; rotation[k]:
                self.Teil1.append(self.Teil1[0])
                del self.Teil1[0]

                self.Teil2.append(self.Teil2[0])
                del self.Teil2[0]

                self.Teil1="""".join(self.Teil1)
                self.Teil2="""".join(self.Teil2)
                self.subschluessel=self.Teil1+self.Teil2
                print(""Teil1: "",self.Teil1)
                print(""Teil2: "",self.Teil2)
                print (""Subschluessel: "",self.subschluessel)
                self.Teil1=list(self.Teil1)
                self.Teil2=list(self.Teil2)
                u+=1

            #pc2 und erstellung der 16 subkeys
            for index2 in pc2:
                self.subkeyliste.append(self.subschluessel[index2])
            k+=1
        while len(self.subkeyliste)&gt;0:
            self.liste1.append("""".join(self.subkeyliste[0:48]))
            del self.subkeyliste[0:48]
        print (""Subkeyliste: "",self.liste1)

    def sechsbitunterteilung(self):
        for l in range(0,16):
            self.liste2.append(findall(""......"",listenachxor[l]))
        print (""liste2: "",self.liste2)

#objekt der klasse DES wird erstellt
listenachxor=[]
Krypto=DES()

#Schluesselgenerieren
Krypto.SchluesselGenerieren()
Krypto.pc1undteilen()
Krypto.rotationundpc2()

Krypto.EingabeNachricht()
Krypto.Bitumwandlung()
Krypto.ippermutation()
Krypto.Teilen()
Krypto.Expandieren()
for p in range(0,16):
    listenachxor.append(bin(Krypto.XOR(int(Krypto.liste1[p],2),int(Krypto.Bits48,2))))
    listenachxor[p]=listenachxor[p].replace(""b"","""")
print (""listenachxor: "",listenachxor)
Krypto.sechsbitunterteilung()
Krypto.SBox()
</code></pre>

<p>By the way the problem is on this part of the programm, the rest just works fine:  </p>

<pre><code>    for z in range(len(self.sbox)):
        for y in range(len(self.sbox[z])):
            for x in range(len(self.sbox[z][y])):
                ausserebits=self.liste2[x][z][0]+self.liste2[x][z][-1]
                innerebits=self.liste2[x][z][1:5]
                print (""innere: "",innerebits)
                print (""aussere: "",ausserebits)
</code></pre>
","","274","<python-3.x><encryption><des>","0","","0","2017-03-23 06:11:04","","13","1","7753621","","2017-03-23 06:11:04","2017-03-22 21:04:36",""
"43202243","Decrypt DES encrypted String back to plain text","<p>I'm working on DES encryption algorithm. I am able to encrypt the plain text to cipher text, but I failed to decrypt the cipher text back to normal plain text. </p>

<p><strong>What converter I should use?</strong> </p>

<p>Here is my code that used in my encryption method:</p>

<pre><code>public static String encryptString(String src) throws Exception {
    String dst = """";

    SecretKey secret_key = KeyGenerator.getInstance(""DES"").generateKey();
    AlgorithmParameterSpec alogrithm_specs = new IvParameterSpec(initialization_vector);
    encrypt = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
    encrypt.init(Cipher.ENCRYPT_MODE, secret_key, alogrithm_specs);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    CipherOutputStream cout = new CipherOutputStream(baos,encrypt);
    cout.write(src.getBytes());
    cout.flush();               //ByteOutputStream -&gt; Write Encryption Text
    cout.close(); 
    dst = DatatypeConverter.printHexBinary(baos.toByteArray());
    return dst;
}
</code></pre>
","","273","<java><encryption><des>","0","","0","2017-04-07 19:04:40","","3","2","190823","","2017-04-07 19:04:40","2017-04-04 08:41:27",""
"19674071","C# encryption in DES","<p>I have a key which is in hex as <code>1C19D5ED8D88DC40</code> and the data in hex as <code>041164DFFFFE7FF7</code>. </p>

<p>I am supposed to do <strong>DES encryption</strong> to obtain the encrypted value in hex as <code>B652FF1BA23C279B</code>.  i struggled a lot with all possible encrypting methods of DES but couldn't get the exact value. I found it in this <a href=""http://mavroudisv.eu/des/index.php"" rel=""nofollow"">link</a> I passed the binary values of the above hex as input and got the desired. </p>

<p>Help with C# code to get the above value. </p>

<pre><code>    public static string Encrypt(string Data,string Key)
{
    byte[] key = Encoding.ASCII.GetBytes(Key);
    // byte[] iv = Encoding.ASCII.GetBytes(""password"");
    byte[] data = Encoding.ASCII.GetBytes(Data);
    byte[] enc = new byte[0];
    TripleDES tdes = TripleDES.Create();
    //tdes.IV = iv;
    tdes.Key = key;
    tdes.Mode = CipherMode.ECB;
    tdes.Padding = PaddingMode.Zeros;
    ICryptoTransform ict = tdes.CreateEncryptor();
    enc = ict.TransformFinalBlock(data, 0, data.Length);
    return Bin2Hex(enc);

}
// my bin2hex implementation        
static string Bin2Hex(byte[] bin)
{
    StringBuilder sb = new StringBuilder(bin.Length * 2);
    foreach (byte b in bin)
    {
        sb.Append(b.ToString(""x"").PadLeft(2, '0'));
    }
    return sb.ToString();
}
</code></pre>
","","273","<c#><encryption><des>","1","","0","2013-10-30 05:11:03","","4","","2462086","","2013-10-30 05:11:03","2013-10-30 04:47:43",""
"42404347","Migrate String encryption from Ruby to Java","<p>I need to produce the same encrypted string in Java as the one built with the Ruby <a href=""https://github.com/pluginaweek/encrypted_strings/blob/master/lib/encrypted_strings/symmetric_cipher.rb"" rel=""nofollow noreferrer"">encrypted_strings</a> library. I've tried many different ways but my Java code keeps returning a different output, and I'm unable to understand what I'm doing wrong.</p>

<p>Below is the ruby script that produces the desired output that I can't get right in Java. </p>

<pre><code>#!/usr/bin/ruby
require 'encrypted_strings'

data = 'Whackabad'
password = 'bAJLyifeUJUBFWdHzVbykfDmPHtLKLMzViHW9aHGmyTLD8hGYZ'

encrypted_data = data.encrypt(:symmetric, :password =&gt; password)
printf ""Data: #{data}\n""
printf ""Encrypted Data: #{encrypted_data}""
</code></pre>

<p>Output: </p>

<pre><code>Data: Whackabad
Encrypted Data: AEsDXVcgh2jsTjlDgh+REg==
</code></pre>

<p>I had a look at the library, and it seems to be using <code>DES-EDE3-CBC</code> as the default algorithm for encryption. I deduce from here that I should use <code>DESede</code> or <code>TripleDES</code> algorithm and <code>CBC</code> mode. As the padding option, I'm using <code>PKCS5Padding</code> cause the library is calling <code>pkcs5_keyivgen</code>.</p>

<p>Below is the Java code that tries to reproduce the same output unsuccessfully.</p>

<pre><code>package ...

import sun.misc.BASE64Encoder;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;

public class SymmetricDESedeCipher {
    private static final String DATA = ""Whackabad"";
    private static final String key = ""bAJLyifeUJUBFWdHzVbykfDmPHtLKLMzViHW9aHGmyTLD8hGYZ"";
    private static final String ALGORITHM = ""DESede"";
    private static final String XFORM = ""DESede/CBC/PKCS5Padding"";

    private static byte[] iv = new byte[8];

    private static byte[] encrypt(byte[] inpBytes,
                                  SecretKey key, String XFORM) throws Exception {
        Cipher cipher = Cipher.getInstance(XFORM);
        IvParameterSpec ips = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, ips);
        return cipher.doFinal(inpBytes);
    }

    public static void main(String[] unused) throws Exception {
        byte[] keyBytes = key.getBytes();
        DESedeKeySpec desKeySpec = new DESedeKeySpec(keyBytes);
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(ALGORITHM);

        SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);

        byte[] dataBytes = DATA.getBytes();
        byte[] encBytes = encrypt(dataBytes, secretKey, XFORM);

        System.out.println(""Data: "" + DATA);
        System.out.println(""Encrypted Data: "" + new BASE64Encoder().encode(encBytes));
    }
}
</code></pre>

<p>Output</p>

<pre><code>Data: Whackabad
Encrypted Data: ScPTKQBsR9Ni1nJ1tsMaaQ==
</code></pre>

<p>I've seen people encrypting data from Java to be decrypted from Ruby and vice-versa with different algorithms so I think this can be achieved but I can't see what's wrong. Do you have an idea? If so, that'd be of much help! </p>

<p>Thanks </p>
","<p>The first thing to do is to <a href=""https://stackoverflow.com/questions/42420098/how-to-extract-the-iv-vector-generated-by-encrypt-method-from-encrypted-strings"">derive the IV and key</a> from the given password.</p>

<p>From the link above, you will get an encoded IV and KEY that corresponds with <code>""VDiJjncs4ak=""</code> and <code>""s9e42J3PpmQv8n5T8L3zzuFaGdrzK/wU""</code> respectively.
This means that the key and IV vector used in the Java code are wrong as it was said in the comments.</p>

<p>Below is the resulting Java code:</p>

<pre><code>public class SymmetricDESedeCipher {
    private static final String DATA = ""Whackabad"";
    private static final String ALGORITHM = ""DESede"";
    private static final String XFORM = ""DESede/CBC/PKCS5Padding"";
    private static final String KEY = ""s9e42J3PpmQv8n5T8L3zzuFaGdrzK/wU"";
    private static final String IV = ""VDiJjncs4ak="";

    private static byte[] encrypt(String data,
                                  SecretKey key, String XFORM, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance(XFORM);
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
        return cipher.doFinal(data.getBytes());
    }

    public static void main(String[] unused) throws Exception {
        DESedeKeySpec spec = new DESedeKeySpec(new BASE64Decoder().decodeBuffer(KEY));
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(ALGORITHM);
        SecretKey secretKey = secretKeyFactory.generateSecret(spec);

        byte[] encBytes = encrypt(DATA, secretKey, XFORM,  new BASE64Decoder().decodeBuffer(IV));

        System.out.println(""Data: "" + DATA);
        System.out.println(""Encrypted Data: "" + new BASE64Encoder().encode(encBytes));
    }
}
</code></pre>

<p>Output: </p>

<pre><code>Data: Whackabad
Encrypted Data: AEsDXVcgh2jsTjlDgh+REg==
</code></pre>
","272","<java><ruby><encryption><des>","1","1","1","2019-04-28 13:40:58","42798372","11","4","1045346","","2019-04-28 13:40:58","2017-02-22 23:35:19",""
"22648953","AES Key From File Trouble","<p>Program is running now. It runs but then crashes. In my files folder it creates an encrypted file but it is blank. It also does not produce a decrypted file at all. I also changed the bit size to 128. What else I am missing in order to properly implement AES?</p>

<p>This is the modified program</p>

<pre><code>import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.Cipher;

import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
import java.security.InvalidAlgorithmParameterException;

import javax.crypto.NoSuchPaddingException;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;





import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.DESKeySpec;

public class MyCiphers {

    public static void main(String[] args) {
        try {



            BufferedReader br = new BufferedReader(new FileReader(""key.txt""));
            String key = br.readLine();
            br.close();
            FileInputStream fis = new FileInputStream(""original.txt"");
            FileOutputStream fos = new FileOutputStream(""encrypted.txt"");
            encrypt(key, fis, fos);

            FileInputStream fis2 = new FileInputStream(""encrypted.txt"");
            FileOutputStream fos2 = new FileOutputStream(""decrypted.txt"");
            decrypt(key, fis2, fos2);

        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    public static void encrypt(String key, InputStream is, OutputStream os) throws Throwable {
        encryptOrDecrypt(key, Cipher.ENCRYPT_MODE, is, os);
    }

    public static void decrypt(String key, InputStream is, OutputStream os) throws Throwable {
        encryptOrDecrypt(key, Cipher.DECRYPT_MODE, is, os);
    }

    public static void encryptOrDecrypt(String key, int mode, InputStream is, OutputStream os) throws Throwable {


      SecretKeySpec dks = new SecretKeySpec(key.getBytes(),""AES"");
        Cipher cipher = Cipher.getInstance(""AES""); 

        if (mode == Cipher.ENCRYPT_MODE) {
            cipher.init(Cipher.ENCRYPT_MODE, dks);
            CipherInputStream cis = new CipherInputStream(is, cipher);
            doCopy(cis, os);        
        } else if (mode == Cipher.DECRYPT_MODE) {
            cipher.init(Cipher.DECRYPT_MODE, dks);
            CipherOutputStream cos = new CipherOutputStream(os, cipher);
            doCopy(is, cos);
        }


    }

    public static void doCopy(InputStream is, OutputStream os) throws IOException {
        byte[] bytes = new byte[128];
        int numBytes;
        while ((numBytes = is.read(bytes)) != -1) {
            os.write(bytes, 0, numBytes);
        }
        os.flush();
        os.close();
        is.close();
    }

}
</code></pre>
","<p>As the error message says, there is no method getBytes() for the type InputStream.
You need to read the key and store it as a String. </p>

<p>eg. 
rather than <code>FileInputStream fisk ...</code> do</p>

<pre><code>BufferedReader br = new BufferedReader(new FileReader(""Key.txt""));
String key = br.readLine();
br.close();
</code></pre>

<p>(assuming that your key file just contains the key on one line)</p>

<p>Then change your encrypt/decrypt and encryptOrDecrypt methods to take in the key as a <code>String</code> rather than <code>InputStream</code>
eg. <code>encrypt(String key, InputStream is, OutputStream os)</code></p>

<p>Then you can call <code>SecretKeySpec(key.getBytes(),""DES"");</code></p>

<p>Also you realise that this is DES, not AES as you say right? If you want to use AES you will need a <strong>128</strong> bit key (or 192/256 bits)</p>
","265","<java><encryption><aes><des>","-1","0","1","2014-03-26 03:54:01","","0","2","3294617","","2014-03-26 03:54:01","2014-03-26 00:10:56",""
"13919099","TCL des: Return encrypted phrase in standard ascii characters","<p>I'm using DES in TCL to encrypt some phrases and I want to store those encrypted phrases in some ascii files which I need to manipulate easily. Therefore, I would like the ""encrypted phrase"" to be constituted only of standard ascii characters (preferentially with no spaces).</p>

<p>I'm using something like this to ecrypt:</p>

<pre><code>set encrypted [ DES:des -dir encrypt -key ""abcdefgh"" ""This_phrase"" ]
</code></pre>

<p>I would like ""encrypted"" to be a standard ascii code, not something that,
as it happens, may even brake my terminal if displayed.</p>

<p>Thank you very much.
Leandro.</p>
","<p>You could either replace all characters that might have a special meaning (everything except a-zA-Z0-9 etc) or encode it with e.g. base64.</p>

<pre><code>set encrypted [base64::encode -wrapchar {} [DES:des -dir encrypt -key abcdefgh ""This_phrase""]]
</code></pre>

<p>You need to strip the extra layer (base64, escape sequence encoding or whatever you used to convert the binary data to ascii) if you want to decode it.</p>
","265","<encryption><ascii><tcl><des>","2","5","1","2012-12-17 23:27:07","13919453","0","","301832","","2012-12-17 23:27:07","2012-12-17 17:34:38",""
"45280204","En/Decryption using Perl Crypt::CBC leads to missing bytes at the end","<p>i am trying to encrypt and then decrypt a file using Crypt::CBC in perl. When decrypting my ciphertext after encrypting it, i am missing some bytes at the end of my recovered plaintext. </p>

<p>encryption method:</p>

<pre><code>#!/usr/bin/perl

use 5.24.0;
use warnings;
use Crypt::CBC;

my $cipher;
my $buffer;

   $cipher = Crypt::CBC-&gt;new( {'key'             =&gt; 'abcdefgh',
                               'literal_key'     =&gt; 1, 
                     # 'cipher'          =&gt; 'Blowfish',
                              'iv'              =&gt; '01234567',
                           #   'regenerate_key'  =&gt; 0,   # default true
                              'padding'         =&gt; 'standard',
                              'prepend_iv'      =&gt; 0,
                              'blocksize'       =&gt; 8
                           });

$cipher-&gt;start('encrypting');
open(F,""./plaintext.txt"");
open(STDOUT,""&gt;ciphertext.txt"");
  while (sysread(F,$buffer,1024)) {
      print $cipher-&gt;crypt($buffer);
  }
close STDOUT;
</code></pre>

<p>my plaintext looks like this:</p>

<p><img src=""https://i.stack.imgur.com/wAXO9.jpg"" alt=""plaintext before""></p>

<p>then i decrypt my ciphertext with:</p>

<pre><code>#!/usr/bin/perl
# # entschlüsselt eine datei, http://www.perlmonks.org/?node_id=252460

use 5.24.0;
use warnings;
use Crypt::CBC;

my $cipher;
my $buffer;

   $cipher = Crypt::CBC-&gt;new( {'key'             =&gt; 'abcdefgh',
                              'literal_key'     =&gt; 1, 
                              #'cipher'          =&gt; 'Blowfish',
                              'iv'              =&gt; '01234567',
                            #  'regenerate_key'  =&gt; 0,   # default true
                              'padding'         =&gt; 'standard',
                              'prepend_iv'      =&gt; 0,
                              'blocksize'       =&gt; 8
                           });

$cipher-&gt;start('decrypting');
open(F,""./ciphertext.txt"")
  while (sysread(F,$buffer,1024)) {
      print $cipher-&gt;crypt($buffer);

  }
close STDOUT;
</code></pre>

<p>and the plaintext afterwards:</p>

<p><img src=""https://i.stack.imgur.com/Tc6Yq.jpg"" alt=""plaintext after""></p>
","<p>You’re missing a call to <a href=""http://search.cpan.org/~lds/Crypt-CBC/CBC.pm#finish()"" rel=""nofollow noreferrer""><code>$cipher-&gt;finish;</code></a> after the loop, for both encrypting and decrypting, so you’re cutting of part of the last block in both cases.</p>

<blockquote>
  <p>The CBC algorithm must buffer data blocks internally until they are even multiples of the encryption algorithm's blocksize (typically 8 bytes). After the last call to crypt() you should call finish(). This flushes the internal buffer and returns any leftover ciphertext.</p>
</blockquote>

<p>You need something like this:</p>

<pre><code>while (sysread(F,$buffer,1024)) {
    print $cipher-&gt;crypt($buffer);
}
print $cipher-&gt;finish;
</code></pre>

<hr>

<p>(You’re also missing a semicolon at the end of the <code>open</code> line in your decryption code.)</p>
","263","<perl><encryption><file-handling><des>","1","2","1","2017-07-24 15:11:08","45284150","7","","2612002","","2017-07-24 12:09:32","2017-07-24 12:05:12",""
"31204949","48-bit string of eight 6-bit units: how to get middle 4 bits of each unit quickly","<p>I have nearly implemented DES algorithm with C language, and I want to optimize my code. So I used <code>gprof</code>.
Here is part of the report:</p>

<pre><code>Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  us/call  us/call  name    
 51.78      9.32     9.32  8000000     1.17     1.17  sboxes
 34.71     15.57     6.25  8000000     0.78     0.78  extendRight
  9.90     17.35     1.78   500000     3.56    35.96  operation
  2.39     17.78     0.43  8000000     0.05     0.05  xorRightAndKey
</code></pre>

<p><code>gprof</code> shows that <code>sboxes</code> function occupied <strong>51.78%</strong> of the time.</p>

<p>In <code>sboxes(uchar aucData[6], ...)</code>, I was given 48 bits, split them into 8 slot, each slot of 6 bits.</p>

<p>for each slot:</p>

<ol>
<li><p>combine first bit with last bit to get <code>X</code>;</p></li>
<li><p>obtain middle 4 bit to get <code>Y</code>;</p></li>
<li><p>do something with <code>(X, Y)</code>;</p></li>
</ol>

<p>For example, <code>011110</code> is a slot, so <code>X = 00</code> and <code>Y = 1111</code>.</p>

<p>To implement this, I wrote MACRO to GET/SET bit in memory, here is relative code:</p>

<pre><code>#define LOCATE(ptr, index) (((char *)(ptr))[(index) &gt;&gt; 3])

#define GET_BIT(ptr, index) (LOCATE((ptr), (index)) &amp; (((uchar)0x80) &gt;&gt; ((index) % 8)))
</code></pre>

<p>And here is the code to get <code>(X, Y)</code></p>

<pre><code>uchar basePos = 0x00;
for (int i = 0; i &lt; 8; ++i) {
    x = 0;
    y = 0;
    basePos = i * 6; // to locate the slot
    // combine first bit with last bit 
    if (0 != GET_BIT(aucData, basePos)) {
        x |= 0x02;
    }   
    if (0 != GET_BIT(aucData, basePos + 5)) {
        x |= 0x01;
    }   
    // get continuous 4 bits
    for (int j = 1; j &lt;= 4; ++j) {
        if (0 != GET_BIT(aucData, basePos + j)) {
            y |= (0x01 &lt;&lt; (4 - j));
        }   
    }   
    // do something with (x, y)
}
</code></pre>

<p>So my question is, I was given 48 bits, how to get the middle 4 bits as fast as possible?</p>
","<p>Without lookup table:</p>

<pre><code>typedef unsigned long long u64;

void sboxes(uchar aucData[6])
{
    u64 v = aucData[0] + (((u64)aucData[1]) &lt;&lt; 8)
    + (((u64)aucData[2]) &lt;&lt; 16)
    + (((u64)aucData[3]) &lt;&lt; 24)
    + (((u64)aucData[4]) &lt;&lt; 32)
    + (((u64)aucData[5]) &lt;&lt; 40);

    for(int i = 0; i &lt; 8; i++) 
    {
        uchar x = ((v &amp; 1) &lt;&lt; 1) | ((v &gt;&gt; 5) &amp; 1);
        uchar y = ((v &gt;&gt; 1) &amp; 0xF);
        // do something with x, y
        printf(""x: %hhu, y: %hhu\n"", x, y);

        v &gt;&gt;= 6;
    }
}
</code></pre>

<p>Full disclaimer: I didn't benchmark. But it should be fast. You may be able to do the packing into u64 faster, if it's still too slow.</p>
","260","<c><algorithm><assembly><des>","5","4","1","2015-07-03 12:02:50","31205923","8","1","212858","","2015-07-03 12:02:50","2015-07-03 10:47:44",""
"40065197","Java DES Wrong Encryption","<p>I have coded DES in Java using builtin Libraries but I am not getting the right Encryption Result. Please explain me where I am making a mistake</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.xml.bind.DatatypeConverter;

public class MainClass {

    public static void main(String[] args) {

        String l = ""0e329232ea6d0d73"";

        byte[] a = DatatypeConverter.parseHexBinary(l);

        try{
            DESKeySpec dks = new DESKeySpec(a);
            SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
            SecretKey sk = skf.generateSecret(dks);
        Cipher c = Cipher.getInstance(""DES"");
        c.init(Cipher.ENCRYPT_MODE, sk);
        String M = ""8787878787878787"";
        byte[] b = c.doFinal(M.getBytes());

        System.out.println(new String(b));
        c.init(Cipher.DECRYPT_MODE, sk);
        System.out.println(new String(c.doFinal(b)));
        }
        catch(Exception e)

        {
            System.out.println(e.getMessage());
        }   
    }

}
</code></pre>

<p>HexaDecimal 16 Digit Key: 0e329232ea6d0d73 <br>
Plain Text: 8787878787878787<br>
Encryption : –m^MúÊ'+–m^MúÊ'+©ôËÓ—<br></p>

<p>Desired Encryption: 0000000000000000</p>

<p>This is what I am saying the answer in the encrypted output in online calculator is 0000, and mine is completely different:</p>

<p><a href=""https://i.stack.imgur.com/fEM02.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/fEM02.png"" alt=""Image""></a></p>
","<p>The data is: hex <code>8787878787878787</code> and needs to be converted to binary.
`</p>
","260","<java><encryption><des>","0","1","3","2016-10-16 22:54:53","40065436","17","2","472495","","2016-10-16 22:54:53","2016-10-15 23:15:56",""
"40065197","Java DES Wrong Encryption","<p>I have coded DES in Java using builtin Libraries but I am not getting the right Encryption Result. Please explain me where I am making a mistake</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.xml.bind.DatatypeConverter;

public class MainClass {

    public static void main(String[] args) {

        String l = ""0e329232ea6d0d73"";

        byte[] a = DatatypeConverter.parseHexBinary(l);

        try{
            DESKeySpec dks = new DESKeySpec(a);
            SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
            SecretKey sk = skf.generateSecret(dks);
        Cipher c = Cipher.getInstance(""DES"");
        c.init(Cipher.ENCRYPT_MODE, sk);
        String M = ""8787878787878787"";
        byte[] b = c.doFinal(M.getBytes());

        System.out.println(new String(b));
        c.init(Cipher.DECRYPT_MODE, sk);
        System.out.println(new String(c.doFinal(b)));
        }
        catch(Exception e)

        {
            System.out.println(e.getMessage());
        }   
    }

}
</code></pre>

<p>HexaDecimal 16 Digit Key: 0e329232ea6d0d73 <br>
Plain Text: 8787878787878787<br>
Encryption : –m^MúÊ'+–m^MúÊ'+©ôËÓ—<br></p>

<p>Desired Encryption: 0000000000000000</p>

<p>This is what I am saying the answer in the encrypted output in online calculator is 0000, and mine is completely different:</p>

<p><a href=""https://i.stack.imgur.com/fEM02.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/fEM02.png"" alt=""Image""></a></p>
","<p>The input to that online calculator is stated to be hex, which implies a data convertion. You aren't doing any hex conversion in your code: you're just providing base-10 digits in ASCII.</p>
","260","<java><encryption><des>","0","0","3","2016-10-16 22:54:53","40065436","17","2","472495","","2016-10-16 22:54:53","2016-10-15 23:15:56",""
"40065197","Java DES Wrong Encryption","<p>I have coded DES in Java using builtin Libraries but I am not getting the right Encryption Result. Please explain me where I am making a mistake</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.xml.bind.DatatypeConverter;

public class MainClass {

    public static void main(String[] args) {

        String l = ""0e329232ea6d0d73"";

        byte[] a = DatatypeConverter.parseHexBinary(l);

        try{
            DESKeySpec dks = new DESKeySpec(a);
            SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
            SecretKey sk = skf.generateSecret(dks);
        Cipher c = Cipher.getInstance(""DES"");
        c.init(Cipher.ENCRYPT_MODE, sk);
        String M = ""8787878787878787"";
        byte[] b = c.doFinal(M.getBytes());

        System.out.println(new String(b));
        c.init(Cipher.DECRYPT_MODE, sk);
        System.out.println(new String(c.doFinal(b)));
        }
        catch(Exception e)

        {
            System.out.println(e.getMessage());
        }   
    }

}
</code></pre>

<p>HexaDecimal 16 Digit Key: 0e329232ea6d0d73 <br>
Plain Text: 8787878787878787<br>
Encryption : –m^MúÊ'+–m^MúÊ'+©ôËÓ—<br></p>

<p>Desired Encryption: 0000000000000000</p>

<p>This is what I am saying the answer in the encrypted output in online calculator is 0000, and mine is completely different:</p>

<p><a href=""https://i.stack.imgur.com/fEM02.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/fEM02.png"" alt=""Image""></a></p>
","<p>Change </p>

<p><code>byte[] b = c.doFinal(M.getBytes());</code> </p>

<p>to </p>

<p><code>byte[] b = c.doFinal(DatatypeConverter.parseHexBinary(M));</code></p>

<p>Besides, use mode ECB in your code (because you marked ECB in your picture). Like:</p>

<pre><code>Cipher c = Cipher.getInstance(""DES/ECB/NoPadding"");
</code></pre>

<p>The <a href=""https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#getBytes()"" rel=""nofollow"">String.getBytes()</a> encodes the String into a sequence of bytes using the platform's default charset, storing the result into a new byte array. In your case which is an array of length 16 containing values <code>56 55 56 55...</code> <a href=""http://www.asciitable.com/"" rel=""nofollow"">ASCII</a> representation of <code>8787...</code></p>

<p>What you need is converting the Hex <code>8787...</code> to binary. </p>
","260","<java><encryption><des>","0","1","3","2016-10-16 22:54:53","40065436","17","2","472495","","2016-10-16 22:54:53","2016-10-15 23:15:56",""
"38459489","Strange DES behavior - decryption is successful using different keys","<p>Occasionally, I meet an interesting, strange thing: same block of encrypted text can be decrypted using several different key!</p>

<p>Can anyone please indicate me what's going wrong? Thanks a lot.</p>

<p>Please don't try to let me switch to triple DES/AES etc, I just want to know where the problem is - the way calling the Java SDK, or the bug in Java SDK?</p>

<p>Below is output on Windows 7, same result in Linux box:</p>

<pre><code>D:\&gt;java -version
java version ""1.7.0_21""
Java(TM) SE Runtime Environment (build 1.7.0_21-b11)
Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)

D:\&gt;java DESTest -e 12345678 abcde977

encrypted as [17fd146fa6fdbb5db667efe657dfcb60]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde977

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde976

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde967

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde867

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcdf867
Exception in thread ""main"" java.lang.RuntimeException: javax.crypto.BadPaddingEx
ception: Given final block not properly padded
        at DESTest.des(DESTest.java:46)
        at DESTest.dec(DESTest.java:31)
        at DESTest.main(DESTest.java:19)
Caused by: javax.crypto.BadPaddingException: Given final block not properly padd
ed
        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
        at com.sun.crypto.provider.DESCipher.engineDoFinal(DESCipher.java:314)
        at javax.crypto.Cipher.doFinal(Cipher.java:2087)
        at DESTest.des(DESTest.java:44)
        ... 2 more

D:\&gt;java DESTest -e 12345678 abcde976

encrypted as [17fd146fa6fdbb5db667efe657dfcb60]

D:\&gt;java DESTest -e 12345678 abcde967

encrypted as [17fd146fa6fdbb5db667efe657dfcb60]

D:\&gt;
</code></pre>

<p>The source code:</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;

public class DESTest {
    public static void main(String[] args) {
        if (args.length &lt; 3) {
            System.out.println(""usage: java "" + DESTest.class.getCanonicalName() + "" -e|-d text key"");
            return;
        }
        String mode = args[0].trim();
        String text = args[1].trim();
        String key = args[2].trim();
        try {
            String s = ""-d"".equalsIgnoreCase(mode) ? dec(text, key) : enc(text, key);
            System.out.println(""\n"" + (""-d"".equalsIgnoreCase(mode) ? ""decryted as ["" : ""encrypted as ["") + s + ""]"");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

    private static String enc(String plainText, String key) throws UnsupportedEncodingException {
        return new String(encHex(des(plainText.getBytes(""UTF-8""), key, Cipher.ENCRYPT_MODE)));
    }

    private static String dec(String encrypted, String key) throws UnsupportedEncodingException {
        return new String(des(decHex(encrypted), key, Cipher.DECRYPT_MODE), ""UTF-8"");
    }

    private static byte[] des(byte[] bytes, String key, int cipherMode) {
        final String encoding = ""UTF-8"";
        try {
            DESKeySpec desKey = new DESKeySpec(key.getBytes(encoding));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
            SecretKey securekey = keyFactory.generateSecret(desKey);
            // SecretKey securekey = new SecretKeySpec(key.getBytes(encoding), ""DES"");//same result as the 3 lines above
            Cipher cipher = Cipher.getInstance(""DES"");
            SecureRandom random = new SecureRandom();
            cipher.init(cipherMode, securekey, random);
            return cipher.doFinal(bytes);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static final char[] HEX_CHARS = ""0123456789abcdef"".toCharArray();

    private static String encHex(byte[] bytes) {
        final char[] chars = new char[bytes.length * 2];
        for (int i = 0, j = 0; i &lt; bytes.length; i++) {
            chars[j++] = HEX_CHARS[(0xF0 &amp; bytes[i]) &gt;&gt;&gt; 4];
            chars[j++] = HEX_CHARS[0x0F &amp; bytes[i]];
        }
        return new String(chars);
    }

    private static byte[] decHex(String hex) {
        final int len = hex.length();
        final byte[] bytes = new byte[len / 2];
        for (int i = 0, j = 0; j &lt; len; i++) {
            int f = Character.digit(hex.charAt(j), 16) &lt;&lt; 4;
            j++;
            f = f | Character.digit(hex.charAt(j), 16);
            j++;
            bytes[i] = (byte) (f &amp; 0xFF);
        }
        return bytes;
    }
}
</code></pre>
","<p>The DES operation (both encryption and decryption) ignores the lsbit of each byte of the key. That is, if you flip any of the lsbits within the key, the operation remains the same. That's what is happening in the keys you tried: the ASCII code for space is 0x20, while the ASCII code for ! is 0x21; they differ only in the lsbit. So, if the key has a byte with the ASCII code for a space, you could replace it with a !, and it'll still be able to decrypt. Similarly, the ASCII code for * is 0x2a, while the ASCII code for + is 0x2b; also differs only in the lsbit.</p>

<p>In the original DES standard, the lsbit was supposed to be used as a parity check bit (with each byte always having odd parity). It was supposed to be a weak error check for manually entered keys. Nowadays, no one does this parity check, and so the lsbit gets ignored.</p>

<p>Extracted from <a href=""https://crypto.stackexchange.com/users/452/poncho"">Poncho's</a> insightful <a href=""https://crypto.stackexchange.com/a/31005"">Answer</a> on <a href=""https://crypto.stackexchange.com/questions/31004/does-des-support-different-keys-that-lead-to-the-same-result"">Cryptography Stackexchange</a>. </p>
","255","<java><encryption><des>","5","4","2","2016-07-19 14:31:02","38460527","1","2","5969411","","2016-07-19 13:52:40","2016-07-19 13:05:06",""
"38459489","Strange DES behavior - decryption is successful using different keys","<p>Occasionally, I meet an interesting, strange thing: same block of encrypted text can be decrypted using several different key!</p>

<p>Can anyone please indicate me what's going wrong? Thanks a lot.</p>

<p>Please don't try to let me switch to triple DES/AES etc, I just want to know where the problem is - the way calling the Java SDK, or the bug in Java SDK?</p>

<p>Below is output on Windows 7, same result in Linux box:</p>

<pre><code>D:\&gt;java -version
java version ""1.7.0_21""
Java(TM) SE Runtime Environment (build 1.7.0_21-b11)
Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)

D:\&gt;java DESTest -e 12345678 abcde977

encrypted as [17fd146fa6fdbb5db667efe657dfcb60]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde977

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde976

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde967

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcde867

decryted as [12345678]

D:\&gt;java DESTest -d 17fd146fa6fdbb5db667efe657dfcb60 abcdf867
Exception in thread ""main"" java.lang.RuntimeException: javax.crypto.BadPaddingEx
ception: Given final block not properly padded
        at DESTest.des(DESTest.java:46)
        at DESTest.dec(DESTest.java:31)
        at DESTest.main(DESTest.java:19)
Caused by: javax.crypto.BadPaddingException: Given final block not properly padd
ed
        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
        at com.sun.crypto.provider.DESCipher.engineDoFinal(DESCipher.java:314)
        at javax.crypto.Cipher.doFinal(Cipher.java:2087)
        at DESTest.des(DESTest.java:44)
        ... 2 more

D:\&gt;java DESTest -e 12345678 abcde976

encrypted as [17fd146fa6fdbb5db667efe657dfcb60]

D:\&gt;java DESTest -e 12345678 abcde967

encrypted as [17fd146fa6fdbb5db667efe657dfcb60]

D:\&gt;
</code></pre>

<p>The source code:</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;

public class DESTest {
    public static void main(String[] args) {
        if (args.length &lt; 3) {
            System.out.println(""usage: java "" + DESTest.class.getCanonicalName() + "" -e|-d text key"");
            return;
        }
        String mode = args[0].trim();
        String text = args[1].trim();
        String key = args[2].trim();
        try {
            String s = ""-d"".equalsIgnoreCase(mode) ? dec(text, key) : enc(text, key);
            System.out.println(""\n"" + (""-d"".equalsIgnoreCase(mode) ? ""decryted as ["" : ""encrypted as ["") + s + ""]"");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

    private static String enc(String plainText, String key) throws UnsupportedEncodingException {
        return new String(encHex(des(plainText.getBytes(""UTF-8""), key, Cipher.ENCRYPT_MODE)));
    }

    private static String dec(String encrypted, String key) throws UnsupportedEncodingException {
        return new String(des(decHex(encrypted), key, Cipher.DECRYPT_MODE), ""UTF-8"");
    }

    private static byte[] des(byte[] bytes, String key, int cipherMode) {
        final String encoding = ""UTF-8"";
        try {
            DESKeySpec desKey = new DESKeySpec(key.getBytes(encoding));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
            SecretKey securekey = keyFactory.generateSecret(desKey);
            // SecretKey securekey = new SecretKeySpec(key.getBytes(encoding), ""DES"");//same result as the 3 lines above
            Cipher cipher = Cipher.getInstance(""DES"");
            SecureRandom random = new SecureRandom();
            cipher.init(cipherMode, securekey, random);
            return cipher.doFinal(bytes);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static final char[] HEX_CHARS = ""0123456789abcdef"".toCharArray();

    private static String encHex(byte[] bytes) {
        final char[] chars = new char[bytes.length * 2];
        for (int i = 0, j = 0; i &lt; bytes.length; i++) {
            chars[j++] = HEX_CHARS[(0xF0 &amp; bytes[i]) &gt;&gt;&gt; 4];
            chars[j++] = HEX_CHARS[0x0F &amp; bytes[i]];
        }
        return new String(chars);
    }

    private static byte[] decHex(String hex) {
        final int len = hex.length();
        final byte[] bytes = new byte[len / 2];
        for (int i = 0, j = 0; j &lt; len; i++) {
            int f = Character.digit(hex.charAt(j), 16) &lt;&lt; 4;
            j++;
            f = f | Character.digit(hex.charAt(j), 16);
            j++;
            bytes[i] = (byte) (f &amp; 0xFF);
        }
        return bytes;
    }
}
</code></pre>
","<p>DES has a 56-bit key, the lsbit of each key byte was initiallly used for parity, now it is ignored.</p>

<p>The answer is: do not use DES! DES is insecure and has been superceeded by AES (Advanced Encryption Standard) AES was specifically designed to replace DES.</p>

<p>Further one should not use a character string as a key, the best practice is to derive an encryption key from the character string with a function such as PBKDF2 (Password Based Key Derivation Function).</p>
","255","<java><encryption><des>","5","1","2","2016-07-19 14:31:02","38460527","1","2","5969411","","2016-07-19 13:52:40","2016-07-19 13:05:06",""
"24600721","Java: StreamCorruptedException occur when Decrypt object with DES","<p>I have two method for Encrypt-save and decrypt-load Object from file in Android Internal Storage. </p>

<p>Encrypt and save process is done without any problem, but when I want to load the object <code>StreamCorruptedException</code> occurs in <code>inputStream = new ObjectInputStream(cipherInputStream);</code></p>

<p>I searched SO more and more but I did't find a solution for my problem. all other solutions are for socket life or like this.</p>

<p>my code is below:</p>

<pre><code>private static byte[] iv = { (byte) 0xB1, (byte) 0x15, (byte) 0xB5,
        (byte) 0xB7, (byte) 0x66, (byte) 0x43, (byte) 0x2F, (byte) 0xA4,
        (byte) 0xB1, (byte) 0x15, (byte) 0x35, (byte) 0xC7, (byte) 0x66,
        (byte) 0x58, (byte) 0x2F, (byte) 0x5F };
</code></pre>

<p>save method: (work well)</p>

<pre><code>private static String saveToFile(Serializable object, String fileName,
        Context ctx) {
    try {
        Cipher cipher = null;
        cipher = Cipher.getInstance(""DES"");
        SecretKey key = KeyGenerator.getInstance(""DES"").generateKey();
        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);

        cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
        SealedObject sealedObject = null;
        sealedObject = new SealedObject(object, cipher);
        CipherOutputStream cipherOutputStream = null;

        FileOutputStream fos = ctx.openFileOutput(fileName,
                Context.MODE_PRIVATE);
        cipherOutputStream = new CipherOutputStream(
                new BufferedOutputStream(fos), cipher);
        ObjectOutputStream outputStream = null;
        outputStream = new ObjectOutputStream(cipherOutputStream);
        outputStream.writeObject(sealedObject);
        outputStream.close();

        return ""Save Complete!"";

    } catch (IOException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
        return e.getMessage();
    }
}
</code></pre>

<p>Load method: (can't load object from <code>cipherInputStream</code>)</p>

<pre><code>private static Serializable loadFromFile(String fileName, Context ctx) {
    Cipher cipher = null;
    Serializable userList = null;
    try {
        cipher = Cipher.getInstance(""DES"");

        // Code to write your object to file
        SecretKey key = KeyGenerator.getInstance(""DES"").generateKey();
        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);

        cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
        CipherInputStream cipherInputStream = null;

        FileInputStream fos = ctx.openFileInput(fileName);
        cipherInputStream = new CipherInputStream(new BufferedInputStream(
                fos), cipher);

        ObjectInputStream inputStream = null;
        inputStream = new ObjectInputStream(cipherInputStream);
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        SealedObject sealedObject = null;
        sealedObject = (SealedObject) inputStream.readObject();
        userList = (Serializable) sealedObject.getObject(cipher);
        inputStream.close();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (StreamCorruptedException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (IOException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
        return e.getMessage();
    } catch (BadPaddingException e) {
        e.printStackTrace();
        return e.getMessage();
    }
    return userList;
}
</code></pre>

<p>public methods for save and load:</p>

<pre><code>public Serializable loadPlayer(Context ctx) {
    return loadFromFile(""player.dat"", ctx);
}

public String savePlayer(Player player, Context ctx) {
    return saveToFile(player, ""player.dat"", ctx);

}
</code></pre>
","<p>You're making at least two major mistakes.</p>

<ol>
<li><p>You have to use the same key to decrypt as you used to encrypt. You can't just generate a random key and except it to be able to decrypt anything. Cryptology isn't magic. You will have to arrange for the decryption key to be preserved somehow, transmitted if necessary, <em>securely,</em> and used at the decryption step.</p></li>
<li><p>You're encrypting once with the <code>SealedObject</code> and again with the <code>CipherOutputStream</code>; then in the reverse direction you're decrypting once with the <code>CipherInputStream</code> and again via the <code>SealedObject</code>. This won't actually work, because the <code>Cipher</code> object isn't in comparable states at sender and receiver, and in any case it's pointless. Lose either the SealedObject or the Cipher streams.</p></li>
</ol>
","254","<java><android><encryption><des>","0","0","1","2017-12-18 05:43:34","24622526","6","3","","","","2014-07-06 22:02:28",""
"26214041","Data type for blocks in DES-like algorithm in Java","<p>I am writing a DES-like block cipher in Java. The cipher works with 64-bit blocks and I'm having a tough time deciding how to partition the data so that its useable. In case your wondering the data will be coming from a file and I'm just going to pad it with zeroes until the nearest multiple of 64. Here's what I've been thinking about.</p>

<p><strong>Store an array of longs.</strong><br>
With an array of longs I can traverse over each block in the fewest amount of steps. But, will the logical operations, like XOR, work properly? Also when I have to split the 64-bit into 32-bits should I convert to ints or just keep using longs? And then there is the sign to worry about, but I think I could use the Long class to fix that.</p>

<p><strong>Store an array of byte arrays.</strong><br>
This was my initial idea, but I'm seeing the limitations now. I would have to work with 8 elements per array rather than just one with the array of longs. This might not even matter I don't know.</p>

<p><strong>BitSets.</strong><br>
I saw these and thought they were the answer I've been looking for, but when I started using them I realized that they are not suited to the problem at hand and a lot of the methods don't actually do what I thought they would do.</p>

<p>I'm wondering how someone more experienced would do this. I think longs are the way to go, but I'm wondering if all the arithmetic will work. Am I on the right track or is there a better way?</p>
","<p>Use a data structure that fits your need the best.</p>

<p>If you never want to split you values then use <code>long</code>. If you need to split your data into two halves then use <code>int</code>.</p>

<p>If you need to have more control over your data you should go with <code>byte[]</code>. Because internal representation is not an issue for you (because you use Java) there is no need to use <code>byte[]</code> internally.</p>

<p>When it comes to communiction with other computers (e.g. via network socket or file) it is possible that the byte order is important. Then it would be better to use a <code>byte[]</code> as then you have better control over the byte order.</p>

<p>A <code>BitSet</code> is for other use cases and not feasible to be used in encryption.</p>
","254","<java><encryption><data-structures><des>","1","2","2","2014-10-06 12:20:18","26216118","2","","1242028","","2014-10-06 10:28:54","2014-10-06 10:09:37",""
"26214041","Data type for blocks in DES-like algorithm in Java","<p>I am writing a DES-like block cipher in Java. The cipher works with 64-bit blocks and I'm having a tough time deciding how to partition the data so that its useable. In case your wondering the data will be coming from a file and I'm just going to pad it with zeroes until the nearest multiple of 64. Here's what I've been thinking about.</p>

<p><strong>Store an array of longs.</strong><br>
With an array of longs I can traverse over each block in the fewest amount of steps. But, will the logical operations, like XOR, work properly? Also when I have to split the 64-bit into 32-bits should I convert to ints or just keep using longs? And then there is the sign to worry about, but I think I could use the Long class to fix that.</p>

<p><strong>Store an array of byte arrays.</strong><br>
This was my initial idea, but I'm seeing the limitations now. I would have to work with 8 elements per array rather than just one with the array of longs. This might not even matter I don't know.</p>

<p><strong>BitSets.</strong><br>
I saw these and thought they were the answer I've been looking for, but when I started using them I realized that they are not suited to the problem at hand and a lot of the methods don't actually do what I thought they would do.</p>

<p>I'm wondering how someone more experienced would do this. I think longs are the way to go, but I'm wondering if all the arithmetic will work. Am I on the right track or is there a better way?</p>
","<p>You should use the most efficient <em>primitive</em> type for your cipher. So if you primarily use 64 bit instructions, please go for <code>long</code>. If you use primarity 32 bit instructions then <code>int</code> is probably the best type. I'll let you guess the types for 16 and 8 bit operations.</p>

<p>Note that you should not present this interface directly to the outside world. Instead you should use an interface based on byte arrays (just like, e.g. <code>Cipher</code>). You don't want to confront your users with a ton of grief with regards to big endian, signed/unsigned etc. Besides that, ciphers are usually defined for messages of a specific size in bits or bytes.</p>

<p>Certainly do not use <code>BitSet</code>. It's a horrible (unbounded) interface with many peculiarities. It is absolutely not fit for this kind of operations.</p>
","254","<java><encryption><data-structures><des>","1","1","2","2014-10-06 12:20:18","26216118","2","","1242028","","2014-10-06 10:28:54","2014-10-06 10:09:37",""
"43872318","File Encryption And Decryption In Java, doesn't work decryption","<p>Hi guys I have to do this and I can encrypt file according to the des algorithm but I can not decyrpt again file  ,I recieve error messaje like that :</p>

<p>javax.crypto.BadPaddingException Given final block not properly padded</p>

<p>I can not decrypt file I couldnt find  why. Can u help me please 
Thank you guys. </p>

<p>JAVA CODE :</p>

<pre><code>public class Sifreleme {

    public static void encrypt(){
     try {
            SecretKey key = KeyGenerator.getInstance(""DES"").generateKey();

            FileOutputStream fosKey = new FileOutputStream(""..\\KEY"");
            SecretKeyFactory keyfac = SecretKeyFactory.getInstance(""DES"");
            DESKeySpec keyspec = (DESKeySpec) keyfac.getKeySpec(key, DESKeySpec.class);
            fosKey.write(keyspec.getKey());
            fosKey.close();

            Cipher crypt = Cipher.getInstance(""DES"");
            crypt.init(Cipher.ENCRYPT_MODE, key);

            FileInputStream fis = new FileInputStream(""C:\\Users\\akif\\Desktop\\zilsesi.mp3"");
            FileOutputStream fos = new FileOutputStream(""C:\\Users\\akif\\Desktop\\sifrelenenzilsesi.mp3"");
            byte[] arrayBytes = new byte[8];
            int bytesReads;
            while ((bytesReads = fis.read(arrayBytes)) != -1) {
                fos.write(crypt.doFinal(arrayBytes), 0, bytesReads);
            }
            fis.close();
            fos.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }




public static void decrypt(){
       try {
                FileInputStream fisKey = new FileInputStream(""..\\KEY"");
                byte[] arrayKey = new byte[fisKey.available()];
                fisKey.read(arrayKey);
                SecretKey key = new SecretKeySpec(arrayKey, ""DES"");

                Cipher decrypt = Cipher.getInstance(""DES"");
                decrypt.init(Cipher.DECRYPT_MODE, key);

                FileInputStream fis = new FileInputStream(""C:\\Users\\akif\\Desktop\\sifrelenenzilsesi.mp3"");
                byte[] encText = new byte[16];
                int bytesReads;
                while ((bytesReads = fis.read(encText)) != -1) {
                    fis.read(decrypt.doFinal(encText), 0, bytesReads);
                }
                fis.close();
                System.out.println(new String(encText));

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        public static void main(String []args) throws IOException{
        encrypt();
        decrypt();
        }
</code></pre>
","<p>Your code here:</p>

<pre><code>    while ((bytesReads = fis.read(encText)) != -1) {
        fis.read(decrypt.doFinal(encText), 0, bytesReads);
    }
</code></pre>

<p>Is rather obviously wrong: you need to write the plaintext generated by calling <code>decrypt.doFinal</code> just like you do during encryption. Currently you are overwriting the generated plaintext by the next block(s) of ciphertext because you call <code>read</code> twice in the loop.</p>

<p>Furthermore, depending on your DES <code>Cipher</code> implementation, you forgot about the IV.</p>

<hr>

<p>A lot of other things are wrong as well, including:</p>

<ul>
<li>the stream handling using <code>getAvailable()</code>;</li>
<li>the use of the 56 bit DES cipher;</li>
<li>the use of ECB mode;</li>
<li>the repeated calls to <code>doFinal</code> (which results in a very large overhead and insecure code);</li>
<li>not using the <code>CipherInputStream</code> and <code>CipherOutputStream</code> (etcetera);</li>
<li>using a string as the key;</li>
<li>forgetting to close your streams when an exception occurs (use the <code>try</code> with resources);</li>
<li>the <code>printStackTracke()</code> exception handling;</li>
<li>the use of <code>static</code> fields as variables. </li>
</ul>

<p>Using the platform encoding within <code>new String(encText)</code> is only likely wrong.</p>

<hr>

<p>Note that using the wrong key / ciphertext combination will likely also result in this error.</p>
","253","<java><file><encryption><des>","0","2","1","2017-05-09 18:07:52","","2","2","","","","2017-05-09 14:18:25",""
"42897556","Stack corruption upon calling OpenSSL DES_cbc_encrypt()","<p>This is code to encrypt a <code>struct</code> using <code>DES</code> and then read it back after writing to <code>File</code> :</p>

<pre><code>#include ""openssl/des.h""
#include ""openssl/conf.h""
#include ""openssl/evp.h""
#include ""openssl/err.h""
#include &lt;stdio.h&gt;


typedef struct MyStruct_t
{
        char m_Name[32];
        char m_ID[16];
} MyStruct;


uint8_t* __stdcall myStructToBytes(const MyStruct * const iMyStruct)
{
    const size_t len = sizeof(MyStruct;
    uint8_t *buffer = (uint8_t*) malloc(len);

    memcpy(buffer, iMyStruct, len);
    return buffer;
}

const int __stdcall encodeMyStructToFile(const char *sOutputFilename,
                                                         const char *sKey, const MyStruct *iStruct)
{
    DES_cblock key, iv;
    DES_key_schedule schedule;
    unsigned char *data = myStructToBytes((const MyStruct * const)iStruct);
    long len = sizeof(MyStruct);
    int ret = 0;

    memcpy(key, &amp;sKey[0], 8);
    memcpy(iv, &amp;sKey[0], 8);
    DES_set_odd_parity(&amp;key);
    ret = DES_set_key_checked(&amp;key, &amp;schedule);

    if(ret == 0) {
        FILE *write_ptr;
        unsigned char *encrypted = (unsigned char *)malloc(len);
        DES_cbc_encrypt(data, encrypted, len, &amp;schedule, &amp;iv, DES_ENCRYPT);

        // Write encrypted data to file...
        fopen_s(&amp;write_ptr, sOutputFilename, ""wb"");
        fwrite(encrypted, len, 1, write_ptr);
        fclose(write_ptr);
        free(encrypted);
    }
    free(data);

    return ret;
}


const int __stdcall decodeMyStructFromFile(const char *sInputFilename,
           const char *sKey, MyStruct *oStruct)
{
    int ret = 0;
    DES_cblock key, iv;
    DES_key_schedule schedule;
    FILE *read_ptr;
    long len = 0;
    unsigned char *encrypted = NULL;

    // Read encrypted data from file...
    fopen_s(&amp;read_ptr, sInputFilename, ""rb"");
    ret = fseek(read_ptr, 0L, SEEK_END);
    len = ftell(read_ptr);
    rewind(read_ptr);
    encrypted = (unsigned char *)malloc(len);
    fread(encrypted, len, 1, read_ptr);
    fclose(read_ptr);

    // Perform decryption...
    memcpy(key, &amp;sKey[0], 8);
    memcpy(iv, &amp;sKey[0], 8);
    DES_set_odd_parity(&amp;key);
    ret = DES_set_key_checked(&amp;key, &amp;schedule);

    if(ret == 0) {
        DES_cbc_encrypt(encrypted, (unsigned char *)oStruct, len, &amp;schedule, &amp;iv, DES_DECRYPT);
    }
    free(encrypted);

    return ret;
}

int main() {
    MyStruct tMyStruct;
    MyStruct tMyStruct1;
    char outputFilename[] = ""abcd.bin"";
    char key[] = ""key_to_file"";

    memset(&amp;tMyStruct, 0, sizeof(MyStruct));
    memcpy_s(tMyStruct.m_Name, 256, ""Hello"", 5);
    memcpy_s(tMyStruct.m_ID, 32, ""1234567890"", 10);

    encodeMyStructToFile((const char *)outputFilename, (const char *)key, (const MyStruct * const)&amp;tMyStruct);

    decodeLicenseStructFromFile(outputFilename, key, &amp;tMyStruct1);


    return 0;
}
</code></pre>

<p>Somehow, I get stack corruption error in debugger for both encrypt and decrypt functions. I traced down the problem around <code>DES_cbc_encrypt()</code>. What am I doing wrong? I'm using compiled binaries for OpenSSL: <code>openssl-1.1.0e-vs2012</code> on <code>64-bit</code>.</p>
","<p>The reason, why I came back here, is because I noticed (although not producible from the sample code), that both <code>DES_cbc_encrypt()</code> and <code>DES_cbc_decrypt()</code> functions expect <code>8-byte aligned</code> inputs. Thus in the unfortunate case, if the struct here would have been not a multiple of 8 in size, <code>DES_cbc_encrypt()</code> would write past the end of buffer, thus the obvious stack-corruption. Although, when padding is not explicitly disabled, <code>sizeof()</code> still returns the sum of the sizes of the members, so this case I understand is the task of the application programmer. Maybe someone could light up more on this.</p>
","244","<c><openssl><des><stack-corruption>","0","0","1","2017-03-21 06:45:01","42920139","7","1","","","","2017-03-20 07:02:02",""
"52516095","Why did I always get wrong des-ecb result in nodejs native cipher?","<p>Here is my code:</p>

<pre><code>const crypto = require('crypto')
let enterJS = 'h';
let enterStr = null;
enterStr = encrypt(enterJS, 'des-ecb').toUpperCase();
console.log(""===============&gt;&gt;&gt;&gt; ENTER STR : "" + enterStr);
function encrypt(plaintext, algorithm) {
    var keyStr = ""imtestKey"";
    var key = new Buffer(keyStr);
    var cipher = crypto.createCipher(algorithm, key);
    cipher.setAutoPadding(true);
    var ciph = cipher.update(plaintext, 'ascii');
    var ciphf = cipher.final();
    return ciph.toString('hex') + ciphf.toString('hex');
}
</code></pre>

<p>But the result I got is:</p>

<blockquote>
  <p>===============>>>> ENTER STR : 16CE7F2DEB9BB56D</p>
</blockquote>

<p>which the right result I test on this web: <a href=""http://tool.chacuo.net/cryptdes"" rel=""nofollow noreferrer"">http://tool.chacuo.net/cryptdes</a></p>

<blockquote>
  <p>des-mode:ecb</p>
  
  <p>fill-mode:pkcs7padding</p>
  
  <p>password:imtestKey</p>
  
  <p>output:hex</p>
</blockquote>

<p>The right result (the same with my java code) is</p>

<blockquote>
  <p>832e52ebd3fb9059</p>
</blockquote>

<p>My node version is v8.9.0, how can I get the right result?</p>

<p>This is my java code:</p>

<pre><code>import java.lang.StringBuilder;
import javax.crypto.Cipher;
import java.security.SecureRandom;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.SecretKey;

public class Test {
    public static void main(String[] args) {
        String js = ""h"";
        try {
            byte[] bs = encrypt(js.getBytes(), ""imtestKey"".getBytes());
            System.out.println(byte2hex(bs));
        } catch(Exception ex) {

        }
    }

    public static byte[] encrypt(byte[] src, byte[] key) throws Exception {
        SecureRandom sr = new SecureRandom();
        DESKeySpec dks = new DESKeySpec(key);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
        SecretKey securekey = keyFactory.generateSecret(dks);
        Cipher cipher = Cipher.getInstance(""DES"");
        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);
        return cipher.doFinal(src);
    }


    public static String byte2hex(byte[] b) {
        StringBuilder sb = new StringBuilder();
        String stmp = """";

        for(int n = 0; b != null &amp;&amp; n &lt; b.length; ++n) {
            stmp = Integer.toHexString(b[n] &amp; 255);
            if (stmp.length() == 1) {
                sb.append(""0"").append(stmp);
            } else {
                sb.append(stmp);
            }
        }

        return sb.toString().toUpperCase();
    }
}
</code></pre>
","<p>Security aspects aside (as has been pointed out, DES and ECB, as well as no key derivation is insecure), you are using a deprecated <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password_options"" rel=""nofollow noreferrer""><code>crypto.createCipher()</code></a> function which <em>derives</em> a key from the provided password.</p>

<blockquote>
  <p>The implementation of <code>crypto.createCipher()</code> <strong>derives</strong> keys using the OpenSSL function <code>EVP_BytesToKey</code> with the digest algorithm set to <strong>MD5, one iteration, and no salt</strong>. The lack of salt allows dictionary attacks as the same password always creates the same key. The low iteration count and non-cryptographically secure hash algorithm allow passwords to be tested very rapidly.</p>
</blockquote>

<p>Use <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options"" rel=""nofollow noreferrer""><code>crypto.createCipheriv()</code></a> instead, which uses the provided key as-is:</p>

<pre><code>const crypto = require('crypto')
let enterJS = 'h';
let enterStr = null;
function encrypt(plaintext, algorithm) {
    var keyStr = ""imtestKey"";
    var key = Buffer.alloc(8, keyStr);
    var cipher = crypto.createCipheriv(algorithm, key, Buffer.alloc(0));
    cipher.setAutoPadding(true);
    var ciph = cipher.update(Buffer.from(plaintext));
    var ciphf = cipher.final();
    return Buffer.concat([ciph, ciphf]).toString('hex');
}
enterStr = encrypt(enterJS, 'des-ecb').toUpperCase();
console.log(""===============&gt;&gt;&gt;&gt; ENTER STR : "" + enterStr);
</code></pre>

<p>The <code>createCipheriv</code> API will reject your 9-byte long key, because DES requires an 8-byte key. I made a workaround to take the first 8 bytes from the provided password as the key and now it's printing your desired result.</p>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>===============&gt;&gt;&gt;&gt; ENTER STR : 832E52EBD3FB9059
</code></pre>
","242","<javascript><node.js><encryption><des>","2","2","1","2018-09-27 20:03:44","52544352","8","","10418241","","2018-09-27 05:00:36","2018-09-26 10:55:09",""
"46713247","bytes[] getIV() method is returning null value","<p>I'm writing a code which will encrypt and decrypt the message(using DES algorithm), and both messages will be displayed in Dialog box. But when i run the code i got nullPointerException. And after debugging the code i realize the null data is getting stored 'iv'.
Here is my code:-</p>

<pre><code>import javax.crypto.spec.*;
import javax.crypto.*;
import javax.swing.*;
public class des 
{
    public static void main(String ar[]) throws Exception
    {
        KeyGenerator keygen=KeyGenerator.getInstance(""DES"");
        SecretKey secretkey=keygen.generateKey();
        Cipher cip=Cipher.getInstance(""DES"");

        String inputText=JOptionPane.showInputDialog(""Give input:"");

        byte[] iv=cip.getIV();
        IvParameterSpec ps=new IvParameterSpec(iv);

        cip.init(Cipher.ENCRYPT_MODE,secretkey);
        byte[] encrypted=cip.doFinal(inputText.getBytes());

        cip.init(Cipher.DECRYPT_MODE,secretkey,ps);
        byte[] decrypted=cip.doFinal(encrypted);

        JOptionPane.showMessageDialog(null,""Encrypted :""+new String(encrypted)+""\n Decrypted :""+new String(decrypted));
        System.exit(0);
    }
}
</code></pre>
","<p>You don't need IvParameterSpec  for decrypt the key.</p>

<p>Working code:</p>

<pre><code>public class des {

    public static void main(String[] args) throws Exception {
        KeyGenerator keygen=KeyGenerator.getInstance(""DES"");
        SecretKey secretkey=keygen.generateKey();
        Cipher encrypter=Cipher.getInstance(""DES"");
        Cipher decrypter=Cipher.getInstance(""DES"");

        String inputText=JOptionPane.showInputDialog(""Give input:"");

        encrypter.init(Cipher.ENCRYPT_MODE,secretkey);
        byte[] encrypted=encrypter.doFinal(inputText.getBytes());

        decrypter.init(Cipher.DECRYPT_MODE,secretkey);
        byte[] decrypted=decrypter.doFinal(encrypted);

        JOptionPane.showMessageDialog(null,""Encrypted :""+new String(encrypted)+""\n Decrypted :""+new String(decrypted));
        System.exit(0);

    }

}
</code></pre>
","239","<java><algorithm><des><block-cipher>","-1","-1","1","2017-10-12 15:33:26","","1","2","","","","2017-10-12 15:18:20",""
"50336891","DES encryption/decryption in client/server using openssl","<p>I need to perform DES encryption in server, send the encryption to the client 
and decrypt it in the client.</p>

<p>Server:</p>

<pre><code>const EVP_CIPHER *c = EVP_des_cbc(); 
EVP_CIPHER_CTX  *x = malloc(sizeof(EVP_CIPHER_CTX));
EVP_CIPHER_CTX_init(x);

EVP_EncryptInit (x, c, key, iv);        // initlizing encryption

EVP_EncryptUpdate (x, encryptedDataBuffer, &amp;encryptedDataLength, dataBuffer, strlen(dataBuffer));
EVP_EncryptFinal (x,  encryptedDataBuffer + encryptedDataLength,  &amp;encryptedDataLength);

write(client_sock , encryptedDataBuffer , encryptedDataLength);
printf(""Encrypted Data Sent to Client\n"");
</code></pre>

<p>Here server encrypts the data and sends it to client. So far so good.</p>

<p>Client:</p>

<pre><code>serverDataLength = recv(sockfd , dataBuffer , MAXDATASIZE , 0);
printf(""Encrypted Data is Received\n"");

const EVP_CIPHER *c = EVP_des_cbc();    
EVP_CIPHER_CTX *x = malloc(sizeof(EVP_CIPHER_CTX));
EVP_CIPHER_CTX_init(x);

EVP_DecryptInit(x, c, key, iv);
EVP_DecryptUpdate(x,  decryptedDataBuffer, &amp;sizeOfDecryptedBuffer , dataBuffer,  serverDataLength);
EVP_DecryptFinal(x, decryptedDataBuffer+sizeOfDecryptedBuffer, &amp;sizeOfDecryptedBuffer);

printf(""\n\nDecrypted Data: %s\n"", decryptedDataBuffer);
</code></pre>

<p>Client receives the data and decrypts it.</p>

<p>However the problem is when I print the decrypted data  in client, it prints some garbage values along with the decrypted data. How do I get rid of those garbage values? Client/Server works fine, no problem there.</p>

<p>I don't want to post the complete code here, it'll get messy. I am pretty sure the problem is somewhere in the posted code.</p>

<p>Thanks!</p>
","<p>I think reason is simple.</p>

<p>In server you use <code>strlen()</code> for getting content length, so you have ignored terminating '\0' at end of your string. You decrypt your content and print it ignoring that terminating '\0'. So you print garbage from memory at end of decrypted message.</p>

<p>You need to send data <strong>including terminating '\0'</strong> by something like using <code>strlen(dataBuffer)+1</code>, or you need to <strong>add</strong> it to received content.</p>

<p><strong>2 side note:</strong></p>

<ol>
<li><code>DES</code> algorithm is a very insecure algorithm, <strong>NEVER</strong> use it.</li>
<li>In socket programming it is always suggested to send data length alongside data. For example, send 2 bytes that show encrypted data length and then send data. So you can manage data much better at client.</li>
</ol>
","239","<c><encryption><openssl><client-server><des>","3","3","2","2018-05-14 20:41:24","50338572","0","","3082254","","2018-05-14 20:29:11","2018-05-14 18:36:04",""
"50336891","DES encryption/decryption in client/server using openssl","<p>I need to perform DES encryption in server, send the encryption to the client 
and decrypt it in the client.</p>

<p>Server:</p>

<pre><code>const EVP_CIPHER *c = EVP_des_cbc(); 
EVP_CIPHER_CTX  *x = malloc(sizeof(EVP_CIPHER_CTX));
EVP_CIPHER_CTX_init(x);

EVP_EncryptInit (x, c, key, iv);        // initlizing encryption

EVP_EncryptUpdate (x, encryptedDataBuffer, &amp;encryptedDataLength, dataBuffer, strlen(dataBuffer));
EVP_EncryptFinal (x,  encryptedDataBuffer + encryptedDataLength,  &amp;encryptedDataLength);

write(client_sock , encryptedDataBuffer , encryptedDataLength);
printf(""Encrypted Data Sent to Client\n"");
</code></pre>

<p>Here server encrypts the data and sends it to client. So far so good.</p>

<p>Client:</p>

<pre><code>serverDataLength = recv(sockfd , dataBuffer , MAXDATASIZE , 0);
printf(""Encrypted Data is Received\n"");

const EVP_CIPHER *c = EVP_des_cbc();    
EVP_CIPHER_CTX *x = malloc(sizeof(EVP_CIPHER_CTX));
EVP_CIPHER_CTX_init(x);

EVP_DecryptInit(x, c, key, iv);
EVP_DecryptUpdate(x,  decryptedDataBuffer, &amp;sizeOfDecryptedBuffer , dataBuffer,  serverDataLength);
EVP_DecryptFinal(x, decryptedDataBuffer+sizeOfDecryptedBuffer, &amp;sizeOfDecryptedBuffer);

printf(""\n\nDecrypted Data: %s\n"", decryptedDataBuffer);
</code></pre>

<p>Client receives the data and decrypts it.</p>

<p>However the problem is when I print the decrypted data  in client, it prints some garbage values along with the decrypted data. How do I get rid of those garbage values? Client/Server works fine, no problem there.</p>

<p>I don't want to post the complete code here, it'll get messy. I am pretty sure the problem is somewhere in the posted code.</p>

<p>Thanks!</p>
","<p>You have supplied wrong lengths to the procedures. </p>

<p>Try the following:</p>

<pre><code>int ciphertext_len;

EVP_EncryptUpdate (x, encryptedDataBuffer, &amp;encryptedDataLength,     dataBuffer, strlen(dataBuffer));
ciphertext_len = encryptedDataLength;

EVP_EncryptFinal (x,  encryptedDataBuffer + encryptedDataLength,  &amp;encryptedDataLength);
ciphertext_len += encryptedDataLength;


int plaintext_len;

EVP_DecryptUpdate(x,  decryptedDataBuffer, &amp;sizeOfDecryptedBuffer , dataBuffer,  ciphertext_len);
plaintext_len = sizeOfDecryptedBuffer;

EVP_DecryptFinal(x, decryptedDataBuffer+sizeOfDecryptedBuffer, &amp;sizeOfDecryptedBuffer);
plaintext_len += sizeOfDecryptedBuffer;
</code></pre>

<p>Now print the decrypted data:</p>

<pre><code>/* Add a NULL terminator. We are expecting printable text */
decryptedDataBuffer[plaintext_len] = '\0';

/* Show the decrypted text */
printf(""Decrypted text is:\n"");
printf(""%s\n"", decryptedDataBuffer);
</code></pre>
","239","<c><encryption><openssl><client-server><des>","3","4","2","2018-05-14 20:41:24","50338572","0","","3082254","","2018-05-14 20:29:11","2018-05-14 18:36:04",""
"42774977","How to send and receive secret key using datagram socket","<p>Im trying to make a simple des chat system, but I have a problem receiving secret key in udp. The error message shows the problem with objectInputStream.</p>

<pre><code>java.io.StreamCorruptedException: invalid stream header: 358A822E
at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:806)
at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:299)
</code></pre>

<p>this is the sender code</p>

<pre><code>InetAddress inetAddress = InetAddress.getLocalHost();
KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
SecretKey myDesKey = keygenerator.generateKey();
Cipher desCipher;

// Create the cipher
desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");

// Initialize the cipher for encryption
desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);

ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(baos);
oos.writeObject((Object) myDesKey);
oos.flush();
final byte[] bytes = baos.toByteArray();

DatagramPacket sendPacket = new DatagramPacket(bytes, bytes.length, inetAddress, 999);
socket.send(sendPacket);
</code></pre>

<p>this is the reciever code</p>

<pre><code>   Cipher desCipher;
SecretKey myDesKey = null;
// Create the cipher

desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");

packetIn = new DatagramPacket(dataOut, dataOut.length);
socket.receive(packetIn);
ByteArrayInputStream bais = new ByteArrayInputStream(packetIn.getData());
ObjectInputStream oos = new ObjectInputStream(bais);
myDesKey = (SecretKey) oos.readObject();
System.out.println(""the key is "" + myDesKey.toString());
desCipher.init(Cipher.DECRYPT_MODE, myDesKey); 
</code></pre>
","","239","<java><sockets><udp><datagram><des>","0","","0","2017-03-13 23:07:01","","2","2","5642825","","2017-03-13 23:07:01","2017-03-13 23:00:44",""
"42906891","Des Decrypt read in C#","<pre><code>static byte[] desdecrypt(Mode mode, byte[] IV, byte[] key, byte[] msg)
    {
        using (var des = new DESCryptoServiceProvider())
        {
            des.IV = IV;
            des.Key = key;
            des.Mode = CipherMode.CBC;
            des.Padding = PaddingMode.PKCS7;

            using (var mstream = new MemoryStream())
            {
                CryptoStream cs = null;
                if (mode == Mode.DECRYPT)
                {
                    cs = new CryptoStream(mstream, des.CreateDecryptor(), CryptoStreamMode.Read);
                }
                if (cs == null)
                    return null;

                cs.Read(msg, 0, msg.Length); 
                return mstream.ToArray();
            }
        }
        return null;
    }

    private void button2_Click(object sender, EventArgs e)
    {
        string a = textBox4.Text;
        string ab = textBox6.Text;
        byte[] IV = Encoding.ASCII.GetBytes(ab);
        string aa = textBox7.Text;
        byte[] key = Encoding.ASCII.GetBytes(aa);
        byte[] decrypted = desdecrypt(Mode.DECRYPT, IV, key, Encoding.ASCII.GetBytes(a));
        textBox5.Text = Encoding.ASCII.GetString(decrypted);
    }
</code></pre>

<p>cs.Read(msg, 0, msg.Length) error occurs in this line (bad data)
unhandled exception has occurred in my application
i dont know what any help please i have tried almost everything</p>
","<p>When you have data in the underlying stream and want to decrypt it to an array, use <code>CryptoStreamMode.Read</code> and <code>Read</code>.</p>

<p>Since you have an empty stream that is collecting data, you should use <code>CryptoStreamMode.Write</code> and <code>Write</code>.</p>

<hr>

<p>Standard caveats apply:</p>

<ul>
<li>DES is a terrible, broken algorithm</li>
<li>Don't use ASCII (or Unicode) data as keys</li>
<li>Don't assume that encrypted data can be represented as ASCII (or Unicode) data</li>
<li>Never add cryptography into released software unless you can explain

<ul>
<li>What it does</li>
<li>Under what conditions it will be deemed out of date</li>
<li>How you will grow it up when it's out of date

<ul>
<li>And how it won't break all your users, or make them insecure, when you do so.</li>
</ul></li>
</ul></li>
</ul>
","236","<c#><encryption><des>","0","1","1","2017-03-20 15:11:13","42907216","0","","","","","2017-03-20 14:55:54","2017-03-21 03:23:21"
"37246048","DES program that goes too many rounds.","<p>I have this program that runs a DES encryption for the full 16 rounds, but I only need it to run 1 complete round.  My problem is that I can't seem to figure out where to cut my coding to make it stop running the full 16 rounds. Thank you for your help!</p>

<pre><code>import javax.crypto.*;
import java.security.*;
import java.util.Scanner;
import java.util.*;

/**
 *  Performs encryption 
 */
public class DESEncryption{

    // Initial Permutation table
    private static final byte[] InitialPermutation = { 
        58, 50, 42, 34, 26, 18, 10, 2,
        60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6,
        64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17, 9,  1,
        59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5,
        63, 55, 47, 39, 31, 23, 15, 7
    };

    // Permuted Choice 1 table
    private static final byte[] PermutedChoice1 = {
        57, 49, 41, 33, 25, 17, 9,
        1,  58, 50, 42, 34, 26, 18,
        10, 2,  59, 51, 43, 35, 27,
        19, 11, 3,  60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
        7,  62, 54, 46, 38, 30, 22,
        14, 6,  61, 53, 45, 37, 29,
        21, 13, 5,  28, 20, 12, 4
    };


    private static final byte[] PermutedChoice2 = {
        14, 17, 11, 24, 1,  5,
        3,  28, 15, 6,  21, 10,
        23, 19, 12, 4,  26, 8,
        16, 7,  27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    };

    // Array to store the number of rotations that are to be done on each round
    private static final byte[] rotations = {
        1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
};

    private static final byte[] Expansion = {
        32, 1,  2,  3,  4,  5,
        4,  5,  6,  7,  8,  9,
        8,  9,  10, 11, 12, 13,
        12, 13, 14, 15, 16, 17,
        16, 17, 18, 19, 20, 21,
        20, 21, 22, 23, 24, 25,
        24, 25, 26, 27, 28, 29,
        28, 29, 30, 31, 32, 1
    };

    private static final byte[][] SubstitutionBoxes = { {
        14, 4,  13, 1,  2,  15, 11, 8,  3,  10, 6,  12, 5,  9,  0,  7,
        0,  15, 7,  4,  14, 2,  13, 1,  10, 6,  12, 11, 9,  5,  3,  8,
        4,  1,  14, 8,  13, 6,  2,  11, 15, 12, 9,  7,  3,  10, 5,  0,
        15, 12, 8,  2,  4,  9,  1,  7,  5,  11, 3,  14, 10, 0,  6,  13
    }, {
        15, 1,  8,  14, 6,  11, 3,  4,  9,  7,  2,  13, 12, 0,  5,  10,
        3,  13, 4,  7,  15, 2,  8,  14, 12, 0,  1,  10, 6,  9,  11, 5,
        0,  14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3,  2,  15,
        13, 8,  10, 1,  3,  15, 4,  2,  11, 6,  7,  12, 0,  5,  14, 9
    }, {
        10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,
        13, 7,  0,  9,  3,  4,  6,  10, 2,  8,  5,  14, 12, 11, 15, 1,
        13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,
        1,  10, 13, 0,  6,  9,  8,  7,  4,  15, 14, 3,  11, 5,  2,  12
    }, {
        7,  13, 14, 3,  0,  6,  9,  10, 1,  2,  8,  5,  11, 12, 4,  15,
        13, 8,  11, 5,  6,  15, 0,  3,  4,  7,  2,  12, 1,  10, 14, 9,
        10, 6,  9,  0,  12, 11, 7,  13, 15, 1,  3,  14, 5,  2,  8,  4,
        3,  15, 0,  6,  10, 1,  13, 8,  9,  4,  5,  11, 12, 7,  2,  14
    }, {
        2,  12, 4,  1,  7,  10, 11, 6,  8,  5,  3,  15, 13, 0,  14, 9,
        14, 11, 2,  12, 4,  7,  13, 1,  5,  0,  15, 10, 3,  9,  8,  6,
        4,  2,  1,  11, 10, 13, 7,  8,  15, 9,  12, 5,  6,  3,  0,  14,
        11, 8,  12, 7,  1,  14, 2,  13, 6,  15, 0,  9,  10, 4,  5,  3
    }, {
        12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3,  4,  14, 7,  5,  11,
        10, 15, 4,  2,  7,  12, 9,  5,  6,  1,  13, 14, 0,  11, 3,  8,
        9,  14, 15, 5,  2,  8,  12, 3,  7,  0,  4,  10, 1,  13, 11, 6,
        4,  3,  2,  12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8,  13
    }, {
        4,  11, 2,  14, 15, 0,  8,  13, 3,  12, 9,  7,  5,  10, 6,  1,
        13, 0,  11, 7,  4,  9,  1,  10, 14, 3,  5,  12, 2,  15, 8,  6,
        1,  4,  11, 13, 12, 3,  7,  14, 10, 15, 6,  8,  0,  5,  9,  2,
        6,  11, 13, 8,  1,  4,  10, 7,  9,  5,  0,  15, 14, 2,  3,  12
    }, {
        13, 2,  8,  4,  6,  15, 11, 1,  10, 9,  3,  14, 5,  0,  12, 7,
        1,  15, 13, 8,  10, 3,  7,  4,  12, 5,  6,  11, 0,  14, 9,  2,
        7,  11, 4,  1,  9,  12, 14, 2,  0,  6,  10, 13, 15, 3,  5,  8,
        2,  1,  14, 7,  4,  10, 8,  13, 15, 12, 9,  0,  3,  5,  6,  11
    } };

    private static final byte[] Permutation = {
        16, 7,  20, 21,
        29, 12, 28, 17,
        1,  15, 23, 26,
        5,  18, 31, 10,
        2,  8,  24, 14,
        32, 27, 3,  9,
        19, 13, 30, 6,
        22, 11, 4,  25
    };

    // Final permutation table
    private static final byte[] FinalPermutation = {
        40, 8, 48, 16, 56, 24, 64, 32,
        39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30,
        37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28,
        35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26,
        33, 1, 41, 9, 49, 17, 57, 25
    };

    private static int[] C = new int[28];
    private static int[] D = new int[28];


    private static int[][] subkey = new int[16][48];

    public static void main(String args[]) {
        System.out.println(""Enter the plaintext in hexadecimal: "");
        String input = new Scanner(System.in).nextLine();
        int inputBits[] = new int[64];

        for(int i=0 ; i &lt; 16 ; i++) {

            String s = Integer.toBinaryString(Integer.parseInt(input.charAt(i) + """", 16));

            while(s.length() &lt; 4) {
                s = ""0"" + s;
            }

            for(int j=0 ; j &lt; 4 ; j++) {
                inputBits[(4*i)+j] = Integer.parseInt(s.charAt(j) + """");
            }
        }

        System.out.println(""Enter the key in hexadecimal: "");
        String key = new Scanner(System.in).nextLine();
        int keyBits[] = new int[64];
        for(int i=0 ; i &lt; 16 ; i++) {
            String s = Integer.toBinaryString(Integer.parseInt(key.charAt(i)          + """", 16));
            while(s.length() &lt; 4) {
                s = ""0"" + s;
            }
            for(int j=0 ; j &lt; 4 ; j++) {
                keyBits[(4*i)+j] = Integer.parseInt(s.charAt(j) + """");
            }
        }

        System.out.println(""Encryption Rounds: "");
        int outputBits[] = permute(inputBits, keyBits, false);
        System.out.println(""Decryption: "");
        permute(outputBits, keyBits, true);
    }

    private static int[] permute(int[] inputBits, int[] keyBits, boolean isDecrypt) {

        int newBits[] = new int[inputBits.length];
        for(int i=0 ; i &lt; inputBits.length ; i++) {
            newBits[i] = inputBits[InitialPermutation[i]-1];
        }

        int L[] = new int[32];
        int R[] = new int[32];
        int i;


        for(i=0 ; i &lt; 28 ; i++) {
            C[i] = keyBits[PermutedChoice1[i]-1];
        }
        for( ; i &lt; 56 ; i++) {
            D[i-28] = keyBits[PermutedChoice1[i]-1];
        }

        for(int n=0 ; n &lt; 16 ; n++) {
            System.out.println(""\n-------------"");
            System.out.println(""Round "" + (n+1) + "":"");

            int newR[] = new int[0];
            if(isDecrypt) {
                newR = fiestel(R, subkey[15-n]);
                BitsDisplayed(subkey[15-n]);
            } else {
                newR = fiestel(R, KS(n, keyBits));
                BitsDisplayed(subkey[n]);
            }


            int newL[] = xor(L, newR);
            L = R;
            R = newL;
            System.out.print(""L = "");
            BitsDisplayed(L);
            System.out.print(""R = "");
            BitsDisplayed(R);
        }

        int output[] = new int[64];
        System.arraycopy(R, 0, output, 0, 32);
        System.arraycopy(L, 0, output, 32, 32);
        int finalOutput[] = new int[64];

        for(i=0 ; i &lt; 64 ; i++) {
            finalOutput[i] = output[FinalPermutation[i]-1];
        }

        String hex = new String();
        for(i=0 ; i &lt; 16 ; i++) {
            String bin = new String();
            for(int j=0 ; j &lt; 4 ; j++) {
                bin += finalOutput[(4*i)+j];
            }
            int decimal = Integer.parseInt(bin, 2);
            hex += Integer.toHexString(decimal);
        }
        if(isDecrypt) {
            System.out.print(""Decrypted text: "");

        } else {
            System.out.print(""Encrypted text: "");
        }
        System.out.println(hex.toUpperCase());
        return finalOutput;
    }

    private static int[] KS(int round, int[] key) {

        int C1[] = new int[28];
        int D1[] = new int[28];


        int rotationTimes = (int) rotations[round];

        C1 = leftShift(C, rotationTimes);
        D1 = leftShift(D, rotationTimes);

        int CnDn[] = new int[56];
        System.arraycopy(C1, 0, CnDn, 0, 28);
        System.arraycopy(D1, 0, CnDn, 28, 28);

        int Kn[] = new int[48];
        for(int i=0 ; i &lt; Kn.length ; i++) {
            Kn[i] = CnDn[PermutedChoice2[i]-1];
        }

        subkey[round] = Kn;
        C = C1;
        D = D1;
        return Kn;
    }

    private static int[] fiestel(int[] R, int[] roundKey) {

        int expandedR[] = new int[48];
        for(int i=0 ; i &lt; 48 ; i++) {
            expandedR[i] = R[Expansion[i]-1];
        }

        int temp[] = xor(expandedR, roundKey);
        int output[] = sBlock(temp);
        return output;
    }

    private static int[] xor(int[] a, int[] b) {
        int answer[] = new int[a.length];
        for(int i=0 ; i &lt; a.length ; i++) {
            answer[i] = a[i]^b[i];
        }
        return answer;
    }

    private static int[] sBlock(int[] bits) {
        // S-boxes applied in  method.
        int output[] = new int[32];
        for(int i=0 ; i &lt; 8 ; i++) {
            int row[] = new int [2];
            row[0] = bits[6*i];
            row[1] = bits[(6*i)+5];
            String sRow = row[0] + """" + row[1];

            int column[] = new int[4];
            column[0] = bits[(6*i)+1];
            column[1] = bits[(6*i)+2];
            column[2] = bits[(6*i)+3];
            column[3] = bits[(6*i)+4];
            String sColumn = column[0] +""""+ column[1] +""""+ column[2] +""""+    column[3];
            // Converting binary to decimal value
            int iRow = Integer.parseInt(sRow, 2);
            int iColumn = Integer.parseInt(sColumn, 2);
            int x = SubstitutionBoxes[i][(iRow*16) + iColumn];

            String s = Integer.toBinaryString(x);

            while(s.length() &lt; 4) {
                s = ""0"" + s;
            }

            for(int j=0 ; j &lt; 4 ; j++) {
                output[(i*4) + j] = Integer.parseInt(s.charAt(j) + """");
            }
        }

        int finalOutput[] = new int[32];
        for(int i=0 ; i &lt; 32 ; i++) {
            finalOutput[i] = output[Permutation[i]-1];
        }
        return finalOutput;
    }

    private static int[] leftShift(int[] bits, int n) {

        int answer[] = new int[bits.length];
        System.arraycopy(bits, 0, answer, 0, bits.length);
        for(int i=0 ; i &lt; n ; i++) {
            int temp = answer[0];
            for(int j=0 ; j &lt; bits.length-1 ; j++) {
                answer[j] = answer[j+1];
            }
            answer[bits.length-1] = temp;
        }
        return answer;
    }

    private static void BitsDisplayed (int[] bits) {

        for(int i=0 ; i &lt; bits.length ; i+=4) {
            String output = new String();
            for(int j=0 ; j &lt; 4 ; j++) {
                output += bits[i+j];
            }
            System.out.print(Integer.toHexString(Integer.parseInt(output, 2)));
        }
        System.out.println();
    }
}
</code></pre>
","<p>The <code>for</code> loop that contains:</p>

<pre><code>System.out.println(""Round "" + (n+1) + "":"");
</code></pre>

<p>would be the primary suspect, wouldn't it? Of course you might not need the full key expansion anymore either; best check if there are bytes unused. Better replace the 16 in the for loop by a constant value so you can change it back.</p>

<p>Note that the code contains binary to hexadecimal conversion and I/O *right within the <code>permute</code> function. I'd expect <em>at most</em> some logging functionality in the heart of the cipher.</p>
","236","<java><encryption><des>","1","0","1","2016-05-16 11:15:39","37252602","0","","","","","2016-05-16 02:52:39",""
"1606589","DirectShow Editing Services on multiple machines in parallel?","<p>Is it in any way possible to process at least 1 <a href=""http://en.wikipedia.org/wiki/DirectShow"" rel=""nofollow noreferrer"">DShow</a> video project on multiple machines in parallel at the same time for faster rendering or just for fun?</p>

<p>In any language? With help of any program?</p>
","<p>The short answer is yes, but it's not a very practical solution</p>

<p>Lets say you did manage to create a system that broke a video up across machines for distributed decoding.  You first would have to be careful on how you did ""break up"" the video.  You must always start at keyframe and ending right before the next keyframe.  Next you would have to decode your clip.  Once decoded, the decoded data must be transfered to the computer rendering the video.  An uncompressed 1080p @ 30 FPS stream would be ~182 megaBYTES/s, which is more than a gigabit connection can handle.</p>

<p>You are better off decoding over multiple cores and the GPU.</p>
","234","<parallel-processing><video-streaming><directshow><des>","0","0","1","2009-10-22 20:06:37","1609647","1","","63550","","2009-10-22 11:34:55","2009-10-22 11:28:48",""
"53332164","Go lang 3DES partially decrypted the encrypted string","<p>While performing decryption using 3des  the given encrypted text is not fully decrypted, not sure where it went wrong, help me complete the decryption error</p>

<p>The code is avaialbe at <a href=""https://play.golang.org/p/3xtFHvpiA3V"" rel=""nofollow noreferrer"">Go Playground</a> for Insection and run </p>

<pre><code>package main

import (
    ""crypto/des""
    ""encoding/hex""
    ""fmt""
)

func main() {

    // Mimimum Key Size of Length 24
    key := ""mysecretPasswordkeySiz24""
    plainText := ""https://8gwifi.org""
    ct := EncryptTripleDES([]byte(key),plainText)
    fmt.Printf(""Original Text:  %s\n"",plainText)
    fmt.Printf(""3DES Encrypted Text:  %s\n"", ct)
    DecryptTripleDES([]byte(key),ct)

}

func EncryptTripleDES(key []byte, plaintext string) string {
        c,err := des.NewTripleDESCipher(key)
    if err != nil {
        fmt.Errorf(""NewTripleDESCipher(%d bytes) = %s"", len(key), err)
        panic(err)
    }

    out := make([]byte, len(plaintext))
    c.Encrypt(out, []byte(plaintext))
    return hex.EncodeToString(out)

    }


func DecryptTripleDES(key []byte, ct string) {

        ciphertext, _ := hex.DecodeString(ct)
        c, err := des.NewTripleDESCipher([]byte(key))
        if err != nil {
            fmt.Errorf(""NewTripleDESCipher(%d bytes) = %s"", len(key), err)
            panic(err)
        }
        plain := make([]byte, len(ciphertext))
        c.Decrypt(plain, ciphertext)
        s := string(plain[:])
        fmt.Printf(""3DES Decrypyed Text:  %s\n"", s)
}
</code></pre>

<p>The output </p>

<pre><code>Original Text:  https://8gwifi.org
3DES Encrypted Text:  a6e5215154bf86d000000000000000000000
3DES Decrypyed Text:  https://
</code></pre>
","<blockquote>
  <p>the given encrypted text is not fully decrypted</p>
</blockquote>

<p>The encrypted text you gave is fully decrypted. The problem is not (yet) the decryption but your encryption. As documented <code>des.NewTripleDESCipher</code> returns a <code>cipher.Block</code> and <code>cipher.Block.Encrypt</code> encrypts as documented only the first block of the input data. Given that DES has a block size of 8 byte only the first 8 byte of the input data are encrypted, i.e. <code>https://</code>. </p>

<p>This means in order to encrypt all data you must encrypt all blocks. Similar you need to decrypt all blocks when decrypting - but <code>cipher.Block.Decrypt</code> also decrypts only a single block.</p>

<p>Apart from that DES is broken, so don't use it for something serious.</p>
","233","<go><encryption><des><3des>","0","2","1","2018-11-16 06:02:44","53332282","0","","","","","2018-11-16 05:52:01",""
"21013844","DES Encryption in asp.net to php","<p>I'm trying to achive the same DES encription that I've in an asp.net code but in PHP.</p>

<p>The asp code looks like the following:</p>

<pre><code> public static string Encrypt(string originalString)
   {
       if (String.IsNullOrEmpty(originalString))
       {
           throw new ArgumentNullException(""The string which needs to be encrypted can not be null."");
       }

       System.Security.Cryptography.DESCryptoServiceProvider cryptoProvider = new System.Security.Cryptography.DESCryptoServiceProvider();
       MemoryStream memoryStream = new MemoryStream();
       System.Security.Cryptography.CryptoStream cryptoStream = new System.Security.Cryptography.CryptoStream(memoryStream, cryptoProvider.CreateEncryptor(bytes, bytes), System.Security.Cryptography.CryptoStreamMode.Write);

       StreamWriter writer = new StreamWriter(cryptoStream);
       writer.Write(originalString);
       writer.Flush();
       cryptoStream.FlushFinalBlock();
       writer.Flush();

       return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
   }
</code></pre>

<p>Is there any equivalent available in php</p>

<pre><code>function get_encrypted_key($key)
{
    $salt = 'abcdefgh';
    $block = mcrypt_get_block_size('des', 'cbc');
    $pad = $block - (strlen($key) % $block);
    $key .= str_repeat(chr($pad), $pad);
    return bin2hex(mcrypt_encrypt(MCRYPT_DES, $salt, $key, MCRYPT_MODE_CBC, $salt));
}
</code></pre>
","<p>Have you tried googling?</p>

<p><a href=""http://us.php.net/crypt"" rel=""nofollow"">http://us.php.net/crypt</a></p>

<pre><code>$hashed = crypt('text_to_crypt');
</code></pre>
","232","<php><asp.net><des>","0","0","1","2014-01-09 07:22:36","","1","","704528","","2014-01-09 07:21:46","2014-01-09 07:13:39",""
"49504044","Segmentation Fault in C while using crypt function","<p>I am new to programming in C.I am trying to make a simple password cracking program but when I try to run it I get Segmentation Fault as an error. Can someone solve the issue. Thanks in advance.</p>

<pre><code>#define _XOPEN_SOURCE
#include&lt;stdio.h&gt;
#include&lt;crypt.h&gt;
#include&lt;unistd.h&gt;
#include&lt;string.h&gt;

int main(int argc, char *argv[])
{
    if(argc != 3)
    {
        printf(""Usage: ./craken salt hash\n"");
        return 0;       
    }


    FILE *fPointer;
    fPointer = fopen(""wordlist.txt"", ""r"");

    char singleLine[150];
    while(fgets(singleLine, 150, fPointer) != NULL)
    {   
        if(!strcmp(argv[2], crypt(singleLine, argv[1])))
       {
            printf(""Password found! %s is the password\n"", singleLine);
            fclose(fPointer);
            return 0;
       }
    }
    printf(""Not found\n"");
    fclose(fPointer);
    return 0;
} 
</code></pre>
","<p>I guess the problem is that if you read out possible passwords out of you're file there is an newline at the end. The crypt() function as I understand can only handle the set [a-zA-Z0-9./] (<a href=""http://man7.org/linux/man-pages/man3/crypt.3.html"" rel=""nofollow noreferrer"">crypt man page</a>) that might result in an NULL pointer being returned. This NULL pointer than leads to a segmentation fault inside the strcmp() function. So try to remove that newline char at the end of each input line. Hope this works</p>
","229","<c><segmentation-fault><des><crypt>","0","1","1","2018-03-27 06:34:30","","4","","","","","2018-03-27 03:48:05",""
"22667255","how to change a string in python sequentially?","<p>I'm trying to write a program for Brute Force Attack on DES, the key is a string of 8 characters made only from decimal digits for example (12345678).</p>

<p>So i need some help writing a program where i can set the testing key to (00000000) and start looping it incrementally (00000001), (00000002) all the way til (99999999) and trying the key each time of course.</p>

<p>I've done the DES program already and now my brain is stuck with this part.</p>

<p>Update: many thanks for <a href=""https://stackoverflow.com/users/763505/hyperboreus"">Hyperboreus</a>, for the key generator function, however when i used it in my program, i get error message </p>

<blockquote>
  <p>UnicodeDecodeError: 'utf-8' codec can't decode byte 0xbf in position 1: invalid start byte</p>
</blockquote>

<p>for any key larger than (00000002)</p>

<p>here is my code</p>

<pre><code>from Crypto.Cipher import DES 
import os 
import base64

print (""key size is fixed at 16 Bytes including parities (56 bits effective)"")
size = 16

key = '00000002'
cipher = DES.new(key)            
BS = 8


def getMode():
    while True:
        mode = input('Do you wish to Encrypt ""e"", Decrypt ""d"" or Brute force ""b"" a message?\n')
        if mode in 'e d b'.split():
            return mode
        else:
            print('Enter either ""e"" for encrypt,""d"" for decrypt, or ""b"" for brute force.\n')


def encrypt(text):
    length = len(plaintext)
    pad = lambda s: s + (BS - len(s) % BS) * ('~')
    paddedtext = pad(plaintext)
    encrypted = DES.new(key, DES.MODE_ECB)
    ciphertext = base64.b64encode(encrypted.encrypt(paddedtext)).decode(""utf-8"")
    return ciphertext


def decrypt(text):
    decrypted = DES.new(key, DES.MODE_ECB)
    paddedtext = decrypted.decrypt(base64.b64decode(cipher)).decode(""utf-8"")
    l = paddedtext.count ('~')
    return paddedtext[:len(paddedtext)-l]


def brute(text):
     text2 = input(""enter a part of the plain text: "")

    def testkeys ():
        for i in range (100000000):
            yield '{:08d}'.format (i)

    for testkey in testkeys ():
        testkey = format (testkey)
        decrypted = DES.new(testkey, DES.MODE_ECB)
        paddedtext = decrypted.decrypt(base64.b64decode(cipher)).decode(""utf-8"")
        if paddedtext.find(text2) != -1:
            print (""the key is "",testkey)
            l = paddedtext.count ('~')
            return paddedtext[:len(paddedtext)-l]
            break

mode = getMode()

print (""key is:"", key)

if mode[0] == 'e':
    plaintext = input(""Enter the plaintext: "")
    encrypted = encrypt(plaintext)
    print (""encrypted:\n"", encrypted)

elif mode [0] == 'd':
    cipher = input(""Enter the ciphertext: "")
    decrypted = decrypt(cipher)
    print (""decrypted:\n"", decrypted)

else:
    cipher = input(""Enter the ciphertext: "")
    brute = brute(cipher)
    print (""decrypted:\n"", brute)
</code></pre>

<p>once i solve this problem, the next step is to incorporate the alphabets (capital and small) into the key</p>
","<p>Strings are immutable, hence you cannot change them. But you can generate all your desired strings.</p>

<pre><code>def keys ():
    for i in range (100000000):
        yield '{:08d}'.format (i)

for key in keys ():
    print ('Testing key {}.'.format (key) )
    #test the key
</code></pre>
","229","<python><string><generator><sequence><des>","1","5","1","2014-03-27 17:36:12","22667302","0","","-1","","2017-05-23 10:26:02","2014-03-26 16:25:35",""
"42995386","Encyrpting a string using Triple DES in c#?","<p>I am trying to write a c# program that will encrypt a string using an API key. The API key is generate by a third party payment gateway. The documentation is provided in java and I was able to encrypt the string in java but I tried to encrypt the string using the c# code and it generated a different result. This is what I tried so far.
java -</p>

<pre><code> public static String harden(String unencryptedString) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    String key =""***************"";
        MessageDigest md = MessageDigest.getInstance(""md5"");
    byte[] digestOfPassword = md.digest(key.getBytes(""utf-8""));
    byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);

    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    SecretKey secretKey = new SecretKeySpec(keyBytes, ""DESede"");
    Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);

    byte[] plainTextBytes = unencryptedString.getBytes(""utf-8"");
    byte[] buf = cipher.doFinal(plainTextBytes);
    byte[] base64Bytes;

           base64Bytes = Base64.getEncoder().encode(buf);

    String base64EncryptedString = new String(base64Bytes);

    return base64EncryptedString;
}
</code></pre>

<p>c# code -</p>

<pre><code>public TripleDES CreateDES(string key)
    {
        MD5 md5 = new MD5CryptoServiceProvider();
        TripleDES des = new TripleDESCryptoServiceProvider();
        des.Key = md5.ComputeHash(Encoding.Unicode.GetBytes(key));
        des.IV = new byte[des.BlockSize / 8];
        return des;
    }

    public  byte[] Encryption(string PlainText, string key)
    {
        TripleDES des = CreateDES(key);
        ICryptoTransform ct = des.CreateEncryptor();
        byte[] input = Encoding.Unicode.GetBytes(PlainText);
        return ct.TransformFinalBlock(input, 0, input.Length);
    }
</code></pre>
","<p>In addition to the remark of Jon, the <code>TripleDESCryptoServiceProvider</code> defaults to CBC mode encryption / decryption. You would need to specify ECB mode for C#, noting that ECB mode is insecure.</p>

<hr>

<p>Actually, to provide full security, the ciphertext <em>should</em> always be different for each encryption / decryption with the same key. That's what the (random) IV is for in CBC mode.</p>

<hr>

<p>Nowadays we try to use an authenticated cipher such as AES / GCM, preferably within a secure protocol. For instance one that uses a secure key derivation method that is not MD5.</p>
","227","<java><c#><encryption><des><ecb>","0","0","1","2017-03-24 11:43:47","","3","2","589259","","2017-03-24 11:43:47","2017-03-24 09:10:18",""
"22824057","Not able to decrypt in mysql that was encrypted using the php script","<p>I am encrypting my string using the following php code. </p>

<pre><code>$encryption_key = ""mickey"";
$value = ""ddd"";
function encrypt($value)
{
    global $encryption_key;
    if(function_exists(""mcrypt_ecb""))
    {
        return mcrypt_ecb(MCRYPT_DES, $encryption_key, $value, MCRYPT_ENCRYPT);
    }
    else return $value;
}
</code></pre>

<p>I am storing the encrypted value in the database. This stores ""<code>?P??</code>"" in the database in column ""Encrypt""</p>

<p>However when I run this query</p>

<pre><code>select DES_DECRYPT(Encrypt,""mickey"") from test_encrypt 
</code></pre>

<p>It gives me </p>

<pre><code>3f503f1b3f1b20
</code></pre>

<p>How can I retrieve my original <code>$value</code> from the sql query?</p>

<p>Thanks</p>
","<p>Sounds like a character set issue to me.</p>

<p>Likely you're storing the binary value into a VARCHAR (or other non-binary type), and a character set conversion is being applied, and some of the bytes aren't valid ""characters"" in the characterset for the column, either that, or, the stored values are being translated on retrieval, and ""unknown"" encodings are being replaced with question marks.</p>

<p>As a test, you could try using the MySQL <code>HEX()</code> and <code>UNHEX()</code> functions on the binary values, though that will effectively double the size of the strings.  There shouldn't be any characterset problem with character strings representing hexadecimal digits. (I don't think there are native base-64 encoding/decoding functions in MySQL.)</p>

<p>Alternatively, you might try storing the encrypted values in a column with a datatype that supports binary data, with no characterset translation, e.g. <code>VARBINARY</code> rather than <code>VARCHAR</code>.</p>
","221","<php><mysql><encryption><des>","0","1","1","2014-04-02 22:55:05","22824497","2","","828983","","2014-04-02 22:17:52","2014-04-02 22:07:36",""
"34307464","Java Card Applet returns 6f00 while trying to encrypt a message","<p>I'm trying to encrypt a key imported in my card and store it again in the same byte array.
The import_key function below receives an apdu and extracts the message KEY, then tries to encrypt it (simple DES encryption) and store it at the same place.
It seems that I have done everything necessary but unfortunately I receive 6f00 every time I uncomment the encryption part!!!
this is my code:</p>

<pre><code>public class Encryptor extends Applet {

private byte[] KEY                                  = new byte[128];
private byte key_len                                = (byte)0;
private byte[] ENC_KEY                              = new byte[32];
private byte enc_key_len                            = (byte)0;

Cipher MyCipher;
private byte[] TheDES_Key = new byte[24];
DESKey MyDES1Key = (DESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_DES,KeyBuilder.LENGTH_DES, false);
byte ConfiguredKeyLength = 0;

{...}

private void import_key(APDU apdu) {
    byte[] buffer = new byte[maximum_buffer_len];
    buffer = apdu.getBuffer();
    key_len = buffer[ISO7816.OFFSET_LC];
    apdu.setIncomingAndReceive();
    Util.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA), KEY, (short) 0, (short) key_len);

    Util.arrayCopyNonAtomic(ENC_KEY, (short) 0, TheDES_Key, (short) 0, (short) enc_key_len);

    MyDES1Key.setKey(TheDES_Key, (short) 0);
    MyCipher.init(MyDES1Key, Cipher.MODE_ENCRYPT);

    byte[] CipheredData = JCSystem.makeTransientByteArray((short) 32,JCSystem.CLEAR_ON_DESELECT);
    MyCipher.doFinal(KEY, (short)0,(short)key_len,CipheredData,(short)0);
    Util.arrayCopyNonAtomic(CipheredData,(short)0,KEY,(short)0,(short)key_len);

    return;
    }
}
</code></pre>
","<p>In the line:</p>

<pre><code>DESKey MyDES1Key = (DESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_DES,KeyBuilder.LENGTH_DES, false);
</code></pre>

<p>you defined length of <code>MyDES1Key</code> as <code>LENGTH_DES</code> that is <code>8</code> bytes, while in the line:</p>

<p><code>MyDES1Key.setKey(TheDES_Key, (short) 0);</code></p>

<p>You are filling it with a <code>24</code> bytes variable!</p>

<p>In the other word you must replace <code>KeyBuilder.LENGTH_DES</code> with <code>KeyBuilder.LENGTH_DES3_3KEY</code>.</p>
","219","<encryption><javacard><des>","0","0","1","2015-12-16 10:28:34","","2","1","","","","2015-12-16 08:49:09",""
"22227457","Perl Crypt::CBC don't return the expected result","<p>I'm looking at the Crypt::CBC lib and I misunderstand something... below an example :</p>

<pre><code>#!/usr/bin/env perl
use warnings;
use strict;
use Crypt::CBC;

my $cipher = Crypt::CBC-&gt;new(
    -key    =&gt; pack(""H*"",""0011223344556677""),
    -iv     =&gt; pack(""H*"",""AABBCCDDEEFF0011""),
    -header =&gt; ""none"",
    -padding=&gt; ""null"",
    -cipher =&gt; ""Crypt::DES"");
my $plaintext = $cipher-&gt;decrypt(pack(""H*"",""0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF""));
print unpack(""H*"",$plaintext).""\n"";
</code></pre>

<p>This script print the  string :</p>

<pre><code>a732b731fdcb5dbe0caa3e8b9a9f90400caa3e8b9a9f90400caa3e8b9a9f90400caa3e8b9a9f90400caa3e8b9a9f90400caa3e8b9a9f9040
</code></pre>

<p>It should be :</p>

<pre><code>D7ED316D5F2C1F1D7C75B8D73878D2E37C75B8D73878D2E37C75B8D73878D2E37C75B8D73878D2E37C75B8D73878D2E37C75B8D73878D2E3
</code></pre>

<p>I use CrypTool 2.0 software and <a href=""http://des.online-domain-tools.com/tool-form-submit/"" rel=""nofollow"">http://des.online-domain-tools.com/tool-form-submit/</a> to get this result.</p>

<p>Any ideas ?</p>

<hr>

<h2>[=> Problem Solved &lt;=]</h2>

<p>I have fixed the issue with <strong>-literal_key => 1,</strong> parameter.</p>

<pre><code>#!/usr/bin/env perl
use warnings;
use strict;
use Crypt::CBC;

my $cipher = Crypt::CBC-&gt;new(
    -literal_key =&gt; 1,
    -key    =&gt; pack(""H*"",""0011223344556677""),
    -iv     =&gt; pack(""H*"",""AABBCCDDEEFF0011""),
    -header =&gt; ""none"",
    -padding=&gt; ""null"",
    -cipher =&gt; ""Crypt::DES"");
my $plaintext = $cipher-&gt;decrypt(pack(""H*"",""0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF""));
print unpack(""H*"",$plaintext).""\n"";
</code></pre>
","<p>I have fixed the issue with <strong>-literal_key => 1,</strong> parameter.</p>

<pre><code>#!/usr/bin/env perl
use warnings;
use strict;
use Crypt::CBC;

my $cipher = Crypt::CBC-&gt;new(
    -literal_key =&gt; 1,
    -key    =&gt; pack(""H*"",""0011223344556677""),
    -iv     =&gt; pack(""H*"",""AABBCCDDEEFF0011""),
    -header =&gt; ""none"",
    -padding=&gt; ""null"",
    -cipher =&gt; ""Crypt::DES"");
my $plaintext = $cipher-&gt;decrypt(pack(""H*"",""0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF""));
print unpack(""H*"",$plaintext).""\n"";
</code></pre>
","211","<perl><des><crypt>","1","0","1","2014-03-07 09:46:30","22246611","2","","3388529","","2014-03-06 15:39:57","2014-03-06 14:31:48",""
"20629312","conversion of list to bitarray in python","<p>I am trying to build a DES code using my humble python knowledge:
I get the following error: ""  xor_lf = l1 ^ Bn
TypeError: bitarray object expected for bitwise operation""
Do I need to convert Bn or l1 to bitarray? And how?</p>

<pre><code>from bitarray import bitarray
iptable=[57, 49, 41, 33, 25, 17, 9,  1,
        59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5,
        63, 55, 47, 39, 31, 23, 15, 7,
        56, 48, 40, 32, 24, 16, 8,  0,
        58, 50, 42, 34, 26, 18, 10, 2,
        60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6
    ]
pc1=[56, 48, 40, 32, 24, 16,  8,
          0, 57, 49, 41, 33, 25, 17,
          9,  1, 58, 50, 42, 34, 26,
         18, 10,  2, 59, 51, 43, 35,
         62, 54, 46, 38, 30, 22, 14,
          6, 61, 53, 45, 37, 29, 21,
         13,  5, 60, 52, 44, 36, 28,
         20, 12,  4, 27, 19, 11,  3
    ]
expTable=[31,  0,  1,  2,  3,  4,
         3,  4,  5,  6,  7,  8,
         7,  8,  9, 10, 11, 12,
        11, 12, 13, 14, 15, 16,
        15, 16, 17, 18, 19, 20,
        19, 20, 21, 22, 23, 24,
        23, 24, 25, 26, 27, 28,
        27, 28, 29, 30, 31,  0]
pc2 = [13, 16, 10, 23,  0,  4,
         2, 27, 14,  5, 20,  9,
        22, 18, 11,  3, 25,  7,
        15,  6, 26, 19, 12,  1,
        40, 51, 30, 36, 46, 54,
        29, 39, 50, 44, 32, 47,
        43, 48, 38, 55, 33, 52,
        45, 41, 49, 35, 28, 31] 
# The (in)famous S-boxes
__sbox = [
        # S1
        [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
         0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
         4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
         15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],

        # S2
        [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
         3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
         0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
         13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],

        # S3
        [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
         13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
         13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
         1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],

        # S4
        [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
         13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
         10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
         3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],

        # S5
        [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
         14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
         4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
         11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],

        # S6
        [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
         10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
         9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
         4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],

        # S7
        [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
         13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
         1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
         6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],

        # S8
        [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
         1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
         7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
         2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
    ]
msg= bitarray(endian='little')
msg.frombytes(b'ABCDEFGH')
perm = bitarray(endian='little')
key= bitarray(endian='little')
key.frombytes(b'FFQQSSMM')
keyPc1 = bitarray(endian='little')
keyPc2 = bitarray(endian='little')
exp = bitarray(endian='little')
for z in pc1:
    keyPc1.append(key[z])
c0 = keyPc1[0:28]
d0 = keyPc1[28:]
key0 = c0 + d0
#permutation of key
for k in pc2:
    keyPc2.append(key0[k])
#permutation of message
for x in iptable:
    perm.append(msg[x])
l1 = perm[0:32]
r1 = perm[32:]
#Expansion of R
for y in expTable:
    exp.append(r1[y])
#XORing R &amp; key
xor_rk = keyPc2 ^ exp
#Working with S-boxes!
B = [xor_rk[0:6], xor_rk[6:12], xor_rk[12:18], xor_rk[18:24], xor_rk[24:30], xor_rk[30:36], xor_rk[36:42], xor_rk[36:]]
j = 0
Bn = [0] * 32
pos = 0
while j &lt; 8:
    # Work out the offsets
    m = (B[j][0] &lt;&lt; 1) + B[j][5]
    n = (B[j][1] &lt;&lt; 3) + (B[j][2] &lt;&lt; 2) + (B[j][3] &lt;&lt; 1) + B[j][4]
    # Find the permutation value
    v = __sbox[j][(m &lt;&lt; 4) + n]
    # Turn value into bits, add it to result: Bn
    Bn[pos] = (v &amp; 8) &gt;&gt; 3
    Bn[pos + 1] = (v &amp; 4) &gt;&gt; 2
    Bn[pos + 2] = (v &amp; 2) &gt;&gt; 1
    Bn[pos + 3] = v &amp; 1
    pos += 4
    j += 1
print (Bn)
print (l1)
xor_lf = l1 ^ Bn
</code></pre>
","<p>The problem here is that Bn is of type list and l1 is of type bitarray.
An easy fix is to convert Bn to a bitarray just after creating it.
After,</p>

<pre><code>Bn = [0] * 32
</code></pre>

<p>add,</p>

<pre><code>Bn = bitarray(Bn)
</code></pre>
","194","<python><des>","0","1","1","2013-12-17 08:55:12","20629730","1","","2722899","","2013-12-17 08:33:47","2013-12-17 08:31:31",""
"19531921","Why android cannot ? DES mp4 encryption decryption success in desktop but failed an Android","<p>I would like to implement a module for mp4 file encryption and decryption using DES .</p>

<p>It succeeds and decrypted file can play identically to the original sound track in desktop application but cannot in Android ? why ? </p>

<p>The below is my code
(Module)</p>

<pre><code>private static final String key = ""v@!#1SF5~6A5XZE3"";

   public static void encrypt(InputStream is, OutputStream os) throws Throwable {
    encryptOrDecrypt(key, Cipher.ENCRYPT_MODE, is, os);
}

public static void decrypt(InputStream is, OutputStream os) throws Throwable {
    encryptOrDecrypt(key, Cipher.DECRYPT_MODE, is, os);
}

public static void encryptOrDecrypt(String key, int mode, InputStream is, OutputStream os) throws Throwable {

    DESKeySpec dks = new DESKeySpec(key.getBytes());
    SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
    SecretKey desKey = skf.generateSecret(dks);
    Cipher cipher = Cipher.getInstance(""DES""); 

    if (mode == Cipher.ENCRYPT_MODE) {
        cipher.init(Cipher.ENCRYPT_MODE, desKey);
        CipherInputStream cis = new CipherInputStream(is, cipher);
        doCopy(cis, os);
    } else if (mode == Cipher.DECRYPT_MODE) {
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        CipherOutputStream cos = new CipherOutputStream(os, cipher);
        doCopy(is, cos);
    }
}

       public static void doCopy(InputStream is, OutputStream os) throws IOException {
byte[] bytes = new byte[8192];
int numBytes;
while ((numBytes = is.read(bytes)) != -1) {
    os.write(bytes, 0, numBytes);
}
os.flush();
os.close();
is.close();
</code></pre>

<p>}</p>

<p>Application (Encryption) : </p>

<pre><code>stopService(new Intent(AlaramScheduleActivity.this, RecordService.class));
        File instanceRecordDirectory = new File(Environment.getExternalStorageDirectory() + File.separator + ""Test"");
        if(instanceRecordDirectory.exists()){       
            FileInputStream fis = new FileInputStream(instanceRecordDirectory.getAbsolutePath() + File.separator +   ""test.mp4"");
            FileOutputStream fos = new FileOutputStream(instanceRecordDirectory.getAbsolutePath() + File.separator +   ""etest.mp4"");
            AESClientEncodeDecode.encrypt(fis, fos);
        }           
</code></pre>

<p>Application (Decrpytion): </p>

<pre><code>File instanceRecordDirectory = new File(Environment.getExternalStorageDirectory() + File.separator + ""Test"");
    File decryptF = null;
    if(instanceRecordDirectory.exists()){

        FileInputStream fis2 = new FileInputStream(instanceRecordDirectory.getAbsolutePath() + File.separator +   ""etest.mp4"");
        FileOutputStream fos2 = new FileOutputStream(instanceRecordDirectory.getAbsolutePath() + File.separator +   ""dtest.mp4"");
        AESClientEncodeDecode.decrypt(fis2, fos2);

    }

    decryptF = new File(instanceRecordDirectory.getAbsolutePath() + File.separator +   ""dtest.mp4"");
    if(decryptF.exists()){          
        Intent intent = new Intent(Intent.ACTION_VIEW);         
        intent.setDataAndType(Uri.fromFile(decryptF), ""audio/*"");  
        startActivity(intent);          
    }else{
        toast(""Recordings does not exists"");
    }
</code></pre>
","","193","<android><encryption><des>","0","","0","2013-10-23 02:49:54","","4","3","","","","2013-10-23 02:49:54",""
"20060036","Cipher class from javax.crypto package not working as expected using the DES algorithm","<p>Here is my code:</p>

<pre><code>public byte[] encrypt(byte[] key, byte[] pText) throws Exception
{
    System.out.println( DatatypeConverter.printHexBinary(key)); // Outputs: 3FBB589A6A941D01
    System.out.println( DatatypeConverter.printHexBinary(pText)); // Outputs: 92F3BD61F852727E
    Cipher ciph = Cipher.getInstance(""DES"");
    SecretKey blah = new SecretKeySpec(key, 0, key.length, ""DES"");

    ciph.init(Cipher.ENCRYPT_MODE,  blah);
    byte[] test = ciph.doFinal(pText); 
    System.out.println( DatatypeConverter.printHexBinary(test)); // Outputs: 4799F8A1C0A427E17E2B19DD22064444

    return test;
}
</code></pre>

<p>A couple of things I as unsure on:</p>

<ol>
<li>I padded the key with 01, that is why the output on the first line ends with 01. I tried padding it with 0s but that did not work either. And the required length is 8 bytes. So not sure if I did that right.</li>
<li>I am not completely sure what offset means in the SecretKey constructor(2nd argument). I am assuming it should be 0.</li>
<li>My main question is why is test(the cipherText) 16 bytes? According to <a href=""http://www.facweb.iitkgp.ernet.in/~sourav/DES.pdf"" rel=""nofollow"">http://www.facweb.iitkgp.ernet.in/~sourav/DES.pdf</a> page 13 it should be only 8 bytes.</li>
</ol>

<p>I also know my code is not working because I know what the final encrypted output should be.</p>
","<p>You don't specify the mode and padding for the cipher in the call to <code>getInstance()</code>, so the provider will choose default parameters. Your provider is defaulting to ""PKCS5Padding"", so it add 8 bytes with a value of 0x08 to your plain text before performing the DES encryption.</p>

<p>To avoid platform-dependent behavior, it's very important to specify a complete transformation when creating a <code>Cipher</code> instance: algorithm, mode, and padding. If you don't want padding, say so:</p>

<pre><code>Cipher ciph = Cipher.getInstance(""DES/ECB/NoPadding"");
SecretKey blah = new SecretKeySpec(key, ""DES"");
</code></pre>

<p>Why did you pad your key? Why wasn't your key 8 bytes long to start? If the first 7 bytes are intended to be used as the actual key, and lack parity bits, you can't just slap a byte on the end; you need to expand the key to eight bytes, appending one parity bit to each 7-bit chunk.</p>

<p>If you use the parity-adjusted key, <code>3EDCD613A754513B</code>, and no padding, the cipher text is <code>C094C47D7F89E219</code>. Is that what you are expecting?</p>
","192","<java><encryption><des>","0","0","1","2013-11-19 00:04:52","20060563","0","2","","","","2013-11-18 23:17:10",""
"37918185","How should I convert this java DES program to PHP?","<p>I have a  DES Algorithm  use java ,now I need convert this java program for php, I don't know java <code>cipher.init</code> method's third parameters <code>SecureRandom</code> ,So I use my php Des program to encrypt a string ,but I got a different result with java Des.</p>

<p>Here is my Java DES:</p>

<pre><code>public static String encode(String srcStr) {
    if (srcStr == null)
        return null;
    String dst = null;
    byte[] result = encrypt2(srcStr.getBytes(), ""h43au76U"");
    if (result == null)
        return null;
    System.out.println(result);
    dst = byte2HexStr(result, result.length);
    return dst;
    }

 private static final char[] mChars = ""0123456789ABCDEF"".toCharArray();


 public static String byte2HexStr(byte[] b, int iLen) {
        if (b == null)
            return null;
        StringBuilder sb = new StringBuilder();
        for (int n = 0; n &lt; iLen; n++) {
            sb.append(mChars[(b[n] &amp; 0xff) &gt;&gt; 4]);
            sb.append(mChars[b[n] &amp; 0xf]);
        }
        return sb.toString().trim().toUpperCase(Locale.US);
        }



 private static byte[] encrypt2(byte[] datasource, String password) {
        byte[] is;
        try {
            SecureRandom random = new SecureRandom();
            DESKeySpec desKey = new DESKeySpec(password.getBytes(""UTF-8""));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
            javax.crypto.SecretKey securekey
            = keyFactory.generateSecret(desKey);
            Cipher cipher = Cipher.getInstance(""DES"");
            cipher.init(1, securekey, random);
            is = cipher.doFinal(datasource);
        } catch (Throwable e) {
            e.printStackTrace();
            return null;
        }
        return is;
        }
</code></pre>

<p>And this is my php des:</p>

<pre><code>function encrypt($input,$key,$iv=0){
    $size = mcrypt_get_block_size(MCRYPT_DES,MCRYPT_MODE_CBC); //3DES加密将MCRYPT_DES改为MCRYPT_3DES
    $input =pkcs5_pad($input, $size); //如果采用PaddingPKCS7，请更换成PaddingPKCS7方法。
    $td = mcrypt_module_open(MCRYPT_DES, '', MCRYPT_MODE_CBC, '');
    @mcrypt_generic_init($td, $key,$iv);
    $data = mcrypt_generic($td, $input);
    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);
//    return $data;
   return strtoupper(bin2hex($data));
}
</code></pre>

<p>I got a different result, why? And I don't know  if SecureRandom is a <code>iv</code> ?</p>
","<p><strong>Always use a fully qualified Cipher string.</strong> <code>Cipher.getInstance(""DES"");</code> may result in different ciphers depending on the default security provider. It most likely results in <code>""DES/ECB/PKCS5Padding""</code>, but it doesn't have to be. If it changes, you'll lose compatibility between different JVMs.</p>

<p>What you need to do in PHP to achieve compatibility with Java is to use ECB mode instead of CBC mode and apply PKCS#5 padding (same as PKCS#7 padding). <a href=""https://stackoverflow.com/a/27590539/1816580"">This answer</a> shows an implementation of that padding. You just have to use the correct block size which is 8 for DES.</p>

<hr>

<p><strong>Never use <a href=""https://crypto.stackexchange.com/q/14487/13022"">ECB mode</a></strong>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like <a href=""https://crypto.stackexchange.com/q/22260/13022"">CBC</a> or <a href=""https://crypto.stackexchange.com/a/2378/13022"">CTR</a>. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p>

<p>The IV must be unpredictable (read: random). Don't use a static IV, because that makes the cipher deterministic and therefore not semantically secure. An attacker who observes ciphertexts can determine when the same message prefix was sent before. The IV is not secret, so you can send it along with the ciphertext. Usually, it is simply prepended to the ciphertext and sliced off before decryption.</p>
","191","<java><php><encryption><des>","0","2","1","2016-06-20 12:51:35","","1","2","1816580","","2016-06-20 12:51:35","2016-06-20 08:50:05",""
"52328004","DES algorithm in VNC authentication with Python","<p>I am trying to connect with a VNC server (Vino) using VNC authentication. Reading the RFC 6143 - The Remote Framebuffer Protocol, we can see how VNC authentication works. </p>

<p>It is using a challenge-response protocol where the server sends a challenge of 16 bytes and the client answer with the challenge encrypted with his key. The encryption is using DES algorithm.</p>

<p>Using TigerVNC and Wireshark I have sniffed this process in order to do this process with Python.</p>

<p>E.g.</p>

<p>This is the traffic which I have sniffed with Wireshark between Vino and TigerVNC. It works.</p>

<pre><code>Server                                                                 Client
|------------------   Server protocol version: 003.007  -----------------&gt;|
|&lt;-----------------   Client protocol version: 003.007      --------------|
|------------------        Security types: 2        ---------------------&gt;|
|&lt;-----------------    Security type selected: VNC (2)  ------------------|
|-------------------        Authentication result: OK           ---------&gt;|
|-----  Authentication challenge: b4a7257a443426527dd9d987fa6b099f  -----&gt;|
|&lt;----  Authentication response: 4838c102d8cbb1decd38ecdbec533bc7   ------|
</code></pre>

<p><em>The challenge and response are bytes, not hex strings.</em></p>

<p>But when I encrypt the authentication challenge with <em>Python</em>, I got different results. I have tryed using differents block cipher mode of operations, without success.</p>

<p>E.g.</p>

<pre><code>&gt;&gt;&gt; from pydes import des
&gt;&gt;&gt; challenge = ""\xb4\xa7\x25\x7a\x44\x34\x26\x52\x7d\xd9\xd9\x87\xfa\x6b\x09\x9f""
&gt;&gt;&gt; key = ""testingg""
&gt;&gt;&gt; d = des()
&gt;&gt;&gt; ciphered = d.encrypt(key,challenge,padding=True)
&gt;&gt;&gt; import binascii
&gt;&gt;&gt; ciphered = d.encrypt(key,challenge)
&gt;&gt;&gt; binascii.hexlify(ciphered)
'4f16bc072bf34903e753b3f968b1aa56'
</code></pre>

<p>Or with another Python module:</p>

<pre><code>&gt;&gt;&gt; import pyDes
&gt;&gt;&gt; des = pyDes.des(""testingg"")
&gt;&gt;&gt; challenge = ""\xb4\xa7\x25\x7a\x44\x34\x26\x52\x7d\xd9\xd9\x87\xfa\x6b\x09\x9f""
&gt;&gt;&gt; e = des.encrypt(challenge)
&gt;&gt;&gt; binascii.hexlify(e)
'4f16bc072bf34903e753b3f968b1aa56'
&gt;&gt;&gt; binascii.hexlify(des.decrypt(e))
'b4a7257a443426527dd9d987fa6b099f'
</code></pre>

<p>Am I missing something? The RFC doesn't show anything about encryption modes or IV vectors..</p>

<p>Moreover, I have shows source code of TigerVNC, which is wrote in Java, and It is not appers to have any special thing about the challenge encryption.</p>
","","189","<python><encryption><vnc><des><vnc-server>","0","","0","2018-09-14 08:35:11","","2","","","","","2018-09-14 08:35:11",""
"38416980","Java DES Encrypt/Decrypt methods","<p>I need to create two simple methods for string DES encryption/decruption. The goal is to have these two methods in the following form</p>

<p>public static String desEcnrypt(String key, String clearMessage)
{
    .....
}</p>

<p>public static String desDecrypt(String key, String encryptedMessage)
{
    .....
}</p>

<p>I haven't found yet any example in this form.</p>
","<p>Use the ""not-yet-commons-ssl.jar"" from <a href=""http://juliusdavies.ca/commons-ssl/"" rel=""nofollow"">http://juliusdavies.ca/commons-ssl/</a>.</p>

<p><a href=""http://juliusdavies.ca/commons-ssl/pbe.html"" rel=""nofollow"">http://juliusdavies.ca/commons-ssl/pbe.html</a></p>

<p>PBE code example (DES-3):*</p>

<pre><code>char[] password = {'c','h','a','n','g','e','i','t'};
byte[] data = ""Hello World!"".getBytes();

// Encrypt!
byte[] encrypted = OpenSSL.encrypt(""des3"", password, data);
System.out.println(""ENCRYPTED: ["" + new String(encrypted) + ""]"");

// Decrypt results of previous!
data = OpenSSL.decrypt(""des3"", password, encrypted);
System.out.println(""DECRYPTED: ["" + new String(data) + ""]"");


OUTPUT:
=======================
ENCRYPTED: [U2FsdGVkX19qplb9qVDVVEYxH8wjJDGpMS+F4/2pS2c=]
DECRYPTED: [Hello World!]
</code></pre>
","188","<java><encryption><des>","3","3","1","2016-07-17 20:56:48","38425860","1","","1816580","","2016-07-17 20:52:17","2016-07-17 00:56:21",""
"17520949","DES Encryption on Blackberry gone wrong","<p>I have an application developed on BlackBerry JDE 5.0.0 that encrypts a String using DES algorithm with ECB mode. After the encryption, the result is encoded by base64 encoding. But whenever I compare the result that i get from my encryption method with the result that i get on the online encryptor engine, it always give different result on the several last character. I tried to decrypt the result that i get form my encryption method with the online encriptor engine and it looks like the result is not the valid one. So how can I fix that different result on the several last character?</p>

<p>Here my encryption method code:</p>

<pre><code>public String encryptDESECB(String text) throws MessageTooLongException
{
    byte[] input = text.getBytes();
    byte[] output = new byte[8];
    byte[] uid = null;
    uid = ""431654625bd37673e3b00359676154074a04666a"".getBytes();
    DESKey key = new DESKey(uid);
    try {
            DESEncryptorEngine engine = new DESEncryptorEngine(key);
            engine.encrypt(input, 0, output, 0);
            String x= BasicAuth.encode(new String(output));
            System.out.println(""AFTER ENCODE""+x);
            return new String(x);
    } catch (CryptoTokenException e) {
        return ""NULL"";
    } catch (CryptoUnsupportedOperationException e) {
        return ""NULL"";
    }
}
</code></pre>

<p>The String that i want to encrypt is ""00123456"" 
The Result that i get from my encryption method is:YnF2BWFV/8w=
The Result that i get from online encryptor engine (<a href=""http://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow"">http://www.tools4noobs.com/online_tools/encrypt/</a>) : YnF2BWFV9sw=
The Result that i get from android (With the same encryption algorithm &amp; Method) : YnF2BWFV9sw=</p>

<p>Here's the code on Android:</p>

<pre><code>public static String encryptDesECB(String data) {
    try {
        DESKeySpec keySpec = newDESKeySpec(""431654625bd37673e3b00359676154074a04666a"".getBytes(""UTF8""));
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
        SecretKey key = keyFactory.generateSecret(keySpec);

        // ENCODE plainTextPassword String
        byte[] cleartext = data.getBytes(""UTF8"");

        Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);

        Logger.log(Log.INFO, new String(cipher.doFinal(cleartext)));

        String encrypedPwd = Base64.encodeToString(cipher.doFinal(cleartext), Base64.DEFAULT);

        Logger.log(Log.INFO, encrypedPwd);

        return encrypedPwd;

    } catch (Exception e) {
        Logger.log(e);
        return null;
    }
}
</code></pre>

<p>Can anyone help me with this?</p>
","<p>This is most likely caused by padding, as DES works with 8 byte blocks.</p>

<p>For more information check out this link:</p>

<p><a href=""http://www.tero.co.uk/des/explain.php#Padding"" rel=""nofollow"">http://www.tero.co.uk/des/explain.php#Padding</a></p>

<p>As long as you can properly decrypt the content you'll be fine.</p>
","185","<java><encryption><blackberry-jde><des><ecb>","0","0","2","2015-01-23 09:55:32","","4","2","2559607","","2013-07-08 08:04:49","2013-07-08 07:14:27",""
"17520949","DES Encryption on Blackberry gone wrong","<p>I have an application developed on BlackBerry JDE 5.0.0 that encrypts a String using DES algorithm with ECB mode. After the encryption, the result is encoded by base64 encoding. But whenever I compare the result that i get from my encryption method with the result that i get on the online encryptor engine, it always give different result on the several last character. I tried to decrypt the result that i get form my encryption method with the online encriptor engine and it looks like the result is not the valid one. So how can I fix that different result on the several last character?</p>

<p>Here my encryption method code:</p>

<pre><code>public String encryptDESECB(String text) throws MessageTooLongException
{
    byte[] input = text.getBytes();
    byte[] output = new byte[8];
    byte[] uid = null;
    uid = ""431654625bd37673e3b00359676154074a04666a"".getBytes();
    DESKey key = new DESKey(uid);
    try {
            DESEncryptorEngine engine = new DESEncryptorEngine(key);
            engine.encrypt(input, 0, output, 0);
            String x= BasicAuth.encode(new String(output));
            System.out.println(""AFTER ENCODE""+x);
            return new String(x);
    } catch (CryptoTokenException e) {
        return ""NULL"";
    } catch (CryptoUnsupportedOperationException e) {
        return ""NULL"";
    }
}
</code></pre>

<p>The String that i want to encrypt is ""00123456"" 
The Result that i get from my encryption method is:YnF2BWFV/8w=
The Result that i get from online encryptor engine (<a href=""http://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow"">http://www.tools4noobs.com/online_tools/encrypt/</a>) : YnF2BWFV9sw=
The Result that i get from android (With the same encryption algorithm &amp; Method) : YnF2BWFV9sw=</p>

<p>Here's the code on Android:</p>

<pre><code>public static String encryptDesECB(String data) {
    try {
        DESKeySpec keySpec = newDESKeySpec(""431654625bd37673e3b00359676154074a04666a"".getBytes(""UTF8""));
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
        SecretKey key = keyFactory.generateSecret(keySpec);

        // ENCODE plainTextPassword String
        byte[] cleartext = data.getBytes(""UTF8"");

        Cipher cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);

        Logger.log(Log.INFO, new String(cipher.doFinal(cleartext)));

        String encrypedPwd = Base64.encodeToString(cipher.doFinal(cleartext), Base64.DEFAULT);

        Logger.log(Log.INFO, encrypedPwd);

        return encrypedPwd;

    } catch (Exception e) {
        Logger.log(e);
        return null;
    }
}
</code></pre>

<p>Can anyone help me with this?</p>
","<p>I found my mistake. It turn out my BasicAuth Class isn't the correct one for encoding the encrypted string. Now I'm using the correct one Base64 Class for the encoding, and it turn out fine.</p>
","185","<java><encryption><blackberry-jde><des><ecb>","0","0","2","2015-01-23 09:55:32","","4","2","2559607","","2013-07-08 08:04:49","2013-07-08 07:14:27",""
"28799948","Incorrect returned cipher text with DES Implementation in Java","<p>For a small assignment I have been given to implement the DES algorithm without using predefined functions already in Java. I got it working, however the ciphered text returned is not correct. It returns 6C 17 96 35 BE 47 EF 95 when it should be AA 39 B9 77 7E FC 3C 14.  Any ideas where I went wrong?  </p>

<p><em>Follow-up; March 8</em></p>

<p>Following David Koontz's suggestion using <a href=""https://ia601704.us.archive.org/35/items/validatingcorrec00gait/validatingcorrec00gait.pdf/"" rel=""nofollow"">this manual</a> he linked me to. I believe that the encryption starts going awry around the subkey generation.</p>

<p><em>Follow-up; later March 8</em></p>

<p>Having been annoyed and reviewing each step of my code, I found out the problem.  In one of my for loops I used int j=0; i&lt;16; i++  instead of using j's.  Stupid mistake but no one found it either so oh well.  Corrected in the posted code.</p>

<pre><code>package des.implementation;
import java.nio.ByteBuffer;
public class DESImplementation {    
    private static final byte[] IP = { 
        58, 50, 42, 34, 26, 18, 10, 2,
        60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6,
        64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17, 9,  1,
        59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5,
        63, 55, 47, 39, 31, 23, 15, 7
    };
    private static final byte[] FP = {
        40, 8, 48, 16, 56, 24, 64, 32,
        39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30,
        37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28,
        35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26,
        33, 1, 41, 9, 49, 17, 57, 25
    };
    private static final byte[] E = {
        32, 1,  2,  3,  4,  5,
        4,  5,  6,  7,  8,  9,
        8,  9,  10, 11, 12, 13,
        12, 13, 14, 15, 16, 17,
        16, 17, 18, 19, 20, 21,
        20, 21, 22, 23, 24, 25,
        24, 25, 26, 27, 28, 29,
        28, 29, 30, 31, 32, 1
    };
    private static final byte[][] S = { {
        14, 4,  13, 1,  2,  15, 11, 8,  3,  10, 6,  12, 5,  9,  0,  7,
        0,  15, 7,  4,  14, 2,  13, 1,  10, 6,  12, 11, 9,  5,  3,  8,
        4,  1,  14, 8,  13, 6,  2,  11, 15, 12, 9,  7,  3,  10, 5,  0,
        15, 12, 8,  2,  4,  9,  1,  7,  5,  11, 3,  14, 10, 0,  6,  13
    }, {
        15, 1,  8,  14, 6,  11, 3,  4,  9,  7,  2,  13, 12, 0,  5,  10,
        3,  13, 4,  7,  15, 2,  8,  14, 12, 0,  1,  10, 6,  9,  11, 5,
        0,  14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3,  2,  15,
        13, 8,  10, 1,  3,  15, 4,  2,  11, 6,  7,  12, 0,  5,  14, 9
    }, {
        10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,
        13, 7,  0,  9,  3,  4,  6,  10, 2,  8,  5,  14, 12, 11, 15, 1,
        13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,
        1,  10, 13, 0,  6,  9,  8,  7,  4,  15, 14, 3,  11, 5,  2,  12
    }, {
        7,  13, 14, 3,  0,  6,  9,  10, 1,  2,  8,  5,  11, 12, 4,  15,
        13, 8,  11, 5,  6,  15, 0,  3,  4,  7,  2,  12, 1,  10, 14, 9,
        10, 6,  9,  0,  12, 11, 7,  13, 15, 1,  3,  14, 5,  2,  8,  4,
        3,  15, 0,  6,  10, 1,  13, 8,  9,  4,  5,  11, 12, 7,  2,  14
    }, {
        2,  12, 4,  1,  7,  10, 11, 6,  8,  5,  3,  15, 13, 0,  14, 9,
        14, 11, 2,  12, 4,  7,  13, 1,  5,  0,  15, 10, 3,  9,  8,  6,
        4,  2,  1,  11, 10, 13, 7,  8,  15, 9,  12, 5,  6,  3,  0,  14,
        11, 8,  12, 7,  1,  14, 2,  13, 6,  15, 0,  9,  10, 4,  5,  3
    }, {
        12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3,  4,  14, 7,  5,  11,
        10, 15, 4,  2,  7,  12, 9,  5,  6,  1,  13, 14, 0,  11, 3,  8,
        9,  14, 15, 5,  2,  8,  12, 3,  7,  0,  4,  10, 1,  13, 11, 6,
        4,  3,  2,  12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8,  13
    }, {
        4,  11, 2,  14, 15, 0,  8,  13, 3,  12, 9,  7,  5,  10, 6,  1,
        13, 0,  11, 7,  4,  9,  1,  10, 14, 3,  5,  12, 2,  15, 8,  6,
        1,  4,  11, 13, 12, 3,  7,  14, 10, 15, 6,  8,  0,  5,  9,  2,
        6,  11, 13, 8,  1,  4,  10, 7,  9,  5,  0,  15, 14, 2,  3,  12
    }, {
        13, 2,  8,  4,  6,  15, 11, 1,  10, 9,  3,  14, 5,  0,  12, 7,
        1,  15, 13, 8,  10, 3,  7,  4,  12, 5,  6,  11, 0,  14, 9,  2,
        7,  11, 4,  1,  9,  12, 14, 2,  0,  6,  10, 13, 15, 3,  5,  8,
        2,  1,  14, 7,  4,  10, 8,  13, 15, 12, 9,  0,  3,  5,  6,  11
    } };
    private static final byte[] P = {
        16, 7,  20, 21,
        29, 12, 28, 17,
        1,  15, 23, 26,
        5,  18, 31, 10,
        2,  8,  24, 14,
        32, 27, 3,  9,
        19, 13, 30, 6,
        22, 11, 4,  25
    };
    private static final byte[] PC1 = {
        57, 49, 41, 33, 25, 17, 9,
        1,  58, 50, 42, 34, 26, 18,
        10, 2,  59, 51, 43, 35, 27,
        19, 11, 3,  60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
        7,  62, 54, 46, 38, 30, 22,
        14, 6,  61, 53, 45, 37, 29,
        21, 13, 5,  28, 20, 12, 4
    };
    private static final byte[] PC2 = {
        14, 17, 11, 24, 1,  5,
        3,  28, 15, 6,  21, 10,
        23, 19, 12, 4,  26, 8,
        16, 7,  27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    };
    private static final byte[] rotations = {
        1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
    };
    private static int charToNibble(char c) {
        if (c&gt;='0' &amp;&amp; c&lt;='9') {
            return (c-'0');
        } else if (c&gt;='a' &amp;&amp; c&lt;='f') {
            return (10+c-'a');
        } else if (c&gt;='A' &amp;&amp; c&lt;='F') {
            return (10+c-'A');
        } else {
            return 0;
        }
    }
    private static byte[] parseBytes(String s) {
        s = s.replace("" "", """");
        byte[] ba = new byte[s.length()/2];
        if (s.length()%2 &gt; 0) { s = s+'0'; }
        for (int i=0; i&lt;s.length(); i+=2) {
            ba[i/2] = (byte) (charToNibble(s.charAt(i))&lt;&lt;4 | charToNibble(s.charAt(i+1)));
        }
        return ba;
    }
    private static long permute(byte[] table, int srcWidth, long src) {
        long dst = 0;
        for (int i=0; i&lt;table.length; i++) {
            int srcPos = srcWidth - table[i];
            dst = (dst&lt;&lt;1) | (src&gt;&gt;&gt;srcPos &amp; 0x01);
        }
        return dst;
    }
    private static byte[] longToBytes(long x) {
        ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
        buffer.putLong(x);
        return buffer.array();
    }   
    private static byte S(int boxNumber, byte src) {
        src = (byte) (src&amp;0x20 | ((src&amp;0x01)&lt;&lt;4) | ((src&amp;0x1E)&gt;&gt;&gt;1));
        return S[boxNumber-1][src];
    }
    private static int  P(int src)    { return (int)permute(P, 32, src&amp;0xFFFFFFFFL); }
    private static int feistel(int r, long subkey) {
        long e = permute(E, 32, r&amp;0xFFFFFFFFL);
        long x = e ^ subkey;
        int dst = 0;
        for (int i=0; i&lt;8; i++) {
            dst&gt;&gt;&gt;=4;
            int s = S(8-i, (byte)(x&amp;0x3F));
            dst |= s &lt;&lt; 28;
            x&gt;&gt;&gt;=6;
        }
        return P(dst);
    }
    private static long bytesToLong(byte[] bytes) {
        ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
        buffer.put(bytes);
        buffer.flip();
        return buffer.getLong();
    }
    public static void main(String[] args) {
        byte[] message = parseBytes(""0123456789ABCDEF"");
        byte[] key = parseBytes(""3b3898371520f75e"");
            byte[] ciphertext = new byte[message.length];
            for(int i=0; i&lt;message.length; i+=8){
                long Lmessage = bytesToLong(message);
                long Lkey = bytesToLong(key);
                        long subkeys[] = new long[16];
                        Lkey = permute(PC1, 64, Lkey);
                        int c = (int) (Lkey&gt;&gt;&gt;28);
                        int d = (int) (Lkey&amp;0x0FFFFFFF);
                        for (int j=0; j&lt;16; j++) {    //the problem was found here
                            if (rotations[j] == 1) {
                                c = ((c&lt;&lt;1) &amp; 0x0FFFFFFF) | (c&gt;&gt;&gt;27);
                                d = ((d&lt;&lt;1) &amp; 0x0FFFFFFF) | (d&gt;&gt;&gt;27);
                            } else {
                                c = ((c&lt;&lt;2) &amp; 0x0FFFFFFF) | (c&gt;&gt;&gt;26);
                                d = ((d&lt;&lt;2) &amp; 0x0FFFFFFF) | (d&gt;&gt;&gt;26);
                            }
                            long cd = (c&amp;0xFFFFFFFFL)&lt;&lt;28 | (d&amp;0xFFFFFFFFL);
                            subkeys[j] = permute(PC2, 56, cd);
                        }                     
                    long ip = permute(IP, 64, Lmessage);
                    int l = (int) (ip&gt;&gt;&gt;32);
                    int r = (int) (ip&amp;0xFFFFFFFFL);                       
                    for (int k=0; k&lt;16; k++) {
                        int previous_l = l;
                        l = r;
                        r = previous_l^feistel(r, subkeys[k]);
                    }
                    long rl = (r&amp;0xFFFFFFFFL)&lt;&lt;32 | (l&amp;0xFFFFFFFFL);
                    long fp =  permute(FP, 64, rl);
                    ciphertext = longToBytes(fp);
            }
        StringBuilder Message = new StringBuilder();
        StringBuilder Key = new StringBuilder();
        StringBuilder Cipher = new StringBuilder();
        for (int i=0; i&lt;ciphertext.length; i++) {
            Message.append(String.format(""%02X "",message[i]));
            Key.append(String.format(""%02X "",key[i]));
            Cipher.append(String.format(""%02X "",ciphertext[i]));
        }
        System.out.println(""Message: ""+Message.toString());
        System.out.println(""Key: ""+Key.toString());
        System.out.println(""Cipher: ""+Cipher.toString());
    }

}
</code></pre>
","<p>Having been annoyed and reviewing each step of my code, I found out the problem. In one of my for loops I used int j=0; i&lt;16; i++ instead of using j's. Stupid mistake but no one found it either so oh well. Corrected in the posted code.</p>
","185","<java><des>","1","1","1","2015-03-09 05:19:25","28935543","8","","4343868","","2015-03-09 05:19:25","2015-03-01 22:27:30",""
"41753233","PHP & JS mcrypt decryption not working","<p>I have the following code in Javascript to encrypt a string using a key:</p>

<p>des.js is this: <a href=""http://www.tero.co.uk/des/code.php"" rel=""nofollow noreferrer"">http://www.tero.co.uk/des/code.php</a></p>

<pre><code>&lt;script src=""/js/des.js""&gt;&lt;/script&gt;
&lt;script&gt;
var key = '12345678';
var message = 'hello world';

var ciph = des(key, message, 1, 0);
ciph = stringToHex(ciph);
console.log(""Encrypted Result: "" + ciph);
&lt;/script&gt; 
</code></pre>

<p>Then I send it server side and attempt to decrypt with this PHP code:</p>

<pre><code>$key = '12345678';
$hexa = '0x28dba02eb5f6dd476042daebfa59687a'; /This is the output from Javascript
$string = '';
for ($i=0; $i &lt; strlen($hexa)-1; $i+=2) {
$string .= chr(hexdec($hexa[$i].$hexa[$i+1])); }
echo mcrypt_decrypt(MCRYPT_DES, $key, $string, MCRYPT_MODE_ECB);
</code></pre>

<p>Ive tried converting it to utf8, changing encoding, changing the hex decoding, etc, but it always comes out gibberish, sometimes as nonreadable characters, other times as readable but nonsense.</p>
","<p>Data to be encrypted with a block cipher such as DES or AES must be an exact multiple of the block size in length. The solution is to add padding to the data to be encrypted, PKCS#5 padding is the usual padding for DES and probably the default for Javascript. Unfortunately mcrypt does not support PKCS#5 padding, only a non-standard zero padding.</p>

<p>Potential solutions:</p>

<ol>
<li>Use a better encryption function than mcrypt, see the comment to the question.</li>
<li>Specify no padding in Javascript and manually add zero padding.</li>
<li>Specify no padding in mcrypt and remove the padding manually.</li>
</ol>

<p>It is better tospecify all options and no to rely on defaults.</p>
","184","<javascript><php><encryption><mcrypt><des>","1","0","2","2017-01-19 23:49:22","41753713","3","1","1415724","","2017-01-19 23:49:22","2017-01-19 22:56:00",""
"41753233","PHP & JS mcrypt decryption not working","<p>I have the following code in Javascript to encrypt a string using a key:</p>

<p>des.js is this: <a href=""http://www.tero.co.uk/des/code.php"" rel=""nofollow noreferrer"">http://www.tero.co.uk/des/code.php</a></p>

<pre><code>&lt;script src=""/js/des.js""&gt;&lt;/script&gt;
&lt;script&gt;
var key = '12345678';
var message = 'hello world';

var ciph = des(key, message, 1, 0);
ciph = stringToHex(ciph);
console.log(""Encrypted Result: "" + ciph);
&lt;/script&gt; 
</code></pre>

<p>Then I send it server side and attempt to decrypt with this PHP code:</p>

<pre><code>$key = '12345678';
$hexa = '0x28dba02eb5f6dd476042daebfa59687a'; /This is the output from Javascript
$string = '';
for ($i=0; $i &lt; strlen($hexa)-1; $i+=2) {
$string .= chr(hexdec($hexa[$i].$hexa[$i+1])); }
echo mcrypt_decrypt(MCRYPT_DES, $key, $string, MCRYPT_MODE_ECB);
</code></pre>

<p>Ive tried converting it to utf8, changing encoding, changing the hex decoding, etc, but it always comes out gibberish, sometimes as nonreadable characters, other times as readable but nonsense.</p>
","<p>The way to decrypt the string is not working properly, try this:</p>

<pre><code>$key = '12345678';
$hexa = '0x28dba02eb5f6dd476042daebfa59687a'; 

function hexToString ($h) {
  $r = """";
 for ($i= (substr($h, 0, 2)==""0x"")?2:0; $i&lt;strlen($h); $i+=2) {$r .= chr (base_convert (substr ($h, $i, 2), 16, 10));}
return $r;
}

echo mcrypt_decrypt(MCRYPT_DES, $key,hexToString('0x28dba02eb5f6dd476042daebfa59687a'), MCRYPT_MODE_ECB);
</code></pre>

<p>The output will be: <strong>hello world</strong></p>

<p>This way work properly, however, you should search another method to encrypt your data, in your script the key (12345678) and your encrypt method is visible to everyone.</p>
","184","<javascript><php><encryption><mcrypt><des>","1","1","2","2017-01-19 23:49:22","41753713","3","1","1415724","","2017-01-19 23:49:22","2017-01-19 22:56:00",""
"16414786","Input another encryption into cbc mode","<p>Current I am using the block encryption DES to do CBC, I would like to include an option for user to use other block cipher such as Tiny Encryption. The output for tiny encryption is different from the DES classes i used hence i am unable to add this in. Anyone can give a little help here?</p>

<pre><code>private static int delta = 0x9E3779B9; /* a key schedule constant */
public void code(int[] v, int[] k) { 
int y=v[0], z=v[1], sum=0, n=32; 
int k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */
while (n-- &gt; 0) { 
 sum += delta; 
 y += ((z &lt;&lt; 4) + k0) ^ (z + sum) ^ ((z &gt;&gt;&gt; 5) + k1); 
 z += ((y &lt;&lt; 4) + k2) ^ (y + sum) ^ ((y &gt;&gt;&gt; 5) + k3); 
 } 
 v[0]=y; v[1]=z; 
 }   
</code></pre>

<p>```````````````````````````````````````````````````````````````````````````````````````````</p>

<pre><code>private static void cbc(byte [] raw_key, PrintStream ofstream) {
    byte [] cbc_ciphertext = null;
    byte [] IV = CryptoUtil.getIV();
    try {
        SecretKey key = new SecretKeySpec(raw_key, ""DES"");
        Cipher c = Cipher.getInstance (""DES/ECB/NoPadding"");
        c.init(Cipher.ENCRYPT_MODE, key);

        /* increment in 8-byte blocks through plaintext */
        for (int i = 0; i &lt; plaintext.length; i += 8) {
            byte [] block = CryptoUtil.getBlock(plaintext, i);
            if (i == 0)
                cbc_ciphertext = c.doFinal(CryptoUtil.xor (IV, block));
            else {
                ciphertext = CryptoUtil.append(ciphertext, cbc_ciphertext);
                cbc_ciphertext = 
                    c.doFinal(CryptoUtil.xor(cbc_ciphertext, block));
            }
        }
    }
    catch (Exception e) {
        e.printStackTrace();
        System.exit(1);
    }
    ciphertext = CryptoUtil.append (ciphertext, cbc_ciphertext);
    ciphertext = CryptoUtil.append (IV, ciphertext); 
    // ciphertext now has chained encrypted cipher blocks
    ofstream.print(CryptoUtil.encode(ciphertext));
    System.out.println(""encrypted ciphertext (DES/CBC) to "" +
                ""ciphertext.txt"");
}
</code></pre>
","","184","<java><encryption><des>","0","","0","2013-05-07 08:47:37","","3","","646591","","2013-05-07 08:47:37","2013-05-07 08:41:59",""
"40244840","C# Protect software","<p>I protect my software this way:</p>

<ol>
<li>Compare HDD and CPU serials with stored ones (I store them encrypted
in program user settings)</li>
<li>All data stored in DB encrypted by DES. DES key and IV I store in
windows registry.</li>
</ol>

<p>I understand what this way protection is weak and store key and IV in registry not a good idea. Please give me some advice to improve this protection.</p>
","<ol>
<li><p>Don't use DES, it is not secure and has been superseded decades ago by AES.</p></li>
<li><p>Do not use ECB mode, it is insecure, see  <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29"" rel=""nofollow"">ECB mode</a>, scroll down to the Penguin. Use CBC mode with an IV, see 3 below.</p></li>
<li><p>The IV should be a random string generated for each encryption, prepend it to the encrypted data for use during decryption—it does not need to be secret.</p></li>
</ol>
","179","<c#><protection><des>","-9","0","1","2016-10-25 17:35:31","40246245","3","","","","","2016-10-25 16:12:57","2016-10-26 11:13:35"
"15376147","DES: (Using sbox 2) to show that Two output bits from each S-box affect middle bits of the next round and the other two affect the end bits","<p>Data Encryption Standard (DES) algorithm : (Using sbox 2) to show that Two output bits from each S-box affect middle bits of the next round and the other two affect the end bits.</p>

<p>The permutation table P is defined in the following table. </p>

<pre><code>16   7   20  21 29  12  28  17 [END BITS]
1    15  23  26  5  18  31  10 [MIDDLE BITS]
2    8   24  14 32  27   3   9 [MIDDLE BITS]
19  13  30   6  22  11   4  25 [END BITS]
</code></pre>

<p>From the table above you can see that bits 7 and 6 refer to the end bits and 5 and 8 refer to the middle bits.</p>

<p>However am not sure if this is correct because if we consider E table the 5,6 are end bits and 7,8 affecting middle bit. What is correct  ?</p>
","<p>Don't fully understand the question but your first statement about bits 7,6,5 and 8 is true, but remember that the ""cascade effect"" will make all the changes made by the P-table will go to the ""right side"" of the equation; but at the same time these will interact in the next round in the left side!</p>

<p>To fully understand the process check out this link: <a href=""http://www.cronos.est.pr/DES.php"" rel=""nofollow"">http://www.cronos.est.pr/DES.php</a></p>
","176","<security><des>","2","1","1","2015-08-28 20:55:40","","0","","1155120","","2015-08-28 20:55:40","2013-03-13 02:48:11",""
"25647636","CXF - How can encrypt all fields in XML","<p>I've to connected a webservice that need to receive all fields (less one) encryted with 3DES.</p>

<p>How can I do that with an inteceptor, I don't want to do it at business level because all methods have field encryption.</p>

<p>Regards</p>
","<p>You can use WS-Security to encrypt parts of a JAX-WS request:</p>

<p><a href=""http://cxf.apache.org/docs/ws-security.html"" rel=""nofollow"">http://cxf.apache.org/docs/ws-security.html</a></p>

<p>WS-SecurityPolicy can also be used, and is more powerful as you can use regular expressions to define what you want to encrypt:</p>

<p><a href=""http://cxf.apache.org/docs/ws-securitypolicy.html"" rel=""nofollow"">http://cxf.apache.org/docs/ws-securitypolicy.html</a></p>

<p>If you have a JAX-RS service you can encrypt in CXF as well:</p>

<p><a href=""http://cxf.apache.org/docs/jax-rs-xml-security.html"" rel=""nofollow"">http://cxf.apache.org/docs/jax-rs-xml-security.html</a></p>

<p>Colm.</p>
","172","<web-services><encryption><cxf><des>","0","0","1","2014-09-04 08:11:56","","0","","3856173","","2014-09-03 15:23:47","2014-09-03 14:58:23",""
"5060213","DTO object design","<p>I have customer object contains his contact information,transaction details,address details.</p>

<p>Here how to design my DTO object to hold all the information.I am getting output as xml file.Here i want to map xml to dto object automatically.</p>

<p>Please give me any suggestions.</p>

<p>Regards,
Chaitu</p>
","<p>I don’t have enough details to give you a proper answer but I’ll try to give it a go. For what I have understood you need to map the customers details (XML based) to a kind of DTO object. I think a good solution could be deserialize  the customer XML to the DTO object you need to create. Have a look at</p>

<p><a href=""http://savagelook.com/blog/portfolio/quick-tip-deserializing-xml-to-objects-in-c"" rel=""nofollow"">http://savagelook.com/blog/portfolio/quick-tip-deserializing-xml-to-objects-in-c</a></p>

<p><a href=""http://www.codingday.com/xml-c-class-generator-for-c-using-xsd-for-deserialization/"" rel=""nofollow"">http://www.codingday.com/xml-c-class-generator-for-c-using-xsd-for-deserialization/</a></p>
","166","<design-patterns><des>","1","0","1","2011-06-03 10:29:39","6225905","3","2","","","","2011-02-20 21:35:14",""
"22326843","Java DES decryption exception in first try","<p>In my project, secure communication is used between android client and server so all messages between them are encrypted as DES algorithm.
I have used default Java Provider and also SpongyCastle but in first try of decryption, it gives the below exception.</p>

<pre><code>javax.crypto.IllegalBlockSizeException: last block incomplete in decryption
at org.spongycastle.jcajce.provider.symmetric.util.BaseBlockCipher.engineDoFinal(BaseBlockCipher.java:815)
at javax.crypto.Cipher.doFinal(Cipher.java:1111)
</code></pre>

<p>Encoded String below</p>

<pre><code>SB1DbM9MbtFYY62OtDwkU4+CxlHi7wj9MQIPVMsoktVyPZDoi79V2Hx5pzjLgQvxXKJSLP7BpNYZg4hlbVGzkCE8x4LTmTbdQzwweMjlOGfTbZSNA+iL1sx0ctRYFIVLu7c0ZnsSnJ4Fq2tdL2XS3YQW3/MokoAlyFK6lhBf/4t+VpZ/cy+s9g==
</code></pre>

<p>In the second try, it successfully decrypts String. I couldn't find the problem.</p>

<p>Source Code that Encrypt and Decrypt </p>

<pre><code>private Cipher encryptCipher = null;
private Cipher decryptCipher = null;

static {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
}

public void initialize(SecretKey key) throws Exception {
    try {
        encryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"", ""SC"");
        decryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"", ""SC"");
    } catch (Exception e) {
    }

    encryptCipher.init(Cipher.ENCRYPT_MODE, key);
    decryptCipher.init(Cipher.DECRYPT_MODE, key);
}

public String encryptBase64(String unencryptedString) throws Exception {
    byte[] unencryptedByteArray = unencryptedString.getBytes(""UTF-8"");
    byte[] encryptedBytes = encryptCipher.doFinal(unencryptedByteArray);
    return new String(Base64.encodeBase64(encryptedBytes), ""UTF-8"");
}

public String decryptBase64(String encryptedString) throws Exception {
    try {
        byte[] unencryptedByteArray = decryptCipher.doFinal(Base64.decodeBase64(encryptedString.getBytes(""UTF-8"")));
        String message = new String(unencryptedByteArray, ""UTF-8"");
        return message;
    } catch (Exception e) {
    }

    return null;
}
</code></pre>
","","166","<java><android><encryption><des><spongycastle>","0","","0","2014-03-11 15:18:55","","2","3","129474","","2014-03-11 15:18:55","2014-03-11 13:15:51",""
"26986381","Can someone explain the difference in openssl cli and c++ DES output","<p>Using openSSL, a program of mine is producing different encrypted output than openSSL's command line utility.  Using 'aaaaaa' as plain text and 'A' as the key, I've been running</p>

<pre><code>openssl enc -des -e -nosalt -in test1.txt -out test1out.txt
</code></pre>

<p>to get a sample encryption, but my sample program (<a href=""http://pastebin.com/e4P0DGYR"" rel=""nofollow"">http://pastebin.com/e4P0DGYR</a>) never produces the same hash.</p>

<p>To run the sample program, enter</p>

<pre><code>./a.out 40 42 $(hexdump -ve '1/1 ""%.2x""' test1.txt) $(hexdump -ve '1/1 ""%.2x""' test1out.txt)
</code></pre>

<p>I used this (<a href=""http://www.codealias.info/technotes/des_encryption_using_openssl_a_simple_example"" rel=""nofollow"">http://www.codealias.info/technotes/des_encryption_using_openssl_a_simple_example</a>) as an example.</p>
","<p>As someone answered when you posted this on the openssl-users mailing list, the CLI uses ECB mode and the program uses CFB mode. DES-ECB isn't the same as DEC-CFB (or any other mode).</p>
","165","<c++><encryption><openssl><des>","0","1","1","2014-11-19 02:45:00","27008062","0","","","","","2014-11-18 04:03:15",""
"55265750","Crypt function in simple C program not working","<p>I'm a NOOB, trying to figure out how to pass a word and a salt to the DES crypt function, and print out an encrypted (well, poorly encrypted) password. I have read the manual pages, and a few posts on here (regarding both cyppt and the crack problem set I'm working through), but am still unsure as to what my syntax needs to be per my code below, which has an 'undefined reference to crypt.' </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;crypt.h&gt;

#define _XOPEN_SOURCE

char *crypt(const char *key, const char *salt);

int main(void) {

    char *password = ""lol"";

    char *salt = ""50"";

    char *encrypted = crypt(password, salt);

    printf(""%s\n"", encrypted);
    return 0;
}

// should print 50cI2vYkF0YU2 per CS50 crack exercise example.
</code></pre>

<p>I've consulted the following before asking this question, and still don't understand how to get my simple example working.
<a href=""http://pubs.opengroup.org/onlinepubs/009695299/functions/crypt.html"" rel=""nofollow noreferrer"">http://pubs.opengroup.org/onlinepubs/009695299/functions/crypt.html</a>
<a href=""https://www.quora.com/How-does-the-crypt-function-work-with-some-examples-of-crypt-function-in-C"" rel=""nofollow noreferrer"">https://www.quora.com/How-does-the-crypt-function-work-with-some-examples-of-crypt-function-in-C</a>
<a href=""https://cs50.stackexchange.com/questions/23583/cs-des-based-crypt-function"">https://cs50.stackexchange.com/questions/23583/cs-des-based-crypt-function</a>
<a href=""https://stackoverflow.com/questions/21311397/crypt-function-in-c-not-working"">crypt() function in C not working</a></p>
","","164","<c><cs50><des><crypt>","0","","0","2019-04-18 06:11:44","","9","","15168","","2019-04-18 06:11:44","2019-03-20 16:29:49",""
"15349247","How insert encrypted value with DES into Postgresql DB?","<p>I am using pyDes and psycopg2 Python library for save encrypted password into a PostgreSql database. 
For a given password, the corresponding DES value is not printable. If i try to execute the following query</p>

<pre><code>INSERT INTO users (id,name,pwd,pass) VALUES ('0101','asino','asinello','?\xa5\x9aO\xbd\x10\xa3\x85\xfa6\xf8_\xfb\x91\x95\xe2')
</code></pre>

<p>I have the following error:
psycopg2.DataError: invalid byte sequence for encoding ""UTF8"": 0xa5</p>

<p>I tried to use repr function but it doesn't work.
I think the error is that the encrypted password is not recognized by the UTF8 encoding.
How can I insert this data into the database?</p>
","<ol>
<li>You shouldn't use DES for anything.  It is obsolete and recommended against.</li>
<li>You shouldn't store encrypted passwords unless you actually need to decrypt them.  For any sort of login system, you should use <code>bcrypt</code></li>
<li>Your <code>insert</code> problem is mostly likely due to the fact that you're trying to store the encrypted, binary, data.  You probably forgot to encode the encrypted value to a base64 string.</li>
</ol>
","160","<python><psycopg2><des>","0","0","1","2018-06-26 04:22:21","","1","","1033581","","2018-06-26 04:22:21","2013-03-11 21:42:38",""
"49699777","How to specify value of AlgorithmParameterSpec in java, for encryption and Decryption puropose, in DES","<p>My qustion is about how should I specify the custom value of AlgorithmParameterSpec in the below program? So that I could use the exact same output value for two different programs, one of which is Server and other is Client. Like I have used the fixed value for Key Generation, I want the same for this AlgorithmParameterSpec.
Client Code Snippet</p>

<pre><code>   ....
   String desKey = ""0123456789abcdef""; // value from user  
   byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);
   SecretKeyFactory factory = SecretKeyFactory.getInstance(""DES"");
   SecretKey key = factory.generateSecret(new DESKeySpec(keyBytes));


   AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);
   ....
</code></pre>

<p>Both client and server are on different pcs and are connected on same LAN. However I dont want to send any file from one to another, and neither do I want to write the value of that parameter from client into any file and use it in server. That has already caused too much problems. Is there a way to do this? Or I have to send this generated value from client to server using readUTF and writeUTF? </p>
","<ol>
<li><p>Original DES aka single-DES has been broken since last century, and should not be used.</p></li>
<li><p>In Java, instantiating plain <code>DES</code> like that defaults to <code>DES/ECB/PKCS5Padding</code> (in general Java treats PKCS5 padding as including PKCS7). ECB does not use an IV, and DES has no other parameters, so a java <code>Cipher</code> object for DES/ECB does not need or use any type of parameters object. However, in most applications, ECB mode even with a good cipher (not DES) is insecure and should not be used.</p></li>
<li><p>If you change to a more secure mode that <em>does</em> use an IV, like CTR CBC OFB CFB, or better in most applications but only supported in j8+ GCM, then <code>IvParameterSpec</code> is indeed the correct type to use. 
However, with modes that use an IV, using a fixed or otherwise duplicated IV is almost always insecure, so you must have a process that provides a unique IV for each encryption and the corresponding decryption(s). </p>

<p>This is often done by choosing a random IV when encrypting and transmitting and/or storing it along with the ciphertext (sometimes simply as the first part of the ciphertext) to be used when decrypting, but other designs that accomplish the same thing are possible. For CTR-based modes including GCM, especially when applied to a stream of traffic between the same parties, using a (scaled) counter provides uniqueness. For CBC the IVs must not only be unique but unpredictable; random is usually easiest for this but it is possible to use an encrypted counter.</p></li>
<li><p>Both key and IV (when used) should actually be bits not characters. However it is often convenient to represent them in characters using hex (as you did) or base64. Such character representations can be transmitted and received by a huge variety of methods, of which <code>DataInput/OutputStream</code> or <code>ObjectInput/OutputStream</code> is one among many. There are also many ways to transmit bits (binary) on all networks used in this century (although back in the 1970s and 1980s this was often problematical). Choosing among these may depend on what else your programs are doing and in particular whether they already use things like HTTP, XML, JSON, etc. </p></li>
</ol>
","160","<java><encryption><des><secret-key><javax>","0","0","1","2018-04-07 00:31:41","","2","","7474730","","2018-04-06 19:31:29","2018-04-06 19:26:09",""
"6465531","What should be the better way to implement DES encrypting and decrypting for a string?","<p>I have gone through theory of <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">DES</a> and also <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES</a>, and it seems better way to use <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES</a>. But I didn't find any help on <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES</a>, that I can implement in my android application. </p>

<p>So what should be better implementation of <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">DES</a> in my application. Can you share some links or codes for example, please?</p>
","<p>This may help</p>

<p><a href=""http://java.sun.com/developer/technicalArticles/Security/AES/AES_v1.html"" rel=""nofollow"">http://java.sun.com/developer/technicalArticles/Security/AES/AES_v1.html</a></p>
","159","<java><android><aes><des>","-2","1","2","2015-09-18 08:08:54","6465620","0","","635608","","2011-06-25 06:18:32","2011-06-24 08:53:47","2011-06-25 10:16:53"
"6465531","What should be the better way to implement DES encrypting and decrypting for a string?","<p>I have gone through theory of <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">DES</a> and also <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES</a>, and it seems better way to use <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES</a>. But I didn't find any help on <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES</a>, that I can implement in my android application. </p>

<p>So what should be better implementation of <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">DES</a> in my application. Can you share some links or codes for example, please?</p>
","<p>This is an <a href=""http://www.androidsnippets.com/encryptdecrypt-strings"" rel=""nofollow"">example</a> that implements AES on Android (using the <code>javax.crypto</code> package).</p>
","159","<java><android><aes><des>","-2","1","2","2015-09-18 08:08:54","6465620","0","","635608","","2011-06-25 06:18:32","2011-06-24 08:53:47","2011-06-25 10:16:53"
"30127333","Why do my two encrypted hex strings decrypt to the same string?","<p>I am trying to write a simple mcrypt tripledes encrypt and decrypt function (code below taken from <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">http://php.net/manual/en/function.mcrypt-encrypt.php</a> and modified).</p>

<pre><code>&lt;?php
class Cipher {
    private $securekey, $iv;
    private $val;
    function __construct($textkey) {
        $this-&gt;securekey = $textkey;                            
        $this-&gt;iv = mcrypt_create_iv(24);
    }

    function decrypt_hex($input){
        $bin = hex2bin($input);
        return trim(mcrypt_decrypt(""tripledes"", $this-&gt;securekey, $bin, MCRYPT_MODE_ECB, $this-&gt;iv));
    }

    function encrypt_hex($input){
        $this-&gt;val = mcrypt_encrypt(""tripledes"", $this-&gt;securekey, $input, MCRYPT_MODE_ECB, $this-&gt;iv);
        return strtoupper(bin2hex($this-&gt;val));
    }
}

$cipher = new Cipher('123456789012345678901234');

$text = ""2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D4B97BD1710125FFD"";
echo ""Decrypting ===== $text&lt;br/&gt;"";
$dec = $cipher-&gt;decrypt_hex($text);
echo ""Decrypted = $dec&lt;br/&gt;"";

$text = ""2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D72FD337F5B6B334B"";
echo ""Decrypting ===== $text&lt;br/&gt;"";
$dec = $cipher-&gt;decrypt_hex($text);
echo ""Decrypted = $dec&lt;br/&gt;"";

?&gt;
</code></pre>

<p>However, I find that the same string can be decrypted from two different encrypted hex strings (cases shown at the end of the code).</p>

<ol>
<li><p>Is this normal?</p></li>
<li><p>How many of such strings exists? How can I find?</p></li>
<li><p>There seem to be some hidden characters at the end of first decrypted string. They do not show up in html (<s>probably visible in the edit text mode</s>, cleaned up by html sanitizer :( ). Is that the difference?</p></li>
</ol>

<p>Output of above script in PHP 5.6.8:</p>

<pre><code>Decrypting ===== 2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D4B97BD1710125FFD
Decrypted = Beli IM3 085728317777 30000
Decrypting ===== 2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D72FD337F5B6B334B
Decrypted = Beli IM3 085728317777 30000
</code></pre>
","<p>They are different, try this: <code>var_dump($dec1 === $dec2);</code> which returns <strong>false</strong>.</p>

<p>Also <code>echo strlen($dec1);</code> returns <strong>32</strong> and <code>echo strlen($dec2);</code> returns <strong>27</strong>.</p>

<p>Update:
Found out, that they have different encodings. Thus they have different sizes:
<code>var_dump(mb_detect_encoding($dec1));</code> returns string(5) ""<strong>UTF-8</strong>"". When <code>var_dump(mb_detect_encoding($dec2));</code> returns string(5) ""<strong>ASCII</strong>"".</p>
","159","<php><encryption><mcrypt><des>","1","1","2","2015-05-08 16:55:25","","0","","439281","","2015-05-08 15:28:14","2015-05-08 15:19:48",""
"30127333","Why do my two encrypted hex strings decrypt to the same string?","<p>I am trying to write a simple mcrypt tripledes encrypt and decrypt function (code below taken from <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">http://php.net/manual/en/function.mcrypt-encrypt.php</a> and modified).</p>

<pre><code>&lt;?php
class Cipher {
    private $securekey, $iv;
    private $val;
    function __construct($textkey) {
        $this-&gt;securekey = $textkey;                            
        $this-&gt;iv = mcrypt_create_iv(24);
    }

    function decrypt_hex($input){
        $bin = hex2bin($input);
        return trim(mcrypt_decrypt(""tripledes"", $this-&gt;securekey, $bin, MCRYPT_MODE_ECB, $this-&gt;iv));
    }

    function encrypt_hex($input){
        $this-&gt;val = mcrypt_encrypt(""tripledes"", $this-&gt;securekey, $input, MCRYPT_MODE_ECB, $this-&gt;iv);
        return strtoupper(bin2hex($this-&gt;val));
    }
}

$cipher = new Cipher('123456789012345678901234');

$text = ""2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D4B97BD1710125FFD"";
echo ""Decrypting ===== $text&lt;br/&gt;"";
$dec = $cipher-&gt;decrypt_hex($text);
echo ""Decrypted = $dec&lt;br/&gt;"";

$text = ""2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D72FD337F5B6B334B"";
echo ""Decrypting ===== $text&lt;br/&gt;"";
$dec = $cipher-&gt;decrypt_hex($text);
echo ""Decrypted = $dec&lt;br/&gt;"";

?&gt;
</code></pre>

<p>However, I find that the same string can be decrypted from two different encrypted hex strings (cases shown at the end of the code).</p>

<ol>
<li><p>Is this normal?</p></li>
<li><p>How many of such strings exists? How can I find?</p></li>
<li><p>There seem to be some hidden characters at the end of first decrypted string. They do not show up in html (<s>probably visible in the edit text mode</s>, cleaned up by html sanitizer :( ). Is that the difference?</p></li>
</ol>

<p>Output of above script in PHP 5.6.8:</p>

<pre><code>Decrypting ===== 2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D4B97BD1710125FFD
Decrypted = Beli IM3 085728317777 30000
Decrypting ===== 2BF8F771E6FAE998AAE0C126B3FDD1994046C0498645E35D72FD337F5B6B334B
Decrypted = Beli IM3 085728317777 30000
</code></pre>
","<p>You've only changed the end of the ciphertext. This holds the last block of encrypted plaintext. However, usually the plaintext doesn't end on a block boundary. In that case PHP will perform zero padding until a block boundary is reached. These zero bytes are removed by the <code>trim</code> function (you should use <code>rtrim</code> and only remove <code>\0</code> bytes).</p>

<p>Now if you change the bytes of the last block then the decrypt will result in random bytes. That block may start - by chance - with the same characters, followed by any other - possibly unprintable - characters. In that case the string printed on screen may display the same.</p>

<p>You should really:</p>

<ul>
<li>use AES (<code>MCRYPT_RIJNDAEL_128</code>);</li>
<li>perform PKCS#7 compatible padding;</li>
<li>use CBC mode encryption with a random IV;</li>
<li>prefix that IV to the ciphertext;</li>
<li>add an authentication tag (using HMAC-SHA-1);</li>
<li>possibly encode the IV + ciphertext + tag.</li>
</ul>
","159","<php><encryption><mcrypt><des>","1","3","2","2015-05-08 16:55:25","","0","","439281","","2015-05-08 15:28:14","2015-05-08 15:19:48",""
"30035313","DES ciphertext length decreased during transmission and is not a multiple of 8 bytes","<p>For a project a try to encrypt a pwd with DES algorithm. </p>

<p>When I try this </p>

<pre><code>    private static String key = ""my8bcode""; /*Key 8 bytes or 56 bit supported by algo OF*/
    private static byte[] byteKey = key.getBytes(); 

    public static void main(String[] args) throws Exception {
          String ss = ""yuyuvdzdsfdsfsdsdsdsdsa"";
          byte[] plainText = ss.getBytes();//Conversion en byte

        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""DES"");

            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding""); // Request the use of the DES algorithm, using the ECB mode (Electronic CodeBook) and style padding PKCS-5.
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            byte[] myCipherText = cipher.doFinal(plainText);
            System.out.println(new String(myCipherText, ""UTF8""));
            System.out.println(myCipherText.length);

             System.out.println(""\nStart decryption"");
             cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
             byte[] newPlainText = cipher.doFinal(myCipherText);
             System.out.println(new String(newPlainText, ""UTF8""));
        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre>

<p>I have no problems, but to go further, i try to do this  in two separate steps with this code :</p>

<pre><code>    try {
        SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""DES"");

        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding""); //Request the use of the DES algorithm, using the ECB mode (Electronic CodeBook) and style padding PKCS-5.
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] myCipherText = cipher.doFinal(plainText);
        byte[] test = (new String(myCipherText, ""UTF8"")).getBytes();

         System.out.println(""\nStart decryption"");
         cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
         byte[] newPlainText = cipher.doFinal(test);
         System.out.println(new String(newPlainText, ""UTF8""));
    } catch (Exception e) {
        e.printStackTrace();
    }
</code></pre>

<p>It doesn't work, i have this message in my console :</p>

<blockquote>
  <p>javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 </p>
</blockquote>

<p>Indeed, the length of test[] is 7 and not 8. How is possible ?</p>

<p>Why did I lose a byte during my transcription?</p>

<p>Help me please to understand and to solve my problem ;)</p>
","<p><code>byte[]</code> and <code>String</code> should be kept apart. The main error is that a random sequence of bytes (the encrypted text) might easily be <strong>incorrect UTF-8</strong>. UTF-8 is a multi-byte format, where high bits mark a multi-byte sequence in a specified way, <code>10xxxxxx</code> being a continuation byte for instance.</p>

<p>However to encrypt a String (Unicode) it is very appropriate to use UTF-8. A single byte encoding would be lossy; say if the text contained both Greek and Bulgarian.</p>

<pre><code>byte[] data = text.getBytes(StandardCharsets.UTF_8);
text = new String(data, StandardCharsets.UTF_8);
</code></pre>

<p>These are the overloaded versions from the <code>String</code> constructor and <code>getBytes</code> method, with charset specified. Otherwise it is platform dependent, hence disastrous in communication to another computer.</p>

<p>But as soon as you have binary data, <code>byte[]</code>, do not convert it to (Unicode) String, which <em>is</em> a (costly) <em>conversion</em>, redundant and error prone.</p>

<p>Hence one often sees an additional conversion of the binary data to Base64, receiving a longer ASCII string.</p>
","158","<java><encryption><byte><des>","1","1","2","2015-05-05 08:08:55","30035896","4","2","1816580","","2015-05-04 19:10:26","2015-05-04 16:41:52","2015-05-05 07:49:53"
"30035313","DES ciphertext length decreased during transmission and is not a multiple of 8 bytes","<p>For a project a try to encrypt a pwd with DES algorithm. </p>

<p>When I try this </p>

<pre><code>    private static String key = ""my8bcode""; /*Key 8 bytes or 56 bit supported by algo OF*/
    private static byte[] byteKey = key.getBytes(); 

    public static void main(String[] args) throws Exception {
          String ss = ""yuyuvdzdsfdsfsdsdsdsdsa"";
          byte[] plainText = ss.getBytes();//Conversion en byte

        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""DES"");

            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding""); // Request the use of the DES algorithm, using the ECB mode (Electronic CodeBook) and style padding PKCS-5.
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            byte[] myCipherText = cipher.doFinal(plainText);
            System.out.println(new String(myCipherText, ""UTF8""));
            System.out.println(myCipherText.length);

             System.out.println(""\nStart decryption"");
             cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
             byte[] newPlainText = cipher.doFinal(myCipherText);
             System.out.println(new String(newPlainText, ""UTF8""));
        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre>

<p>I have no problems, but to go further, i try to do this  in two separate steps with this code :</p>

<pre><code>    try {
        SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""DES"");

        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding""); //Request the use of the DES algorithm, using the ECB mode (Electronic CodeBook) and style padding PKCS-5.
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] myCipherText = cipher.doFinal(plainText);
        byte[] test = (new String(myCipherText, ""UTF8"")).getBytes();

         System.out.println(""\nStart decryption"");
         cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
         byte[] newPlainText = cipher.doFinal(test);
         System.out.println(new String(newPlainText, ""UTF8""));
    } catch (Exception e) {
        e.printStackTrace();
    }
</code></pre>

<p>It doesn't work, i have this message in my console :</p>

<blockquote>
  <p>javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 </p>
</blockquote>

<p>Indeed, the length of test[] is 7 and not 8. How is possible ?</p>

<p>Why did I lose a byte during my transcription?</p>

<p>Help me please to understand and to solve my problem ;)</p>
","<p>I just do that (delete UTF 8 specifications) and after lots of test it's working :</p>

<pre><code>try {

            SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""DES"");



            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding""); //Demande l'utilisation de l'algorithme DES, en utilisant le mode ECB (Electronic CodeBook) et le style de padding PKCS-5.
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            byte[] myCipherText = cipher.doFinal(plainText);
            byte[] test = (new String(myCipherText)).getBytes();


             cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
             byte[] newPlainText = cipher.doFinal(test);
             System.out.println(new String(newPlainText));

        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre>

<p>Thanks a lot </p>
","158","<java><encryption><byte><des>","1","0","2","2015-05-05 08:08:55","30035896","4","2","1816580","","2015-05-04 19:10:26","2015-05-04 16:41:52","2015-05-05 07:49:53"
"31720188","java DES encrypt code convert to ruby","<p>Hi I have a java android encrypt method, and want to convert to ruby code.</p>

<pre><code>IvParameterSpec localIvParameterSpec = new IvParameterSpec(new byte[] { 12, 34, 34, 11, 64, 23, 89, 27 });

DESKeySpec localDESKeySpec = new DESKeySpec(paramString2.getBytes());

SecretKey localSecretKey = SecretKeyFactory.getInstance(""DES"").generateSecret(localDESKeySpec);

Cipher localCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

localCipher.init(1, localSecretKey, localIvParameterSpec);

return new String(Base64.encode(localCipher.doFinal(paramString1.getBytes()), 0));
</code></pre>

<p>and I google some useful articles, but still could not get the same output.
So anyone know the ruby code as above java code? </p>

<p>Thx!</p>
","<pre><code>des = OpenSSL::Cipher::Cipher.new(""DES-CBC"")
des.encrypt
des.key = ""xxxx""
des.iv = ""xxxx""
cipher = des.update(str) + des.final
Base64.strict_encode64(cipher)
</code></pre>
","156","<ruby><encryption><openssl><des>","-1","0","1","2015-09-01 05:48:08","32324361","2","2","109450","","2015-07-30 11:49:53","2015-07-30 09:37:13",""
"11161499","Migrate AIX 5.3 crypt function to C#","<p>I have a project that was on an old AIX system and we are migrating it to a new windows server system. I am trying to get a authentication system setup but I can't seem to match the way the password encryption was being created.</p>

<p>Can C# mimic the AIX <a href=""http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/crypt.htm"" rel=""nofollow"">crypt</a> function? I understand the function uses a form of DES, but I can't seem to set up the C# DES to match the outputs of the AIX crypt. </p>
","<p>A quick search for an implementation of the generic unix <code>crypt()</code> seems to point to an implementation at <a href=""http://www.codeproject.com/Articles/9183/A-C-implementation-of-Unix-crypt"" rel=""nofollow"">code project</a>.</p>

<p>Note that this is just the generic Unix <code>crypt()</code> that AIX tries to emulate. It would be a good idea to test it against AIX code first, keeping in mind the specific encoding (character) encoding of the input and output parameters.</p>
","155","<c#><.net><encryption><aix><des>","0","1","1","2012-06-24 11:41:52","11177149","2","0","","","","2012-06-22 17:46:42",""
"32742846","Size of DES encrypted text","<p>I'm using this code for DES encryption:
<a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a></p>

<p>I'm encrypting byte array of size 8. As far as I know, it should result in encrypted data of size 8. But the result is 16 bytes.</p>

<p>I've done necessary edits in the code to do DES encryption of byte array. Like changed the algo name to DES (than DEDede), key size of 8 bytes (than 24) etc.</p>
","<p>DES has a block size of 64 bit or 8 byte. Modes of operations like CBC and ECB are block based, but in order to encrypt plaintexts of arbitrary it is necessary to use a padding scheme like PKCS#5/PKCS#7 paddings to pad the arbitrary plaintext to the next multiple of the block size.</p>

<p>The padding itself contains the information how many bytes where added for PKCS#5 padding. Since 8 byte is already a multiple of the block size, a full padding block is added. It this weren't the case, you would be able to reliably disambiguate plaintext and padding after decryption.</p>
","153","<java><encryption><padding><des>","0","2","1","2015-09-23 15:00:50","32743033","0","","-1","","2017-05-23 11:44:48","2015-09-23 14:52:19",""
"3242056","What is wrong with my DESKey (BlackBerry API)?","<p>I have an application developed on BlackBerry JE 4.6.1 that decrypts an information from WebServer using DES algorythm. 
If I send encrypted information to the server, it is decrypted well. But in case if the server sends an encrypted data, 
I do not get the correct value after decryption.
Key is supposed to be the same and crypted information is sent base64 encoded.
During debugging I have found out, that after DESKey is created it's inner data differs from the byte array passed to the constructor.
For example if I create the DESKey the next way</p>

<pre><code>String keyStr = ""2100000A"";
DESKey desKey = new DESKey(keyStr.getBytes()); // pass the byte array {'2','1','0','0','0','0','0','A'}
</code></pre>

<p>the method desKey.getData() returns the byte array {'2','1','1','1','1','1','1','@'} that differs from the initial key bytes.</p>

<p>So is it possible for such behavior of the DESKey to be the reason why I can not decrypt data from server? </p>

<p>Thank you.</p>
","<p>The desKey.getData() behaviour is expected. </p>

<p>The <a href=""http://www.blackberry.com/developers/docs/4.7.0api/net/rim/device/api/crypto/DESDecryptorEngine.html"" rel=""nofollow noreferrer"">doc</a> states:</p>

<blockquote>
  <p>DES operates on 64 bit blocks and has
  an effective key length of 56 bits. In
  reality, the key is 64 bits but there
  are 8 bits of parity used which means
  that the effective key length is only
  56 bits. Every eighth bit is used for
  parity and it is the least significant
  bit that is used for parity.</p>
</blockquote>

<p>Parity bit <a href=""http://en.wikipedia.org/wiki/Parity_bit"" rel=""nofollow noreferrer"">definition</a>:</p>

<blockquote>
  <p>A parity bit, or check bit, is a bit that is added to ensure that the number of bits with the value one in a set of bits is even or odd. Parity bits are used as the simplest form of error detecting code.</p>
</blockquote>

<p>So, this is how it happens:</p>

<pre><code>'2' =&gt; 0x32 =&gt; 00110010 =&gt; 0011001 + (parity bit 0) =&gt; 00110010 =&gt; 0x32 =&gt; '2'
'1' =&gt; 0x31 =&gt; 00110001 =&gt; 0011000 + (parity bit 1) =&gt; 00110001 =&gt; 0x31 =&gt; '1'
'0' =&gt; 0x30 =&gt; 00110000 =&gt; 0011000 + (parity bit 1) =&gt; 00110001 =&gt; 0x31 =&gt; '1'
'0' =&gt; 0x30 =&gt; 00110000 =&gt; 0011000 + (parity bit 1) =&gt; 00110001 =&gt; 0x31 =&gt; '1'
'0' =&gt; 0x30 =&gt; 00110000 =&gt; 0011000 + (parity bit 1) =&gt; 00110001 =&gt; 0x31 =&gt; '1'
'0' =&gt; 0x30 =&gt; 00110000 =&gt; 0011000 + (parity bit 1) =&gt; 00110001 =&gt; 0x31 =&gt; '1'
'0' =&gt; 0x30 =&gt; 00110000 =&gt; 0011000 + (parity bit 1) =&gt; 00110001 =&gt; 0x31 =&gt; '1'
'A' =&gt; 0x41 =&gt; 01000001 =&gt; 0100000 + (parity bit 0) =&gt; 01000000 =&gt; 0x40 =&gt; '@'
</code></pre>
","153","<blackberry><encryption><des>","0","0","1","2012-10-25 07:42:32","3696552","0","","247013","","2012-10-25 07:39:20","2010-07-13 22:25:37",""
"45373191","Using ntlm authentication in Nativescript ios platform","<p>I am building an app with authenticates the user against a sharepoint site which uses NTLM authentication. I found the ntlm.js which has been patched for nativescript here <a href=""https://github.com/hdeshev/nativescript-ntlm-demo"" rel=""nofollow noreferrer"">https://github.com/hdeshev/nativescript-ntlm-demo</a>.</p>

<p>I have managed to get it working for android platform, but it fails on ios showing an 401 error. As far as I can tell, the difference happens in this segment:</p>

<pre><code>Ntlm.setCredentials = function(domain, username, password) {
    var magic = 'KGS!@#$%'; // Create LM password hash.
    var lmPassword = password.toUpperCase().substr(0, 14);
    while (lmPassword.length &lt; 14) lmPassword += '\0';
    var key1 = Ntlm.createKey(lmPassword);
    var key2 = Ntlm.createKey(lmPassword.substr(7));
    var lmHashedPassword = des(key1, magic, 1, 0) + des(key2, magic, 1, 0);
    var ntPassword = ''; // Create NT password hash.
    for (var i = 0; i &lt; password.length; i++)
        ntPassword += password.charAt(i) + '\0';
    var ntHashedPassword = str_md4(ntPassword);
    Ntlm.domain = domain;
    Ntlm.username = username;
    Ntlm.lmHashedPassword = lmHashedPassword;
    Ntlm.ntHashedPassword = ntHashedPassword;
};
</code></pre>

<p>When I log the result of 'lmhashedPassword' after going through the <code>des()</code> function, it simply returns 'A'. Whereas on android, it returns a longer string. Something in the <code>des</code> function must be cutting it off, but I cannot see what. </p>

<p>Here is the <code>des</code> function: </p>

<pre><code>function des (key, message, encrypt, mode, iv, padding) {
    //declaring this locally speeds things up a bit
    var spfunction1 = new Array (0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004);
    var spfunction2 = new Array (-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000);
    var spfunction3 = new Array (0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200);
    var spfunction4 = new Array (0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080);
    var spfunction5 = new Array (0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100);
    var spfunction6 = new Array (0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010);
    var spfunction7 = new Array (0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002);
    var spfunction8 = new Array (0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000);

    //create the 16 or 48 subkeys we will need
    var keys = des_createKeys (key);
    var m=0, i, j, temp, temp2, right1, right2, left, right, looping;
    var cbcleft, cbcleft2, cbcright, cbcright2
    var endloop, loopinc;
    var len = message.length;
    var chunk = 0;
    //set up the loops for single and triple des
    var iterations = keys.length == 32 ? 3 : 9; //single or triple des
    if (iterations == 3) {looping = encrypt ? new Array (0, 32, 2) : new Array (30, -2, -2);}
    else {looping = encrypt ? new Array (0, 32, 2, 62, 30, -2, 64, 96, 2) : new Array (94, 62, -2, 32, 64, 2, 30, -2, -2);}

    //pad the message depending on the padding parameter
    if (padding == 2) message += ""        ""; //pad the message with spaces
    else if (padding == 1) {temp = 8-(len%8); message += String.fromCharCode (temp,temp,temp,temp,temp,temp,temp,temp); if (temp==8) len+=8;} //PKCS7 padding
    else if (!padding) message += ""\0\0\0\0\0\0\0\0""; //pad the message out with null bytes

    //store the result here
    result = """";
    tempresult = """";

    if (mode == 1) { //CBC mode
        cbcleft = (iv.charCodeAt(m++) &lt;&lt; 24) | (iv.charCodeAt(m++) &lt;&lt; 16) | (iv.charCodeAt(m++) &lt;&lt; 8) | iv.charCodeAt(m++);
        cbcright = (iv.charCodeAt(m++) &lt;&lt; 24) | (iv.charCodeAt(m++) &lt;&lt; 16) | (iv.charCodeAt(m++) &lt;&lt; 8) | iv.charCodeAt(m++);
        m=0;
    }

    //loop through each 64 bit chunk of the message
    while (m &lt; len) {
        left = (message.charCodeAt(m++) &lt;&lt; 24) | (message.charCodeAt(m++) &lt;&lt; 16) | (message.charCodeAt(m++) &lt;&lt; 8) | message.charCodeAt(m++);
        right = (message.charCodeAt(m++) &lt;&lt; 24) | (message.charCodeAt(m++) &lt;&lt; 16) | (message.charCodeAt(m++) &lt;&lt; 8) | message.charCodeAt(m++);

        //for Cipher Block Chaining mode, xor the message with the previous result
        if (mode == 1) {if (encrypt) {left ^= cbcleft; right ^= cbcright;} else {cbcleft2 = cbcleft; cbcright2 = cbcright; cbcleft = left; cbcright = right;}}

        //first each 64 but chunk of the message must be permuted according to IP
        temp = ((left &gt;&gt;&gt; 4) ^ right) &amp; 0x0f0f0f0f; right ^= temp; left ^= (temp &lt;&lt; 4);
        temp = ((left &gt;&gt;&gt; 16) ^ right) &amp; 0x0000ffff; right ^= temp; left ^= (temp &lt;&lt; 16);
        temp = ((right &gt;&gt;&gt; 2) ^ left) &amp; 0x33333333; left ^= temp; right ^= (temp &lt;&lt; 2);
        temp = ((right &gt;&gt;&gt; 8) ^ left) &amp; 0x00ff00ff; left ^= temp; right ^= (temp &lt;&lt; 8);
        temp = ((left &gt;&gt;&gt; 1) ^ right) &amp; 0x55555555; right ^= temp; left ^= (temp &lt;&lt; 1);

        left = ((left &lt;&lt; 1) | (left &gt;&gt;&gt; 31));
        right = ((right &lt;&lt; 1) | (right &gt;&gt;&gt; 31));

        //do this either 1 or 3 times for each chunk of the message
        for (j=0; j&lt;iterations; j+=3) {
            endloop = looping[j+1];
            loopinc = looping[j+2];
            //now go through and perform the encryption or decryption
            for (i=looping[j]; i!=endloop; i+=loopinc) { //for efficiency
                right1 = right ^ keys[i];
                right2 = ((right &gt;&gt;&gt; 4) | (right &lt;&lt; 28)) ^ keys[i+1];
                //the result is attained by passing these bytes through the S selection functions
                temp = left;
                left = right;
                right = temp ^ (spfunction2[(right1 &gt;&gt;&gt; 24) &amp; 0x3f] | spfunction4[(right1 &gt;&gt;&gt; 16) &amp; 0x3f]
                    | spfunction6[(right1 &gt;&gt;&gt;  8) &amp; 0x3f] | spfunction8[right1 &amp; 0x3f]
                    | spfunction1[(right2 &gt;&gt;&gt; 24) &amp; 0x3f] | spfunction3[(right2 &gt;&gt;&gt; 16) &amp; 0x3f]
                    | spfunction5[(right2 &gt;&gt;&gt;  8) &amp; 0x3f] | spfunction7[right2 &amp; 0x3f]);
            }
            temp = left; left = right; right = temp; //unreverse left and right
        } //for either 1 or 3 iterations

        //move then each one bit to the right
        left = ((left &gt;&gt;&gt; 1) | (left &lt;&lt; 31));
        right = ((right &gt;&gt;&gt; 1) | (right &lt;&lt; 31));

        //now perform IP-1, which is IP in the opposite direction
        temp = ((left &gt;&gt;&gt; 1) ^ right) &amp; 0x55555555; right ^= temp; left ^= (temp &lt;&lt; 1);
        temp = ((right &gt;&gt;&gt; 8) ^ left) &amp; 0x00ff00ff; left ^= temp; right ^= (temp &lt;&lt; 8);
        temp = ((right &gt;&gt;&gt; 2) ^ left) &amp; 0x33333333; left ^= temp; right ^= (temp &lt;&lt; 2);
        temp = ((left &gt;&gt;&gt; 16) ^ right) &amp; 0x0000ffff; right ^= temp; left ^= (temp &lt;&lt; 16);
        temp = ((left &gt;&gt;&gt; 4) ^ right) &amp; 0x0f0f0f0f; right ^= temp; left ^= (temp &lt;&lt; 4);

        //for Cipher Block Chaining mode, xor the message with the previous result
        if (mode == 1) {if (encrypt) {cbcleft = left; cbcright = right;} else {left ^= cbcleft2; right ^= cbcright2;}}
        tempresult += String.fromCharCode ((left&gt;&gt;&gt;24), ((left&gt;&gt;&gt;16) &amp; 0xff), ((left&gt;&gt;&gt;8) &amp; 0xff), (left &amp; 0xff), (right&gt;&gt;&gt;24), ((right&gt;&gt;&gt;16) &amp; 0xff), ((right&gt;&gt;&gt;8) &amp; 0xff), (right &amp; 0xff));

        chunk += 8;
        if (chunk == 512) {result += tempresult; tempresult = """"; chunk = 0;}
    } //for every 8 characters, or 64 bits in the message

    //return the result as an array
    return result + tempresult;
} //end of des
</code></pre>

<p>In case it may be relevant, I have changed the way the request is made too. When the user clicks login, the following promise is called:</p>

<pre><code>Ntlm.login('url')
            .then(() =&gt; {
                console.log('Success');
                appSettings.setString('token', 'abc123');
                this.router.navigate(['/ilt']);
            })
            .catch(error =&gt; {
                console.log('Failed');
                appSettings.remove('token');
                alert('Failed! ' + error );
            })
</code></pre>

<p>I created a new login function in the ntlm.js file:</p>

<pre><code>Ntlm.login = function(url) {

    return new Promise((resolve, reject) =&gt; {
        if (!Ntlm.domain || !Ntlm.username || !Ntlm.lmHashedPassword || !Ntlm.ntHashedPassword) {

            Ntlm.error('No NTLM credentials specified. Use Ntlm.setCredentials(...) before making calls.');
        }
        var hostname = Ntlm.getLocation(url).hostname;
        var msg1 = Ntlm.createMessage1(hostname);
        var request = new XMLHttpRequest();

        request.onload = function() {
            var response = request.getResponseHeader('WWW-Authenticate');
            var challenge = Ntlm.getChallenge(response);

            var msg3 = Ntlm.createMessage3(challenge, hostname);
            request.open('GET', url, false);
            var authorization = 'NTLM ' + msg3.toBase64();
            request.setRequestHeader('Authorization', authorization);

            request.onload = function() {
                if (request.readyState == 4 &amp;&amp; request.status == 200) {
                    resolve(request.status);
                }
                else if (request.readyState == 4 &amp;&amp; request.status != 200) {
                    reject(request.status);
                }
            };
            request.send(null);
        };
        request.open('GET', url, false);
        request.setRequestHeader('Authorization', 'NTLM ' + msg1.toBase64());
        request.send(null);   
    })

};
</code></pre>

<p>This is all working fine on the Android version, just cant understand why it isnt on ios. Very frustrating! If anyone can make sense of this, I would be eternally grateful. I realise it is a lot of code and quite niche area!</p>

<p>Many thanks,</p>

<hr>

<p>UPDATE</p>

<p>I think there may be a difference in the way console.log behaves in Android and iOS, which could explain some of the missing characters. I created a new test account (testuser / testing), and logged various points to try and establish what was happening in the NTLM process step by step. Here are the logs for android:</p>

<pre><code>NTLM WALKTHROUGH ON ANDROID

Step 1: Creates a cryptographic hash of the users password:
lmHashedPassword = -UE}{}*ªÓ´5µî
ntHashedPassword = |SÏ¥ê}�;�� ûQ£õ

Step 2: Sends first request to the server, with the following Authorisation header:
NTLM TlRMTVNTUAABAAAAA7IAAAUABQBEAAAAJAAkACAAAABHQVRFV0FZLlNUUEFVTFNDQVRIT0xJQ0NPTExFR0UuQ08uVUtBRE1JTg==

Step 3: Server sends a challenge back to client:
¡2@�³Q%Ï

Step 4: Client encrypts this challenge with the hash of the users password and sends back to server (response).
The Authorization header is: NTLM TlRMTVNTUAADAAAAGAAYAKQAAAAYABgAvAAAAAoACgBAAAAAEgASAEoAAABIAEgAXAAAAAAAAADUAAAAAYIAAEEARABNAEkATgB0AGUAcwB0AHMAdABhAGYAZgBHAEEAVABFAFcAQQBZAC4AUwBUAFAAQQBVAEwAUwBDAEEAVABIAE8ATABJAEMAQwBPAEwATABFAEcARQAuAEMATwAuAFUASwBsEslcvTQhhY3+RgKtqufBzFrmufFKNkAHXJRcA6ThOAU105+NJBGnsn2ri6Ziuv8=

Step 5: Now the server has sent the username, challenge and response to the Domain Controller.
The DC compares and returns status of: 200
</code></pre>

<p>Here are the logs for iOS:</p>

<pre><code>NTLM WALKTHROUGH ON IOS

Step 1: Creates a cryptographic hash of the users password:
lmHashedPassword = -UE}{}*ªÓ´5µî
ntHashedPassword = |SÏ¥ê}�;�� ûQ£õ

Step 2: Sends the first request to the server, with the following Authorisation header:
NTLM TlRMTVNTUAABAAAAA7IAAAUABQBEAAAAJAAkACAAAABHQVRFV0FZLlNUUEFVTFNDQVRIT0xJQ0NPTExFR0UuQ08uVUtBRE1JTg==

Step 3: Server sends a challenge back to client:
q�v¹,

Step 4: Client encrypts this challenge with the hash of the users password and sends back to server (response).
The Authorization header is: NTLM TlRMTVNTUAADAAAAGAAYAKQAAAAYABgAvAAAAAoACgBAAAAAEgASAEoAAABIAEgAXAAAAAAAAADUAAAAAYIAAEEARABNAEkATgB0AGUAcwB0AHMAdABhAGYAZgBHAEEAVABFAFcAQQBZAC4AUwBUAFAAQQBVAEwAUwBDAEEAVABIAE8ATABJAEMAQwBPAEwATABFAEcARQAuAEMATwAuAFUASwAP9HN5WjPCs9hMRrmttnYHieFrThwyUAWanKWtVdzOqDOJ2isUdQeV0ISmv9TT0ek=

Step 5: Now the server has sent the username, challenge and response to the Domain Controller.
The DC compares returns status of: 401
</code></pre>

<p>Seems the credentials are worked out the same, and then the challenge returned from the server is random. But on iOS, the challenge seems to be missing characters - possibly due to the type of characters. The client then encrypts the challenge with the hashed passwords and sends back to the server. I imagine it might be this part which is not correct on iOS. </p>
","","152","<javascript><ios><nativescript><ntlm><des>","3","","0","2017-08-09 07:36:47","","2","","2210482","","2017-08-09 07:36:47","2017-07-28 12:10:49",""
"23032262","URL decryption error using DES","<p>Am being able to encrypt/decrypt my URL successfully before sending the url in an email, but after passing the URL and retrieving it am decrypting the encrypted part of the URL, its not being decrypted correctly. Am getting strange characters after decryption, for example:</p>

<p>my text before encryption: </p>

<pre><code>dkjkb7i8doprgeh521tbbdll9r-Sat Apr 12 17:21:01 EEST 2014
</code></pre>

<p>my text after:</p>

<pre><code>decryption:ziUO5baLOpFaOfWBtMOLhrRBR2ucXnxFHbA2KoRUVVQst6oDqUrGIU04qey4xU6haNvyp18+BROzadH6MXNxKA==
</code></pre>

<p>URL decryption after sending the url,decrypted text after sending url : </p>

<pre><code>dkjkb7i8doprgeh521tbbdll9r-Sat Apr 12 17:21:01 **E[???xno**
</code></pre>

<p>this is my DES class that i use for encryption, decryption:</p>

<pre><code>package com;

import java.security.spec.KeySpec;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

public class DESEncryption {

    private static final String UNICODE_FORMAT = ""UTF8"";
    public static final String DES_ENCRYPTION_SCHEME = ""DES"";
    private KeySpec myKeySpec;
    private SecretKeyFactory mySecretKeyFactory;
    private Cipher cipher;
    byte[] keyAsBytes;
    private String myEncryptionKey;
    private String myEncryptionScheme;
    SecretKey key;

    public DESEncryption() throws Exception {
        myEncryptionKey = ""ThisIsSecretEncryptionKey"";
        myEncryptionScheme = DES_ENCRYPTION_SCHEME;
        keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        myKeySpec = new DESKeySpec(keyAsBytes);
        mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = mySecretKeyFactory.generateSecret(myKeySpec);
    }

    /**
     * Method To Encrypt The String
     */
    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            BASE64Encoder base64encoder = new BASE64Encoder();
            encryptedString = base64encoder.encode(encryptedText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }

    /**
     * Method To Decrypt An Ecrypted String
     */
    public String decrypt(String encryptedString) {
        String decryptedText = null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            BASE64Decoder base64decoder = new BASE64Decoder();
            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText = bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }

    /**
     * Returns String From An Array Of Bytes
     */
    private static String bytes2String(byte[] bytes) {
        StringBuffer stringBuffer = new StringBuffer();

        for (int i = 0; i &lt; bytes.length; i++) {
            stringBuffer.append((char) bytes[i]);
        }
        return stringBuffer.toString();
    }

}
</code></pre>
","<p>Base 64 utilizes the <code>/</code> and <code>+</code> characters. You need to do either one of the following:</p>

<ol>
<li>URL-encode your base 64 string;</li>
<li>Use a <a href=""http://en.wikipedia.org/wiki/Base64#Implementations_and_history"" rel=""nofollow"">base 64 variant</a> that is safe for URL's.</li>
</ol>

<p>The first one is easier to code but may be less efficient than the second one (if there are many <code>/</code> and <code>+</code> characters in the encoding).</p>

<p>Note that you can use a simple string replacement to utilize #2, so it is not <em>that</em> hard.</p>
","150","<java><security><url><encryption><des>","0","1","1","2014-04-12 15:54:52","23032691","0","2","3444240","","2014-04-12 15:25:47","2014-04-12 15:20:06",""
"42838979","SymmetricAlgorithm DES C#. Base64","<p>So im trying to encrypt data using C# DES </p>

<p>have the following code</p>

<pre><code>            static public string Encrypt(string _dataToEncrypt) {
                SymmetricAlgorithm algorithm = DES.Create();
                ICryptoTransform transform = algorithm.CreateEncryptor(key, iv);
                byte[] inputbuffer = Encoding.Unicode.GetBytes(_dataToEncrypt);
                byte[] outputBuffer = transform.TransformFinalBlock(inputbuffer, 0, inputbuffer.Length);
                return Convert.ToBase64String(outputBuffer);
            }

            static public string Decrypt(string _dataToDecrypt) {
                SymmetricAlgorithm algorithm = DES.Create();
                ICryptoTransform transform = algorithm.CreateDecryptor(key, iv);
                byte[] inputbuffer = Convert.FromBase64String(_dataToDecrypt); // Here is the problem.
                byte[] outputBuffer = transform.TransformFinalBlock(inputbuffer, 0, inputbuffer.Length);
                return Encoding.Unicode.GetString(outputBuffer);
            }
</code></pre>

<p>And im getting an error <code>System.FormatException: 'Invalid length for a Base-64 char array or string.'</code></p>

<p>It works when string has an even number of characters.</p>

<p>Is it even real to encrypt/decrypt data with an odd number of characters ?</p>
","<p>DES, as well as AES does not have limit on what can be encrypted, the problem is elsewhere.</p>

<p>It looks like it is a Bas64 encoding problem given the line the error occurs on.</p>

<p>Perhaps trailing ""="" characters were stripped from the Base64.</p>

<p>Information:</p>

<p>DES is a block based encryption algorithm, as such the input must be an exact multiple of the block size, 8-bytes for DES. When the input is not <em>always</em> an exact multiple padding must be added, the easiest way to to let the implementation do that for you by specifying padding, generally PKCS#5 for DES.</p>

<p>For SymmetricAlgorithm use Padding Property <code>PKCS7</code>, it is always best to fully specify everything and not rely on defaults.</p>

<pre><code>algorithm.Padding = PaddingMode.PKCS7;
</code></pre>
","148","<c#><encryption><msdn><des>","-1","1","1","2017-03-16 16:28:47","","2","1","","","","2017-03-16 15:55:16",""
"47097206","DES decryption in JavaScript not showing the original message","<pre><code>    function des (key, message, encrypt, mode, iv, padding) {
  //declaring this locally speeds things up a bit
  var spfunction1 = new Array (0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004);
  var spfunction2 = new Array (-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000);
  var spfunction3 = new Array (0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200);
  var spfunction4 = new Array (0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080);
  var spfunction5 = new Array (0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100);
  var spfunction6 = new Array (0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010);
  var spfunction7 = new Array (0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002);
  var spfunction8 = new Array (0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000);

  //create the 16 or 48 subkeys we will need
  var keys = des_createKeys (key);
  var m=0, i, j, temp, temp2, right1, right2, left, right, looping;
  var cbcleft, cbcleft2, cbcright, cbcright2
  var endloop, loopinc;
  var len = message.length;
  var chunk = 0;
  //set up the loops for single and triple des
  var iterations = keys.length == 32 ? 3 : 9; //single or triple des
  if (iterations == 3) {looping = encrypt ? new Array (0, 32, 2) : new Array (30, -2, -2);}
  else {looping = encrypt ? new Array (0, 32, 2, 62, 30, -2, 64, 96, 2) : new Array (94, 62, -2, 32, 64, 2, 30, -2, -2);}

  //pad the message depending on the padding parameter
  if (padding == 2) message += ""        ""; //pad the message with spaces
  else if (padding == 1) {temp = 8-(len%8); message += String.fromCharCode (temp,temp,temp,temp,temp,temp,temp,temp); if (temp==8) len+=8;} //PKCS7 padding
  else if (!padding) message += ""\0\0\0\0\0\0\0\0""; //pad the message out with null bytes

  //store the result here
  result = """";
  tempresult = """";

  if (mode == 1) { //CBC mode
    cbcleft = (iv.charCodeAt(m++) &lt;&lt; 24) | (iv.charCodeAt(m++) &lt;&lt; 16) | (iv.charCodeAt(m++) &lt;&lt; 8) | iv.charCodeAt(m++);
    cbcright = (iv.charCodeAt(m++) &lt;&lt; 24) | (iv.charCodeAt(m++) &lt;&lt; 16) | (iv.charCodeAt(m++) &lt;&lt; 8) | iv.charCodeAt(m++);
    m=0;
  }

  //loop through each 64 bit chunk of the message
  while (m &lt; len) {
    left = (message.charCodeAt(m++) &lt;&lt; 24) | (message.charCodeAt(m++) &lt;&lt; 16) | (message.charCodeAt(m++) &lt;&lt; 8) | message.charCodeAt(m++);
    right = (message.charCodeAt(m++) &lt;&lt; 24) | (message.charCodeAt(m++) &lt;&lt; 16) | (message.charCodeAt(m++) &lt;&lt; 8) | message.charCodeAt(m++);

    //for Cipher Block Chaining mode, xor the message with the previous result
    if (mode == 1) {if (encrypt) {left ^= cbcleft; right ^= cbcright;} else {cbcleft2 = cbcleft; cbcright2 = cbcright; cbcleft = left; cbcright = right;}}

    //first each 64 but chunk of the message must be permuted according to IP
    temp = ((left &gt;&gt;&gt; 4) ^ right) &amp; 0x0f0f0f0f; right ^= temp; left ^= (temp &lt;&lt; 4);
    temp = ((left &gt;&gt;&gt; 16) ^ right) &amp; 0x0000ffff; right ^= temp; left ^= (temp &lt;&lt; 16);
    temp = ((right &gt;&gt;&gt; 2) ^ left) &amp; 0x33333333; left ^= temp; right ^= (temp &lt;&lt; 2);
    temp = ((right &gt;&gt;&gt; 8) ^ left) &amp; 0x00ff00ff; left ^= temp; right ^= (temp &lt;&lt; 8);
    temp = ((left &gt;&gt;&gt; 1) ^ right) &amp; 0x55555555; right ^= temp; left ^= (temp &lt;&lt; 1);

    left = ((left &lt;&lt; 1) | (left &gt;&gt;&gt; 31)); 
    right = ((right &lt;&lt; 1) | (right &gt;&gt;&gt; 31)); 

    //do this either 1 or 3 times for each chunk of the message
    for (j=0; j&lt;iterations; j+=3) {
      endloop = looping[j+1];
      loopinc = looping[j+2];
      //now go through and perform the encryption or decryption  
      for (i=looping[j]; i!=endloop; i+=loopinc) { //for efficiency
        right1 = right ^ keys[i]; 
        right2 = ((right &gt;&gt;&gt; 4) | (right &lt;&lt; 28)) ^ keys[i+1];
        //the result is attained by passing these bytes through the S selection functions
        temp = left;
        left = right;
        right = temp ^ (spfunction2[(right1 &gt;&gt;&gt; 24) &amp; 0x3f] | spfunction4[(right1 &gt;&gt;&gt; 16) &amp; 0x3f]
              | spfunction6[(right1 &gt;&gt;&gt;  8) &amp; 0x3f] | spfunction8[right1 &amp; 0x3f]
              | spfunction1[(right2 &gt;&gt;&gt; 24) &amp; 0x3f] | spfunction3[(right2 &gt;&gt;&gt; 16) &amp; 0x3f]
              | spfunction5[(right2 &gt;&gt;&gt;  8) &amp; 0x3f] | spfunction7[right2 &amp; 0x3f]);
      }
      temp = left; left = right; right = temp; //unreverse left and right
    } //for either 1 or 3 iterations

    //move then each one bit to the right
    left = ((left &gt;&gt;&gt; 1) | (left &lt;&lt; 31)); 
    right = ((right &gt;&gt;&gt; 1) | (right &lt;&lt; 31)); 

    //now perform IP-1, which is IP in the opposite direction
    temp = ((left &gt;&gt;&gt; 1) ^ right) &amp; 0x55555555; right ^= temp; left ^= (temp &lt;&lt; 1);
    temp = ((right &gt;&gt;&gt; 8) ^ left) &amp; 0x00ff00ff; left ^= temp; right ^= (temp &lt;&lt; 8);
    temp = ((right &gt;&gt;&gt; 2) ^ left) &amp; 0x33333333; left ^= temp; right ^= (temp &lt;&lt; 2);
    temp = ((left &gt;&gt;&gt; 16) ^ right) &amp; 0x0000ffff; right ^= temp; left ^= (temp &lt;&lt; 16);
    temp = ((left &gt;&gt;&gt; 4) ^ right) &amp; 0x0f0f0f0f; right ^= temp; left ^= (temp &lt;&lt; 4);

    //for Cipher Block Chaining mode, xor the message with the previous result
    if (mode == 1) {if (encrypt) {cbcleft = left; cbcright = right;} else {left ^= cbcleft2; right ^= cbcright2;}}
    tempresult += String.fromCharCode ((left&gt;&gt;&gt;24), ((left&gt;&gt;&gt;16) &amp; 0xff), ((left&gt;&gt;&gt;8) &amp; 0xff), (left &amp; 0xff), (right&gt;&gt;&gt;24), ((right&gt;&gt;&gt;16) &amp; 0xff), ((right&gt;&gt;&gt;8) &amp; 0xff), (right &amp; 0xff));

    chunk += 8;
    if (chunk == 512) {result += tempresult; tempresult = """"; chunk = 0;}
  } //for every 8 characters, or 64 bits in the message

  //return the result as an array
  return result + tempresult;
} //end of des



//des_createKeys
//this takes as input a 64 bit key (even though only 56 bits are used)
//as an array of 2 integers, and returns 16 48 bit keys
function des_createKeys (key) {
  //declaring this locally speeds things up a bit
  pc2bytes0  = new Array (0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204);
  pc2bytes1  = new Array (0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101);
  pc2bytes2  = new Array (0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808);
  pc2bytes3  = new Array (0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000);
  pc2bytes4  = new Array (0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010);
  pc2bytes5  = new Array (0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420);
  pc2bytes6  = new Array (0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002);
  pc2bytes7  = new Array (0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800);
  pc2bytes8  = new Array (0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002);
  pc2bytes9  = new Array (0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408);
  pc2bytes10 = new Array (0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020);
  pc2bytes11 = new Array (0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200);
  pc2bytes12 = new Array (0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010);
  pc2bytes13 = new Array (0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105);

  //how many iterations (1 for des, 3 for triple des)
  var iterations = key.length &gt; 8 ? 3 : 1; //changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
  //stores the return keys
  var keys = new Array (32 * iterations);
  //now define the left shifts which need to be done
  var shifts = new Array (0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0);
  //other variables
  var lefttemp, righttemp, m=0, n=0, temp;

  for (var j=0; j&lt;iterations; j++) { //either 1 or 3 iterations
    left = (key.charCodeAt(m++) &lt;&lt; 24) | (key.charCodeAt(m++) &lt;&lt; 16) | (key.charCodeAt(m++) &lt;&lt; 8) | key.charCodeAt(m++);
    right = (key.charCodeAt(m++) &lt;&lt; 24) | (key.charCodeAt(m++) &lt;&lt; 16) | (key.charCodeAt(m++) &lt;&lt; 8) | key.charCodeAt(m++);

    temp = ((left &gt;&gt;&gt; 4) ^ right) &amp; 0x0f0f0f0f; right ^= temp; left ^= (temp &lt;&lt; 4);
    temp = ((right &gt;&gt;&gt; -16) ^ left) &amp; 0x0000ffff; left ^= temp; right ^= (temp &lt;&lt; -16);
    temp = ((left &gt;&gt;&gt; 2) ^ right) &amp; 0x33333333; right ^= temp; left ^= (temp &lt;&lt; 2);
    temp = ((right &gt;&gt;&gt; -16) ^ left) &amp; 0x0000ffff; left ^= temp; right ^= (temp &lt;&lt; -16);
    temp = ((left &gt;&gt;&gt; 1) ^ right) &amp; 0x55555555; right ^= temp; left ^= (temp &lt;&lt; 1);
    temp = ((right &gt;&gt;&gt; 8) ^ left) &amp; 0x00ff00ff; left ^= temp; right ^= (temp &lt;&lt; 8);
    temp = ((left &gt;&gt;&gt; 1) ^ right) &amp; 0x55555555; right ^= temp; left ^= (temp &lt;&lt; 1);

    //the right side needs to be shifted and to get the last four bits of the left side
    temp = (left &lt;&lt; 8) | ((right &gt;&gt;&gt; 20) &amp; 0x000000f0);
    //left needs to be put upside down
    left = (right &lt;&lt; 24) | ((right &lt;&lt; 8) &amp; 0xff0000) | ((right &gt;&gt;&gt; 8) &amp; 0xff00) | ((right &gt;&gt;&gt; 24) &amp; 0xf0);
    right = temp;

    //now go through and perform these shifts on the left and right keys
    for (var i=0; i &lt; shifts.length; i++) {
      //shift the keys either one or two bits to the left
      if (shifts[i]) {left = (left &lt;&lt; 2) | (left &gt;&gt;&gt; 26); right = (right &lt;&lt; 2) | (right &gt;&gt;&gt; 26);}
      else {left = (left &lt;&lt; 1) | (left &gt;&gt;&gt; 27); right = (right &lt;&lt; 1) | (right &gt;&gt;&gt; 27);}
      left &amp;= -0xf; right &amp;= -0xf;

      //now apply PC-2, in such a way that E is easier when encrypting or decrypting
      //this conversion will look like PC-2 except only the last 6 bits of each byte are used
      //rather than 48 consecutive bits and the order of lines will be according to 
      //how the S selection functions will be applied: S2, S4, S6, S8, S1, S3, S5, S7
      lefttemp = pc2bytes0[left &gt;&gt;&gt; 28] | pc2bytes1[(left &gt;&gt;&gt; 24) &amp; 0xf]
              | pc2bytes2[(left &gt;&gt;&gt; 20) &amp; 0xf] | pc2bytes3[(left &gt;&gt;&gt; 16) &amp; 0xf]
              | pc2bytes4[(left &gt;&gt;&gt; 12) &amp; 0xf] | pc2bytes5[(left &gt;&gt;&gt; 8) &amp; 0xf]
              | pc2bytes6[(left &gt;&gt;&gt; 4) &amp; 0xf];
      righttemp = pc2bytes7[right &gt;&gt;&gt; 28] | pc2bytes8[(right &gt;&gt;&gt; 24) &amp; 0xf]
                | pc2bytes9[(right &gt;&gt;&gt; 20) &amp; 0xf] | pc2bytes10[(right &gt;&gt;&gt; 16) &amp; 0xf]
                | pc2bytes11[(right &gt;&gt;&gt; 12) &amp; 0xf] | pc2bytes12[(right &gt;&gt;&gt; 8) &amp; 0xf]
                | pc2bytes13[(right &gt;&gt;&gt; 4) &amp; 0xf];
      temp = ((righttemp &gt;&gt;&gt; 16) ^ lefttemp) &amp; 0x0000ffff; 
      keys[n++] = lefttemp ^ temp; keys[n++] = righttemp ^ (temp &lt;&lt; 16);
    }
  } //for each iterations
  //return the keys we've created
  return keys;
} //end of des_createKeys



////////////////////////////// TEST //////////////////////////////
function stringToHex (s) {
  var r = ""0x"";
  var hexes = new Array (""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f"");
  for (var i=0; i&lt;s.length; i++) {r += hexes [s.charCodeAt(i) &gt;&gt; 4] + hexes [s.charCodeAt(i) &amp; 0xf];}
  return r;
}

function hexToString (h) {
  var r = """";
  for (var i= (h.substr(0, 2)==""0x"")?2:0; i&lt;h.length; i+=2) {r += String.fromCharCode (parseInt (h.substr (i, 2), 16));}
  return r;
}

var key = ""12345678"";
var message = ""This is a test message"";
var ciphertext = des (key, message, 1, 1,""23456789"");


//console.log(""Encrypted Value : "" + ciphertext);
console.log (""Cipher Text is : "" + stringToHex (ciphertext));

var deciphertext = des(key, stringToHex(ciphertext), 0, 1,""23456789"");
console.log(""Decipher Text is (Message) is :"" + hexToString(deciphertext));
</code></pre>

<p>I am obtaining the correct encrypted value but for some reason during decryption i'm not obtaining the actual message which is ""<strong>This is a test message</strong>"". Instead,I'm obtaining a unicode value <strong>±</strong>. 
I am using DES with <strong>CBC</strong> mode of operation. Input vector is <strong>23456789</strong>
The source code is from <a href=""http://www.tero.co.uk/des/code.php"" rel=""nofollow noreferrer"">http://www.tero.co.uk/des/code.php</a>. </p>

<p>I ran this script in Developer tools of Google Chrome. </p>
","","147","<javascript><des><forge>","0","","0","2017-11-03 14:23:11","","2","","6760338","","2017-11-03 14:23:11","2017-11-03 13:42:35",""
"37964265","How to make php code ""echo 62837 << -16;"" return same result between windows and linux?","<p>How to make php code ""echo 62837 &lt;&lt; -16;"" return same result between windows and linux?</p>

<p>windows result:-176881664</p>

<p>linux result:-759700962142060544</p>
","<p>Shifting by a negative number throws an exception in PHP 7+ so it's obviously invalid to do so.</p>

<pre><code>Fatal error: Uncaught ArithmeticError: Bit shift by negative number
</code></pre>

<p>In C, it invokes undefined behavior, see: <a href=""https://stackoverflow.com/questions/4945703/left-shifting-with-a-negative-shift-count"">Left shifting with a negative shift count</a></p>

<p><strong>To answer your question:</strong> You can't make code that invokes undefined behavior return consistent results across platforms. That code needs to be modified to not shift by a negative number.</p>
","143","<php><des>","1","2","1","2016-06-22 13:37:43","","1","","","","","2016-06-22 09:43:31",""
"12265969","Inmutable values mutating in IIS?","<p>So, I've been trying to figure out the following problem for the past few weeks, and at this point I'm almost exhausting my options because how contradictory the situation seems.</p>

<p>I have an application which is developed to work under SharePoint but it's basically ASP.NET code. I have an encrypted connection string which I decrypt it in memory and store it in a configuration object to access the database. My configuration object is static (accesible through a <code>Service Locator</code> pattern), which I later use to seed a LINQ-to-SQL data context.</p>

<p>My internal key for decryption is stored, privately in a class as <code>private static readonly string myPassword = ""MyPassword"";</code> (just an example, the actual password is more complex and valid). There's no single statement, anywhere, referencing that field, except one on a static method using it as a parameter for another decryption method (instance method), which instantiates a new <code>DESCryptoServiceProvider</code> with it.</p>

<p>And still, I get the following exception from time to time in my production server logs:</p>

<pre><code>Exception type: CryptographicException
Exception message: Specified key is a known weak key for 'DES' and cannot be used.
</code></pre>

<p>As such, the connection string decryption fails and, of course, the database is not accessed anymore. Poof, application down.</p>

<p>How is this even possible? </p>

<p><strong>Disclaimer</strong>: This is an old application I am maintaining. The description I provide here is to help troubleshoot, but I cannot change the way it works internally. Some will agree that this is not the best approach but the application has been running without a problem for more than 2 years and suddenly these exceptions are taking it down.</p>

<p><strong>Update</strong>: I've been requested to clarify with a stack trace of the exception, but I cannot provide one full stack trace for NDA reasons. What I <em>can</em> tell is the following:</p>

<ul>
<li>The object throwing the exception is the <code>System.Security.DESCryptoServiceProvider.CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)</code> method</li>
<li>The original key (the one we actually use) does validate and does not generate an exception. Still, we get this exception from time to time (not always), without knowing which is the current value which does not validate</li>
<li>The instance of the <code>DESCryptoServiceProvider</code> is stored statically, privately, in a helper class</li>
<li>This is all triggered by <code>System.Web.HttpApplication.InitModulesCommon()</code>, to initialize the application internal parts</li>
</ul>

<p>Also, here is an obscured stack trace:</p>

<pre><code>at System.Security.Cryptography.DESCryptoServiceProvider.CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
at SymmetricEncryption.Decrypt(String contents, String key)
// our helper, just a wrapper, based from this class: http://www.codeproject.com/Articles/1967/Encryption-Decryption-with-NET
at EncryptedConnectionStringHelper.DecryptUserAndPass(String connectionString)\
// our container for parsing the connection string and decrypting the user and password, not the full connstring is encrypted
at OurModule.Init(OurConfigurationSection config)
at OurModule.Boot(OurConfigurationSection config)
at OurModule.Boot()
at OurModule.Init(HttpApplication context)
at System.Web.HttpApplication.InitModulesCommon()
at System.Web.HttpApplication.InitInternal(HttpContext context, HttpApplicationState state, MethodInfo[] handlers)
at System.Web.HttpApplicationFactory.GetNormalApplicationInstance(HttpContext context)
at System.Web.HttpApplicationFactory.GetApplicationInstance(HttpContext context)
at System.Web.HttpRuntime.ProcessRequestInternal(HttpWorkerRequest wr)
</code></pre>

<p>Our application registers this module in the following way:</p>

<pre><code>public class OurModule : IHttpModule
{
    public static bool initialized = false;

    public void Init(HttpApplication context)
    { 
        if (!initialized) {
            subscribe(context);
            OurModule.Boot();
            initialized = true;
        }
    }
</code></pre>
","<p>It doesn't sound like anything's <em>mutating</em> the object. It sounds like ""something"" (if you'd posted the stack trace it would be clearer) is <em>validating</em> the DES key... and complaining that it's a known weak key.</p>

<p>Ideally, you should change your password to be more secure, of course - but if you can't, you should look at exactly where that exception's coming from, and see if there are settings somewhere controlling how and when it's validated.</p>

<p>If you're not already logging the full stack trace (instead of just the exception message) that's the <em>first</em> thing you should do.</p>
","142","<c#><iis><des>","2","0","2","2012-09-15 21:10:33","","5","","387076","","2012-09-15 21:10:33","2012-09-04 14:45:05",""
"12265969","Inmutable values mutating in IIS?","<p>So, I've been trying to figure out the following problem for the past few weeks, and at this point I'm almost exhausting my options because how contradictory the situation seems.</p>

<p>I have an application which is developed to work under SharePoint but it's basically ASP.NET code. I have an encrypted connection string which I decrypt it in memory and store it in a configuration object to access the database. My configuration object is static (accesible through a <code>Service Locator</code> pattern), which I later use to seed a LINQ-to-SQL data context.</p>

<p>My internal key for decryption is stored, privately in a class as <code>private static readonly string myPassword = ""MyPassword"";</code> (just an example, the actual password is more complex and valid). There's no single statement, anywhere, referencing that field, except one on a static method using it as a parameter for another decryption method (instance method), which instantiates a new <code>DESCryptoServiceProvider</code> with it.</p>

<p>And still, I get the following exception from time to time in my production server logs:</p>

<pre><code>Exception type: CryptographicException
Exception message: Specified key is a known weak key for 'DES' and cannot be used.
</code></pre>

<p>As such, the connection string decryption fails and, of course, the database is not accessed anymore. Poof, application down.</p>

<p>How is this even possible? </p>

<p><strong>Disclaimer</strong>: This is an old application I am maintaining. The description I provide here is to help troubleshoot, but I cannot change the way it works internally. Some will agree that this is not the best approach but the application has been running without a problem for more than 2 years and suddenly these exceptions are taking it down.</p>

<p><strong>Update</strong>: I've been requested to clarify with a stack trace of the exception, but I cannot provide one full stack trace for NDA reasons. What I <em>can</em> tell is the following:</p>

<ul>
<li>The object throwing the exception is the <code>System.Security.DESCryptoServiceProvider.CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)</code> method</li>
<li>The original key (the one we actually use) does validate and does not generate an exception. Still, we get this exception from time to time (not always), without knowing which is the current value which does not validate</li>
<li>The instance of the <code>DESCryptoServiceProvider</code> is stored statically, privately, in a helper class</li>
<li>This is all triggered by <code>System.Web.HttpApplication.InitModulesCommon()</code>, to initialize the application internal parts</li>
</ul>

<p>Also, here is an obscured stack trace:</p>

<pre><code>at System.Security.Cryptography.DESCryptoServiceProvider.CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
at SymmetricEncryption.Decrypt(String contents, String key)
// our helper, just a wrapper, based from this class: http://www.codeproject.com/Articles/1967/Encryption-Decryption-with-NET
at EncryptedConnectionStringHelper.DecryptUserAndPass(String connectionString)\
// our container for parsing the connection string and decrypting the user and password, not the full connstring is encrypted
at OurModule.Init(OurConfigurationSection config)
at OurModule.Boot(OurConfigurationSection config)
at OurModule.Boot()
at OurModule.Init(HttpApplication context)
at System.Web.HttpApplication.InitModulesCommon()
at System.Web.HttpApplication.InitInternal(HttpContext context, HttpApplicationState state, MethodInfo[] handlers)
at System.Web.HttpApplicationFactory.GetNormalApplicationInstance(HttpContext context)
at System.Web.HttpApplicationFactory.GetApplicationInstance(HttpContext context)
at System.Web.HttpRuntime.ProcessRequestInternal(HttpWorkerRequest wr)
</code></pre>

<p>Our application registers this module in the following way:</p>

<pre><code>public class OurModule : IHttpModule
{
    public static bool initialized = false;

    public void Init(HttpApplication context)
    { 
        if (!initialized) {
            subscribe(context);
            OurModule.Boot();
            initialized = true;
        }
    }
</code></pre>
","<p>Have a look at your wrapper <code>SymmetricEncryption.Decrypt</code>. My guess would be that the issue is in there. How it creates the Key from your password. Does it use <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.passwordderivebytes.aspx"" rel=""nofollow"" title=""PasswordDiriveBytes"">PasswordDeriveBytes</a> or some other half baked solution?</p>

<p>Failing that maybe you could try get a better key than ""MyPassword"".</p>

<p>Failing that maybe you could use web.config encryption. <a href=""http://weblogs.asp.net/scottgu/archive/2006/01/09/434893.aspx"" rel=""nofollow"">Scott Gu wrote about it here.</a></p>
","142","<c#><iis><des>","2","1","2","2012-09-15 21:10:33","","5","","387076","","2012-09-15 21:10:33","2012-09-04 14:45:05",""
"18182604","DES Algorithm Identifier","<p>Can somebody please give me an authoritative reference that <strong>1.3.14.3.2.7</strong> is the DES algorithm identifier used in S/MIME? I figured the number by sending a DES encrypted email and viewing the P7M file of the email.</p>
","<p>The <a href=""http://www.oid-info.com/cgi-bin/display?oid=1.3.14.3.2.7&amp;action=display"" rel=""nofollow"">OID repository has it here</a>. It parses it as:</p>

<p><strong>{ iso(1) identified-organization(3) oiw(14) secsig(3) algorithm(2) }</strong></p>

<p>and it oddly describes it as <em>""Voice encryption using DES (56 bit) in CBC mode and 512-bit DH-group""</em>.</p>

<p>For the record, <strong>oiw</strong> stands for the OSI Implementor's Working Group.</p>
","141","<des><pkcs#7><smime>","0","0","2","2013-08-15 04:49:10","18246504","0","","","","","2013-08-12 08:34:41",""
"18182604","DES Algorithm Identifier","<p>Can somebody please give me an authoritative reference that <strong>1.3.14.3.2.7</strong> is the DES algorithm identifier used in S/MIME? I figured the number by sending a DES encrypted email and viewing the P7M file of the email.</p>
","<p>This list of OIDs <a href=""http://www.imc.org/ietf-smime/other-smime-oids.asn"" rel=""nofollow"">OIDs Used with S/MIME</a> is maintained by the Internet Mail Consortium and it is referenced in RFC 2633 p. 7. It clearly mentions that the OID for the DES algorithm in CBC mode is <strong>1.3.14.3.2.7</strong>.</p>
","141","<des><pkcs#7><smime>","0","0","2","2013-08-15 04:49:10","18246504","0","","","","","2013-08-12 08:34:41",""
"17134649","Openssl Encrypting, Decrypting doesn't work with DES","<p>I'm developing a simple application where there are a Client (C) and a Server (S).</p>

<p>Client gets text from std input, encrypts it, and sends it to the Server.</p>

<p>Since, I don't know if the text from user is multiple of 8 byte( I'm using des),
in my encryption function I always call:
EVP_EncryptUpdate</p>

<p>and then:
EVP_EncryptFinal_ex</p>

<pre><code>int encrypt(EVP_CIPHER_CTX *x, char * in, char * buf_out )
{

    int text_len;
    int loutU;
    int loutF;


    text_len = strlen(in) + 1; // i.e : adding '\0'

    if( EVP_EncryptUpdate(x, (unsigned char *)buf_out, &amp;loutU, ( unsigned char*) in, text_len) == 0 )
        return -1;

    if( EVP_EncryptFinal_ex(x, (unsigned char *) &amp;buf_out[loutU], &amp;loutF) == 0 )
        return -1;  

    return loutU + loutF;
}
</code></pre>

<p>All works fine but only for the first message.</p>

<p>For example if I send as first message:
""12345678"" (that are 8 bytes), and as second message:
""hello"".
My server will print as second message:
""0x08 0x08 0x08 0x08 0x08 0x08 0x08 0x08 Hello"".</p>

<p>0x08 8 times is the padding that on client side EVP_EncryptFinal_ex added.</p>

<p>Another Example:
If first message is ""prova daje"".
And ""Hello"" as second.
Server will print as second message: 
""je 0x05 0x05 0x05 0x05 0x05 hello""
Note that je and 0x05 for 5 times are part of first message, indeed:
""prova da"" are 8 bytes ,  ""je'\0'"" are 3 bytes, so 0x05 is  the padding.</p>

<p>How can I avoid this?
I would like to have no dependency between the first and the second message.</p>

<p>Do I have to call <code>clean_up</code> each time?</p>

<hr>

<p>EDIT:
I solved, since I called EVP_EncryptFinal_ex I had to call EVP_init to can reuse
the context.</p>
","","138","<openssl><des>","1","","0","2013-06-26 21:07:21","","0","","2350420","","2013-06-26 21:07:21","2013-06-16 10:50:48",""
"34328851","How to use CCCryptorStatus for DES encryption if NSString in iPhone? objective c","<p>Can anyone help how to use CCCryptorStatus for DES encryption of NSString. I want to pass des encrypted password to the API for login. </p>
","<ol>
<li><p>The simpliest and secure method is to use https. With https the data and qyerry parameters are all encrypted for transmission over the Internet.</p></li>
<li><p>Do not use DES, it is to weak for curent work. Instead use AES (Advanced Encryption Standard) if you need to do your own encryption.</p></li>
<li><p>If you do your own encryption how will you get the encryption on both the client and server and keep it secure?</p></li>
</ol>
","135","<objective-c><iphone><nsstring><des>","-1","0","1","2015-12-17 13:05:20","34335336","1","","","","","2015-12-17 07:24:15",""
"20871148","Why can't PyDES output be printed without changing?","<p>I have a very simple problem. Which is best explained by this sample code from the idle:</p>

<pre><code>    from pyDes import *
&gt;&gt;&gt; ciphertext = triple_des('a 16 or 24 byte password').encrypt(""secret message"", padmode=2)
&gt;&gt;&gt; ciphertext
')\xd8\xbfFn#EY\xcbiH\xfa\x18\xb4\xf7\xa2'
&gt;&gt;&gt; print ciphertext
)Ø¿Fn#EYËiHú´÷¢
</code></pre>

<p>I would appreciate it if someone could explain why this happens and how I can stop it from happening when writing this code to a txt file (without changing the decrypted output) since the <code>write()</code> function has the same effect on the text. I'm using python 2.7 on vista by the way.</p>
","<p>When you are in the Python shell and print some variable in this way:</p>

<pre><code>&gt;&gt;&gt; print var
</code></pre>

<p>What you get is the output of the <code>__str__</code> method of the object <code>var</code>.
Instead, when you ""print"" a variable in this other way:</p>

<pre><code>&gt;&gt;&gt;&gt; var
</code></pre>

<p>What you get is the output of the <code>__repr__</code> method of the object <code>var</code>.</p>

<p>The difference between these two methods is that the return value of the <code>__repr__</code> function <em>should</em> be a valid python expression. Ideally you should be able to get a new object identical to <code>var</code> by simply doing a copy/paste of the output of its <code>__repr__</code> method (by the way this is not possible in every case). However the output of the <code>__repr__</code> method is intended to be used only for debugging purpose.
The <code>__str__</code> method, instead, is intended to return you a human-readable and concise representation of the object.</p>

<p>In your case what you get when you write <code>&gt;&gt;&gt; ciphertext</code> is the ""formal"" representation which translate any non-printable character in its hexadecimal representation. Instead, when you use the <code>print</code> statement you get the ""raw"" data containing the non-printable characters as they are.</p>
","134","<python><python-2.7><encryption><des>","1","0","1","2014-01-01 18:27:22","20871806","5","","","","","2014-01-01 17:19:30",""
"47524230","OpenSSL ECB non 64 bits multiple plain text","<p>I'm having problems when I try to cipher and decipher a non 64 bits multiple plain text using OpenSSL ECB problem.</p>

<p>I have two .c files, one to cipher, another one to decipher. </p>

<p>This is the first one.</p>

<pre><code>// FILE ENCRYPTION
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;openssl/des.h&gt;
#include &lt;sys/types.h&gt;

void merror(char *msg) {
  perror(msg);
  exit(0);
}

char *Encriptar(char *Key, char *Msg, int size) {
  static char*    Res;
  int       n=0;
  DES_cblock      Key2;
  DES_key_schedule schedule;
  Res = ( char * ) malloc( size );

  memcpy( Key2, Key,8);
  DES_set_odd_parity( &amp;Key2 );
  DES_set_key_checked( &amp;Key2, &amp;schedule );
  DES_ecb_encrypt((unsigned char *)Msg, (unsigned char *)Res, &amp;schedule,DES_ENCRYPT);
  return (Res);
}

#define LINELEN 8

int main(int argc, char *argv[]) {
  int n, fdp, fdc;
  char key[]=""password"";
  unsigned char buf[LINELEN];

  if (argc &lt; 3) {fprintf(stderr,""USO %s &lt;fileP&gt; &lt;fileC&gt;\n"",argv[0]);exit(0);}
  if ((fdp = open (argv[1], O_RDONLY)) == -1)
     merror (""Open FDP"");
   if ((fdc = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 00744)) == -1)
      merror (""Open FDC"");
   while ((n = read(fdp, buf, LINELEN)) &gt; 0) 
   write (fdc, Encriptar(key, buf, n), n);

   close (fdp);
   close (fdc);
   exit (0);
}
</code></pre>

<p>This is the second one</p>

<pre><code>//FILE DECRYPTION

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;openssl/des.h&gt;
#include &lt;sys/types.h&gt;

void merror(char *msg) {
  perror(msg);
  exit(0);
}

char *Decriptar(char *Key, char *Msg, int size) {
  static char* Res;
  int n=0;
  DES_cblock      Key2;
  DES_key_schedule schedule;
  Res = ( char * ) malloc( size );
  memcpy( Key2, Key,8);
  DES_set_odd_parity( &amp;Key2 );
  DES_set_key_checked( &amp;Key2, &amp;schedule );
  DES_ecb_encrypt((unsigned char *)Msg, (unsigned char *)Res,&amp;schedule,DES_DECRYPT);
  return (Res);
}

#define LINELEN 8
int main(int argc, char *argv[]) {
int n, fdp, fdc;
char key[]=""password"";
unsigned char buf[LINELEN];

if (argc&lt;3) {fprintf(stderr,""USO %s &lt;fileC&gt; &lt;fileP&gt;\n"", argv[0]); exit(0);}

if ((fdc = open (argv[1], O_RDONLY)) == -1)
merror (""Open FDP"");
if ((fdp = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 00744)) == -1)
merror (""Open FDC"");

while ((n = read(fdc, buf, LINELEN)) &gt; 0) 
write (fdp, Decriptar(key, buf, n), n);

close (fdp);
close (fdc);

exit (0);
}
</code></pre>

<p>But, the plain text I got from the decipher es not the same as the plain text I used to create mi cipher text.</p>
","<p>DES ECB is a block mode cipher with a 64-bit (or 8-octet) block and is <strong>designed to work only on</strong> data that is <strong>a multiple of the block size</strong>. Plus OpenSSL <code>DES_ecb_encrypt</code> isn't really ECB <em>mode</em> but rather the DES block <em>primitive</em>: it encrypts or decrypts one block of exactly 64 bits not less and not more. What you are trying to do should not and cannot work. </p>

<p>Properly-designed cryptosystems that need to handle variable-length data, which many do, either use a stream cipher, a stream mode (like CTR), or a block mode (but not ECB, see below) with padding -- there are a number of standards to choose from; OpenSSL's <code>EVP_{Encrypt,Decrypt,Cipher}*</code> module uses PKCS5/7 padding by default, although you can turn it off. </p>

<hr>

<p>Note DES has been broken and obsolete for two decades, and in most applications where ECB mode has been used even with a good primitive it allows attacks that reduce or eliminate security. If you intend to actually secure something, drop this and use a program designed by someone who knows what they are doing -- but that's offtopic for SO.</p>

<hr>

<p>More ontopic for SO, your program uses the wrong pointer type for the calls to <code>DES_ecb_encrypt</code>, which your compiler should have detected and warned you about; however, because of the way C defines arrays it is unlikely any implementation will actually fail because of this error. Also you didn't #include the required prototypes for <code>exit malloc memcpy</code> and this could result in bugs or crashes on a system with <code>size_t</code> larger than <code>int</code>.</p>
","133","<c><security><openssl><des><ecb>","0","1","1","2017-11-29 06:45:26","47526104","2","","31667","","2017-11-28 05:06:04","2017-11-28 04:52:55",""
"28920112","Encrypting and decrypting File - Lead to ""Bad Data""","<p>I'm currently working a little object that will help me encrypt a file then decrypt it, and return it as a MemoryStream. However, when I'm decrypting, I keep getting a ""Bad data"".</p>

<pre><code>""ExceptionMessage"": ""Bad Data.\ \ "",
""ExceptionType"": ""System.Security.Cryptography.CryptographicException"",
</code></pre>

<p>The Class goes as follow</p>

<pre><code>public class SignatureService {
    private readonly DESCryptoServiceProvider _desCryptoServiceProvider;
    private static byte[] _key = { 5, 6, 7, 2, 3, 4, 8, 1 };
    private static byte[] _iv = { 5, 2, 3, 4, 1, 7, 4, 2 };

    public SignatureService () {
        _desCryptoServiceProvider = new DESCryptoServiceProvider();
    }

    public void SaveSignatureOnDisk ( Stream stream ) {
        using ( var fs = new FileStream( ""filepath"", FileMode.Create, FileAccess.Write ) ) {
            var cryptoStream = new CryptoStream( fs, _desCryptoServiceProvider.CreateEncryptor( _key, _iv ), CryptoStreamMode.Write );
            var bytearrayinput = new byte[ stream.Length - 1 ];
            stream.Read( bytearrayinput, 0, bytearrayinput.Length );
            cryptoStream.Write( bytearrayinput, 0, bytearrayinput.Length );
        }
 }

    public Stream ReadSignatureOnDisk () {
        Stream returnedStream;
        using ( var fs = new FileStream( ""filepath"", FileMode.Open, FileAccess.Read ) ) {
            var cryptoStream = new CryptoStream( fs, _desCryptoServiceProvider.CreateDecryptor( _key, _iv ), CryptoStreamMode.Read );

            string contents = new StreamReader( cryptoStream ).ReadToEnd();
            byte[] unicodes = Encoding.Unicode.GetBytes( contents );
            returnedStream = new MemoryStream( unicodes );
        }

        return returnedStream;
    }
}
</code></pre>
","<p>You made a few mistakes, the CryptoStream and the ICryptoTransform from <code>CreateDecryptor</code> and <code>CreateEncryptor</code> should be disposed. Also your <code>stream.Read</code> is not reliable, Read is not guaranteed to actually read all of the bytes you asked it to. You must either loop till the Read returns 0 or use <a href=""https://msdn.microsoft.com/en-us/library/system.io.stream.copyto%28v=vs.110%29.aspx"" rel=""nofollow noreferrer""><code>.CopyTo(</code></a> if you are on a version of .NET that has it.</p>

<pre><code>public void SaveSignatureOnDisk ( Stream stream ) 
{
    using (var fs = new FileStream(""filepath"", FileMode.Create, FileAccess.Write))
    using (var encryptor = _desCryptoServiceProvider.CreateEncryptor( _key, _iv))
    using (var cryptoStream = new CryptoStream(fs, encryptor, CryptoStreamMode.Write))
    {
        stream.CopyTo(cryptoStream);
    }
}
</code></pre>

<p>Your ReadSignatureOnDisk also has the same mistakes and needs to be fixed similarly.</p>

<pre><code>public Stream ReadSignatureOnDisk ()
{
    Stream returnedStream = new MemoryStream();
    using (var fs = new FileStream(""filepath"", FileMode.Open, FileAccess.Read))
    using (var decryptor = _desCryptoServiceProvider.CreateDecryptor(_key, _iv))
    using (var cryptoStream = new CryptoStream(fs, decryptor, CryptoStreamMode.Read);
    {
        cryptoStream.CopyTo(returnedStream);
    }

    returnedStream.Position = 0
    return returnedStream;
}
</code></pre>

<p>If you want you could use my ReturnableCryptoStream class <a href=""https://stackoverflow.com/a/24188846/80274"">I wrote for another answer</a> which allows you to return the original crypto stream and just let the caller dispose it.</p>

<pre><code>/// &lt;summary&gt;
/// Creates a class that creates a &lt;see cref=""CryptoStream""/&gt; and wraps the disposing action of all the associated objects 
/// &lt;/summary&gt;
class ReturnableCryptoStream : CryptoStream
{
    private readonly ICryptoTransform _transform;
    private readonly IDisposable _algorithom;

    public ReturnableCryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode, IDisposable algorithom) 
        : base(stream, transform, mode)
    {
        _transform = transform;
        _algorithom = algorithom;
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        if (disposing)
        {
            if (_transform != null)
                _transform.Dispose();

            if (_algorithom != null)
                _algorithom.Dispose();
        }
    }
}
</code></pre>

<p>used like</p>

<pre><code>public Stream ReadSignatureOnDisk ()
{
    var fs = new FileStream(""filepath"", FileMode.Open, FileAccess.Read);
    var serviceProvider = new DESCryptoServiceProvider()
    var decryptor = serviceProvider.CreateDecryptor(_key, _iv);
    var cryptoStream = new ReturnableCryptoStream(fs, 
             decryptor, 
             CryptoStreamMode.Read, 
             serviceProvider); 
    //note that I now make my own local copy of the service provider, you could use your 
    //existing one and pass in null to the ReturnableCryptoStream.

    return cryptoStream ;
}
</code></pre>
","127","<c#><encryption><des>","0","1","1","2015-03-13 13:44:21","28920596","1","","1023093","","2015-03-07 21:45:54","2015-03-07 21:17:47",""
"53436072","Why does checking if a HashMap has a certain value take very long to execute within a for loop?","<p>I am working with meet-in-the-middle attack on Double-DES. I have implemented the DES encryption/decryption and done the encryptions and now I would like to perform a MITM attack on the Double-DES in order to find the keys. The way I am trying to achieve this is by storing, within a for loop, the intermediate ciphers as the key of a HashMap and the possible keys as the values of the HashMap. However, within this for loop I also want to make sure that the possible keys are unique i.e. I have an if statement, which checks whether the possible key already exists in the HashMap. If not, then it uses it to encrypt the plain text and store the cipher text and the possible key in the HashMap. Aftwards, I try to find the keys, which have matching intermediate cipher text by iterating through the HashMap with a foreach and compare each intermediate cipher text from the encryptions with the intermediate cipher text from the decryptions. </p>

<p>However, I am unable to find the match as it takes too long to finish. I have been waiting for like 2 hours now without any result. If I remove the if statement, which checks if the possible key is already in the HashMap it finishes in like 10 seconds.</p>

<pre><code>for (int size = intermediateCipher.size(); size &lt; Math.pow(2, 20); size++) { // intermediateCipher is my HashMap consisting of &lt;String, byte[]&gt;
    byte[] possibleKey = generateDesKey(); // generateDesKey generates a key of 64 bits
    if (!intermediateCipher.containsValue(possibleKey)) {
        intermediateCipher.put((encrypt(possibleKey, plainText)).toString(), possibleKey);
    }
}

int count = 0;
for (Entry&lt;String, byte[]&gt; arr : intermediateCipher.entrySet()) {

    String temp = (decrypt(arr.getValue(), cipherText)).toString();

    if (intermediateCipher.containsKey(temp)) {
        count++;
    }
}
</code></pre>

<p>I should mention that only 20 bits of the DES key is effective. That is why there are 2^20 possible keys. Furthermore, if I don't have the if statement, which checks if the possible key is already in the HashMap, I get 510 matches, which is too much.</p>

<p>UPDATE:</p>

<p>I have tried using a Set in order to store the keys first and then used the keys from the Set to encrypt etc. However, instead of having a for, which iterates from 0 to 2^20, I have tried with a while loop, which checks iterates as long as the Set has elements. However, I have tried running this approach for over 10 mins without any result. It never gets out of the loop.</p>

<pre><code>for (int i = 0; i &lt; Math.pow(2, 20); i++) {
            possibleKeySet.add(generateDesKey());
        }
        System.out.println(possibleKeySet.size());

        for (int i = 0; i &lt; possibleKeySet.size(); i++) {

            intermediateCipher.put((encrypt(possibleKeySet.iterator().next(), plainText)).toString(),
                    possibleKeySet.iterator().next());
        }

        System.out.println(""ss "" + intermediateCipher.size());

        int count = 0;
        for (Entry&lt;String, byte[]&gt; arr : intermediateCipher.entrySet()) {

            String temp = ((decrypt(arr.getValue(), cipherText)).toString());
            if (intermediateCipher.containsKey(temp)) {
                count++;
            }
        }
</code></pre>

<p>I have read that for a set hasNext() always returns true for a non-empty collection. So, I have tried with a for each, but the size of the hashMap is never the same as the size of the set of keys, which doesn't make sense to me as I use every key in the set:</p>

<pre><code>for (int i = 0; i &lt; Math.pow(2, 20); i++) {
            possibleKeySet.add(generateDesKey());
        }

        System.out.println(possibleKeySet.size());

        for (byte[] key : possibleKeySet) {
            intermediateCipher.put((encrypt(key, plainText)).toString(),
                    key);
        }
</code></pre>
","<p><a href=""https://docs.oracle.com/javase/10/docs/api/java/util/Map.html#containsValue(java.lang.Object)"" rel=""nofollow noreferrer""><code>Map.containsValue()</code></a> will have a linear time as you are iterating blindly over all the map values. As per the method javadoc:</p>

<blockquote>
  <p>Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that Objects.equals(value, v). <strong>This operation will probably require time linear in the map size for most implementations of the Map interface.</strong></p>
</blockquote>

<p>To take advantage of a hash lookup you should check the keys with <a href=""https://docs.oracle.com/javase/10/docs/api/java/util/Map.html#containsKey(java.lang.Object)"" rel=""nofollow noreferrer""><code>Map.containsKey()</code></a>:</p>

<pre><code>if (!intermediateCipher.containsKey(possibleKey)) {
  ...
}
</code></pre>
","121","<java><performance><hashmap><des>","4","1","2","2018-11-22 21:08:34","","5","1","4789269","","2018-11-22 21:08:34","2018-11-22 17:48:00",""
"53436072","Why does checking if a HashMap has a certain value take very long to execute within a for loop?","<p>I am working with meet-in-the-middle attack on Double-DES. I have implemented the DES encryption/decryption and done the encryptions and now I would like to perform a MITM attack on the Double-DES in order to find the keys. The way I am trying to achieve this is by storing, within a for loop, the intermediate ciphers as the key of a HashMap and the possible keys as the values of the HashMap. However, within this for loop I also want to make sure that the possible keys are unique i.e. I have an if statement, which checks whether the possible key already exists in the HashMap. If not, then it uses it to encrypt the plain text and store the cipher text and the possible key in the HashMap. Aftwards, I try to find the keys, which have matching intermediate cipher text by iterating through the HashMap with a foreach and compare each intermediate cipher text from the encryptions with the intermediate cipher text from the decryptions. </p>

<p>However, I am unable to find the match as it takes too long to finish. I have been waiting for like 2 hours now without any result. If I remove the if statement, which checks if the possible key is already in the HashMap it finishes in like 10 seconds.</p>

<pre><code>for (int size = intermediateCipher.size(); size &lt; Math.pow(2, 20); size++) { // intermediateCipher is my HashMap consisting of &lt;String, byte[]&gt;
    byte[] possibleKey = generateDesKey(); // generateDesKey generates a key of 64 bits
    if (!intermediateCipher.containsValue(possibleKey)) {
        intermediateCipher.put((encrypt(possibleKey, plainText)).toString(), possibleKey);
    }
}

int count = 0;
for (Entry&lt;String, byte[]&gt; arr : intermediateCipher.entrySet()) {

    String temp = (decrypt(arr.getValue(), cipherText)).toString();

    if (intermediateCipher.containsKey(temp)) {
        count++;
    }
}
</code></pre>

<p>I should mention that only 20 bits of the DES key is effective. That is why there are 2^20 possible keys. Furthermore, if I don't have the if statement, which checks if the possible key is already in the HashMap, I get 510 matches, which is too much.</p>

<p>UPDATE:</p>

<p>I have tried using a Set in order to store the keys first and then used the keys from the Set to encrypt etc. However, instead of having a for, which iterates from 0 to 2^20, I have tried with a while loop, which checks iterates as long as the Set has elements. However, I have tried running this approach for over 10 mins without any result. It never gets out of the loop.</p>

<pre><code>for (int i = 0; i &lt; Math.pow(2, 20); i++) {
            possibleKeySet.add(generateDesKey());
        }
        System.out.println(possibleKeySet.size());

        for (int i = 0; i &lt; possibleKeySet.size(); i++) {

            intermediateCipher.put((encrypt(possibleKeySet.iterator().next(), plainText)).toString(),
                    possibleKeySet.iterator().next());
        }

        System.out.println(""ss "" + intermediateCipher.size());

        int count = 0;
        for (Entry&lt;String, byte[]&gt; arr : intermediateCipher.entrySet()) {

            String temp = ((decrypt(arr.getValue(), cipherText)).toString());
            if (intermediateCipher.containsKey(temp)) {
                count++;
            }
        }
</code></pre>

<p>I have read that for a set hasNext() always returns true for a non-empty collection. So, I have tried with a for each, but the size of the hashMap is never the same as the size of the set of keys, which doesn't make sense to me as I use every key in the set:</p>

<pre><code>for (int i = 0; i &lt; Math.pow(2, 20); i++) {
            possibleKeySet.add(generateDesKey());
        }

        System.out.println(possibleKeySet.size());

        for (byte[] key : possibleKeySet) {
            intermediateCipher.put((encrypt(key, plainText)).toString(),
                    key);
        }
</code></pre>
","<p><code>Map.containsValue()</code> must check every map entry.  That costs O(n) in the size of the map.  Supposing that the number of duplicates does not exceed a fixed fraction of all keys generated, checking <code>containsValue()</code> on each iteration of your loop then costs an aggregate O(n<sup>2</sup>) in the number of keys generated.  For a million keys that's awfully expensive.</p>

<p>Consider instead keeping an auxiliary <code>Set</code> of the keys stored so far, and testing membership in that set instead of directly testing the values in the Map.</p>
","121","<java><performance><hashmap><des>","4","1","2","2018-11-22 21:08:34","","5","1","4789269","","2018-11-22 21:08:34","2018-11-22 17:48:00",""
"1303150","General Design Question about data binding in WPF","<p>I'm starting to use Binding in my WPF project and I'm actually confused about few things on the presentation side (XAML).</p>

<p>So I want to populate a <code>TreeView</code> with a List of Categories. I know how to write the right <code>HierarchicalDataTemplate</code> for my List of Category instances. </p>

<pre><code>&lt;HierarchicalDataTemplate ItemsSource=""{Binding Path=ChildrenCategories}"" DataType=""{x:Type src:Category}""&gt;
      &lt;TextBlock Text=""{Binding Path=Name}""&gt;&lt;/TextBlock&gt;
&lt;/HierarchicalDataTemplate&gt;
</code></pre>

<p>But what now I don't know is from where to get the list. I have here 2 solutions :</p>

<ol>
<li><p>I got a <code>Library Singleton</code> class
    which return me the right
    arborescence, then I need to use an
    <code>ObjectDataProvider</code> in my xaml which
    would call the
    Library.Instance.Categories method. (Which means that the controller has to be completely separated from the UI).</p></li>
<li><p>I got a <code>Property ListCategories</code>
        in my page interactionLogic
        (OpenUnit.xaml.cs), and bind the
        tree with it.</p></li>
</ol>

<p>I'm not sure about the purpose of the xaml.cs files, what are they made for? Is it normally used to store the properties (and act as a controller) or simply to have a back-end for the UI (for example get values from the UI?)?</p>

<p>In case the xaml.cs file is used as a controller, how do I bind my data to it, I've tried many solutions without success,my only success was with the use  of static binding.</p>

<p>I would appreciate any comment or recommandation about UI and Logic Binding in WPF, hopefully I will get less confused.</p>

<p>Thanks in advance, </p>

<p>Boris</p>
","<p>After reading this great article, I got a little bit less confused :</p>

<p><a href=""http://msdn.microsoft.com/en-us/magazine/dd419663.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/magazine/dd419663.aspx</a></p>

<p>The article is about the Model View ViewController pattern, and how WPF integrates it. So it seems that xaml.cs files should be used as the ViewController here, and should hold the properties.
It actually make sense since it's not a good practice to mix the View and the Data, we want the designers should have a completely independant work to do.</p>

<p>Also for the solution 2) it is possible if you set the data context to the current file.</p>
","120","<wpf><data-binding><treeview><des>","0","0","1","2011-08-09 01:59:17","","1","","305637","","2011-08-09 01:59:17","2009-08-19 23:21:47",""
"47127235","javax.crypto.BadPaddingException: Given final block not properly padded when decrypt file","<p>I am writing a small secure storage server simulation, in order to get familira with Cryptography techniques and algorithms. I stucked on decryption of file content. Project is a little bit large to put it all here, so I will put excepts ( methods which I use and where problem occurs) from code.
Problem is, when I try to decrypt file,BadPaddingException happens.
Excepts of Crypto class, where main crypto logic is implemented</p>

<pre><code>public class Crypto {

private Cipher asymmCipher;
//one cipher for asymmetric and one for symmetric
private Cipher symmCipher;

public IvParameterSpec iv;
SecureRandom sr;
KeyGenerator kg;

   public Crypto() throws NoSuchAlgorithmException, NoSuchPaddingException {
      this.asymmCipher = Cipher.getInstance(""RSA"");
      this.symmCipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
   }
 /*
        Method for symmetric encription of file
 */
  public byte[] SymmetricFileEncryption(byte[] file, SecretKey key)
          throws InvalidKeyException, IllegalBlockSizeException,
          BadPaddingException, NoSuchAlgorithmException {

      this.symmCipher.init(Cipher.ENCRYPT_MODE, key);

      return this.symmCipher.doFinal(file);
  }

 /*
        Method for symmetric decription of file
 */
  public byte[] SymmetricFileDecription(byte[] file, SecretKey key)
          throws InvalidKeyException, IllegalBlockSizeException,
          BadPaddingException, InvalidAlgorithmParameterException {
      this.symmCipher.init(Cipher.DECRYPT_MODE, key);
      return this.symmCipher.doFinal(file);
  }
    /*
        Method for write encrypted file
 */
public void writeToFile(File output, byte[] data, SecretKey key)
        throws IllegalBlockSizeException, BadPaddingException, 
        IOException, InvalidKeyException, NoSuchAlgorithmException {

    FileOutputStream fos = new FileOutputStream(output);
    byte[] encContent = SymmetricFileEncryption(data, key);
    fos.write(encContent);
    fos.flush();
    fos.close();
}
   public byte[] readFromFile(File input, SecretKey key)
        throws IllegalBlockSizeException, BadPaddingException, 
        IOException, InvalidKeyException, NoSuchAlgorithmException, InvalidAlgorithmParameterException {

    byte[] fileContent = new byte[(int) input.length()];
    FileInputStream fis = new FileInputStream(input);
    fis.read(fileContent);
    fis.close();

    return SymmetricFileDecription(fileContent, key);
}

}
</code></pre>

<p>When I try to use symmetric file enc and dec one after other like :</p>

<pre><code>                    String test = ""Test symmetric file enc / dec"";
                    byte[] tesT = aCrypto.SymmetricFileEncryption(test.getBytes(), sessionKey);
                    System.out.println(""ENC FROM SERVER "" + new String(tesT));
                    String test2 = new String(aCrypto.SymmetricFileDecription(tesT, sessionKey));
                    System.out.println(""DEC FROM SERVER: "" + test2);
</code></pre>

<p>it works well.</p>

<p>Except from Server for new File creation and for edit file(where I need reading and decrypting)</p>

<pre><code>               if (""new"".equals(option)) {
                    String fileName = aCrypto.DecryptStringSymmetric((String) ois.readObject(), sessionKey);
                    System.out.println(""FILE NAME SERVER POSLAN IS UPANEL CONTROLLERA : "" + fileName);
                    // String cFileName = aCrypto.EncryptStringSymmetric(fileName, sessionKey);
                    String formatedEncFileName = aCrypto.encodeWithSHA256(fileName).replaceAll(""\\/"", """");
                    File f = new File(""src/server/users/"" + userName + ""/"" + formatedEncFileName);

                    if (!f.exists()) {
                        f.createNewFile();
                        System.out.println(""FILE CREATED!"");
                        fileNamesMap.put(formatedEncFileName, fileName);
                        serialize(fileNamesMap);
                        System.out.println(""MAP VALUE FOR "" + fileNamesMap.get(formatedEncFileName));
                    }
                    byte[] file = aCrypto.SymmetricFileDecription(((byte[]) ois.readObject()), sessionKey);
                    System.out.println(""FILE CONTENT :  "" + new String(file));
                   // String encContent = aCrypto.EncryptStringSymmetric(new String(file), sessionKey);
                    aCrypto.writeToFile(f, file, sessionKey);
                    oos.writeObject(aCrypto.EncryptStringSymmetric(((f.exists()) ? ""true"" : ""false""), sessionKey));
                    changeFileWatcher(userName);
                }
                    if ((""edit"").equals(option)) {
                    fileName = aCrypto.DecryptStringSymmetric((String) ois.readObject(), sessionKey);
                    byte[] content = aCrypto.readFromFile(new File(PATH + userName + ""/"" + (String)  getKeyFromValue(fileNamesMap, fileName.split(""/"")[4])), sessionKey); //Exception in readFromFile
                    String fileContent = aCrypto.DecryptStringSymmetric(new String(content), sessionKey);
                    oos.writeObject(aCrypto.EncryptStringSymmetric(fileContent, sessionKey));
                    System.out.println(""NAME FROM SERVER IN EDIT : "" + fileName);
                }
                if ((""modify"").equals(option)) {
                    String editedFileContent = aCrypto.DecryptStringSymmetric((String) ois.readObject(), sessionKey);
                    System.out.println(""NAME FROM SERVER IN MODIFY: "" + fileName);
                    String encrytedFileContent = aCrypto.EncryptStringSymmetric(editedFileContent, sessionKey);
                    File f = new File(PATH + userName + ""/"" + (String) getKeyFromValue(fileNamesMap, fileName.split(""/"")[4]));
                    aCrypto.writeToFile(f, encrytedFileContent.getBytes(), sessionKey);
                    oos.writeObject(aCrypto.EncryptStringSymmetric(""true"", sessionKey));
                }
</code></pre>

<p>Another example - I put print in writeToFile method and tested write and read :</p>

<pre><code>    String test = ""Test symmetric file enc / dec"";
    File fileTest = new File(""src/server/testFileEnc"");
    if(!fileTest.exists()) {
        fileTest.createNewFile();
    }
    aCrypto.writeToFile(fileTest, test.getBytes(), sessionKey);
                    String decryptedFromFile = new String(aCrypto.readFromFile(fileTest , sessionKey));
    System.out.println(""DECRYPTED DATA "" + decryptedFromFile);
</code></pre>

<p>Output : </p>

<pre><code>  ENCRYPTED DATA:  ×^đzŞĘňmř”›&amp;şH«ťq
  DECRYPTED DATA : Test symmetric file enc / dec
</code></pre>
","<p>Finally I have found problem. Problem is that I am a little bit dumb :)
I forgot that with every new client, new session key is generated, so even if I created encrypted file with specific user, after application restart, user is provided with new 3DES key, and with that new key I am trying to decrypt file encrypted with different 3DES key. 
I need to store session key on server, and to use same key for specific user</p>
","120","<java><encryption><des>","0","0","1","2017-11-06 14:31:37","","2","1","5348310","","2017-11-06 11:53:03","2017-11-05 22:17:19",""
"21277796","Unable to pass encrypted text to .net web service","<p>I'm working on a <code>web service</code> based system which has a Client who encrypts a text using <code>DES</code> algorithm.</p>

<p>When my client sends the encrypted text to a web method on the web service, I catch a </p>

<blockquote>
  <p><em>ProtocolException exception saying The remote server returned an unexpected response: (400) Bad Request.</em></p>
</blockquote>

<p>Text before encryption : ""Hello""<br>
Text after encryption : ""I%�l�*�""</p>

<p>What should I do to solve the issue?</p>
","<p>Exception occurred due to special characters in string which is not supported.
You can make change in service to accept stream in place of string.</p>

<p>Server side code :</p>

<pre><code>Boolean GetData(Stream fStream)
{
    try 
    {           
    // Read the stream into a byte array

    Byte[] data  = new Byte[32767];
    using (MemoryStream ms = new MemoryStream())
    {
            while(true)
            {
                    Int32 read = stream.Read(data, 0, data.Length);
                    if(read &lt;= 0)
                        return ms.ToArray();
                    ms.Write(data, 0, read);
            }
    }

    // Copy to a string for header parsing
    String content = Encoding.UTF8.GetString(data);

    // do something
    }
    catch (Exception ex)
    {
    throw(ex);
    }
}
</code></pre>
","115","<c#><.net><web-services><encryption><des>","0","1","1","2014-01-22 08:53:49","21278006","2","1","447156","","2014-01-22 08:33:08","2014-01-22 08:31:42",""
"18913825","Encryption and Decryption of File","<p>I am trying to encrypt and decrypt a file. The file can be any file like txt, jpg, doc, pdf.
The IV is prepended to the cipher text. but while decrypting if i read first 8 bytes it gives me different value then the value of IV while encryption.</p>

<p>Here is my code to encrypt the file</p>

<pre><code>fsOut = new FileStream(savepath, FileMode.OpenOrCreate, FileAccess.Write);
                des = new DESCryptoServiceProvider();
                des.Key = ASCIIEncoding.ASCII.GetBytes(secretkey);                 

                des.GenerateIV();                

                desencrypt = des.CreateEncryptor();
                cryptoStream = new CryptoStream(fsOut, desencrypt, CryptoStreamMode.Write);

                //write the IV to beginning of encrypted data
                BinaryWriter bw = new BinaryWriter(cryptoStream);
                bw.Write(des.IV, 0, des.IV.Length);

                // Now will initialize a buffer and will be 
                // processing the input file in chunks. 
                // This is done to avoid reading the whole file (which can be
                // huge) into memory. 
                int bufferLen = 4096;
                byte[] buffer = new byte[bufferLen];
                int bytesRead;
                do
                {
                    // read a chunk of data from the input file 
                    bytesRead = filestream.Read(buffer, 0, bufferLen);
                    // Encrypt it 
                    cryptoStream.Write(buffer, 0, bytesRead);
                }
                while (bytesRead != 0);

                cryptoStream.FlushFinalBlock();
</code></pre>

<p>This produces an encrypted file to the specified location.</p>

<p>Now below is my decryption code</p>

<pre><code>des = new DESCryptoServiceProvider();
                des.Key = Encoding.ASCII.GetBytes(secretkey);

                byte[] iv = new byte[8];
                sourcefile.Read(iv, 0, 8);
                des.IV = iv;

                desdecrypt = des.CreateDecryptor();
                msOut = new MemoryStream();
                cryptoStream = new CryptoStream(sourcefile, desdecrypt, CryptoStreamMode.Read);

                StreamWriter fsDecrypted = new StreamWriter(""D:\\tempDecrypted.jpg"");
                fsDecrypted.Write(new StreamReader(cryptoStream).ReadToEnd());
                fsDecrypted.Flush();
                fsDecrypted.Close();
</code></pre>
","<p>You are writing your IV to the <code>CryptoStream</code> so it will be transformed to ciphertext. The IV should be prepended to the ciphertext in plain, it should not be part of the ciphertext.</p>
","115","<encryption><des>","-1","0","1","2015-11-17 08:49:18","","4","","126273","","2015-11-17 08:49:18","2013-09-20 09:54:03",""
"14432074","a function about pc1 operation in DES","<p>when I read the des source of ""openssl ""  . there is a comment that "" 
do PC1 in 47 simple operations :-)
    * Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
    * for the inspiration. :-)
""</p>

<pre><code>PERM_OP (d,c,t,4,0x0f0f0f0fL);
HPERM_OP(c,t,-2,0xcccc0000L);/
HPERM_OP(d,t,-2,0xcccc0000L);/
PERM_OP (d,c,t,1,0x55555555L);
PERM_OP (c,d,t,8,0x00ff00ffL);
PERM_OP (d,c,t,1,0x55555555L);
</code></pre>

<p>it could reduce 56 operation to 47 . </p>

<p>Could anyone tell me theory of this . ?</p>

<p>And  the array static const DES_LONG des_skb[8][64]={</p>

<p>it isn't define  in arithmetic statement</p>

<p>why the openssl optimize it~~~?</p>
","","113","<openssl><des>","1","","0","2013-01-21 03:24:09","","0","","","","","2013-01-21 03:24:09",""
"55280102","Why AES Produce Different result and Why DES not Produce","<p>I'm trying to change encryption algorithm of existing project. But i have a little bit confusion. When i use ""PBEWithHmacSHA512AndAES_256"" as a parameter, it produce different result but when i use ""PBEWithMD5AndDES"" as a parameter it produce same result. My functions are : </p>

<pre><code> public static synchronized String encrypt1(final String textToEncrypt, final String pathPublicKey) throws Exception {
    final KeySpec pbeKeySpec = new PBEKeySpec(DbKeyHandler.getDbKey(pathPublicKey).toCharArray());
    final SecretKey pbeKey = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(pbeKeySpec);
    // Prepare the parameter to the ciphers
    final AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);
    final Cipher cipher = Cipher.getInstance(pbeKey.getAlgorithm());

    // Create the ciphers
    cipher.init(Cipher.ENCRYPT_MODE, pbeKey, paramSpec);

    // Encode the string into bytes using utf-8
    final byte[] utf8 = textToEncrypt.getBytes(""UTF8"");

    // Encrypt
    final byte[] enc = cipher.doFinal(utf8);

    // Encode bytes to base64 to get a string
    return new sun.misc.BASE64Encoder().encode(enc);
}


public static synchronized String encrypt2 (final String textToEncrypt, final String pathPublicKey) throws Exception {
    final KeySpec pbeKeySpec = new PBEKeySpec(DbKeyHandler.getDbKey(pathPublicKey).toCharArray());
    final SecretKey pbeKey = SecretKeyFactory.getInstance(""PBEWithHmacSHA512AndAES_256"").generateSecret(pbeKeySpec);
    // Prepare the parameter to the ciphers
    final AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);
    final Cipher cipher = Cipher.getInstance(pbeKey.getAlgorithm());

    // Create the ciphers
    cipher.init(Cipher.ENCRYPT_MODE, pbeKey, paramSpec);

    // Encode the string into bytes using utf-8
    final byte[] utf8 = textToEncrypt.getBytes(""UTF8"");

    // Encrypt
    final byte[] enc = cipher.doFinal(utf8);

    // Encode bytes to base64 to get a string
    return new sun.misc.BASE64Encoder().encode(enc);
}
</code></pre>

<p>Any suggestions, ideas will help me to figure out what's going on here.</p>

<p>Also this is produce different results: </p>

<pre><code>    KeyStore keyStore = KeyStore.getInstance(""JCEKS"");
    keyStore.load(new FileInputStream((pathOfJKSfile)), password.toCharArray());
    Key key = keyStore.getKey(keyName, keyPass.toCharArray());
    byte[] raw = key.getEncoded();
    SecretKeySpec secretKeySpec = new SecretKeySpec(raw, ""PBEWithHmacSHA512AndAES_256"");
    final AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATIONS);

    final Cipher cipherEncrypt = Cipher.getInstance(ALGORITHM);
    cipherEncrypt.init(Cipher.ENCRYPT_MODE, secretKeySpec, paramSpec);

    final byte[] enc = cipherEncrypt.doFinal(messageBytes);
    System.out.println( new sun.misc.BASE64Encoder().encode(enc));
</code></pre>

<p>And i know that cipher.init() using ""JceSecurity.RANDOM"" for pruducing different results. </p>
","<ul>
<li><p>Both algorithms, <code>PBEWithHmacSHA512AndAES_256</code> and <code>PBEWithMD5AndDES</code>, first generate an encryption key by processing a password, a salt and an iteration count (using <code>HmacSHA512</code> and <code>MD5</code>, respectively) and then encrypt the plain text (with <code>AES-256</code> and <code>DES</code>, respectively) using this key and the <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)"" rel=""nofollow noreferrer""><code>CBC</code>-mode</a>. When the <code>Cipher</code>-instance is initialized, a pseudo-random <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Initialization_vector_(IV)"" rel=""nofollow noreferrer"">initialization vector</a> (IV) is generated that is required for the <code>CBC</code>- mode.</p></li>
<li><p>In the context of <code>PBEWithHmacSHA512AndAES_256</code>, the IV is generated <em>using the <code>SecureRandom</code> implementation of the highest-priority installed provider</em>, at least for the <a href=""https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/crypto/Cipher.html#init(int,java.security.Key,java.security.AlgorithmParameters)"" rel=""nofollow noreferrer""><code>Cipher#init()</code></a>-method used in the code (note that there are several overloads of the <code>Cipher#init()</code>-method and that a <code>SecureRandom</code>-instance can also be passed explicitly). I.e. with each <code>Cipher</code>-initialization a <strong>new</strong> (random) IV is generated and therefore the encrypted text is always different, even for an identical plain text. For this reason, the encrypted text in your examples changes in this context.</p></li>
<li><p>In the context of <code>PBEWithMD5AndDES</code>, the IV is <strong>only</strong> determined by the password, the salt, the iteration count (and of course the <code>MD5</code>-hash-algorithm itself). Therefore, the IV and the encrypted text do not change in case of repetition (provided that password, salt, iteration count etc. are the same). For this reason, the encrypted text in your example does not change in this context.</p></li>
<li><p>The generation of a new, random IV during the Cipher-initalization makes sense with regard to the following requirements for the IV: For security reasons, an IV in <code>CBC</code>-mode (btw this also applies to other modes) <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Initialization_vector_(IV)"" rel=""nofollow noreferrer"">may only be used once under the same key</a>. In addition the IV must be unpredictable.</p></li>
<li><p><code>PBEWithMD5AndDES</code> is <a href=""https://stackoverflow.com/questions/54143361/what-is-pbewithmd5anddes"">deprecated</a>.</p></li>
</ul>

<p><strong>EDIT:</strong></p>

<ul>
<li><p>The use of an IV is standard nowadays (for security reasons). A lot of information can be found on the Internet on this topic e.g. <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">here</a>. In the following I will only describe a few basic things.</p></li>
<li><p>The IV used for encryption must be stored in some way because it is required for decryption. The IV does not have to be kept secret, so that it is usually concatenated with the encrypted data (e.g. before the encrypted data) and stored together with them. During decryption, both parts can be separated because the length of the IV is known (16 Byte for AES). E.g for the concatenation in the encryption-method something like the following is used (let <code>iv</code> and <code>enc</code> be the byte-arrays with the IV and the encrypted data, respectively): </p>

<pre><code>byte[] result = new byte[enc.length + iv.length];
System.arraycopy(iv, 0, result, 0, iv.length);
System.arraycopy(enc, 0, result, iv.length, enc.length);
</code></pre>

<p>and in the decryption-method the corresponding counterpart (having in mind that the length of an IV in AES is 16 Byte).</p></li>
<li><p>In the encryption-method the IV can be determined with <code>Cipher#getIV()</code> (this must of course happen after calling <code>Cipher#init()</code>).</p></li>
<li><p>In the decryption-method you have to pass the IV to the <code>PBEParameterSpec</code>-ctor (e.g. let <code>iv</code> be the byte-array with the IV):</p>

<pre><code>IvParameterSpec ivSpec = new IvParameterSpec(iv); 
AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount, ivSpec);
</code></pre></li>
<li><p>The generation of an IV can also take place outside the <code>Cipher</code>-class, see e.g. <a href=""https://stackoverflow.com/questions/29267435/generating-random-iv-for-aes-in-java"">Generating random IV for AES in Java</a>. Then you have to pass that IV in the encryption-method in the same way as above described for the decryption-method. </p></li>
<li><p>Note, in connection with an IV some points have to be considered e.g. using a mode without an IV (e.g. ECB), using an IV consisting exclusively of <code>0</code>-values, using a predictable IV or using an IV more than once under the same key etc. drastically reduces security in general, see e.g. <a href=""https://en.wikipedia.org/wiki/Initialization_vector"" rel=""nofollow noreferrer"">here</a>!</p></li>
</ul>
","111","<java><encryption><aes><des>","0","2","1","2019-03-24 14:20:36","55300746","0","","","","","2019-03-21 12:07:48",""
"39271415","javax.crypto.BadPaddingException: Given final block not properly padded DES","<p>I get error when I try to decode. 
This is Decoder:</p>

<pre><code>public class Encrypter {

    Cipher ecipher;
    Cipher dcipher;

    SecretKeySpec key = new SecretKeySpec(""missyou1"".getBytes(), ""DES"");

    public DesEncrypter() throws Exception {
        ecipher = Cipher.getInstance(""DES"");
        dcipher = Cipher.getInstance(""DES"");
        ecipher.init(Cipher.ENCRYPT_MODE, key);
        dcipher.init(Cipher.DECRYPT_MODE, key);
    }

    public String encrypt(String str) throws Exception {
        byte[] utf8 = str.getBytes(""UTF8"");
        byte[] enc = ecipher.doFinal(utf8);
        return new sun.misc.BASE64Encoder().encode(enc);
    }

    public String decrypt(String str) throws Exception {
        byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);

        byte[] asd = new byte[(dec.length/8+1)*8];
        for(int i = 0; i &lt; dec.length; i++){
            asd[i] = dec[i];
        }
        byte[] utf8 = dcipher.doFinal(asd);

        return new String(utf8, ""UTF8"");
    }
}
</code></pre>

<p>This is code where I get error:</p>

<pre><code>private static void appenda(Encrypter encrypt) {
        if (Files.exists(Paths.get(filePath), new LinkOption[] { LinkOption.NOFOLLOW_LINKS })) {
            Stream&lt;String&gt; stringStream = null;
            try {
                stringStream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8);
            } catch (IOException e) {
                LOGGER.error(""Failed "", e);
            }

            if (stringStream.toString() != null) {
                stringStream.forEach(s -&gt; {
                    try {
                        System.out.println(encrypt.decrypt(s));
                        endpoint.delete(0, endpoint.length());
                        endpoint.append(encrypt.decrypt(s));
                    } catch (Exception e) {
                        LOGGER.error(""Failed to decrypt"", e);
                    }
                });
            }
        }
    }
</code></pre>

<p>in line <code>endpoint.append(encrypter.decrypt(s));</code>
Any idea why?</p>
","<p>Its not working because you are needlessly copying the data into an incorrectly sized array.</p>

<p>Just remove the array copy and decrypt the bytes directly.</p>

<pre><code>public String decrypt(String str) throws Exception {
    byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);
    byte[] utf8 = dcipher.doFinal(dec);
    return new String(utf8, ""UTF8"");
}
</code></pre>
","109","<java><des>","-1","0","1","2016-09-01 12:59:02","","1","2","","","","2016-09-01 12:19:15",""
"55844991","After function call, argument pointers don't keep their value","<p>I am passing 3 pointers (key, K1Ptr, K2Ptr) as arguments to a function (keyGenerator) but when the function call ends, only the key pointer keeps the value from the function call and the other 2 pointers don't.</p>

<p>I have tried a lot of different things, like returning an array with the 2 pointers, or i tried not using pointers and pass 2 arrays instead. Both tries had the same result none kept value after the function call.</p>

<pre><code>char K1[9], K2[9];
char *K1ptr, *K2ptr;

K1ptr = K1;
K2ptr = K2;

keyGenerator(key, K1ptr, K2ptr);

printf(""Key. %s\n"", key);
printf(""K1. %s\n"", K1Ptr);
printf(""K2. %s\n"", K2Ptr);
</code></pre>

<p>\</p>

<pre><code>void keyGenerator(char *key, char *K1, char *K2) {

char P10_Left[6];
char P10_Right[6];
char *P10leftPtr, *P10rightPtr;


printf(""Starting key: %s\n"", key);

//P10 Operation first step
P10_swap(key);
printf(""P10swap key: %s\n"", key);

//Initializing the left and right arrays
int i;
for(i=0;i&lt;5;i++) {

    P10_Left[i] = key[i];
    P10_Right[i] = key[i+5];
}
P10_Left[5] = '\0';
P10_Right[5] = '\0';

P10leftPtr = P10_Left;
P10rightPtr = P10_Right;

//The left half shift
LS(P10leftPtr, 1);
//The right half shift
LS(P10rightPtr, 1);


//P8 swap starts here
K1 = P8_swap(P10leftPtr, P10rightPtr);

printf(""K1 key: %s\n"", K1);
//P8 swap ends here


//After we find K1 we need to shift the 2 halves again, 2 times to the left this time
//The left half shift
LS(P10leftPtr, 2);
//The right half shift
LS(P10rightPtr, 2);


//After the 2 shifts we use P8 operation again on the new halves
//P8 swap starts here
K2 = P8_swap(P10leftPtr, P10rightPtr);

printf(""K2 key: %s\n"", K2);
//P8 swap ends here
</code></pre>

<p>}
//</p>

<pre><code>char* P8_swap(char *left_key, char *right_key) {

int P8[8] = {6, 3, 7, 4, 8, 5, 10, 9}; //key possitions after P8 operation
char P8_Output[9];
char *K1; //They key after the P8 swap
char keyLR[11]; //The left and right halves will be stored together here

int i;

//The two halves become one so that we can do the P8 swap
for(i=0;i&lt;5;i++) {
    keyLR[i] = left_key[i];
    keyLR[i+5] = right_key[i];
}

//P8 swap
for(i=0; i&lt;8; i++) {
    P8_Output[i] = keyLR[P8[i]-1];  //P10[i] - 1 because the possitiongs in P10 are from 1-10 and not 0-9
}

P8_Output[8] = '\0';

K1 = P8_Output;

return K1;
</code></pre>

<p>}</p>

<p>After the function keyGenerator when i print the K1Ptr and K2Ptr i get nothing but i was expecting to get the values that are stored inside the function.</p>
","<p>In this line:</p>

<pre><code>K1 = P8_swap(P10leftPtr, P10rightPtr);
</code></pre>

<p>you change the value of <code>K1</code> but that change is <strong>local</strong> to the function and will not change the value of <code>K1ptr</code> in <code>main</code>.</p>

<p>If you want to change the value of <code>K1ptr</code> in <code>main</code> you need to pass a <strong>pointer to <code>K1ptr</code></strong> to the function. However, that would seem a bit strange as you initialize <code>K1ptr</code> to point to the char-array <code>K1[9]</code>. My guess is that you don't want to change the pointer value in the function but just copy some data into the ""pointed-to"" array.</p>

<p>BTW:</p>

<p>Your <code>P8_swap</code> is wrong. You return a pointer to <code>P8_Output</code> which is a local variable. Never do that! When the function returns, the local variable goes out of scope (aka no longer exists) so the returned pointer points to illegal memory. If you really want something like that, you must use dynamic memory allocation.</p>
","108","<c><des>","2","2","3","2019-04-25 10:24:31","55845585","3","","11409331","","2019-04-25 08:56:44","2019-04-25 08:30:35","2019-04-25 09:10:03"
"55844991","After function call, argument pointers don't keep their value","<p>I am passing 3 pointers (key, K1Ptr, K2Ptr) as arguments to a function (keyGenerator) but when the function call ends, only the key pointer keeps the value from the function call and the other 2 pointers don't.</p>

<p>I have tried a lot of different things, like returning an array with the 2 pointers, or i tried not using pointers and pass 2 arrays instead. Both tries had the same result none kept value after the function call.</p>

<pre><code>char K1[9], K2[9];
char *K1ptr, *K2ptr;

K1ptr = K1;
K2ptr = K2;

keyGenerator(key, K1ptr, K2ptr);

printf(""Key. %s\n"", key);
printf(""K1. %s\n"", K1Ptr);
printf(""K2. %s\n"", K2Ptr);
</code></pre>

<p>\</p>

<pre><code>void keyGenerator(char *key, char *K1, char *K2) {

char P10_Left[6];
char P10_Right[6];
char *P10leftPtr, *P10rightPtr;


printf(""Starting key: %s\n"", key);

//P10 Operation first step
P10_swap(key);
printf(""P10swap key: %s\n"", key);

//Initializing the left and right arrays
int i;
for(i=0;i&lt;5;i++) {

    P10_Left[i] = key[i];
    P10_Right[i] = key[i+5];
}
P10_Left[5] = '\0';
P10_Right[5] = '\0';

P10leftPtr = P10_Left;
P10rightPtr = P10_Right;

//The left half shift
LS(P10leftPtr, 1);
//The right half shift
LS(P10rightPtr, 1);


//P8 swap starts here
K1 = P8_swap(P10leftPtr, P10rightPtr);

printf(""K1 key: %s\n"", K1);
//P8 swap ends here


//After we find K1 we need to shift the 2 halves again, 2 times to the left this time
//The left half shift
LS(P10leftPtr, 2);
//The right half shift
LS(P10rightPtr, 2);


//After the 2 shifts we use P8 operation again on the new halves
//P8 swap starts here
K2 = P8_swap(P10leftPtr, P10rightPtr);

printf(""K2 key: %s\n"", K2);
//P8 swap ends here
</code></pre>

<p>}
//</p>

<pre><code>char* P8_swap(char *left_key, char *right_key) {

int P8[8] = {6, 3, 7, 4, 8, 5, 10, 9}; //key possitions after P8 operation
char P8_Output[9];
char *K1; //They key after the P8 swap
char keyLR[11]; //The left and right halves will be stored together here

int i;

//The two halves become one so that we can do the P8 swap
for(i=0;i&lt;5;i++) {
    keyLR[i] = left_key[i];
    keyLR[i+5] = right_key[i];
}

//P8 swap
for(i=0; i&lt;8; i++) {
    P8_Output[i] = keyLR[P8[i]-1];  //P10[i] - 1 because the possitiongs in P10 are from 1-10 and not 0-9
}

P8_Output[8] = '\0';

K1 = P8_Output;

return K1;
</code></pre>

<p>}</p>

<p>After the function keyGenerator when i print the K1Ptr and K2Ptr i get nothing but i was expecting to get the values that are stored inside the function.</p>
","<p>Definition of function parameters <code>K1</code> and <code>K2</code>:</p>

<p><code>void keyGenerator(char *key, char *K1, char *K2)</code></p>

<p>shadows global variables:</p>

<p><code>char K1[9], K2[9];</code></p>

<p>And since function parameters are local to the scope of the function they are in fact assigned, but the value is not propagated to the variables defined elsewhere.</p>

<p>Try to use:</p>

<p><code>void keyGenerator(char *key, char **K1, char **K2)</code></p>

<p>and call it:</p>

<p><code>keyGenerator(key, &amp; K1ptr, &amp; K2ptr);</code></p>

<p>Also there is a need to change assignmend to K1 inside the function depending on P8_swap function.</p>
","108","<c><des>","2","0","3","2019-04-25 10:24:31","55845585","3","","11409331","","2019-04-25 08:56:44","2019-04-25 08:30:35","2019-04-25 09:10:03"
"55844991","After function call, argument pointers don't keep their value","<p>I am passing 3 pointers (key, K1Ptr, K2Ptr) as arguments to a function (keyGenerator) but when the function call ends, only the key pointer keeps the value from the function call and the other 2 pointers don't.</p>

<p>I have tried a lot of different things, like returning an array with the 2 pointers, or i tried not using pointers and pass 2 arrays instead. Both tries had the same result none kept value after the function call.</p>

<pre><code>char K1[9], K2[9];
char *K1ptr, *K2ptr;

K1ptr = K1;
K2ptr = K2;

keyGenerator(key, K1ptr, K2ptr);

printf(""Key. %s\n"", key);
printf(""K1. %s\n"", K1Ptr);
printf(""K2. %s\n"", K2Ptr);
</code></pre>

<p>\</p>

<pre><code>void keyGenerator(char *key, char *K1, char *K2) {

char P10_Left[6];
char P10_Right[6];
char *P10leftPtr, *P10rightPtr;


printf(""Starting key: %s\n"", key);

//P10 Operation first step
P10_swap(key);
printf(""P10swap key: %s\n"", key);

//Initializing the left and right arrays
int i;
for(i=0;i&lt;5;i++) {

    P10_Left[i] = key[i];
    P10_Right[i] = key[i+5];
}
P10_Left[5] = '\0';
P10_Right[5] = '\0';

P10leftPtr = P10_Left;
P10rightPtr = P10_Right;

//The left half shift
LS(P10leftPtr, 1);
//The right half shift
LS(P10rightPtr, 1);


//P8 swap starts here
K1 = P8_swap(P10leftPtr, P10rightPtr);

printf(""K1 key: %s\n"", K1);
//P8 swap ends here


//After we find K1 we need to shift the 2 halves again, 2 times to the left this time
//The left half shift
LS(P10leftPtr, 2);
//The right half shift
LS(P10rightPtr, 2);


//After the 2 shifts we use P8 operation again on the new halves
//P8 swap starts here
K2 = P8_swap(P10leftPtr, P10rightPtr);

printf(""K2 key: %s\n"", K2);
//P8 swap ends here
</code></pre>

<p>}
//</p>

<pre><code>char* P8_swap(char *left_key, char *right_key) {

int P8[8] = {6, 3, 7, 4, 8, 5, 10, 9}; //key possitions after P8 operation
char P8_Output[9];
char *K1; //They key after the P8 swap
char keyLR[11]; //The left and right halves will be stored together here

int i;

//The two halves become one so that we can do the P8 swap
for(i=0;i&lt;5;i++) {
    keyLR[i] = left_key[i];
    keyLR[i+5] = right_key[i];
}

//P8 swap
for(i=0; i&lt;8; i++) {
    P8_Output[i] = keyLR[P8[i]-1];  //P10[i] - 1 because the possitiongs in P10 are from 1-10 and not 0-9
}

P8_Output[8] = '\0';

K1 = P8_Output;

return K1;
</code></pre>

<p>}</p>

<p>After the function keyGenerator when i print the K1Ptr and K2Ptr i get nothing but i was expecting to get the values that are stored inside the function.</p>
","<p>The problem is here</p>

<pre><code>K1 = P8_swap(P10leftPtr, P10rightPtr);
</code></pre>

<p>and here</p>

<pre><code>K2 = P8_swap(P10leftPtr, P10rightPtr);
</code></pre>

<p>You are basically overwriting the value of the pointers, so that they point to something else that is eventually destroyed at the end of the function call.</p>

<p>So, instead, you need to copy the return value of <code>P8_swap()</code> call into the pointers' content, like so:</p>

<pre><code>char* tmp = P8_swap(P10leftPtr, P10rightPtr);
memcpy(K1, tmp, strlen(tmp)+1);

...

tmp = P8_swap(P10leftPtr, P10rightPtr);
memcpy(K2, tmp, strlen(tmp)+1);
</code></pre>

<p>You can read more about <code>memcpy</code> <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_memcpy.htm"" rel=""nofollow noreferrer"">here</a>.</p>

<p>or a basic for loop would also do it</p>

<pre><code>char* tmp = P8_swap(P10leftPtr, P10rightPtr);
for(int i = 0; i &lt; strlen(tmp); i++) {
  K1[i] = tmp[i];
}
</code></pre>

<hr>

<p>Edit:</p>

<p>As @4386427 just pointed out, the <code>tmp</code> would be in this case an unsafe pointer to use, since the return value <code>P8_swap()</code> might get destroyed in the meantime - because it's defined locally within the function.</p>

<p>However, if the memory was allocated dynamically for the value (within the function) - as I initially assumed, then the pointer would be safe to use. <a href=""https://www.onlinegdb.com/B151wW1oE"" rel=""nofollow noreferrer"">See demo</a>.</p>
","108","<c><des>","2","0","3","2019-04-25 10:24:31","55845585","3","","11409331","","2019-04-25 08:56:44","2019-04-25 08:30:35","2019-04-25 09:10:03"
"44464766","Why is only one half of my encrypted string not decrypting properly?","<p>Can't seem to figure this one out... I am using DESCryptoServiceProvider to do a quick little two way encryption (not security related, and security is not the purpose of this question).</p>

<p>Anyways it's weird because the string that goes in and then comes back out is only decrypting properly for one half of the string. I can't seem to notice the bug so maybe someone will have some fun with this...</p>

<p><a href=""https://i.stack.imgur.com/Tdkf8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Tdkf8.png"" alt=""enter image description here""></a></p>

<p>I am combining the two strings with a colon as the separator so 'abc12345:xyz56789' is the input. Then notice in the output only the first part of the string is getting screwed up, not the second part. I would expect that if I was doing it totally wrong then the whole thing wouldn't decrypt properly.</p>

<p>Here is all the code:</p>

<pre><code>class Program
{
    static void Main(string[] args)
    {
        var userId = ""abc12345"";
        var appId = ""xyz56789"";

        Console.WriteLine($""UserId: {userId}, AppId: {appId}"");

        var code = QuickEncode(userId, appId);

        Console.WriteLine(code);

        var result = QuickDecode(code);

        var uId = result.Item1;
        var aId = result.Item2;

        Console.WriteLine($""UserId: {uId}, AppId: {aId}"");

        Console.ReadKey();
    }

    private static string QuickEncode(string userId, string appId)
    {
        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        var desKey = StringToByteArray(""437459133faf42cb"");

        des.Key = desKey;

        ICryptoTransform encryptor = des.CreateEncryptor();

        var encryptMe = $""{userId}:{appId}"";

        Console.WriteLine($""Input String: {encryptMe}"");

        byte[] stringBytes = System.Text.Encoding.UTF8.GetBytes(encryptMe);

        byte[] enc = encryptor.TransformFinalBlock(stringBytes, 0, stringBytes.Length);

        var encryptedBytesString = Convert.ToBase64String(enc);

        return encryptedBytesString;
    }

    private static Tuple&lt;string, string&gt; QuickDecode(string code)
    {
        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        var desKey = StringToByteArray(""437459133faf42cb"");

        des.Key = desKey;

        ICryptoTransform decryptor = des.CreateDecryptor();

        var codeBytes = Convert.FromBase64String(code);

        byte[] originalAgain = decryptor.TransformFinalBlock(codeBytes, 0, codeBytes.Length);

        var decryptMe = System.Text.Encoding.UTF8.GetString(originalAgain);

        Console.WriteLine($""Output String: {decryptMe}"");

        var ids = decryptMe.Split(':');

        return new Tuple&lt;string, string&gt;(ids[0], ids[1]);
    }

    public static string ByteArrayToString(byte[] ba)
    {
        StringBuilder hex = new StringBuilder(ba.Length * 2);
        foreach (byte b in ba)
            hex.AppendFormat(""{0:x2}"", b);
        return hex.ToString();
    }

    public static byte[] StringToByteArray(String hex)
    {
        int NumberChars = hex.Length;
        byte[] bytes = new byte[NumberChars / 2];
        for (int i = 0; i &lt; NumberChars; i += 2)
            bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
        return bytes;
    }
}
</code></pre>
","<p>You must set <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.symmetricalgorithm.iv?view=netframework-4.7"" rel=""nofollow noreferrer"">initialization vector</a> (IV) to the same value for encryption as well as for decryption. Because new IV is automatically generated for each new instance of DESCryptoServiceProvider, your IV differs and decryption is not successfull.</p>

<p>The reason that half of the message is decrypted correctly results from usage of CBC <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.ciphermode?view=netframework-4.7"" rel=""nofollow noreferrer"">mode</a> (which is default mode), which has one really nasty property, that only first block of encrypted message actually depends on value of IV, so potential attacker can decode all message, except first block, without knowing correct IV (of course, correct Key is still needed). So it is not recommended to use this mode. See <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29"" rel=""nofollow noreferrer"">Block cipher mode of operation</a> for more info about this.</p>

<p>So solution is easy - store somewhere IV used for encryption and use the same IV for decryption. If possible, use another cypher mode too. Somthing like this:</p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        var userId = ""abc12345"";
        var appId = ""xyz56789"";

        Console.WriteLine($""UserId: {userId}, AppId: {appId}"");

        byte[] IV;
        var code = QuickEncode(userId, appId, out IV);

        Console.WriteLine(code);

        var result = QuickDecode(code, IV);

        var uId = result.Item1;
        var aId = result.Item2;

        Console.WriteLine($""UserId: {uId}, AppId: {aId}"");

        Console.ReadKey();
    }

    private static string QuickEncode(string userId, string appId, out byte[] IV)
    {
        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        var desKey = StringToByteArray(""437459133faf42cb"");

        des.Key = desKey;
        des.GenerateIV();
        IV = des.IV;

        ICryptoTransform encryptor = des.CreateEncryptor();

        var encryptMe = $""{userId}:{appId}"";

        Console.WriteLine($""Input String: {encryptMe}"");

        byte[] stringBytes = System.Text.Encoding.UTF8.GetBytes(encryptMe);

        byte[] enc = encryptor.TransformFinalBlock(stringBytes, 0, stringBytes.Length);

        var encryptedBytesString = Convert.ToBase64String(enc);

        return encryptedBytesString;
    }

    private static Tuple&lt;string, string&gt; QuickDecode(string code, byte[] IV)
    {
        DESCryptoServiceProvider des = new DESCryptoServiceProvider();

        var desKey = StringToByteArray(""437459133faf42cb"");

        des.Key = desKey;
        des.IV = IV;

        ICryptoTransform decryptor = des.CreateDecryptor();

        var codeBytes = Convert.FromBase64String(code);

        byte[] originalAgain = decryptor.TransformFinalBlock(codeBytes, 0, codeBytes.Length);

        var decryptMe = System.Text.Encoding.UTF8.GetString(originalAgain);

        Console.WriteLine($""Output String: {decryptMe}"");

        var ids = decryptMe.Split(':');

        return new Tuple&lt;string, string&gt;(ids[0], ids[1]);
    }

    public static string ByteArrayToString(byte[] ba)
    {
        StringBuilder hex = new StringBuilder(ba.Length * 2);
        foreach (byte b in ba)
            hex.AppendFormat(""{0:x2}"", b);
        return hex.ToString();
    }

    public static byte[] StringToByteArray(String hex)
    {
        int NumberChars = hex.Length;
        byte[] bytes = new byte[NumberChars / 2];
        for (int i = 0; i &lt; NumberChars; i += 2)
            bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
        return bytes;
    }
}
</code></pre>
","102","<c#><des>","-1","3","1","2017-06-09 19:46:36","44465665","8","","","","","2017-06-09 18:44:03",""
"20625361","index out of range in DES python","<p>I am really sorry for the long program I am complaining about it here, I am just trying to make up my own DES  encryption code using python with the little knowledge I have. So I have written the following code: It returned an error saying :"" m = (B[j][0] &lt;&lt; 1) + B[j][5]
IndexError: bitarray index out of range"". How can I solve that?</p>

<pre><code>from bitarray import bitarray
    iptable=[57, 49, 41, 33, 25, 17, 9,  1,
            59, 51, 43, 35, 27, 19, 11, 3,
            61, 53, 45, 37, 29, 21, 13, 5,
            63, 55, 47, 39, 31, 23, 15, 7,
            56, 48, 40, 32, 24, 16, 8,  0,
            58, 50, 42, 34, 26, 18, 10, 2,
            60, 52, 44, 36, 28, 20, 12, 4,
            62, 54, 46, 38, 30, 22, 14, 6
        ]
    pc1=[56, 48, 40, 32, 24, 16,  8,
              0, 57, 49, 41, 33, 25, 17,
              9,  1, 58, 50, 42, 34, 26,
             18, 10,  2, 59, 51, 43, 35,
             62, 54, 46, 38, 30, 22, 14,
              6, 61, 53, 45, 37, 29, 21,
             13,  5, 60, 52, 44, 36, 28,
             20, 12,  4, 27, 19, 11,  3
        ]
    expTable=[31,  0,  1,  2,  3,  4,
             3,  4,  5,  6,  7,  8,
             7,  8,  9, 10, 11, 12,
            11, 12, 13, 14, 15, 16,
            15, 16, 17, 18, 19, 20,
            19, 20, 21, 22, 23, 24,
            23, 24, 25, 26, 27, 28,
            27, 28, 29, 30, 31,  0]
    pc2 = [13, 16, 10, 23,  0,  4,
             2, 27, 14,  5, 20,  9,
            22, 18, 11,  3, 25,  7,
            15,  6, 26, 19, 12,  1,
            40, 51, 30, 36, 46, 54,
            29, 39, 50, 44, 32, 47,
            43, 48, 38, 55, 33, 52,
            45, 41, 49, 35, 28, 31] 
    # The (in)famous S-boxes
    __sbox = [
            # S1
            [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
             0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
             4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
             15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],

            # S2
            [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
             3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
             0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
             13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],

            # S3
            [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
             13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
             13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
             1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],

            # S4
            [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
             13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
             10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
             3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],

            # S5
            [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
             14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
             4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
             11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],

            # S6
            [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
             10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
             9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
             4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],

            # S7
            [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
             13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
             1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
             6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],

            # S8
            [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
             1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
             7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
             2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
        ]
    msg= bitarray(endian='little')
    msg.frombytes(b'ABCDEFGH')
    perm = bitarray(endian='little')
    key= bitarray(endian='little')
    key.frombytes(b'FFQQSSMM')
    keyPc1 = bitarray(endian='little')
    keyPc2 = bitarray(endian='little')
    exp = bitarray(endian='little')
    for z in pc1:
        keyPc1.append(key[z])
    c0 = keyPc1[0:28]
    d0 = keyPc1[28:]
    key0 = c0 + d0
    #permutation of key
    for k in pc2:
        keyPc2.append(key0[k])
    #permutation of message
    for x in iptable:
        perm.append(msg[x])
    l1 = perm[0:32]
    r1 = perm[32:]
    #Expansion of R
    for y in expTable:
        exp.append(r1[y])
    #XORing R &amp; key
    xor_rk = keyPc2 ^ exp
    #Working with S-boxes!
    B = [xor_rk[0:6], xor_rk[6:14], xor_rk[14:20], xor_rk[20:26], xor_rk[26:32], xor_rk[32:38], xor_rk[38:42], xor_rk[42:47]]
    j = 0
    Bn = [0] * 32
    pos = 0
    while j &lt; 8:
        # Work out the offsets
        m = (B[j][0] &lt;&lt; 1) + B[j][5]
        n = (B[j][1] &lt;&lt; 3) + (B[j][2] &lt;&lt; 2) + (B[j][3] &lt;&lt; 1) + B[j][4]
        # Find the permutation value
        v = __sbox[j][(m &lt;&lt; 4) + n]
        # Turn value into bits, add it to result: Bn
        Bn[pos] = (v &amp; 8) &gt;&gt; 3
        Bn[pos + 1] = (v &amp; 4) &gt;&gt; 2
        Bn[pos + 2] = (v &amp; 2) &gt;&gt; 1
        Bn[pos + 3] = v &amp; 1
        pos += 4
        j += 1
    f = Bn[0] + Bn[1] + Bn[2] + Bn[3] + Bn[4] +Bn[5] + Bn[6] +Bn[7]
    xor_lf = l ^ f
</code></pre>
","<p>Not all parts of your <code>B</code> list are the same length. For example, this part:</p>

<pre><code>xor_rk[38:42]
</code></pre>

<p>has a length of 4, so you can't get the 5th element of that. Is it supposed to have a length of 4? Or did you mean to count by sixes and screw up?</p>
","102","<python><des>","0","1","1","2013-12-17 03:33:28","","1","","","","","2013-12-17 03:26:24",""
"24515223","Get 192bits cipher from 64bit blocksize in des","<p>I was wondering, is it possible to extend the cipher byte length when block size  64bits (8byte) in DES?</p>

<p>Its like this, When the input <code>Blocksize</code> is <code>&lt;=64bits</code> the cypher size is <code>128bits</code> for sure because of the <code>PaddingMode.PKCS7</code> in DES. The below code is an example of what I'm saying. </p>

<pre><code>   static void Main(string[] args)
    {
            Console.WriteLine(""Original String: "");
            string originalString = Console.ReadLine();
            string cryptedString = Encrypt(originalString);
            Console.WriteLine(""Encrypt Result: "" +cryptedString);
    }

    public static string Encrypt(string originalString)
    {

        const string AesIV = ""!QAZ2WSX"";
        const string AesKey = ""5TGB&amp;YHN"";
        byte[] input_text = Encoding.UTF8.GetBytes(originalString);


        DESCryptoServiceProvider des = new DESCryptoServiceProvider();
        des.BlockSize = 64;
        des.IV = Encoding.UTF8.GetBytes(AesIV);
        des.Key = Encoding.UTF8.GetBytes(AesKey);
        des.Mode = CipherMode.CBC;
        des.Padding = PaddingMode.PKCS7;


        ICryptoTransform des_demo = des.CreateEncryptor();
        byte[] encrypted = des_demo.TransformFinalBlock(input_text , 0, input_text.Length );
        string encrypt = Convert.ToBase64String(encrypted );
        return encrypt;
    }
</code></pre>

<p>But I want to have cyphersize more than <code>128bits</code> (specially <code>192bits</code>) from same input <code>Blocksize</code> which is <code>&lt;=64bits</code> from this code. How I can I do that? Is there any way to fix up the output cipher size to 24bytes? </p>
","<p>This problem can be solved very easily. Just change the <code>UTF8</code> to Unicode. Now, each input data characters will be <code>2byte</code> each instead of <code>1byte</code>. So, <code>8byte</code> (64bits) input will be <code>16byte</code> (128bits) and when <code>PKCS#7</code> is used in <code>16byte</code> data it becomes <code>24byte</code> (192bits). This is the way to get <code>192bit</code> cipher from <code>64bit</code> input. </p>
","99","<c#><encryption><des>","-1","-2","1","2014-07-14 04:32:11","24728679","3","","232671","","2014-07-14 04:32:11","2014-07-01 16:30:58",""
"22085170","DES performance in jastypt","<p>Currently we're using PBEWithMD5AndDES as a 2-way encryption algorithm for usernames, email addresses birthdates? It doesn't seem particularly performant (1 minute to read and write 30k DB rows in large batches, with 1 string encrypted string per row).</p>

<p>Does this seem reasonable? Or is there anything better.</p>

<p>Also, its not clear to me whether the default PBEWithMD5AndDES algorithm in jastypt performs multiple iterations or just one.</p>
","<p>Encryption operations are always quite slow. Anyway, if you are using a fixed salt generator, jasypt 1.9.2 includes an optimization that saves some initialization calls and might improve your performance: <a href=""http://jasypt.org/changelogs/jasypt/ChangeLog.txt"" rel=""nofollow"">http://jasypt.org/changelogs/jasypt/ChangeLog.txt</a></p>

<p>As for iterations, note that iteration in PBE encryption (two-way) is only performed in order to obtain the encryption key (it is obtained by applying a hash function on the password, which is not a byte[] encryption key but an unlimited-strength String). The amount of iterations performed on the hash function that obtains the key can be configured in most encryptor objects by means of a <code>keyObtentionIterations</code> property (and if not, javadoc will explain the value chosen).</p>

<p>Disclaimer, per stackoverflow rules: I'm jasypt's author.</p>
","99","<java><security><encryption><des><jasypt>","1","2","1","2014-03-01 10:21:57","22113070","0","","","","","2014-02-28 02:43:49",""
"15577906","J2ME App Selectively Working on Some Phones","<p>I'm currently working on a j2me app. The app encrypts(using DES) and sends username and password to a server which then decrypts and authenticates the supplied credentials. Tested it on a Nokia E63 and it worked well, but failed to work on some other phones that I tested it on like Bold 5 and LG C199. I tried debugging and found out that the program fails at the point where it instantiates the class responsible for the encryption.
Does anyone know how I can work around this? Also is there anyway I can write a DES encryption without using the javax.crypto.Cipher class?</p>
","<p>some of those phone's jvm might won't have that class, try adding that class explicitly in your application </p>
","97","<java><encryption><java-me><des>","0","0","2","2013-03-23 19:53:43","","2","","","","","2013-03-22 18:57:25",""
"15577906","J2ME App Selectively Working on Some Phones","<p>I'm currently working on a j2me app. The app encrypts(using DES) and sends username and password to a server which then decrypts and authenticates the supplied credentials. Tested it on a Nokia E63 and it worked well, but failed to work on some other phones that I tested it on like Bold 5 and LG C199. I tried debugging and found out that the program fails at the point where it instantiates the class responsible for the encryption.
Does anyone know how I can work around this? Also is there anyway I can write a DES encryption without using the javax.crypto.Cipher class?</p>
","<p>The <a href=""http://www.bouncycastle.org/latest_releases.html"" rel=""nofollow"">bouncycastle</a> lightweight crypto API comes in a <a href=""http://www.bouncycastle.org/download/lcrypto-j2me-148.zip"" rel=""nofollow"">j2me version</a>. Be sure to read the FAQ about running an obfuscator on your j2me thingy (I don't know squat about j2me so you'll have to fill in the blanks).</p>
","97","<java><encryption><java-me><des>","0","0","2","2013-03-23 19:53:43","","2","","","","","2013-03-22 18:57:25",""
"14720554","Permuting on a schedule python","<p>I'm trying to implement simplified DES for learning purposes in python, but I am having trouble figuring out how to do the permutations based on a ""schedule."" Essentially, I have a tuple with the appropriate permutations, and I need to bit shift to the correct location.</p>

<p>For example, using a key:</p>

<p>K = 00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001</p>

<p>Would move the 57st bit to the first bit spot, 49th bit to the second bit spot, etc...</p>

<p>K+ = 1111000 0110011 0010101 0101111 0101010 1011001 1001111 0001111</p>

<p>Current code:</p>

<pre><code>def keyGen(key):
    PC1table = (57, 49, 41, 33, 25, 17,  9,
                 1, 58, 50, 42, 34, 26, 18,
                10,  2, 59, 51, 43, 35, 27,
                19, 11,  3, 60, 52, 44, 36,
                63, 55, 47, 39, 31, 23, 15,
                 7, 62, 54, 46, 38, 30, 22,
                14,  6, 61, 53, 45, 37, 29,
                21, 13,  5, 28, 20, 12,  4)

    keyBinary = bin(int(key, 16))[2:].zfill(64)
    print keyBinary
    permute(PC1table, keyBinary)

def permute(permutation, permuteInput):
    elements = list(enumerate(permutation))
    for bit in permuteInput:
         ***magic bitshifting goes here***


keyGen(""133457799BBCDFF1"")
</code></pre>

<p>The logic I thought would work was to enumerate the tuple of permutations, and for each bit of my old key, look in the enumeration to find the index corresponding the the bit, and bit shift the appropriate number of times, but I just can't figure out how to go about doing this. It may be that I am approaching the problem from the wrong angle, but any guidance would be greatly appreciated!</p>
","<p>Ok, I ended up figuring a way to make this work, although this probably isn't the most efficient way...</p>

<p>prior to calling the function, turn the binary number into a list:</p>

<pre><code>keyBinary = bin(int(key, 16))[2:].zfill(64)
keyBinary = [int(i) for i in keyBinary]

Kplus = permute(PC1table, keyBinary)

def permute(mapping, permuteInput):
    permuteOutput = []

    for i in range(len(mapping)):
        permuteOutput.append(permuteInput[mapping[i % 56] - 1])

    return permuteOutput
</code></pre>

<p>if anyone has a better way of tackling this, I'd love to see your solutions!</p>
","96","<python-2.7><permutation><des>","0","0","1","2013-02-13 00:34:48","14844518","2","","","","","2013-02-06 02:21:28",""
"36765831","can we used same key in AES or DES","<p>As i am using client server communication, where i used same key (shared key) between client and server. but problem arise key is change every execution so i want to fixed it. is their any solution to take fixed key using AES/DES on both side.</p>

<pre><code>private static void setUp() throws Exception {
    key = KeyGenerator.getInstance(algorithm).generateKey();
    System.out.println(key);
    cipher = Cipher.getInstance(algorithm);
    System.out.println(cipher);
}
</code></pre>
","<p>You can use a <code>javax.crypto.spec.SecretKeySpec</code> as a <code>Key</code>. This allows you to give the key as a byte array.</p>
","96","<java><security><aes><des>","1","0","1","2016-04-21 15:15:47","","1","","3503018","","2016-04-21 15:15:47","2016-04-21 09:47:50",""
"26962744","DES encryption in Rubymotion","<p>How can I encrypt/decrypt a string with DES algorithm on iOS using Rubymotion?</p>

<p>There are very few examples even on Obj-C, and they are hardly translatable to Rubymotion.</p>
","<p>I had to install CommonCrypto pod.</p>

<p>After I used this code to encrypt with DES:</p>

<pre><code>string = ""string to encrypt""
data = params.dataUsingEncoding(NSUTF8StringEncoding)

errorPtr = nil # You can use a real error object here if you need
encrypted_data      = data.DESEncryptedDataUsingKey(User.first.key, error: errorPtr) 
</code></pre>

<p>Also you can check other aviable encryption and decryption methods in  <code>/vendors/Pods/CommonCrypto/NSData+CommonCrypto.m</code> file.</p>
","95","<ios><objective-c><encryption><rubymotion><des>","0","0","1","2014-11-17 19:34:54","26980491","4","","1849664","","2014-11-17 19:34:54","2014-11-16 22:22:23",""
"41006091","DES Encryption keys","<p>I was reading about DES Triple Encryption,and I found a lot of diffrent combinations of the 3 keys , for example there's : using k1 - k2 - k3 , as there's k1- k2 - k1 , ... 
My Question is , what is the diffrence between these combinations? and which one is advisable (most used) ? </p>
","<p><a href=""https://stackoverflow.com/questions/39446834/how-many-keys-does-triple-des-encryption-need?rq=1"">How many keys does Triple DES encryption need?</a> should provide depth to the following answer:</p>

<p>Using three distinct keys is the best way to go.  In fact, it's the only option for the US Government (and US Government contractors):</p>

<blockquote>
  <p>3.2.1.2 Triple Data Encryption Algorithm (TDEA)</p>
  
  <p>The Triple Data Encryption Algorithm (TDEA), also known as Triple DES, uses the DES
  cryptographic engine to transform data in three operations. TDEA is
  specified in SP 800-67.   </p>
  
  <p>TDEA encrypts data in blocks of 64 bits, using three keys that define
  a key bundle. The use of  TDEA  using  three  distinctly  different 
  (i.e.,  mathematically  independent)  keys  is approved and  is 
  commonly  known  as  three-key  TDEA  (also  referred  to  as  3TDEA 
  or  3TDES). </p>
  
  <p><strong>Other  variations  of  TDEA,  where  two  or  three  of  the  keys 
  are  identical,  are no  longer  approved</strong> for applying cryptographic
  protection  because of increased computing power or weaknesses in the
  algorithm.</p>
</blockquote>

<p>(Emphasis mine).  Source: <a href=""http://csrc.nist.gov/publications/drafts/800-175/sp800-175b_draft.pdf"" rel=""nofollow noreferrer"">http://csrc.nist.gov/publications/drafts/800-175/sp800-175b_draft.pdf</a></p>
","94","<security><encryption><des><symmetric-key>","0","0","1","2016-12-11 14:06:49","41006585","1","","1816580","","2016-12-11 14:06:49","2016-12-06 22:25:46",""
"1697607","Naming confusion? Is having objects named FlowerGroup and FlowerGroups confusing?","<p>I'm writing a program and I seem to be creating alot of objects where one object will be the singular form and then the collection is the plural form. eg</p>

<p>SalesGroup
SalesGroups</p>

<p>Is this confusing for other programmers to read my code?</p>
","<p>should not be confusing, in fact I find it pretty informative and clear; unless you have multiple kinds of collections (lame example: suppose you have an array but also a map of SalesGroup, then SalesGroups would not be the best choice but you'd rather pick SalesGroupArray, SalesGroupMap etc.)</p>
","93","<c++><des>","2","2","4","2015-07-18 16:47:24","1697615","0","","","","","2009-11-08 19:23:05",""
"1697607","Naming confusion? Is having objects named FlowerGroup and FlowerGroups confusing?","<p>I'm writing a program and I seem to be creating alot of objects where one object will be the singular form and then the collection is the plural form. eg</p>

<p>SalesGroup
SalesGroups</p>

<p>Is this confusing for other programmers to read my code?</p>
","<p>I think that makes perfect sense. Not specifying the type of collection means you're at liberty to change the implementation later, and clients can't rely on a particular implementation.</p>
","93","<c++><des>","2","2","4","2015-07-18 16:47:24","1697615","0","","","","","2009-11-08 19:23:05",""
"1697607","Naming confusion? Is having objects named FlowerGroup and FlowerGroups confusing?","<p>I'm writing a program and I seem to be creating alot of objects where one object will be the singular form and then the collection is the plural form. eg</p>

<p>SalesGroup
SalesGroups</p>

<p>Is this confusing for other programmers to read my code?</p>
","<p>seems OK to me. just maintain your coding style throughout all your project. </p>
","93","<c++><des>","2","0","4","2015-07-18 16:47:24","1697615","0","","","","","2009-11-08 19:23:05",""
"1697607","Naming confusion? Is having objects named FlowerGroup and FlowerGroups confusing?","<p>I'm writing a program and I seem to be creating alot of objects where one object will be the singular form and then the collection is the plural form. eg</p>

<p>SalesGroup
SalesGroups</p>

<p>Is this confusing for other programmers to read my code?</p>
","<p>While it's not confusing, I think it is very easy to miss.  If I were doing this, I would use something that stands out more, perhaps <code>SalesGroup</code> and <code>SalesGroupCollection</code>.</p>
","93","<c++><des>","2","0","4","2015-07-18 16:47:24","1697615","0","","","","","2009-11-08 19:23:05",""
"22657135","C# DES encryption output not always matching expected","<p>I'm doing some work querying an API using that has been provided by another (large, multinational) company. One of the parameters needs to be encrypted using DES (I know, it's not considered secure, but a. the API has already been developed and b. the data encrypted is fairly easily available to the public anyway). I've got to the point where 2 of the 5 queries I've been asked to run are working, but the other 3 are not.</p>

<p>This is where things start to confuse me. The 2 that work fine are obviously encrypting the number correctly. However, the company in question has advised that the encrypted outputs do not match theirs for the 3 that are failing. I don't really understand how this can be, but they've shown me that, for example, one expected encrypted output should have been ""9B2653BF0C348D8BA8643266BEBF329FDD643D2E4F432062"" but my output was ""9B2653BF0C348D8B710BCAF2B3DBFCBFDD643D2E4F432062"" - it seems that 16 characters in the middle in each instance are not matching their output.</p>

<p>My code to encrypt the data is this:</p>

<pre><code>public string GetEncryptedValue(string baseValue)
{
    using (var desProvider = new DESCryptoServiceProvider
          {
            Mode = CipherMode.ECB,
            Padding = PaddingMode.PKCS7,
            Key = Encoding.UTF8.GetBytes(Key)
          })
    using (var memoryStream = new MemoryStream())
    using (var cryptoStream = new CryptoStream(memoryStream, 
            desProvider.CreateEncryptor(), CryptoStreamMode.Write))
    {
       var data = Encoding.UTF8.GetBytes(baseValue);
       cryptoStream.Write(data, 0, data.Length);
       cryptoStream.FlushFinalBlock();

       return ByteArrayToString(memoryStream.ToArray());
    }
}

private static string ByteArrayToString(ICollection&lt;byte&gt; byteArray)
{
    var hex = new StringBuilder(byteArray.Count * 2);
    foreach (var singleByte in byteArray)
    hex.AppendFormat(""{0:x2}"", singleByte);
    return hex.ToString().ToUpper();
}
</code></pre>

<p>Can anyone make suggestions as to what the cause might be? I've tried different encoding types. I know the padding mode is PKCS#5, but as per <a href=""https://stackoverflow.com/questions/8614997/pkcs5padding-in-c-sharp"">this SO answer</a> the algorithms are the same. The company in question are large and it often takes several days for questions to go between several countries to get an answer which is often irrelevant.</p>

<p>Thanks.</p>
","<p>It turns out the problem was at the other company's end, and backs up exactly Oleg Estekhin's comment: ""The encrypted output is 3*8=24 bytes, meaning that the initial value is 16-23 bytes long. The DES has block-size of 8 bytes, meaning that 8 input bytes correspond to 8 output bytes, and ECB mode means that 8-byte blocks are independent. This and the fact that the outputs differ by only the second 8-byte block leads to conclusion that inputs differ by at least one byte in positions 8-16.""</p>

<p>The values added to their system (which were VIN numbers) were added with the letter O in them where the number 0 should have been used; interestingly, the letter ""O"" is an illegal character in VINs, which one would assume a company that manufactures cars would know!</p>
","93","<c#><encryption><des>","0","0","1","2014-04-07 09:36:13","22908640","3","","-1","","2017-05-23 12:05:21","2014-03-26 09:50:35",""
"55969395","Encrypt plaintext with DES algorithm","<p>I'm trying to encrypt a plaintext using DES algorithm in PHP.<br>
I managed to code a working example in C#:</p>

<pre><code>String plaintext = ""1y7wpc4iddseyrwez1lor8ow3297t.pd0bfl"";
String pass = ""rpsxi.t.rjsmklexarygfqyrrkhwdjh"";
byte[] bytesPlain = Encoding.UTF8.GetBytes(plaintext);
byte[] bytesPass = Encoding.UTF8.GetBytes(pass).Take(8).ToArray();
DESCryptoServiceProvider p = new DESCryptoServiceProvider();
p.Mode = CipherMode.ECB;
ICryptoTransform t = p.CreateEncryptor(bytesPass, bytesPass);
CryptoStreamMode m = CryptoStreamMode.Write;
MemoryStream stream = new MemoryStream();
CryptoStream cryptoStream = new CryptoStream(stream, t, m);
cryptoStream.Write(bytesPlain, 0, bytesPlain.Length);
cryptoStream.FlushFinalBlock();
byte[] encBytesPlain = new byte[stream.Length];
stream.Position = 0;
stream.Read(encBytesPlain, 0, encBytesPlain.Length);
string encrypted = Convert.ToBase64String(encBytesPlain);
System.Diagnostics.Debug.WriteLine(encrypted);
</code></pre>

<p><strong>plaintext</strong> = <strong>1y7wpc4iddseyrwez1lor8ow3297t.pd0bfl</strong> <br> <strong>password</strong> = <strong>rpsxi.t.rjsmklexarygfqyrrkhwdjh</strong><br>
(only the first 8 bytes of the password are used to encrypt the message).</p>

<p>Anyway when I try to code a PHP version, using the crypt function or also this class I found on github <a href=""https://github.com/phpseclib/phpseclib-php5/blob/master/phpseclib/Crypt/DES.php"" rel=""nofollow noreferrer"">https://github.com/phpseclib/phpseclib-php5/blob/master/phpseclib/Crypt/DES.php</a>, i don't get the same result as the C# one. <br><br>I'm completely sure that the C# code works fine but I really don't know how to make a working version in PHP to get the same result in Base64.</p>

<p>Edit1: I already knew that DES isn't secure anymore but I need to use it in a web page just for learning purposes, also the way that C# code was written is completely right because I needed to follow some instructions and get that exactly result.</p>
","<p>DES is a deprecated encryption standard and you should not use it for anything else than learning purposes. <a href=""https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a> would probably be the better choice if you're planning on using this to encrypt sensitive data.</p>

<p>Other than that since I haven't coded PHP in a while, but still wanted to contribute, I fixed up your existing C# code a little:</p>

<pre><code>var plainText = ""1y7wpc4iddseyrwez1lor8ow3297t.pd0bfl"";
var password = ""rpsxi.t.rjsmklexarygfqyrrkhwdjh"";
var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
var passwordBytes = Encoding.UTF8.GetBytes(password).Take(8).ToArray();

var des = new DESCryptoServiceProvider
{
    Mode = CipherMode.CBC, // don't use ECB as your CipherMode
    Padding = PaddingMode.PKCS7,
    Key = passwordBytes
};

des.GenerateIV(); // work with a unique IV for each operation

string encrypted = null;
using (var desEncryptor = des.CreateEncryptor())
{
    var resultStream = new MemoryStream();
    using (var cryptoStream = new CryptoStream(resultStream, desEncryptor, CryptoStreamMode.Write))
    {
        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
    }

    encrypted = Convert.ToBase64String(resultStream.ToArray());
}
</code></pre>

<p>This is still not secure and as I said in the beginning, if security is critical for the application you're building you shouldn't use this. This answer is <strong>not</strong> supposed to make your code secure, just to point out some flaws in your usage of C# Streams and general coding guidelines.</p>

<p>For the PHP part <a href=""https://stackoverflow.com/a/20170850/9456781"">this</a> answer could work with the updated code I posted. You just have to extract the IV from the <code>des</code> object via <code>des.IV</code> and use it in your PHP script for the same functionality.</p>

<p>It's also worth noting that the used function <code>mcrypt_encrypt</code> is deprecated in newer versions of PHP, which brings me back to the first sentence of my answer: You should probably stop using DES altogether!</p>
","91","<c#><php><encryption><des>","-2","1","2","2019-05-04 08:48:01","","5","","11447140","","2019-05-03 12:18:48","2019-05-03 12:00:02","2019-05-05 23:20:56"
"55969395","Encrypt plaintext with DES algorithm","<p>I'm trying to encrypt a plaintext using DES algorithm in PHP.<br>
I managed to code a working example in C#:</p>

<pre><code>String plaintext = ""1y7wpc4iddseyrwez1lor8ow3297t.pd0bfl"";
String pass = ""rpsxi.t.rjsmklexarygfqyrrkhwdjh"";
byte[] bytesPlain = Encoding.UTF8.GetBytes(plaintext);
byte[] bytesPass = Encoding.UTF8.GetBytes(pass).Take(8).ToArray();
DESCryptoServiceProvider p = new DESCryptoServiceProvider();
p.Mode = CipherMode.ECB;
ICryptoTransform t = p.CreateEncryptor(bytesPass, bytesPass);
CryptoStreamMode m = CryptoStreamMode.Write;
MemoryStream stream = new MemoryStream();
CryptoStream cryptoStream = new CryptoStream(stream, t, m);
cryptoStream.Write(bytesPlain, 0, bytesPlain.Length);
cryptoStream.FlushFinalBlock();
byte[] encBytesPlain = new byte[stream.Length];
stream.Position = 0;
stream.Read(encBytesPlain, 0, encBytesPlain.Length);
string encrypted = Convert.ToBase64String(encBytesPlain);
System.Diagnostics.Debug.WriteLine(encrypted);
</code></pre>

<p><strong>plaintext</strong> = <strong>1y7wpc4iddseyrwez1lor8ow3297t.pd0bfl</strong> <br> <strong>password</strong> = <strong>rpsxi.t.rjsmklexarygfqyrrkhwdjh</strong><br>
(only the first 8 bytes of the password are used to encrypt the message).</p>

<p>Anyway when I try to code a PHP version, using the crypt function or also this class I found on github <a href=""https://github.com/phpseclib/phpseclib-php5/blob/master/phpseclib/Crypt/DES.php"" rel=""nofollow noreferrer"">https://github.com/phpseclib/phpseclib-php5/blob/master/phpseclib/Crypt/DES.php</a>, i don't get the same result as the C# one. <br><br>I'm completely sure that the C# code works fine but I really don't know how to make a working version in PHP to get the same result in Base64.</p>

<p>Edit1: I already knew that DES isn't secure anymore but I need to use it in a web page just for learning purposes, also the way that C# code was written is completely right because I needed to follow some instructions and get that exactly result.</p>
","<p>Please do not use DES any more, as it is not considered secure anymore. Instead try using AES.</p>

<p>Also note that the php crypt function does not encrypt by default, but only creates a hash value using DES, which is not the same as encrypting.</p>

<p>Source: <a href=""https://www.w3schools.com/php/func_string_crypt.asp"" rel=""nofollow noreferrer"">https://www.w3schools.com/php/func_string_crypt.asp</a></p>
","91","<c#><php><encryption><des>","-2","1","2","2019-05-04 08:48:01","","5","","11447140","","2019-05-03 12:18:48","2019-05-03 12:00:02","2019-05-05 23:20:56"
"49727945","C++ DES algorithm keeps generating incorrect final block","<p>I have an assignment for school where I need to use the standard library to program DES in C++. I have most of the algorithm done, however the final block isn't encrypting properly compared to the openssl des-cbc that we are using to verify. The other blocks all work properly, so I think it has something to do with my padding</p>

<pre><code>void des::get_mes_data(std::string mes_file){
    std::ifstream mes_in(mes_file, std::ios::binary);
    std::string content;
    std::getline(mes_in, content, std::string::traits_type::to_char_type(std::string::traits_type::eof()));

    //error seems to be here since last block is the only block affected
    if(content.size()%8 != 0) content.append(8-(content.size()%8), 0);
    //end error

    for(char c : content){
        if(c == 0) std::cout&lt;&lt;"" NULL ""&lt;&lt;std::endl;
        else if( c == EOF) std::cout&lt;&lt;"" EOF ""&lt;&lt;std::endl;
        else std::cout&lt;&lt;c;
    }
    std::string mes_bin="""";
    for(int i = 0; i &lt; content.size(); i++){
        mes_bin += char_to_bin(content[i]);
        if(mes_bin.size() == 64){
            m_mes_data.push_back(mes_bin);
            mes_bin = """";
        }
    }
}
</code></pre>

<p>I've tried to insert an EOF char at the end of content before padding with 0's and I have also tried inserting '\r\n' before padding with 0 as well as per the guide I was using here <a href=""http://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm"" rel=""nofollow noreferrer"">http://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm</a>  but everything I have tried doesn't seem to fix it.</p>

<p>Am I missing something when it comes to padding, or is there some special character I need to end my content with before adding 0 (nul) to the end?</p>
","<p>Thanks Joker_vD for the solution</p>

<p>The issue arose from not padding properly following the openssl PKCS #5(or <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7"" rel=""nofollow noreferrer"">PKCS #7 on wikipedia</a>). By changing the line</p>

<pre><code>if(content.size()%8 != 0) content.append(8-(content.size()%8), 0);
</code></pre>

<p>to</p>

<pre><code>if(content.size()%8 != 0) content.append(8-(content.size()%8), 8-content.size()%8);
else content.append(8, 8);
</code></pre>

<p>The program started to pad properly.</p>
","91","<c++><openssl><des>","1","0","1","2018-04-09 23:53:49","49743295","4","","","","","2018-04-09 07:49:30",""
"19282302","DES Encryption: File bigger after enryption","<p>I'm trying to write my own DES encryption program without using the .NET libraries.</p>

<p>However, after going through all the steps I noticed my file gets twice as big!
I'm reading from a txt file (byte by byte) into a list of <code>BitArrays</code>, and after a few conversions I end up with a list of <code>byte[]</code> arrays. Finally I write these to another txt file. All the arrays never change in size (always 64 bits or 8 bytes).
Has this got anything to do with encoding? I know it's ANSI, but since I'm not getting the required result back after decrypting, I think it's either the encoding or my logic.</p>

<p>Thanks in advance.</p>
","<p>If you have &lt;= 8 symbols in your txt, than you should receive 8 encoded bytes. If 9 - 16 bytes (with 7 padding bytes). This is the only case when your close to have twice as big encrypted file</p>
","90","<c#><filestream><des><binarystream>","0","0","1","2013-10-09 21:32:14","19283137","0","","","","","2013-10-09 20:44:11",""
"39820867","Hardware implementation of Data Encryption Standard (S-boxes /permutations)","<p>I am trying to implement the DES circuit and according to a lot of papers, the S-boxes usually is implemented using a SRL or LUT, i'm not familiar with SRL, so i thought i use 8 LUT, each one has 6 adress lines and 4 data lines ( the 1st 2 adress lines represent the 1st and last bits of the bloc, and the 4 other adress lines represent the rest which will define the column) </p>

<p><a href=""https://i.stack.imgur.com/hnQzh.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hnQzh.jpg"" alt=""enter image description here""></a></p>

<p>For example if we take S-box 1 (shown in this figure) 
<a href=""https://i.stack.imgur.com/B4Gn2.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B4Gn2.jpg"" alt=""enter image description here""></a></p>

<p>Here is the table that comes with it </p>

<p><a href=""https://i.stack.imgur.com/rYLSo.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rYLSo.jpg"" alt=""enter image description here""></a></p>

<p>That's just for one box, it seems to me wrong, to do all of the boxes we have to write 512 lines. My first question is: is a LUT a hardware component? if so, i am using it correctly? and, is there a more appropriate implementation or representation?
My second question is: what does it mean hardware wiring? I found out that all the permutation function could be implemented using wire crossing, i didn't understand it. Should i make a wire for every bit? </p>
","","88","<hardware><hdl><lookup-tables><des>","0","","0","2018-02-06 00:16:31","","6","","1155120","","2018-02-06 00:16:31","2016-10-02 19:35:38",""
"54089115","Why did the result of DES Encryption executed in Java different from executed in PHP?","<p>I ran the Trible DES Encryption in Java, with <code>null</code> IV (I have run <code>cipher.getIV()</code> method and indeed it's IV is null) and the same string ran the Triple DES Encryption in PHP with <code>null</code> IV, but I get a different result. Why is that?</p>

<p>Java Code:</p>

<pre><code>private static final String model = ""DESede/ECB/PKCS5Padding"";
public static String desEncrypt(String message, String key) throws Exception {
    byte[] keyBytes = null;
    if(key.length() == 16){
        keyBytes = newInstance8Key(ByteUtil.convertHexString(key));
    } else if(key.length() == 32){
        keyBytes = newInstance16Key(ByteUtil.convertHexString(key));
    } else if(key.length() == 48){
        keyBytes = newInstance24Key(ByteUtil.convertHexString(key));
    }

    SecretKey deskey = new SecretKeySpec(keyBytes, ""DESede"");

    Cipher cipher = Cipher.getInstance(model);
    cipher.init(1, deskey);
    return ByteUtil.toHexString(cipher.doFinal(message.getBytes(""UTF-8"")));
}
</code></pre>

<p>PHP Code:</p>

<pre><code>// composer require phpseclib/phpseclib
use phpseclib\Crypt\TripleDES;

function desEncrypt($str,$key){
    $cipher = new TripleDES();
    $cipher-&gt;setKey(hex2bin($key));

    $cryptText = $cipher-&gt;encrypt($str);

   return unpack(""H*"",$cryptText)[1];
}
</code></pre>

<p>I want to modify my PHP code to fit the Java Encryption Process，how should I do? where is the proplem?</p>

<p>Java Encrypt Result:</p>

<pre><code>before: 622700300000
key: 0123456789ABCDEFFEDCBA98765432100123456789ABCDEF
after: c9aa8ebfcc12ce13e22a33b05d4c18cf
</code></pre>

<p>PHP Encrypt Result:</p>

<pre><code>before: 622700300000
key: 0123456789ABCDEFFEDCBA98765432100123456789ABCDEF
after: a6e7a000d4ce79ac8b3db9f6acf73de3
</code></pre>

<p>Fixed PHP Code:</p>

<pre><code>/**
 * Triple DES (ECB) Encryption Function
 * PKCS5Padding
 * 
 * @param string $message String needed to be encode
 * @param string $key Hex encoded key
 * @return string Hex Encoded
 */
function desEncrypt($message,$key){
    $cipher = new TripleDES(TripleDES::MODE_ECB);
    $cipher-&gt;setKey(hex2bin($key));

    $cryptText = $cipher-&gt;encrypt($message);

   return bin2hex($cryptText);
}
</code></pre>
","<p>You forgot to hex decode the key before using it. You're also using CBC mode instead of ECB mode, but as your IV is all zero's, that amounts to the same thing <em>for the first block</em> of data that is encrypted.</p>
","86","<java><php><encryption><des><3des>","3","1","1","2019-01-08 14:14:40","54091507","1","1","5971805","","2019-01-08 14:14:40","2019-01-08 09:48:12",""
"54862788","DES Encryption and decryption algorithm in swift","<p>I am trying to use DES algorithm for Encryption and decryption in swift</p>

<p>But with the code that I have written the encrypted message is changing for every build</p>

<p>Here is my code:</p>

<pre><code>import UIKit
import CommonCrypto

public class IAppEncryptionUtitlity: NSObject {
    private override init(){}
    public static let sharedNetworkVar: IAppEncryptionUtitlity = IAppEncryptionUtitlity()
    let key = IAppConfig.key
     func myEncrypt(encryptData:String) -&gt; NSData?{

        var myKeyData : NSData = (""DyfmgL9p"" as NSString).data(using: String.Encoding.utf8.rawValue)! as NSData
        var myRawData : NSData = encryptData.data(using: String.Encoding.utf8)! as NSData
        var iv : [UInt8] = [56, 101, 63, 23, 96, 182, 209, 205]  // I didn't use
        var buffer_size : size_t = myRawData.length + kCCBlockSize3DES
        var buffer = UnsafeMutablePointer&lt;NSData&gt;.allocate(capacity: buffer_size)
        var num_bytes_encrypted : size_t = 0

        let operation: CCOperation = UInt32(kCCEncrypt)
        let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
        let options:   CCOptions   = UInt32(kCCOptionECBMode + kCCOptionPKCS7Padding)
        let keyLength        = size_t(kCCKeySize3DES)

        var Crypto_status: CCCryptorStatus = CCCrypt(operation, algoritm, options, myKeyData.bytes, keyLength, nil, myRawData.bytes, myRawData.length, buffer, buffer_size, &amp;num_bytes_encrypted)

        if UInt32(Crypto_status) == UInt32(kCCSuccess){

            var myResult: NSData = NSData(bytes: buffer, length: num_bytes_encrypted)

            free(buffer)
            print(""my result \(myResult)"") //This just prints the data

            let keyData: NSData = myResult

            let hexString = keyData.hexEncodedString()
            print(""hex result \(keyData)"") // I needed a hex string output


            //myDecrypt(decryptData: myResult) // sent straight to the decryption function to test the data output is the same
            return myResult
        }else{
            free(buffer)
            return nil
        }
    }
    func myDecrypt(decryptData : NSData) -&gt; NSData?{

        var mydata_len : Int = decryptData.length
        var keyData : NSData = (""myEncryptionKey"" as NSString).data(using: String.Encoding.utf8.rawValue)! as NSData

        var buffer_size : size_t = mydata_len+kCCBlockSizeAES128
        var buffer = UnsafeMutablePointer&lt;NSData&gt;.allocate(capacity: buffer_size)
        var num_bytes_encrypted : size_t = 0

        var iv : [UInt8] = [56, 101, 63, 23, 96, 182, 209, 205]  // I didn't use

        let operation: CCOperation = UInt32(kCCDecrypt)
        let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
        let options:   CCOptions   = UInt32(kCCOptionPKCS7Padding)
        let keyLength        = size_t(kCCKeySize3DES)

        var decrypt_status : CCCryptorStatus = CCCrypt(operation, algoritm, options, keyData.bytes, keyLength, nil, decryptData.bytes, mydata_len, buffer, buffer_size, &amp;num_bytes_encrypted)

        if UInt32(decrypt_status) == UInt32(kCCSuccess){

            var myResult : NSData = NSData(bytes: buffer, length: num_bytes_encrypted)
            free(buffer)
            print(""decrypt \(myResult)"")

            var stringResult = NSString(data: myResult as Data, encoding:String.Encoding.utf8.rawValue)
            print(""my decrypt string \(stringResult!)"")
            return myResult
        }else{
            free(buffer)
            return nil

        }
    }
}
extension NSData {
    struct HexEncodingOptions: OptionSet {
        let rawValue: Int
        static let upperCase = HexEncodingOptions(rawValue: 1 &lt;&lt; 0)
    }

    func hexEncodedString(options: HexEncodingOptions = []) -&gt; String {
        let format = options.contains(.upperCase) ? ""%02hhX"" : ""%02hhx""
        //var map = { String(format: format, $0) }.joined()

        return """"
    }
}
</code></pre>

<p>Output is changing for every build . Whats wrong in the code or </p>

<p>And is kCCOptionPKCS7Padding and kCCOptionPKCS5Padding is same?</p>

<p>Thanks In advance</p>
","<p>Got Solution by changing the code </p>

<pre><code>import UIKit
import CommonCrypto
var message: String?

public class IAppEncryptionUtitlity: NSObject {

   //Calling method to encrypt using extensions
    public func methodToCallEncryption( stringToEncrypt : String ) -&gt;String {
        let iVValue:String = ""nzug8FrX""
        let keyValue = IAppConfig.key //DyfmgL9p
        let encoded = stringToEncrypt.desEncrypt( key : keyValue , iv : iVValue )
        return encoded!
    }

    public func methodToCallDecryption( stringToDecrypt : String ) -&gt; String{
        let iVValue:String = ""nzug8FrX""
        let keyValue = IAppConfig.key //DyfmgL9p
        let decoded = stringToDecrypt.desEncrypt( key : keyValue , iv : iVValue )
        return decoded!
    }
}
extension String {

    func desEncrypt(key:String, iv:String, options:Int = kCCOptionPKCS7Padding) -&gt; String? {
        if let keyData = key.data(using: String.Encoding.utf8),
            let data = self.data(using: String.Encoding.utf8),
            let cryptData    = NSMutableData(length: Int((data.count)) + kCCBlockSizeDES) {


            let keyLength              = size_t(kCCKeySizeDES)
            let operation: CCOperation = UInt32(kCCEncrypt)
            let algoritm:  CCAlgorithm = UInt32(kCCAlgorithmDES)
            let options:   CCOptions   = UInt32(options)



            var numBytesEncrypted :size_t = 0

            let cryptStatus = CCCrypt(operation,
                                      algoritm,
                                      options,
                                      (keyData as NSData).bytes, keyLength,
                                      iv,
                                      (data as NSData).bytes, data.count,
                                      cryptData.mutableBytes, cryptData.length,
                                      &amp;numBytesEncrypted)

            if UInt32(cryptStatus) == UInt32(kCCSuccess) {
                cryptData.length = Int(numBytesEncrypted)
                let base64cryptString = cryptData.base64EncodedString(options: .lineLength64Characters)
                return base64cryptString

            }
            else {
                return nil
            }
        }
        return nil
    }

    func desDecrypt(key:String, iv:String, options:Int = kCCOptionPKCS7Padding) -&gt; String? {
        if let keyData = key.data(using: String.Encoding.utf8),
            let data = NSData(base64Encoded: self, options: .ignoreUnknownCharacters),
            let cryptData    = NSMutableData(length: Int((data.length)) + kCCBlockSizeDES) {

            let keyLength              = size_t(kCCKeySizeDES)
            let operation: CCOperation = UInt32(kCCDecrypt)
            let algoritm:  CCAlgorithm = UInt32(kCCAlgorithmDES)
            let options:   CCOptions   = UInt32(options)

            var numBytesEncrypted :size_t = 0

            let cryptStatus = CCCrypt(operation,
                                      algoritm,
                                      options,
                                      (keyData as NSData).bytes, keyLength,
                                      iv,
                                      data.bytes, data.length,
                                      cryptData.mutableBytes, cryptData.length,
                                      &amp;numBytesEncrypted)

            if UInt32(cryptStatus) == UInt32(kCCSuccess) {
                cryptData.length = Int(numBytesEncrypted)
                let unencryptedMessage = String(data: cryptData as Data, encoding:String.Encoding.utf8)
                return unencryptedMessage
            }
            else {
                return nil
            }
        }
        return nil
    }
}
</code></pre>

<p>Thanks everyone for the help</p>
","86","<ios><swift><encryption><des>","0","1","1","2019-02-26 07:16:10","54880187","7","2","","","","2019-02-25 09:13:02",""
"48503209","Implementation of the ""Retail MAC"" algorithm through the OpenSSL library on C","<p>I would be grateful if anyone could share an example of the implementation of the algorithm for calculating the checksum of a <a href=""https://en.wikipedia.org/wiki/ISO/IEC_9797-1"" rel=""nofollow noreferrer"">Retail MAC</a> using the OpenSSL library in C. I could not find nothing like this.
P.S. I'm sorry for my English</p>
","","85","<macos><algorithm><openssl><crc><des>","0","","0","2018-01-29 14:09:47","","2","0","","","","2018-01-29 14:09:47",""
"29587526","Why does generateKey method from DES algorithm multiply the key by 8?","<p>I am in need of some explanations on the corresponding line, which I do not understand:</p>

<pre><code>KeyGenerationParameters kgp = new KeyGenerationParameters(sr,(DESParameters.DES_KEY_LENGTH) * 8);
</code></pre>

<p>Would it stop working, if I had, for instance, the number 6 instead of 8?</p>
","<p>It is multiplied by 8 because it is in bytes otherwise. The code wants bits. </p>
","85","<java><bouncycastle><des><encryption-symmetric>","-1","0","2","2015-04-23 20:32:30","29588951","3","","2227834","","2015-04-13 00:29:03","2015-04-12 08:36:30",""
"29587526","Why does generateKey method from DES algorithm multiply the key by 8?","<p>I am in need of some explanations on the corresponding line, which I do not understand:</p>

<pre><code>KeyGenerationParameters kgp = new KeyGenerationParameters(sr,(DESParameters.DES_KEY_LENGTH) * 8);
</code></pre>

<p>Would it stop working, if I had, for instance, the number 6 instead of 8?</p>
","<p>strength - the size, in bits, of the keys we want to produce.</p>

<p>it is from javadoc for KeyGenerationParameters. The DESPArameters.DES_KEY_LENGTH stores value 8 (DES key length in bytes), but KeyGenerationParameters requires key length in bits. 8 bytes * 8 = 64 bits in a case of KeyGenerationParameters. You can just put the constant value 64.</p>

<p>This class can be used for random key generation for any algorythm, for example, to generate DES key you must use value of 64, to generate 3DES key 128 or 192. </p>
","85","<java><bouncycastle><des><encryption-symmetric>","-1","0","2","2015-04-23 20:32:30","29588951","3","","2227834","","2015-04-13 00:29:03","2015-04-12 08:36:30",""
"39691368","time taken to decrypt data in mysql","<p>i am compairing the time taken to query records in mysql in 3 different ways for a coursework project.
i have set up 3 identical databases</p>

<p>1 not encrypted,
1 that using a trigger to AES ENCRYPT inserted data,
1 that using a trigger to DES ENCRYPT inserted data</p>

<p>used a single table with a user id &amp; 6 VARBINARY columns for encrypted personal details like names and addresses (all encrypted with a single key).</p>

<p>after inserting 2000 rows the encrtption seems to be working correctly.
unfortunately the time taken to query and decrypt even all of the results is only taking 0.01 secconds so isnt noticable.</p>

<p>any suggestions on what would make the difference in time taken to retreive the data more noticable?</p>
","","85","<mysql><encryption><aes><des>","1","","0","2016-09-25 20:13:49","","7","","","","","2016-09-25 20:13:49",""
"17589874","DES Serialization Exception","<p>I am  and am having some trouble deserializing an object with DES cryptography.</p>

<p>I am getting an exception that says ""Bad Data."" in the <code>DeserializeDESObjectFromFile</code> function.</p>

<p>Can I please have some help to get this working?</p>

<p>Here is my code:</p>

<pre><code>    Public Sub SerializeDESObjectToFile(FileName As String, Item As Object)
    Dim fs As FileStream
    Dim formatter As New BinaryFormatter

    Dim DESKey() As Byte = {200, 5, 78, 232, 9, 6, 0, 4}
    Dim DESInitializationVector() As Byte = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    Dim MyStreamEncrypter As CryptoStream = Nothing

    fs = New FileStream(FileName, FileMode.Create)
    Dim DESAlgorithm As DES
    DESAlgorithm = New DESCryptoServiceProvider
    MyStreamEncrypter = New CryptoStream(fs, DESAlgorithm.CreateEncryptor(DESKey, DESInitializationVector), CryptoStreamMode.Write)

    Try
        formatter.Serialize(MyStreamEncrypter, Item)
    Catch e As Exception
        Console.WriteLine(""Failed to serialize. Reason: "" &amp; e.Message)
    Finally
        fs.Close()
    End Try
End Sub

Public Function DeserializeDESObjectFromFile(FileName As String) As Object
    Dim fs As New FileStream(FileName, FileMode.Open)
    Dim ItemToReturn As New Object

    Dim DESKey() As Byte = {200, 5, 78, 232, 9, 6, 0, 4}
    Dim DESInitializationVector() As Byte = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    Dim MyStreamDecrypter As CryptoStream = Nothing

    Dim DESAlgorithm As DES
    DESAlgorithm = New DESCryptoServiceProvider

    MyStreamDecrypter = New CryptoStream(fs, DESAlgorithm.CreateDecryptor(DESKey, DESInitializationVector), CryptoStreamMode.Read)

    Try
        Dim formatter As New BinaryFormatter
        ItemToReturn = DirectCast(formatter.Deserialize(MyStreamDecrypter), Object)
        Return ItemToReturn
    Catch e As Exception
        MsgBox(e.Message)
        Return Nothing
    Finally
        fs.Close()
    End Try
End Function
</code></pre>
","<p>It is important to make sure that the last block in the stream is flushed. Block ciphers modes such as ECB mode and CBC mode need to be padded because a block cipher can only encrypt full blocks of plaintext. As the stream does not know that your serialized data object is the last data it has to encrypt, it cannot pad and encrypt the last block itself.</p>

<p>The <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.cryptostream.flushfinalblock.aspx"" rel=""nofollow"">FlushFinalBlock</a> should be called after you have written the last plain text data to the <code>CryptoStream</code>. Alternatively you could call <code>close()</code> on the upper <code>CryptoStream</code> instead of the underlying stream, or make sure it is properly disposed <em>before</em> you call <code>close()</code> on the underlying stream.</p>
","83","<vb.net><serialization><encryption><des>","0","0","1","2013-07-12 20:36:17","17621383","1","","589259","","2013-07-12 18:13:06","2013-07-11 09:32:08",""
"29814670","Looking for ""des"" binary?","<p>I am unable to find the linux binary ""des"", which seems to exist according to this <a href=""http://linux.die.net/man/7/des"" rel=""nofollow"">man page</a>.</p>

<p>Or if someone has an alternate method, I am wanting to decrypt DES encrypted strings from the shell.</p>
","<p>If this is a Debian based distribution, you can look up which packages provide which files online using <a href=""http://packages.debian.org"" rel=""nofollow noreferrer"">http://packages.debian.org</a>. I just looked up <code>des</code> and can't find anything like this as an executable. Also, this is man page from section 7 which is not where command references usually lie. I don't think it is either. </p>

<p>As for doing DES encryption from the command line, a quick google gave me <a href=""https://security.stackexchange.com/questions/19426/openssl-equivalent-to-des-command-line"">this</a>.</p>
","81","<linux><shell><des>","-2","2","1","2015-04-23 06:03:20","","0","","139746","","2015-04-23 06:03:20","2015-04-23 05:43:41","2015-04-23 18:26:00"
"41650987","How Can I Test Symmetric Encryption Algorithms","<p>I am doing an experiment for an essay in computer science. My topic is focused around encryption. Having conducted some research, I am interested in testing symmetric encryption programs such as AES, DES, Blowfish and Twofish. However I am stuck for ideas on how to test them.</p>

<p>I had the idea of comparing file sizes after encryption to see which one is the most efficient. I must also include Big-O notation in my experiment.</p>

<p>Could someone direct me on how I could possibly do this, or suggest any other experiments that I could possibly do. P.S. I am only a 6th form student therefore my knowledge is limited, so please ensure the experiment is not too difficult. Thank you very much.</p>
","","79","<encryption><aes><big-o><des><symmetric>","0","","0","2017-01-14 14:19:44","","2","","","","","2017-01-14 14:19:44",""
"55923521","How to convert Des-ede algorithm encryption written in Java to NodeJS","<p>I am trying to convert code the below java to Nodejs. I have one requirement to encrypt the text with a key using ""DESede"" algorithm. Currently code is written in Java and now I need to migrate to Nodejs</p>

<p>Java code - </p>

<pre><code>public static void main(String args[]) throws Exception {

    String myString = ""the sample text to be encrypted"";

    EncryptData(myString);
}

public static byte[] EncryptData(String text) throws Exception {
    String keyValue = ""kbhgvfbjhgfcf87576hgv656"" ;
    final byte[] keyBytes = keyValue.getBytes(""UTF8"");

    final DESedeKeySpec key = new DESedeKeySpec(keyBytes);
    SecretKeyFactory keyFactory = 
    SecretKeyFactory.getInstance(""DESede"");
    SecretKey key1 = keyFactory.generateSecret(key);
    final Cipher cipher = Cipher.getInstance(""DESede"");
    cipher.init(1, key1);

    final byte[] plainTextBytes = text.getBytes(""UTF8"");
    final byte[] cipherText = cipher.doFinal(plainTextBytes);

    return cipherText;
}
</code></pre>

<p>I have tried using both NodeJS in built module Crypto and as well as CryptoJS. But getting different results than what I am getting in Java. Unable to figure out what I am missing. </p>

<p>Using CryptoJS [Google Code]- </p>

<pre><code>function encrypt(message, key) {

    var keyHex = CryptoJS.enc.Utf8.parse(key);

    var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });

    return encrypted;
}
</code></pre>

<p>Using NodeJS Crypto -</p>

<pre><code>let option = {
        alg: 'des-ede3',
        key: ""kbhgvfbjhgfcf87576hgv656"",
        plaintext: ""the sample text to be encrypted"",
    }

encrypt(option);

function encrypt(param) {
    var key = new Buffer(param.key, 'utf8');
    var plaintext = new Buffer(param.plaintext, 'utf8');
    var alg = param.alg;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, '');
    var ciph = cipher.update(plaintext, 'utf8');
    ciph += cipher.final('utf8');
    console.log(alg, ciph);
    return ciph;
}
</code></pre>

<p>I expect the output to be -</p>

<p>[-15, 6, -31, 6, -99, 57, -90, -125, 121, 73, -107, 112, -68, 8, 66, 62, 116, 71, 118, -55, -50, -21, 96, -124, 63, -75, -96, -117, 108, -46, -72]</p>

<p>but the actual output is -
[5a ad e6 65 a1 be b9 68 d5 bd e4 9f 3c ca d6 6c 7e 71 ad 84 c6 39 81 49 14 35 7e 5f de 64 da 40].</p>
","","78","<node.js><encryption><cryptojs><des>","1","","0","2019-04-30 14:49:25","","3","","","","","2019-04-30 14:49:25",""
"12246948","Does Crypto++ support TOFB-I?","<p>I'm developing a C++ application to decrypt the data encrypted by someone else with TOFB-I (TDEA Output Feedback - Interleaved).
To do this I'm using the Crypto++ library. </p>

<p>Unfortunately, the result of the decryption doesn't seem to work: the first byte is decrypted correctly, the rest is just meaningless data.
I've double checked with the Linux command line tool OpenSSL and get exactly the same result.
So I'm inclined to believe that I'm applying a decryption algorithm with wrong feedback, so that the first IV works fine but something goes wrong with the feedbacks.</p>

<p>My question is: how do I apply the interleaved variant of the DES_OFB mode?<br>
Couldn't find anything about this either in the Crypto++ or in the OpenSSL documentation.</p>
","<p>Apparently Crypto++ (and also OpenSSL) doesn't support TOFB-I operation mode:<br>
<a href=""http://csrc.nist.gov/groups/STM/cavp/documents/des/tripledesval.html"" rel=""nofollow"">http://csrc.nist.gov/groups/STM/cavp/documents/des/tripledesval.html</a></p>

<p>Actually, according to the above link no implementation has been validated yet as conforming to TOFB-I!</p>

<p>So I guess I'll need to implement my own TOFB-I algo.</p>
","78","<c++><des><crypto++>","1","1","1","2012-09-04 13:48:44","12264920","1","","","","","2012-09-03 11:28:30",""
"23293892","What is the encryption used in this java code? Any PHP equavent for this","<p>I have a java code</p>

<pre><code>import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import java.io.PrintStream;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class SecureCardData
{
  public static final String retailerid = ""61220121"";

  public String encryptData(String sData)
    throws Exception
  {
    byte[] bPrivateKey = ""61220121"".getBytes();
    SecretKeySpec spec = new SecretKeySpec(bPrivateKey, ""DES"");
    Cipher cipher = Cipher.getInstance(""DES"");
    cipher.init(1, spec);
    byte[] bEncryptedData = cipher.doFinal(sData.getBytes());
    return Base64.encode(bEncryptedData);
  }

  public String decryptData(String sData)
    throws Exception
  {
    byte[] bPrivateKey = ""61220121"".getBytes();
    SecretKeySpec spec = new SecretKeySpec(bPrivateKey, ""DES"");
    Cipher cipher = Cipher.getInstance(""DES"");
    cipher.init(2, spec);
    byte[] bencryptedData = Base64.decode(sData);
    byte[] bDecryptedData = cipher.doFinal(bencryptedData);
    return new String(bDecryptedData);
  }

  public static void main(String[] args)
    throws Exception
  {
    String s = ""1800585544448888|445|0611"";
    SecureCardData sd = new SecureCardData();
    String ss = sd.encryptData(s);
    System.out.println(ss);

    ss = sd.decryptData(ss);
    System.out.println(ss);
  }
}
</code></pre>

<p>Im not into java,can anyone help me make the code equivalent for this in php?
I haven't touched java ever.Finding it really hard to figure out.Is there someone who could help me with this code.?</p>
","<p><code>new SecretKeySpec(bPrivateKey, ""DES"");</code></p>

<p>This creates a secret key using the DES specification.</p>

<p><a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">http://en.wikipedia.org/wiki/Data_Encryption_Standard</a></p>

<p>Note that DES is considered obsolete/easy to break so has not been recommended for use in quite some time.</p>
","76","<java><php><encryption><base64><des>","0","0","1","2014-04-25 13:07:50","23294099","3","2","","","","2014-04-25 12:58:52",""
"50268138","Error in doFinal on multiple DES_CBC_NOPAD encryption","<p>I had a problem with DES encryption on Java Card: I encrypt the data before sending it and then send it as a response to requests coming from some library.</p>

<p>If in one  applet <code>SELECT</code> sends requests for information, then through 28-30 encryptions on the card the session falls with the error <code>6F00</code>. After that, all encryption calls return <code>6F00</code>. The problem disappears if you do a second selection of the applet.</p>

<p>All data before encryption, I make a multiple of 8, so the error due to the length of the message I eliminated immediately. There may be a memory problem, but I call <code>JCSystem.requestObjectDeletion();</code> after each sending of data. </p>

<p>Below is the initialization and encryption function implemented in my Applet.</p>

<pre><code>public static void Init()
    rw_des_key = (DESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_DES, KeyBuilder.LENGTH_DES3_3KEY, false);
    rw_cipherDes = Cipher.getInstance(Cipher.ALG_DES_CBC_NOPAD, false);
    rw_des_key.setKey(rwdeskey, (short) 0);
}

public static short RWEncrypt(byte[] msg, short pos, short len, byte[] encMsg, short encPos) throws ArithmeticException, ArrayIndexOutOfBoundsException, ArrayStoreException, ClassCastException, IndexOutOfBoundsException, NegativeArraySizeException, NullPointerException, RuntimeException, SecurityException {
        rw_cipherDes.init(rw_des_key, Cipher.MODE_ENCRYPT);
        return rw_cipherDes.doFinal(msg, (short) pos, len, encMsg, (short) encPos);}
</code></pre>

<p>If someone can tell what might be the case, then I will be very grateful!</p>
","<p>I Fix my broblem by changing <strong>externalAccess</strong> flag from False to True in <strong>Cipher.getInstance</strong> function:</p>

<pre><code>Cipher.getInstance(Cipher.ALG_DES_CBC_NOPAD, true);
</code></pre>

<p>It's resolve my problem.</p>
","76","<encryption><javacard><des>","2","0","2","2018-05-11 13:49:15","50287553","1","","589259","","2018-05-11 13:49:15","2018-05-10 07:52:44",""
"50268138","Error in doFinal on multiple DES_CBC_NOPAD encryption","<p>I had a problem with DES encryption on Java Card: I encrypt the data before sending it and then send it as a response to requests coming from some library.</p>

<p>If in one  applet <code>SELECT</code> sends requests for information, then through 28-30 encryptions on the card the session falls with the error <code>6F00</code>. After that, all encryption calls return <code>6F00</code>. The problem disappears if you do a second selection of the applet.</p>

<p>All data before encryption, I make a multiple of 8, so the error due to the length of the message I eliminated immediately. There may be a memory problem, but I call <code>JCSystem.requestObjectDeletion();</code> after each sending of data. </p>

<p>Below is the initialization and encryption function implemented in my Applet.</p>

<pre><code>public static void Init()
    rw_des_key = (DESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_DES, KeyBuilder.LENGTH_DES3_3KEY, false);
    rw_cipherDes = Cipher.getInstance(Cipher.ALG_DES_CBC_NOPAD, false);
    rw_des_key.setKey(rwdeskey, (short) 0);
}

public static short RWEncrypt(byte[] msg, short pos, short len, byte[] encMsg, short encPos) throws ArithmeticException, ArrayIndexOutOfBoundsException, ArrayStoreException, ClassCastException, IndexOutOfBoundsException, NegativeArraySizeException, NullPointerException, RuntimeException, SecurityException {
        rw_cipherDes.init(rw_des_key, Cipher.MODE_ENCRYPT);
        return rw_cipherDes.doFinal(msg, (short) pos, len, encMsg, (short) encPos);}
</code></pre>

<p>If someone can tell what might be the case, then I will be very grateful!</p>
","<p>This problem occurs when external access (externalAccess) flag is false in the object but the corresponding object is called by a shareable interface.</p>

<p>For example (from your code): -</p>

<blockquote>
  <p>rw_cipherDes = Cipher.getInstance(Cipher.ALG_DES_CBC_NOPAD, false);</p>
</blockquote>

<p>Here the external access flag is False i.e. you are instructing the Cipher API <strong>not</strong> to provide the access of cipher object to any external application (which is for the case of calling this API by shareable interface).</p>

<p>So, the following line will generate a security exception (hence SW 6F00) when called from across applications by shareable interface. </p>

<blockquote>
  <p>return rw_cipherDes.doFinal(msg, (short) pos, len, encMsg, (short)
  encPos);}</p>
</blockquote>

<p>Obviously,when you call the same API from its own application, then it will work fine.</p>

<p>Solution is allowing <code>externalAccess (true)</code> for the object. This would make it accessible via shareable interface.</p>

<blockquote>
  <p>rw_cipherDes = Cipher.getInstance(Cipher.ALG_DES_CBC_NOPAD, true);</p>
</blockquote>
","76","<encryption><javacard><des>","2","4","2","2018-05-11 13:49:15","50287553","1","","589259","","2018-05-11 13:49:15","2018-05-10 07:52:44",""
"53366883","Generate 20 different bits","<p>I am working on encryption with DES, which uses a 56-bit effective key (after discarding the least significant bits) to encrypt a 64-bit plaintext. I want to set the first 20-bits of the key to random bits, and the last 36-bits to 0. I have been trying to do it with <code>BitSet</code> where I have set up an array with with 64-bits where all the values are false in the beginning. Then I have set up a temp array of 20-bits, and I have been trying to use <code>bitset.set(Random.nextInt(n), true)</code>  within a for loop, which goes from 0-20 - The idea is that I get exactly 20 random bits.</p>

<p>In order to discard the least significant bit, I have a for loop where I go from 0 to 20. Within this for loop, I have an if statement which discards every 8th element for the first 20 elements</p>

<pre><code>static BitSet key1 = new BitSet(64);
static BitSet key2 = new BitSet(64);

    public static void generate() {

        BitSet temp1 = new BitSet(20);
        BitSet temp2 = new BitSet(20);

        Random r = new Random();
        for (int i = 0; i &lt; 20; i++) {
            temp1.set(r.nextInt(60), true);
            temp2.set(r.nextInt(60), true);
        }
for (int i = 0; i &lt; 20; i++) {
            key1.set(i, temp1.get(i));
            key2.set(i, temp2.get(i));
        }
            System.out.println(k1temp);

        for (int i = 0; i &lt; temp1.length(); i++) {

        if (i % 8 == 0) {
                key1.clear(i);
                key2.clear(i);
            }
        }    
    }
</code></pre>

<p>So, the problem I have is that my <code>BitSet</code> does not always consist of 20 elements, which leads to that the key I generate is wrong. I have been through the code several times, but I cannot see what is wrong.</p>

<p>EDIT:</p>

<p>What I mean by first and last is that the first bits are the Most significant bits and the last are the Least significant bits.</p>
","<p>You can use bitmasks with the &amp; (bitwise and) operator:</p>

<pre><code>Random r = new SecureRandom(); // WARNING - use SecureRandom when generating cryptographic keys!
long v1 = r.nextLong() &amp; 0xfffff; // Low order 20 bits are random, rest zero
long v2 = r.nextLong() &amp; 0xfffff00000000000L; // High order 20 bits are random
</code></pre>
","76","<java><bit><bitset><des>","0","1","2","2019-02-11 09:17:34","","7","","4789269","","2018-11-19 01:01:39","2018-11-19 00:30:56",""
"53366883","Generate 20 different bits","<p>I am working on encryption with DES, which uses a 56-bit effective key (after discarding the least significant bits) to encrypt a 64-bit plaintext. I want to set the first 20-bits of the key to random bits, and the last 36-bits to 0. I have been trying to do it with <code>BitSet</code> where I have set up an array with with 64-bits where all the values are false in the beginning. Then I have set up a temp array of 20-bits, and I have been trying to use <code>bitset.set(Random.nextInt(n), true)</code>  within a for loop, which goes from 0-20 - The idea is that I get exactly 20 random bits.</p>

<p>In order to discard the least significant bit, I have a for loop where I go from 0 to 20. Within this for loop, I have an if statement which discards every 8th element for the first 20 elements</p>

<pre><code>static BitSet key1 = new BitSet(64);
static BitSet key2 = new BitSet(64);

    public static void generate() {

        BitSet temp1 = new BitSet(20);
        BitSet temp2 = new BitSet(20);

        Random r = new Random();
        for (int i = 0; i &lt; 20; i++) {
            temp1.set(r.nextInt(60), true);
            temp2.set(r.nextInt(60), true);
        }
for (int i = 0; i &lt; 20; i++) {
            key1.set(i, temp1.get(i));
            key2.set(i, temp2.get(i));
        }
            System.out.println(k1temp);

        for (int i = 0; i &lt; temp1.length(); i++) {

        if (i % 8 == 0) {
                key1.clear(i);
                key2.clear(i);
            }
        }    
    }
</code></pre>

<p>So, the problem I have is that my <code>BitSet</code> does not always consist of 20 elements, which leads to that the key I generate is wrong. I have been through the code several times, but I cannot see what is wrong.</p>

<p>EDIT:</p>

<p>What I mean by first and last is that the first bits are the Most significant bits and the last are the Least significant bits.</p>
","<p>As I understand the problem: You have an unexpected count of (set) bits!</p>

<p>Reason: Using <code>Random</code>, with the given bounds <code>nextInt(60)</code> and a repetition of 2 x 20 times, it is ""quite likely"" that you set (overwrite) your bits multiple times, which makes you missing (set) bits by the end.</p>

<p>A simple solution 'd be to repeat <code>int next = nextInt(60);</code> until <code>!temp1.get(next)</code> (<code>temp2</code>respectively):</p>

<pre><code>    Random r = new Random();
    for (int i = 0; i &lt; 20; i++) {
        int next = r.nextInt(60);
        while (temp1.get(next)) { //bit already set, repeat:
            next = r.nextInt(60);
        }
        temp1.set(next);

        // temp2:
        next = r.nextInt(60);
        while (temp2.get(next)) {
            next = r.nextInt(60);
        }
        temp2.set(next);
    } // ensures you 20 bits set.
</code></pre>

<hr>

<p>A finer solution, would be a data structure, which ensures you random &amp; unique values...like: <a href=""https://stackoverflow.com/q/4040001/592355"">Creating random numbers with no duplicates</a></p>

<p>or this function (see : <a href=""https://stackoverflow.com/a/54608445/592355"">https://stackoverflow.com/a/54608445/592355</a>):</p>

<pre><code>static IntStream uniqueInts(int min, int max, int count, java.util.Random rnd) {
    // call Random.ints(min, max) with ... distinct and limit
    return rnd.ints(min, max).distinct().limit(count);
}
</code></pre>

<p>which you would use like:</p>

<pre><code>final BitSet temp1 = new BitSet(20); // values lower than 64 (resp. 32?) lead to 64 (resp. 32!)
final BitSet temp2 = new BitSet(20);
final Random r = new Random();
unniqueInts(0, 60, 20, r).forEach(i - &gt; {if(i % 8 &gt; 0)temp1.set(i)});
unniqueInts(0, 60, 20, r).forEach(i - &gt; {if(i % 8 &gt; 0)temp2.set(i)});
//also better:
key1.or(temp1);
key2.or(temp2);

System.out.println(k1temp);
//the if (i % 8 == 0)  ..already done in forEach^^
</code></pre>
","76","<java><bit><bitset><des>","0","0","2","2019-02-11 09:17:34","","7","","4789269","","2018-11-19 01:01:39","2018-11-19 00:30:56",""
"21639318","What typedef to use for 48bits vars","<p>I don't really know the vocabulary here (bit vars? bit fields? bit strings?)</p>

<p>I'm coding an implementation of DES and I'm manipulating 64bits strings rarely, 28bits and 24bits a bit more, and 48 bits strings a lot.</p>

<p>I've seen implementations using arrays of chars. So it takes exactly the right amount of memory.</p>

<p>But when it comes to bit operation, I found using uint64_t typedef simplifying everything. Eventhough it's too much most of the time.</p>

<p>What do you guys think? Should I keep using uint64_t and pad it with 0s most of the time?</p>
","<p>You definitely want to use uint64_t for everything for performance and simplicity. If you need to handle 48-bit overflow you'll have to handle that specially.</p>
","75","<c><typedef><des>","2","5","1","2014-02-07 23:03:34","","4","","","","","2014-02-07 22:58:09",""
"42124390","exponential arrival and service rates","<p>I have 2 agent types (say patients). each patient type will need a service after an exponential amount of time. 
We also have 2 different services A and B which have different service rates (exponential) for different patient types. 
So in total we have 4 different arrival rates and 4 different service rates.
How can I model this? How can I say that these 2 patient types are going to use those 2 servers since arrival and service rates are exponential? right now I am using probability in selectoutput but the results I get are not exact. When we have exponential arrival and service rates,
how can we say that the agents are going to use the s<a href=""https://i.stack.imgur.com/lnFqm.png"" rel=""nofollow noreferrer"">enter image description here</a>ervers? Is there a better way to model this? any help would be appreciated.</p>
","<p>What I could make up from the text and the model you showed is that you have 2 different patients which are also split in 2 different services which they need and that causes the 4 different delays. So patient 1 and 2 and service A or B cause 4 delays? If this is the case than I would make a parameter in the agent called serviceType which Amy Greer first stated and define this parameter at the exit of the first selectOutputs (or exit of delays is also possible). With the select output you can assign the patients to the right service which Amy already stated by using a condition statement.</p>

<p>Now if you want to use different processtimes in your services for the different patients, which consist of 2 different processtimes for service A and B (1&amp;2 for A and 1&amp;2 for B) there are multiple way to do this. Personally I would make a database in my model in which I specify the process times (exponential distributions in this case) and do the delay time in service A and B through a database reference. If you are not familiar with how to do this, I uploaded a screenshot to this link <a href=""https://imgur.com/7x0xCUZ"" rel=""nofollow noreferrer"">http://imgur.com/7x0xCUZ</a>. I'm not sure if I know exactly what you are trying to do but I think that this should resolve the problem.</p>
","73","<des><exponential>","-2","0","1","2017-02-16 19:54:24","","0","","","","","2017-02-08 21:55:18",""
"15638920","DES Encryption and Decryption in Objective C","<p>I want to encrypt and decrypt some data in my ios project with DES. I searched the internet but could not find a proper answer of my question. I am searching a tutorial or an example about how to decrypt and encrypt data with objective c in DES. can anyone show me a way or example?</p>
","","72","<ios><objective-c><des>","0","","0","2013-03-26 13:57:30","","4","","","","","2013-03-26 13:57:30","2013-03-26 15:25:31"
"49792516","Could not write JSON: Input length must be multiple of 8 when decrypting with padded cipher","<p>I have followed a guide to simply encrypt and decrypt a string but I can't somehow make it work</p>

<p>I want to have a constant key so I don't need to save it to my database and waste space</p>

<p>I just want to encrypt some personal data not password</p>

<p>do you guys have any idea?</p>

<p>I'm following <a href=""https://www.mkyong.com/java/jce-encryption-data-encryption-standard-des-tutorial/"" rel=""nofollow noreferrer"">this</a> guide please it </p>

<pre><code>      public String getAction() throws Exception {
            String encodedKey = ""eightkey"";
            byte[] key = encodedKey.getBytes();
            decodedKey.length, ""DES"");

            SecretKey myDesKey = new SecretKeySpec(key, ""DES"");
            Cipher desCipher;
            desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
            desCipher.init(Cipher.DECRYPT_MODE, myDesKey);
            byte[] text = action.getBytes();
            byte[] textEncrypted = desCipher.doFinal(text);
            String getAct = """"+textEncrypted;

                return getAct;
        }

        public void setAction(String action) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {

            String encodedKey = ""eightkey"";
            byte[] key = encodedKey.getBytes();
            SecretKey myDesKey = new SecretKeySpec(key, ""DES"");
            Cipher desCipher;
            desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
            byte[] text = action.getBytes();
            desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
            byte[] textEncrypted = desCipher.doFinal(text);
            String setAct = """"+textEncrypted;
            this.action = setAct;
        }
</code></pre>

<p>Full error here</p>

<pre><code>2018-04-12 17:06:34.587  WARN 1572 --- [nio-8080-exec-3] .w.s.m.s.DefaultHandlerExceptionResolver : Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Input length must be multiple of 8 when decrypting with padded cipher; nested exception is com.fasterxml.jackson.databind.JsonMappingException: Input length must be multiple of 8 when decrypting with padded cipher (through reference chain: com.capstone.codegum.Codegum.Objects.Logs[""action""])
</code></pre>
","<p>Use byte[] actionBytes instead of String action something of the sort:</p>

<pre><code>private byte[] actionBytes;

public String getAction() throws Exception {

    String encodedKey = ""eightkey"";
    byte[] key = encodedKey.getBytes(""UTF8"");
    SecretKey myDesKey = new SecretKeySpec(key, ""DES"");

    Cipher desCipher;
    desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    desCipher.init(Cipher.DECRYPT_MODE, myDesKey);      
    byte[] textEncrypted = desCipher.doFinal(actionBytes);
    return new String(textEncrypted);
}

public void setAction(String action) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {

    String encodedKey = ""eightkey"";
    byte[] key = encodedKey.getBytes(""UTF8"");       

    SecretKey myDesKey = new SecretKeySpec(key, ""DES"");

    Cipher desCipher;
    desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    byte[] text = action.getBytes(""UTF8"");
    desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
    byte[] textEncrypted = desCipher.doFinal(text);
    actionBytes = textEncrypted;
}
</code></pre>

<p>Or if you want to keep using String action then you should do this:</p>

<pre><code>public String action;

public String getAction() throws Exception {

    String encodedKey = ""eightkey"";
    byte[] key = encodedKey.getBytes(""UTF8"");
    SecretKey myDesKey = new SecretKeySpec(key, ""DES"");

    Cipher desCipher;
    desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    desCipher.init(Cipher.DECRYPT_MODE, myDesKey);      
    byte[] textEncrypted = desCipher.doFinal(action.getBytes(""UTF8""));
    return new String(textEncrypted);
}

public void setAction(String action) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {

    String encodedKey = ""eightkey"";
    byte[] key = encodedKey.getBytes(""UTF8"");       

    SecretKey myDesKey = new SecretKeySpec(key, ""DES"");

    Cipher desCipher;
    desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    byte[] text = action.getBytes(""UTF8"");
    desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
    byte[] textEncrypted = desCipher.doFinal(text);
    action = new String(textEncrypted, ""UTF8"");
}
</code></pre>
","70","<java><encryption><des><jce>","0","0","2","2018-04-12 10:01:44","","2","","9066659","","2018-04-12 09:19:21","2018-04-12 09:11:04",""
"49792516","Could not write JSON: Input length must be multiple of 8 when decrypting with padded cipher","<p>I have followed a guide to simply encrypt and decrypt a string but I can't somehow make it work</p>

<p>I want to have a constant key so I don't need to save it to my database and waste space</p>

<p>I just want to encrypt some personal data not password</p>

<p>do you guys have any idea?</p>

<p>I'm following <a href=""https://www.mkyong.com/java/jce-encryption-data-encryption-standard-des-tutorial/"" rel=""nofollow noreferrer"">this</a> guide please it </p>

<pre><code>      public String getAction() throws Exception {
            String encodedKey = ""eightkey"";
            byte[] key = encodedKey.getBytes();
            decodedKey.length, ""DES"");

            SecretKey myDesKey = new SecretKeySpec(key, ""DES"");
            Cipher desCipher;
            desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
            desCipher.init(Cipher.DECRYPT_MODE, myDesKey);
            byte[] text = action.getBytes();
            byte[] textEncrypted = desCipher.doFinal(text);
            String getAct = """"+textEncrypted;

                return getAct;
        }

        public void setAction(String action) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {

            String encodedKey = ""eightkey"";
            byte[] key = encodedKey.getBytes();
            SecretKey myDesKey = new SecretKeySpec(key, ""DES"");
            Cipher desCipher;
            desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
            byte[] text = action.getBytes();
            desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
            byte[] textEncrypted = desCipher.doFinal(text);
            String setAct = """"+textEncrypted;
            this.action = setAct;
        }
</code></pre>

<p>Full error here</p>

<pre><code>2018-04-12 17:06:34.587  WARN 1572 --- [nio-8080-exec-3] .w.s.m.s.DefaultHandlerExceptionResolver : Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Input length must be multiple of 8 when decrypting with padded cipher; nested exception is com.fasterxml.jackson.databind.JsonMappingException: Input length must be multiple of 8 when decrypting with padded cipher (through reference chain: com.capstone.codegum.Codegum.Objects.Logs[""action""])
</code></pre>
","<p>I have modified your code a bit and able to run it. Here is a running example:</p>

<p>Pojo.java</p>

<pre><code>package com.test;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class Pojo {
    private byte[] action = null;
    private SecretKey myDesKey = null;
    private String encodedKey = ""eightkey"";

    public String getAction() throws Exception {
        Cipher desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);

        byte[] text = action;
        byte[] textEncrypted = desCipher.doFinal(text);
        String getAct = new String(textEncrypted);

        return getAct;
    }

    public void setAction(String action) throws Exception {
        Cipher desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        byte[] key = encodedKey.getBytes();
        this.myDesKey = new SecretKeySpec(key, ""DES"");
        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);

        byte[] text = action.getBytes();
        byte[] textEncrypted = desCipher.doFinal(text);
        this.action = textEncrypted;
    }
}
</code></pre>

<p>MainClass.java</p>

<pre><code>package com.test;

public class MainClass {

    public static void main(String[] args) throws Exception {
        Pojo p = new Pojo();
        p.setAction(""hello"");
        String s = p.getAction();
        System.out.println(s);
        p.setAction(""world"");
        s = p.getAction();
        System.out.println(s);
    }

}
</code></pre>

<p>Output:</p>

<pre><code>hello
world
</code></pre>
","70","<java><encryption><des><jce>","0","1","2","2018-04-12 10:01:44","","2","","9066659","","2018-04-12 09:19:21","2018-04-12 09:11:04",""
"47266693","Triple DES Java not working","<p>I'm using this programs code <a href=""http://www.pracspedia.com/INS/DES-java.html"" rel=""nofollow noreferrer"">Programs code full</a> and i can't figure it out why wouldn't my Triple DES work. How and what did i try?</p>

<ol>
<li><p>I added 3key inputs (as well arrays for keybits) that i would use to encrypt the hex and converted them:</p>

<pre><code>    String keyy1 = new Scanner(System.in).nextLine();
    int keyBitstriple1[] = new int[64];
        for(int i=0 ; i &lt; 14 ; i++) {
        String s = Integer.toBinaryString(Integer.parseInt(keyy1.charAt(i) + """", 16));
                while(s.length() &lt; 4) {
                    s = ""0"" + s;
                }
                for(int j=0 ; j &lt; 4 ; j++) {
                    keyBitstriple1[(4*i)+j] = Integer.parseInt(s.charAt(j) + """");
                }
            }    
</code></pre></li>
<li><p>Then i encrypted the hexa:</p>

<pre><code>    System.out.println(""1st encrypt"");
    int outputBits[] = permute(inputBits, keyBitstriple1, false);
    int outputBits2[] = Arrays.copyOf(outputBits, outputBits.length);
    System.out.println(""-----------------------------------------------------------"");
    System.out.println(""2nd enrypt"");
    int outputBits3[] = permute(outputBits2, keyBitstriple2, false);
    int outputBits4[] = Arrays.copyOf(outputBits3, outputBits3.length);
    System.out.println(""-----------------------------------------------------------"");
    System.out.println(""3rd enrypt"");
    int outputBits5[] = permute(outputBits4, keyBitstriple3, false);
 );
 int outputBits6[] = Arrays.copyOf(outputBits5, outputBits5.length); 
//a copy of end encrypt
</code></pre></li>
</ol>

<p><strong>Encryption is completely correct, even when i check with online DES encryption software results was the same.</strong></p>

<ol start=""3"">
<li><p>Then i saved the end encryption in outputBits6 and made a user enter 3 more keys to what decrypt that encrypted text. <strong>The same as first step.</strong></p>

<pre><code> String keyy4 = new Scanner(System.in).nextLine();
 String keyy5 = new Scanner(System.in).nextLine();
 String keyy6 = new Scanner(System.in).nextLine();
</code></pre></li>
<li><p>Then i took first user entered key to decrypt the hexa text. (outputbits6)</p>

<pre><code>    System.out.println(""-----------------------------------------------------------"");
    System.out.println(""First decrypt"");
    int outputBits7[] =  permute(outputBits6, keyBitstriple4, true);
    System.out.println(""-----------------------------------------------------------"");
    System.out.println(""2nd decrypt"");
    int outputBits8[] = permute(outputBits7, keyBitstriple5, true);
    System.out.println(""-----------------------------------------------------------"");
    System.out.println(""3rd decrypt"");
    int outputBits9[] = permute(outputBits8, keyBitstriple6, true);
</code></pre></li>
</ol>

<p>Every time decryption is wrong and i can't figure it out why but encryption is correct. <a href=""https://gist.github.com/e1cd910ad2ec86fe1cf9ee07c4f83936"" rel=""nofollow noreferrer"">MY FULL CODE</a></p>

<p>Thanks in advance.</p>
","<p>One thing that is missing is that generally 3DES encryption is <code>ede</code>: encrypt with the 1st key, decrypt with the 2nd key and encrypt with the 3rd key. The reverse <code>ded</code> for decryption.</p>
","70","<java><des>","1","1","1","2017-11-13 15:27:12","47267827","7","","","","","2017-11-13 14:29:51",""
"20804487","Encryption/Decryption invalid parameters using DES algorithm","<p>I am currently working on a Encryption/Decryption exercise. Main functionality is done however it was done in console. Now I will create the application in win form.</p>

<p>My Encryption/Decryption methods take byte arrays as arguments. I used DES as per program specifications. I was population the byte arrays like this </p>

<pre><code>//were mk is a string
byte[] mkBytes = System.Text.UTF8Encoding.UTF8.GetBytes(mk); 
</code></pre>

<p>However CreateDecryptor method was giving <code>""Specified key is not a valid size for this algorithm""</code> error. 
Therefore to go around the problem I was forced to do this, hard code the whole bit array and worked fine.</p>

<pre><code>byte[] masterKey_bytearr = { 0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23 };
</code></pre>

<p>But now I face the problem again since the user will be inputting the string in a textbox and cannot hard code them myself.  How can I get the string from textbox and assign it to a byte[] suitable for DES CreateDecryptor method?</p>
","","69","<c#><winforms><encryption><des>","0","","0","2013-12-27 16:55:33","","2","","320417","","2013-12-27 16:55:33","2013-12-27 16:51:38","2013-12-27 16:53:46"
"24299298","DESede Decrypt Issue","<p>I am trying to understand some legacy code where one of the parameter to <code>Cipher.init</code> is 2. What does 2 signify here?</p>

<pre><code>try
{
    if (key == null)
    {
        key = SecretKeyFactory.getInstance(""DESede"").generateSecret(new DESedeKeySpec(keyBytes));
    }

    Cipher cipher = Cipher.getInstance(""DESede"");
    cipher.init(2, key);
}
</code></pre>
","<blockquote>
  <p>What does 2 signify here?</p>
</blockquote>

<p>That's <code>opmode</code>. From <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html"" rel=""nofollow""><code>Cipher</code> class Javadocs</a>:</p>

<pre><code>void init(int opmode, Key key)
</code></pre>

<p>I believe 2 is <code>DECRYPT_MODE</code>. See the <a href=""http://docs.oracle.com/javase/7/docs/api/constant-values.html#javax.crypto.Cipher.DECRYPT_MODE"" rel=""nofollow"">Constant Field Values</a> at the bottom of the page.</p>
","69","<java><encryption><des>","0","0","1","2014-06-19 05:27:38","24299345","0","2","608639","","2014-06-19 05:24:49","2014-06-19 05:23:09",""
"41474308","How do you prepend an IV to the ciphertext in Go?","<p>I would really appreciate the help. I have the following <a href=""https://play.golang.org/p/gIee9raIQV"" rel=""nofollow noreferrer"">code</a> running. Unfortunately, I do not understand how to properly prepend the IV to the ciphertext. Line 1 is the plaintext. Line 2 is the encrypted plaintext in terms of DES (which is wrong). Line 3 is the decryption of Line 2.</p>

<p><code>**output** 
1  Yolandi Visser
2  AAAAAAAAAAAfiIMmXF4ZPYOcypF5JA== 
3  Yolandi Visser</code></p>
","<p>@JimB thank you for your clarifications! I ended up rewording the question <a href=""https://stackoverflow.com/questions/41490851/golang-how-do-i-encrypt-plain-text-that-is-5-characters-long-with-des-and-cbc?noredirect=1#comment70188445_41490851"">here</a> and found my answer.</p>
","69","<go><des>","-1","0","1","2017-01-06 21:36:49","","9","","4021006","","2017-01-05 15:39:17","2017-01-04 22:30:08",""
"47048121","c# DES encryption not working as expected","<p>Previously we have a DES encryption function in Oracle, now we want to move it to C# code. However, when testing the 2 methods, they give the different output with the same input text and key. I noticed in Oracle code, it adds chr(0) to the end of string, while in C#, I use new byte[]{0,0} for the same, not sure if this causes the problem?</p>

<p>Oracle code:</p>

<pre><code>create or replace 
function
encrypt_des(p_text varchar2, p_key varchar2) return varchar2 is
v_text varchar2(4000);
v_enc varchar2(4000);
raw_input RAW(128) ;
key_input RAW(128) ;
decrypted_raw RAW(2048);
begin
v_text := rpad( p_text, (trunc(length(p_text)/8)+1)*8, chr(0));
raw_input := UTL_RAW.CAST_TO_RAW(v_text);
key_input := UTL_RAW.CAST_TO_RAW(p_key);
 dbms_output.put_line(raw_input ); 
//display the raw_input

dbms_obfuscation_toolkit.DESEncrypt(input =&gt; raw_input,key =&gt; 
key_input,encrypted_data =&gt;decrypted_raw);
v_enc := rawtohex(decrypted_raw);

dbms_output.put_line(v_enc);

return v_enc;
end;
</code></pre>

<p>C# code:</p>

<pre><code>        byte[] rgbKey = Encoding.ASCII.GetBytes(""aaaaaaaa"".Substring(0, 8));

        byte[] inputByteArray = Encoding.UTF8.GetBytes(""9804ff20"");
        var newbyte = inputByteArray.Concat(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }).ToArray();
        var rawinput= BitConverter.ToString(newbyte).Replace(""-"", """");
    //display the raw_input

        DESCryptoServiceProvider dCSP = new DESCryptoServiceProvider();
        dCSP.Mode = CipherMode.ECB;
        dCSP.Padding = PaddingMode.None;
        dCSP.Key = rgbKey;
        MemoryStream mStream = new MemoryStream();
        CryptoStream cStream = new CryptoStream(mStream, dCSP.CreateEncryptor(), CryptoStreamMode.Write);
        cStream.Write(newbyte, 0, newbyte.Length);
        cStream.FlushFinalBlock();
        StringBuilder builder = new StringBuilder();

        foreach (byte num in mStream.ToArray())
        {
            builder.AppendFormat(""{0:X2}"", num);
        }
        mStream.Close();
        var result= builder.ToString(); 
</code></pre>

<p>before encryption, I compared the raw_input in both methods (the line I commented in the code), and they are exactly the same, but after encryption, why I get different results?</p>

<p>Testing result:</p>

<pre><code>Input text: 9804ff20
Key: aaaaaaaa
Oracle Raw input:39383034666632300000000000000000
C# raw input: 39383034666632300000000000000000
Oracle result: 29B63290034C40DAEF7A5D9608CC19B1
C# result: 29B63290034C40DA5FF660CB09F83313
</code></pre>
","","69","<c#><oracle><encryption><des>","0","","0","2017-11-01 04:12:53","","6","","","","","2017-11-01 04:12:53",""
"30631992","How can I save the DES encrypted string correctly?","<p>I'm using DES to encrypt a certain <code>String s1</code>.
After <code>s1</code> is encrypted into <code>byte[] b1</code>, I want to save it as a <code>String s2</code>.
But when I try to turn <code>s2</code> back into <code>byte[] b2</code> and decrypt it into the original <code>String s1</code>, an error occurs:</p>

<blockquote>
  <p>javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 when decrypting with padded cipher</p>
</blockquote>

<pre><code>CipherTest ct = new CipherTest();
byte[] encoded = ct.encrypt(str, key);
String s1 = new String(encoded);
byte[] b1 = s1.getBytes();
String decoded=ct.decrypt(b1, key);
</code></pre>
","","67","<java><encryption><des>","0","","0","2015-06-03 23:24:27","","4","1","1295435","","2015-06-03 23:24:27","2015-06-03 22:34:13",""
"21105156","Program giving wrong output","<p>I need some help with my program here. Can anyone help me out with this?</p>

<p>Thanks!</p>

<p>Every time I run my code, I get the following output:</p>

<p><img src=""https://i.stack.imgur.com/Olwcb.png"" alt=""enter image description here"">
<img src=""https://i.stack.imgur.com/cdZUs.png"" alt=""enter image description here"">
<img src=""https://i.stack.imgur.com/yBxip.png"" alt=""enter image description here""></p>

<p>But I want the output to be like this in one box instead of many:
<img src=""https://i.stack.imgur.com/ECjHD.png"" alt=""enter image description here""></p>

<p>Code:</p>

<pre><code>public class myDesCbc2 {

    public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

JFrame frame = null;
JFileChooser fChoose = new JFileChooser(System.getProperty(""user.home""));
int returnVal = fChoose.showOpenDialog(frame);
File myFile = fChoose.getSelectedFile();

//Read file and store to String line
FileInputStream fis = new FileInputStream(myFile);
BufferedReader stream = new BufferedReader(new InputStreamReader(fis, ""ISO-8859-1""));
String file;
while ((file = stream.readLine()) != null) {

    JOptionPane.showOptionDialog(
            null, ""Generating a 56-bit DES key..."", ""Processing..."", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, new Object[]{}, null);
    // Create an 8-byte initialization vector
    SecureRandom sr = new SecureRandom();
    byte[] iv = new byte[8];
    sr.nextBytes(iv);
    IvParameterSpec IV = new IvParameterSpec(iv);

    // Create a 56-bit DES key
    KeyGenerator kg = KeyGenerator.getInstance(""DES"");

    // Initialize with keysize
    kg.init(56);
    Key mykey = kg.generateKey();

    JOptionPane.showOptionDialog(
            null, ""Your key has been generated!"", ""Processing..."", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, new Object[]{}, null);

    // Create a cipher object and use the generated key to initialize it
    Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

    cipher.init(Cipher.ENCRYPT_MODE, mykey, IV);

    byte[] plaintext = file.getBytes(""UTF8"");

    // Encrypt the text
    byte[] ciphertext = cipher.doFinal(plaintext);

   JOptionPane.showMessageDialog(null,""\n\nCiphertext: "");
    for (int i = 0; i &lt; ciphertext.length; i++) {

        if (chkEight(i)) {
            System.out.print(""\n"");
        }
        JOptionPane.showMessageDialog(null,ciphertext[i] + "" "");
    }
}
}
}
</code></pre>

<p>chkEight code:</p>

<pre><code>public class chkEight {
      public static Boolean chkEight (int num) {
         int num1, rem;
         num1 = num % 8;
         if(num1== 0) {
             return true;
         }
         else
         {
             return false;
         }
}
}
</code></pre>
","<p>Your error is in this part:</p>

<pre><code>JOptionPane.showMessageDialog(null,""\n\nCiphertext: "");
for (int i = 0; i &lt; ciphertext.length; i++) {

    if (chkEight(i)) {
        System.out.print(""\n"");
    }
    JOptionPane.showMessageDialog(null,ciphertext[i] + "" "");
}
</code></pre>

<p>You want to take all those <code>ciphertext[i]</code> parts and somehow combine them. Then you can display a single MessageDialog outside of your loop. That will achieve the desired result.</p>
","67","<java><joptionpane><encryption><des>","0","2","2","2018-04-15 14:03:43","21105371","1","2","1033581","","2018-04-15 14:03:43","2014-01-14 02:41:28",""
"21105156","Program giving wrong output","<p>I need some help with my program here. Can anyone help me out with this?</p>

<p>Thanks!</p>

<p>Every time I run my code, I get the following output:</p>

<p><img src=""https://i.stack.imgur.com/Olwcb.png"" alt=""enter image description here"">
<img src=""https://i.stack.imgur.com/cdZUs.png"" alt=""enter image description here"">
<img src=""https://i.stack.imgur.com/yBxip.png"" alt=""enter image description here""></p>

<p>But I want the output to be like this in one box instead of many:
<img src=""https://i.stack.imgur.com/ECjHD.png"" alt=""enter image description here""></p>

<p>Code:</p>

<pre><code>public class myDesCbc2 {

    public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

JFrame frame = null;
JFileChooser fChoose = new JFileChooser(System.getProperty(""user.home""));
int returnVal = fChoose.showOpenDialog(frame);
File myFile = fChoose.getSelectedFile();

//Read file and store to String line
FileInputStream fis = new FileInputStream(myFile);
BufferedReader stream = new BufferedReader(new InputStreamReader(fis, ""ISO-8859-1""));
String file;
while ((file = stream.readLine()) != null) {

    JOptionPane.showOptionDialog(
            null, ""Generating a 56-bit DES key..."", ""Processing..."", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, new Object[]{}, null);
    // Create an 8-byte initialization vector
    SecureRandom sr = new SecureRandom();
    byte[] iv = new byte[8];
    sr.nextBytes(iv);
    IvParameterSpec IV = new IvParameterSpec(iv);

    // Create a 56-bit DES key
    KeyGenerator kg = KeyGenerator.getInstance(""DES"");

    // Initialize with keysize
    kg.init(56);
    Key mykey = kg.generateKey();

    JOptionPane.showOptionDialog(
            null, ""Your key has been generated!"", ""Processing..."", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, new Object[]{}, null);

    // Create a cipher object and use the generated key to initialize it
    Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

    cipher.init(Cipher.ENCRYPT_MODE, mykey, IV);

    byte[] plaintext = file.getBytes(""UTF8"");

    // Encrypt the text
    byte[] ciphertext = cipher.doFinal(plaintext);

   JOptionPane.showMessageDialog(null,""\n\nCiphertext: "");
    for (int i = 0; i &lt; ciphertext.length; i++) {

        if (chkEight(i)) {
            System.out.print(""\n"");
        }
        JOptionPane.showMessageDialog(null,ciphertext[i] + "" "");
    }
}
}
}
</code></pre>

<p>chkEight code:</p>

<pre><code>public class chkEight {
      public static Boolean chkEight (int num) {
         int num1, rem;
         num1 = num % 8;
         if(num1== 0) {
             return true;
         }
         else
         {
             return false;
         }
}
}
</code></pre>
","<p>To expand on Jean-Bernard's answer:</p>

<p>String concatenation is done like this in Java:</p>

<pre><code>String s1 = ""hello"";
String s2 = ""world"";
String s3 = s1+"" ""+s2; // ""hello world""
</code></pre>

<p>Therefore what you want to do is concatenate all of the strings (with a loop) before you show the dialog box.</p>

<p>Which you would do like this:</p>

<pre><code>String collection = """";
for(int i  = 0; i &lt; cihpertext.length; i++) {
    collection += "" ""+ciphertext[i];
    if(chkEight(i)) [
        collection += ""\n""
    }
}
JOptionPane.showMessageDialog(null, collection);
</code></pre>

<p>EDIT: To clarify what your mistake is:</p>

<pre><code>JOptionPane.showMessageDialog(null,""\n\nCiphertext: "");
for (int i = 0; i &lt; ciphertext.length; i++) {

    if (chkEight(i)) {
        System.out.print(""\n"");
    }
    JOptionPane.showMessageDialog(null,ciphertext[i] + "" "");
}
</code></pre>

<p>In this code you:</p>

<ol>
<li><p>Try to print a newline to the terminal if chkEight(i) returns true; this won't append anything to the string.</p></li>
<li><p>Then you call showMessageDialog for every iteration in the loop, showing the current ciphertext element plus a space.</p></li>
</ol>

<p>Are you sure that you understand your own code?</p>
","67","<java><joptionpane><encryption><des>","0","1","2","2018-04-15 14:03:43","21105371","1","2","1033581","","2018-04-15 14:03:43","2014-01-14 02:41:28",""
"53941878","Can I use PKCS5Padding padding algorithm while decryption for already encrypted data using PKCS7Padding?","<p>I'm replacing PKCS7Padding padding with PKCS5Padding for my AES encryptions.</p>

<p>Can I use PKCS5Padding padding algorithm while decryption for already encrypted data using PKCS7Padding?</p>

<p>I tried using a sample program on local and somehow it works and didn't give any error. Just want to ensure if we need any sort of Migration for all the existing records.</p>

<p>For all the existing records, Do I need to decrypt first using PKCS7Padding and then again encrypt using PKCS5Padding and store it back in the DB?</p>
","<p>You may check the following post <a href=""https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding"">https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding</a></p>

<p>PKCS5 and PKCS7 are effectively the same by algorithm, just PKCS5 is defined on 8 byte block (64 bit). Therefore cipher <code>AES/.../PKCS5Padding</code> is formally incorrect designation, effectively PKCS7 is used.</p>

<blockquote>
  <p>Do I need to decrypt first using PKCS7Padding and then again encrypt using PKCS5Padding and store it back in the DB?</p>
</blockquote>

<p>No, just to change the padding you don't need to do anything</p>
","66","<encryption><aes><bouncycastle><public-key-encryption><des>","1","2","1","2018-12-27 09:54:30","53943041","0","","","","","2018-12-27 08:21:50",""
"36675020","vb.net: DES decryption error while using memory stream","<p>This is my code for des decryption. I dont know why it showing error on CopyTo function.</p>

<pre><code>Private Function Unsecure(ByVal sInput As Byte(), ByVal sKey As String)
  'Define the service provider
  Dim DES As New DESCryptoServiceProvider()

  DES.Key() = ASCIIEncoding.ASCII.GetBytes(sKey)
  DES.IV = ASCIIEncoding.ASCII.GetBytes(sKey)

  'Define the crypto transformer
  Dim cryptoTransform As ICryptoTransform

  cryptoTransform = DES.CreateDecryptor 

  Dim ms As New MemoryStream(sInput)   
  Dim cryptostream As New CryptoStream(ms, cryptoTransform, CryptoStreamMode.Read)    
  Dim ms1 As New MemoryStream()

  cryptostream.CopyTo(ms1) '// &lt;- **Error: CopyTo is not a member of System.Security.Cryptography.Cryptostream**

  Return ms1.ToArray()
End Function
</code></pre>
","","64","<vb.net><des>","0","","0","2016-04-17 11:11:02","","3","","1981088","","2016-04-17 11:11:02","2016-04-17 09:53:14",""
"53977428","Problem by Encryption & Decryption of text with EVP_des_ofb(), openSSL , C","<p>I need to encrypt and decrypt txt-file with DES-ofb (libcrypto) using OpenSSL library, the key and Init Vector is given in one bin.file(key+iv). But after the decryption via EVP_DecryptUpdate(), decrypted text and plain text are not similar at all. </p>

<p><a href=""https://i.stack.imgur.com/nkq9A.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nkq9A.png"" alt=""Decryption Difficulties""></a></p>

<p>So I read plain.txt 8 bytes and a 'keyandIV.bin' files. Than I took first 8 bytes from keyandIVbuffer as a KEY for DES and the rest as IV. So I have 8 bytes key and 8 bytes IV, added '\0'  at the end of both (Do I need '\0' here ? Key length must be 64 or 56 bits?).</p>

<p>This is my code for ercryption with DES ofb:</p>

<pre><code>printf(""ENCRYPTION:\n"");
int howmany = 0, final1;
const EVP_CIPHER *CIPHER_TYPE = EVP_des_ofb();
EVP_CIPHER_CTX *ctx_encrypt = EVP_CIPHER_CTX_new();
EVP_CIPHER_CTX_init(ctx_encrypt);

EVP_EncryptInit(ctx_encrypt, CIPHER_TYPE, keybuf1, ivbuf1);
if(!EVP_EncryptUpdate(ctx_encrypt, ciphertextbuf1, &amp;howmany, plaintextbuf1, plainlength1))return -1;
if(!EVP_EncryptUpdate(ctx_encrypt, ciphertextbuf1, &amp;howmany, plaintextbuf1, plainlength1)) return -1;
EVP_EncryptFinal_ex(ctx_encrypt, ciphertextbuf1 + howmany , &amp;final1);
EVP_CIPHER_CTX_cleanup(ctx_encrypt);
</code></pre>

<p>Than I took the encrypted buffer und decrypt it so:</p>

<pre><code>printf(""DECRYPTION:\n"");
int final2;
EVP_CIPHER_CTX *ctx_decrypt = EVP_CIPHER_CTX_new();
EVP_CIPHER_CTX_init(ctx_decrypt);
EVP_DecryptInit(ctx_decrypt, CIPHER_TYPE, keybuf1, ivbuf1);
if(!EVP_DecryptUpdate(ctx_decrypt, decryptedtext, &amp;howmany, ciphertextbuf1, strlen(ciphertextbuf1))) return -1;
if(!EVP_EncryptFinal_ex(ctx_decrypt, decryptedtext + howmany, &amp;final2)) return -1;
EVP_CIPHER_CTX_cleanup(ctx_decrypt);
</code></pre>

<p>I definetly have understanding problem with DES. Maybe I did something wrong by creatimg key and IV from one file.I have seen plenty of examples but I still don't understand what I did wrong in my  program.</p>
","<p>The decryption sequence is <code>EVP_DecryptInit_ex()</code>, <code>EVP_DecryptUpdate()</code> and <code>EVP_DecryptFinal_ex()</code>. This follows <code>EVP_EncryptInit_ex()</code>, <code>EVP_EncryptUpdate()</code> and <code>EVP_EncryptFinal_ex()</code>. In your code you are calling <code>EVP_EncryptFinal_ex()</code> to decrypt, so obviously that's not going to work. Also, if something went wrong during an operation an error code should have been printed out to stderr.</p>
","64","<c><encryption><openssl><des><evp-cipher>","1","1","1","2018-12-31 04:17:43","53978317","0","","10848840","","2018-12-30 12:56:39","2018-12-30 12:04:36",""
"43371689","Include the trailing space in sprintf in MATLAB","<p>I'm trying to implement the <code>DES</code> cipher in Matlab.
In order to have the bits for the plain text and key, I'm doing this:<br></p>

<pre><code>binInput = hex2bin(sprintf('%x',input));
</code></pre>

<p>Where <code>hex2bin</code> is a function gave to us by the professor.<br>
This gives me the hex for the input, then the binary of it as <code>char</code> array.<br></p>

<p>I noted that when <code>input</code> has a trailing space, it is ignored, hence my algorithm stops to work because the block is not 64 bit long anymore (i get a <code>1x15</code> char vector instead of a <code>1x16</code> for example).<br><br>
How can I include this trailing space? I could not find anything online or in the <code>help</code> of <code>sprintf</code>.<br><br>
Thanks in advance</p>
","<p><code>sprintf</code> <em>does</em> respect all whitespace regardless of whether it's trailing, leading, or in-between.</p>

<pre><code>sprintf('%x', 'hello')
%   68656c6c6f

sprintf('%x', 'hello ')
%   68656c6c6f20
</code></pre>

<p>If you need your input length to be a multiple of 64-bits, you'll likely want to pad your data with null bytes</p>

<pre><code>str((end+1):(end+mod(numel(str), 8))) = '0';
</code></pre>

<p>If anything is getting truncated, it is likely an issue with the <code>hex2bin</code> function your professor gave you.</p>
","64","<matlab><des>","0","0","1","2017-04-12 14:24:02","","1","","","","","2017-04-12 13:58:29",""
"49196935","Encrypt data with DES ECB in Ruby","<p>I am implementing an encryption in a project that I has in another java project.</p>

<p>The code in java project is this: </p>

<pre><code>public static String cifraDES(String chave, String dado) throws Exception {
        DESKeySpec keySpec = new DESKeySpec(hexStringToByteArray(chave));
        SecretKeyFactory kf = SecretKeyFactory.getInstance(""DES"");
        SecretKey passwordKey = kf.generateSecret(keySpec);
        Cipher c = Cipher.getInstance(""DES"");
        c = Cipher.getInstance(""DES/ECB/NoPadding"");
        c.init(Cipher.ENCRYPT_MODE, passwordKey);
        return bytesToHex(c.doFinal(hexStringToByteArray(dado)));
}
</code></pre>

<p>In Ruby project i want implement this encrypt too. But this dont work: </p>

<pre><code>  dado = ""53495A45303030386E6F7661313031305858585858585858""
  chave = ""3455189635541968""
  des = OpenSSL::Cipher.new('des-ecb').encrypt
  des.key = chave
  s = des.update(dado) + des.final

  Base64.encode64(s).gsub(/\n/, """") 
</code></pre>

<p>In terminal I recive this message: </p>

<pre><code>'key' be must 8 bytes
</code></pre>

<p>And i need this return: <strong>b42e3dbfffd4bb5487a27fd702f079e287e6325767bfdd20</strong>    </p>

<p>View: 
<a href=""http://des.online-domain-tools.com/link/1145159gOjlrPNRkaT/"" rel=""nofollow noreferrer"">http://des.online-domain-tools.com/link/1145159gOjlrPNRkaT/</a></p>
","<p>The error seems pretty clear to me. The key you're using <code>chave</code> is 16 bytes.  Your key has to be 8 bytes.  So reduce the length of the key to 8 chars then try.</p>
","63","<ruby><encryption><des>","0","0","2","2018-03-09 15:45:01","49197340","0","0","","","","2018-03-09 15:22:11",""
"49196935","Encrypt data with DES ECB in Ruby","<p>I am implementing an encryption in a project that I has in another java project.</p>

<p>The code in java project is this: </p>

<pre><code>public static String cifraDES(String chave, String dado) throws Exception {
        DESKeySpec keySpec = new DESKeySpec(hexStringToByteArray(chave));
        SecretKeyFactory kf = SecretKeyFactory.getInstance(""DES"");
        SecretKey passwordKey = kf.generateSecret(keySpec);
        Cipher c = Cipher.getInstance(""DES"");
        c = Cipher.getInstance(""DES/ECB/NoPadding"");
        c.init(Cipher.ENCRYPT_MODE, passwordKey);
        return bytesToHex(c.doFinal(hexStringToByteArray(dado)));
}
</code></pre>

<p>In Ruby project i want implement this encrypt too. But this dont work: </p>

<pre><code>  dado = ""53495A45303030386E6F7661313031305858585858585858""
  chave = ""3455189635541968""
  des = OpenSSL::Cipher.new('des-ecb').encrypt
  des.key = chave
  s = des.update(dado) + des.final

  Base64.encode64(s).gsub(/\n/, """") 
</code></pre>

<p>In terminal I recive this message: </p>

<pre><code>'key' be must 8 bytes
</code></pre>

<p>And i need this return: <strong>b42e3dbfffd4bb5487a27fd702f079e287e6325767bfdd20</strong>    </p>

<p>View: 
<a href=""http://des.online-domain-tools.com/link/1145159gOjlrPNRkaT/"" rel=""nofollow noreferrer"">http://des.online-domain-tools.com/link/1145159gOjlrPNRkaT/</a></p>
","<p>You haven’t converted the key and data from hex strings, you can do that using <a href=""http://ruby-doc.org/core-2.5.0/Array.html#method-i-pack"" rel=""nofollow noreferrer""><code>pack</code></a>:</p>

<pre><code>dado = [""53495A45303030386E6F7661313031305858585858585858""].pack('H*')
</code></pre>

<p>(When you do this to the key, it is converted from 16 hexidecimal characters to 8 bytes, so not doing this step is causing the error are getting).</p>

<p>You haven’t specified no padding:</p>

<pre><code>des.padding = 0
</code></pre>

<p>And you want the result hex encoded, not base 64. You can use <a href=""http://ruby-doc.org/core-2.5.0/String.html#method-i-unpack"" rel=""nofollow noreferrer""><code>unpack</code></a>:</p>

<pre><code>puts s.unpack('H*')[0]
</code></pre>

<p>Putting it all together:</p>

<pre><code>dado = [""53495A45303030386E6F7661313031305858585858585858""].pack('H*')
chave = [""3455189635541968""].pack('H*')
des = OpenSSL::Cipher.new('des-ecb').encrypt
des.key = chave
des.padding = 0
s = des.update(dado) + des.final

puts s.unpack('H*')[0]
</code></pre>

<p>Result is <code>b42e3dbfffd4bb5487a27fd702f079e287e6325767bfdd20</code>.</p>
","63","<ruby><encryption><des>","0","1","2","2018-03-09 15:45:01","49197340","0","0","","","","2018-03-09 15:22:11",""
"49691275","Can't do equivalent of php DES decryption in Java","<p>I can't create equivalent of php DES decryption in Java, always different result.
Here php-code what i want replicate:</p>

<pre><code>$key = substr(sha1(""m"",true),0,8); //8-byte key
$iv = mcrypt_encrypt (MCRYPT_DES,$key,hex2bin(""0000000000000000""),MCRYPT_MODE_ECB); //get Iv
print(bin2hex($iv).""\n""); // ""b5872289d3c49605""
$plain_text = ""MZ4aXMCMO/TQAsZ2bYwagw=="";
$plain_text = base64_decode($plain_text);
$cipher_text = mcrypt_decrypt (MCRYPT_DES, $key, $plain_text, MCRYPT_MODE_CFB, $iv);
print(""\nThe ciphertext: "".$cipher_text);
print(""\nThe expected  : "".""489B4F2ADD728755"");
</code></pre>

<p>and my Java code:</p>

<pre><code>public static void desCipherDecrypt(String key, String encodedString) throws Exception {
    byte [] keyByte = Arrays.copyOf(DigestUtils.sha1(key),8);
    byte [] encodedByte = Base64.decodeBase64(encodedString);
    byte [] iv = DatatypeConverter.parseHexBinary(""B5872289D3C49605""); //same as Iv in php

    AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);
    Cipher desCipherDecrypt;

    desCipherDecrypt = Cipher.getInstance(""DES/CFB/NoPadding"");
    DESKeySpec dks = new DESKeySpec(keyByte);
    SecretKeyFactory skf = SecretKeyFactory.getInstance(""DES"");
    SecretKey desKey = skf.generateSecret(dks);
    desCipherDecrypt.init(Cipher.DECRYPT_MODE, desKey,paramSpec);
    byte[] cryptByte = desCipherDecrypt.doFinal(encodedByte);

    System.out.println(""resultBytes: ""+Arrays.toString(cryptByte)+""\n"");
    System.out.println(""resultHex: ""+DatatypeConverter.printHexBinary(cryptByte)+""\n"");
    System.out.println(""Decryption ended"");
  }
...
desCipherDecrypt(""m"", ""MZ4aXMCMO/TQAsZ2bYwagw==""); 
</code></pre>
","<p>So, it was a stupid mistake, for some reason I thought $cipher_text was encoded in Hex, but it was wrong, it's plain text, another reason was that mcrypt_decrypt for some reason doesn't uses standard block in a 64-bit, but 8-bit block.</p>

<p>after all answer will be,
    first, uses CFB8:</p>

<pre><code>desCipherDecrypt = Cipher.getInstance(""DES/CFB8/NoPadding"");
</code></pre>

<p>second read result byte like plain text </p>

<pre><code>yte[] cryptByte = desCipherDecrypt.doFinal(encodedByte);
    for (int i = 0; i &lt; cryptByte.length; i++ ){
                sResult += (char)(cryptByte[i]);
        }
</code></pre>
","61","<java><php><encryption><des>","-1","0","1","2018-04-06 14:37:02","","5","","8664578","","2018-04-06 11:09:47","2018-04-06 11:01:29",""
"42332060","Different number of replications in anylogic","<p>Can anyone knows how can we have for example 30 replications (different number of replications) in Anylogic (DES)?</p>
","<p>Search for ""replications"" in the help :-)
There is a property in your experiment settings (but you need to create a new non-simulation experiment first).</p>
","61","<des><anylogic>","0","0","1","2017-02-20 08:16:59","","0","","","","","2017-02-19 19:49:30",""
"56808655","C# DES vs Java DES Byte[] and BlockSize differs","<p>I am struggling to get the Java code to output the same Byte[] as the C# code.</p>

<h2>C# Code:</h2>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class Program
{
    private const string k = ""A2B3C4D1"";
    private const string kiv = ""1A2B3C4D"";

    public static void Main()
    {
        encrypt(""peanuts"");
    }

    public static void encrypt(string str)
    {
        try
        {
            using (var ms = new MemoryStream())
            using (var csp = new DESCryptoServiceProvider() { Key = Encoding.UTF8.GetBytes(k), IV =  Encoding.UTF8.GetBytes(kiv) })
            {
                Console.WriteLine(""Algorithm: DES?/"" + csp.Mode + ""/"" + csp.Padding);
                Console.WriteLine(""BlockSize: "" + csp.BlockSize);

                using (var cs = new CryptoStream(ms, csp.CreateEncryptor(), CryptoStreamMode.Write))
                using (var sw = new StreamWriter(cs))
                    sw.WriteLine(str);

                byte[] barray = ms.ToArray();

                Console.WriteLine(""barray length: "" + barray.Length);

                Console.WriteLine(""barray: "" + string.Join("" "", barray));
            }
        }
        catch (Exception ex) { Console.Write(ex.ToString()); }
    }
}
</code></pre>

<h2>Java Code:</h2>

<pre><code>import java.io.ByteArrayOutputStream;
import java.nio.charset.Charset;
import java.security.Security;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class MyClass {
    private static final String k = ""A2B3C4D1"";
    private static final String kiv = ""1A2B3C4D"";

    public static void main(String args[]) {
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

        encrypt(""peanuts"");
    }

    public static void encrypt(String str) {
        try {
            SecretKeySpec key = new SecretKeySpec(k.getBytes(Charset.forName(""UTF-8"")), ""DES"");
            IvParameterSpec iv = new IvParameterSpec(kiv.getBytes(Charset.forName(""UTF-8"")));
            Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS7Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            System.out.println(""Algorithm: "" + cipher.getAlgorithm());
            System.out.println(""BlockSize: "" + cipher.getBlockSize());

            ByteArrayOutputStream out = new ByteArrayOutputStream();
            CipherOutputStream cos = new CipherOutputStream(out, cipher);

            cos.write(str.getBytes());
            cos.close();

            byte[] barray = out.toByteArray();

            System.out.println(""barray length: "" + barray.length);

            System.out.print(""barray: "");
            for(byte b : barray){
                System.out.print("" "" + b);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre>

<p><strong>C# Output</strong></p>

<blockquote>
  <p>Algorithm: DES?/CBC/PKCS7</p>
  
  <p>BlockSize: 64</p>
  
  <p>barray length: 16</p>
  
  <p>barray: 107 125 91 205 77 206 98 120 214 194 64 167 128 97 132 75</p>
  
  <p>base64: a31bzU3OYnjWwkCngGGESw==</p>
</blockquote>

<p><strong>Java Output</strong></p>

<blockquote>
  <p>Algorithm: DES/CBC/PKCS7Padding</p>
  
  <p>BlockSize: 8</p>
  
  <p>barray length: 8</p>
  
  <p>barray: 45 100 -86 103 9 -7 -19 -76</p>
  
  <p>base64: LWSqZwn57bQ=</p>
</blockquote>

<p>I am trying to get exactly the same <code>Byte[]</code> output from the Java code as I'm already getting from the <code>C#</code>. But the only difference I manage to see is the block size differs from both.</p>

<h1><a href=""https://dotnetfiddle.net/5a9h6V"" rel=""nofollow noreferrer"">C# Dot.Net Fiddle</a></h1>

<h1><a href=""http://www.jdoodle.com/a/1jKf"" rel=""nofollow noreferrer"">Java jDoodle.com</a></h1>

<p>I just don't get it, is there something which I am missing or don't understand?</p>

<h1>EDIT</h1>

<p>I have added code to print out the byte array in string, it differs:</p>

<p>C# </p>

<pre><code>barray length: 16
barray: 107 125 91 205 77 206 98 120 214 194 64 167 128 97 132 75
base64: a31bzU3OYnjWwkCngGGESw==
</code></pre>

<p>Java </p>

<pre><code>barray length: 8
barray: 45 100 -86 103 9 -7 -19 -76
base64: LWSqZwn57bQ=
</code></pre>
","<p>@JamesKPolk is correct: You're encrypting <code>{ (byte)'p', (byte)'e', (byte)'a', (byte)'n', (byte)'u', (byte)'t', (byte)'s', (byte)'\r', (byte)'\n' }</code> in C#, and <code>{ (byte)'p', (byte)'e', (byte)'a', (byte)'n', (byte)'u', (byte)'t', (byte)'s' }</code> in Java.</p>

<p>Since ""peanuts"" is (in UTF-8) 7 bytes, it can be PKCS7 padded into one DES block. The next 1-8 bytes results in a second block... and you added two.</p>

<p>Changing the code in the Dot.Net Fiddle to <code>Write</code> instead of <code>WriteLine</code> produces</p>

<pre><code>Algorithm: DES?/CBC/PKCS7
BlockSize: 64
barray length: 8
barray: 45 100 170 103 9 249 237 180
barray: LWSqZwn57bQ=
</code></pre>

<p>where now the only difference is that C# BlockSize is bits, and your Java code has it as bytes.</p>

<p>Change <code>""peanuts""</code> to <code>""peanuts\r\n""</code> in your JDoodle and you get</p>

<pre><code>Algorithm: DES/CBC/PKCS7Padding
BlockSize: 8
barray length: 16
barray:  107 125 91 -51 77 -50 98 120 -42 -62 64 -89 -128 97 -124 75
barray: a31bzU3OYnjWwkCngGGESw==
</code></pre>

<p>Which is the same, if the <code>barray</code> decimal contents had been printed as unsigned values instead of signed values (add 256 to all the negative numbers) -- a fact easily visible in the Base64 being the same.</p>
","60","<java><c#><encryption><des>","1","2","1","2019-06-28 15:44:50","56809771","5","","1876355","","2019-06-28 15:30:04","2019-06-28 14:21:50",""
"56789185","Decryption does not work on Production(Red Hat Enterprise Linux 7) and works on UAT(SUSE based linux distro)","<p>I'm using  DES  for encryption/decryption as its not recommended but its an old code so i could'nt move to AES, now my code working fine on local environment(i.e mac ) with production db, also its working fine on UAT which is SUSE based linux distro but decryption not working on Production which is redhat based enironment. on Production it throws ""Input length (with padding) not multiple of 8 bytes"" Illegal Block size exception</p>

<pre><code>@Service
public class EncryptionUtil {

    private static final Logger log = LogManager.getLogger(EncryptionUtil.class);
    @Autowired
    GpsCacheManager gpsCacheManager;
    private Cipher ecipher;
    private Cipher dcipher;
    @Autowired
    private StringUtils stringUtils;

    public EncryptionUtil() throws Exception {
        ecipher = Cipher.getInstance(""DES"");
        dcipher = Cipher.getInstance(""DES"");
        initCipher();
    }


    private void initCipher() {
        try {
            String response = “[-3232, -34, -98, 111, -222, 33, -22, 55]”;
            String[] byteValues = response.substring(1, response.length() - 1).split("","");
            byte[] bytes = new byte[byteValues.length];
            for (int i = 0, len = bytes.length; i &lt; len; i++) {
                bytes[i] = Byte.parseByte(byteValues[i].trim());
            }

            SecretKey key = new SecretKeySpec(bytes, ""DES"");
            ecipher.init(Cipher.ENCRYPT_MODE, key);
            dcipher.init(Cipher.DECRYPT_MODE, key);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
        }
    }


    public String encryptUTF8(String str) throws Exception {
        // Encode the string into bytes using utf-8
        byte[] utf8 = str.getBytes(""UTF8"");

        // Encrypt
        byte[] enc = ecipher.doFinal(utf8);
        // Encode bytes to base64 to get a string
        return new String(Base64.encodeBase64(enc));
    }

    public String decryptUTF8(String str) throws Exception {

        if (stringUtils == null) {
            stringUtils = new StringUtils();
        }
        //do not decrypt if a valid email.
        if (stringUtils.isValidEmail(str)) {
            return str;
        }
        // Decode base64 to get bytes
        byte[] dec = Base64.decodeBase64(str.getBytes());

        byte[] utf8 = null;
        try {
            utf8 = dcipher.doFinal(dec);
        } catch (IllegalBlockSizeException e) {
            return str;
        }
        // Decode using utf-8
        return new String(utf8, ""UTF8"");
    }
}
</code></pre>
","<p>There is an issue with <code>String.getBytes()</code> and <code>new String(byte[])</code> which are platform dependent and should not be used here. At the same time I replaced that Base64 class with the standard java's <a href=""https://docs.oracle.com/javase/9/docs/api/java/util/Base64.html"" rel=""nofollow noreferrer"">Base64</a>, that was intended to replace several Base64 implementations some ten years ago.</p>

<pre><code>public String encryptUTF8(String str) throws Exception {
    // Encode the string into bytes using utf-8
    byte[] utf8 = str.getBytes(StandardCharsets.UTF_8);

    // Encrypt
    byte[] enc = ecipher.doFinal(utf8);
    // Encode bytes to base64 to get a string
    return Base64.getEncoder().encodeToString(enc));
    //Old class: return new String(Base64.encodeBase64(enc), StandardCharsets.US_ASCII);
}

public String decryptUTF8(String str) throws Exception {

     if (stringUtils == null) {
            stringUtils = new StringUtils();
     }
     //do not decrypt if a valid email.
     if (stringUtils.isValidEmail(str)) {
        return str;
     }
     // Decode base64 to get bytes
     //byte[] dec = Base64.getDecoder().decode(str.getBytes(StandardCharsets.US_ASCII));    
     byte[] dec = Base64.getDecoder().decode(str);    
     try {
         byte[] utf8 = dcipher.doFinal(dec);
         // Decode using utf-8
         return new String(utf8, StandardCharsets.UTF_8);
     } catch (IllegalBlockSizeException e) {
         return str;
     }
}
</code></pre>

<p>There is one problem: <code>String</code> is for Unicode text, with two-byte <code>char</code>s (UTF-16).
This means any <code>byte[]</code> value must be text in some encoding, and with that encoding converted to a String. Any arbitrary <code>byte[]</code> value will not be a valid String. Especially on Linux with the preeminent UTF-8 encoding that will corrupt data.</p>

<p>The problem probably resides in <code>decryptUTF8</code>. If in the original code the default encoding is a single byte encoding, everything is swallowed as-is. For Linux, UTF-8, erroneous UTF-8 multi-byte sequences might be encountered. <em>Or the encoding is a 7-bits ASCII.</em></p>

<p>In general keep <code>String</code> and <code>byte[]</code> apart; use <code>byte[]</code> for non-text binary data.</p>
","57","<java><linux><encryption><redhat><des>","-1","1","1","2019-06-28 07:24:29","","9","","4162905","","2019-06-28 05:55:19","2019-06-27 10:36:54",""
"47885180","Creating an RC4 / DES SSL PFX","<p>I'm trying to check a specific IIS configuration, which should reject weak SSL certificates. </p>

<p>How would I go about creating an SSL certificate with either RC4 or DES encryption? </p>

<p>I've tried using openssl with the -des flag, but it seems to still create a sha256 cert.</p>
","<p>The choice of the symmetric cipher used in TLS (i.e. RC4, DES, AES...) does not depend on the certificate. This means that any certificate you'll create can be used together with RC4, DES, ... . Instead of trying to enforce a strong cipher using the certificate you have to do this in the server configuration. See <a href=""https://wiki.mozilla.org/Security/Server_Side_TLS"" rel=""nofollow noreferrer"">Mozilla: Security/Server Side TLS</a> for examples on how to configure common web servers with strong ciphers.</p>
","57","<ssl><openssl><des><rc4-cipher><weak>","0","1","1","2017-12-19 12:54:33","47887537","0","","","","","2017-12-19 10:44:54",""
"57530671","Convert OpenSSL encryption into native C#","<p>I have a legacy application which uses OpenSSL to encrypt a string using <code>DES3</code>.</p>

<p>These are the parameters that are set for OpenSSL:</p>

<pre><code>OpenSSL enc -des3 -nosalt -a -A -iv 1234567890123456 -K 1234567890123456...48
</code></pre>

<p>The key is a <strong>string</strong> of <strong>48 digits</strong> and the iv is a substring of the first <strong>16 digits</strong> of this key.</p>

<p>Now, I am trying to replicate this functionality with C#'s <code>System.Cryptography</code> library and without the use of OpenSSL if possible.</p>

<p>My goal is not to have to use OpenSSL and have the encryption done in native C# code.</p>

<p>Here is what I have got so far:</p>

<pre><code>public string Encrypt(string toEncrypt, bool useHashing)
{
    var _key = ""48...digits..."";
    byte[] keyArray;
    var toEncryptArray = Encoding.UTF8.GetBytes(toEncrypt);

    if (useHashing)
    {
        var hashmd5 = new MD5CryptoServiceProvider();
        keyArray = hashmd5.ComputeHash(Encoding.UTF8.GetBytes(_key));

        hashmd5.Clear();
    }
    else
    {
        keyArray = Encoding.UTF8.GetBytes(_key);
    }

    var tdes = new TripleDESCryptoServiceProvider();

    tdes.Key = keyArray;

    // Is this even the correct cipher mode?
    tdes.Mode = CipherMode.CBC;

    // Should the PaddingMode be None?
    tdes.Padding = PaddingMode.PKCS7;

    // THIS is the line where I am currently stuck on:
    tdes.IV = Encoding.UTF8.GetBytes(_key.Substring(0, 16));

    var cTransform = tdes.CreateEncryptor();

    var resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

    return Convert.ToBase64String(resultArray, 0, resultArray.Length);
}
</code></pre>

<p>As written as comments in the code, I am not quite sure if I am using the correct cipher, maybe even the padding mode is incorrect and my iv has a length of <code>16 bytes</code> but only <code>8 bytes</code> are expected.</p>

<p>Also, I did try my luck already with or without hashing the key/iv.</p>

<p>Is it even possible to convert the above mentioned OpenSSL logic into plain C#? </p>
","<p>Key and IV must be specified for <a href=""https://www.openssl.org/docs/man1.0.2/man1/enc.html"" rel=""nofollow noreferrer""><code>openssl enc</code></a> with <code>-K</code> and <code>-iv</code> as <em>hexadecimal</em> values. This is missing in the C# code, so that essentially the following expressions</p>

<pre><code>tdes.Key = Encoding.UTF8.GetBytes(_key);
tdes.IV = Encoding.UTF8.GetBytes(_key.Substring(0, 16));
</code></pre>

<p>would have to be replaced by</p>

<pre><code>tdes.Key = StringToByteArray(_key);
tdes.IV = StringToByteArray(_key.Substring(0, 16));
</code></pre>

<p>to produce the same ciphertext for <code>useHashing == false</code>. Here <code>StringToByteArray</code> is a method that converts a hexadecimal string into the corresponding byte array, e.g. <a href=""https://stackoverflow.com/a/321404/9014097"">here</a>.</p>

<p>It should also be noted that .NET does not accept keys that are too <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.tripledes.isweakkey?view=netcore-3.0#remarks"" rel=""nofollow noreferrer"">weak</a>, e.g.:</p>

<pre><code>123456789012345612345678901234561234567890123456
</code></pre>

<p>In case of such a key a <code>CryptographicException</code> is thrown (<em>Specified key is a known weak key for 'TripleDES' and cannot be used</em>). OpenSSL accepts this key.</p>

<p>Regarding security:</p>

<ul>
<li>MD5 shouldn't be used nowadays to generate a key, more <a href=""https://crypto.stackexchange.com/a/62833"">here</a>.</li>
<li>In addition, MD5 generates a 16 byte hash. Thus, always keying option 2 is used, which is weaker than keying option 1 (<a href=""https://en.wikipedia.org/wiki/Triple_DES#Keying_options"" rel=""nofollow noreferrer"">Keying options</a>). </li>
<li>Generally it's insecure to use the key as IV, more <a href=""https://crypto.stackexchange.com/a/16162"">here</a>.</li>
<li>TripleDES is slow compared to today's standard AES, more <a href=""https://security.stackexchange.com/a/26181"">here</a>.</li>
</ul>
","57","<c#><openssl><des>","1","2","1","2019-08-17 12:24:31","57535098","0","","1405376","","2019-08-16 20:57:53","2019-08-16 20:20:51",""
"34103221","Websockets Javascript DES code issue","<p>Following is the excerpt from noVNC code,</p>

<pre><code>            if (this._sock.rQwait(""auth challenge"", 16)) { return false; }

        // TODO(directxman12): make genDES not require an Array
        var challenge = Array.prototype.slice.call(this._sock.rQshiftBytes(16));
            Util.Warn(""Challenge "" + challenge);
        var response = RFB.genDES(this._rfb_password, challenge);
            Util.Warn(""Response "" + response);
        this._sock.send(response);
            Util.Warn(""Response "" + response);
        this._updateState(""SecurityResult"");
        return true;
</code></pre>

<p>My understanding is that the client is asking sever to send challenge with code</p>

<pre><code>this._sock.rQwait(""auth challenge"", 16)
</code></pre>

<p>Then server is sending a challenge which is being received by client in code</p>

<pre><code>this._sock.rQshiftBytes(16)
</code></pre>

<p>Then the Password is DES encrypted using RFB.genDES and response ise sent over socket.</p>

<p>However on server side, which is a XVP proxy program, the code looks like</p>

<pre><code>unsigned int major, minor, type, res, challenge[4], response[16];
</code></pre>

<p>...</p>

<pre><code>        case XVP_STATE_CHALLENGE_AUTH:
        srandom((unsigned int)(time(NULL) ^ 0xdf214a30));
        for (i = 0; i &lt; 4; i++) {
            challenge[i] = (random() ^ 0x51a488ce);
        }
        if (!xvp_write_all(client_sock, challenge, sizeof(challenge)))
            return 1;
        xvp_proxy_state = XVP_STATE_RESPONSE_AUTH;
        xvp_proxy_writing = false;
        break;
    case XVP_STATE_RESPONSE_AUTH:
        if (!xvp_read_all(client_sock, response, 16))
            return 1;
        authok = (vm == xvp_multiplex_vm || wrongvm) ? false :
            xvp_password_vnc_ok(vm-&gt;password, client_ip,
                                (char *)challenge, (char *)response);
        xvp_proxy_state = XVP_STATE_CONFIRM_AUTH;
        xvp_proxy_writing = true;
        break;
</code></pre>

<p>The challenge array is only 4 byte and is being sent as it is using code</p>

<pre><code>!xvp_write_all(client_sock, challenge, sizeof(challenge))
</code></pre>

<p>However my javascript log from following code shows array of 16 numbers.</p>

<pre><code>Util.Warn(""Challenge "" + challenge);
</code></pre>

<p>e.g. Challenge 100,139,246,69,3,120,162,81,179,57,13,48,56,106,4,19</p>

<p>My question is whether java script is really reading 16 bytes from socket using this._sock.rQshiftBytes(16) and server is sending only 4 bytes on same socket ?</p>
","","54","<javascript><c><websocket><des>","2","","0","2015-12-05 09:17:16","","0","","","","","2015-12-05 09:17:16",""
"42402693","increasing fraction digits in the result Anylogic","<p>Can anyone knows how can we increase the decimal places of the results that Anylogic is giving us? Any help would be appreciated.</p>
","<p>Access the actual object to get the high-precision value. </p>

<p>If you want to see the full numbers at runtime, you can use a ""Text"" object from the Presentation library and change its dynamic text (see the help) to <code>AQLPatient1a.getMean()</code> or <code>probExc1A</code></p>

<p>Move the text object near those objects to see the difference at runtime. </p>

<p>You could even hide the variables and statistics objects and only display relevant text objects. Set ""visible"" to false in the object properties.</p>
","54","<des><anylogic>","0","0","1","2017-02-24 17:57:29","","5","","","","","2017-02-22 21:33:08",""
"40258914","VB Unable to retrieve string after 3DES encryption","<p>Initial conditions:</p>

<pre><code>Private TheKey() As Byte = {1, 2, 3, 4, 5, 6, 7, 8}
Private Vector() As Byte = {&amp;H7C, &amp;H22, &amp;H2F, &amp;HB2, &amp;H92, &amp;H7D, &amp;H82, &amp;H8A}
</code></pre>

<p>I then proceed to encrypt the string: ""asd"" (without quotations) using:</p>

<pre><code>CryptoStream(ms, des.CreateEncryptor(TheKey, Vector), CryptoStreamMode.Write)
</code></pre>

<p><strong>input: asd<br>
output: 82804AD2B295E9E3</strong></p>

<p>When i try to encrypt the same string with the same key/vector on <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow"">http://tripledes.online-domain-tools.com/</a> as shown below (can't post image due to reputation):</p>

<p><a href=""https://i.stack.imgur.com/hIB4r.png"" rel=""nofollow"">online 3DES encryption</a></p>

<p>I get a different result.</p>

<p>My ultimate goal is to have this output decrypted in a C application. But two 3DES encryptors giving 2 different results is a show stopper.. Any thoughts about what could be causing this ?</p>

<p>Thanks in advance!</p>
","<p>A good idea to test your crypto against some other ""oracle"". But two issues apparent with your use of the online tool:</p>

<ul>
<li>the key should be given as hex not text (the VB code has a byte array). Presumably 0102030405060708</li>
<li>3DES is the algorithm, but the VB code uses classic DES - there's a separate TripleDESCryptoServiceProvider for 3DES</li>
</ul>

<p>However that site gives me the same encrypted text for both DES and 3DES, so it may not be a reliable oracle anyway? Try another, but may need to use a plain text key (first two I looked at didn't offer hex input in any obvious way)</p>
","54","<c><vb.net><encryption><des><3des>","-1","0","1","2016-10-26 10:40:38","40260085","2","","","","","2016-10-26 09:46:52",""
"58645977","Encrypting and decrypting strings in Python, to match old VB.NET code","<p>For quite a few years I've been running a VB.Net application, which used functions for encrypting and decrypting strings. These functions are gratefully taken from a WordPress blog which is now no longer available.</p>

<p>The problem now is that I am making a new Python-based version of the application, but we have databases full of strings that have been encrypted using the old VB.NET version, that I will need to be able to decrypt. So I need Python functions that will decrypt and encrypt to give <em>exactly</em> the same results!</p>

<p>In the old code, sending <code>strText = ""Secret message.""</code> and <code>strEncrKey = ""Terribly""</code> to <code>encryptString()</code> would result in this encrypted, database-friendly string: <code>dqCMClFoMs3B9AjoFGs+cQ==</code> </p>

<p>(This process could then be reversed with <code>decryptString()</code>)</p>

<p>I'm still new to Python and a complete novice on anything to do with encryption or byte conversion, so I don't know how to replicate the equivalent of the 'createEncryptor' function from the VB.NET code.</p>

<p>Here's my Python code as it stands. It uses pyDes (<code>import pydes</code>) at the top of the code:</p>

<pre><code>    defaultKey = ""Terribly""
    charset = ""utf-8""
    data = pyDes.des(defaultKey)
    print(""pyDes initialised."")
    text_to_encode = ""Secret message.""
    encrypted = data.encrypt(text_to_encode.encode(charset))
    print(""encrypted:"", repr(encrypted))
    decrypted = data.decrypt(encrypted).decode(charset)
    print(""decrypted:"", repr(decrypted))
</code></pre>

<p>but this code fails to run.</p>

<p>So my question is two-fold:</p>

<ol>
<li><p>Why is my Python installation bombing out with an <code>exit code -1073740791</code> error on the <code>data.encrypt</code> line? Am I messing up the syntax?</p></li>
<li><p>Is it possible to completely replicate the previous encryption and decryption, with matching results each time, and if so, how do I do it?</p></li>
</ol>

<p>The old VB.NET code, unchanged for a long time, is as follows:</p>

<pre class=""lang-vb prettyprint-override""><code>Public Function stringEncrypt(ByVal strText As String, ByVal strEncrKey As String) As String
        ' from http://ntcnet.wordpress.com/2007/11/27/encryptdecrypt-string-vbnet/
        If strText.Length = 0 Then Return """"
        Dim IV() As Byte = {&amp;H12, &amp;H34, &amp;H56, &amp;H78, &amp;H90, &amp;HAB, &amp;HCD, &amp;HEF}
        Try
            Dim bykey() As Byte = System.Text.Encoding.UTF8.GetBytes(Left(strEncrKey, 8))
            Dim InputByteArray() As Byte = System.Text.Encoding.UTF8.GetBytes(strText)
            Dim des As New DESCryptoServiceProvider
            Dim ms As New MemoryStream
            Dim cs As New CryptoStream(ms, des.CreateEncryptor(bykey, IV), CryptoStreamMode.Write)
            cs.Write(InputByteArray, 0, InputByteArray.Length)
            cs.FlushFinalBlock()
            Return Convert.ToBase64String(ms.ToArray())
        Catch ex As Exception
            Return ex.Message
        End Try
    End Function

    Public Function stringDecrypt(ByVal strText As String, ByVal sDecrKey As String) As String
        ' from http://ntcnet.wordpress.com/2007/11/27/encryptdecrypt-string-vbnet/
        If strText.Length = 0 Then Return """"
        Dim IV() As Byte = {&amp;H12, &amp;H34, &amp;H56, &amp;H78, &amp;H90, &amp;HAB, &amp;HCD, &amp;HEF}
        Dim inputByteArray(strText.Length) As Byte
        Try
            Dim byKey() As Byte = System.Text.Encoding.UTF8.GetBytes(Left(sDecrKey, 8))
            Dim des As New DESCryptoServiceProvider
            inputByteArray = Convert.FromBase64String(strText)
            Dim ms As New MemoryStream
            Dim cs As New CryptoStream(ms, des.CreateDecryptor(byKey, IV), CryptoStreamMode.Write)
            cs.Write(inputByteArray, 0, inputByteArray.Length)
            cs.FlushFinalBlock()
            Dim encoding As System.Text.Encoding = System.Text.Encoding.UTF8
            Return encoding.GetString(ms.ToArray())
        Catch ex As Exception
            Return ex.Message
        End Try
    End Function
</code></pre>
","","52","<python><vb.net><encryption><des>","0","","0","2019-10-31 19:49:59","","4","","8367626","","2019-10-31 19:49:59","2019-10-31 14:51:22",""
"58635098","PHP openssl_decrypt doesn't get same results as online tools","<p>Using an online encrypt/decrypt tool, using DES-ECB, I can encrypt an 8 digit hexadecimal number using an 8 digit hexadecimal key, resulting in an 8 digit hex result. I can decrypt that 8 digit result by the same key and get the original data I encrypted.</p>

<p>However, I cannot reproduce this locally using PHP. The encrypted result I get online, it turns out, is the first 8 of 16 digits actually produced. No problem... But when I try to decrypt locally using PHP, I need all 16 digits in order to get the original data.</p>

<p>How can I decrypt with only the 8 digits and still get the original data, like the online tool does?</p>

<p>Online results:</p>

<p>Encrypting:</p>

<pre><code>$data = '03 67 A6 7F C2 00 0A DB';
$key = '00 F2 83 CD BA 41 6F FF';
$result = '8b be 0f 3b ae 92 56 07';
</code></pre>

<p>Verify: <a href=""http://des.online-domain-tools.com/link/1b40d6agZYE0TFR5sM/"" rel=""nofollow noreferrer"">http://des.online-domain-tools.com/link/1b40d6agZYE0TFR5sM/</a></p>

<p>Decrypting:</p>

<pre><code>$data = '8b be 0f 3b ae 92 56 07';
$key = '00 F2 83 CD BA 41 6F FF';
$result = '03 67 A6 7F C2 00 0A DB';
</code></pre>

<p>Verify: <a href=""http://des.online-domain-tools.com/link/1b40e05gD5TNgMb72h/"" rel=""nofollow noreferrer"">http://des.online-domain-tools.com/link/1b40e05gD5TNgMb72h/</a></p>

<p>Local PHP test:</p>

<pre><code>$enc = openssl_encrypt( hex2bin('0367A67FC2000ADB'), 'DES-ECB', hex2bin('00F283CDBA416FFF'), 1);
</code></pre>

<p><code>bin2hex($enc)</code> results in <code>8bbe0f3bae9256071da486ee680f8449</code></p>

<p>If I decrypt only the first 8 hex digits, I don't get the same results I do with the online tool:</p>

<pre><code>$dec = openssl_decrypt( hex2bin('8bbe0f3bae925607'), 'DES-ECB', hex2bin('00F283CDBA416FFF'), 1);
</code></pre>

<p><code>bin2hex($dec)</code> results in null (or false if we do not convert to hex)</p>

<p>But if I enter the full 16 digit hex as the encrypted data, I get the correct result:</p>

<pre><code>$dec = openssl_decrypt( hex2bin('8bbe0f3bae9256071da486ee680f8449'), 'DES-ECB', hex2bin('00F283CDBA416FFF'), 1);
</code></pre>

<p><code>bin2hex($dec)</code> results in <code>0367A67FC2000ADB</code></p>

<p>This makes sense to me... but I need to be able to get this result from only the 8 digit hex, just like the online tool does. What do I need to do to make this possible?</p>
","<p>The reason for the difference is the <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)"" rel=""nofollow noreferrer"">padding</a>. A block cipher only allows the encryption of data whose length corresponds to an integer multiple of the blocksize (8 bytes in the case of DES). Padding ensures that this condition is met by adding data according to a specific logic.</p>

<p>There are different types of padding. <a href=""https://www.php.net/manual/en/function.openssl-encrypt.php"" rel=""nofollow noreferrer""><code>openssl_encrypt</code></a>/<a href=""https://www.php.net/manual/en/function.openssl-decrypt.php"" rel=""nofollow noreferrer""><code>openssl_decrypt</code></a> uses <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7"" rel=""nofollow noreferrer"">PKCS7-padding</a> by <a href=""https://www.php.net/manual/en/function.openssl-encrypt.php#117208"" rel=""nofollow noreferrer"">default</a>, the <a href=""http://des.online-domain-tools.com/"" rel=""nofollow noreferrer"">online-tool</a> <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding"" rel=""nofollow noreferrer"">Zero-padding</a>. </p>

<p>PKCS7-padding will always add data to the plaintext, even if the plaintext already has a length that is an integer multiple of the blocksize. In this case, a complete block is added (<a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7"" rel=""nofollow noreferrer"">details</a>). For this reason, the posted ciphertext generated with <code>openssl_encrypt</code> has a length of 2 blocks (16 bytes) for a plaintext with a length of 1 block (8 bytes).</p>

<p>Unlike PKCS7-padding, the Zero-padding variant used by the online-tool doesn't add any data if the plaintext already has a length that is a multiple of the blocksize.  For this reason, the posted ciphertext generated with the online-tool has a length of 1 block (8 bytes) for a plaintext with a length of 1 block (8 bytes).</p>

<p><code>openssl_encrypt</code>/<code>openssl_decrypt</code> doesn't support Zero-padding. For the ciphertext of <code>openssl_encrypt</code> to match that of the online-tool, the PKCS7-padding must be disabled and the Zero-padding variant used by the online-tool must be implemented <em>manually</em>. The disabling of the padding is done with the flag <code>OPENSSL_ZERO_PADDING</code>, which must be set with the fourth parameter. <em>Note</em>: The name of the flag is misleading: This flag doesn't enable Zero-padding, but only disables PKCS7-padding. This means that the Zero-padding variant of the online-tool still has to be implemented manually. Furthermore: In the current code, the value <code>1</code> is passed in the fourth parameter, which corresponds to the flag <code>OPENSSL_RAW_DATA</code>. To set both flags, the value <code>1</code> must therefore be replaced by <code>OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING</code>.</p>

<p>For plaintexts whose length already corresponds to an integer multiple of the blocksize, both a disabled PKCS7-padding and the Zero-padding variant used by the online-tool don't add any additional data, so that the ciphertexts match. In this case, a manual implementation of the Zero-padding variant used by the online-tool isn't necessary.</p>

<p>A final note on security: <a href=""https://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow noreferrer"">DES</a> is insecure. Today's standard is <a href=""https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a>. ECB is also insecure. More secure <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">modes</a> are e.g. CBC or GCM.</p>
","51","<php><encryption><openssl><des><ecb>","1","1","1","2019-10-31 19:18:49","58648819","5","","1491895","","2019-10-31 00:27:07","2019-10-30 23:44:52",""
"47383754","Decrypt DES accepts some keys variation of the real key","<p>I am using DES method. When I try to decrypt, it accepts variation of the real key.</p>

<p>For example:</p>

<pre><code>Real key: abcdefgh
Key 1: accefgh
key 2: abcdefgi
</code></pre>

<p>Those keys( key 1 and key2) are accepted when I decrypt, even though those ones are not the real key that I used to encrypt. What I have figured out is that those variations are accepted.</p>

<p>Look at the picture below:
<a href=""https://i.stack.imgur.com/qkMbE.png"" rel=""nofollow noreferrer"">enter image description here</a></p>

<p>Why does the method DES accept these variation of the key that I used to encrypt?</p>
","<p>DES takes a 64 bit key but only actually uses 56 bits. The remaining 8 bits are discarded or used for parity checking.</p>
","48","<java><des>","-7","0","2","2017-11-20 01:57:39","","6","","4953776","","2017-11-20 01:57:39","2017-11-20 01:04:15","2017-11-20 03:11:45"
"47383754","Decrypt DES accepts some keys variation of the real key","<p>I am using DES method. When I try to decrypt, it accepts variation of the real key.</p>

<p>For example:</p>

<pre><code>Real key: abcdefgh
Key 1: accefgh
key 2: abcdefgi
</code></pre>

<p>Those keys( key 1 and key2) are accepted when I decrypt, even though those ones are not the real key that I used to encrypt. What I have figured out is that those variations are accepted.</p>

<p>Look at the picture below:
<a href=""https://i.stack.imgur.com/qkMbE.png"" rel=""nofollow noreferrer"">enter image description here</a></p>

<p>Why does the method DES accept these variation of the key that I used to encrypt?</p>
","<p>The least significant bit of each byte in a DES key is a 'parity' bit that doesn't really influence the cipher.</p>

<p>It's a little hard to say from your example whether this is what you're seeing, but the ASCII values of the characters 'B' and 'C' differ only in the LSb.  Same for 'D' and 'E', 'F' and 'G', etc.  Only 'Z'/'A' breaks the pattern.</p>
","48","<java><des>","-7","1","2","2017-11-20 01:57:39","","6","","4953776","","2017-11-20 01:57:39","2017-11-20 01:04:15","2017-11-20 03:11:45"
"55872167","convert byte like this : (b'\xe4\x06-\x95\xf5!P4' ) to a binary string of zeros and ones in python","<p>well ,i have an assignment to implement the operation modes of the DES algorithm 
in CBC mode : i am stuck at the point where the output of the encryption function gives bytes like this : b'\xe4\x06-\x95\xf5!P4' 
(i am using DES library from Crypto.Cipher)</p>

<p>i don't know what is that representation or how to convert it to a binary string of zeros and ones , to xor it with the 2nd plain text.</p>

<p>any help would be highly appreciated</p>

<pre><code>iv = random_iv()


des = DES.new(key)

plaintext1=""""
#convert it into binary
plaintext1=bin(int.from_bytes(arr[0].encode(), 'big'))[2:]

y = fn.xor(plaintext1 ,iv)
y1='0'+'b'+y

y= int(y1, 2)
#y is the string output of xoring plaintext1 with the IV 
y= y.to_bytes((y.bit_length() + 7) // 8, 'big').decode()   

encrypted_blocks=[]

# arr is the array of the original blocks of the msg.
for i in range (1, len(arr)):
    c = des.encrypt(y)
    print(c)
    encrypted_blocks.append(c)
    ### stuck here ### 
    #### don't know how to work with c in that format ######
</code></pre>
","<p>hello @nehal you can convert your bytes into binary by the following method</p>

<pre class=""lang-py prettyprint-override""><code># let b is your bytes
b = b'\xe4\x06-\x95\xf5!P4'

# first convert it to hex
bHex = b.hex()

# convert it to integet
bInt = int(bHex, 16)

# finaly convert it to binary
bBin = ""{:08b}"".format(bInt)

print(bBin) #1110010000000110001011011001010111110101001000010101000000110100
</code></pre>

<p>OR SIMPLY</p>

<pre><code>b = b'\xe4\x06-\x95\xf5!P4'
bBin = ""{:08b}"".format( int( b.hex(), 16 ) )
print(bBin) #1110010000000110001011011001010111110101001000010101000000110100
</code></pre>
","48","<python><unicode><undefined><des><python-cryptography>","-4","0","2","2019-04-27 20:25:12","55872568","0","","235698","","2019-04-27 20:20:48","2019-04-26 17:08:05",""
"55872167","convert byte like this : (b'\xe4\x06-\x95\xf5!P4' ) to a binary string of zeros and ones in python","<p>well ,i have an assignment to implement the operation modes of the DES algorithm 
in CBC mode : i am stuck at the point where the output of the encryption function gives bytes like this : b'\xe4\x06-\x95\xf5!P4' 
(i am using DES library from Crypto.Cipher)</p>

<p>i don't know what is that representation or how to convert it to a binary string of zeros and ones , to xor it with the 2nd plain text.</p>

<p>any help would be highly appreciated</p>

<pre><code>iv = random_iv()


des = DES.new(key)

plaintext1=""""
#convert it into binary
plaintext1=bin(int.from_bytes(arr[0].encode(), 'big'))[2:]

y = fn.xor(plaintext1 ,iv)
y1='0'+'b'+y

y= int(y1, 2)
#y is the string output of xoring plaintext1 with the IV 
y= y.to_bytes((y.bit_length() + 7) // 8, 'big').decode()   

encrypted_blocks=[]

# arr is the array of the original blocks of the msg.
for i in range (1, len(arr)):
    c = des.encrypt(y)
    print(c)
    encrypted_blocks.append(c)
    ### stuck here ### 
    #### don't know how to work with c in that format ######
</code></pre>
","<p>You've accepted an answer, but perhaps you don't realize that byte strings can be XORed as is?  No need for conversion to binary.  Example:</p>

<pre><code>&gt;&gt;&gt; msg = b'Mark'
&gt;&gt;&gt; key = b'\x01\x02\x03\x04'
&gt;&gt;&gt; enc = bytes([a^b for a,b in zip(msg,key)]) # xor each byte with key byte
&gt;&gt;&gt; enc
b'Lcqo'
&gt;&gt;&gt; dec = bytes([a^b for a,b in zip(enc,key)]) # xor again to decrypt
&gt;&gt;&gt; dec
b'Mark'
</code></pre>
","48","<python><unicode><undefined><des><python-cryptography>","-4","1","2","2019-04-27 20:25:12","55872568","0","","235698","","2019-04-27 20:20:48","2019-04-26 17:08:05",""
"56741153","How do I decrypt files that are encrypted using des command in Ruby?","<p>I need to decrypt files that are encrypted with this command:</p>

<pre><code>des -E -u -k ""some key"" file.in file.out.enc
</code></pre>

<p>The decryption code in Ruby:</p>

<pre><code>def decrypt(key)
  cipher = OpenSSL::Cipher.new(‘des’).decrypt
  cipher.key = key

  File.open(‘file.out’, ‘wb’) do |outf|
    decrypted = cipher.update(File.read(‘file.in.enc’)) + cipher.final
    outf.write(decrypted)
  end
end
</code></pre>

<p>I’m getting wrong final block length error when I run the code above. I also tried decrypting using the openssl command line tool and got a bad magic number error. Any advice?</p>
","<p>Try switching the mode, from <code>CBC</code> to <code>ECB</code> for instance with <code>OpenSSL::Cipher.new('DES-ECB')</code>. </p>

<p>If you check which ciphers your Ruby installation supports by looking at <code>OpenSSL::Cipher.ciphers</code>, you'll find a list of available modes too.</p>
","47","<ruby><encryption><openssl><des>","1","1","1","2019-06-24 19:23:28","","0","","","","","2019-06-24 17:12:23",""
"43054831","Convert Text String into Hex code","<p>I am trying to implement DES algorithm in Swift. And to do that, I need to convert my text string, ex. ""Hello, world"" into Hex string. I've found out <a href=""https://stackoverflow.com/questions/37720475/how-to-convert-a-text-string-to-hex-string-in-swift"">here</a> about this way </p>

<pre><code>var text = ""Hello, world!""
let data = text.data(using: String.Encoding.utf16)
data?.base64EncodedString()
</code></pre>

<p>But <code>base64EncodeString()</code> obviously does not return what I need. What should I do to get something like </p>

<pre><code>48656c6c6f2c20776f726c6421  
</code></pre>
","","47","<swift><string><hex><des>","1","","0","2017-03-27 19:26:10","","1","","-1","","2017-05-23 11:46:19","2017-03-27 19:26:10","2017-03-27 19:28:09"
"42612610","How to find the library <openssl/des.c> and usit in C programs","<p>I found a code in C used to break a DES encryption by means of a brute force attack (I will attach the link), but it is using a library that I can not find, I tried to search it on the webpage openssl and on their github repository, but I got lost.</p>

<p><a href=""https://stackoverflow.com/questions/9119046/brute-forcing-des-with-a-weak-key"">What I am trying to implement</a></p>
","","46","<c><openssl><des>","0","","0","2017-03-08 11:54:38","","2","","-1","","2017-05-23 12:00:21","2017-03-05 18:58:01","2017-03-06 04:30:46"
"37773953","What is the data type to store user inputted bitwise operator","<p>I have implemented Data Encryption Standard(DES) to encrypt a plain text and get the cipher from it. Though the DES uses 56 bit key , 64 bit block size and 16 rounds, to start from a simple code. I used 4 bit key, 8 bit block size, 4 rounds and without sub key generation (i.e. same key is used in all the rounds). According to DES for each an every round a round function is used. In my case I used the bitwise AND (<code>&amp;</code>) operator.</p>

<p>Here is a portion of my code</p>

<pre><code>import java.util.Arrays;

public class Encrypt {
    private int key[]={1,0,1,0};
    private int dataBlock[]={1,1,1,0,1,0,1,1};
    private int dataLeft[]=new int [4]; // for left part the plain text 
    private int dataRight[]=new int [4];    //for right part of the plain text
    private int dataLeftTemp[];
    private int dataRightTemp[]=new int [4];
    private int i=2;    // as initially two steps are run through automatically
    private int n=5;    // the no of rounds
    private int cipher[];

    public void splitting(){
        int j=0;        // for setting the indexes of the dataRight[]
        for(int i=0;i&lt;dataBlock.length;i++){

            if (i&lt;(dataBlock.length/2)){

                dataLeft[i]=dataBlock[i];

            }
            //           when i is greater than the half the index of the plain text
            else{

                dataRight[j]=dataBlock[i];
                j++;
            }
        }
        // for printing the array-------------------------------------------------  
        System.out.println(""DataSet"");
        for(int i: dataLeft){
            System.out.print(i);
        }
        for(int i: dataRight){
            System.out.print(i);
        }
        System.out.println("" "");
        System.out.println("" "");
        //------------------------------------------------------------------------
    }

    //==============================round function================================================

    public void roundingStart(){
        System.out.println(""Enter the round function"");



        for(int i=0;i&lt;4;i++){
            //           AND function
            dataRightTemp[i]=key[i] &amp; dataRight[i];
            //              XOR function
            dataRightTemp[i]=dataRightTemp[i]^dataLeft[i];

        }

        dataLeft=dataRight.clone();
        //      printResults();

        printFirst();
        roundingRest(dataLeft,dataRightTemp);


    }
//rest of the code
}
</code></pre>

<p>This works fine. But how do I change the above code so that user can enter the bitwise operator that is to be used in the round function. I tried using <code>Scanner</code> but I don't know what data type to be used to store the user input as bitwise operator so that it can be used at line</p>

<pre><code>dataRightTemp[i]=key[i] &amp; dataRight[i];
</code></pre>

<p>Can someone explain me how to do this?</p>
","<p>you cannot store the operator itself.</p>

<p>instead let the user input the operator as text: e.g. <code>and</code>, <code>or</code> , ..
and in your code use an if-statement to use the correct operator based on this user-text. Pseudocode:</p>

<pre><code>if (""and"".equalsIgnoreCase(userInput) {
     dataRightTemp[i]=key[i] &amp; dataRight[i];
} else if (""or"".equalsIgnoreCase(userInput)) {
     dataRightTemp[i]=key[i] | dataRight[i];
}
</code></pre>
","46","<java><java.util.scanner><bitwise-operators><des>","0","2","1","2016-06-12 12:21:08","37774191","1","","1288","","2016-06-12 12:13:02","2016-06-12 11:57:32",""
"55092686","I need help understanding bit order in DES for a C implementation","<p>I'm using a variety of references to study this algorithm, among others Christof Paar's book and classes. Currently I'm working on a custom C implementation of the algorithm, and am trying to implement <strong><em>the Expansion function</em></strong> in DES.</p>

<p>I am having problems with bit order. In an example provided in this <a href=""https://www.eit.lth.se/fileadmin/eit/courses/edi051/projects/des/des.pdf"" rel=""nofollow noreferrer"">link</a>, the following data (A) gets expanded to (B):</p>

<pre><code>(b&lt;x&gt;) --&gt; byte &lt;x&gt;

   (b0) (b1) (b2) (b3)
A: 0xF0 0xAA 0xF0 0xAA

   (b0)                    (b5)
B: 0x7A 0x15 0x55 x7A 0x15 0x55
</code></pre>

<p>At a bit level, what's happening is:</p>

<pre><code>A:   1111   0000   1010   1010
B:  011110 100001 010101 01010-

    0111 1010 0001 0101 0101...
    0x7  0xA  0x1  0x5  0x5...
</code></pre>

<p>Now, unless I'm missing something, I'd say that in byte 0xF0, or 0b11110000, the left-most bit (1) is being treated as bit 0, and the right-most bit (0), is being treated as bit 7.</p>

<p>This is, however, opposite to the bit order offered by C. In C, bit 0 is the right-most, and bit 7 is the left-most. The expansion of this byte would look like:</p>

<pre><code> 0000   1111
100001 01111...
</code></pre>

<p>Am I missing something? What bit order - endianness should I be considering in this algorithm?</p>
","","45","<encryption><des>","1","","0","2019-03-10 21:53:53","","2","","6365633","","2019-03-10 21:53:53","2019-03-10 21:19:54",""
"42340738","DES-X library for C (implementation on µController)","<p>I am searching for a c-library to decode and encode with DES-X. 
Unfortunately i can't find any...
Can you please let me know if anything is out there?
It has to be DES-X.</p>
","","45","<encryption><des>","0","","0","2017-02-20 09:26:38","","2","","","","","2017-02-20 09:26:38",""
"39767204","DES enctypted file gives different results","<p>I have a file which I am trying to decrypt using OpenSSL from bash: </p>

<pre><code>openssl des-ede3 -in test.bin -out test.txt -md md5 -k 'HELLO'
</code></pre>

<p>Each time I run this command I get different results in test.txt, Why is that? Shouldn't the result be the same given the same key?</p>
","<p>When not given a salt value, it seems to generate a random value on each run.</p>

<p>With a hexadecimal salt value specified like so <code>-S cafed00d</code>, I get the same result on subsequent runs.</p>

<p>Reference: <code>man enc</code>.</p>

<p>Side note: I find no reference of <code>-md md5</code> in man pages. This appears to be unused?</p>
","45","<linux><openssl><des><tripledes>","0","2","1","2017-03-14 04:39:29","","0","1","1007939","","2017-03-13 22:49:43","2016-09-29 10:00:08",""
"38920323","Loss of data when passing it to Cipher.update while using DES (Node.js)","<p>Here's the deal:</p>

<p>I have a Buffer of data structured like this:</p>

<p><code>[39 bytes of header] + [body] + [padding]</code> (calculated by me).
If I save it to a file, I can actually recognize the structure, and everything seems fine.</p>

<p>Then, I have to DES-CBC encrypt this buffer, and what I do is</p>

<p>a) Instantiate the DES wrapper, which has a key, and calculates a new IV (autoPadding: false on the Cipher object it creates, too)<br>
b) Pass the buffer to the DES wrapper<br>
c) The buffer then gets encrypted as follows:
(data is the buffer, en is the Cipher object)</p>

<pre><code>var buf1 = en.update(data);
</code></pre>

<p>When I output <code>buf1</code> on a file (and then, in my case, on a socket) and retrieve it's bytes, then decrypt it I obtain the following structure:
<code>[header][body]</code>
But when I output data on a file and retrieve it's bytes, I get the starting structure.
I know I should also append <code>en.final()</code> to <code>buf1</code>, but in my case I don't need those values, also with autoPadding being false it would just throw an error.</p>
","<p>The API provides you with a contract. One of the properties of the contract is that you need to call <code>Cipher#final([output_encoding])</code> when you finished encrypting. Even if the padding doesn't need to be handled by the <code>Cipher</code> instance, the code is written for re-usability and therefore expects to be used in the same way regardless of padding options.</p>
","44","<javascript><node.js><encryption><padding><des>","0","2","1","2016-08-12 20:08:27","38923757","2","","451475","","2016-08-12 20:08:27","2016-08-12 14:24:10",""
"57449581","Triple DES encryption string generates ""\n""","<p>While encrypting a string, it generates <code>'\n'</code> at end of the string.</p>

<p>This is how I'm doing encryption</p>

<pre><code>public static String encrypt(String plainText) throws Exception {
        byte[] tdesKeyData = Consts.getSecretKey().getBytes();
        byte[] myIV = Consts.getInitializationVector().getBytes();
        SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DES"");
        IvParameterSpec ivspec = new IvParameterSpec(myIV);
        Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS7Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, myKey, ivspec);

        byte[] plainTextBytes = plainText.getBytes(""UTF-8"");
        byte[] buf = cipher.doFinal(plainTextBytes);
        byte[] base64Bytes = Base64.encode(buf, Base64.DEFAULT);
        String base64EncryptedString = new String(base64Bytes);
        return base64EncryptedString;
    }
</code></pre>

<p>Please, somebody, guide me, what am I doing wrong here? Thanks in Advance.</p>
","<pre><code>  public byte[] encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return cipherText;
    }

    public String decrypt(byte[] message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
</code></pre>

<p>Try this code for encryption an decryption.</p>
","43","<java><android><encryption><des>","2","-2","2","2019-08-11 14:15:18","57450693","3","","238704","","2019-08-11 14:06:27","2019-08-11 11:27:40",""
"57449581","Triple DES encryption string generates ""\n""","<p>While encrypting a string, it generates <code>'\n'</code> at end of the string.</p>

<p>This is how I'm doing encryption</p>

<pre><code>public static String encrypt(String plainText) throws Exception {
        byte[] tdesKeyData = Consts.getSecretKey().getBytes();
        byte[] myIV = Consts.getInitializationVector().getBytes();
        SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DES"");
        IvParameterSpec ivspec = new IvParameterSpec(myIV);
        Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS7Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, myKey, ivspec);

        byte[] plainTextBytes = plainText.getBytes(""UTF-8"");
        byte[] buf = cipher.doFinal(plainTextBytes);
        byte[] base64Bytes = Base64.encode(buf, Base64.DEFAULT);
        String base64EncryptedString = new String(base64Bytes);
        return base64EncryptedString;
    }
</code></pre>

<p>Please, somebody, guide me, what am I doing wrong here? Thanks in Advance.</p>
","<p><a href=""https://developer.android.com/reference/android/util/Base64.html"" rel=""nofollow noreferrer"">Base64.NO_WRAP</a></p>

<p>Encoder flag bit to omit all line terminators (i.e., the output will be on one long line).</p>
","43","<java><android><encryption><des>","2","0","2","2019-08-11 14:15:18","57450693","3","","238704","","2019-08-11 14:06:27","2019-08-11 11:27:40",""
"56733079","Encrypt data with accents using python crypto library","<p>I am implementing DES3 in Python using Crypto library. I was doing some test when I’ve stumbled upon the next problem: </p>

<p>If the plain text that I want to encrypt contains strange charactes, as accents, fails. </p>

<p>For example, my code is working fine when I try to encrypt the next word: </p>

<p>Text to be encrypted(multiple of 8 in length) : <code>""Hello Jose      ""</code></p>

<p>However, it fails if I try to encrypt the same text but containing an accent:
Text to be encrypted (multiple of 8 in length)= <code>""Hello José      ""</code></p>

<p>The error that I am getting is “ValueError: Input strings must be a multiple of 8 in length”.</p>

<p>If I check the length of the word, it is a multiple of 8. </p>

<pre><code>plaintext=""Hello Jose      ""
print("" Plain text:"" + plaintext)
print("" Plain Text length:"" + str(len(plaintext)))
</code></pre>

<p>Result: Plain Text length : 16</p>

<p>Find next a reduced example of my code: </p>

<pre><code>from Crypto.Cipher import DES3
import binascii
import base64

plaintext=""Hello Jose      ""
print("" Plain text:"" + plaintext)
print("" Plain Text length:"" + str(len(plaintext)))

#### ENCRYPTION 
key ='173JKL3D93A9CNI1G6NP9A14'
key=bytes(key, 'utf-8')
plaintext_bytes=bytes(plaintext, 'utf-8')
print("" Plain Text length:"" + str(len(plaintext_bytes)))


cipher_encrypt=DES3.new(key)
encrypted_text=cipher_encrypt.encrypt(plaintext_bytes)
print( "" Encrypted word:"" + str(encrypted_text))

#### DECRYPTION
cipher_encrypt=DES3.new(key)
decrypted_text=cipher_encrypt.decrypt(encrypted_text)
print("" Decripted text:"" + str(decrypted_text,'utf-8') + ""\n"")
</code></pre>

<p>Can anyone help me to understand why it is not working correctly?</p>
","<p>Goyo is right. The algorithm reads the plain text as a byte-string. Knowing that, the length in bytes of one character with accent is 2. See next example: </p>

<pre><code>&gt;&gt; a='a'
&gt;&gt; print(""length:"" + str(len(a.encode('utf-8'))))
length:1
</code></pre>

<pre><code>&gt;&gt; a='á'
&gt;&gt; print(""length:"" + str(len(a.encode('utf-8'))))
length:2
</code></pre>

<p>So, firstly you have to encode the text to bytes and then calculate the length. </p>

<p>What you could do is calculate the next multiple of 8 and that should be the length of the plain text. After that, you could fill out the string with whitespace to that length. </p>
","43","<python><encryption><pycrypto><des>","-1","1","1","2019-06-25 10:54:03","","3","","603316","","2019-06-24 11:40:04","2019-06-24 08:56:59",""
"34433376","javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 when decrypting with padded cipher","<p>I am using the following algo to encrypt/decrypt in Java -</p>

<pre><code>cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
</code></pre>

<p>Encrypt/Decrypt methods are as follows -</p>

<pre><code>    public String encryptString(String originalString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, secKey);
            byte[] encryptedBytes = cipher.doFinal(originalString.getBytes(""UTF8""));
            encryptedString = new String(encryptedBytes,""UTF8"");
        } catch (Exception ex) {
            LOGGER.error(""Could not encrypt String {}"", originalString, ex);
            ex.printStackTrace();
        }
        return encryptedString;
    }

    public String decryptString(String encryptedString) {
        String decryptedString = null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, secKey);
            byte[] encryptedBytes = cipher.doFinal(encryptedString.getBytes(""UTF8""));
            decryptedString = new String(encryptedBytes,""UTF8"");
        } catch (Exception ex) {
            LOGGER.error(""Could not decrypt String {}"", encryptedString, ex);
            ex.printStackTrace();
        }
        return decryptedString;
    }
</code></pre>

<p>But it gives me following error</p>

<pre><code>javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 when decrypting with padded cipher
    at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
</code></pre>

<p>If I remove all UTF-8 in String and <code>getBytes()</code> in works fine in on my local windows 7 machine but does not work on the my linux box (where tomcat is deployed) with same error as above. Any help or suggestion is appreciated.</p>

<p>It may not be relevant but I am saving and retrieving values from DB2 database.</p>

<hr>

<p>I cannot use to store String in DB2 after base64 encoding due to existing data setups. I need to decrypt existing data with above alogo. It works on windows machine but not on Linux (all without utf-formats).</p>

<hr>

<p>After some debugging it looks like <code>new String()</code> and <code>getBytes()</code> are using default platform specific locales. Also <code>UTF-8</code> in new String() changes encoded bytes (which are multiple of 8 bytes as per DES) to non multiple of 8 due to which decryption fails. <strong>Using base64 is not an option.</strong>  </p>
","","41","<java><db2><des><ecb><pkcs#5>","0","","0","2015-12-23 13:02:25","","2","2","2396539","","2015-12-23 13:02:25","2015-12-23 10:18:31","2015-12-23 13:31:57"
"58141398","C# DES ECB Encryption OpenSSL","<p>I am having a problem getting my encryption to match what I am getting out of OpenSSL.  The input in the Mk.bin file is a hex value of <code>CA46E5A885D1E016150B5B64ECC11A43</code></p>

<p>The following is my openssl command:</p>

<pre><code>openssl.exe enc -des-ecb -in C:\OpenSSL\Mk.bin -out C:\OpenSSL\MkOut.bin -nosalt -k TestKey0
</code></pre>

<p>And my C# function to attempt to match that is:</p>

<pre><code>public static byte[] EncryptDES(byte[] clearData, byte[] key)
    {
        DES desEncrypt = new DESCryptoServiceProvider();
        desEncrypt.Mode = CipherMode.ECB;
        desEncrypt.Key = key;
        ICryptoTransform transForm = desEncrypt.CreateEncryptor();
        MemoryStream encryptedStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(encryptedStream, transForm, CryptoStreamMode.Write);
        cryptoStream.Write(clearData, 0, clearData.Length);
        cryptoStream.FlushFinalBlock();
        return encryptedStream.ToArray();
    }
</code></pre>
","<p>I found the answer 
-p put into openssl shows me that it was converting my hex input.  When I used the converted key in c#, it outputted the correct value</p>
","37","<c#><openssl><des><ecb>","0","0","1","2019-09-28 20:48:33","","0","","11019743","","2019-09-27 22:54:41","2019-09-27 21:13:44",""
"54582074","Decrypting MDES cipher text","<p>I'm trying to work with a sort of custom DES-style encryption and I'm having trouble decrypting it. </p>

<p>From my understanding, the Feistel cipher would decrypt a cipher text just by having the keys fed back to it in a backwards order, but this doesn't seem to be working. </p>

<p>Do we have to reverse the keys or the order of Li,Ri as well. </p>

<p>My Python Code:</p>

<pre><code>def Encrypt (plainString):

l0=plainString[0:8]
r0=plainString[8:16]
l1=r0
fOutcome1=bitManage (r0,key[0:12])
r1=xorHelper (r0,fOutcome1)
l2=r1
fOutcome2=bitManage (r1,key[12:24])
r2=xorHelper (l1,fOutcome2)
rawCipherText= l2+r2
return rawCipherText

def desDecrypt (plainString):
l0=plainString[0:8]
r0=plainString[8:16]
l1=r0
fOutcome1=bitManage (r0,key[12:24])
r1=xorHelper (l0,fOutcome1)

l2=r1
fOutcome2=bitManage (r1,key[0:12])
r2=xorHelper (l1,fOutcome2)
rawCipherText= l2+r2
return rawCipherText
</code></pre>

<p><a href=""https://pastebin.com/1jc9mMjd"" rel=""nofollow noreferrer"">Here is the code for BitManage</a></p>

<p>Given the basic formula of the Feistel Cipher: 
Li = Ri−1
Ri = Li−1 ⊕ f(Ri−1, Ki).</p>

<p>I'm just doing two rounds of encryption.</p>

<ol>
<li>I take in a string</li>
<li>Convert it to a numeric value (a=0...until 31)</li>
<li>Convert to bit strings</li>
<li>Encrypt 16 bit chunks of string.</li>
<li>Decrypt same chunks</li>
<li>Recombine the chunks (so you have one string) then break again into 5 bit strings to get character's numeric value and then convert back to letters.</li>
</ol>

<p>So I should be able to just reverse the key schedule in f(Encrypt) for f(Decrypt) and get the correct answer but I'm getting gibberish back.</p>

<p>For more information: The key is a 24 bit round number, and,for the f function, the 8 bits of L0,R0 are passed through a separate program that expands them to 12 bits, XORs them with the relevant half of the roundkey and then passes them through S-boxes. I've checked the values of this f function and it seems to work perfectly. </p>

<p>Is the problem the ""BitManage' function? The only place I can see the problem being caused is with the bit expansion (where I turn an 8 bit value into a 12 bit one by adding all the values at odd indexes to the end of the string) but I'm not sure why that would cause a problem.</p>
","","37","<encryption><des><feistel-cipher>","0","","0","2019-02-07 20:51:54","","0","","","","","2019-02-07 20:51:54",""
"57054908","how to decrypt a text by DES algorithm in ecmascript or any package in react native?","<p>how to decrypt my text  by DES algorithm in ecmascript or any package in react native?
I test <code>react-native-des</code> and <code>react-native-des-cbc</code>, but no any result for me.</p>
","<p>Try this:</p>

<p><a href=""https://cryptojs.gitbook.io/docs/"" rel=""nofollow noreferrer"">CryptoJS</a></p>

<p>Example:</p>

<pre><code>var encrypted = CryptoJS.DES.encrypt(""Message"", ""Secret Passphrase"");

var decrypted = CryptoJS.DES.decrypt(encrypted, ""Secret Passphrase"");
</code></pre>
","36","<react-native><des>","0","0","1","2019-07-17 06:56:48","","0","","","","","2019-07-16 10:11:04",""
"57932475","Mifare DESFire EV2 Master File AES Authentication","<p>I am working with Mifare DESFire EV2 card, I am trying to authenticate with the master file using AES Key.</p>

<p>I have achieved the authentication with master file using DES successfully, but when trying with AES using the command INS=0xAA, i get response 0x91AE.</p>

<p>is there any setting for the master file to enable AES Authentication? or only DES is the available authentication with master file?</p>
","<p>If it is a blank new card, AES is the the wrong cipher. The default cipher is 2K3DES, not AES. You must first change the cipher from the default to AES if you want to use it.</p>
","35","<aes><mifare><des>","0","1","1","2019-09-23 11:15:35","58061239","0","","","","","2019-09-14 04:35:06",""
"41936915","TCL Tcllib DES wrong parameters?","<p>I want to use the DES function from the Tcllib, but it seems I do not handle the
variables in a correct way.</p>

<p>Here is the code:</p>

<pre><code>set key DAAE57F813459B3B
set key_b [binary format H* $key]

set data 2D7A99F520D684B4
set data_b [binary format H* $data]

set result [DES::des -dir encrypt -key $key_b -hex $data_b]
</code></pre>

<p>When using these values I got an error:</p>

<pre><code>bad option ""-z..."": must be one of -chunksize, -dir, -hex, -in, -iv, -key, -mode, -out, -weak
</code></pre>

<p>It seems that the DES function is interpreting '2D...' as '-z...' and therefore as an option (which is not allowed).</p>

<p>When I exchange the values (key &lt;-> data, data &lt;-> key) I do not get an error.<br>
Also when I use data 1D..., 3D... etc. the function works fine.</p>

<p>I am using Tcllib V1.18 and packages: des, sha1, pki, asn, aes, math::bignum, md5, base64.</p>

<p>Does anybody has an idea how to hand over the variable 'data' to the DES function without interpreting the data as option?</p>
","<p>The problem is that the high-level driver code in the <code>DES::des</code> command is confused by the data beginning with a <code>-</code> (0x2D) byte. That's a reportable bug; please report it.</p>

<p>But you can work around it by using the <em>low-level</em> interface in the Tcllib des package:</p>

<pre><code>package require des

set key DAAE57F813459B3B
set key_b [binary format H* $key]

set data 2D7A99F520D684B4
set data_b [binary format H* $data]

# The [binary format] below is for the initialisation vector (IV) which should usually be
# 64 zero bits to start with if you're using simple encryption.
set d [DES::Init cbc $key_b [binary format I* {0 0}]]
set encBytes [DES::Encrypt $d $data_b]
DES::Final $d

# We've got the bytes out; let's convert to hex for printing

binary scan $encBytes H* encHex
puts $encHex;    # --&gt; “4cd33892969591b4”
</code></pre>

<p>Going in the reverse direction is pretty easy too:</p>

<pre><code>package require des

set key DAAE57F813459B3B
set key_b [binary format H* $key]

set encHex 4cd33892969591b4
set encBytes [binary format H* $encHex]

set d [DES::Init cbc $key_b [binary format I* {0 0}]]
set decBytes [DES::Decrypt $d $encBytes]
DES::Final $d

binary scan $decBytes H* decHex
puts $decHex;    # --&gt; “2d7a99f520d684b4”
</code></pre>
","34","<parameters><tcl><des>","1","1","1","2017-01-30 13:50:40","41937531","0","","301832","","2017-01-30 13:33:43","2017-01-30 13:18:12",""
"56079235","Why does the key not seem to work when using the DES_DECRYPT function in MySQL?","<p>When I run the following code it does not seem the use the key to decrypt the data? </p>

<p>I receive the same results whether I add the key or not when decrypting.<br>
It may be relevant to know that the data was encrypted in nodejs (Code Below)</p>

<pre><code>SELECT 
     des_decrypt(firstName, 'MYSECRYPTKEY') Name, firstName
FROM users 
</code></pre>

<p>Encryption code in node</p>

<pre><code>const enc = value =&gt; {
  if (value !== null &amp;&amp; value !== """" &amp;&amp; value !== undefined) {
    var keyHex = CryptoJS.enc.Utf8.parse(process.env.AES_KEY);
    var encrypted = CryptoJS.DES.encrypt(value, keyHex, {
      mode: CryptoJS.mode.ECB,
      padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.toString();
  } else {
    return value;
  }
};
</code></pre>

<p>Example of results</p>

<pre><code>Name            firstName
Hv1eN7CLj1k=    Hv1eN7CLj1k=
bc0vsKnLa00=    bc0vsKnLa00=
OhhE6Va+tg0=    OhhE6Va+tg0=
02RJonbm2jY=    02RJonbm2jY=
</code></pre>
","","34","<mysql><encryption><des>","0","","0","2019-05-10 14:00:47","","5","","","","","2019-05-10 14:00:47",""
"58191393","DES in CBC mode must be caught or thrown error","<p>I am trying to figure out why my DES code for cbc mode is not working. I get an error that says :
error: unreported exception NoSuchProviderException; must be caught or declared to be thrown
   desCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"", ""CB"");</p>

<pre><code>import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

public class JEncrytion
{    
    public static void main(String[] argv) {

        try{

        KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
        SecretKey myDesKey = keygenerator.generateKey();

        Cipher desCipher;

        // Create the cipher 
        desCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"", ""CB"");

        // Initialize the cipher for encryption
        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);

        //sensitive information
        byte[] text = ""hello world how are you"".getBytes();

        System.out.println(""Text [Byte Format] : "" + text);
        System.out.println(""Text : "" + new String(text));

        // Encrypt the text
        byte[] textEncrypted = desCipher.doFinal(text);

        System.out.println(""Text Encryted : "" + textEncrypted);

        // Initialize the same cipher for decryption
        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);

        // Decrypt the text
        byte[] textDecrypted = desCipher.doFinal(textEncrypted);

        System.out.println(""Text Decryted : "" + new 
String(textDecrypted));

    }catch(NoSuchAlgorithmException e){
        e.printStackTrace();
    }catch(NoSuchPaddingException e){
        e.printStackTrace();
    }catch(InvalidKeyException e){
        e.printStackTrace();
    }catch(IllegalBlockSizeException e){
        e.printStackTrace();
    }catch(BadPaddingException e){
        e.printStackTrace();
    } 
}
}
</code></pre>
","<p>Do what the message says - declare an exception:</p>

<pre><code>public static void main(String[] argv) throws Exception {
</code></pre>

<p>In your case a general exception is sufficient.</p>
","34","<java><des><cbc-mode>","0","0","2","2019-10-02 06:13:40","","0","","","","","2019-10-01 19:49:45",""
"58191393","DES in CBC mode must be caught or thrown error","<p>I am trying to figure out why my DES code for cbc mode is not working. I get an error that says :
error: unreported exception NoSuchProviderException; must be caught or declared to be thrown
   desCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"", ""CB"");</p>

<pre><code>import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

public class JEncrytion
{    
    public static void main(String[] argv) {

        try{

        KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
        SecretKey myDesKey = keygenerator.generateKey();

        Cipher desCipher;

        // Create the cipher 
        desCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"", ""CB"");

        // Initialize the cipher for encryption
        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);

        //sensitive information
        byte[] text = ""hello world how are you"".getBytes();

        System.out.println(""Text [Byte Format] : "" + text);
        System.out.println(""Text : "" + new String(text));

        // Encrypt the text
        byte[] textEncrypted = desCipher.doFinal(text);

        System.out.println(""Text Encryted : "" + textEncrypted);

        // Initialize the same cipher for decryption
        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);

        // Decrypt the text
        byte[] textDecrypted = desCipher.doFinal(textEncrypted);

        System.out.println(""Text Decryted : "" + new 
String(textDecrypted));

    }catch(NoSuchAlgorithmException e){
        e.printStackTrace();
    }catch(NoSuchPaddingException e){
        e.printStackTrace();
    }catch(InvalidKeyException e){
        e.printStackTrace();
    }catch(IllegalBlockSizeException e){
        e.printStackTrace();
    }catch(BadPaddingException e){
        e.printStackTrace();
    } 
}
}
</code></pre>
","<p>You need not to use Provider <strong>CB</strong> in <code>Cipher.getInstance()</code>. So, you will not get <code>NoSuchProviderException</code> anymore.</p>

<p>Just see below code, It works perfectly.</p>

<pre><code>import java.security.InvalidKeyException;
import java.security.InvalidAlgorithmParameterException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.SecretKey;

public class JEncryption
{    
    public static void main(String[] argv) {

    try{

        KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
        SecretKey myDesKey = keygenerator.generateKey();

        Cipher desCipher;

        // Create the cipher 
        desCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        // Initialize the cipher for encryption
        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey,iv);

        //sensitive information
        byte[] text = ""hello world how are you"".getBytes();

        System.out.println(""Text [Byte Format] : "" + text);
        System.out.println(""Text : "" + new String(text));

        // Encrypt the text
        byte[] textEncrypted = desCipher.doFinal(text);

        System.out.println(""Text Encryted : "" + textEncrypted);
        // Initialize the same cipher for decryption
        desCipher.init(Cipher.DECRYPT_MODE, myDesKey,iv);

        // Decrypt the text
        byte[] textDecrypted = desCipher.doFinal(textEncrypted);

        System.out.println(""Text Decryted : "" + new String(textDecrypted));

     }catch(NoSuchAlgorithmException e){
         e.printStackTrace();
     }catch(NoSuchPaddingException e){
         e.printStackTrace();
     }catch(InvalidKeyException e){
         e.printStackTrace();
     }catch(InvalidAlgorithmParameterException e){
         e.printStackTrace();
     }catch(IllegalBlockSizeException e){
         e.printStackTrace();
     }catch(BadPaddingException e){
         e.printStackTrace();
     } 
  }
}
</code></pre>
","34","<java><des><cbc-mode>","0","0","2","2019-10-02 06:13:40","","0","","","","","2019-10-01 19:49:45",""
"39063366","How to search keyword in DES encrypted fields?","<p>I encrypted some fields like name and mobile then stored them in SQL Server, now I have to search the fields.  </p>

<p>For example: <code>select * from X_Table where Name Like 'aaa'</code>.</p>

<p>The Name field is encrypted and the <code>aaa</code> unencrypted. How should I do this?</p>
","","33","<sql><sql-server><des>","0","","0","2016-08-21 21:02:36","","5","","369","","2016-08-21 21:02:36","2016-08-21 10:49:54",""
"56203915","what is the fastest way to search for pairs with certain input-difference to use in cryptanalysis on DES?","<p>I'm trying to implement differential crypt-analysis on 6-variant DES and I need some pairs with a certain input-Difference(deltaX). What is the fastest way to do so?</p>

<p>DES cipher has 64-bit-block which means 8 letters.I've tried searching for pairs block by block and letter by letter but the number of pairs returned was so little even when I used long texts, so I've tried searching bit by bit but the search is taking too long.</p>

<p>Here are the functions I used to search:</p>

<pre class=""lang-java prettyprint-override""><code>static double stringBlockLengthDouble=8.0;
static int stringBlockLength=8;
static int blockLengthInBits=64;

public static Pair[] searchForPairsBlockByBlock(byte[] OmegaP,byte[] initialKey,int rounds,String plaintext1,String plaintext2){
   ArrayList&lt;ArrayList&lt;String&gt;&gt; pairsString=new ArrayList&lt;&gt;();
   ArrayList&lt;String&gt; texts=new ArrayList&lt;&gt;();

   int plaintext1BlocksNum=(int)Math.ceil(plaintext1.length()/stringBlockLengthDouble);
   int plaintext2BlocksNum=(int)Math.ceil(plaintext2.length()/stringBlockLengthDouble);

   for(int i=0;i&lt;plaintext1BlocksNum;i++){
        String plaintext1Block="""";
        if(i&lt;plaintext1BlocksNum-1){
            plaintext1Block=plaintext1.substring(i*stringBlockLength,(i+1)*stringBlockLength);
        }
        else{
            plaintext1Block=plaintext1.substring(i*stringBlockLength);

        }
        if(texts.contains(plaintext1Block)){
            continue;
        }
        byte[] plaintext1BinaryBlock=convertTextToBinaryArrayASCII(plaintext1Block);

        for(int j=0;j&lt;plaintext2BlocksNum;j++){
            String plaintext2Block="""";
            if(j&lt;plaintext2BlocksNum-1){
                    plaintext2Block=plaintext2.substring(j*stringBlockLength,(j+1)*stringBlockLength);

             }
             else{
                    plaintext2Block=plaintext2.substring(j*stringBlockLength);

             }
             if(texts.contains(plaintext2Block)){
                continue;
             }

             byte[] plaintext2BinaryBlock=convertTextToBinaryArrayASCII(plaintext2Block);

             byte[] xor=DESCipher.xor(plaintext1BinaryBlock,plaintext2BinaryBlock);

            if(isEqualBinaryArray(xor, OmegaP)){
                 System.out.println(""inside b"");
                 texts.add(plaintext1Block);
                 texts.add(plaintext2Block);
                 ArrayList&lt;String&gt; onePairString=new ArrayList&lt;&gt;();
                 onePairString.add(plaintext1Block);
                 onePairString.add(plaintext2Block);
                 pairsString.add(onePairString);

            }
        }
   }

   Pair[] returned=new Pair[pairsString.size()];
   for(int i=0;i&lt;pairsString.size();i++){
        byte[] plaintext1Binary=convertTextToBinaryArrayASCII(pairsString.get(i).get(0));
        returned[i]=new Pair(plaintext1Binary,OmegaP,initialKey,rounds);
   }
   return returned;
}



public static Pair[] searchForPairsBitByBit(byte[] OmegaP,byte[] initialKey,int rounds,String plaintext1,String plaintext2){
    ArrayList&lt;ArrayList&lt;String&gt;&gt; pairsString=new ArrayList&lt;&gt;();
    ArrayList&lt;String&gt; texts=new ArrayList&lt;&gt;();

    byte[] plaintext1Binary=convertTextToBinaryArrayASCII(plaintext1);
    byte[] plaintext2Binary=convertTextToBinaryArrayASCII(plaintext2);

    byte[] binaryBlock1=new byte[blockLengthInBits];
    byte[] binaryBlock2=new byte[blockLengthInBits]; 

    for(int i=0;i&lt;plaintext1Binary.length-blockLengthInBits-1;i++){
        for(int blockIndex=0;blockIndex&lt;blockLengthInBits;blockIndex++){
             binaryBlock1[blockIndex]=plaintext1Binary[i+blockIndex];
        }
        String block1Hex=DES_Analysis.convertBinaryArrayToHex(binaryBlock1);
        if(texts.contains(block1Hex)){
            continue;
        }
        for(int j=0;j&lt;plaintext2Binary.length-blockLengthInBits-1;j++){
            for(int blockIndex=0;blockIndex&lt;blockLengthInBits;blockIndex++){
                    binaryBlock2[blockIndex]=plaintext2Binary[j+blockIndex];
        }
        String block2Hex=DES_Analysis.convertBinaryArrayToHex(binaryBlock2);
        if(texts.contains(block2Hex)){
                continue;
        }
        byte[] xor=DESCipher.xor(binaryBlock1,binaryBlock2);

        if(isEqualBinaryArray(xor,OmegaP)){
                System.out.println(""inside b"");
                texts.add(block1Hex);
                texts.add(block2Hex);
                ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();
                list.add(block1Hex);
                list.add(block2Hex);
                pairsString.add(list);
        }
     }
  }

  Pair[] returned=new Pair[pairsString.size()];
  for(int i=0;i&lt;pairsString.size();i++){
        byte[] binary1=DES_Analysis.convertHexToBinaryArray(pairsString.get(i).get(0));
        returned[i]=new Pair(plaintext1Binary,OmegaP,initialKey,rounds);
  }
  return returned;

}


public static Pair[] searchForPairsLetterByLetter(byte[] OmegaP,byte[] initialKey,int rounds,String plaintext1,String plaintext2){
    ArrayList&lt;ArrayList&lt;String&gt;&gt; pairsString=new ArrayList&lt;&gt;();
    ArrayList&lt;String&gt; texts=new ArrayList&lt;&gt;();

    int plaintext1BlocksNum=(int)Math.ceil(plaintext1.length()/stringBlockLengthDouble);
    int plaintext2BlocksNum=(int)Math.ceil(plaintext2.length()/stringBlockLengthDouble);

    for(int i=0;i&lt;plaintext1.length();i++){
        String plaintext1Block="""";
        if(i&lt;plaintext1.length()-stringBlockLength){
                plaintext1Block=plaintext1.substring(i,i+stringBlockLength);
        }
        else{
            plaintext1Block=plaintext1.substring(i);
        }
        if(texts.contains(plaintext1Block)){
            continue;
        }

        byte[] plaintext1BinaryBlock=convertTextToBinaryArrayASCII(plaintext1Block);

        for(int j=0;j&lt;plaintext2.length();j++){
            String plaintext2Block="""";
            if(j&lt;plaintext2.length()-stringBlockLength){
                    plaintext2Block=plaintext2.substring(j,j+stringBlockLength);

            }
            else{
                plaintext2Block=plaintext2.substring(j);
            }
            if(texts.contains(plaintext2Block)){
                continue;
            }

            byte[] plaintext2BinaryBlock=convertTextToBinaryArrayASCII(plaintext2Block);
            byte[] xor=DESCipher.xor(plaintext1BinaryBlock,plaintext2BinaryBlock);

            if(isEqualBinaryArray(xor,OmegaP)){
                System.out.println(""inside b"");
                texts.add(plaintext1Block);
                texts.add(plaintext2Block);
                ArrayList&lt;String&gt; onePairString=new ArrayList&lt;&gt;();
                onePairString.add(plaintext1Block);
                onePairString.add(plaintext2Block);
                pairsString.add(onePairString);

            }
        }
    }

    Pair[] returned=new Pair[pairsString.size()];
    for(int i=0;i&lt;pairsString.size();i++){
        byte[] plaintext1Binary=convertTextToBinaryArrayASCII(pairsString.get(i).get(0));
        returned[i]=new Pair(plaintext1Binary,OmegaP,initialKey,rounds);
    }
    return returned;
}


</code></pre>
","","30","<java><des><cryptanalysis>","0","","0","2019-05-19 00:42:16","","0","","","","","2019-05-19 00:42:16",""
"25227715","How to get Encryption key if i have data which needs to be encrypted is present and data after encryption is also present using DES","<p>I have a data which is encrypted using DES , it's a 10 character data which is encrypted into 28 character where last character is always = . I have around 10 data samples available. How can i get key to this.</p>
","<p>You have too few samples for recover key. 10 samples is not seriously. </p>

<p>You need to collect 2^48 encrypted pairs (text:ciphertext) and 2^39 
attempts for recover key by linear cryptanalysis. </p>

<p>Detail here: <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""nofollow"">http://en.wikipedia.org/wiki/Data_Encryption_Standard</a></p>
","29","<algorithm><security><encryption><des>","0","0","1","2014-08-11 01:24:48","","4","","","","","2014-08-10 10:32:57",""
"44066330","Possible DES keys","<p>I have two questions. </p>

<ol>
<li>How many DES-keys will produce the same first 32 bit ciphertext from the same plaintext?</li>
</ol>

<p>Example:</p>

<p>Plaintext = 00 00 00 00 00 00 00 00 (hex)</p>

<p>Ciphertext = 01 02 03 04 ?? ?? ?? ?? (hex)</p>

<p>How many keys can produce this?</p>

<ol start=""2"">
<li>If I get another plaintext-ciphertext pair, where I know the entire plaintext, but only the first half of the ciphertext. How many keys can produce the same first half of a ciphertext?</li>
</ol>
","<blockquote>
  <p>How many DES-keys will produce the same first 32 bit ciphertext from the same plaintext?</p>
</blockquote>

<p>Since a block cipher is modeled as a pseudo-random permutation, the answer is 2<sup>32</sup>.</p>

<blockquote>
  <p>If I get another plaintext-ciphertext pair, where I know the entire plaintext, but only the first half of the ciphertext. How many keys can produce the same first half of a ciphertext?</p>
</blockquote>

<p>If the plaintext is longer than a block, then this depends on the mode of operation you're using and the specific length. </p>

<p>If the plaintext is exactly one block and no padding is used, then it is the same answer as to your first question, because half a block are 32 bits for DES.</p>
","28","<des>","-2","0","1","2017-05-19 16:53:01","","0","","","","","2017-05-19 09:29:23",""
"42883438","Python DES encryption strange behavior","<p>I have a text file containing the following text:</p>

<h1>message.txt</h1>

<pre><code>this is my secret message
</code></pre>

<p>I wrote a small python code to read that file and encode it using <code>Crypto.Cipher</code></p>

<pre><code>from Crypto.Cipher import DES
f = open('message.txt','rb')
text = f.read()
f.close()

iv   = Random.get_random_bytes(8)
des1 = DES.new('01234567', DES.MODE_CFB, iv)

secret = des1.encrypt(text)  
print(""Encrypted text: "" + secret)   
</code></pre>

<h1>output:</h1>

<blockquote>
  <p>Encrypted text: Å..GH.ÿì.Vs~ö.~.wôÇ.k5â</p>
</blockquote>

<p>I then saved the output string to a text file:</p>

<pre><code>w = open('encrypted.txt','wb')
w.write(secret)
w.close()
</code></pre>

<p>Then I tried to open the same encrypted file and decrypt the content back to its original message:</p>

<pre><code>d = open('encrypted.txt','rb')
secret = d.read()
d.close()

text = des1.decrypt(secret)
print(""decreypted text is: "" + text)
</code></pre>

<h1>output:</h1>

<blockquote>
  <p>decrypted text is: óF2â.}1Úmy secret message</p>
</blockquote>

<p>It is very strange that the encryption works partially. I was under the impression that you would either encryption would produce the whole original message intact, or it would yield an unreadable gibberish text. But never expected a mixture of the two.</p>

<p>What am I doing wrong?</p>

<p>*Edit: I have edited my question: I always read binary and write binary. The half decrypted output happens when I read/write binary. When I don't read binary, the output is completely gibberish.</p>
","","27","<python><encryption><pycrypto><des>","0","","0","2017-03-19 06:48:39","","4","","736172","","2017-03-19 06:48:39","2017-03-19 06:00:12","2017-03-19 09:40:26"
"44310691","Encryption with DES with urlENcode(encrypt)","<p>I am attempting to use DES to encrypt / decrypt. However, the decrypt is not working. I keep getting the error: Cannot read property 'charCodeAt' of null</p>

<p>The decryption is from <a href=""http://www.tero.co.uk/des/"" rel=""nofollow noreferrer"">http://www.tero.co.uk/des/</a></p>

<p>I am using this to encode: </p>

<pre><code>var decodedKey = decodeBase64(key);
var em = urlEncode(encrypt(decodedKey, value));
</code></pre>

<p>and then I am attempting to use this function to decrypt:</p>

<pre><code>var emD = urlDecode(decrypt(decodedKey, em))
</code></pre>

<p>with </p>

<pre><code> function encrypt(key, message) {
        var ciphertext = des(key, message, 1, 0, null, 1);
        var encodedCiphertext = encodeBase64(ciphertext);
        return encodedCiphertext;

       }

       function decrypt(key,message) {
         var ciphertext = des(key, message, 0, 1, null,1);
         var plainText = decodeBase64(ciphertext);
         return plainText;
       };
</code></pre>
","<p>With:</p>

<pre><code>urlEncode(encrypt(decodedKey, value));
</code></pre>

<p>you first encrypt then url-encode. When you need to decrypt, you need to first url-decode then decrypt - something like: </p>

<pre><code>decrypt(decodedKey, urlDecode(em));
</code></pre>

<p>as opposed to decrypt then url-decode as you try with this statement: </p>

<pre><code>urlDecode(decrypt(decodedKey, em));
</code></pre>

<p>Also, please note that <strong>DES</strong> is considered <strong>insecure</strong> and should be avoided. Use a secure cipher like <strong>AES</strong>.</p>
","26","<encryption><des>","0","1","1","2017-06-01 15:09:10","","0","","","","","2017-06-01 14:46:42",""
"57847702","how to encrypt/decrypt with PBEWithMD5AndDES in swift","<p>My Backend server use token encrypted with PBEWithMD5AndDES written in java servlet.</p>

<p>My iOS Apps need to decrypt this token and then use this token to encrypt data with same algorithm</p>

<p>some solution written in objC, but my Apps need to be written in Swift</p>

<p>is there any code example to write PBEWithMD5AndDES in swift.</p>

<p>thank you</p>
","","26","<encryption><md5><des><swift5>","0","","0","2019-09-09 03:58:07","","0","","","","","2019-09-09 03:58:07",""
"53443148","expect and DES encryption","<p>I want to write a expect script to login to our routers/switches (Cisco). It is working but the problem is that the password is in cleartext form in my script. That is why I want to make it encrypted like:
<a href=""https://wiki.tcl-lang.org/page/Secure+expect"" rel=""nofollow noreferrer"">https://wiki.tcl-lang.org/page/Secure+expect</a>
Problem now is that I imported tcllib, can make </p>

<pre><code>package require des
</code></pre>

<p>but when I want to use the command des, like in the example script, I get:</p>

<pre><code>expect1.1&gt; package require des
1.1.0
expect1.2&gt; des
invalid command name ""des""
    while executing
""des""
</code></pre>

<p>What am I doing wrong here?</p>

<p>Thanks in advance!</p>
","","25","<linux><encryption><passwords><expect><des>","0","","0","2018-11-23 08:37:06","","3","","","","","2018-11-23 08:37:06",""
"36230105","How are 16 rounds in DES connected?","<p>The outputs of each of the rounds are connected how ? I am not able to figure out how the outputs are connected to one another</p>
","<p>They are connected by permutation and transposition; the output of the previous round becomes the input of the next round (and a few monkey wrenches), go to this website to see a graphical representation (<a href=""http://www.cronospr.com/DES.php"" rel=""nofollow"">http://www.cronospr.com/DES.php</a>); it is just plain arithmetic!</p>
","23","<des>","0","0","1","2016-05-06 02:47:16","","1","","","","","2016-03-26 00:15:43",""
"29583775","Java TripleDES using DES","<p>I'm trying to implement the <code>TripleDES</code> encryption algorithm using <code>DES</code>,<br>
I want to use 2 keys, and the flavor of the <code>TripleDES</code> is <strong>EDE</strong> using (key1, key2, key1).<br>
I know that there is a TripleDES algorithm, but my project is about implementing it using DES.<br>
Here is my code  </p>

<pre><code>static Cipher cipher;

static final int[] ENC_MODE = {Cipher.ENCRYPT_MODE, Cipher.DECRYPT_MODE, Cipher.ENCRYPT_MODE};

public static void main(String[] args) throws Exception {

    String text = ""this is my text"";
    cipher = Cipher.getInstance(""DES"");
    SecretKey key1 = KeyGenerator.getInstance(""DES"").generateKey();
    SecretKey key2 = KeyGenerator.getInstance(""DES"").generateKey();

    String cipherText = enc(text, key1, key2);



}

private static String enc(String plainText, SecretKey key1, SecretKey key2) throws Exception{
    byte[] textBytes = null;
    String encText = plainText;

    for(int i=0; i&lt;3; i++){ 
        if (ENC_MODE[i] == Cipher.ENCRYPT_MODE){
            cipher.init(ENC_MODE[i], key1);
            textBytes = encText.getBytes(""UTF8"");
            textBytes = cipher.doFinal(textBytes);
            encText = Base64.getEncoder().encodeToString(textBytes);

        }else if(ENC_MODE[i] == Cipher.DECRYPT_MODE){
            cipher.init(ENC_MODE[i], key2);
            textBytes = cipher.doFinal(textBytes);  //Error Line
            encText = new String(textBytes, ""UTF8"");
        }

        System.out.println(""loop= "" + i +"" ""+encText);
    }
    return encText;
}
</code></pre>

<p>my problem is that in the second loop (decryption with key2) I'm always getting this exception
<code>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded</code>
I looked for this problem everywhere, but I didn't find a solution!<br>
Thank you.</p>
","","20","<java><encryption><des><3des><tripledes>","1","","0","2015-04-11 22:26:22","","0","2","","","","2015-04-11 22:26:22","2015-04-11 22:37:35"
"56368220","Is setting ALL to Ciphers list for SSL Profile in NETSCALAR 12 58.15 bad?","<p>When Default has been configured in NETSCALAR SSL Profile, the other system couldn't communicate. 
So, It has been changed to ALL.</p>

<p>NETSCALAR 12 58.15</p>

<p>TLS 1.2 is enabled in default Profile. </p>

<p>But the server is a legacy system, so there were handshake errors.</p>

<p>So, SSL Profile Ciphers List has been updated to ALL instead of Default or customized Ciphers suite.</p>

<p>will select 'ALL'  for Ciphers list weakens the system?</p>

<p>Netscalar 12 57.x and above disables DES by default, so will allow ALL weakens the system?
The system in intranet-based and don't face the internet.</p>
","","18","<ssl><default><tls1.2><des><rc4-cipher>","0","","0","2019-05-31 00:09:15","","1","","3284149","","2019-05-31 00:09:15","2019-05-29 20:42:22",""
"55362898","DES program that encrypt and decrypt files","<p>I am doing a DES program so the user can choose a file to encrypt then produce two files one for the encrypted text and one for the key
It's working fine
The problem is when we want to decrypt the user choose the encrypted file, and the key should be retrieve from the folder it's saved I use this by putting the whole key path<br>
C:\Users\name\Documents\NetBeansProjects\DESCombine\key.txt
The problem is each time I need to run the program on a different machine I need to change the whole path</p>

<p>How to make it flexible, so we can implement from different machines without changing</p>
","","14","<file><path><des>","0","","0","2019-03-26 17:20:59","","0","","","","","2019-03-26 17:20:59",""
"55750271","how I can transform a folder (with all its content) into a file with string strin in python-2.7?","<p>I am looking to pass a folder into a string of text (something like an image based on base64) to be able to encrypt it with the DES algorithm, or if there is a more efficient way I would also serve much</p>
","","12","<python-2.7><des>","0","","0","2019-04-18 16:30:40","","1","","","","","2019-04-18 16:30:40",""
post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"20770072","AES/CBC/PKCS5Padding vs AES/CBC/PKCS7Padding with 256 key size performance java","<p>I am currently using <code>AES/CBC/PKCS5Padding</code> for encrypting files in Java with <strong>256 bytes</strong> key size, but while searching I found on stackexchange <a href=""https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding"">PKCS#5-PKCS#7 Padding</a> and  it is mentioned,</p>

<blockquote>
  <p>PKCS#5 padding is a subset of PKCS#7 padding for 8 byte block sizes</p>
</blockquote>

<p>So I want to know  </p>

<ol>
<li>Will the performance of <code>AES/CBC/PKCS7Padding</code> will be better then <code>AES/CBC/PKCS5Padding</code> for the above configuration?</li>
<li>How can we configure the block size in Java as it is mentioned

<blockquote>
  <p>PKCS#7 padding would work for any block size from 1 to 255 bytes.</p>
</blockquote></li>
</ol>

<p>My sample code is,</p>

<pre><code>SecureRandom rnd = new SecureRandom();
IvParameterSpec iv = new IvParameterSpec(rnd.generateSeed(16));

KeyGenerator generator = KeyGenerator.getInstance(""AES"");
generator.init(256);
SecretKey k = generator.generateKey();

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
c.init(Cipher.ENCRYPT_MODE, k, iv);
</code></pre>
","<p>The block size is a property of the used cipher algorithm. For AES it is always 16 bytes.</p>

<p>So strictly speaking, PKCS5Padding cannot be used with AES since it is defined only for a block size of 8 bytes. I assume, AES/CBC/PKCS5Padding is interpreted as AES/CBC/PKCS7Padding internally.</p>

<p>The only difference between these padding schemes is that PKCS7Padding has the block size as a parameter, while for PKCS5Padding it is fixed at 8 bytes. When the Block size is 8 bytes they do exactly the same.</p>
","69899","<java><encryption><aes><pkcs#7><pkcs#5>","21","34","1","2017-02-14 04:58:03","20770158","0","16","-1","","2017-04-13 12:48:18","2013-12-25 07:10:52",""
"15814569","Import PKCS7 (Chained Certificate) using KeyTool command to JKS","<p>I have a CA issued CERT in PKCS#7 format. It has certificates (chained) within it.
Keytool does not recognize the PKCS7 format. I have tried OpenSSL tool to convert PKCS7 format certificate to PEM format and it fails. I receive an error message ""Unable to load PKCS7 object"".</p>

<p>How do I import the PKCS7 cert chain to my JKS?</p>
","<p>As you can read in the <a href=""http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html#importCertCmd"">keytool reference</a> for <strong><em>-importcert</em></strong> command:</p>

<blockquote>
  <p>Reads the certificate or certificate chain (where the latter is supplied in a PKCS#7 formatted reply) from the file cert_file, and stores it in the keystore entry identified by alias. If no file is given, the certificate or PKCS#7 reply is read from stdin.</p>
  
  <p>keytool can import X.509 v1, v2, and v3 certificates, and PKCS#7 formatted certificate chains consisting of certificates of that type.</p>
</blockquote>

<p>Try to import the PKCS7 cert as it is.</p>

<p>Though, it doesn't always work. If you have problems, try to do the following (using OpenSSL):</p>

<ol>
<li><p>Print all the certs it contains to a PEM file </p>

<p><code>OpenSSL&gt; pkcs7 -in initial_file.p7b -inform DER -print_certs -outform PEM -out certs_chain.pem</code></p></li>
<li><p>Open the new PEM file (<strong>certs_chain.pem</strong>) with an editor and delete everything outside <code>-----BEGIN CERTIFICATE-----</code> and <code>-----END CERTIFICATE-----</code> boundaries (keep only the encoded content within the boundaries, the certificates themselves) and save it.</p></li>
</ol>

<p>Now keytool should not have problems to import your cert, using <strong>certs_chain.pem</strong> as <code>cert_file</code></p>
","54829","<certificate><keytool><pkcs#7><jks>","8","9","2","2014-12-12 00:20:30","","0","1","64046","","2014-12-12 00:20:30","2013-04-04 14:48:07",""
"15814569","Import PKCS7 (Chained Certificate) using KeyTool command to JKS","<p>I have a CA issued CERT in PKCS#7 format. It has certificates (chained) within it.
Keytool does not recognize the PKCS7 format. I have tried OpenSSL tool to convert PKCS7 format certificate to PEM format and it fails. I receive an error message ""Unable to load PKCS7 object"".</p>

<p>How do I import the PKCS7 cert chain to my JKS?</p>
","<p>Another approach is to use IE to create an X.509 certificate. You can find the steps in my article on doing SSL between WLS and IIS at <a href=""http://techblog.fywservices.com/2012/10/establishing-weblogic-server-https-trust-of-iis-using-a-microsoft-local-certificate-authority/"" rel=""nofollow"">http://techblog.fywservices.com/2012/10/establishing-weblogic-server-https-trust-of-iis-using-a-microsoft-local-certificate-authority/</a></p>
","54829","<certificate><keytool><pkcs#7><jks>","8","0","2","2014-12-12 00:20:30","","0","1","64046","","2014-12-12 00:20:30","2013-04-04 14:48:07",""
"7314901","How to add/remove PKCS7 padding from an AES encrypted string?","<p>I'm trying to encrypt/decrypt a string using 128 bit AES encryption (ECB). What I want to know is how I can add/remove the PKCS7 padding to it. It seems that the Mcrypt extension can take care of the encryption/decryption, but the padding has to be added/removed manually.</p>

<p>Any ideas?</p>
","<p>Let's see. PKCS #7 is described in RFC 5652 (Cryptographic Message Syntax).</p>

<p>The padding scheme itself is given in section <a href=""http://tools.ietf.org/html/rfc5652#section-6.3"" rel=""noreferrer"">6.3.  Content-encryption Process</a>. It essentially says: append that many bytes as needed to fill the given block size (but at least one), and each of them should have the padding length as value.</p>

<p>Thus, looking at the last decrypted byte we know how many bytes to strip off. (One could also check that they all have the same value.)</p>

<p>I could now give you a pair of PHP functions to do this, but my PHP is a bit rusty. So either do this yourself (then feel free to edit my answer to add it in), or have a look at the <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php#usernotes"" rel=""noreferrer"">user-contributed notes</a> to the mcrypt documentation - quite some of them are about padding and provide an implementation of PKCS #7 padding.</p>

<hr>

<p>So, let's look on the <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php#105173"" rel=""noreferrer"">first note there</a> in detail:</p>

<pre><code>&lt;?php

function encrypt($str, $key)
 {
     $block = mcrypt_get_block_size('des', 'ecb');
</code></pre>

<p>This gets the block size of the used algorithm. In your case, you would use <code>aes</code> or <code>rijndael_128</code> instead of <code>des</code>, I suppose (I didn't test it). (Instead, you could simply take <code>16</code> here for AES, instead of invoking the function.)</p>

<pre><code>     $pad = $block - (strlen($str) % $block);
</code></pre>

<p>This calculates the padding size. <a href=""http://de3.php.net/manual/en/function.strlen.php"" rel=""noreferrer""><code>strlen($str)</code></a> is the length of your data (in bytes), <code>% $block</code> gives the remainder modulo <code>$block</code>, i.e. the number of data bytes in the last block. <code>$block - ...</code> thus gives the number of bytes needed to fill this last block (this is now a number between <code>1</code> and <code>$block</code>, inclusive).</p>

<pre><code>     $str .= str_repeat(chr($pad), $pad);
</code></pre>

<p><a href=""http://de3.php.net/manual/en/function.str-repeat.php"" rel=""noreferrer""><code>str_repeat</code></a> produces a string consisting of a repetition of the same string, here a repetition of the <a href=""http://de3.php.net/manual/en/function.chr.php"" rel=""noreferrer"">character given by</a> <code>$pad</code>, <code>$pad</code> times, i.e. a string of length <code>$pad</code>, filled with <code>$pad</code>.
<code>$str .= ...</code> appends this padding string to the original data.</p>

<pre><code>     return mcrypt_encrypt(MCRYPT_DES, $key, $str, MCRYPT_MODE_ECB);
</code></pre>

<p>Here is the encryption itself. Use <a href=""http://de3.php.net/manual/en/mcrypt.ciphers.php"" rel=""noreferrer""><code>MCRYPT_RIJNDAEL_128</code></a> instead of <code>MCRYPT_DES</code>.</p>

<pre><code> }
</code></pre>

<p>Now the other direction:</p>

<pre><code> function decrypt($str, $key)
 {   
     $str = mcrypt_decrypt(MCRYPT_DES, $key, $str, MCRYPT_MODE_ECB);
</code></pre>

<p>The decryption. (You would of course change the algorithm, as above). $str is now the decrypted string, including the padding.</p>

<pre><code>     $block = mcrypt_get_block_size('des', 'ecb');
</code></pre>

<p>This is again the block size. (See above.)</p>

<pre><code>     $pad = ord($str[($len = strlen($str)) - 1]);
</code></pre>

<p>This looks a bit strange. Better write it in multiple steps:</p>

<pre><code>    $len = strlen($str);
    $pad = ord($str[$len-1]);
</code></pre>

<p><code>$len</code> is now the length of the padded string, and <code>$str[$len - 1]</code> is the last character of this string. <a href=""http://de3.php.net/manual/en/function.ord.php"" rel=""noreferrer""><code>ord</code></a> converts this to a number. Thus <code>$pad</code> is the number which we previously used as the fill value for the padding, and this is the padding length.</p>

<pre><code>     return substr($str, 0, strlen($str) - $pad);
</code></pre>

<p>So now we cut off the last <code>$pad</code> bytes from the string. (Instead of <code>strlen($str)</code> we could also write <code>$len</code> here: <code>substr($str, 0, $len - $pad)</code>.).</p>

<pre><code> }

?&gt;
</code></pre>

<p>Note that instead of using <code>substr($str, $len - $pad)</code>, one can also write <code>substr($str, -$pad)</code>, as the <code>substr</code> function in PHP has a special-handling for negative operands/arguments, to count from the end of the string. (I don't know if this is more or less efficient than getting the length first and and calculating the index manually.)</p>

<p>As said before and noted in the comment by rossum, instead of simply stripping off the padding like done here, you should check that it is correct - i.e. look at <code>substr($str, $len - $pad)</code>, and check that all its bytes are <code>chr($pad)</code>. This serves as a slight check against corruption (although this check is more effective if you use a chaining mode instead of ECB, and is not a replacement for a real MAC).</p>

<hr>

<p>(And still, tell your client they should think about changing to a more secure mode than ECB.)</p>
","35341","<php><encryption><aes><mcrypt><pkcs#7>","17","55","3","2017-12-22 10:42:11","7324793","4","16","49153","","2011-09-07 02:27:42","2011-09-06 04:23:54",""
"7314901","How to add/remove PKCS7 padding from an AES encrypted string?","<p>I'm trying to encrypt/decrypt a string using 128 bit AES encryption (ECB). What I want to know is how I can add/remove the PKCS7 padding to it. It seems that the Mcrypt extension can take care of the encryption/decryption, but the padding has to be added/removed manually.</p>

<p>Any ideas?</p>
","<p>I've created two methods to perform the padding and unpadding. The functions are documented using <code>phpdoc</code> and require PHP 5. As you will notice the unpad function contains a lot of exception handling, generating not less than 4 different messages for each possible error.</p>

<p>To get to the block size for PHP mcrypt, you can use <a href=""http://php.net/manual/en/function.mcrypt-get-block-size.php"" rel=""nofollow noreferrer""><code>mcrypt_get_block_size</code></a>, which also defines the block size to be in bytes instead of bits.</p>

<pre><code>/**
 * Right-pads the data string with 1 to n bytes according to PKCS#7,
 * where n is the block size.
 * The size of the result is x times n, where x is at least 1.
 * 
 * The version of PKCS#7 padding used is the one defined in RFC 5652 chapter 6.3.
 * This padding is identical to PKCS#5 padding for 8 byte block ciphers such as DES.
 *
 * @param string $plaintext the plaintext encoded as a string containing bytes
 * @param integer $blocksize the block size of the cipher in bytes
 * @return string the padded plaintext
 */
function pkcs7pad($plaintext, $blocksize)
{
    $padsize = $blocksize - (strlen($plaintext) % $blocksize);
    return $plaintext . str_repeat(chr($padsize), $padsize);
}

/**
 * Validates and unpads the padded plaintext according to PKCS#7.
 * The resulting plaintext will be 1 to n bytes smaller depending on the amount of padding,
 * where n is the block size.
 *
 * The user is required to make sure that plaintext and padding oracles do not apply,
 * for instance by providing integrity and authenticity to the IV and ciphertext using a HMAC.
 *
 * Note that errors during uppadding may occur if the integrity of the ciphertext
 * is not validated or if the key is incorrect. A wrong key, IV or ciphertext may all
 * lead to errors within this method.
 *
 * The version of PKCS#7 padding used is the one defined in RFC 5652 chapter 6.3.
 * This padding is identical to PKCS#5 padding for 8 byte block ciphers such as DES.
 *
 * @param string padded the padded plaintext encoded as a string containing bytes
 * @param integer $blocksize the block size of the cipher in bytes
 * @return string the unpadded plaintext
 * @throws Exception if the unpadding failed
 */
function pkcs7unpad($padded, $blocksize)
{
    $l = strlen($padded);

    if ($l % $blocksize != 0) 
    {
        throw new Exception(""Padded plaintext cannot be divided by the block size"");
    }

    $padsize = ord($padded[$l - 1]);

    if ($padsize === 0)
    {
        throw new Exception(""Zero padding found instead of PKCS#7 padding"");
    }    

    if ($padsize &gt; $blocksize)
    {
        throw new Exception(""Incorrect amount of PKCS#7 padding for blocksize"");
    }

    // check the correctness of the padding bytes by counting the occurance
    $padding = substr($padded, -1 * $padsize);
    if (substr_count($padding, chr($padsize)) != $padsize)
    {
        throw new Exception(""Invalid PKCS#7 padding encountered"");
    }

    return substr($padded, 0, $l - $padsize);
}
</code></pre>

<p>This does not invalidate the answer of Pa≈≠lo Ebermann in any way, it's basically the same answer in code &amp; phpdoc instead of as description.</p>

<hr>

<p>Note that returning a padding error to an attacker might result in a <em>padding oracle attack</em> which completely breaks CBC (when CBC is used instead of ECB or a secure authenticated cipher).</p>
","35341","<php><encryption><aes><mcrypt><pkcs#7>","17","8","3","2017-12-22 10:42:11","7324793","4","16","49153","","2011-09-07 02:27:42","2011-09-06 04:23:54",""
"7314901","How to add/remove PKCS7 padding from an AES encrypted string?","<p>I'm trying to encrypt/decrypt a string using 128 bit AES encryption (ECB). What I want to know is how I can add/remove the PKCS7 padding to it. It seems that the Mcrypt extension can take care of the encryption/decryption, but the padding has to be added/removed manually.</p>

<p>Any ideas?</p>
","<p>Just call the following function after you decrypt the data</p>

<pre><code>function removePadding($decryptedText){
    $strPad = ord($decryptedText[strlen($decryptedText)-1]);
    $decryptedText= substr($decryptedText, 0, -$strPad);
    return $decryptedText;
}
</code></pre>
","35341","<php><encryption><aes><mcrypt><pkcs#7>","17","0","3","2017-12-22 10:42:11","7324793","4","16","49153","","2011-09-07 02:27:42","2011-09-06 04:23:54",""
"29232705","Encrypt text to AES/CBC/PKCS7Padding","<p>I am developing a web application to encrypt some texts with java 6. </p>

<p>The encrypted that I have to do is a AES (Rijndael) in CBC mode with PKCS7 padding and a 128-bit key.</p>

<p>I saw an article that explains how to encrypt in the same way I have to do, but with PKCS5 padding.</p>

<p>The link of the article is here:</p>

<p><a href=""https://bit502.wordpress.com/2014/06/27/codigo-java-encriptar-y-desencriptar-texto-usando-el-algoritmo-aes-con-cifrado-por-bloques-cbc-de-128-bits/"" rel=""noreferrer"">https://bit502.wordpress.com/2014/06/27/codigo-java-encriptar-y-desencriptar-texto-usando-el-algoritmo-aes-con-cifrado-por-bloques-cbc-de-128-bits/</a></p>

<p>I change </p>

<pre><code>private final static String cI = ""AES/CBC/PKCS5Padding"";
</code></pre>

<p>To</p>

<pre><code>private final static String cI = ""AES/CBC/PKCS7Padding"";
</code></pre>

<p>But Java couldn't find a provider for this.</p>

<p>Could someone tell me how I have to do?</p>
","<p>The Java specification list a number of encryption modes (and paddings) that needs to be supported. <code>PKCS7Padding</code> is not included.  </p>

<p>These are the AES/CBC modes any Java implementation must support.</p>

<ul>
<li>AES/CBC/NoPadding (128 bit key)</li>
<li>AES/CBC/PKCS5Padding (128 bit key)</li>
</ul>

<p>(See <a href=""https://stackoverflow.com/questions/10935068/what-are-the-cipher-padding-strings-in-java/10935308#10935308"">this answer</a> for more information)</p>

<p><a href=""http://www.bouncycastle.org"" rel=""nofollow noreferrer"">Bouncy Castle</a> does however have what you need.</p>
","30261","<java><encryption><aes><pkcs#7>","8","2","3","2017-05-08 22:56:05","29234136","1","3","1816580","","2015-03-24 19:21:27","2015-03-24 12:30:45",""
"29232705","Encrypt text to AES/CBC/PKCS7Padding","<p>I am developing a web application to encrypt some texts with java 6. </p>

<p>The encrypted that I have to do is a AES (Rijndael) in CBC mode with PKCS7 padding and a 128-bit key.</p>

<p>I saw an article that explains how to encrypt in the same way I have to do, but with PKCS5 padding.</p>

<p>The link of the article is here:</p>

<p><a href=""https://bit502.wordpress.com/2014/06/27/codigo-java-encriptar-y-desencriptar-texto-usando-el-algoritmo-aes-con-cifrado-por-bloques-cbc-de-128-bits/"" rel=""noreferrer"">https://bit502.wordpress.com/2014/06/27/codigo-java-encriptar-y-desencriptar-texto-usando-el-algoritmo-aes-con-cifrado-por-bloques-cbc-de-128-bits/</a></p>

<p>I change </p>

<pre><code>private final static String cI = ""AES/CBC/PKCS5Padding"";
</code></pre>

<p>To</p>

<pre><code>private final static String cI = ""AES/CBC/PKCS7Padding"";
</code></pre>

<p>But Java couldn't find a provider for this.</p>

<p>Could someone tell me how I have to do?</p>
","<p>Java only provides PKCS#5 padding, but it is the same as PKCS#7 padding. See this question on Crypto.SE:</p>

<p><a href=""https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding"">What is the difference between PKCS#5 padding and PKCS#7 padding</a></p>

<p>They are interchangeable for the common block ciphers like AES and DES.</p>
","30261","<java><encryption><aes><pkcs#7>","8","18","3","2017-05-08 22:56:05","29234136","1","3","1816580","","2015-03-24 19:21:27","2015-03-24 12:30:45",""
"29232705","Encrypt text to AES/CBC/PKCS7Padding","<p>I am developing a web application to encrypt some texts with java 6. </p>

<p>The encrypted that I have to do is a AES (Rijndael) in CBC mode with PKCS7 padding and a 128-bit key.</p>

<p>I saw an article that explains how to encrypt in the same way I have to do, but with PKCS5 padding.</p>

<p>The link of the article is here:</p>

<p><a href=""https://bit502.wordpress.com/2014/06/27/codigo-java-encriptar-y-desencriptar-texto-usando-el-algoritmo-aes-con-cifrado-por-bloques-cbc-de-128-bits/"" rel=""noreferrer"">https://bit502.wordpress.com/2014/06/27/codigo-java-encriptar-y-desencriptar-texto-usando-el-algoritmo-aes-con-cifrado-por-bloques-cbc-de-128-bits/</a></p>

<p>I change </p>

<pre><code>private final static String cI = ""AES/CBC/PKCS5Padding"";
</code></pre>

<p>To</p>

<pre><code>private final static String cI = ""AES/CBC/PKCS7Padding"";
</code></pre>

<p>But Java couldn't find a provider for this.</p>

<p>Could someone tell me how I have to do?</p>
","<p>Try this method</p>

<pre><code>String KEY_AES = ""**************"";
public String encrypt(String value) {
        try {
            byte[] key = KEY_AES.getBytes(""UTF-8"");
            byte[] ivs = KEY_AES.getBytes(""UTF-8"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(ivs);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, paramSpec);
            return Base64.encodeToString(cipher.doFinal(value.getBytes(""UTF-8"")), Base64.DEFAULT);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre>
","30261","<java><encryption><aes><pkcs#7>","8","3","3","2017-05-08 22:56:05","29234136","1","3","1816580","","2015-03-24 19:21:27","2015-03-24 12:30:45",""
"19635499","Not able to load P7B file into keystore file","<p>I received a new certificate in <code>crt</code> / <code>cert</code> format. When I open this file in a text editor they added the complete certificate chain to this file. Each certificate starts with:</p>

<pre><code>-----BEGIN CERTIFICATE-----
</code></pre>

<p>And ends with:</p>

<pre><code>-----END CERTIFICATE-----
</code></pre>

<p>There are no empty lines in between. Since I am not keen with <code>openssl</code>, I opened up the certificate into Windows and exported the certificate with the complete chain in <code>PKCS#7</code> format (test.p7b). When I open this file all looks fine in Windows and the root, intermediate and the certificate are all their in the chain.</p>

<p>When I put the file <code>test.p7b</code> on the server and try to import this with <code>keytool</code> as follows:</p>

<pre><code>keytool -import -trustcacerts -alias my.domain.com -keystore my.domain.keystore -keypass changeme -storepass changeme -file test.p7b
</code></pre>

<p>I get the following error:</p>

<pre><code>keytool error: java.lang.Exception: Input not an X.509 certificate
</code></pre>

<p>When I test the P7B file I also get errors:</p>

<pre><code>bash-4.1$ openssl x509 -in test.p7b -text
unable to load certificate
140009984849736:error:0906D06C:PEM routines:PEM_read_bio:no start line:pem_lib.c:698:Expecting: TRUSTED CERTIFICATE
</code></pre>

<p>or:</p>

<pre><code>bash-4.1$ openssl x509 -in test.p7b -inform DER -text
unable to load certificate
140396587853640:error:0D0680A8:asn1 encoding routines:ASN1_CHECK_TLEN:wrong tag:tasn_dec.c:1320:
140396587853640:error:0D07803A:asn1 encoding routines:ASN1_ITEM_EX_D2I:nested asn1 error:tasn_dec.c:382:Type=X509_CINF
140396587853640:error:0D08303A:asn1 encoding routines:ASN1_TEMPLATE_NOEXP_D2I:nested asn1 error:tasn_dec.c:752:Field=cert_info, Type=X509
</code></pre>

<p>Can someone help me out?</p>
","<p>When importing a certificate chain, keytool expects the certificates to be loaded in DER form. You can create such a bundle with openssl:</p>

<p>1 - Convert all certificates in DER format </p>

<pre><code>openssl x509 -in certificate.pem -outform DER -out certificate.crt
</code></pre>

<p>2 - Concat all DER certificates into one single file</p>

<pre><code>cat cert1.crt cert2.crt ... &gt; chain.der
</code></pre>

<p>3 - Now you can import the chain into your keystore with keytool </p>

<pre><code>keytool -importcert -trustcacerts -alias &lt;myalias&gt; -file chain.der -keystore keystore.jks -storepass &lt;mypassword&gt;
</code></pre>

<p>Note that <code>myalias</code> <strong>MUST be the same</strong> as the one used when the key was generated.</p>

<p>4 - verify that the chain was successfully imported</p>

<pre><code>keytool -list -v -keystore keystore.jks
</code></pre>
","24421","<openssl><certificate><keystore><keytool><pkcs#7>","6","4","1","2013-10-28 14:20:52","19637262","2","5","1800695","","2013-10-28 13:55:07","2013-10-28 13:00:17",""
"12426064","How to sign pdf in Java using pdfbox","<p>I am trying to sign pdf using pdfbox libraries.
I have stuck now and realy need a help.</p>

<p>This is my code:</p>

<pre class=""lang-java prettyprint-override""><code>private static void signPdf(PDDocument document) throws Exception 
{
    PDSignature sig = new PDSignature();
    sig.setFilter(COSName.ADOBE_PPKLITE);
    sig.setSubFilter(COSName.ADBE_PKCS7_DETACHED);
    sig.setByteRange(new int[] {'a','a','a','a'});
    sig.setContents(new byte[]{(byte) 23, (byte) 23, (byte) 23, (byte) 23});

    SignatureOptions options = new SignatureOptions();

    document.addSignature(sig, new SignatureInterface() {
        public byte[] sign(InputStream content)
                throws SignatureException, IOException       {        
             //this should be made MD5 checksum?           
            return new byte[]{(byte) 'a', (byte) 'a', (byte) 'a', (byte) 'a'};
        }
    }, options);
}
</code></pre>

<p>Then Iam saving my pdf, but:
1) I have noticed that sign method is never called
2) Where should I attach certyficate? in sign method?</p>

<p>pdf:</p>

<pre><code>/Type /Sig
/Filter /Adobe.PPKLite
/SubFilter /adbe.pkcs7.sha1
/Contents &lt;0000000000. a lot of zeros..000&gt;
/ByteRange [0 1000000000 1000000000 1000000000]
</code></pre>

<p>I think that i miss something, but documentation says nothing about how to sign a file.</p>

<p>Tahnks in advance JC.</p>

<p>@Ed</p>

<p>Here is how I save my pdf:</p>

<pre class=""lang-java prettyprint-override""><code>public static void saveFile(COSDocument doc, String out)
        throws IOException, COSVisitorException {  
    java.io.OutputStream os = null;  
    COSWriter writer = null;  
    try {
        os = new java.io.FileOutputStream(out);
        writer = new COSWriter(os);
        writer.write(doc);
    } finally {
        if (os != null) {
            os.close();
        }
        if (writer != null) {
            writer.close();
        }
    }
}
</code></pre>
","<p>The linked <strong>PDFBox-SignExample.zip</strong> is out of date. Please use this sample instead:</p>

<p><a href=""https://svn.apache.org/repos/asf/pdfbox/trunk/examples/src/main/java/org/apache/pdfbox/examples/signature/CreateSignature.java"" rel=""noreferrer"">https://svn.apache.org/repos/asf/pdfbox/trunk/examples/src/main/java/org/apache/pdfbox/examples/signature/CreateSignature.java</a></p>

<p>It is better documented and kept up-to-date.</p>
","24205","<pdf><certificate><sign><pdfbox><pkcs#7>","12","8","1","2018-02-15 09:32:10","","3","4","322166","","2018-02-15 09:32:10","2012-09-14 13:57:25",""
"4508749","AES with padding pkcs7 c++ code","<p>I need an example of string encryption (in C++ -> I'm working on linux-Ubuntu) with aes-cbc256 and a padding: PKCS7
Please help.</p>

<hr>

<p>For the following code how can I set the IV to 0 and set the key value to a string value? I would also like to add the pkcs7 padding. I'm using the crypto++ lib (in Linux)</p>

<pre><code>// Driver.cpp   
//      

#include ""stdafx.h""    
#include ""cryptopp/dll.h""    
#include ""cryptopp/default.h""    
#include ""crypto++/osrng.h""    
using CryptoPP::AutoSeededRandomPool;    

#include &lt;iostream&gt;    
using std::cout;    
using std::cerr;       

#include &lt;string&gt;    
using std::string;       

#include ""crypto++/cryptlib.h""    
using CryptoPP::Exception;        

#include ""crypto++/hex.h""    
using CryptoPP::HexEncoder;    
using CryptoPP::HexDecoder;        

#include ""crypto++/filters.h""    
using CryptoPP::StringSink;    
using CryptoPP::StringSource;    
using CryptoPP::StreamTransformationFilter;        

#include ""crypto++/aes.h""    
using CryptoPP::AES;       

#include ""crypto++/ccm.h""    
using CryptoPP::CBC_Mode;       

#include ""assert.h""        

int main(int argc, char* argv[])    
{    
    AutoSeededRandomPool prng;        

    byte key[ AES::DEFAULT_KEYLENGTH ];    
    prng.GenerateBlock( key, sizeof(key) );        

    byte iv[ AES::BLOCKSIZE];    
    iv[AES::BLOCKSIZE] = 0;    
    //prng.GenerateBlock(iv,  sizeof(iv) );        

    string plain = ""CBC Mode Test"";    
    string cipher, encoded, recovered;       

    // Pretty print key    
    encoded.clear();    
    StringSource( key, sizeof(key), true,    
                  new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;        

    // Pretty print iv    
    encoded.clear();

    StringSource( iv, sizeof(iv), true,    
        new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;       

    /*********************************\
    \*********************************/

    try    
    {    
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;            
        CBC_Mode&lt; AES &gt;::Encryption e;    
        e.SetKeyWithIV( key, sizeof(key), iv );     

        // The StreamTransformationFilter adds padding    
        //  as required. ECB and CBC Mode must be padded    
        //  to the block size of the cipher.    
        StringSource( plain, true,     
            new StreamTransformationFilter( e,    
                new StringSink( cipher )    
            ) // StreamTransformationFilter          
        ); // StringSource    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    // Pretty print    
    encoded.clear();    
    StringSource( cipher, true,    
        new HexEncoder(    
            new StringSink( encoded )    
        ) // HexEncoder    
    ); // StringSource    
    cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;    

    /*********************************\    
    \*********************************/    

    try    
    {    
        CBC_Mode&lt; AES &gt;::Decryption d;    
        d.SetKeyWithIV( key, sizeof(key), iv );    

        // The StreamTransformationFilter removes    
        //  padding as required.    
        StringSource s( cipher, true,     
            new StreamTransformationFilter( d,    
                new StringSink( recovered )    
            ) // StreamTransformationFilter    
        ); // StringSource    

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    assert( plain == recovered );    

    return 0;    
}
</code></pre>
","<p>look also at my answer to <a href=""https://stackoverflow.com/questions/4508646/rijndael-alternative-for-linux"">this question</a></p>

<p>I suggest checking out <a href=""http://www.cryptopp.com"" rel=""nofollow noreferrer"">cryptopp</a>. Here's a code sample:</p>

<pre><code>CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor;
byte* key;
size_t keylen;
// ... acquire key

encryptor.SetKey( key, keylen );

std::string input;
std::string result;
// read input ...

StringSource( input, true,
       new StreamTransformationFilter( encryptor, new StringSink( result ),
     StreamTransformationFilter::PKCS_PADDING));
</code></pre>

<p>The values for padding mode in <code>StreamTransformationFilter</code> can be:</p>

<pre><code>BlockPaddingScheme { 
  NO_PADDING, ZEROS_PADDING, PKCS_PADDING, ONE_AND_ZEROS_PADDING, 
  DEFAULT_PADDING 
}
</code></pre>

<p>EDIT: replaced the padding mode in the sample to pkcs</p>
","19279","<c++><crypto++><pkcs#7>","2","1","2","2016-08-12 21:46:19","","4","2","608639","","2016-08-12 21:46:19","2010-12-22 11:34:58",""
"4508749","AES with padding pkcs7 c++ code","<p>I need an example of string encryption (in C++ -> I'm working on linux-Ubuntu) with aes-cbc256 and a padding: PKCS7
Please help.</p>

<hr>

<p>For the following code how can I set the IV to 0 and set the key value to a string value? I would also like to add the pkcs7 padding. I'm using the crypto++ lib (in Linux)</p>

<pre><code>// Driver.cpp   
//      

#include ""stdafx.h""    
#include ""cryptopp/dll.h""    
#include ""cryptopp/default.h""    
#include ""crypto++/osrng.h""    
using CryptoPP::AutoSeededRandomPool;    

#include &lt;iostream&gt;    
using std::cout;    
using std::cerr;       

#include &lt;string&gt;    
using std::string;       

#include ""crypto++/cryptlib.h""    
using CryptoPP::Exception;        

#include ""crypto++/hex.h""    
using CryptoPP::HexEncoder;    
using CryptoPP::HexDecoder;        

#include ""crypto++/filters.h""    
using CryptoPP::StringSink;    
using CryptoPP::StringSource;    
using CryptoPP::StreamTransformationFilter;        

#include ""crypto++/aes.h""    
using CryptoPP::AES;       

#include ""crypto++/ccm.h""    
using CryptoPP::CBC_Mode;       

#include ""assert.h""        

int main(int argc, char* argv[])    
{    
    AutoSeededRandomPool prng;        

    byte key[ AES::DEFAULT_KEYLENGTH ];    
    prng.GenerateBlock( key, sizeof(key) );        

    byte iv[ AES::BLOCKSIZE];    
    iv[AES::BLOCKSIZE] = 0;    
    //prng.GenerateBlock(iv,  sizeof(iv) );        

    string plain = ""CBC Mode Test"";    
    string cipher, encoded, recovered;       

    // Pretty print key    
    encoded.clear();    
    StringSource( key, sizeof(key), true,    
                  new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;        

    // Pretty print iv    
    encoded.clear();

    StringSource( iv, sizeof(iv), true,    
        new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;       

    /*********************************\
    \*********************************/

    try    
    {    
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;            
        CBC_Mode&lt; AES &gt;::Encryption e;    
        e.SetKeyWithIV( key, sizeof(key), iv );     

        // The StreamTransformationFilter adds padding    
        //  as required. ECB and CBC Mode must be padded    
        //  to the block size of the cipher.    
        StringSource( plain, true,     
            new StreamTransformationFilter( e,    
                new StringSink( cipher )    
            ) // StreamTransformationFilter          
        ); // StringSource    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    // Pretty print    
    encoded.clear();    
    StringSource( cipher, true,    
        new HexEncoder(    
            new StringSink( encoded )    
        ) // HexEncoder    
    ); // StringSource    
    cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;    

    /*********************************\    
    \*********************************/    

    try    
    {    
        CBC_Mode&lt; AES &gt;::Decryption d;    
        d.SetKeyWithIV( key, sizeof(key), iv );    

        // The StreamTransformationFilter removes    
        //  padding as required.    
        StringSource s( cipher, true,     
            new StreamTransformationFilter( d,    
                new StringSink( recovered )    
            ) // StreamTransformationFilter    
        ); // StringSource    

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    assert( plain == recovered );    

    return 0;    
}
</code></pre>
","<p>OpenSSL uses PKCS7 padding by default.  This padding means when your data is not a multiple of the block size, you pad <em>n</em> bytes of the value <em>n</em>, where <em>n</em> is however many bytes you need to get to the block size.  AES's block size is 16.</p>

<p>Here's an example on how to encrypt a string using AES256-cbc with OpenSSL.  The OpenSSL documentation also has <a href=""http://www.openssl.org/docs/crypto/EVP_EncryptInit.html"" rel=""nofollow"">examples</a>, although they use different ciphers.  This example does no error checking.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;

#include &lt;openssl/evp.h&gt;

int main()
{
    // ctx holds the state of the encryption algorithm so that it doesn't
    // reset back to its initial state while encrypting more than 1 block.
    EVP_CIPHER_CTX ctx;
    EVP_CIPHER_CTX_init(&amp;ctx);

    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                   0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                   0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
    unsigned char iv[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    assert(sizeof(key) == 32);  // AES256 key size
    assert(sizeof(iv) == 16);   // IV is always the AES block size

    // If data isn't a multiple of 16, the default behavior is to pad with
    // n bytes of value n, where n is the number of padding bytes required
    // to make data a multiple of the block size.  This is PKCS7 padding.
    // The output then will be a multiple of the block size.
    std::string plain(""encrypt me"");
    std::vector&lt;unsigned char&gt; encrypted;
    size_t max_output_len = plain.length() + 16 - (plain.length() % 16);
    encrypted.resize(max_output_len);

    // Enc is 1 to encrypt, 0 to decrypt, or -1 (see documentation).
    EVP_CipherInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key, iv, 1);

    // EVP_CipherUpdate can encrypt all your data at once, or you can do
    // small chunks at a time.
    int actual_size = 0;
    EVP_CipherUpdate(&amp;ctx,
             &amp;encrypted[0], &amp;actual_size,
             reinterpret_cast&lt;unsigned char *&gt;(&amp;plain[0]), plain.size());

    // EVP_CipherFinal_ex is what applies the padding.  If your data is
    // a multiple of the block size, you'll get an extra AES block filled
    // with nothing but padding.
    int final_size;
    EVP_CipherFinal_ex(&amp;ctx, &amp;encrypted[actual_size], &amp;final_size);
    actual_size += final_size;

    encrypted.resize(actual_size);

    for( size_t index = 0; index &lt; encrypted.size(); ++index )
    {
        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;
            static_cast&lt;unsigned int&gt;(encrypted[index]);
    }
    std::cout &lt;&lt; ""\n"";

    EVP_CIPHER_CTX_cleanup(&amp;ctx);

    return 0;
}
</code></pre>

<p>Name it <code>encrypt.cpp</code> and compile with:</p>

<pre><code>g++ encrypt.cpp -o encrypt -lcrypto -lssl -Wall
</code></pre>

<p>You'll get this output:</p>

<pre><code>338d2a9e28208cad84c457eb9bd91c81
</code></pre>

<p>You can verify correctness by running the OpenSSL command-line utility from the command prompt:</p>

<pre><code>$ echo -n ""encrypt me"" &gt; to_encrypt
$ openssl enc -in to_encrypt -out encrypted -e -aes-256-cbc \
-K 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f \
-iv 00000000000000000000000000000000
$ hexdump -C encrypted
</code></pre>

<p>And the hexdump will show the same bytes as the c++ program.</p>

<pre><code>00000000  33 8d 2a 9e 28 20 8c ad  84 c4 57 eb 9b d9 1c 81  |3.*.( ....W.....|
</code></pre>
","19279","<c++><crypto++><pkcs#7>","2","5","2","2016-08-12 21:46:19","","4","2","608639","","2016-08-12 21:46:19","2010-12-22 11:34:58",""
"25942165","AES-256 and PKCS7Padding fails in Java","<p>I have a couple of library, C#, PHP and Android where they all encrypt/decrypt a string in the same way so they are all compatible with each other, i.e. C# writes and encrypts data to a database and PHP can successfully decrypt it and return the original string. </p>

<p>I now need to do the same thing with a standard Java application, so I've taken the code from my Android library and need libraries but I am getting an exception. As far as I know the code wasn't Android specific so it shouldn't be a problem. </p>

<p>Below is my encryption function </p>

<pre><code>public static String encrypt(String plainPasword)
    {
            String password = """";
            try
            {
                SecretKeySpec key = new SecretKeySpec(""hcxilkqbbhczfeultgbskdmaunivmfuo"".getBytes(""US-ASCII""), ""AES"");
                IvParameterSpec iv = new IvParameterSpec(""ryojvlzmdalyglrj"".getBytes(""US-ASCII""));

                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");

                cipher.init(Cipher.ENCRYPT_MODE, key, iv);

                byte[] encoded = cipher.doFinal(plainPasword.getBytes());
                password = new String(Base64.encodeBase64(encoded));

            }
            catch (Exception ex)
            {
                System.err.println(""Encryption Exception: "" + ex.toString());
            }
            return password;
    }
</code></pre>

<p>When I call <code>Encryption.encrypt(""myString"")</code> I get the following exception:</p>

<pre><code>Encryption Exception: java.security.NoSuchAlgorithmException: Cannot find any provider supporting AES/CBC/PKCS7Padding
</code></pre>

<p>As I said this code is working fine on Android and it shouldn't make any difference where it is running from. </p>

<h2>Update</h2>

<p>I found that I needed PKCS5Padding instead of 7 thanks to a link on a comment. I am now though getting the following exception:</p>

<pre><code>Encryption Exception: java.security.InvalidKeyException: Illegal key size
</code></pre>
","<p>First, in Java, the standard padding name is PKCS5Padding, not PKCS7Padding. Java is actually performing PKCS #7 padding, but in the JCA specification, PKCS5Padding is the name given.</p>

<p>Next, you are trying to use AES-256, so you'll need to install the <a href=""http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html"">Unlimited Strength Jurisdiction</a> policy files.</p>

<p>Hopefully this is just an example and you aren't using the same IV for every message, right?</p>
","18444","<java><encryption><aes><jce><pkcs#7>","6","18","2","2019-09-26 20:55:11","25942381","5","3","472495","","2019-09-26 20:55:11","2014-09-19 20:47:55",""
"25942165","AES-256 and PKCS7Padding fails in Java","<p>I have a couple of library, C#, PHP and Android where they all encrypt/decrypt a string in the same way so they are all compatible with each other, i.e. C# writes and encrypts data to a database and PHP can successfully decrypt it and return the original string. </p>

<p>I now need to do the same thing with a standard Java application, so I've taken the code from my Android library and need libraries but I am getting an exception. As far as I know the code wasn't Android specific so it shouldn't be a problem. </p>

<p>Below is my encryption function </p>

<pre><code>public static String encrypt(String plainPasword)
    {
            String password = """";
            try
            {
                SecretKeySpec key = new SecretKeySpec(""hcxilkqbbhczfeultgbskdmaunivmfuo"".getBytes(""US-ASCII""), ""AES"");
                IvParameterSpec iv = new IvParameterSpec(""ryojvlzmdalyglrj"".getBytes(""US-ASCII""));

                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");

                cipher.init(Cipher.ENCRYPT_MODE, key, iv);

                byte[] encoded = cipher.doFinal(plainPasword.getBytes());
                password = new String(Base64.encodeBase64(encoded));

            }
            catch (Exception ex)
            {
                System.err.println(""Encryption Exception: "" + ex.toString());
            }
            return password;
    }
</code></pre>

<p>When I call <code>Encryption.encrypt(""myString"")</code> I get the following exception:</p>

<pre><code>Encryption Exception: java.security.NoSuchAlgorithmException: Cannot find any provider supporting AES/CBC/PKCS7Padding
</code></pre>

<p>As I said this code is working fine on Android and it shouldn't make any difference where it is running from. </p>

<h2>Update</h2>

<p>I found that I needed PKCS5Padding instead of 7 thanks to a link on a comment. I am now though getting the following exception:</p>

<pre><code>Encryption Exception: java.security.InvalidKeyException: Illegal key size
</code></pre>
","<p>@Boardy If you are still facing the issue then i think you have to use MessageDigest which is compatible for both for C# and Java. I have faced the similar issue for AES 256 encryption and decryption. The sample code will be as follows.</p>

<pre><code>public static String encryptWithAES256(String strToEncrypt) throws Exception
{
    MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
    byte[] encodedhash = digest.digest(KEY.getBytes(StandardCharsets.UTF_8));
    IvParameterSpec ivspec = new IvParameterSpec(Arrays.copyOf(KEY.getBytes(),16));
    SecretKeySpec secretKey = new SecretKeySpec(encodedhash, AES_ENCRYPTION_ALGORITHM);
    Cipher cipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
    cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivspec);
    return new String(Base64.encodeBase64(cipher.doFinal(strToEncrypt.getBytes(CHARACTER_ENCODING))));
}
</code></pre>
","18444","<java><encryption><aes><jce><pkcs#7>","6","-1","2","2019-09-26 20:55:11","25942381","5","3","472495","","2019-09-26 20:55:11","2014-09-19 20:47:55",""
"6099467","How to parse a SAML assertion request in .Net","<p>I'm trying to implement a SAML SSO solution in .Net, but I'm having a problem parsing the assertion.</p>

<p>I have a sample assertion (looks like <code>byte[]</code> data as text) and corresponding <code>.p7b</code> file.</p>

<p>I want to load the keys from the <code>.p7b</code> and decrypt the assertion to an XML document.</p>

<p>So far I think I'm reading the keys correctly:</p>

<pre><code>// get the key data
byte[] certificateData = System.IO.File.ReadAllBytes(""myKeys.p7b"");

// decode the keys
var cms = new SignedCms(SubjectIdentifierType.IssuerAndSerialNumber);
cms.Decode(certificateData);

var samlCertificates = cms.Certificates;
</code></pre>

<p>Then I try to parse the assertion I get a problem:</p>

<pre><code>// we have a keychain of X509Certificate2s, we need a collection of tokens
var certificatesAsTokens =
    from X509Certificate2 cert in samlCertificates
    select new X509SecurityToken(cert) as SecurityToken;

// get a token resolver
var tokens = new ReadOnlyCollection&lt;SecurityToken&gt;(
    certificatesAsTokens.ToList());
var resolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(
    tokens, true);

// get the SAML data in an XML reader
var reader = XmlReader.Create(assertionPostStream);

// use the WS Security stuff to parse the reader
var securityToken = WSSecurityTokenSerializer.
    DefaultInstance.ReadToken(reader, resolver) as SamlSecurityToken;
</code></pre>

<p>That last statement throws an exception, stating that it can't parse the XML content.</p>

<p>I think this means that I'm missing a step decrypting the assertion - getting the <code>byte[]</code> as text converted to a SAML format XML document.</p>

<p>Anyone know how to add this step? Am I missing something else?</p>
","<p>I've figured this out - I was missing part of the SAML specification.</p>

<p>The assertion is sent (rather weirdly, since it isn't encrypted) as base64 data, and it was being URL encoded twice as it was sent.</p>

<p>So adding this step gives us a valid assertion:</p>

<pre><code>// spec says ""SAMLResponse="" 
string rawSamlData = Request[""SAMLResponse""];

// the sample data sent us may be already encoded, 
// which results in double encoding
if (rawSamlData.Contains('%'))
{
    rawSamlData = HttpUtility.UrlDecode(rawSamlData);
}

// read the base64 encoded bytes
byte[] samlData = Convert.FromBase64String(rawSamlData);

// read back into a UTF string
string samlAssertion = Encoding.UTF8.GetString(samlData);
</code></pre>

<p>The <a href=""https://stackoverflow.com/questions/6108564"">authentication still isn't working</a>, but I now have valid XML so it's a different problem.</p>
","17324","<.net><single-sign-on><x509certificate><saml><pkcs#7>","6","14","1","2014-09-25 04:14:45","6108496","0","2","","","","2011-05-23 15:37:14",""
"3166159","Verifying PKCS#7 certificates in Java","<p>Need some help with crypto routines in Java.</p>

<p>Given a PKCS#7 signature, I want to verify all certificates it contains against a trusted store. I assume that all certificates contained in signature are in the correct order to form a valid certificate path (or chain, whatever), so that</p>

<ul>
<li>topmost (#0) is a signing certificate;</li>
<li>next one (#1) is an intermediate certificate, used to sign #0;</li>
<li>next one (#2) is another intermediate certificate, used to sign #1;</li>
<li>and so on.</li>
</ul>

<p>The last certificate (#N) is signed by CA.</p>

<p>That's what I've managed to hack so far:</p>

<pre><code>// Exception handling skipped for readability

//byte[] signature = ...
pkcs7 = new PKCS7(signature); // `sun.security.pkcs.PKCS7;`

// *** Checking some PKCS#7 parameters here

X509Certificate prevCert = null; // Previous certificate we've found
X509Certificate[] certs = pkcs7.getCertificates(); // `java.security.cert.X509Certificate`
for (int i = 0; i &lt; certs.length; i++) {
    // *** Checking certificate validity period here

    if (cert != null) {
        // Verify previous certificate in chain against this one
        prevCert.verify(certs[i].getPublicKey());
    }
    prevCert = certs[i];
}

//String keyStorePath = ...
KeyStore keyStore = KeyStore.getInstance(""JKS""); // `java.security.KeyStore`
keyStore.load(new FileInputStream(keyStorePath), null);

// Get trusted VeriSign class 1 certificate
Certificate caCert = keyStore.getCertificate(""verisignclass1ca""); // `java.security.cert.Certificate`

// Verify last certificate against trusted certificate
cert.verify(caCert.getPublicKey());
</code></pre>

<p>So the question is -- how can this be done using standard Java classes like <code>CertPath</code> and friends? I have a strong feeling I'm re-inventing a bicycle. Or, if someone has an example with BouncyCastle library, that would also be fine.</p>

<p>Bonus question: how to verify a certificate against a trusted store so that root certificate is selected automatically?</p>
","<p>You want <a href=""http://java.sun.com/javase/6/docs/api/java/security/cert/CertificateFactory.html"" rel=""nofollow noreferrer"">CertificateFactory</a>. The last example in the javadocs do exactly what you want.</p>
","15917","<java><certificate><bouncycastle><pkcs#7>","7","2","2","2010-07-05 14:08:06","3180123","2","7","","","","2010-07-02 13:39:49",""
"3166159","Verifying PKCS#7 certificates in Java","<p>Need some help with crypto routines in Java.</p>

<p>Given a PKCS#7 signature, I want to verify all certificates it contains against a trusted store. I assume that all certificates contained in signature are in the correct order to form a valid certificate path (or chain, whatever), so that</p>

<ul>
<li>topmost (#0) is a signing certificate;</li>
<li>next one (#1) is an intermediate certificate, used to sign #0;</li>
<li>next one (#2) is another intermediate certificate, used to sign #1;</li>
<li>and so on.</li>
</ul>

<p>The last certificate (#N) is signed by CA.</p>

<p>That's what I've managed to hack so far:</p>

<pre><code>// Exception handling skipped for readability

//byte[] signature = ...
pkcs7 = new PKCS7(signature); // `sun.security.pkcs.PKCS7;`

// *** Checking some PKCS#7 parameters here

X509Certificate prevCert = null; // Previous certificate we've found
X509Certificate[] certs = pkcs7.getCertificates(); // `java.security.cert.X509Certificate`
for (int i = 0; i &lt; certs.length; i++) {
    // *** Checking certificate validity period here

    if (cert != null) {
        // Verify previous certificate in chain against this one
        prevCert.verify(certs[i].getPublicKey());
    }
    prevCert = certs[i];
}

//String keyStorePath = ...
KeyStore keyStore = KeyStore.getInstance(""JKS""); // `java.security.KeyStore`
keyStore.load(new FileInputStream(keyStorePath), null);

// Get trusted VeriSign class 1 certificate
Certificate caCert = keyStore.getCertificate(""verisignclass1ca""); // `java.security.cert.Certificate`

// Verify last certificate against trusted certificate
cert.verify(caCert.getPublicKey());
</code></pre>

<p>So the question is -- how can this be done using standard Java classes like <code>CertPath</code> and friends? I have a strong feeling I'm re-inventing a bicycle. Or, if someone has an example with BouncyCastle library, that would also be fine.</p>

<p>Bonus question: how to verify a certificate against a trusted store so that root certificate is selected automatically?</p>
","<p>Found the solution myself. So, here's how one can extract and validate a certificate chain against the trusted store (exception handling skipped for readability):</p>

<pre><code>CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

// Get ContentInfo
//byte[] signature = ... // PKCS#7 signature bytes
InputStream signatureIn = new ByteArrayInputStream(signature);
DERObject obj = new ASN1InputStream(signatureIn).readObject();
ContentInfo contentInfo = ContentInfo.getInstance(obj);

// Extract certificates
SignedData signedData = SignedData.getInstance(contentInfo.getContent());
Enumeration certificates = signedData.getCertificates().getObjects();

// Build certificate path
List certList = new ArrayList();
while (certificates.hasMoreElements()) {
    DERObject certObj = (DERObject) certificates.nextElement();
    InputStream in = new ByteArrayInputStream(certObj.getDEREncoded());
    certList.add(cf.generateCertificate(in));
}
CertPath certPath = cf.generateCertPath(certList);

// Load key store
//String keyStorePath = ...
KeyStore keyStore = KeyStore.getInstance(""JKS"");
keyStore.load(new FileInputStream(keyStorePath), null);

// Set validation parameters
PKIXParameters params = new PKIXParameters(keyStore);
params.setRevocationEnabled(false); // to avoid exception on empty CRL

// Validate certificate path
CertPathValidator validator = CertPathValidator.getInstance(""PKIX"");
CertPathValidatorResult result = validator.validate(certPath, params);
</code></pre>

<p><code>validate()</code> will throw an exception if validation fails.</p>

<p>Docs: <a href=""http://bouncycastle.gva.es/www.bouncycastle.org/docs/docs1.6/org/bouncycastle/asn1/ASN1Set.html"" rel=""nofollow noreferrer""><code>ASN1Set</code></a>, <a href=""http://bouncycastle.gva.es/www.bouncycastle.org/docs/docs1.6/org/bouncycastle/asn1/pkcs/ContentInfo.html"" rel=""nofollow noreferrer""><code>ContentInfo</code></a>, <a href=""http://bouncycastle.gva.es/www.bouncycastle.org/docs/docs1.6/org/bouncycastle/asn1/pkcs/SignedData.html"" rel=""nofollow noreferrer""><code>SignedData</code></a>. All other exotic names and related docs can be found in <code>java.security.cert</code>.</p>

<p>No SUN-dependencies here, only <a href=""http://www.bouncycastle.org/latest_releases.html"" rel=""nofollow noreferrer"">BouncyCastle provider library</a> is needed.</p>

<p><a href=""https://stackoverflow.com/questions/2377402/how-to-encode-a-value-in-pkcs7-with-java"">This</a> question (and especially an answer) may help too.</p>
","15917","<java><certificate><bouncycastle><pkcs#7>","7","13","2","2010-07-05 14:08:06","3180123","2","7","","","","2010-07-02 13:39:49",""
"579035","How to read Pkcs#7 certificate chain from file/stream in C#?","<p>I have two certificates that I saved to disk. One is a certificate with private key that I exported as a .pfx file, the other one is a certificate that I saved including its certificate chain as a PKCS#7 file (""certchain.p7b"").</p>

<p>In C# I can now load the .pfx file with</p>

<pre><code>  var cert = new X509Certificate2(myPfxFileStream); 
</code></pre>

<p>(myPfxFileStream is a <code>FileStream</code> opened to the .pfx File for reading), however trying the same thing with the PKCs#7 Certificate fails in a <code>CryptoGraphicException</code> ""Der Indexwert ist ung√ºltig"" which translates to ""invalid index value"".</p>

<p>I assume I have to parse PKCS#7 differently (it contains a chain, not a single certificate!), but how?</p>

<p>(Oh, by the way: Currently I have no passwords on those certficiates)</p>
","<p>You will want to use the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.pkcs.signedcms.aspx"" rel=""noreferrer""><code>SignedCms</code></a> class in the <a href=""http://msdn.microsoft.com/en-us/library/6see7k14.aspx"" rel=""noreferrer""><code>System.Security.Cryptography.Pkcs</code></a> namespace.</p>

<p>This blog entry will show you how to use the class:</p>

<p><a href=""http://blogs.msdn.com/shawnfa/archive/2006/02/27/539990.aspx"" rel=""noreferrer"">http://blogs.msdn.com/shawnfa/archive/2006/02/27/539990.aspx</a></p>

<p>You basically will call the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.pkcs.signedcms.decode.aspx"" rel=""noreferrer""><code>Decode</code></a> method, passing the bytes representing the PKCS file.</p>
","15095","<c#><x509certificate2><pkcs#7>","5","8","1","2018-07-27 13:06:35","579059","0","2","60229","froh42","2018-07-27 13:06:35","2009-02-23 19:42:42",""
"13347528","PHP Encrypt/Decrypt with TripleDes, PKCS7, and ECB","<p>I've got my encryption function working properly however I cannot figure out how to get the decrypt function to give proper output.</p>

<p>Here is my encrypt function:</p>

<pre><code>function Encrypt($data, $secret)
{    
  //Generate a key from a hash
  $key = md5(utf8_encode($secret), true);

  //Take first 8 bytes of $key and append them to the end of $key.
  $key .= substr($key, 0, 8);

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');

  return base64_encode($encData);

}
</code></pre>

<p>Here is my decrypt function:</p>

<pre><code>function Decrypt($data, $secret)
{
    $text = base64_decode($data);

    $data = mcrypt_decrypt('tripledes', $secret, $text, 'ecb');

    $block = mcrypt_get_block_size('tripledes', 'ecb');
    $pad   = ord($data[($len = strlen($data)) - 1]);

    return substr($data, 0, strlen($data) - $pad);
}
</code></pre>

<p>Right now I am using a key of <code>test</code> and I'm trying to encrypt <code>1234567</code>. I get the base64 output from encryption I'm looking for, but when I go to decrypt it returns nothing (a blank area).</p>

<p>I'm not very well versed in encryption/decryption so any help is much appreciated!!</p>
","<p>Thanks for anyone who took a look at my problem. I think I have solved it and here is my full solution. Hopefully it helps out someone else who is having a similar issue:</p>

<pre><code>function Encrypt($data, $secret)
{    
  //Generate a key from a hash
  $key = md5(utf8_encode($secret), true);

  //Take first 8 bytes of $key and append them to the end of $key.
  $key .= substr($key, 0, 8);

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');

  return base64_encode($encData);

}
</code></pre>

<p>And here is the new decrypt function.</p>

<pre><code>function Decrypt($data, $secret)
{

    //Generate a key from a hash
    $key = md5(utf8_encode($secret), true);

    //Take first 8 bytes of $key and append them to the end of $key.
    $key .= substr($key, 0, 8);

    $data = base64_decode($data);

    $data = mcrypt_decrypt('tripledes', $key, $data, 'ecb');

    $block = mcrypt_get_block_size('tripledes', 'ecb');
    $len = strlen($data);
    $pad = ord($data[$len-1]);

    return substr($data, 0, strlen($data) - $pad);
}
</code></pre>

<p>I had to add the same code for generating the key in the correct format before I ran the mycrypt_decrypt function.</p>
","12284","<php><encryption><pkcs#7><tripledes><ecb>","7","15","1","2014-08-27 11:23:55","","2","1","671736","","2012-11-12 17:05:42","2012-11-12 16:30:36",""
"21724337","Signing and Verifying on iOS using RSA","<p>How to sign and verify some data on iOS with an RSA key (preferably using the system own <code>libcommonCrypto</code>)?</p>
","<p>Since there hasn't been nearly any knowledge about signing and verifying found on StackOverflow and the Apple docs, I had to manually browse around in the iOS header files and found <code>SecKeyRawSign</code> and <code>SecKeyRawVerify</code>. The following lines of code seem to work.</p>

<hr>

<p><strong>Signing NSData (using SHA256 with RSA):</strong></p>

<pre><code>NSData* PKCSSignBytesSHA256withRSA(NSData* plainData, SecKeyRef privateKey)
{
    size_t signedHashBytesSize = SecKeyGetBlockSize(privateKey);
    uint8_t* signedHashBytes = malloc(signedHashBytesSize);
    memset(signedHashBytes, 0x0, signedHashBytesSize);

    size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;
    uint8_t* hashBytes = malloc(hashBytesSize);
    if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {
        return nil;
    }

    SecKeyRawSign(privateKey,
                  kSecPaddingPKCS1SHA256,
                  hashBytes,
                  hashBytesSize,
                  signedHashBytes,
                  &amp;signedHashBytesSize);

    NSData* signedHash = [NSData dataWithBytes:signedHashBytes
                                        length:(NSUInteger)signedHashBytesSize];

    if (hashBytes)
        free(hashBytes);
    if (signedHashBytes)
        free(signedHashBytes);

    return signedHash;
}
</code></pre>

<hr>

<p><strong>Verification (using SHA256 with RSA):</strong></p>

<pre><code>BOOL PKCSVerifyBytesSHA256withRSA(NSData* plainData, NSData* signature, SecKeyRef publicKey)
{
    size_t signedHashBytesSize = SecKeyGetBlockSize(publicKey);
    const void* signedHashBytes = [signature bytes];

    size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;
    uint8_t* hashBytes = malloc(hashBytesSize);
    if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {
        return nil;
    }

    OSStatus status = SecKeyRawVerify(publicKey,
                                      kSecPaddingPKCS1SHA256,
                                      hashBytes,
                                      hashBytesSize,
                                      signedHashBytes,
                                      signedHashBytesSize);

    return status == errSecSuccess;
}
</code></pre>

<hr>

<p><strong>Alternatives (OpenSSL):</strong></p>

<p>There is a very good alternative available which utilizes OpenSSL directly instead of libCommonCrypto. <a href=""https://github.com/hohl/MIHCrypto"" rel=""noreferrer"">MIHCrypto</a> is a well-designed Objective-C wrapper library for OpenSSL which makes working with cryptography very easy. See the example below.</p>

<p>Generating a key is that simple:</p>

<pre><code>MIHAESKeyFactory *factory = [[MIHAESKeyFactory alloc] init];
id&lt;MIHSymmetricKey&gt; aesKey = [factory generateKey];
</code></pre>

<p>Or loading a key from file:</p>

<pre><code>NSData *privateKeyData = [[NSFileManager defaultManager] contentsAtPath:""mykey.pem""];
MIHRSAPrivateKey *privateKey = [[MIHRSAPrivateKey alloc] initWithData:privateKeyData];
</code></pre>

<p>Now sign something:</p>

<pre><code>NSError *signingError = nil;
NSData *message = // load something to sign from somewhere
NSData *signature = [privateKey signWithSHA256:message error:&amp;signingError]
</code></pre>

<p>For more examples browse the <a href=""https://github.com/hohl/MIHCrypto"" rel=""noreferrer"">MIHCrypto</a> page.</p>
","10584","<ios><rsa><pkcs#7><commoncrypto>","19","29","1","2014-08-30 10:23:56","21826729","6","15","","","","2014-02-12 09:53:50",""
"17043569","PKCS7 Verify digital signature in Java","<p>The situation is that i have to check a digital signature:</p>

<p>String1 ""A1005056807CE11EE2B4CE0025305725CFrCN=KED,OU=I0020266601,OU=SAPWebAS,O=SAPTrustCommunity,C=DE20130611102236"" 
is signed via PKCS#7 and send over HTTP-URL to me.</p>

<p>I get the signed content in BASE64 (look in code String sc).</p>

<p>Now i have to check, if the Hash of String1 which i will reproduce later in my code, is the same as from the signed content. Therefore i have to use the public key which i have from a certificate.</p>

<p>I have a file with a X.509 certificate. This file i load into a X509Certificate instance. I got this file by copy and paste the bytes out from SAP- so i am not sure if the certificate is correct. But i can load it into the instance - i have putted the output of this certificate below.</p>

<p>Now i get ""message-digest attribute value does not match calculated value"" when i run my code. 
I dont know if these steps are right and is this message is correct, or am I doing something false!?</p>

<p>Here my code:</p>

<pre><code>String sc = ""MIIBUQYJKoZIhvcNAQcCoIIBQjCCAT4CAQExCzAJBgUrDgMCGgUAMAsGCSqGSIb3DQEHATGCAR0wggEZAgEBMG8wZDELMAkGA1UEBhMCREUxHDAaBgNVBAoTE1NBUCBUcnVzdCBDb21tdW5pdHkxEzARBgNVBAsTClNBUCBXZWIgQVMxFDASBgNVBAsTC0kwMDIwMjY2NjAxMQwwCgYDVQQDEwNLRUQCByASEgITMlYwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMDYxMTA4MjM1MVowIwYJKoZIhvcNAQkEMRYEFGy7jXb/pUqMYdk2dss2Qe6hNroaMAkGByqGSM44BAMELjAsAhRMJ+t5/3RxQAsHKnIoPY4BnO0qCAIUAbKRwWNjOYsewB56zoZqnZwRyWw="";
byte[] secKey = Base64.decode(sc);


CMSSignedData s = new CMSSignedData(secKey);

SignerInformationStore signers = s.getSignerInfos();
Iterator&lt;SignerInformation&gt; it = signers.getSigners().iterator();

FileInputStream fis = new FileInputStream(""c:\\sap.cer"");
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
Collection&lt;X509Certificate&gt; c = (Collection&lt;X509Certificate&gt;)cf.generateCertificates(fis);
Iterator&lt;X509Certificate&gt; i = c.iterator();

while(it.hasNext()){
    SignerInformation signer = it.next();
    while (i.hasNext()) {
        X509Certificate cert = i.next();
        cert.checkValidity();
        cert.verify(cert.getPublicKey());           
        signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""SUN"").build(cert));
    }
}
</code></pre>

<p>Certificate Output:</p>

<pre><code>[
[
  Version: V1
  Subject: CN=KED, OU=I0020266601, OU=SAP Web AS, O=SAP Trust Community, C=DE
  Signature Algorithm: SHA1withDSA, OID = 1.2.840.10040.4.3

  Key:  Sun DSA Public Key
    Parameters:DSA
    p:     ffd22469 8c53aa90 7585c3ee b65ffd9a cde5b230 53041af9 969e69c8 22093f5a
    477740c5 d398084f 3830ea33 8dbd8505 d6cce42b 135794b1 a971e670 f896eee2
    17acf3f8 48c67d35 434768d7 9c30567f abeb0d86 5674ef2b d391d530 26cbd9ba
    647414ba ff6e2f5b 9f468df7 3e266bd5 b330058d e64cfd69 75065322 11c43237
    q:     cd1ac6c7 d55ae243 cd5bbb0c 0f0789b4 233786b1
    g:     0945535b 061de39c 995832d2 03d3c2a0 c352cad9 2a524886 7c681962 ca94e5e3
    f23cc4c0 7891bc0d 0abc85fe 4f575334 b8e02d02 176d7534 ec7080c3 a46ccba3
    776a1b2f fa6f3586 e4e90e40 558e779a 6d90c9c0 c788592f 5d8ffe16 801e2c9e
    b3305ed3 c4035015 a246b7fc 2d2dda7f e6431fe3 d3b291fe 58082643 49d9bac1

  y:
    cab5984a d0254277 fd4aab43 799d8120 35f7725b 313b87a2 ca092c91 96236e44
    8ad7c157 d000395b 1ce37da2 a9c18113 c34067e8 c917752b 9604049d 70b92bb0
    6aa65d45 d5fde439 bbcbaa21 7520542a baac4e64 75fabc57 56a91856 178d8fc4
    6aa34d71 5a06b59f 6c89ae81 3571d4ce 89bbeb49 dedfc68c 4fa8a6d1 9aefcdcf

  Validity: [From: Sun Dec 02 14:32:56 CET 2012,
               To: Fri Jan 01 01:00:01 CET 2038]
  Issuer: CN=KED, OU=I0020266601, OU=SAP Web AS, O=SAP Trust Community, C=DE
  SerialNumber: [    20121202 133256]

]
  Algorithm: [SHA1withDSA]
  Signature:
0000: 30 2D 02 14 15 BE 80 34   1A 6F 02 F4 C8 5A 9A 6A  0-.....4.o...Z.j
0010: 3E 5A A8 66 C2 A2 AD 3C   02 15 00 C9 53 A6 D9 85  &gt;Z.f...&lt;....S...
0020: 3F 22 FB 12 5C E9 9D B7   77 29 03 62 81 EA 17     ?""..\...w).b...

]
</code></pre>
","<p>Finally i got it with help of this: <a href=""https://stackoverflow.com/questions/8243566/verifying-detached-signature-with-bc"">verifying detached signature with BC</a></p>

<pre><code>    String toVerify = ""A1005056807CE11EE2B4CE0025305725CFrCN%3DKED,OU%3DI0020266601,OU%3DSAPWebAS,O%3DSAPTrustCommunity,C%3DDE20130611102236"";
    String signed = ""MIIBUQYJKoZIhvcNAQcCoIIBQjCCAT4CAQExCzAJBgUrDgMCGgUAMAsGCSqGSIb3DQEHATGCAR0wggEZAgEBMG8wZDELMAkGA1UEBhMCREUxHDAaBgNVBAoTE1NBUCBUcnVzdCBDb21tdW5pdHkxEzARBgNVBAsTClNBUCBXZWIgQVMxFDASBgNVBAsTC0kwMDIwMjY2NjAxMQwwCgYDVQQDEwNLRUQCByASEgITMlYwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMDYxMTA4MjM1MVowIwYJKoZIhvcNAQkEMRYEFGy7jXb/pUqMYdk2dss2Qe6hNroaMAkGByqGSM44BAMELjAsAhRMJ+t5/3RxQAsHKnIoPY4BnO0qCAIUAbKRwWNjOYsewB56zoZqnZwRyWw="";
    byte[] signedByte = Base64.decode(signed);

    Security.addProvider(new BouncyCastleProvider());

    CMSSignedData s = new CMSSignedData(new CMSProcessableByteArray(toVerify.getBytes()), signedByte);
    SignerInformationStore signers = s.getSignerInfos();
    SignerInformation signerInfo = (SignerInformation)signers.getSigners().iterator().next();

    FileInputStream fis = new FileInputStream(""c:\\sap.cer"");
    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    X509Certificate cert = (X509Certificate)cf.generateCertificates(fis).iterator().next();

    boolean result = signerInfo.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""SUN"").build(cert.getPublicKey())); 
    System.out.println(""Verified: ""+result);
</code></pre>
","9261","<java><security><sap><pkcs#7>","2","4","1","2018-09-29 04:31:36","17059469","6","1","2427960","","2013-06-11 13:39:48","2013-06-11 11:59:59",""
"6369096","How to Read the certificates file from the PKCS7.p7b certificate file using openssl?","<p>I am getting PKCS7 file (p7b). I want to read the content of the file and extract certificate in X509 structure.</p>

<p>How can I access individual Certificate from the PKCS container using openssl library?</p>
","<p>I've used the following program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;openssl/pkcs7.h&gt;
#include &lt;openssl/x509.h&gt;
#include &lt;openssl/bio.h&gt;
#include &lt;openssl/pem.h&gt;

int main(int argc, char **argv)
{
    PKCS7 *p7 = NULL;
    BIO *in = BIO_new(BIO_s_file());
    BIO *out = BIO_new(BIO_s_file());
    int der = 0; /* Input from DER or PEM ? */
    int text = 0; /* Dump text or output PEM ? */
    STACK_OF(X509) *certs = NULL;
    int i;

    CRYPTO_malloc_init();                                               \
    ERR_load_crypto_strings();
    OpenSSL_add_all_algorithms();

    BIO_set_fp(out, stdout, BIO_NOCLOSE);
    BIO_read_filename(in, argv[1]);
    p7 = der ?
        d2i_PKCS7_bio(in, NULL) :
        PEM_read_bio_PKCS7(in, NULL, NULL, NULL);

    i = OBJ_obj2nid(p7-&gt;type);
    if(i == NID_pkcs7_signed) {
        certs = p7-&gt;d.sign-&gt;cert;
    } else if(i == NID_pkcs7_signedAndEnveloped) {
        certs = p7-&gt;d.signed_and_enveloped-&gt;cert;
    }

    for (i = 0; certs &amp;&amp; i &lt; sk_X509_num(certs); i++) {
        X509 *x = sk_X509_value(certs,i);
        if(text) {
            X509_print(out, x);
        } else {
            PEM_write_bio_X509(out,x);
        }
    }
}
</code></pre>

<p>It's based on <code>openssl-1.0.0d/apps/pkcs7.c</code> and it's easily compiled (on Linux or Mac OS X) with (provided you save it as readp7.c):</p>

<pre><code>gcc -o readp7 readp7.c -lcrypto
</code></pre>

<p>You can create files with openssl and read them like this:</p>

<pre><code>openssl crl2pkcs7 -nocrl -certfile a.crt -certfile b.crt -out test.p7b
./readp7 test.p7b
</code></pre>
","8642","<c++><certificate><openssl><x509><pkcs#7>","4","10","1","2018-10-11 07:17:23","6395941","0","5","1033581","","2018-10-11 07:17:23","2011-06-16 08:32:39",""
"6126388","How to verify an X509Certificate2 against an X509Certificate2Collection chain","<p>I'm writing a SAML 2.0 response parser to handle POST authentication in ASP.Net (in C# and MVC, but that's less relevant).</p>

<p>So I have a <code>.p7b</code> file to validate with and that can be read into a <code>X509Certificate2Collection</code> and a sample assertion - a base 64 encoded SAML response.</p>

<p>Ideally I want to use the built in <code>WSSecurityTokenSerializer</code>, but <a href=""https://stackoverflow.com/questions/6108564"">that fails</a>, so I'm looking for a way that works.</p>

<p>I'm reading the XML directly instead:</p>

<pre><code>// get the base 64 encoded SAML
string samlAssertionRaw = GetFromHttpRequest();

// load a new XML document
var assertion = new XmlDocument { PreserveWhitespace = true };
assertion.LoadXml(samlAssertionRaw);

// use a namespace manager to avoid the worst of xpaths
var ns = new XmlNamespaceManager(assertion.NameTable);
ns.AddNamespace(""samlp"", @""urn:oasis:names:tc:SAML:2.0:protocol"");
ns.AddNamespace(""saml"", @""urn:oasis:names:tc:SAML:2.0:assertion"");
ns.AddNamespace(""ds"", SignedXml.XmlDsigNamespaceUrl);

// get the signature XML node
var signNode = assertion.SelectSingleNode(
    ""/samlp:Response/saml:Assertion/ds:Signature"", ns);

// load the XML signature
var signedXml = new SignedXml(assertion.DocumentElement);
signedXml.LoadXml(signNode as XmlElement);

// get the certificate, basically:
// signedXml.KeyInfo.OfType&lt;KeyInfoX509Data&gt;().First().
//     Certificates.OfType&lt;X509Certificate2&gt;().First()
// but with added checks
var certificate = GetFirstX509Certificate(signedXml);

// check the key and signature match
if (!signedXml.CheckSignature(certificate, true))
{
    throw new SecurityException(""Signature check failed."");
}

// go on and read the SAML attributes from the XML doc
</code></pre>

<p>That lot works, but all it's doing is checking that the signature and the <code>X509Certificate2</code> public key in the SAML response match. It doesn't in any way verify who it's from, and I need to do that before accepting the SAML authentication.</p>

<p>There appear to be two ways to check the certificate found in the SAML response - I can do <code>certificate.Verify()</code> or I can do the check with the signature <code>signedXml.CheckSignature(certificate, false)</code>.</p>

<p>However both return false.</p>

<p>I think this is because they're being checked against the machine store or possibly online (I'm not sure how to check). I want to check them against the <code>X509Certificate2Collection</code> retrieved from the <code>.p7b</code> file instead - the certificates registered on the machine should be ignored and just the <code>.p7b</code> certificates checked.</p>

<p>There doesn't appear to be any way to pass the <code>X509Certificate2Collection</code> to either the <code>Verify</code> or <code>CheckSignature</code> methods.</p>

<p>Is this the right check to be doing on the SAML response?</p>

<p>Is there any way to use the <code>.p7b</code> certificates the way I want to?</p>
","<p>Have you tried using a custom <code>X509Chain</code> configured to search an <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.x509chainpolicy.extrastore.aspx"" rel=""noreferrer""><code>ExtraStore</code></a> of certificates during the validation process. Something like the following:</p>

<pre><code>// Placeholder for the certificate to validate
var targetCertificate = new X509Certificate2();
// Placeholder for the extra collection of certificates to be used
var certificates = new X509Certificate2Collection();

var chain = new X509Chain();

chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;
chain.ChainPolicy.ExtraStore.AddRange(certificates);

bool isValidCertificate = chain.Build(targetCertificate);
</code></pre>

<p>In the example the revocation check is also disabled but if you have online or offline access to the CRL you could enable it. </p>

<hr />

<p>The <code>ExtraStore</code> should allow to include intermediate certificates that are not in the machine/user store. However, the trusted root certificate may need to be in the machine or user store depending on the one specified in <code>X509Chain</code> because otherwise you'll get an <code>UntrustedRoot</code> fail. If not even the root can be available in a machine or user store you could try to walk up the resulting chain and guarantee that the only error you have is due to an untrusted root and at the same time guaranteeing that the chain root is what you would expect based on the <code>X509Certificate2Collection</code> you have for validation.</p>

<p>Alternatively you could create your own custom <a href=""http://msdn.microsoft.com/en-us/library/system.identitymodel.selectors.x509certificatevalidator.aspx"" rel=""noreferrer""><code>X509CertificateValidator</code></a> to validate a certificate taking only in consideration a provided <code>X509Certificate2Collection</code>.</p>
","8050","<.net><single-sign-on><x509certificate><pkcs#7><saml-2.0>","10","5","1","2011-05-31 12:54:26","6187016","7","9","-1","","2017-05-23 11:43:48","2011-05-25 14:51:10",""
"23935033","Enveloping, signing and creating PKCS#7 DER message with .pfx certificate","<p>My task is to create data that are digitally signed in format of <code>PKCS#7 version 1.5 (RFC 2315) DER (ITU-T Recommendation X.690)</code> - basically <code>ANSI.1</code> with <code>X.509 signature</code>?</p>

<p>the message must satisfy following:</p>

<ul>
<li>must be type <code>signedData</code></li>
<li>must contain signed data</li>
<li>must contain signer's certificate</li>
<li>must contain one digital signature</li>
</ul>

<p>My code is following</p>

<pre><code>static void Main(string[] args)
{

    string pfx = @""C:\Users\marek\Downloads\mfcr\marek-pfx.pfx"";
    string xml = @""C:\Users\marek\Downloads\mfcr\souhr20141.xml"";
    X509Certificate2 cert = new X509Certificate2(pfx, ""thepass"");

    byte[] publicBytes = cert.RawData;

    //var f = new FileStream(xml, System.IO.FileMode.Open);
    var fileContent = System.IO.File.ReadAllBytes(xml);

    char[] cArray = System.Text.Encoding.ASCII.GetString(fileContent).ToCharArray();
    RSACryptoServiceProvider rsa = (RSACryptoServiceProvider)cert.PrivateKey;

    byte[] signedData = rsa.SignData(new System.Text.UTF8Encoding().GetBytes(cArray), new SHA1CryptoServiceProvider());

    RSACryptoServiceProvider rsa2 = (RSACryptoServiceProvider)new X509Certificate2(publicBytes).PublicKey.Key;

    var dataGenerator = new CmsEnvelopedDataStreamGenerator();
    bool verified = rsa2.VerifyData(new System.Text.UTF8Encoding().GetBytes(cArray), new SHA1CryptoServiceProvider(), signedData);

    File.WriteAllBytes(@""C:\Users\marek\Downloads\mfcr\Foo.p7b"", signedData);
 }
</code></pre>

<p>The <code>WebService</code> that Iam sending the <code>Foo.p7b</code> responds with: File is not in expected format of PKCS7(DER).</p>

<p>This code for sending the <code>HttpWebRequest</code> :</p>

<pre><code>static void Main(string[] args)
    {
        try
        {

            string fileName = (@""C:\Users\marek\Downloads\mfcr\Foo.p7b"");
            WebResponse rsp = null;
            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(""https://adisepo.mfcr.cz/adistc/epo_podani"");
            request.ClientCertificates.Add(new X509Certificate(pfx,""thepass""));
            request.Method = ""POST"";
            request.ContentType = ""application/pkcs7-signature"";
            request.Credentials = CredentialCache.DefaultNetworkCredentials;
            var encoder = new UTF8Encoding();
            var reqStream = request.GetRequestStream();
            StreamWriter writer = new StreamWriter(request.GetRequestStream());
            // Write the XML text into the stream
            writer.WriteLine(GetTextFromXMLFile(fileName));
            writer.Close();
            reqStream.Close();
            rsp = request.GetResponse();
            StreamReader sr = new StreamReader(rsp.GetResponseStream());
            string result = sr.ReadToEnd();
            sr.Close();
            Console.Write(""\n p≈ô√≠kaz odesl√°n  \n"");
            Console.Write(result);
            Console.ReadLine();
            Console.Read();
        }
        catch (Exception ex)
        { Console.WriteLine(ex.ToString());
        Console.ReadLine();
        }

    }
    private static string GetTextFromXMLFile(string file)
    {
        StreamReader reader = new StreamReader(file);
        string ret = reader.ReadToEnd();
        reader.Close();
        return ret;
    }
}
</code></pre>

<p>I'm struggling with this issue for almost 5 days - I'm surely not expert on digital signature or certificates.</p>

<p>From what I learned so far - to create message like that I should do:</p>

<ol>
<li>Sign the <code>xml</code> with my <code>private key</code></li>
<li>Envelope that blob with my <code>public key</code></li>
</ol>

<p>But how could the recipient check whether I am the real sender? Should I add to <code>HttpWebRequest</code> parameter with my certificate? Or that step 2 - Enveloping the message is enough for him to check that?</p>

<p>Thank you everyone for your time and replies. </p>
","<p>Take a look at BouncyCastle - it has all you need for that:</p>

<p><a href=""http://www.bouncycastle.org/csharp/"" rel=""nofollow"">http://www.bouncycastle.org/csharp/</a></p>
","7420","<c#><ssl-certificate><digital-signature><certificate><pkcs#7>","4","0","2","2014-06-02 12:56:17","23990736","1","2","2538352","","2014-06-02 07:54:15","2014-05-29 13:52:05",""
"23935033","Enveloping, signing and creating PKCS#7 DER message with .pfx certificate","<p>My task is to create data that are digitally signed in format of <code>PKCS#7 version 1.5 (RFC 2315) DER (ITU-T Recommendation X.690)</code> - basically <code>ANSI.1</code> with <code>X.509 signature</code>?</p>

<p>the message must satisfy following:</p>

<ul>
<li>must be type <code>signedData</code></li>
<li>must contain signed data</li>
<li>must contain signer's certificate</li>
<li>must contain one digital signature</li>
</ul>

<p>My code is following</p>

<pre><code>static void Main(string[] args)
{

    string pfx = @""C:\Users\marek\Downloads\mfcr\marek-pfx.pfx"";
    string xml = @""C:\Users\marek\Downloads\mfcr\souhr20141.xml"";
    X509Certificate2 cert = new X509Certificate2(pfx, ""thepass"");

    byte[] publicBytes = cert.RawData;

    //var f = new FileStream(xml, System.IO.FileMode.Open);
    var fileContent = System.IO.File.ReadAllBytes(xml);

    char[] cArray = System.Text.Encoding.ASCII.GetString(fileContent).ToCharArray();
    RSACryptoServiceProvider rsa = (RSACryptoServiceProvider)cert.PrivateKey;

    byte[] signedData = rsa.SignData(new System.Text.UTF8Encoding().GetBytes(cArray), new SHA1CryptoServiceProvider());

    RSACryptoServiceProvider rsa2 = (RSACryptoServiceProvider)new X509Certificate2(publicBytes).PublicKey.Key;

    var dataGenerator = new CmsEnvelopedDataStreamGenerator();
    bool verified = rsa2.VerifyData(new System.Text.UTF8Encoding().GetBytes(cArray), new SHA1CryptoServiceProvider(), signedData);

    File.WriteAllBytes(@""C:\Users\marek\Downloads\mfcr\Foo.p7b"", signedData);
 }
</code></pre>

<p>The <code>WebService</code> that Iam sending the <code>Foo.p7b</code> responds with: File is not in expected format of PKCS7(DER).</p>

<p>This code for sending the <code>HttpWebRequest</code> :</p>

<pre><code>static void Main(string[] args)
    {
        try
        {

            string fileName = (@""C:\Users\marek\Downloads\mfcr\Foo.p7b"");
            WebResponse rsp = null;
            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(""https://adisepo.mfcr.cz/adistc/epo_podani"");
            request.ClientCertificates.Add(new X509Certificate(pfx,""thepass""));
            request.Method = ""POST"";
            request.ContentType = ""application/pkcs7-signature"";
            request.Credentials = CredentialCache.DefaultNetworkCredentials;
            var encoder = new UTF8Encoding();
            var reqStream = request.GetRequestStream();
            StreamWriter writer = new StreamWriter(request.GetRequestStream());
            // Write the XML text into the stream
            writer.WriteLine(GetTextFromXMLFile(fileName));
            writer.Close();
            reqStream.Close();
            rsp = request.GetResponse();
            StreamReader sr = new StreamReader(rsp.GetResponseStream());
            string result = sr.ReadToEnd();
            sr.Close();
            Console.Write(""\n p≈ô√≠kaz odesl√°n  \n"");
            Console.Write(result);
            Console.ReadLine();
            Console.Read();
        }
        catch (Exception ex)
        { Console.WriteLine(ex.ToString());
        Console.ReadLine();
        }

    }
    private static string GetTextFromXMLFile(string file)
    {
        StreamReader reader = new StreamReader(file);
        string ret = reader.ReadToEnd();
        reader.Close();
        return ret;
    }
}
</code></pre>

<p>I'm struggling with this issue for almost 5 days - I'm surely not expert on digital signature or certificates.</p>

<p>From what I learned so far - to create message like that I should do:</p>

<ol>
<li>Sign the <code>xml</code> with my <code>private key</code></li>
<li>Envelope that blob with my <code>public key</code></li>
</ol>

<p>But how could the recipient check whether I am the real sender? Should I add to <code>HttpWebRequest</code> parameter with my certificate? Or that step 2 - Enveloping the message is enough for him to check that?</p>

<p>Thank you everyone for your time and replies. </p>
","<p>Your code tries digitally sign byte representation of XML, but signing XML requires more processing before signing. For example XML requires to be canonicalized (or signed message can be injected with unsigned data), and there is a special format for enveloped signatures. I don't know what is actual method Danovy Portal uses, but if it uses standard way, you can follow the links below and sign your data.   </p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms229745%28v=vs.110%29.aspx"" rel=""noreferrer"">MSDN: How to: Sign XML Documents with Digital Signatures</a></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms767623%28v=vs.85%29.aspx"" rel=""noreferrer"">How enveloped signatures look</a></p>

<p>And just for information (don't think you really need to read this)
<a href=""http://www.w3.org/TR/xmldsig-core/"" rel=""noreferrer"">W3C Xml Signature specification</a></p>

<p>EDIT: to send pkcs#7 message change the code. When generating </p>

<pre><code>        ContentInfo contentInfo = new ContentInfo(new System.Text.UTF8Encoding().GetBytes(cArray));
        SignedCms cms = new SignedCms (contentInfo);
        CmsSigner signer = new CmsSigner (cert);
        cms.ComputeSignature (signer);
        byte[] pkcs7=cms.Encode ();
        File.WriteAllBytes(@""../../Foo.p7b"", pkcs7);
</code></pre>

<p>When send:</p>

<pre><code>            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(""https://adisepo.mfcr.cz/adistc/epo_podani"");
            //we don't need to add certificate to POST
    //      request.ClientCertificates.Add(new X509Certificate(pfx,""test""));
            request.Method = ""POST"";
            request.ContentType = ""application/pkcs7-signature"";
            request.Credentials = CredentialCache.DefaultNetworkCredentials;
            var encoder = new UTF8Encoding();
            using (var reqStream = request.GetRequestStream())
            {
                // Write pkcs#7 into the stream
                byte[] pkcs = File.ReadAllBytes(@""../../Foo.p7b"");
                reqStream.Write(pkcs, 0, pkcs.Length);
            }
            rsp = request.GetResponse();
</code></pre>
","7420","<c#><ssl-certificate><digital-signature><certificate><pkcs#7>","4","9","2","2014-06-02 12:56:17","23990736","1","2","2538352","","2014-06-02 07:54:15","2014-05-29 13:52:05",""
"39653074","AES-CBC 128, 192 and 256 encryption decryption in Python 3 using PKCS#7 padding","<p>I have searched a lot on SO about complete encryption decryption example with my requirement. In fact, I've got many links and examples but None is working for me for AES-192-CBC mode and AES-256-CBC.</p>

<p>I have got following example which is supposed to be working with all types but it is working only with AES-128-CBC mode. I am new to Python. Can anyone help me where I am wrong?</p>

<p>I am using Python 3.4 on windows and I can not move to Python 2.7.</p>

<pre><code>import base64
from Crypto.Cipher import AES

class AESCipher:
    class InvalidBlockSizeError(Exception):
        """"""Raised for invalid block sizes""""""
        pass

    def __init__(self, key, block_size=16):
        if block_size &lt; 2 or block_size &gt; 255:
            raise AESCipher.InvalidBlockSizeError('The block size must be between 2 and 255, inclusive')
        self.block_size = block_size
        self.key = key
        self.iv = bytes(key[0:16], 'utf-8')
        print(self.key)
        print(key[0:16])

    def __pad(self, text):
        text_length = len(text)
        amount_to_pad = self.block_size - (text_length % self.block_size)
        if amount_to_pad == 0:
            amount_to_pad = self.block_size
        self.pad = chr(amount_to_pad)
        return text + self.pad * amount_to_pad

    def __unpad(self, text):
        #pad = ord(text[-1])
        #return text[:-pad]
        text = text.rstrip(self.pad)
        return text

    def encrypt( self, raw ):
        raw = self.__pad(raw)
        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)
        return base64.b64encode(cipher.encrypt(raw)) 

    def decrypt( self, enc ):
        enc = base64.b64decode(enc)
        cipher = AES.new(self.key, AES.MODE_CBC, self.iv )
        return self.__unpad(cipher.decrypt(enc).decode(""utf-8""))

e = AESCipher('1234567812345678', 16)
#e = AESCipher('123456781234567812345678', 24)
#e = AESCipher('12345678123456781234567812345678', 32)
secret_data = ""hi""
enc_str = e.encrypt(secret_data)
print('enc_str: ' + enc_str.decode())
dec_str = e.decrypt(enc_str)
print('dec str: ' + dec_str)
</code></pre>

<p>Though this code encrypts the data with 192 and 256 bit encryption and successfully decrypt that too but my other .Net and Ruby application only able to decrypt the data which was encrypted using 128 encryption.</p>

<p>Note .Net and Ruby application are successfully tested with each other and with online encryption tool with all encryption types.</p>

<p><strong>Note that my application requires AES-CBC mode and PKCS#7 padding and must be run on Python 3.4.</strong></p>
","<p>Made it working by padding of 16 bytes for any encryption types. For that I used AES.block_size which is 16 by default for AES.</p>

<pre><code>import base64
from Crypto.Cipher import AES

class AESCipher:
    class InvalidBlockSizeError(Exception):
        """"""Raised for invalid block sizes""""""
        pass

    def __init__(self, key):
        self.key = key
        self.iv = bytes(key[0:16], 'utf-8')
        print(self.key)
        print(key[0:16])

    def __pad(self, text):
        text_length = len(text)
        amount_to_pad = AES.block_size - (text_length % AES.block_size)
        if amount_to_pad == 0:
            amount_to_pad = AES.block_size
        pad = chr(amount_to_pad)
        return text + pad * amount_to_pad

    def __unpad(self, text):
        pad = ord(text[-1])
        return text[:-pad]

    def encrypt( self, raw ):
        raw = self.__pad(raw)
        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)
        return base64.b64encode(cipher.encrypt(raw)) 

    def decrypt( self, enc ):
        enc = base64.b64decode(enc)
        cipher = AES.new(self.key, AES.MODE_CBC, self.iv )
        return self.__unpad(cipher.decrypt(enc).decode(""utf-8""))

e = AESCipher('1234567812345678', 16)
#e = AESCipher('123456781234567812345678', 24)
#e = AESCipher('12345678123456781234567812345678', 32)
secret_data = ""hi""
enc_str = e.encrypt(secret_data)
print('enc_str: ' + enc_str.decode())
dec_str = e.decrypt(enc_str)
print('dec str: ' + dec_str)
</code></pre>
","7277","<python><aes><pycrypto><pkcs#7><cbc-mode>","1","2","1","2016-09-26 09:01:04","","0","","1816580","","2016-09-25 19:05:14","2016-09-23 05:17:15",""
"3267594","C# Create MIME Message?","<p>Is there any built in functionality to MIME a file in C# .Net? What I am looking to do is:</p>

<ol>
<li>Convert a file into a MIME message</li>
<li>Sign the MIME Message to a pcks 7 blob</li>
<li>MIME that pkcs 7 blob</li>
<li>Finally encrypt the entire thing.</li>
</ol>

<p>Any suggestions on how I would go about this (not the encryption or signing part but the MIMEing)? What exactly is envolved in MIMEing a file?</p>
","<p>There is a good commercial package for a small fee:
<a href=""http://www.mime4.net/"" rel=""nofollow noreferrer"">Mime4Net</a></p>
","7066","<c#><mime><pkcs#7>","3","2","3","2010-08-02 20:39:10","3337670","0","2","","","","2010-07-16 17:55:50",""
"3267594","C# Create MIME Message?","<p>Is there any built in functionality to MIME a file in C# .Net? What I am looking to do is:</p>

<ol>
<li>Convert a file into a MIME message</li>
<li>Sign the MIME Message to a pcks 7 blob</li>
<li>MIME that pkcs 7 blob</li>
<li>Finally encrypt the entire thing.</li>
</ol>

<p>Any suggestions on how I would go about this (not the encryption or signing part but the MIMEing)? What exactly is envolved in MIMEing a file?</p>
","<p>Rather than deal with third party libraries, I suggest you look to the core .NET library. Use the <a href=""http://msdn.microsoft.com/en-us/library/system.net.mail.attachment.aspx"" rel=""nofollow noreferrer"">Attachment</a> class; it's been around since .NET 2. </p>
","7066","<c#><mime><pkcs#7>","3","2","3","2010-08-02 20:39:10","3337670","0","2","","","","2010-07-16 17:55:50",""
"3267594","C# Create MIME Message?","<p>Is there any built in functionality to MIME a file in C# .Net? What I am looking to do is:</p>

<ol>
<li>Convert a file into a MIME message</li>
<li>Sign the MIME Message to a pcks 7 blob</li>
<li>MIME that pkcs 7 blob</li>
<li>Finally encrypt the entire thing.</li>
</ol>

<p>Any suggestions on how I would go about this (not the encryption or signing part but the MIMEing)? What exactly is envolved in MIMEing a file?</p>
","<p>As far as I know there is no such support in the bare .NET. You have to try one of third party libraries. One of them is our <a href=""http://www.rebex.net/secure-mail.net/"" rel=""nofollow noreferrer"">Rebex Secure Mail for .NET</a>. Following code shows how to achieve it:</p>

<pre><code>using Rebex.Mail;
using Rebex.Mime.Headers;
using Rebex.Security.Certificates;
...

// load the sender's certificate and 
// associated private key from a file 
Certificate signer = Certificate.LoadPfx(""hugo.pfx"", ""password"");

// load the recipient's certificate 
Certificate recipient = Certificate.LoadDer(""joe.cer"");

// create an instance of MailMessage 
MailMessage message = new MailMessage();

// set its properties to desired values 
message.From = ""hugo@example.com"";
message.To = ""joe@example.com"";
message.Subject = ""This is a simple message"";
message.BodyText = ""Hello, Joe!"";
message.BodyHtml = ""Hello, &lt;b&gt;Joe&lt;/b&gt;!"";

// sign the message using Hugo's certificate 
message.Sign(signer);

// and encrypt it using Joe's certificate 
message.Encrypt(recipient);

// if you wanted Hugo to be able to read the message later as well, 
// you can encrypt it for Hugo as well instead - comment out the previous 
// encrypt and uncomment this one: 
// message.Encrypt(recipient, signer) 
</code></pre>

<p>(Code taken from the <a href=""http://www.rebex.net/secure-mail.net/tutorial-mail-secure.aspx#creating-encrypted-message"" rel=""nofollow noreferrer"">S/MIME tutorial page</a>)</p>
","7066","<c#><mime><pkcs#7>","3","2","3","2010-08-02 20:39:10","3337670","0","2","","","","2010-07-16 17:55:50",""
"7096877","Warning: openssl_pkcs7_sign() [function.openssl-pkcs7-sign]: error getting private key in C:\xampp\htdocs\this\tcpdf\tcpdf.php on line 8366","<p>I am using TCPDF to sign PDF, but when running the <a href=""http://www.tcpdf.org/examples/example_052.phps"" rel=""nofollow"">example 52</a> I got this error:</p>

<pre><code>Warning: openssl_pkcs7_sign() [function.openssl-pkcs7-sign]: error getting 
private key in C:\xampp\htdocs\this\tcpdf\tcpdf.php on line 8366
</code></pre>

<p>Could you please tell me or guide me where is the problem. I am just running the example without changing anything. I am using xampp.</p>
","<p>The problem is with the location from where it tries to access the private key. Instead of '' like in their example use 'file://'.( dirname(<strong>FILE</strong>)).'./path/to/file'. This worked for me.</p>
","6484","<php><openssl><tcpdf><pkcs#7>","7","4","3","2016-04-15 12:21:28","","0","1","1401975","","2013-03-26 09:24:44","2011-08-17 17:21:42",""
"7096877","Warning: openssl_pkcs7_sign() [function.openssl-pkcs7-sign]: error getting private key in C:\xampp\htdocs\this\tcpdf\tcpdf.php on line 8366","<p>I am using TCPDF to sign PDF, but when running the <a href=""http://www.tcpdf.org/examples/example_052.phps"" rel=""nofollow"">example 52</a> I got this error:</p>

<pre><code>Warning: openssl_pkcs7_sign() [function.openssl-pkcs7-sign]: error getting 
private key in C:\xampp\htdocs\this\tcpdf\tcpdf.php on line 8366
</code></pre>

<p>Could you please tell me or guide me where is the problem. I am just running the example without changing anything. I am using xampp.</p>
","<p>I solved it by using:</p>

<pre><code>$certificate = 'file://'.realpath('../tcpdf.crt');
</code></pre>

<p>When you create your own certificate use this:</p>

<pre><code>/*
NOTES:
 - To create self-signed signature: openssl req -x509 -nodes -days 365000 -newkey rsa:1024 -keyout tcpdf.crt -out tcpdf.crt
 - To export crt to p12: openssl pkcs12 -export -in tcpdf.crt -out tcpdf.p12
 - To convert pfx certificate to pem: openssl pkcs12 -in tcpdf.pfx -out tcpdf.crt -nodes
*/
</code></pre>
","6484","<php><openssl><tcpdf><pkcs#7>","7","3","3","2016-04-15 12:21:28","","0","1","1401975","","2013-03-26 09:24:44","2011-08-17 17:21:42",""
"7096877","Warning: openssl_pkcs7_sign() [function.openssl-pkcs7-sign]: error getting private key in C:\xampp\htdocs\this\tcpdf\tcpdf.php on line 8366","<p>I am using TCPDF to sign PDF, but when running the <a href=""http://www.tcpdf.org/examples/example_052.phps"" rel=""nofollow"">example 52</a> I got this error:</p>

<pre><code>Warning: openssl_pkcs7_sign() [function.openssl-pkcs7-sign]: error getting 
private key in C:\xampp\htdocs\this\tcpdf\tcpdf.php on line 8366
</code></pre>

<p>Could you please tell me or guide me where is the problem. I am just running the example without changing anything. I am using xampp.</p>
","<p>Finally, after weeks ago, I found the solution. I just donwloaded the TCPDF 5.9 Version and it works :D if you wanna try, here's the link to download that version</p>

<p>link: <a href=""https://sourceforge.net/code-snapshots/git/u/u/u/mynetx/tcpdf.git/u-mynetx-tcpdf-5828c0d80580cbad069988e2067ad5e37e1e98e7.zip"" rel=""nofollow"">https://sourceforge.net/code-snapshots/git/u/u/u/mynetx/tcpdf.git/u-mynetx-tcpdf-5828c0d80580cbad069988e2067ad5e37e1e98e7.zip</a> </p>
","6484","<php><openssl><tcpdf><pkcs#7>","7","0","3","2016-04-15 12:21:28","","0","1","1401975","","2013-03-26 09:24:44","2011-08-17 17:21:42",""
"6108564","Problems reading authenticating a SAML assertion in .Net using WSSecurityTokenSerializer","<p>I have a SAML assertion that I wish to authenticate in .Net using <code>WSSecurityTokenSerializer</code>.</p>

<p>I've got the key-chain and SAML XML, despite <a href=""https://stackoverflow.com/questions/6099467"">a few issues</a>.</p>

<p>First I get the SAML assertion from the HTTPS POST:</p>

<pre><code>// spec says ""SAMLResponse="" 
string rawSamlData = Request[""SAMLResponse""];

// read the base64 encoded bytes
byte[] samlData = Convert.FromBase64String(rawSamlData);

// read back into a UTF string
string samlAssertion = Encoding.UTF8.GetString(samlData);

// get the SAML data in an XML reader
var assertionPostStream = new StringReader(samlAssertion);
var reader = XmlReader.Create(assertionPostStream);
</code></pre>

<p>Then I get the keys provided by my IdP:</p>

<pre><code>// get the key data
byte[] certificateData = System.IO.File.ReadAllBytes(""myKeys.p7b"");

// decode the keys
var cms = new SignedCms(SubjectIdentifierType.IssuerAndSerialNumber);
cms.Decode(certificateData);

// we have a keychain of X509Certificate2s, we need a collection of tokens
var certificatesAsTokens =
    from X509Certificate2 cert in cms.Certificates
    select new X509SecurityToken(cert) as SecurityToken;

// get a token resolver
var tokens = new ReadOnlyCollection&lt;SecurityToken&gt;(
    certificatesAsTokens.ToList());
var resolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(
    tokens, true);
</code></pre>

<p>Finally I get an error thrown here: </p>

<pre><code>// use the WS Security stuff to parse the reader
var securityToken = WSSecurityTokenSerializer.
    DefaultInstance.ReadToken(reader, resolver) as SamlSecurityToken;
</code></pre>

<p>When calling that <code>ReadToken</code> I get the following error:</p>

<blockquote>
  <p>Cannot read the token from the 'Response' element with the 'urn:oasis:names:tc:SAML:2.0:protocol' namespace for BinarySecretSecurityToken, with a '' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</p>
</blockquote>

<p>My SAML XML starts with:</p>

<pre><code>&lt;Response xmlns=""urn:oasis:names:tc:SAML:2.0:protocol"" ...
</code></pre>

<p>So clearly I have a <code>Response</code> element in the <code>urn:oasis:names:tc:SAML:2.0:protocol</code> namespace.</p>

<p>Any idea what's wrong/missing here?</p>
","<p>It looks like you are receiving a SAML2 response. Although there is support for SAML2 in .NET 4.5, there is unfortunately only support for the assertions - not the protocol itself (including the Response message).</p>

<p>To process the SAML2 response in .NET you have to:</p>

<ol>
<li>Validate the signature on the entire response message.</li>
<li>Extract the assertion part of the message.</li>
<li>Read the token with <code>Saml2SecurityTokenHandler.ReadToken()</code>.</li>
<li>Validate the token with <code>Saml2SecurityTokenHandler.DetectReplayedToken()</code>.</li>
<li>Validate the token with <code>Saml2SecurityTokenHandler.ValidateConditions()</code></li>
<li>Use <code>Saml2SecurityTokenHandler.CreateClaims()</code> to create a claims identity.</li>
</ol>

<p>Unfortunately most of those methods are protected, but you can subclass <code>Saml2SecurityTokenHandler</code> and get access to them.</p>

<p>A complete working example can be found in the <a href=""https://github.com/Sustainsys/Saml2/blob/1.0/Sustainsys.Saml2/SAML2P/Saml2Response.cs"" rel=""nofollow noreferrer"">Saml2Response</a> class in the <a href=""https://github.com/Sustainsys/Saml2"" rel=""nofollow noreferrer"">Sustainsys.Saml2</a> project.</p>
","6366","<.net><single-sign-on><x509certificate><pkcs#7><saml-2.0>","3","5","1","2019-02-06 11:00:35","20858413","1","2","-1","","2017-05-23 12:15:36","2011-05-24 09:46:50",""
"2377402","How to encode a value in PKCS7 with Java?","<p>I would like to use PKCS7 encryption to encode a value together with Java and Java Servlet. Is there any available library and references to do the encryption? Any sample or tutorial that I could follow?</p>

<p>Thank you.</p>
","<p>For general cryptografy I use <a href=""http://www.bouncycastle.org/specifications.html"" rel=""nofollow noreferrer"">bouncycastle library</a>. I haven't used PKCS7, but there is example how to use it: <a href=""http://i-proving.com/space/Technologies/JCE/PKCS7+Signatures+using+Bouncy+Castle"" rel=""nofollow noreferrer"">PKCS7 Signatures using Bouncy Castle</a></p>
","6321","<java><encryption><encoding><pkcs#7>","2","4","1","2012-05-30 21:23:38","2377581","1","1","","","","2010-03-04 07:03:44",""
"7579269","Verify Digital Signature with SignedCms","<p>I get the CryptographicException ""The hash value is not correct."" I tried verifyCms.CheckSignature(true); (same error)
I tried to add in ContentInfo the whole mail (Sender , Subject , Body, HTML Sectione ...) (same error)</p>

<pre><code>public static bool Verify(byte[] signature, X509Certificate2 certificate)
{
       X509Certificate2 cert=new X509Certificate2(@""D:\Work\Digital Signature\smime.p7s"");
   certificate = cert;

    if(signature == null)
        throw new ArgumentNullException(""signature"");
    if(certificate == null)
        throw new ArgumentNullException(""certificate"");

    //the text from the body of the mail    
    string text = ""FINAL TEST SIGNED"";
    //hash the text 
     // Methode 3 for Hashing
            System.Security.Cryptography.SHA1 hash3 = System.Security.Cryptography.SHA1.Create();
            System.Text.UnicodeEncoding encoder = new System.Text.UnicodeEncoding();
            byte[] combined = encoder.GetBytes(text);
            byte[] hash3byte = hash3.ComputeHash(combined);

    //Adding the text from the email, to a contentInfo 
      ContentInfo content = new ContentInfo(hash3byte);

    // decode the signature
    SignedCms verifyCms = new SignedCms(content,true);
    verifyCms.Decode(signature);

    // verify it
    try
    {
        verifyCms.CheckSignature(new X509Certificate2Collection(certificate), false);
        return true;
    }
    catch(CryptographicException)
    {
        return false;
    }
} 
</code></pre>

<p>Where is the problem?</p>
","<p>You can <a href=""https://stackoverflow.com/questions/8584280/how-to-use-rsaencryption-to-create-pkcs7-cms-in-c-sharp-with-sha1-digest"">see my post</a>.</p>

<p>Just change the Oid 'SHA1' to the the algorithm you need.</p>
","6282","<c#><digital-signature><x509certificate><pkcs#7>","0","0","1","2019-08-10 19:01:50","","1","","107625","","2019-07-11 10:12:41","2011-09-28 06:43:29",""
"15969733","Verify PKCS#7 (PEM) signature / unpack data in node.js","<p>I get a PKCS#7 crypto package from a 3rd party system.
The package is not compressed and not encrypted, PEM-encoded, signed with X.509 certificate.
I also have a PEM cert file from the provider.</p>

<p>The data inside is XML</p>

<p>I need to do the following in Node.JS:</p>

<ul>
<li>extract the data</li>
<li>verify the signature</li>
</ul>

<p>A sample package (no sensitive info, data refers to our qa system) <a href=""http://pastebin.com/7ay7F99e"" rel=""noreferrer"">http://pastebin.com/7ay7F99e</a></p>
","<p>OK, finally got it.</p>

<p>First of all, PKCS messages are complex structures binary-encoded using <a href=""http://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One"" rel=""nofollow noreferrer"">ASN1</a>.</p>

<p>Second, they can be serialized to binary files (<a href=""http://en.wikipedia.org/wiki/Distinguished_Encoding_Rules#DER_encoding"" rel=""nofollow noreferrer"">DER encoding</a>) or text PEM files using <a href=""http://en.wikipedia.org/wiki/Base64"" rel=""nofollow noreferrer"">Base64</a> encoding.</p>

<p>Third, <a href=""http://tools.ietf.org/html/rfc2315"" rel=""nofollow noreferrer"">PKCS#7 format</a> specifies several package types from which my is called Signed Data. These formats are distinguished by OBJECT IDENTIFIER value in the beginning of the ASN1 object (1st element of the wrapper sequence) ‚Äî you can go to <a href=""http://lapo.it/asn1js/"" rel=""nofollow noreferrer"">http://lapo.it/asn1js/</a> and paste the <a href=""http://pastebin.com/7ay7F99e"" rel=""nofollow noreferrer"">package text</a> for the fully parsed structure.</p>

<p>Next, we need to parse the package (Base64 -> ASN1 -> some object representation). Unfortunately, there's no npm package for that. I found quite a good project <a href=""https://github.com/digitalbazaar/forge/"" rel=""nofollow noreferrer"">forge</a> that is not published to npm registry (though npm-compatible). It parsed PEM format but the resulting tree is quite an unpleasant thing to traverse. Based on their Encrypted Data and Enveloped Data implementations I created partial implementation of Signed Data in my own fork. <strong>UPD:</strong> my pull request was later merged to the forge project.</p>

<p>Now finally we have the whole thing parsed. 
At that point I found a great (and probably the only on the whole web) explanative article on signed PKCS#7 verification: <a href=""http://qistoph.blogspot.com/2012/01/manual-verify-pkcs7-signed-data-with.html"" rel=""nofollow noreferrer"">http://qistoph.blogspot.com/2012/01/manual-verify-pkcs7-signed-data-with.html</a></p>

<p>I was able to extract and successfully decode the signature from the file, but the hash inside was different from the data's hash. God bless Chris who <a href=""http://qistoph.blogspot.com/2012/01/manual-verify-pkcs7-signed-data-with.html?showComment=1366358745362#c7080164702597052179"" rel=""nofollow noreferrer"">explained</a> what actually happens.</p>

<p>The data signing process is 2-step:</p>

<ol>
<li>original content's hash is calculated</li>
<li>a set of ""Authorized Attributes"" is constructed including: type of the data singed, signing time and data hash</li>
</ol>

<p>Then the set from step 2 is signed using the signer's private key.</p>

<p>Due to PKCS#7 specifics this set of attributes is stored inside of the context-specific constructed type (class=0x80, type=0) but should be signed and validated as normal SET (class=0, type=17).</p>

<p>As Chris mentions (<a href=""https://stackoverflow.com/a/16154756/108533"">https://stackoverflow.com/a/16154756/108533</a>) this only verifies that the attributes in the package are valid. We should also validate the actual data hash against the digest attribute.</p>

<p>So finally here's a code doing validation (<code>cert.pem</code> is a certificate file that the provider sent me, <code>package</code> is a PEM-encoded message I got from them over HTTP POST):</p>

<pre><code>var fs = require('fs');
var crypto = require('crypto');
var forge = require('forge');
var pkcs7 = forge.pkcs7; 
var asn1 = forge.asn1;
var oids = forge.pki.oids;

var folder = '/a/path/to/files/';
var pkg = fs.readFileSync(folder + 'package').toString();
var cert = fs.readFileSync(folder + 'cert.pem').toString();


var res = true;

try {
    var msg = pkcs7.messageFromPem(pkg);
    var attrs = msg.rawCapture.authenticatedAttributes;
    var set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
    var buf = Buffer.from(asn1.toDer(set).data, 'binary');

    var sig = msg.rawCapture.signature;

    var v = crypto.createVerify('RSA-SHA1');
    v.update(buf);
    if (!v.verify(cert, sig)) {
        console.log('Wrong authorized attributes!');
        res = false;
    }

    var h = crypto.createHash('SHA1');
    var data = msg.rawCapture.content.value[0].value[0].value;
    h.update(data);

    var attrDigest = null;
    for (var i = 0, l = attrs.length; i &lt; l; ++i) {
        if (asn1.derToOid(attrs[i].value[0].value) === oids.messageDigest) {
            attrDigest = attrs[i].value[1].value[0].value;
        }
    }

    var dataDigest = h.digest();
    if (dataDigest !== attrDigest) {
        console.log('Wrong content digest');
        res = false;
    }

}
catch (_e) {
    console.dir(_e);
    res = false;
}

if (res) {
    console.log(""It's OK"");
}
</code></pre>
","5890","<javascript><node.js><pem><pkcs#7>","11","10","3","2018-09-27 00:46:12","16154756","0","6","108533","","2013-04-13 12:42:13","2013-04-12 11:04:27",""
"15969733","Verify PKCS#7 (PEM) signature / unpack data in node.js","<p>I get a PKCS#7 crypto package from a 3rd party system.
The package is not compressed and not encrypted, PEM-encoded, signed with X.509 certificate.
I also have a PEM cert file from the provider.</p>

<p>The data inside is XML</p>

<p>I need to do the following in Node.JS:</p>

<ul>
<li>extract the data</li>
<li>verify the signature</li>
</ul>

<p>A sample package (no sensitive info, data refers to our qa system) <a href=""http://pastebin.com/7ay7F99e"" rel=""noreferrer"">http://pastebin.com/7ay7F99e</a></p>
","<p>Your answer is a big step in the right direction. You are however missing out an essential part of the validation!</p>

<p>You should verify the hash of the data against the digest contained in the signed attributes. Otherwise it would be possible for someone to replace the content with malicious data. Try for example validating the following 'package' with your code (and have a look at the content): <a href=""http://pastebin.com/kaZ2XQQc"" rel=""nofollow"">http://pastebin.com/kaZ2XQQc</a></p>

<p>I'm not much of a NodeJS developer (this is actually my first try :p), but here's a suggestion to help you get started.</p>

<pre><code>var fs = require('fs');
var crypto = require('crypto');
var pkcs7 = require('./js/pkcs7'); // forge from my own fork
var asn1 = require('./js/asn1');

var folder = '';
var pkg = fs.readFileSync(folder + 'package').toString();
var cert = fs.readFileSync(folder + 'cert.pem').toString();

try {
    var msg = pkcs7.messageFromPem(pkg);
    var attrs = msg.rawCapture.authenticatedAttributes; // got the list of auth attrs
    var set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs); // packed them inside of the SET object
    var buf = new Buffer(asn1.toDer(set).data, 'binary'); // DO NOT forget 'binary', otherwise it tries to interpret bytes as UTF-8 chars

    var sig = msg.rawCapture.signature;

    var shasum = crypto.createHash('sha1'); // better be based on msg.rawCapture.digestAlgorithms
    shasum.update(msg.rawCapture.content.value[0].value[0].value);

    for(var n in attrs) {
        var attrib = attrs[n].value;
        var attrib_type = attrib[0].value;
        var attrib_value = attrib[1].value[0].value;
        if(attrib_type == ""\x2a\x86\x48\x86\xf7\x0d\x01\x09\x04"") { // better would be to use the OID (1.2.840.113549.1.9.4)
            if(shasum.digest('binary') == attrib_value) {
                console.log('hash matches');

                var v = crypto.createVerify('RSA-SHA1');
                v.update(buf);
                console.log(v.verify(cert, sig)); // -&gt; should type true
            } else {
                console.log('hash mismatch');
            }
        }
    }

}
catch (_e) {
    console.dir(_e);
}
</code></pre>
","5890","<javascript><node.js><pem><pkcs#7>","11","4","3","2018-09-27 00:46:12","16154756","0","6","108533","","2013-04-13 12:42:13","2013-04-12 11:04:27",""
"15969733","Verify PKCS#7 (PEM) signature / unpack data in node.js","<p>I get a PKCS#7 crypto package from a 3rd party system.
The package is not compressed and not encrypted, PEM-encoded, signed with X.509 certificate.
I also have a PEM cert file from the provider.</p>

<p>The data inside is XML</p>

<p>I need to do the following in Node.JS:</p>

<ul>
<li>extract the data</li>
<li>verify the signature</li>
</ul>

<p>A sample package (no sensitive info, data refers to our qa system) <a href=""http://pastebin.com/7ay7F99e"" rel=""noreferrer"">http://pastebin.com/7ay7F99e</a></p>
","<p>based on inspiration form <a href=""https://stackoverflow.com/questions/15969733/verify-pkcs7-pem-signature-unpack-data-in-node-js/16148331#16148331"">this answer</a>, I've implemented a <a href=""https://github.com/MohammedEssehemy/node-sign-validate-pdf"" rel=""nofollow noreferrer"">sample</a> for signing and verifying pdf files using <a href=""https://github.com/vbuch/node-signpdf/"" rel=""nofollow noreferrer"">node-signpdf</a> and <a href=""https://github.com/digitalbazaar/forge"" rel=""nofollow noreferrer"">node-forge</a>.</p>
","5890","<javascript><node.js><pem><pkcs#7>","11","2","3","2018-09-27 00:46:12","16154756","0","6","108533","","2013-04-13 12:42:13","2013-04-12 11:04:27",""
"24567623","How to see what attributes are signed inside pkcs#7?","<p>I have a pkcs#7 file, which contains signed data. It successfully verifies:</p>

<pre><code>$ openssl smime -verify -in data.p7s -CAfile root-certificate.pem 
Verification successful
Signed data
</code></pre>

<p>But when I extract the signed part, I do not see that it is actually the same as what was signed. I mean the following steps:</p>

<pre><code>$ openssl asn1parse -in data.p7s
...
   35:d=4  hl=2 l=   9 prim: OBJECT            :pkcs7-data
   46:d=4  hl=2 l=inf  cons: cont [ 0 ]        
   48:d=5  hl=2 l=inf  cons: OCTET STRING      
   50:d=6  hl=2 l=   5 prim: OCTET STRING      :(my data is here in plaintext)
...
(then the signed block starts:)
 2861:d=6  hl=2 l=   9 prim: OBJECT            :rsaEncryption
 2872:d=6  hl=2 l=   0 prim: NULL              
 2874:d=5  hl=4 l= 256 prim: OCTET STRING      [HEX DUMP]:&lt;signed data is here&gt;
</code></pre>

<p>I cut the <code>[HEX DUMP]</code> with the signed data:</p>

<pre><code>$ dd if=data.p7s of=signed-part.bin bs=1 skip=2878 count=256
</code></pre>

<p>Decrypt it with the corresponding public key:</p>

<pre><code>$ openssl rsautl -verify -in signed-part.bin -pubin -inkey root-public-key.pem -out verified-data.bin
</code></pre>

<p>and look inside the result:</p>

<pre><code>$ openssl asn1parse -inform der -in verified-data.bin
    0:d=0  hl=2 l=  33 cons: SEQUENCE          
    2:d=1  hl=2 l=   9 cons: SEQUENCE          
    4:d=2  hl=2 l=   5 prim: OBJECT            :sha1
   11:d=2  hl=2 l=   0 prim: NULL              
   13:d=1  hl=2 l=  20 prim: OCTET STRING      [HEX DUMP]:&lt;hash here&gt;
</code></pre>

<p>This <code>[HEX DUMP]</code> is <em>not</em> the SHA1 sum of my original data.</p>

<p>I do not understand why the hash is different. Obviously, it's a hash of something different than my original data. Does the hash also cover any ""Authenticated attributes""? If yes, how to see what exactly attributes have been hashed and signed?</p>
","<p>OK, you don't provide a full sample, but I'll try to navigate you nevertheless, with a different sample.</p>

<p>OpenSSL <code>asn1parse</code> does not help much identifying the authenticated attributes. You can use OpenSSL <code>cms</code>:</p>

<pre><code>openssl cms -in data.p7s -noout -cmsout -print
</code></pre>

<p>Look for <code>signedAttrs</code> (""signed attributes"" is how the ""authenticated attributes"" are now called, in CMS terminology)</p>

<p>It will look like this:</p>

<pre><code>    ...
    signerInfos:
        ...
        signedAttrs:
            object: contentType (1.2.840.113549.1.9.3)
            value.set:
              OBJECT:pkcs7-data (1.2.840.113549.1.7.1)    
            object: signingTime (1.2.840.113549.1.9.5)
            ...
</code></pre>

<p>Now go back to <code>asn1parse</code> output, and find the corresponding part, which may look like:</p>

<pre><code> ...
 1343:d=5  hl=3 l= 216 cons:      cont [ 0 ]
 1346:d=6  hl=2 l=  24 cons:       SEQUENCE
 1348:d=7  hl=2 l=   9 prim:        OBJECT            :contentType
 1359:d=7  hl=2 l=  11 cons:        SET
 1361:d=8  hl=2 l=   9 prim:         OBJECT            :pkcs7-data
 1372:d=6  hl=2 l=  28 cons:       SEQUENCE
 1374:d=7  hl=2 l=   9 prim:        OBJECT            :signingTime
 ...
</code></pre>

<p>(for this nice indentation, add <code>-i</code> option)</p>

<p>Now, extract (<code>dd ...</code>) the data, including the DER context tag header, i.e. offset 1343, length 219, in this case. Then replace the <code>0xa0</code> byte at the beginning by <code>0x31</code>. Why you have to do it, is described in <a href=""https://stackoverflow.com/questions/3638495/der-encoding-how-to-convert-implicit-tag-to-explicit-tag"">DER encoding - How to convert implicit tag to explicit tag</a>, or <a href=""http://tools.ietf.org/html/rfc5652#section-5.4"" rel=""nofollow noreferrer"">RFC5652, section 5.4</a></p>

<p>The sha1 hash of this data should now match.</p>
","5873","<openssl><sign><pkcs#7>","5","5","1","2014-07-07 08:45:54","24581628","2","5","3608247","","2014-07-04 08:43:04","2014-07-04 06:01:10",""
"7112148","Parse PKCS #7 SSL Certificate Chain (.p7b) without private key?","<p>I have a PKCS #7, signed, .p7b file which contains an X509 SSL certificate and the intermediate and root CA certs it was signed with. I need to use C# to parse the .p7b file, pull out the SSL certificate, and pull some values off of it (expiry date, DN, etc).</p>

<p>I've tried reading it as an X509 certificate like so:</p>

<pre><code>//certContent is a byte array with the p7b file contents
X509Certificate2 cert = new X509Certificate2(certContent);
</code></pre>

<p>That works fine with a regular .cer certificate, but throws a <code>CryptographicException</code> when used with a .p7b certificate. This is because the .p7b contains the entire certificate chain.</p>

<p>I've also tried parsing it as a <code>SignedCms</code> object, then iterating through the certificate chain and pulling out my SSL certificate:</p>

<pre><code>SignedCms certContainer = new SignedCms();
certContainer.Decode(certContent);
foreach(X509Certificate2 cert in certConatiner.Certificates)
{
     ...
}
</code></pre>

<p>However that throws an exception on <code>Decode</code> saying <code>ASN1 bad tag value met</code>. After some searching, I believe that is because I do not have the private key which was used to create the certificate and/or sign the certificate.</p>

<p>Does anyone know how I can parse this .p7b certificate chain using C#? </p>
","<p>Well, I'm an idiot. I opened up the .p7b file and realized it was just base64 on the inside. I pulled out the base64, decoded that, then parsed that as a signed CMS and all is well.</p>

<pre><code>String content = Encoding.UTF8.GetString(certContent);
String base64Content = content.Replace(""-----BEGIN CERTIFICATE-----"", """").Replace(""-----END CERTIFICATE-----"", """").Replace(""\r"", """").Replace(""\n"", """");
byte[] decodedContent = Convert.FromBase64String(base64Content);
SignedCms certContainer = new SignedCms();
certContainer.Decode(decodedContent);
</code></pre>
","5636","<c#><security><ssl><certificate><pkcs#7>","4","4","1","2011-08-18 18:29:35","7112301","0","3","","","","2011-08-18 18:19:49",""
"8584280","How to Use RSAEncryption to create PKCS7/CMS with SHA1 digest?","<p>I create a pkcs7 block,and can verify myself, but the result is not the same with my partner who use    OpenSSL.The p7 block I create cannot verify by my partner.</p>

<p>we check the code carefully, just find the code which cannot find counterpart in c#,</p>

<p>OPENSSL:</p>

<pre><code> signInfo-&gt;digest_enc_alg-&gt;algorithm=OBJ_nid2obj(NID_rsaEncryption);
</code></pre>

<p>Here is the code us C# in .net 4.0, can everyone know that how to Use <strong>RSAEncryption</strong> in <strong>p7</strong>?</p>

<pre><code>public static string Sign(byte[] data, X509Certificate2 certificate)
        {
            if (data == null)
                throw new ArgumentNullException(""data"");
            if (certificate == null)
                throw new ArgumentNullException(""certificate"");

            //1 setup the data to sign           
            Oid digestOid = new Oid(""1.2.840.113549.1.7.2"");//pkcs7 signed 
            ContentInfo content = new ContentInfo(digestOid, data);           
            try
            {      
                //2,SignerCms
                SignedCms signedCms = new SignedCms(content, true); //detached = true           

                //3. CmsSigner
                CmsSigner signer = new CmsSigner(SubjectIdentifierType.IssuerAndSerialNumber, certificate);       

                signer.DigestAlgorithm = new Oid(""1.3.14.3.2.26"");//sha1

                //4.create signature
                signedCms.ComputeSignature(signer);          

                //5,to Base64
                byte[] signEnv = signedCms.Encode();                
                return  Convert.ToBase64String(signEnv);               

            }catch (Exception e)
            {
                Console.WriteLine(e);
            }
            return null;
        }
</code></pre>
","","4972","<c#><rsa><pkcs#7>","2","","0","2017-03-05 03:49:44","","0","1","521757","","2017-03-05 03:49:44","2011-12-21 02:03:50",""
"36887197","JAVA Encryption with AES/CBC/PKCS7Padding","<p>I got problem with encryption using java AES/CBC/PKCS7Padding. I have already search and follow throuh till using the <code>BouncyCastle</code> provider. But I still cant get the right encryption</p>

<p>Let say the requirements are:</p>

<p>Encryption Type: Symmetric<br>
Algorithm: AES<br>
Blocksize = 128Bit (16 Bytes)<br>
Cipher mode: CBC<br>
Padding mode: PKCS7<br>
Encryption key length: 256 Bit (32 Bytes)<br>
Vector Initialization Length (IV): 128 Bit (16 Bytes)  </p>

<p>sample: </p>

<p>Plain data = ABC123<br>
Encrypted data (base64 encoded) = CtGtW4hJfXxilSfNR1xmrg== </p>

<p>and my code is...</p>

<pre><code>public final class StringFunc {
    final static String key = ""jb2a19ou79rws6zknjlr803fvfgiyp1k"";
    final static String algorithm = ""AES/CBC/PKCS7Padding"";
    final static String iv = ""hod74ty97wr97g83"";
    private static Cipher cipher = null;
    private static SecretKeySpec skeySpec = null;
    private static IvParameterSpec  ivSpec = null;

    private static void setUp(){
        try{
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); 
            skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
            ivSpec = new IvParameterSpec(iv.getBytes());
            cipher = Cipher.getInstance(algorithm);
        }catch(NoSuchAlgorithmException | NoSuchPaddingException ex){
        }
    }

    public static String encrypt(String str){
        try{
            Integer strL = (int) Math.ceil(str.length() / 8.0);
            Integer strB = strL*8;
            str = padRight(str, '', strB);
            setUp();
            try {
                cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);
            } catch (InvalidAlgorithmParameterException ex) {
                return """";
            }
            byte[] enc = cipher.doFinal(str.getBytes());
            return new String(Base64.encodeBase64(enc));
        }catch(InvalidKeyException | IllegalBlockSizeException | BadPaddingException ex){
            return """";            
        }
    }

    public static String padRight(String msg, char x, int l) {
        String result = """";
        if (!msg.isEmpty()) {
            for (int i=0; i&lt;(l-msg.length()); i++) {
                result = result + x;
            }
            result = msg + result;
        }
        return result;
    }
}
</code></pre>

<p>I still cant get the right encryption. Anyone can help or give suggestion?</p>
","<p>Guessing from the given input, you should run into Javas restriction of the key length:
Since the US doesn't allow usage of hard security keys, Java is restricted to a key length of 128bit per default.</p>

<p>To enable keys >128bit you have to change the policy of your Java version with the offical ""unlimited"" policies (<a href=""http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html"" rel=""nofollow"">here for SE8</a>)</p>

<p>Overwriting the current policies in lib/security with the download should be enough.</p>
","4889","<java><encryption><aes><pkcs#7>","0","0","1","2016-04-27 13:54:55","","3","2","1816580","","2016-04-27 13:20:27","2016-04-27 10:28:58",""
"5167174","Problems with pkcs7 file validation","<p>I have a big and strange problem with PKCS7 securities files.
I create a p7s file like what is suggested in <a href=""http://www.thatsjava.com/java-tech/85019/"" rel=""nofollow"">http://www.thatsjava.com/java-tech/85019/</a> where it creatse the file and validates it using only sun libraries. It works fine.<br>
The problem starts when I want to validate this file. It returns this exception:</p>

<pre class=""lang-none prettyprint-override""><code>java.security.SignatureException: Signature encoding error
        at sun.security.rsa.RSASignature.engineVerify(RSASignature.java:185)
        at java.security.Signature$Delegate.engineVerify(Signature.java:1140)
        at java.security.Signature.verify(Signature.java:592)
        at sun.security.pkcs.SignerInfo.verify(SignerInfo.java:374)
        at sun.security.pkcs.PKCS7.verify(PKCS7.java:494)
        at sun.security.pkcs.PKCS7.verify(PKCS7.java:511)
        at sun.security.pkcs.PKCS7.verify(PKCS7.java:533)
        at firma.FirmaDigitalImpl.firmarCadenaSun(FirmaDigitalImpl.java:553)
        at firma.FirmaDigitalImpl.firmarCadena(FirmaDigitalImpl.java:249)
        at firma.FirmaDigitalImpl.firmarCadena(FirmaDigitalImpl.java:147)
        at firma.TestFirma.main(TestFirma.java:75)
Caused by: java.io.IOException: Sequence tag error
        at sun.security.util.DerInputStream.getSequence(DerInputStream.java:280)
        at sun.security.rsa.RSASignature.decodeSignature(RSASignature.java:209)
        at sun.security.rsa.RSASignature.engineVerify(RSASignature.java:174)
        ... 10 more
</code></pre>

<p>But the problems don't appear always, just only with a type of certificates used to sign.  I will explain better.
I have two certificates (stored into smartcard) and the first works fine; I create the p7s and next I validate correctly, but the second certificate allows me to create the p7s, file but when I validate it, it returns the SignatureException.  I thought the p7s file was wrong, but I tested it with others' applications, and it looks correct. Besides, this file is sent throws webservice and it returns that it is ok! </p>

<p>And for more information, if the p7s file is created with different tools (.net and capicom) and the same certificate, then I can validate correctly.</p>

<p>I have looked for the solution, but nothing.  I have found the same exception in similar situations, but either the solution suggested doesn't work for me, or it doesn't appear.</p>

<p>Any advice to find the solution will be very appreciated.</p>
","<p>It might be encoding problem: text vs. binary.  PKCS7 can be in either DER-encoded binary format or PEM-format (which is base64 encoded DER).  Open the files in a text editor (e.g. notepad) and see whether the one which works is binary or text.</p>
","4744","<java><security><validation><x509certificate><pkcs#7>","0","1","2","2016-07-09 05:26:02","","0","","5827958","","2016-07-09 05:19:06","2011-03-02 12:02:11",""
"5167174","Problems with pkcs7 file validation","<p>I have a big and strange problem with PKCS7 securities files.
I create a p7s file like what is suggested in <a href=""http://www.thatsjava.com/java-tech/85019/"" rel=""nofollow"">http://www.thatsjava.com/java-tech/85019/</a> where it creatse the file and validates it using only sun libraries. It works fine.<br>
The problem starts when I want to validate this file. It returns this exception:</p>

<pre class=""lang-none prettyprint-override""><code>java.security.SignatureException: Signature encoding error
        at sun.security.rsa.RSASignature.engineVerify(RSASignature.java:185)
        at java.security.Signature$Delegate.engineVerify(Signature.java:1140)
        at java.security.Signature.verify(Signature.java:592)
        at sun.security.pkcs.SignerInfo.verify(SignerInfo.java:374)
        at sun.security.pkcs.PKCS7.verify(PKCS7.java:494)
        at sun.security.pkcs.PKCS7.verify(PKCS7.java:511)
        at sun.security.pkcs.PKCS7.verify(PKCS7.java:533)
        at firma.FirmaDigitalImpl.firmarCadenaSun(FirmaDigitalImpl.java:553)
        at firma.FirmaDigitalImpl.firmarCadena(FirmaDigitalImpl.java:249)
        at firma.FirmaDigitalImpl.firmarCadena(FirmaDigitalImpl.java:147)
        at firma.TestFirma.main(TestFirma.java:75)
Caused by: java.io.IOException: Sequence tag error
        at sun.security.util.DerInputStream.getSequence(DerInputStream.java:280)
        at sun.security.rsa.RSASignature.decodeSignature(RSASignature.java:209)
        at sun.security.rsa.RSASignature.engineVerify(RSASignature.java:174)
        ... 10 more
</code></pre>

<p>But the problems don't appear always, just only with a type of certificates used to sign.  I will explain better.
I have two certificates (stored into smartcard) and the first works fine; I create the p7s and next I validate correctly, but the second certificate allows me to create the p7s, file but when I validate it, it returns the SignatureException.  I thought the p7s file was wrong, but I tested it with others' applications, and it looks correct. Besides, this file is sent throws webservice and it returns that it is ok! </p>

<p>And for more information, if the p7s file is created with different tools (.net and capicom) and the same certificate, then I can validate correctly.</p>

<p>I have looked for the solution, but nothing.  I have found the same exception in similar situations, but either the solution suggested doesn't work for me, or it doesn't appear.</p>

<p>Any advice to find the solution will be very appreciated.</p>
","<p>After more than two weeks, I have noticed what was the problem, although I didn't find the full solution.</p>

<p>First, I extracted the problem out of the PKCS7 file, and I reproduced the exception with the following source code:</p>

<pre><code>import diz.firma.keyStore.SmartCard;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.Signature;

public class TestFirma3 {
public static void main(String args[]) throws Exception {
    //Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    SmartCard sm = new SmartCard();
    KeyStore ks = sm.loadKeyStore(""1234"");
    //KeyPair keyPair = generateKeyPair(999);


    byte[] data = ""original"".getBytes(""UTF-8"");
    //byte[] data = { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74 };
    //byte[] digitalSignature = signData(data, keyPair.getPrivate());
    byte[] digitalSignature = signData(data,
            (PrivateKey)ks.getKey(sm.getAlias(), null),ks.getProvider());

    boolean verified;

    //verified = verifySig(data, keyPair.getPublic(), digitalSignature);
    verified = verifySig(data, ks.getCertificate(sm.getAlias()).
            getPublicKey(),ks.getProvider(), digitalSignature);
    System.out.println(""verified:"" + verified) ;

    //keyPair = generateKeyPair(888);
    //verified = verifySig(data, keyPair.getPublic(), digitalSignature);
    //System.out.println(verified);

  }

  public static byte[] signData(byte[] data, PrivateKey key,Provider p) throws Exception {
    Signature signer = Signature.getInstance(""SHA1withRSA"",p);
    //Signature signer = Signature.getInstance(""SHA1withRSA"",Security.getProviders()[10]);

    signer.initSign(key);
    signer.update(data);
    return (signer.sign());
  }

  public static boolean verifySig(byte[] data, PublicKey key, Provider p, byte[] sig) throws Exception {
    Signature signer = Signature.getInstance(""SHA1withRSA"",p);
    //Signature signer = Signature.getInstance(""SHA1withRSA"");
    signer.initVerify(key);
    signer.update(data);

    boolean valido = false;
    try{
        valido = signer.verify(sig);
    }catch(Exception e){
        e.printStackTrace();
        valido = false;
    }
    return valido;

  }

  public static KeyPair generateKeyPair(long seed) throws Exception {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(""DSA"");
    SecureRandom rng = SecureRandom.getInstance(""SHA1PRNG"", ""SUN"");
    rng.setSeed(seed);
    keyGenerator.initialize(1024, rng);

    return (keyGenerator.generateKeyPair());
  }
}
</code></pre>

<p>In this code, (extracted from an example in the net), I changed the generators key and took it from my card. I got the exception again, without using PKCS7 files.</p>

<p>Looking at all providers (with Security.getProviders() you can get all of them; they are defined in java.security file, but it can be added to or taken from in runtime), and I used everyone to sign and validate, I found out that:</p>

<ol>
<li>If no one provider is selected when Signature is instantiated, it uses SunRsaSign by default.</li>
<li>My Signature is validated with 2 providers:<br>
a) With SunMSCAPI provider, which uses Microsoft Crypt API.<br>
b) With the provider created by smart card reader, in my case Siemens.</li>
<li>Reading another smart card that does not belong to Siemens, it is validated with SunRsaSign and SunJSSE.</li>
</ol>

<p>At this moment, I find out the problem and a workarournd using SunMSCAPI to validate, but I have to validate into an IBM machine.  Siemens software provides an option to install into Unix, but I cannot get it to work. And using SunMSCAPI, I suppose it isn't available for IBM.</p>

<p>So, I have to find out a provider that validates correctly in IMB the Signature that SunRsaSign returns SignatureException.</p>
","4744","<java><security><validation><x509certificate><pkcs#7>","0","1","2","2016-07-09 05:26:02","","0","","5827958","","2016-07-09 05:19:06","2011-03-02 12:02:11",""
"10837494","Openssl command line fails to verify detached smime signature created moments earlier","<p>I'm using the command line interface of openssl 1.0.1b on OSX 10.6.</p>

<p>First I create a DSA key.</p>

<pre><code>openssl dsaparam -noout -out privatekey.pem -genkey 1024
</code></pre>

<p>Next i create a self-signed certificate from that key.</p>

<pre><code>openssl req -new -outform PEM -out certificate.pem -key privatekey.pem -keyform PEM -sha1 -x509 -days 1000
</code></pre>

<p>Next i use that certificate and key in order to create a detached smime signature of a file.</p>

<pre><code>openssl smime -sign -in file.zip -out file.zip.signature -outform DER -inkey privatekey.pem -signer certificate.pem
</code></pre>

<p>Finally I immediately try to verify that same file/signature*</p>

<pre><code>openssl smime -verify -in file.zip.signature -inform DER -content file.zip -noverify certificate.pem &gt; /dev/null
</code></pre>

<p>But somehow I get a digest failure.</p>

<pre><code>PKCS7 routines:PKCS7_signatureVerify:digest failure:pk7_doit.c:1097:
PKCS7 routines:PKCS7_verify:signature failure:pk7_smime.c:410
</code></pre>

<p>Nothing is changing the file, manual md5 hashes match before and after, yet somehow the signature digest is failing. Does anyone have any clue as to what i'm doing wrong?</p>

<p>Thanks.</p>

<p>`* <em>Note that -noverify is used to tell openssl to not warn me about the certificate being self-signed</em></p>
","<p>I've figured out the issue. </p>

<p>Because I didn't use the -binary flag openssl was transforming \n in the input file to \r\n</p>
","4564","<openssl><signature><verify><pkcs#7><smime>","4","3","1","2012-06-02 15:12:21","","0","2","1428899","","2012-05-31 16:28:34","2012-05-31 16:21:55",""
"31118893","How to load PKCS7 (.p7b) file in java","<p>I have a <code>pkcs7</code> file, and I want to load it and extract its contents.</p>

<p>I tried these two methods:</p>

<pre><code>byte[] bytes = Files.readAllBytes(Paths.get(""myfile.p7b""));
FileInputStream fi = new FileInputStream(file);

//Creating PKCS7 object
PKCS7 pkcs7Signature = new PKCS7(bytes);
</code></pre>

<p>or this</p>

<pre><code>FileInputStream fis = new FileInputStream(new File(""myfile.p7b""));
PKCS7 pkcs7Signature = new PKCS7(fis);
</code></pre>

<p>but I got <code>IOException: Sequence tag error</code></p>

<p>So how can I load this .p7b file ?</p>
","<p>Finally I did it with BouncyCastle library.</p>

<p>PKCS#7 is a complex format, also called CMS. Sun JCE has no direct support to PKCS#7.</p>

<p>This is the code that I used to extract my content:</p>

<pre><code>// Loading the file first
   File f = new File(""myFile.p7b"");
   byte[] buffer = new byte[(int) f.length()];
   DataInputStream in = new DataInputStream(new FileInputStream(f));
   in.readFully(buffer);
   in.close();

   //Corresponding class of signed_data is CMSSignedData
   CMSSignedData signature = new CMSSignedData(buffer);
   Store cs = signature.getCertificates();
   SignerInformationStore signers = signature.getSignerInfos();
   Collection c = signers.getSigners();
   Iterator it = c.iterator();

   //the following array will contain the content of xml document
   byte[] data = null;

   while (it.hasNext()) {
        SignerInformation signer = (SignerInformation) it.next();
        Collection certCollection = cs.getMatches(signer.getSID());
        Iterator certIt = certCollection.iterator();
        X509CertificateHolder cert = (X509CertificateHolder) certIt.next();

        CMSProcessable sc = signature.getSignedContent();
        data = (byte[]) sc.getContent();
    }
</code></pre>

<p>If you want to verify the signature of this PKCS7 file against X509 certificate, you must add the following code to the while loop:</p>

<pre><code>// ************************************************************* //
// ********************* Verify signature ********************** //
//get CA public key
// Create a X509 certificat
CertificateFactory certificatefactory = CertificateFactory.getInstance(""X.509"");

// Open the certificate file
FileInputStream fileinputstream = new FileInputStream(""myCA.cert"");

//get CA public key
PublicKey pk = certificatefactory.generateCertificate(fileinputstream).getPublicKey();

X509Certificate myCA = new JcaX509CertificateConverter().setProvider(""BC"").getCertificate(cert);

myCA.verify(pk);
System.out.println(""Verfication done successfully "");
</code></pre>
","4426","<java><security><digital-signature><pkcs#7>","2","2","1","2015-07-15 09:22:08","","3","","","","","2015-06-29 14:54:42",""
"8144875","Create PKCS#7 detached signature","<p>I've been googling how to do this (in Java) with very little success.<br>
Creating the Signature object is pretty straightforward and so is getting the certificate chain, but how do I create a detached PKCS#7 object with that data?</p>
","<p>Try to use <a href=""http://www.bouncycastle.org/java.html"" rel=""nofollow"">Bouncy Castle</a>. <a href=""http://i-proving.com/space/Technologies/JCE/PKCS7+Signatures+using+Bouncy+Castle"" rel=""nofollow"">Here</a> is the sample of creating PKCS7 signatures with it.</p>
","4322","<java><digital-signature><x509certificate><keystore><pkcs#7>","5","2","1","2013-10-26 23:05:20","8146264","6","","432152","","2011-11-16 15:01:32","2011-11-15 23:58:13",""
"19244860","Extracting individual .cer certificate from a .p7b file in java","<p>I am new to Cryptography and so please excuse me if you think this is a basic question</p>

<p>I have a .p7b file which I need to read and extract the individual public certificates i.e  the .cer files and store it in the key store. I need not worry about persisting in the key store as there is already a service which takes in the .cer file as <em>byte[]</em> and saves that.</p>

<p>What i want to know is , how do i read the .p7b and extract the individual .cer file? I know that can be done via the openSSL commands, but i need to do the same in java. I need to also read the <em>Issued By</em> name as that will be used as a unique key to persist the certificate.</p>

<p>Thanks in advance</p>
","<p>You can get the certificates from a PKCS#7 object with BouncyCastle. Here is a quick code sample:</p>

<pre><code> public Collection&lt;X59Certificate&gt; getCertificates(String path) throws Exception
 {
     Security.addProvider(new BouncyCastleProvider());
     CMSSignedData sd = new CMSSignedData(new FileInputStream(path));
     X509Store store = sd.getCertificates(""Collection"", ""BC"");
     Collection&lt;X509Certificate&gt; certificates = store.getMatches(X509CertStoreSelector.getInstance(new X509CertSelector()));
     return certificates;
 }
</code></pre>

<p>Note that a PKCS#7 may contain more than one certificate. Most of the time it includes intermediate certification authority certificates required to build the certificate chain between the end-user certificate and the root CA.</p>
","4215","<java><openssl><x509certificate><bouncycastle><pkcs#7>","3","2","2","2013-11-08 11:44:52","19858316","3","1","962536","","2013-11-08 11:44:52","2013-10-08 10:12:00",""
"19244860","Extracting individual .cer certificate from a .p7b file in java","<p>I am new to Cryptography and so please excuse me if you think this is a basic question</p>

<p>I have a .p7b file which I need to read and extract the individual public certificates i.e  the .cer files and store it in the key store. I need not worry about persisting in the key store as there is already a service which takes in the .cer file as <em>byte[]</em> and saves that.</p>

<p>What i want to know is , how do i read the .p7b and extract the individual .cer file? I know that can be done via the openSSL commands, but i need to do the same in java. I need to also read the <em>Issued By</em> name as that will be used as a unique key to persist the certificate.</p>

<p>Thanks in advance</p>
","<p>I was successfully able to read the individual .X509 certificates from the p7b files. Here are the steps </p>

<ul>
<li><p>First step includes, getting a byte[] from the java.io.File. The steps include to   remove the -----BEGIN PKCS7----- and -----END PKCS7----- from the file, and decode the remaining base64 encoded String.</p>

<pre><code>BufferedReader reader = new BufferedReader(new FileReader(file));
StringBuilder cerfile = new StringBuilder();
String line = null;
while(( line = reader.readLine())!=null){
  if(!line.contains(""PKCS7"")){
    cerfile.append(line);
  }
}
byte[] fileBytes = Base64.decode(cerfile.toString().getBytes());
</code></pre></li>
<li><p>The next step is to use the BouncyCastle api to parse the file</p>

<pre><code>CMSSignedData  dataParser = new CMSSignedData(trustBundleByte);
ContentInfo contentInfo = dataParser.getContentInfo();
SignedData signedData = SignedData.getInstance(contentInfo.getContent());

CMSSignedData encapInfoBundle = new CMSSignedData(new CMSProcessableByteArray(signedData.getEncapContentInfo().getContent().getDERObject().getEncoded()),contentInfo);
SignedData encapMetaData = SignedData.getInstance(encapInfoBundle.getContentInfo().getContent());

CMSProcessableByteArray cin = new CMSProcessableByteArray(((ASN1OctetString)encapMetaData.getEncapContentInfo().getContent()).getOctets());
CertificateFactory ucf = CertificateFactory.getInstance(""X.509"");

CMSSignedData  unsignedParser = new CMSSignedData(cin.getInputStream());
ContentInfo unsginedEncapInfo = unsignedParser.getContentInfo();
SignedData metaData = SignedData.getInstance(unsginedEncapInfo.getContent());
Enumeration certificates = metaData.getCertificates().getObjects();

// Build certificate path

while (certificates.hasMoreElements()) {
   DERObject certObj = (DERObject) certificates.nextElement();
   InputStream bin = new ByteArrayInputStream(certObj.getDEREncoded());
   X509Certificate cert = (X509Certificate) ucf.generateCertificate(bin);
 X500Name x500name = new JcaX509CertificateHolder(cert).getSubject();
RDN cn = x500name.getRDNs(BCStyle.CN)[0];
}
</code></pre></li>
<li><p>The above steps are working fine, but i am sure there are other solutions with less lines of code to achieve this. I am using bcjdk16 jars.</p></li>
</ul>
","4215","<java><openssl><x509certificate><bouncycastle><pkcs#7>","3","2","2","2013-11-08 11:44:52","19858316","3","1","962536","","2013-11-08 11:44:52","2013-10-08 10:12:00",""
"3513162","Add Signing Time to PKCS7 Signed CMS?","<p>I'm trying to add the signing time attribute to a file that I am signing using SignedCMS.</p>

<pre><code>private byte[] signFile(byte[] fileContent, X509Certificate2 verificationCert)
{
   ContentInfo contentInfo = new ContentInfo(fileContent);

   SignedCms signedCMS = new SignedCms(contentInfo);

   CmsSigner cmsSigner = new CmsSigner(SubjectIdentifierType.IssuerAndSerialNumber, verificationCert);

   Oid signedDate = new Oid(""1.2.840.113549.1.9.5""); //oid for PKCS #9 signing time 

   signedDate.Value = DateTime.Now.ToString();

   CryptographicAttributeObject cryptoAtty = new CryptographicAttributeObject(signedDate);

   cmsSigner.SignedAttributes.Add(cryptoAtty);

   signedCMS.ComputeSignature(cmsSigner, false);

   byte[] encoded = signedCMS.Encode();

   return encoded;
}
</code></pre>

<p>Error thrown on Encode:</p>

<pre><code>CryptographicException: The object identifier is poorly formatted. 
</code></pre>

<p>Any ideas on how to properly add the signing time? I think I may have to convert the signing time to an ASN.1 encoded object and add that to <code>cryptoAtty</code>'s values. How would one convert the date/time to an ASN.1 Encoded object? </p>
","<p><img src=""https://i.stack.imgur.com/yAwdo.jpg"" alt=""alt text""></p>

<p>Well that was easy.</p>

<pre><code>cmsSigner.SignedAttributes.Add(new Pkcs9SigningTime());
</code></pre>
","4163","<c#><security><content-management-system><signing><pkcs#7>","6","11","1","2012-07-03 16:24:58","3522814","0","2","104998","","2012-07-03 16:24:58","2010-08-18 14:31:23",""
"3753458","Opening PKCS 7 Certificate files","<p>How can I open text files which seem to be PKCS #7 Certificates.  These were archived onto floppy discs in the late 90s and have now been burned onto a CD.  I am using windows 7 on my computer</p>
","<p>OpenSSL and its <a href=""http://www.openssl.org/docs/apps/pkcs7.html"" rel=""nofollow"">pkcs7 command</a> may help you to decode your documents. Adapt the parameters to your own needs. </p>

<pre><code>openssl pkcs7 -in myfile.pem -print_certs -text
</code></pre>
","4158","<pkcs#7>","1","1","1","2010-09-26 10:33:35","","1","","","","","2010-09-20 16:31:18",""
"9062830","In Ruby/Rails, how to decrypt a string encrypted and signed by PKCS7","<p>In <a href=""http://railscasts.com/episodes/143-paypal-security"" rel=""nofollow"">this RailsCast on PayPal</a> it shows you how to encrypt a URL parameter before sending it to PayPal. </p>

<pre><code>PAYPAL_CERT_PEM = File.read(""#{Rails.root}/certs/paypal_cert.pem"")
APP_CERT_PEM = File.read(""#{Rails.root}/certs/app_cert.pem"")
APP_KEY_PEM = File.read(""#{Rails.root}/certs/app_key.pem"")
def encrypt_for_paypal(values)
    signed = OpenSSL::PKCS7::sign(OpenSSL::X509::Certificate.new(APP_CERT_PEM),        OpenSSL::PKey::RSA.new(APP_KEY_PEM, ''), values.map { |k, v| ""#{k}=#{v}"" }.join(""\n""), [], OpenSSL::PKCS7::BINARY)
    OpenSSL::PKCS7::encrypt([OpenSSL::X509::Certificate.new(PAYPAL_CERT_PEM)], signed.to_der, OpenSSL::Cipher::Cipher::new(""DES3""),        OpenSSL::PKCS7::BINARY).to_s.gsub(""\n"", """")
end
</code></pre>

<p>Suppose I was writing the code for PayPal's server. How would I decrypt this string? It appears to me that this code both public-key signs the string (to verify authenticity) and then encrypts the string (to provide privacy). What would the code be for doing the reverse, decrypting and verifying authenticity?</p>

<p>Thanks.</p>
","<p>Hi John here is an example of encryption / decryption using ruby openssl.
Note its using AES for the cypher as DES3 seemed to be dropped in my version of ruby openssl.
Calling gsub on the string to replace newlines seemed to break it so i have left it commented out.
Hope it helps you out.</p>

<pre><code>require 'openssl'

PAYPAL_CERT_PEM = File.read(""paypal_cert.pem"")
@paypal_cert = OpenSSL::X509::Certificate.new(PAYPAL_CERT_PEM)

APP_CERT_PEM = File.read(""app_cert.pem"")
@app_cert = OpenSSL::X509::Certificate.new(APP_CERT_PEM)

APP_KEY_PEM = File.read(""app_key.pem"")
@app_key = OpenSSL::PKey::RSA.new(APP_KEY_PEM, '')

PAYPAL_KEY_PEM = File.read(""paypal_key.pem"")
@paypal_key = OpenSSL::PKey::RSA.new(PAYPAL_KEY_PEM, '')

CERT_STORE = OpenSSL::X509::Store.new
CERT_STORE.add_cert(@app_cert)

data = Hash.new
data['customer_id'] = '123456789'
data['customer_name'] = 'Mr Smith'

def encrypt_for_paypal(values)
data_name_values = values.map { |k, v| ""#{k}=#{v}"" }

signed_data = OpenSSL::PKCS7::sign(@app_cert, @app_key, data_name_values.join(""\n""), [], OpenSSL::PKCS7::BINARY)

cypher = OpenSSL::Cipher::new(""AES-128-CFB"")

encrypted_data = OpenSSL::PKCS7::encrypt([@paypal_cert], signed_data.to_der, cypher, OpenSSL::PKCS7::BINARY)

encrypted_data.to_s #.gsub(""\n"", """")
end

def decrypt_by_paypal(encrypted_data)
received_encrypted_data = OpenSSL::PKCS7.new(encrypted_data)

received_signed_data = received_encrypted_data.decrypt(@paypal_key, @paypal_cert)

p7_received_signed_data = OpenSSL::PKCS7.new(received_signed_data)

p7_received_signed_data.verify(nil, CERT_STORE, nil, OpenSSL::PKCS7::NOVERIFY)

p7_received_signed_data.data
end

encrypted_txt = encrypt_for_paypal data
puts decrypt_by_paypal encrypted_txt
</code></pre>
","4074","<ruby-on-rails><encryption><pkcs#7>","1","1","1","2012-02-05 11:56:02","","2","","","","","2012-01-30 11:02:10",""
"12966460","REST APIs and message level security","<p>I need to implement message level security in a REST API and have some concerns and questions. I found the answer here: 
<a href=""https://stackoverflow.com/questions/9869828/message-level-security-in-rest-web-services"">Message Level Security in Rest Web services</a></p>

<p>only partially helpful. </p>

<p>We currently support standard SSL transport security and several authentication methods including:</p>

<ul>
<li>Basic http auth (required by some network equipment services that
talk to our API's)</li>
<li>HMAC with pre-shared secrete key in both SHA1 and    SHA256 flavors.</li>
<li>Client identity certs sent @ the TLS level. </li>
<li>SAML 2.0</li>
</ul>

<p>Why we need message level security because:</p>

<ul>
<li>Customer industries include health care, financial and government, among others, and they often frown on SSL only.</li>
<li>Need to guarantee end to end security. Through reverse proxies, SSL accelerators, etc... </li>
<li>Some data passed through the services will include very sensitive data. </li>
<li>Need to have a good answer for customers that insist that SOAP's WS-* security standards are  ""Enterprise strength"" web services and REST APIs are not.</li>
</ul>

<p>My initial thought is to use an PKCS#7 envelope, as an option, if client applications understand how to process enveloped responses. </p>

<p>I want client applications to tell the API that they want a secured response or tell the API that the message they are POSTing or PUTing is secured.</p>

<p>My real question is, should this be communicated through a media type? E.g.:</p>

<ul>
<li>Content-Type: application/vnd.resourcetype1+json+pkcs7</li>
<li>Content-Type: txt/csv+pkcs7</li>
</ul>

<p>i don't want to loose information on the media type that is enveloped. </p>

<p>It gets complicated as in some cases the signature is enough. Others require encryption as well. The term ""pkcs7"" is vague as to how the envelope is constructed. </p>

<p>I want the client and server to tell each other the type of content they are sending and the type of content they understand through standard HTTP headers.</p>
","<p>Of course, it is up to you how to define your API, there is no right or wrong way, however <a href=""http://tools.ietf.org/html/rfc3851"" rel=""nofollow"">S/MIME</a> is a very well understood message format, well suited to the internet. As is <a href=""http://tools.ietf.org/html/rfc2015"" rel=""nofollow"">PGP/MIME</a> if your prefer a de-centralised trust hierarchy. Since these are well understood formats, it will allow clients to adopt existing libraries to process these message bodies.</p>

<p>If you are adament you do not want to use a multi-part response, you may want to take a look at the <a href=""http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11"" rel=""nofollow"">Content-Encoding</a> header, besides just Content-Type. You could then specify the signature/encryption format as a custom encoding type.</p>

<p>There are significant benefits to using HTTP as an application protocol and not just a transport protocol, but you seem to understand that already. Be sure you set and parse the Accept* headers correctly, including q-values. Beware of things such as the default of q=1 meaning equal (not descending) preference, and q=0.</p>
","4024","<web-services><security><rest><pkcs#7>","10","1","1","2012-12-05 13:51:19","13724762","2","1","-1","","2017-05-23 12:31:25","2012-10-19 02:17:21",""
"3265351","BouncyCastle create PKCS 7 Encrypted File? C#","<p>I am trying to use BouncyCastle to encrypt a file using the PKCS 7 file standard. Here is the code I have which outputs a p7m file. When I go to decrypt the file (using Entrust) I am prompted for my key store password, so it knows the file was encrypted for me using AES 128, but it cannot decrypt the body of the file. Something has to be going wrong on the encrypt.</p>

<pre><code>byte[] fileContent = readFile(filename);

FileStream outStream = null;
Stream cryptoStream = null;
BinaryWriter binWriter = null;

try
{
    CmsEnvelopedDataStreamGenerator dataGenerator = new CmsEnvelopedDataStreamGenerator();
    dataGenerator.AddKeyTransRecipient(cert); //cert is the user's x509cert that i am encrypting for
    outStream = new FileStream(filename + "".p7m"", FileMode.Create);
    cryptoStream = dataGenerator.Open(outStream, CmsEnvelopedGenerator.Aes128Cbc);
    binWriter = new BinaryWriter(cryptoStream);

    binWriter.Write(fileContent);
}
</code></pre>

<p>And when i try and decrypt the file using BouncyCastle I get this error when i pass the file contents to a CMSEnveloped Object: </p>

<pre><code>IOException converting stream to byte array: Attempted to read past the end of the stream.
</code></pre>

<p>Any ideas whats going on here?</p>
","<p>I used the EnvelopedCMS class to accomplish this.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/bb924575(VS.90).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/bb924575(VS.90).aspx</a></p>
","3969","<c#><bouncycastle><encryption-asymmetric><pkcs#7>","1","0","1","2019-08-26 21:53:50","3514901","0","","","","","2010-07-16 13:34:31",""
"25388148","Sign file with .der-Certificate and create signature (pkcs#7)","<p>The thing I would like to do is:</p>

<ul>
<li>Sign a zip-file with openssl using a certificate and create a signature-file (pkcs#7)</li>
</ul>

<p>What I have/I did so far:</p>

<ol>
<li>I installed openssl and opened the console</li>
<li>I created a rsa key (openssl genrsa -out key.pem 2048)</li>
<li>I created a request (openssl req -batch -sha256 -new -key key.pem
-out request.pem ‚Äìsubj '/C=../ST=../L=../O=../OU=../CN=..')</li>
<li>I sent this request to someone who did any magic with the request
and sent me an file named 'certificate.der'. When I open this file there are some information like oscp-url and things like this.</li>
</ol>

<p>So far, so good. Next my naive approach is to sign the zip-file with this certificate and tell openssl to create the pkcs#7-signature so I can verify it using the ocsp-responder.
But I have really not the foggiest notion whether the approach is correct and how to sign the zip-file. :-( If I have errors in reasoning please also let me know. :-)</p>

<p>Can someone please help me?</p>
","<p>You can use openssl to do that. Use the command</p>

<pre><code>openssl.exe smime -sign -binary -in file.zip -signer certificate.der -inkey key.pem -outform DER -out file.p7b
</code></pre>

<p>You can verify the signature using openssl with this command</p>

<pre><code>openssl.exe smime -verify -binary -inform DER -in file.p7b -content file.zip -noverify &gt; nul
</code></pre>

<p>For more information read openssl manual <a href=""http://www.openssl.org/docs/apps/smime.html"" rel=""nofollow"">here</a></p>
","3942","<openssl><certificate><sign><pkcs#7><der>","2","3","1","2014-08-19 22:47:51","25391933","0","","608639","","2014-08-19 22:47:51","2014-08-19 16:08:56",""
"18072356","Implementing Digital Signing in a Java Applet","<p>I am trying to sign some data (a POST form) in a web based application using a Java Applet. The user's x509 certificate would be in a cryptoken/smart card. The signature needs to be in attached pkcs#7 format.</p>

<p>I am using this tutorial/code as a starting point in building the applet - <a href=""http://www.developer.com/java/other/article.php/3587361/Java-Applet-for-Signing-with-a-Smart-Card.htm"" rel=""nofollow"">http://www.developer.com/java/other/article.php/3587361/Java-Applet-for-Signing-with-a-Smart-Card.htm</a></p>

<p>The biggest problem for me here seems to be the fact that the applet asks the user for location of the pkcs#11 implementation library. This is a big no-no for me because my typical user is not going to know the location of his pkcs#11 library.</p>

<p>From Oracle's Java documentation - <a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/p11guide.html"" rel=""nofollow"">http://docs.oracle.com/javase/6/docs/technotes/guides/security/p11guide.html</a> it seems that Java doesn't come with it's own implementation.</p>

<p>Is there a way to do this signing without asking the user for this location. I am OK with a solution which only works with just IE and Firefox on Windows.</p>

<p>With a few smartcards/cryptokens I have used, I have noticed that the moment I insert it, I can see the certificate in IE &amp; Firefox's personal tab of certificates. This probably means that the crypto token registers all the certificates it contains with OS when you insert the card and deregisters it when you remove it. So it must probably be exposing some interface to the OS/Browser when it does it - can this not be used for signing?</p>
","<p>We did the thing you are trying to do now (distributed signing with client-side modules) within Distributed Cryptography add-on for our SecureBlackox product and we offer ActiveX control for IE and Java applet for other browsers. </p>

<p>Unfortunately PKCS#11 DLLs are not registered anywhere so you can't avoid asking the user about location of this DLL. </p>

<p>Most hardware devices support both PKCS#11 and CryptoAPI interfaces. Within CryptoAPI interface the CSP DLL exposes hardware-based certificates to CryptoAPI engine and thus to applications. In this case you can use Java classes that work with Windows CryptoAPI.</p>

<p>PKCS#11 is an interface, implemented by hardware vendors, so Java can't implement it's own - JVM is not a hardware and doesn't contain certificates (even if it did, that would not solve your problem). I need to notice, that Firefox has built-in PKCS#11 driver via which Firefox accesses its own certificates.  This was done for uniform support for software- and hardware-stored certificates. </p>
","3917","<java><digital-signature><jce><pkcs#7><pkcs#11>","5","3","2","2019-06-22 06:24:06","","0","1","922712","","2013-08-06 06:46:27","2013-08-06 05:25:17",""
"18072356","Implementing Digital Signing in a Java Applet","<p>I am trying to sign some data (a POST form) in a web based application using a Java Applet. The user's x509 certificate would be in a cryptoken/smart card. The signature needs to be in attached pkcs#7 format.</p>

<p>I am using this tutorial/code as a starting point in building the applet - <a href=""http://www.developer.com/java/other/article.php/3587361/Java-Applet-for-Signing-with-a-Smart-Card.htm"" rel=""nofollow"">http://www.developer.com/java/other/article.php/3587361/Java-Applet-for-Signing-with-a-Smart-Card.htm</a></p>

<p>The biggest problem for me here seems to be the fact that the applet asks the user for location of the pkcs#11 implementation library. This is a big no-no for me because my typical user is not going to know the location of his pkcs#11 library.</p>

<p>From Oracle's Java documentation - <a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/p11guide.html"" rel=""nofollow"">http://docs.oracle.com/javase/6/docs/technotes/guides/security/p11guide.html</a> it seems that Java doesn't come with it's own implementation.</p>

<p>Is there a way to do this signing without asking the user for this location. I am OK with a solution which only works with just IE and Firefox on Windows.</p>

<p>With a few smartcards/cryptokens I have used, I have noticed that the moment I insert it, I can see the certificate in IE &amp; Firefox's personal tab of certificates. This probably means that the crypto token registers all the certificates it contains with OS when you insert the card and deregisters it when you remove it. So it must probably be exposing some interface to the OS/Browser when it does it - can this not be used for signing?</p>
","<p>Smartcard or Token driver (PKCS#11) library has an additional layer called CSP (Crypto Service Provider) which acts like bridge between the device driver and OS Crypto services.  Token driver, once installed also adds this CSP and thus plunging the token or smartcard makes Certificates in it available (which acts as handle to private key stored securely on the crypto device).</p>

<p>For signing from Browser as client, applets are no more supported by modern browsers. You may use Browser Extension for the purposes which has a native application running behind the browser to access Certificate Store and provide signing function through JavaScript in the browser. Signer Digital Browser Extension offers various type of signing form browser using JavaScript. Refer to 3 different SO answer links on the page <a href=""https://signer.digital/SignerDigitalBrowserExtensions"" rel=""nofollow noreferrer"">Digitally Signing From Browser</a> for various operations to be achieved using the Web Browser Extension. </p>
","3917","<java><digital-signature><jce><pkcs#7><pkcs#11>","5","0","2","2019-06-22 06:24:06","","0","1","922712","","2013-08-06 06:46:27","2013-08-06 05:25:17",""
"17607604","Digitally Signing Data in a web app","<p>I have a web application where some data (not file) needs to be digitally signed using a PKI Private Key. The PKI Certificate &amp; Private Key will be in a USB Cryptotoken which registers the certificates with the browser when inserted into the USB slot. This eases the pain of doing authentication using the certificate because I do that by trigerring ssl-renegotiation in my Application.</p>

<p>However, using a certificate for digital signing seems to be a bit more tricky. I can think of several ways to do this</p>

<ol>
<li><p>CAPICOM - <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">http://en.wikipedia.org/wiki/CAPICOM</a>
This will work for browsers which support CAPICOM (eg. IE). However it seems that Microsoft has discontinued this.</p></li>
<li><p>Mozilla Crypto Object - <a href=""https://developer.mozilla.org/en-US/docs/JavaScript_crypto"" rel=""noreferrer"">https://developer.mozilla.org/en-US/docs/JavaScript_crypto</a></p></li>
<li><p>WebCrypto API - this is not yet supported by most browsers. </p></li>
<li><p>A custom Java Applet or some opensource freely available JavaApplet control.</p></li>
<li><p>Any other options?</p></li>
</ol>

<p>I am trying to figure out what is the common, convenient and secure way of doing this in a web-application.</p>

<p>Note:</p>

<ol>
<li>I am OK with just supporting the popular browsers.</li>
<li>I am signing a small piece of data - say 100-200 bytes rather than a file.</li>
<li>I would prefer PKCS#7 signatures.</li>
</ol>
","<p>[Disclosure: I work for CoSign.]</p>

<p>The problem that you're running into is a common one with old-style PKI systems that store the  signer's private key at the boundary (eg in a smart card, a token, etc). This system was designed when the PC (and apps running on it) was the focus. But that isn't true this century. Now either the browser or the mobile is the focus.</p>

<p>You have tension between the nature of web apps (they're either running on the host or are sandboxed JavaScript on the browser) versus the idea of local hardware that ""protects"" the private key.</p>

<p><strong>Breaking out of the browser's sandbox</strong></p>

<p>One design direction is to try to break out of the browser's sandbox to access the local hardware private key store. You've listed a number of options. An additional one is the <a href=""http://developer.chrome.com/apps/usb.html"" rel=""nofollow"">Chrome USB access library</a>. But all of these solutions are:</p>

<ul>
<li>Limited to specific browsers</li>
<li>Hard (and expensive) to install</li>
<li>Hard (and expensive) to maintain</li>
<li>High level of administrative overhead to help the users with their questions about keeping the system working.</li>
</ul>

<p><strong>Re your question 5 ""Any other options?""</strong></p>

<p><strong>Yes: Centralized signing</strong></p>

<p>A better option (IMHO) is to sign centrally. This way the keys are kept in a centralized FIPS-secure server. Meanwhile, the signers just use a webapp to authorize the signing. The signers don't need to hold the private key since it is stored in the secure server.</p>

<p>To authenticate the signers, you can use whatever level of security your app needs: user name/password; One Time Password; two factor authentication via SMS; etc.</p>

<p>The <a href=""http://www.arx.com/digital-signatures/sapi"" rel=""nofollow"">CoSign Signature API</a> and <a href=""http://www.arx.com/digital-signatures/cswa"" rel=""nofollow"">CoSign Signature Web Agent</a> are designed for this. Centralized PKI signing is also available from other vendors.</p>

<p><strong>Added in response to comment</strong></p>

<blockquote>
  <blockquote>
    <p>From the 2nd part of your answer - If the certificate is stored in the server and retrieved by authenticating the user by using uname/pwd or with 2FA, then why do digital signing at all? i.e. what advantage does it offer over just authenticating the transaction with uname/pwd or 2FA?</p>
  </blockquote>
</blockquote>

<p><strong>A:</strong> In the centralized design, the private key does <em>not</em> leave the central server. Rather, the document or data to be signed is sent to the server, is signed, and then the signed doc or data (e.g. XML) is returned to the webapp. </p>

<p>Re: why do this? Because a digitally signed document or data set (eg XML) can be <em>verified</em> to guarantee that the document was not changed since signed and provides a trust chain to provide assurance of the signer's identity. In contrast, passwords, even when strengthed by 2FA etc, only provide the <em>app</em> with signer identity assurance, not third parties.</p>

<p>PKI digital signing enables <em>third parties</em> to assure themselves of the signer's identity through the verification process. And the strength of the assurance can be set, as needed, by choosing different CAs.</p>
","3748","<security><web-applications><digital-signature><pki><pkcs#7>","8","1","2","2019-10-08 08:46:11","","2","1","922712","","2013-07-12 12:38:55","2013-07-12 04:46:21",""
"17607604","Digitally Signing Data in a web app","<p>I have a web application where some data (not file) needs to be digitally signed using a PKI Private Key. The PKI Certificate &amp; Private Key will be in a USB Cryptotoken which registers the certificates with the browser when inserted into the USB slot. This eases the pain of doing authentication using the certificate because I do that by trigerring ssl-renegotiation in my Application.</p>

<p>However, using a certificate for digital signing seems to be a bit more tricky. I can think of several ways to do this</p>

<ol>
<li><p>CAPICOM - <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">http://en.wikipedia.org/wiki/CAPICOM</a>
This will work for browsers which support CAPICOM (eg. IE). However it seems that Microsoft has discontinued this.</p></li>
<li><p>Mozilla Crypto Object - <a href=""https://developer.mozilla.org/en-US/docs/JavaScript_crypto"" rel=""noreferrer"">https://developer.mozilla.org/en-US/docs/JavaScript_crypto</a></p></li>
<li><p>WebCrypto API - this is not yet supported by most browsers. </p></li>
<li><p>A custom Java Applet or some opensource freely available JavaApplet control.</p></li>
<li><p>Any other options?</p></li>
</ol>

<p>I am trying to figure out what is the common, convenient and secure way of doing this in a web-application.</p>

<p>Note:</p>

<ol>
<li>I am OK with just supporting the popular browsers.</li>
<li>I am signing a small piece of data - say 100-200 bytes rather than a file.</li>
<li>I would prefer PKCS#7 signatures.</li>
</ol>
","<p>Modern browsers does not support Java Applets. The most recommended approach today, as I see, is use of Browser Extension to access Certificate Store From the Browser. Browser accesses Certificate store through the host application running locally.</p>

<p>Refer to this <a href=""https://stackoverflow.com/a/55692742/9659885"">SO Answer</a></p>

<p>Driver for USB tokens or smartcard has CSP (Crypto Service Provider), which makes Certificates (not private keys) in token available in Certificate Store, once the token is plugged in. On user selecting certificate for signing, the CSP uses hardware device connected at client to get content signed by sending it to crypto device.</p>
","3748","<security><web-applications><digital-signature><pki><pkcs#7>","8","0","2","2019-10-08 08:46:11","","2","1","922712","","2013-07-12 12:38:55","2013-07-12 04:46:21",""
"20659268","Message Signing using X509 certificate","<p>I am signing message using digital certificate in a asp.net web service using below code.
Signing is working fine expect signedMessage.ComputeSignature line is taking up to 30 to 40 seconds because of this i am face timeout exception. The same code when i am running under windows forms application is producing result in fraction of second. Any clue or help.</p>

<pre><code>   public static string Encrypt(string fullMessage, string certificateName, bool deAttch)
    {
        X509Certificate2 signer = GetCertificate(certificateName);  
        byte[] contentBytes = Encoding.ASCII.GetBytes(fullMessage);  
        Oid contentOid = new Oid(""1.2.840.113549.1.7.1"", ""PKCS 7 Data"");
        SignedCms signedMessage = new SignedCms(new ContentInfo(contentOid, contentBytes), deAttch);

        signedMessage.ComputeSignature(new CmsSigner(signer));

        byte[] signedBytes = signedMessage.Encode();
        return Convert.ToBase64String(signedBytes).Trim();
        }
</code></pre>
","<p>I am not sure whether this should be a answer (I don't know what impact it cause, but i will find out). Just setting a property</p>

<pre><code>cert.IncludeOption = X509IncludeOption.EndCertOnly;    
</code></pre>

<p>of</p>

<pre><code>CmsSigner cert = new CmsSigner(signer);
</code></pre>

<p>where previously i was creating object using constructor and passing directly to method. Now it is working fine and not taking that much time.</p>

<pre><code>   public static string Encrypt(string fullMessage, string certificateName, bool deAttch)
    {
        X509Certificate2 signer = GetCertificate(certificateName);  
        byte[] contentBytes = Encoding.ASCII.GetBytes(fullMessage);  
        Oid contentOid = new Oid(""1.2.840.113549.1.7.1"", ""PKCS 7 Data"");
        SignedCms signedMessage = new SignedCms(new ContentInfo(contentOid, contentBytes), deAttch);
        CmsSigner cert = new CmsSigner(signer);
        cert.IncludeOption = X509IncludeOption.EndCertOnly;            
        signedMessage.ComputeSignature(cert);
        byte[] signedBytes = signedMessage.Encode();
        return Convert.ToBase64String(signedBytes).Trim();
        }


        private static X509Certificate2 GetCertificate(string certificateName)
    {
        X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
        store.Open(OpenFlags.OpenExistingOnly | OpenFlags.ReadOnly);
        X509Certificate2 certificate = store.Certificates.Cast&lt;X509Certificate2&gt;().Where(cert =&gt; cert.Subject.IndexOf(certificateName) &gt;= 0).FirstOrDefault();
        if (certificate == null)
            throw new Exception(""Certificate "" + certificateName + "" not found."");

        return certificate;
    }
</code></pre>
","3717","<c#><x509><pkcs#7>","0","3","1","2015-07-28 13:26:48","20727241","0","2","1232227","","2015-07-28 13:26:48","2013-12-18 13:16:10",""
"19410688","PKCS#7 Signature Verification","<p>I am trying to implement signature verification for PDFs. It is a big topic so I am taking it one step at a time, first I am trying to actually return a positive in the case of a PDF I have signed myself, using all the default values with the current Acrobat ‚Äî that should be SHA256 for the digest, and a PKCS7 detached signature. So, I crack out openssl, and by reading the byte range given in the PDF and calling the <code>SHA256_*</code> functions I have a hash to compare against. So now I need to read the certificate data etc, and use the <code>PKCS7_*</code> functions. This one looks to be the one I want:</p>

<pre><code>int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store, BIO *indata, BIO *out, int flags);
</code></pre>

<p>as <a href=""http://www.openssl.org/docs/crypto/PKCS7_verify.html"" rel=""noreferrer"">found in the documentation</a>. Except said documentation doesn't tell me how to construct any of these things. Ok, so I think the <code>BIO *indata</code> can be made with some of the functions in <a href=""http://www.openssl.org/docs/crypto/BIO_new.html"" rel=""noreferrer"">here</a> and the array of certs using <a href=""http://www.openssl.org/docs/crypto/X509_new.html"" rel=""noreferrer"">these</a> (despite having not worked out the precise details), but what about the <code>PKCS7 *p7</code>, or the <code>STACK_OF(x)</code> called for. I cannot find any documented way of initialising these structures. There are some pkcs7_ctrl functions in the <code>pkcs7.h</code> header:-</p>

<pre><code>long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg);

int PKCS7_set_type(PKCS7 *p7, int type);
int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other);
int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data);
int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey, const EVP_MD *dgst);
int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si);
int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *p7i);
int PKCS7_add_certificate(PKCS7 *p7, X509 *x509);
int PKCS7_add_crl(PKCS7 *p7, X509_CRL *x509);
int PKCS7_content_new(PKCS7 *p7, int nid);
int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx,
    BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si); 
int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si, X509 *x509);

BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio);
int PKCS7_dataFinal(PKCS7 *p7, BIO *bio);
BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert);
</code></pre>

<p>but without some guidelines this doesn't seem like a forest it would be efficacious to start blindly poking around in. </p>

<p>Have I missed something obvious? How do I go about calling this function with the data values I have parsed from the PDF?</p>
","<p>Ok, found all this out the (very) hard way. This is how you do it, so that others might learn more easily.</p>

<p>Lets say we have the signature <code>char* sig</code> of length <code>int sig_length</code>, and verification data <code>char* data</code>, <code>int data_length</code>. (There are some subtleties here for PDF signatures but these are well documented in the PDF spec.)</p>

<pre><code>OpenSSL_add_all_algorithms();
OpenSSL_add_all_digests();
EVP_add_digest(EVP_md5());
EVP_add_digest(EVP_sha1());
EVP_add_digest(EVP_sha256());

BIO* sig_BIO = BIO_new_mem_buf(sig, sig_length)
PKCS7* sig_pkcs7 = d2i_PKCS7_bio(sig_BIO, NULL);

BIO* data_BIO = BIO_new_mem_buf(data, data_length)
BIO* data_pkcs7_BIO = PKCS7_dataInit(sig_pkcs7, data_BIO);

// Goto this place in the BIO. Why? No idea!
char unneeded[1024*4];
while (BIO_read(dataPKCS7_BIO, unneeded, sizeof(buffer)) &gt; 0);

int result;
X509_STORE *certificateStore = X509_STORE_new();
X509_STORE_CTX certificateContext;
STACK_OF(PKCS7_SIGNER_INFO) *signerStack = PKCS7_get_signer_info(sig_pkcs7);
int numSignerInfo = sk_PKCS7_SIGNER_INFO_num(signerStack);
for (int i=0; i&lt;numSignerInfo; ++i) {
    PKCS7_SIGNER_INFO *signerInfo = sk_PKCS7_SIGNER_INFO_value(signerStack, i);
    result = PKCS7_dataVerify(certificateStore, &amp;certificateContext, data_pkcs7_BIO, sig_pkcs7, signerInfo);
}

X509_STORE_CTX_cleanup(&amp;certificateContext);
BIO_free(sig_BIO);
BIO_free(data_BIO);
BIO_free(data_pkcs7_BIO);
PKCS7_free(sig_pkcs7);
X509_STORE_free(certificateStore);
</code></pre>

<p>The function that does the work is actually PKCS7_dataVerify, and you don't need to run any digests yourself.</p>

<p>But wait, if you try this, it won't work! Why? Because the verification does both trust and integrity. In addition to this, you will also need to either establish trust by adding certs to the store, which is also complicated and undocumented. If you want fine grain results for you'll want to set a callback on the verification via the certificate store like this:</p>

<pre><code>X509_VERIFY_PARAM_set_flags(certificateStore-&gt;param, X509_V_FLAG_CB_ISSUER_CHECK);
X509_STORE_set_verify_cb_func(certificateStore, verificationCallback);
</code></pre>

<p>where</p>

<pre><code>static int verificationCallback(int ok, X509_STORE_CTX *ctx) {
    switch (ctx-&gt;error)
    {
        case X509_V_ERR_INVALID_PURPOSE: //...
        case X509_V_ERR_CERT_HAS_EXPIRED: //...
        case X509_V_ERR_KEYUSAGE_NO_CERTSIGN: //... 
        case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: //...
        // ... etc
        default: break;
    }
    return ok;
}
</code></pre>

<p>You can set the error to ok and tell it to verify, for example if you want to ignore expired certs:</p>

<pre><code>static int verificationCallback(int ok, X509_STORE_CTX *ctx) {
    switch (ctx-&gt;error)
    {
        case X509_V_ERR_CERT_HAS_EXPIRED: 
            X509_STORE_CTX_set_error(ctx, X509_V_OK);
            ok = 1;
            break;
    }
    return ok;
}
</code></pre>
","3702","<c><security><openssl><digital-signature><pkcs#7>","9","8","1","2013-10-25 11:54:24","19588319","0","2","1324720","","2013-10-17 10:38:19","2013-10-16 18:11:02",""
"4600149","PEM Conversion (PKCS7) to DER - AKA Base64 C++ Problems","<p>I've just finished up writing some OpenSSL/PKCS7 digital signature code and now have a working PEM encoded PKCS7 file. So after little battle, I need to convert that PEM to DER format. This is proving tougher than I hoped.</p>

<p>There are some convenience methods in OpenSSL such as ""PEM_write_bio_PKCS7_stream"" to write your PKCS7 object. But after some extensive googling and browsing some header files, I can't seem to find anything to take a PKCS7 object and write it to anything (BIO, FILE, char*) in DER format.</p>

<p>So feeling defeated there, I turned to parsing out the header &amp; footer in the PEM file and Base64 decoding the contents. As a check, I did this with Java &amp; BouncyCastle and got exactly what I want.</p>

<p>Here's my code for that. With almost every Base64 decoder I try I turn something like this...</p>

<pre><code>MIIHmwYJKoZIhvcNAQcCoIIHjDCCB4gCAQExCzAJBgUrDgMCGgUAMIIBrQYJKoZI
hvcNAQc ... Lots More stuff
... +8L5ad45D/7ZGJWafaSw==
</code></pre>

<p>into...</p>

<pre><code>0\202\233   *\367\367
\240\202\2140\202\21010 +
</code></pre>

<p>Here's that code...</p>

<pre><code>    string PKCS7String(starting_point);

    string PEM_PKCS7_HEADER(""-----BEGIN PKCS7-----\n"");
    string PEM_PKCS7_FOOTER(""\n-----END PKCS7-----"");

    string::size_type pos = 0;
    while ( (pos = PKCS7String.find(PEM_PKCS7_HEADER, pos)) != string::npos ) {
        PKCS7String.replace( pos, PEM_PKCS7_HEADER.length(), """" );
        pos++;
    }

    pos = 0;
    while ( (pos = PKCS7String.find(PEM_PKCS7_FOOTER, pos)) != string::npos ) {
        PKCS7String.replace( pos, PEM_PKCS7_FOOTER.length(), """" );
        pos++;
    }
    //Take your pick of decoders, they all do the same thing. Here's just the most recent
    auto_ptr&lt; uint8_t &gt; decoded = decode(PKCS7String);
    uint8_t* array = decoded.get();
    cout &lt;&lt; array &lt;&lt; endl;
</code></pre>

<p>Any thoughts?</p>
","<p>A PEM file is just a Base64 encoded version of the DER file with the <code>-----BEGIN PKCS7-----</code> &amp; <code>-----END PKCS7-----</code> header and footer lines.<br>
So not exactly sure what you expect to see after Base64 decoding it...</p>

<p>As a test just:  </p>

<ol>
<li><p>package a certificate in PKCS#7 PEM format: <code>$ openssl crl2pkcs7 -nocrl -out outfile.pem.p7b -certfile server.crt -outform pem</code></p></li>
<li><p>package the same certificate in PKCS#7 DER format: <code>$ openssl crl2pkcs7 -nocrl -out outfile.der.p7b -certfile server.crt -outform der</code></p></li>
<li><p>Base64 decode the body of the PEM file (<code>outfile.pem.p7b</code>) with the decoder of your choice &amp; compare the binary output with the DER file (<code>outfile.der.p7b</code>)</p></li>
</ol>

<p>Now, I'm afraid this may be what you asked for but not what you wanted...</p>
","3663","<c++><openssl><base64><pem><pkcs#7>","0","3","2","2011-01-05 04:05:12","4600732","0","","","","","2011-01-05 01:45:00",""
"4600149","PEM Conversion (PKCS7) to DER - AKA Base64 C++ Problems","<p>I've just finished up writing some OpenSSL/PKCS7 digital signature code and now have a working PEM encoded PKCS7 file. So after little battle, I need to convert that PEM to DER format. This is proving tougher than I hoped.</p>

<p>There are some convenience methods in OpenSSL such as ""PEM_write_bio_PKCS7_stream"" to write your PKCS7 object. But after some extensive googling and browsing some header files, I can't seem to find anything to take a PKCS7 object and write it to anything (BIO, FILE, char*) in DER format.</p>

<p>So feeling defeated there, I turned to parsing out the header &amp; footer in the PEM file and Base64 decoding the contents. As a check, I did this with Java &amp; BouncyCastle and got exactly what I want.</p>

<p>Here's my code for that. With almost every Base64 decoder I try I turn something like this...</p>

<pre><code>MIIHmwYJKoZIhvcNAQcCoIIHjDCCB4gCAQExCzAJBgUrDgMCGgUAMIIBrQYJKoZI
hvcNAQc ... Lots More stuff
... +8L5ad45D/7ZGJWafaSw==
</code></pre>

<p>into...</p>

<pre><code>0\202\233   *\367\367
\240\202\2140\202\21010 +
</code></pre>

<p>Here's that code...</p>

<pre><code>    string PKCS7String(starting_point);

    string PEM_PKCS7_HEADER(""-----BEGIN PKCS7-----\n"");
    string PEM_PKCS7_FOOTER(""\n-----END PKCS7-----"");

    string::size_type pos = 0;
    while ( (pos = PKCS7String.find(PEM_PKCS7_HEADER, pos)) != string::npos ) {
        PKCS7String.replace( pos, PEM_PKCS7_HEADER.length(), """" );
        pos++;
    }

    pos = 0;
    while ( (pos = PKCS7String.find(PEM_PKCS7_FOOTER, pos)) != string::npos ) {
        PKCS7String.replace( pos, PEM_PKCS7_FOOTER.length(), """" );
        pos++;
    }
    //Take your pick of decoders, they all do the same thing. Here's just the most recent
    auto_ptr&lt; uint8_t &gt; decoded = decode(PKCS7String);
    uint8_t* array = decoded.get();
    cout &lt;&lt; array &lt;&lt; endl;
</code></pre>

<p>Any thoughts?</p>
","<p><code>i2d_PKCS7_fp()</code> and <code>i2d_PKCS7_bio()</code> from <code>&lt;openssl/pkcs7.h&gt;</code> will write out a <code>PKCS7</code> structure in DER format to a file stream or BIO respectively.</p>
","3663","<c++><openssl><base64><pem><pkcs#7>","0","0","2","2011-01-05 04:05:12","4600732","0","","","","","2011-01-05 01:45:00",""
"25162605","Signature Verification (formate is PKCS#7)","<p>I have following in the XML
1.  tag : Signature in this is in the PKCS#7 format, This is an international standard. The signature includes the Signer's public key certificate as part of the PKCS#7 bag, along with the encrypted hash of data. 
2. tag: Original Data  is in this tag. </p>

<p>I don't understand how to verify the signature. Client said that ""Any API /  tool that can read the PKCS#7 Signature can give you the Public Key."" </p>

<p>The examples which I saw require public key separately to verify the signature. Is it even possible that required public key float with signature and some tool will automatically identify it and verify the data?
If yes, I am not able to find any java API which will verify this signature.</p>
","<p>As a prologue, first rule of cryptography : do not do it yourself, use proven tools in their documented use cases to perform the operations.</p>

<p>So I'd first check if you XML document is indeed signed using a standard (I don't know of an XML signature format that is based on PKCS7, but then, I sure don't know everything). If so, I'd find a library that supports this specific format. </p>

<p>XML Signature is standardized along the <code>XMLD Sig</code> umbrella, formalized here : <a href=""http://www.w3.org/TR/xmldsig-core/"" rel=""nofollow noreferrer"">http://www.w3.org/TR/xmldsig-core/</a>. The Oracle JDK ships with a reference implementation (that is derived from an Apache implementation of the standard), using the <code>XMLSignatureFactory</code> base class.</p>

<p>PKCS7 is not used as part of XML DSig, though, so you may have to ""do it yourself"" (a small enough part of if) in the end, unless there is a protocol that I do not know of.</p>

<p>That said, indeed PKCS7 (superseeded in some cases by CMS) is a standard cryptographic format that allows the signature of arbitrary content. The structure is flexible enough to hold notably : the content to be signed (it can be embedded, or not), the signature and associated algorithm identifiers, plus X509 material linked to the signature (such as Certificates and public keys, certificate revocation lists...).</p>

<p>The Java language does not provide a generic implementation of PKCS7 processing to my knowledge, although the Oracle JDK does under the <code>sun.security.pkcs</code> package. </p>

<p>A popular, common library for PKCS7 processing in Java is BouncyCastle. I'm more familiar with it, so this is what I'll talk about.  </p>

<p>You can find a usage sample here :
<a href=""http://i-proving.com/2007/09/21/pkcs7-signatures-using-bouncy-castle/"" rel=""nofollow noreferrer"">http://i-proving.com/2007/09/21/pkcs7-signatures-using-bouncy-castle/</a></p>

<p>Bouncy Castle has a fairly good example package when you download the source, and also Javadoc. So you can check it out for up-to-date usage of the API. Check for example : 
<a href=""https://www.bouncycastle.org/docs/pkixdocs1.5on/org/bouncycastle/cms/CMSSignedData.html"" rel=""nofollow noreferrer"">https://www.bouncycastle.org/docs/pkixdocs1.5on/org/bouncycastle/cms/CMSSignedData.html</a>, reproduced here for easier reference</p>

<pre><code>CMSSignedData           s = new CMSSignedData(inputStream);
Store                   certStore = s.getCertificates(); // This is where you access embedded certificates
SignerInformationStore  signers = s.getSignerInfos();
Collection              c = signers.getSigners();
Iterator                it = c.iterator();

while (it.hasNext())
{
  SignerInformation   signer = (SignerInformation)it.next();
  Collection          certCollection = certStore.getMatches(signer.getSID());

  Iterator              certIt = certCollection.iterator();
  X509CertificateHolder cert = (X509CertificateHolder)certIt.next();

  if (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert)))
  {
      verified++;
  } 
}
</code></pre>

<p>Remember though, that checking the validity of the signature is one step, the second is to verify that the signing certificates are indeed trustworthy. An example is available here :</p>

<p><a href=""https://stackoverflow.com/questions/3166159/verifying-pkcs7-certificates-in-java"">Verifying PKCS#7 certificates in Java</a></p>
","3645","<java><pkcs#7>","0","2","1","2014-08-06 15:24:36","25164172","0","","","","","2014-08-06 14:09:28",""
"41579325","Golang: How do I decrypt with DES, CBC, and PKCS7?","<p>Currently trying to figure out why my decryption method is not working. I used DES, CBC, and PKCS7Padding to encrypt my string. My current <a href=""https://play.golang.org/p/FZN6POxqU8"" rel=""nofollow noreferrer"">code</a> outputs <code>panic: crypto/cipher: input not full blocks</code> during decryption. </p>
","<p>Buddy it's work completely fine. </p>

<pre><code>package main

    import (
        ""bytes""
        ""crypto/des""
        ""crypto/cipher""
        ""fmt""
    )

    func DesEncryption(key, iv, plainText []byte) ([]byte, error) {

        block, err := des.NewCipher(key)

        if err != nil {
            return nil, err
        }

        blockSize := block.BlockSize()
        origData := PKCS5Padding(plainText, blockSize)
        blockMode := cipher.NewCBCEncrypter(block, iv)
        cryted := make([]byte, len(origData))
        blockMode.CryptBlocks(cryted, origData)
        return cryted, nil
    }

    func DesDecryption(key, iv, cipherText []byte) ([]byte, error) {

        block, err := des.NewCipher(key)

        if err != nil {
            return nil, err
        }

        blockMode := cipher.NewCBCDecrypter(block, iv)
        origData := make([]byte, len(cipherText))
        blockMode.CryptBlocks(origData, cipherText)
        origData = PKCS5UnPadding(origData)
        return origData, nil
    }

    func PKCS5Padding(src []byte, blockSize int) []byte {
        padding := blockSize - len(src)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(src, padtext...)
    }

    func PKCS5UnPadding(src []byte) []byte {
        length := len(src)
        unpadding := int(src[length-1])
        return src[:(length - unpadding)]
    }


    func main() {
        originalText := ""sysys""
        fmt.Println(originalText)
        mytext := []byte(originalText)

        key := []byte{0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC }
        iv := []byte{0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC }


        cryptoText,_ := DesEncryption(key, iv, mytext)
        fmt.Println(string(cryptoText))
        decryptedText,_ := DesDecryption(key, iv, cryptoText)
        fmt.Println(string(decryptedText))

    }
</code></pre>
","3628","<go><base64><des><pkcs#7><cbc-mode>","1","3","1","2017-01-11 16:13:46","41595640","5","1","4021006","","2017-01-11 15:38:50","2017-01-10 22:10:39",""
"13379846","Extract userCertificate from PKCS7 envelop in python","<p>Ok, I am trying to verify data from PKCS7 envelop using Python.</p>

<p>I have the working code in Java: <a href=""http://nyal.developpez.com/tutoriel/java/bouncycastle/#L4.2"" rel=""nofollow"">http://nyal.developpez.com/tutoriel/java/bouncycastle/#L4.2</a></p>

<p>What I want is first get the certificate from the envelop.</p>

<p>I am able to open it with that command:</p>

<pre><code>openssl pkcs7 -in pkcs7 -print_certs -text
</code></pre>

<p>Then I want to verify that the data is ok.</p>

<p>I tried this:</p>

<pre><code>import base64
from M2Crypto import SMIME, X509, BIO

raw_sig = """"""base64 PKCS7 envelop""""""
msg = ""challenge message to verify""

sm_obj = SMIME.SMIME()
x509 = X509.load_cert('/etc/ssl/certs/ca-certificates.crt') # public key cert used by the remote
# client when signing the message
sk = X509.X509_Stack()
sk.push(x509)
sm_obj.set_x509_stack(sk)

st = X509.X509_Store()
st.load_info('/etc/ssl/certs/ca-certificates.crt') # Public cert for the CA which signed
# the above certificate
sm_obj.set_x509_store(st)

# re-wrap signature so that it fits base64 standards
cooked_sig = '\n'.join(raw_sig[pos:pos+76] for pos in xrange(0, len(raw_sig), 76))

# now, wrap the signature in a PKCS7 block
sig = """"""
-----BEGIN PKCS7-----
%s
-----END PKCS7-----
"""""" % cooked_sig

# print sig

# and load it into an SMIME p7 object through the BIO I/O buffer:
buf = BIO.MemoryBuffer(sig)
p7 = SMIME.load_pkcs7_bio(buf)

# do the same for the message text
data_bio = BIO.MemoryBuffer(msg)

cert = sm_obj.verify(p7, data_bio)
</code></pre>

<p>I think one of the /etc/ssl/certs/ca-certificates.crt should be the userCertificate.</p>

<p>After having the certificate I want to check that it is still valid (using validatity date) and verify it against the CRL and the CPS for revocation.</p>

<p>I hope you can help me.</p>
","<p>So I was almost there:</p>

<pre><code>import base64
from M2Crypto import SMIME, X509, BIO

raw_sig = """"""base64 PKCS7 envelop""""""
msg = ""challenge message to verify""

sm_obj = SMIME.SMIME()
x509 = X509.load_cert('ISSUER.crt') # public key cert used by the remote
                                             # client when signing the message
sk = X509.X509_Stack()
sk.push(x509)
sm_obj.set_x509_stack(sk)

st = X509.X509_Store()
st.load_info('ROOT.crt') # Public cert for the CA which signed
                                    # the above certificate
sm_obj.set_x509_store(st)

# re-wrap signature so that it fits base64 standards
cooked_sig = '\n'.join(raw_sig[pos:pos+76] for pos in xrange(0, len(raw_sig), 76))

# now, wrap the signature in a PKCS7 block
sig = """"""
-----BEGIN PKCS7-----
%s
-----END PKCS7-----
"""""" % cooked_sig

# print sig

# and load it into an SMIME p7 object through the BIO I/O buffer:
buf = BIO.MemoryBuffer(sig)
p7 = SMIME.load_pkcs7_bio(buf)

signers = p7.get0_signers(sk)
certificat = signers[0]
</code></pre>

<p>Then you might also be interested in CRL and OCSP validation:</p>

<pre><code>from os.path import basename
import re
from tempfile import NamedTemporaryFile

try:
    from subprocess import check_output, CalledProcessError, STDOUT
except ImportError:  # check_output new in 2.7, so use a backport for &lt;=2.6
    from subprocess32 import check_output, CalledProcessError, STDOUT

class OpenSSLError(Exception):
    pass

def info_extension_cert(cert):
    """"""
    This function take a certificate and return the extensions in dict.

    @type cert : M2Crypto.X509
    @param cert : Certificate
    """"""
    certificateExtensions = {}

    for index in range(cert.get_ext_count()):
        ext = cert.get_ext_at(index)
        certificateExtensions[ext.get_name()] = ext.get_value()
    return certificateExtensions


def get_cert_url_ocsp(cert):
    """"""
    Get the OCSP url of a certificate

    @type cert : M2Crypto.X509
    @parm cert : Certificat

    @rtype : string
    @return : The OSCP url
    """"""

    infos = [x.strip() for x in info_extension_cert(cert)[""authorityInfoAccess""].split('\n')]
    ocsp_url = None
    for info in infos:
        if re.match(r""^OCSP - URI:"", info):
            ocsp_url = info.replace(""OCSP - URI:"","""")
            break
    return ocsp_url.strip()


def is_revoked(cert, cert_parent):
    """"""
    Check if the certificate has been revoked.

    @type cert : M2Crypto.X509
    @param cert : The certificate

    @type cert_parent : string
    @param cert_parent : Issuer certificate file path

    @rtype : boolean
    @return : True if revoked or False
    """"""
    ocsp_url = get_cert_url_ocsp(cert)
    if re.match(r""^http"", ocsp_url) is None:
        return False

    data = {'cert_parent': cert_parent,
            'ocsp_url': ocsp_url,
            'serial': cert.get_serial_number()}

    cmd = ""openssl ocsp -issuer %(cert_parent)s -CAfile %(cert_parent)s -url %(ocsp_url)s -serial %(serial)s"" % data
    print cmd
    try:
        output = check_output(cmd, shell=True, stderr=STDOUT).lower()
    except CalledProcessError, e:
        msg = u""[OpenSSL] Error while checking ocsp %s: %s. Output: %r"" % (
                    cmd, e, e.output)
        raise OpenSSLError(msg)
    return not ('response verify ok' in output and '%s: good' % data['serial'] in output)


def is_revoked_crl(cert, cert_parent_with_crl):
    """"""
    Check if the certificate as been revoked with the crl.

    @type cert : M2Crypto.X509
    @param cert : The certificate

    @type cert_parent : string
    @param cert_parent : Issuer certificate file path

    @rtype : boolean
    @return : True if revoked or False
    """"""
    tmp_file = NamedTemporaryFile(prefix='cert')
    cert.save(tmp_file.name)
    data = {'cert': tmp_file.name,
            'cert_parent_with_crl': cert_parent_with_crl}
    cmd = ""openssl verify -crl_check -CAfile %(cert_parent_with_crl)s %(cert)s"" % data
    print cmd
    try:
        output = check_output(cmd, shell=True, stderr=STDOUT).lower()
    except CalledProcessError, e:
        msg = u""[OpenSSL] Error while checking ocsp %s: %s. Output: %r"" % (
                    cmd, e, e.output)
        raise OpenSSLError(msg)
    print output
    return '%s: ok' % data['cert'] not in output


def get_cert_url_crl(cert):
    """"""
    Return the crl url from the certificate

    @type cert : M2Crypto.X509
    @parm cert : Certificate

    @rtype : string
    @return : CRL url
    """"""

    infos = [x.strip() for x in info_extension_cert(cert)[""crlDistributionPoints""].split('\n')]
    crl_url = None
    for info in infos:
        print info
        if re.match(r""^URI:"", info):
            crl_url = info.replace(""URI:"","""")
            break
    return crl_url.strip()
</code></pre>

<p><code>cert_parent</code> is the file with ROOT.crt and ISSUER.crt concatenates together.
<code>cert_parent_crl</code> is the file with ROOT.crt, ISSUER.crt and CRL concatenates together.</p>

<p>To concat the CRL with other certificate I use:</p>

<pre><code>rm FILE.crl
wget http://URL/FILE.crl
cat ROOT_ISSUER.crt &gt; ROOT_ISSUER_CRL.crt
echo ""-----BEGIN X509 CRL-----"" &gt;&gt; ROOT_ISSUER_CRL.crt
openssl enc -base64 -in FILE.crl &gt;&gt; ROOT_ISSUER_CRL.crt
echo ""-----END X509 CRL-----"" &gt;&gt; ROOT_ISSUER_CRL.crt
</code></pre>
","3624","<python><x509><m2crypto><pkcs#7>","4","4","2","2013-07-06 07:58:46","13419260","0","1","","","","2012-11-14 13:35:54",""
"13379846","Extract userCertificate from PKCS7 envelop in python","<p>Ok, I am trying to verify data from PKCS7 envelop using Python.</p>

<p>I have the working code in Java: <a href=""http://nyal.developpez.com/tutoriel/java/bouncycastle/#L4.2"" rel=""nofollow"">http://nyal.developpez.com/tutoriel/java/bouncycastle/#L4.2</a></p>

<p>What I want is first get the certificate from the envelop.</p>

<p>I am able to open it with that command:</p>

<pre><code>openssl pkcs7 -in pkcs7 -print_certs -text
</code></pre>

<p>Then I want to verify that the data is ok.</p>

<p>I tried this:</p>

<pre><code>import base64
from M2Crypto import SMIME, X509, BIO

raw_sig = """"""base64 PKCS7 envelop""""""
msg = ""challenge message to verify""

sm_obj = SMIME.SMIME()
x509 = X509.load_cert('/etc/ssl/certs/ca-certificates.crt') # public key cert used by the remote
# client when signing the message
sk = X509.X509_Stack()
sk.push(x509)
sm_obj.set_x509_stack(sk)

st = X509.X509_Store()
st.load_info('/etc/ssl/certs/ca-certificates.crt') # Public cert for the CA which signed
# the above certificate
sm_obj.set_x509_store(st)

# re-wrap signature so that it fits base64 standards
cooked_sig = '\n'.join(raw_sig[pos:pos+76] for pos in xrange(0, len(raw_sig), 76))

# now, wrap the signature in a PKCS7 block
sig = """"""
-----BEGIN PKCS7-----
%s
-----END PKCS7-----
"""""" % cooked_sig

# print sig

# and load it into an SMIME p7 object through the BIO I/O buffer:
buf = BIO.MemoryBuffer(sig)
p7 = SMIME.load_pkcs7_bio(buf)

# do the same for the message text
data_bio = BIO.MemoryBuffer(msg)

cert = sm_obj.verify(p7, data_bio)
</code></pre>

<p>I think one of the /etc/ssl/certs/ca-certificates.crt should be the userCertificate.</p>

<p>After having the certificate I want to check that it is still valid (using validatity date) and verify it against the CRL and the CPS for revocation.</p>

<p>I hope you can help me.</p>
","<p>Try also <a href=""https://github.com/erny/pyx509"" rel=""nofollow"">https://github.com/erny/pyx509</a>. This needs pyasn1 &amp; pyasn1-modules. And it's python only:</p>

<pre><code>./pkcs7_parse &lt;pkcs7 signature in DER format&gt;
</code></pre>
","3624","<python><x509><m2crypto><pkcs#7>","4","2","2","2013-07-06 07:58:46","13419260","0","1","","","","2012-11-14 13:35:54",""
"17261951","java.security.NoSuchAlgorithmException: no such algorithm: SHA1WITHRSA for provider BC","<p>I try verifying PKCS#7 Signature by this following code:</p>

<pre><code>public static void verifypkcs7(String content, byte[] signedBytes) throws OperatorCreationException, CMSException, IOException, CertificateException, NoSuchAlgorithmException, NoSuchProviderException, CertStoreException, NoSuchStoreException
{
    Security.addProvider(new BouncyCastleProvider());

    CMSProcessableByteArray cmsByteArray = new CMSProcessableByteArray(content.getBytes(""UTF-8""));
    CMSSignedData sp = new CMSSignedData(cmsByteArray, signedBytes);

    Store                   certStore = sp.getCertificates();
    SignerInformationStore  signers = sp.getSignerInfos();

    Collection&lt;?&gt;              c = signers.getSigners();
    Iterator&lt;?&gt;                it = c.iterator();
    boolean verified = false;
    while (it.hasNext())
    {
        SignerInformation   signer = (SignerInformation)it.next();
        Collection&lt;?&gt;          certCollection = certStore.getMatches(signer.getSID());

        Iterator&lt;?&gt;        certIt = certCollection.iterator();
        X509CertificateHolder cert = (X509CertificateHolder)certIt.next();
        verified = signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert));
    }
    System.out.println(verified);
    CMSProcessable signedContent = sp.getSignedContent() ;
    byte[] originalContent  = (byte[]) signedContent.getContent();
    System.out.println(new String(originalContent));
}
</code></pre>

<p>and my problem is:</p>

<pre><code>Exception in thread ""main"" org.bouncycastle.cms.CMSException: can't create digest calculator: exception on setup: java.security.NoSuchAlgorithmException: no such algorithm: SHA1WITHRSA for provider BC
    at org.bouncycastle.cms.SignerInformation.doVerify(Unknown Source)
    at org.bouncycastle.cms.SignerInformation.verify(Unknown Source)
    at PKCS7Signer.verifypkcs7_4(PKCS7Signer.java:281)
    at PKCS7Signer.main(PKCS7Signer.java:170)
Caused by: org.bouncycastle.operator.OperatorCreationException: exception on setup: java.security.NoSuchAlgorithmException: no such algorithm: SHA1WITHRSA for provider BC
    at org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1.get(Unknown Source)
    at org.bouncycastle.cms.SignerInformationVerifier.getDigestCalculator(Unknown Source)
    ... 4 more
Caused by: java.security.NoSuchAlgorithmException: no such algorithm: SHA1WITHRSA for provider BC
    at sun.security.jca.GetInstance.getService(Unknown Source)
    at sun.security.jca.GetInstance.getInstance(Unknown Source)
    at java.security.Security.getImpl(Unknown Source)
    at java.security.MessageDigest.getInstance(Unknown Source)
    at org.bouncycastle.jcajce.NamedJcaJceHelper.createDigest(Unknown Source)
    at org.bouncycastle.operator.jcajce.OperatorHelper.createDigest(Unknown Source)
    ... 6 more
</code></pre>

<p>The Exception caused at:</p>

<pre><code>verified = signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert));
</code></pre>

<p>I have tried googling for solution but nothing helped. Can you help me, please?</p>

<p>Data I use for testing:</p>

<pre><code>Signature: MIIHFgYJKoZIhvcNAQcCoIIHBzCCBwMCAQExDzANBgkqhkiG9w0BAQUFADAvBgkqhkiG9w0BBwGgIgQgNURERTg3OUNERUIwNjIzRTAxOEQwQjY3QTIyN0U2N0KgggWeMIIFmjCCA4KgAwIBAgIQVAbJaGFPCH5uamvYoUjDLzANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJWTjEkMCIGA1UEChMbQ0sgTWVkaWEgYW5kIFRlY2hub2xvZ3kgSlNDMRYwFAYDVQQLEw1DS0NBIE9yaWdTaWduMQ0wCwYDVQQDEwRDS0NBMB4XDTEzMDUzMDA5MjYwNVoXDTE0MDUzMDA5MjYwNVowgcAxCzAJBgNVBAYTAlZOMRIwEAYDVQQIDAlIw6AgTuG7mWkxFTATBgNVBAcMDEPhuqd1IEdp4bqleTFBMD8GA1UECgw4Q8OUTkcgVFkgQ+G7lCBQSOG6pk4gQ8OUTkcgTkdI4buGIFbDgCBUUlVZ4buATiBUSMOUTkcgQ0sxHDAaBgNVBAsME1BIw5JORyBL4bu4IFRIVeG6rFQxJTAjBgNVBAMMHMSQ4bq2TkcgTkfhu4xDIFRV4bqkTiAtIFRFU1QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMoad+6Rjjcp1OEYPRq0Qas7cKe8+Sp1rvfoicap82BLVTcTqrOlMta/n3XLDQq0gQW30ffecNxSvUyFiJCXuuuP7G0CeQGV7GsWSkQoyBFsSiSsILMkCYbIAiObjwr66dxPHB/O1Oj9LVFxo39raXzEixl/xvufgO1xo60DUVONAgMBAAGjggF3MIIBczBmBggrBgEFBQcBAQRaMFgwLgYIKwYBBQUHMAKGImh0dHA6Ly9jZXJ0LmNrY2Eudm4vY2VydHMvY2tjYS5jZXIwJgYIKwYBBQUHMAGGGmh0dHA6Ly9vY3NwLmNrY2Eudm4vc3RhdHVzMB0GA1UdDgQWBBTXjYoyauIsE3keHaGt9lnasv3fiTAMBgNVHRMBAf8EAjAAMB8GA1UdIwQYMBaAFA8K92CW2aRVFNba/CaAkgNTtugUMDwGA1UdIAQ1MDMwMQYNKwYBBAGB7QMBBgEDBTAgMB4GCCsGAQUFBwIBFhJodHRwOi8vY2tjYS52bi9ycGEwMQYDVR0fBCowKDAmoCSgIoYgaHR0cDovL2NybC5ja2NhLnZuL2NybHMvY2tjYS5jcmwwDgYDVR0PAQH/BAQDAgTwMB8GA1UdJQQYMBYGCCsGAQUFBwMEBgorBgEEAYI3CgMMMBkGA1UdEQQSMBCBDnR1YW5ka0Bja2NhLnZuMA0GCSqGSIb3DQEBBQUAA4ICAQBbsJIh1PhKkyPd5BkpD5/EjgQODKsw2m9ZV3WSdM2HOVh1Pgv24FcJDGp93w6a2FWOx66m8JJXKRGVkAkizWvh/PkYrKOt2hpMetOm1uSDd2y3VcfTZyPcQ3T6qUJUje3DzA6ySWFbmTMv9lV3+dW7jvBHEXzagFVY5ZmzajFmsJ2oRp1DD3Ry/3ZsaP6j+w6FoIXB9LhNbmI8FNQ3A1Q3t/zxJovtsOHbS5cPzFjGLv7BJKWV0BG0eFvoxCb/tJkY5yOBP5P5bD5ht59D4AyEzKS8NKTYLnnIADQ6/zvpBzSoWzYTEKT8xl3o3LYBZQJL7D1U1yofhL3oYefc7fmwAuAZe5hjkO23N844gjz6ru1hBgzf2Zu8w37GZ+jUDPfisQhuGbkFSsNPFjz+CjKrrFO0H4o3hWF4l/t9nXVsM7PwNRo8YYxZmCM+nHTch1ITpzMh+z16KAQ2Ucncgwap+sTwMGnVYFhSsCJCTkYQY9J7OQrElNI7oHKEO1jQsSjghGTkpOvuoIcPimlJGuOUPQhJ3HZzfSPxaOznqpXwkHpTkNhUyzet1QZjdaQ4jNBPTO6pqHnDKXEtJKJsABnCy5tzdBch2Shw68NtFjC+siiLuzNxnz8G/4rWq4edQqpWz0RbMYnWoeuet/pbWF8yYX+zXL6LKECk7U6Nf3Y1UjGCARgwggEUAgEBMG4wWjELMAkGA1UEBhMCVk4xJDAiBgNVBAoTG0NLIE1lZGlhIGFuZCBUZWNobm9sb2d5IEpTQzEWMBQGA1UECxMNQ0tDQSBPcmlnU2lnbjENMAsGA1UEAxMEQ0tDQQIQVAbJaGFPCH5uamvYoUjDLzANBgkqhkiG9w0BAQUFADANBgkqhkiG9w0BAQEFAASBgB0Liyncn9qSKQIjoDXvLYf+vLSZv2XyiXbQI2jNaCMEvKpRToJWh3aPPQNJTJ7aam5ngue2IzcPeA52GqYqDhVfioGc1Y6MaKxlLTBSp/Jqg8LLwnj8BorOwqzuBAJIzyMfnPhD+DwMPCdbIL5Tpi5zwW7RlKcakuVkhONZhY2g
Content: 5DDE879CDEB0623E018D0B67A227E67B
</code></pre>

<p>Unbase64 before use as the second parameter</p>
","<p>Try this, but you should switch for older bouncy castle version. I used 1.45</p>

<pre><code>        byte[] signedData = ...;
        byte[] originalData = ...;
        CMSSignedDataParser parser = new CMSSignedDataParser(new CMSTypedStream(
                new ByteArrayInputStream(originalData)), signedData);
        parser.getSignedContent().drain();
        CertStore certs = parser.getCertificatesAndCRLs(""Collection"", ""BC"");
        SignerInformationStore signers = parser.getSignerInfos();
        Collection&lt;?&gt; c = signers.getSigners();
        Iterator&lt;?&gt; it = c.iterator();
        while (it.hasNext()) {
            SignerInformation signer = (SignerInformation) it.next();
            Collection&lt;?&gt; certCollection = certs.getCertificates(signer.getSID());

            Iterator&lt;?&gt; certIt = certCollection.iterator();
            X509Certificate cert = (X509Certificate) certIt.next();

            System.out.println(""verify returns: "" + signer.verify(cert, ""BC""));
        }
</code></pre>
","3599","<bouncycastle><signature><pkcs#7>","1","1","1","2014-01-24 07:13:46","","0","","","","","2013-06-23 14:53:02",""
"10300673","generate and encode PKCS7 message in Java","<p>I have seen many similar question asked here before, but I haven't found a proper answer yet.</p>

<p>I got signature which was generated and encoded by C# <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.pkcs.signedcms.aspx"" rel=""nofollow"">SignedCms </a>.</p>

<p>My goal is generating the same signature in Java.
I managed to create a similar signature which has the same length and most of its data. 
But there are not the same bits in position from 120 to 133 bits and last approximately 250 bits.</p>

<p>According to this <a href=""http://www.jensign.com/JavaScience/sigview/index.html"" rel=""nofollow"">Anatomy of PKCS#7 signed message</a>. I have wrong signature and content blocks.
I have tried bouncycastle but I didn't manage to generate correct signature. 
I'd like to use sun.* classes to generate and encode PKCS#7 message.</p>

<pre><code>        X509Certificate x509 = siginingCert;
        PrivateKey priv = privateKeyFromPKCS12KeyStore;
        byte[] data = sha1HashOfDocument

        String digestAlgorithm = ""MD5"";
        String signingAlgorithm = ""SHA1withRSA"";

        AlgorithmId[] digestAlgorithmIds = new AlgorithmId[]{AlgorithmId.get(digestAlgorithm)};

        Signature sigSigner = Signature.getInstance(signingAlgorithm);
        sigSigner.initSign(priv);
        sigSigner.update(data);
        byte[] signedAttributes = sigSigner.sign();

        ContentInfo contentInfo = new ContentInfo(
                sun.security.pkcs.ContentInfo.DATA_OID,
                new DerValue(DerValue.tag_OctetString, data));

        X509Certificate[] certificates = {x509};

        BigInteger serial = x509.getSerialNumber();
        String issuerName = x509.getIssuerDN().getName();
        AlgorithmId dAlgId =  AlgorithmId.getAlgorithmId(digestAlgorithm);

        SignerInfo si = new SignerInfo(
                new X500Name(issuerName), serial, dAlgId, null,
                new AlgorithmId(AlgorithmId.RSAEncryption_oid),
                signedAttributes, null);

        SignerInfo[] signerInfos = {si};
        PKCS7 p7 = new PKCS7(digestAlgorithmIds, contentInfo, certificates, signerInfos);
        ByteArrayOutputStream bytes = new ByteArrayOutputStream();
        p7.encodeSignedData(bytes);
</code></pre>

<p>I got stuck on this issue and I have no idea what I missed.</p>

<p>Any help is appreciated. Thanks a lot.</p>
","<pre><code>byte[] signedData = signature.sign();

    SignerInfo si = new SignerInfo(
            new X500Name(issuerName), serial, dAlgId, null,
            new AlgorithmId(AlgorithmId.RSAEncryption_oid),
            signedAttributes,signedData  );
</code></pre>
","3599","<java><digital-signature><pkcs#7>","0","0","1","2014-01-20 11:24:12","","1","","","","","2012-04-24 15:05:10",""
"12796545","How can we Convert PKCS#1 to PKCS #7 if I have the Certificate?","<p>I was developing a PDF signing tool. For this I will get a signed sha256 data of PDF in PKCS#1 format and a certificate from a device, I need to use these two to embed inside the PDF. Most of the PDF reader only support PKCS#7 signature.</p>

<p>Is there any way to convert a PKCS#1 signature to PKCS#7 signature  (using certificate file) ?</p>

<p>I knew that PKCS#7 = Certificate + Optional raw data + Signature in PKCS#1 format</p>
","<p>Your question somewhat oversimplifies the situation.</p>

<p>Concerning PKCS#7 &lt;-> PKCS#1:</p>

<p>Yes, a PKCS#7 signature container contains SignerInfo objects which respectively essentially contain a PKCS#1 style signature and some attributes. BUT this PKCS#1 style signature generally is NOT merely signing the document data but instead is signing a structure of so called ""signed attributes"". One of these is a document hash, others can be the signing time, a link to the signer certificate, and other information; these extra information is required in many use cases. Only the most primitively built SignerInfo structures sign the document data directly.</p>

<p>In general, therefore, if you simply take a PKCS#1 signature of some data and wrap it in a PKCS#7 container, that signature container won't be accepted.</p>

<p>For details see <a href=""http://www.ietf.org/rfc/rfc3852.txt"" rel=""noreferrer"">RFC 3852</a>.</p>

<p>Concerning integrated PDF signatures:</p>

<p>Your description of your implementation-to-be is somewhat vague. You seem to think that the document hash to sign is a hash of the original PDF. In case of integrated PDF signatures this is wrong: In order to create an integrated PDF signature, you first extend the PDF by some data which envelop a placeholder for the PKCS#7 signature container (recommended by the specification) or the PKCS#1 signature to integrate. Then you need to hash this extended PDF except the placeholder. (By the current PDF specification you could hash less than that but this won't be accepted by the current Adobe Acrobat/Reader and shouldn't be accepted by any serious verifier).</p>

<p>For details see <a href=""http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf"" rel=""noreferrer"">ISO 32000-1:2008 as published by Adobe</a></p>

<p>Depending on the legal requirements you may also have to take into account PDF Advanced Electronic Signatures (PAdES) as specified by ETSI, cf. <a href=""http://www.etsi.org/website/newsandevents/200909_electronicsignature.aspx"" rel=""noreferrer"">ETSI standard for EU-compliant electronic signatures</a>. These will become part of ISO 32000-2, aka PDF 2.0.</p>

<p>So, are you still sure your use case allows for those very simple PKCS#7 signatures you have in mind, and are your PKCS#1 source signatures created for the right document? In that case building those containers is easily done by looking at <a href=""http://www.ietf.org/rfc/rfc3852.txt"" rel=""noreferrer"">RFC 3852</a>.</p>

<p>Anyways, you should have a look at the whitepaper <a href=""http://itextpdf.com/book/digitalsignatures"" rel=""noreferrer"">Digital Signatures for PDF documents</a> by Bruno Lowagie (iText Software).</p>
","3521","<pdf><rsa><digital-signature><pkcs#7>","1","6","2","2018-10-11 02:12:40","12816472","0","","1816580","","2015-06-09 19:20:07","2012-10-09 09:10:53",""
"12796545","How can we Convert PKCS#1 to PKCS #7 if I have the Certificate?","<p>I was developing a PDF signing tool. For this I will get a signed sha256 data of PDF in PKCS#1 format and a certificate from a device, I need to use these two to embed inside the PDF. Most of the PDF reader only support PKCS#7 signature.</p>

<p>Is there any way to convert a PKCS#1 signature to PKCS#7 signature  (using certificate file) ?</p>

<p>I knew that PKCS#7 = Certificate + Optional raw data + Signature in PKCS#1 format</p>
","<p>Looking at RFC 3852 > 5.4.  Message Digest Calculation Process</p>

<p>It is possible to simply convert PKCS#1 to PKCS#7 as long as there are not signed attributes in it. If there are then you are stuck as the PKCS#1 coverts ONLY the hash of the content and PKCS#7 with signed attributes required to construct an intermediary structure and hash of that structure is being signed.</p>
","3521","<pdf><rsa><digital-signature><pkcs#7>","1","1","2","2018-10-11 02:12:40","12816472","0","","1816580","","2015-06-09 19:20:07","2012-10-09 09:10:53",""
"3496493","Should X509 certificate have nonRepudiation bit set to check PKCS7 signature?","<p>X509 certificate has set of keyUsage bits. Two of them are
digitalSignature<br>
nonRepudiation (recent editions of X.509 have renamed this bit to contentCommitment).</p>

<p>I read X509 RFC (<a href=""http://tools.ietf.org/html/rfc5280"" rel=""nofollow noreferrer"">http://tools.ietf.org/html/rfc5280</a>) and it talks about general usage of these bit.</p>

<p>And I read PKCS7 RFC (<a href=""http://tools.ietf.org/html/rfc2315"" rel=""nofollow noreferrer"">http://tools.ietf.org/html/rfc2315</a>) and it talks about PKCS7 structure and so on and doesn't specify which bits needs to be set.</p>

<p>Is there any RFC or other specification which identifies whether one or both of them should be set? </p>

<p>Regards,
Victor</p>
","<p>A PKCS#7 file generally contains a chain of certificates.  That is, a Root CA certificate, any intermediate CA certificates that apply, and then the endpoint certificate (SSL, e-mail, etc.)  A PKCS#7 is typically used to bundle these up into a single file.  It's useful, in that you can import the entire chain at once into a keystore or other relying application.</p>

<p>As to the key usage bits, those are set depending on the needs and purpose of a particular certificate.  For example, a Root CA certificate would typically have both digital signature and non-repudiation set.  For an SSL certificate, you may find key encipherment and digital signature.  There's really no correlation between key usage and PKCS#7 files, unless you're talking about the CA certificates contained in the PKCS#7 file.</p>
","3484","<certificate><x509><pki><pkcs#7>","0","3","2","2011-06-24 07:23:31","3515262","0","","5000","","2011-06-24 07:23:31","2010-08-16 19:17:35",""
"3496493","Should X509 certificate have nonRepudiation bit set to check PKCS7 signature?","<p>X509 certificate has set of keyUsage bits. Two of them are
digitalSignature<br>
nonRepudiation (recent editions of X.509 have renamed this bit to contentCommitment).</p>

<p>I read X509 RFC (<a href=""http://tools.ietf.org/html/rfc5280"" rel=""nofollow noreferrer"">http://tools.ietf.org/html/rfc5280</a>) and it talks about general usage of these bit.</p>

<p>And I read PKCS7 RFC (<a href=""http://tools.ietf.org/html/rfc2315"" rel=""nofollow noreferrer"">http://tools.ietf.org/html/rfc2315</a>) and it talks about PKCS7 structure and so on and doesn't specify which bits needs to be set.</p>

<p>Is there any RFC or other specification which identifies whether one or both of them should be set? </p>

<p>Regards,
Victor</p>
","<p>BTW, this bit violates the separation of concerns in its design. Non-repudiation is a legal issues negotiated on the business level. Using the bit at the certificate/signing level is irrelevant. See e.g. <a href=""http://www-personal.umich.edu/~lsiden/tutorials/signed-applet/ShockingTruth.html"" rel=""nofollow"">http://www-personal.umich.edu/~lsiden/tutorials/signed-applet/ShockingTruth.html</a></p>
","3484","<certificate><x509><pki><pkcs#7>","0","1","2","2011-06-24 07:23:31","3515262","0","","5000","","2011-06-24 07:23:31","2010-08-16 19:17:35",""
"3576066","C# PKCS signatures","<p>Im devloping a system that needs to sign files. I already have a function that receive the byte[] of data to sign and the X509 Certificate and computes the signature using System.Security.Cryptography.Pkcs namespace. Its important to note that we need the signature to be dettached, so for verification we use the file, the dettached signature and the certificate.</p>

<p>The thing is that this function returns a byte[] as signature. Right now for serializing it I am using Base64 encoding, but I saw that the standard is to use .p7s files. </p>

<p>So, how do I generate a .p7s file from the byte[] of the dettached signature?</p>

<p>Another question, is there a way to add a timestamp on the signature and then to retrieve it?</p>

<p>Thanks!
Juan</p>
","<p>p7s is a detached PKCS#7 signature itself. It can be (optionally) base64-encoded and that's all, there's no other formatting that needs to be applied.</p>

<p>Yes, you can timestamp PKCS#7 signature. You need to read RFC 3161 and implement it yourself. You can use <a href=""http://www.eldos.com/sbb/net-pki.php"" rel=""nofollow noreferrer"">PKI components</a> of our SecureBlackbox product. Our components let you sign and timestamp data using PKCS#7 and CMS (extension and descendant of PKCS#7). I am not aware of free timestamping clients for PKCS#7, though some might exist. </p>
","3419","<c#><digital-signature><pkcs#7>","0","0","2","2014-02-27 18:54:49","","0","","178382","","2010-08-26 14:26:03","2010-08-26 14:23:38",""
"3576066","C# PKCS signatures","<p>Im devloping a system that needs to sign files. I already have a function that receive the byte[] of data to sign and the X509 Certificate and computes the signature using System.Security.Cryptography.Pkcs namespace. Its important to note that we need the signature to be dettached, so for verification we use the file, the dettached signature and the certificate.</p>

<p>The thing is that this function returns a byte[] as signature. Right now for serializing it I am using Base64 encoding, but I saw that the standard is to use .p7s files. </p>

<p>So, how do I generate a .p7s file from the byte[] of the dettached signature?</p>

<p>Another question, is there a way to add a timestamp on the signature and then to retrieve it?</p>

<p>Thanks!
Juan</p>
","<p>Now it possible using X509Certificate2 class</p>

<pre><code>public static byte[] Sign(byte[] data, X509Certificate2 certificate)
{
    if(data == null)
        throw new ArgumentNullException(""data"");
    if(certificate == null)
        throw new ArgumentNullException(""certificate"");

    // setup the data to sign
    ContentInfo content = new ContentInfo(data);
    SignedCms signedCms = new SignedCms(content, false);
    CmsSigner signer = new CmsSigner(SubjectIdentifierType.IssuerAndSerialNumber, certificate);

    // create the signature
    signedCms.ComputeSignature(signer);
    return signedCms.Encode();
}
</code></pre>
","3419","<c#><digital-signature><pkcs#7>","0","0","2","2014-02-27 18:54:49","","0","","178382","","2010-08-26 14:26:03","2010-08-26 14:23:38",""
"18225897","API secured by PKCS#7 cryptographic message","<p>I am currently trying to call an API that requires me to put XML data in a PKCS#7 format.<br>
This data is posted to the API end point.<br>
The response also comes in a form of a PKCS#7 cryptographic messages (MIME-type is application/pkcs7-mime).<br>
Some Notes they provide: A cryptographic message doesn't contain any certification chains. Data compression is not used. Data encryption is not used. A cryptographic message is in the OpenSSL PEM format.  </p>

<p>I have been supplied two certificates. One I created the request for and have the private key, the other supplied to me by the service provider.<br>
I have managed to successfully install these certificates, and can communicate with the service.</p>

<p>I am seemingly sending data to this API service successfully.<br>
Now I'm trying to make sense of the response I'm receiving from this API.<br>
This response looks like this</p>

<pre><code>-----BEGIN PKCS7-----
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
WISGCSqGSIb3DQEHSqCSWISCSQExCzSJBgUrDgWCGgUSWISGCSqGSIb3DQEHSSCS
AfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsdfdAfsdFAD3433423ASfdsd
-----END PKCS7-----
</code></pre>

<p>(I jumbled up the contents on the off chance there's anything sensitive in there)</p>

<p>With this response i need to</p>

<ol>
<li>Verify the digital signature to ensure that response was sent by the provider</li>
<li>Get an Xml formatted message from this response</li>
</ol>

<p>I have been primarily using the <a href=""http://www.bouncycastle.org/csharp/"" rel=""nofollow"">Bouncy Castle</a> library and the MS <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.pkcs.signedcms%28v=vs.85%29.aspx"" rel=""nofollow"">SignedCms Class</a><br>
In summary, I am getting absolutely nowhere.</p>

<p>Please can someone guide me on what to do here as I've been at this for about 5 days and am going nowhere fast.  </p>

<p>Here is some of what I'm doing so far:</p>

<p><strong>Make the request</strong></p>

<p>Using the HttpWebRequest and HttpWebResponse i am posting data to the service using my supplied certificate</p>

<pre><code>var store = new X509Store(StoreLocation.LocalMachine);
store.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);
X509Certificate2 cert = store.Certificates.Find(X509FindType.FindByThumbprint, ""ACLKJCLKJCLKJCLKJCLKJCLKJCLKJCLKJCLKJCLK"", false)[0];

HttpWebRequest request = null;
var uri = new Uri(endPointUri);
request = (HttpWebRequest) WebRequest.Create(uri);
request.Method = ""POST"";
request.ContentType = ""application/pkcs7-mime"";
request.ContentLength = requestString.Length;
request.ClientCertificates.Add(cert);

using (Stream writeStream = request.GetRequestStream())
{
    var encoding = new UTF8Encoding();
    byte[] bytes = encoding.GetBytes(requestString);
    writeStream.Write(bytes, 0, bytes.Length);
}
string result = null;
using (var response = (HttpWebResponse) request.GetResponse())
{
    using (Stream responseStream = response.GetResponseStream())
    {
        if (responseStream != null)
        {
            using (var readStream = new StreamReader(responseStream, Encoding.UTF8))
            {
                result = readStream.ReadToEnd();
            }
        }
    }
}

return result;
</code></pre>

<p>Here I get back the ""BEGIN PKCS7"" message from above.<br>
Now I'm trying to figure out what to do with this</p>

<p><strong>MS Signed CMS Class Approach</strong></p>

<pre><code>SignedCms signedCms = new SignedCms();
signedCms.Decode(Encoding.Default.GetBytes(resultString));
try
{
    signedCms.CheckSignature(new X509Certificate2Collection(cert1), true);
}
catch (System.Security.Cryptography.CryptographicException e)
{
    _Log.Error(e.Message)
}
</code></pre>

<p>This throws the exception on ""signedCms.Decode"" of ""ASN1 bad tag value met.""</p>

<p><strong>BouncyCastle ISigner</strong></p>

<p>Here the documentation is non-existent.<br>
So first I save my response to a file and use the TextReader object to try test with BouncyCastle</p>

<pre><code>using (TextReader reader = File.OpenText(@""c:\temp\resultString.txt""))
{
    PemReader pemRd = new PemReader(reader);
    ContentInfo d = (ContentInfo)pemRd.ReadObject();
    Console.WriteLine(d.ContentType.ToString());
}
</code></pre>

<p>This returns the result: ""1.2.840.113549.1.7.2""<br>
From what i can tell, this means its ""Pkcs7 Signed Data""<br>
Woohoo, something looks like its working.<br>
But from here, how do I verify, and how do I extract any information from this</p>

<p>My Verify attempt</p>

<pre><code>using (TextReader reader = File.OpenText(@""c:\temp\resultString.txt""))
{
    PemReader pemRd = new PemReader(reader);
    var signature = new CmsSignedData(pemRd.ReadObject());
}
</code></pre>

<p>Fail - signature is null</p>

<pre><code>var store = new X509Store(StoreLocation.LocalMachine);
store.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);
X509Certificate2 cert = store.Certificates.Find(X509FindType.FindByThumbprint, ""ACLKJCLKJCLKJCLKJCLKJCLKJCLKJCLKJCLKJCLK"", false)[0]; //tried with both certs
ISigner signer = SignerUtilities.GetSigner(""RSA"");
var bouncyx509 = DotNetUtilities.FromX509Certificate(cert1);
signer.Init(true, DotNetUtilities.FromX509Certificate(cert1).GetPublicKey());
</code></pre>

<p>Fail - need private key to create signer</p>

<p><strong>In Closing</strong></p>

<p>I hope I have provided enough information to get some help here.<br>
Maybe I'm heading in completely the wrong direction.  </p>

<p>My Questions are:</p>

<ol>
<li>How do I Verify the digital signature?</li>
<li>How do I get an Xml formatted message from this response?</li>
</ol>

<p><strong>THE SOLUTION</strong></p>

<p>Thanks to gtrig, i finally have a solution.<br>
Using the MS SignedCms object I had to first remove the Header and Footer form the message, then Convert.FromBase64String</p>

<p>Working Solution</p>

<pre><code>SignedCms signedCms = new SignedCms();
resultString = resultString.Replace(""\n"", """").Replace(""-----BEGIN PKCS7-----"", """").Replace(""-----END PKCS7-----"", """");
signedCms.Decode(Convert.FromBase64String(resultString));
</code></pre>

<p>Now signedCms.ContentInfo.Content contains the reponse Xml message I expect</p>
","<p>This is an incomplete answer, but it may get you a little further along.</p>

<p>If you have access to openssl, try this <a href=""http://www.openssl.org/docs/apps/pkcs7.html"" rel=""nofollow"">command</a> to see if it can read the data:</p>

<p><code>openssl pkcs7 -in resultString.txt -text</code></p>

<p>After that try this in your code (The only difference from what you had is ""Content"" instead of ""ContentType"":</p>

<pre><code>Console.WriteLine(d.Content.ToString());
</code></pre>

<p>signedCms.Decode() takes a byte array, and that is probably the DER formatted message instead of the PEM formatted message that you received in the response.  To get that in a byte array, you'll have to strip the header and footer (Begin/End) lines and pass the rest to this method: </p>

<pre><code>Convert.FromBase64String()
</code></pre>

<p>Alternatively, you could use openssl to convert the file to DER format and then read in the bytes directly from the file.</p>

<blockquote>
  <p>openssl pkcs7 -in resultString.txt -outform DER -out result.der</p>
</blockquote>
","3364","<c#><x509certificate><pkcs#7>","3","2","1","2013-08-16 06:31:38","18227110","0","","15360","","2013-08-16 06:31:38","2013-08-14 07:44:10",""
"21019018","AES128/CBC/PKCS7padding in Objective-C?","<p>I am attempting to decrypt the blob data for stories sent from Snapchat. Here is how gibsonsec describes the method to decrypting the image:</p>

<ul>
<li>Padded using PKCS#7.</li>
<li>Encrypted using AES/CBC with a unique IV and key per piece of the story.</li>
</ul>

<p>So is there some way to accomplish this, <code>AES128/CBC/PKCS7padding</code> within Objective-C? Indeed I do have both the <code>data</code> value (in NSData form), <code>key</code> value (encrypted in base63 form of NSString), and <code>iv</code> value (again, encrypted in base63 form of NSString)</p>

<p>Thank you!</p>
","<p>Found the following; <a href=""https://github.com/dev5tec/FBEncryptor"" rel=""nofollow"">https://github.com/dev5tec/FBEncryptor</a> - Solved.</p>
","3322","<objective-c><encryption><aes><pkcs#7>","2","2","1","2014-01-09 11:49:47","","0","1","","","","2014-01-09 11:32:33",""
"17706020","C# Cades P7M with Smartcard","<p>I read this post <a href=""https://stackoverflow.com/questions/3944265/how-can-sign-a-file-with-bouncycastle-dll-in-c-sharp"">how can sign a file with BouncyCastle dll in c#</a>
and I would to know if it is possible found some support for certificates stored in smartcard.</p>

<p>What I'm trying to do is to create P7M cades but it seems impossibile to found any dopcumentation, .NET classes or free library.</p>
","<p>If the smartcard is mapped to Windows Certificate storage, then you can use certificates available via CryptoAPI. If the smartcard is available via PKCS#11, you can use <a href=""https://www.eldos.com/sbb/net-pki.php"" rel=""nofollow"">PKIBlackbox</a> package of our SecureBlackbox product to use it. Also PKIBlackbox supports CAdES format, not just PKCS#7/CMS.  </p>
","3063","<c#><digital-signature><pkcs#7>","0","-1","3","2019-05-16 18:43:44","","1","","-1","","2017-05-23 12:06:52","2013-07-17 17:07:39",""
"17706020","C# Cades P7M with Smartcard","<p>I read this post <a href=""https://stackoverflow.com/questions/3944265/how-can-sign-a-file-with-bouncycastle-dll-in-c-sharp"">how can sign a file with BouncyCastle dll in c#</a>
and I would to know if it is possible found some support for certificates stored in smartcard.</p>

<p>What I'm trying to do is to create P7M cades but it seems impossibile to found any dopcumentation, .NET classes or free library.</p>
","<p>You can also try this c# ported version of an European Commission initiative:</p>

<p><a href=""https://github.com/nonorganic/dssnet"" rel=""nofollow"">DSS .NET</a></p>

<p>It supports CAdES. Try using the MSCAPISignatureToken and the guide in the CookBook</p>

<p><a href=""https://github.com/nonorganic/dssnet/blob/master/DSS3-T1-CookBook-v1.05.doc"" rel=""nofollow"">CookBook</a></p>
","3063","<c#><digital-signature><pkcs#7>","0","2","3","2019-05-16 18:43:44","","1","","-1","","2017-05-23 12:06:52","2013-07-17 17:07:39",""
"17706020","C# Cades P7M with Smartcard","<p>I read this post <a href=""https://stackoverflow.com/questions/3944265/how-can-sign-a-file-with-bouncycastle-dll-in-c-sharp"">how can sign a file with BouncyCastle dll in c#</a>
and I would to know if it is possible found some support for certificates stored in smartcard.</p>

<p>What I'm trying to do is to create P7M cades but it seems impossibile to found any dopcumentation, .NET classes or free library.</p>
","<p>I used DSS.NET with this code:</p>

<pre><code>using System.Security.Cryptography.X509Certificates;
using EU.Europa.EC.Markt.Dss;
using EU.Europa.EC.Markt.Dss.Signature;
using EU.Europa.EC.Markt.Dss.Signature.Cades;
using EU.Europa.EC.Markt.Dss.Signature.Token;

   private static void SignP7M(X509Certificate2 card, string sourcepath)
            {
                var service = new CAdESService();

                // Creation of MS CAPI signature token
                var token = new MSCAPISignatureToken { Cert = card };

                var parameters = new SignatureParameters
                {
                    SignatureAlgorithm = SignatureAlgorithm.RSA,
                    SignatureFormat = SignatureFormat.CAdES_BES,
                    DigestAlgorithm = DigestAlgorithm.SHA256,
                    SignaturePackaging = SignaturePackaging.ENVELOPING,
                    SigningCertificate = Org.BouncyCastle.Security.DotNetUtilities.FromX509Certificate(token.Cert),
                    SigningDate = DateTime.UtcNow
                };

                var toBeSigned = new FileDocument(sourcepath);

                var iStream = service.ToBeSigned(toBeSigned, parameters);

                var signatureValue = token.Sign(iStream, parameters.DigestAlgorithm, token.GetKeys()[0]);

                var signedDocument = service.SignDocument(toBeSigned, parameters, signatureValue);

                var dest = sourcepath + "".p7m"";
                if (File.Exists(dest)) File.Delete(dest);
                var fout = File.OpenWrite(dest);
                signedDocument.OpenStream().CopyTo(fout);
                fout.Close();
            }
</code></pre>

<p>You can get the card in two ways:</p>

<ul>
<li>from cert store </li>
<li>from cert serial number</li>
</ul>

<p>here the samples:</p>

<pre><code>public static X509Certificate2 GetCertificate(string _certSn)
        {
            //selezione del token di firma

            var st = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            st.Open(OpenFlags.ReadOnly);
            var col = st.Certificates;
            var card = col.Cast&lt;X509Certificate2&gt;().FirstOrDefault(t =&gt; t.SerialNumber == _certSn);

            st.Close();

            return card;
        }


public static X509Certificate2 selectCert(StoreName store, StoreLocation location, string windowTitle, string windowMsg)
{

    X509Certificate2 certSelected = null;
    X509Store x509Store = new X509Store(store, location);
    x509Store.Open(OpenFlags.ReadOnly);

    X509Certificate2Collection col = x509Store.Certificates;
    X509Certificate2Collection sel = X509Certificate2UI.SelectFromCollection(col, windowTitle, windowMsg, X509SelectionFlag.SingleSelection);

    if (sel.Count &gt; 0)
    {
        X509Certificate2Enumerator en = sel.GetEnumerator();
        en.MoveNext();
        certSelected = en.Current;
    }

    x509Store.Close();

    return certSelected;
}
</code></pre>
","3063","<c#><digital-signature><pkcs#7>","0","2","3","2019-05-16 18:43:44","","1","","-1","","2017-05-23 12:06:52","2013-07-17 17:07:39",""
"2023046","Is there any OpenSSL function to convert PKCS7 file to PEM","<p>Is there any openssl api function to convert PKCS7 file to PEM. I am able to convert a PKCS12 file to PEM using PKCS12_parse() function which returns key and certificate given the password. There is no similar function for pkcs7.</p>

<p>My pkcs7 input has just the certificate in binary format. I am able to do the conversion using command</p>

<pre><code>openssl pkcs7 -inform DER -in input.p7b -printcerts -text
</code></pre>

<p>How do I do this in a C program? I am able to read it to a PKCS7 structure like this</p>

<pre><code> FILE* fp;
 if (!(fp = fopen(""ca.p7b"", ""rb""))) { 
  fprintf(stderr, ""Error reading input pkcs7 file\n"" ); 
  exit(1); 
 } 
 PKCS7 *p7; 
 p7 = d2i_PKCS7_fp(cafp, NULL);
</code></pre>
","<p>After some googling I am able to do that.</p>

<pre><code>if(p7-&gt;d.sign-&gt;cert != NULL){
    PEM_write_X509(fp, sk_X509_value(p7-&gt;d.sign-&gt;cert, 0)); 
}
</code></pre>

<p>where p7 is a pointer to pkcs7 struct and fp is the file pointer to PEM file</p>
","3055","<c++><openssl><pkcs#7>","3","1","1","2011-05-12 11:33:53","2024120","0","1","89847","","2011-05-12 11:33:53","2010-01-07 19:30:38",""
"6335928","Signing and creating a asn1 signedmessage - Bouncycastle","<p>Is there any good tutorials on how to sign a file, and wrap it inside a asn1 pkcs7 package using bouncycastle?</p>
","<p>After sometime, i've found how its done, in the examples inside the bouncyCastle app.</p>

<p>It's actually quite simpler and straight foward than i had found in IText (, not taking out the geniality of the framework itself).</p>

<p>The code is something like:</p>

<pre><code>        AsymmetricCipherKeyPair signaturePair;
        X509Certificate signatureCert;

        IList certList = new ArrayList();
        IList crlList = new ArrayList();
        CmsProcessable msg = new CmsProcessableByteArray(Encoding.ASCII.GetBytes(""I hate hello world!""));

        certList.Add(signatureCert);
        certList.Add(OrigCert);

        crlList.Add(SignCrl);

        IX509Store x509Certs = X509StoreFactory.Create(
            ""Certificate/Collection"",
            new X509CollectionStoreParameters(certList));
        IX509Store x509Crls = X509StoreFactory.Create(
            ""CRL/Collection"",
            new X509CollectionStoreParameters(crlList));

        CmsSignedDataGenerator gen = new CmsSignedDataGenerator();

        gen.AddSigner(signaturePair.Private, signatureCert, CmsSignedDataGenerator.DigestSha1);

        gen.AddCertificates(x509Certs);
        gen.AddCrls(x509Crls);

        CmsSignedData signedData = gen.Generate(msg, true);

        //saving in BER encoding
        Stream stream = new MemoryStream(signedData.GetEncoded());
</code></pre>
","3048","<c#><bouncycastle><asn.1><pkcs#7>","5","6","1","2011-06-28 13:30:27","6445410","0","","","","","2011-06-13 20:29:34",""
"29304071","JAVA - How to create signed PDF using original PDF and separate PKCS#7 signed data","<p>I have a original PDF document and separate file as PKCS#7 signed data.
I would like to combine these to create signed PDF document so that it could be shown in for example Adobe reader that it is signed and who signed the document.</p>

<p>Are there any libraries in Java that could be used to create such signed PDF document programatically? I need to load that PDF and add the signature to it somehow, then save it as a new PDF document. </p>

<p>Sample code would be appreciated.</p>

<p><strong>EDIT:</strong></p>

<p>The resulting code should take the PDF document as input parameter and do the following:</p>

<ol>
<li>prepare data to be signed</li>
<li>provide data to be signed to external signing mechanism that produces PKCS#7 signed data file</li>
<li>provide PKCS#7 signed data file</li>
<li>add signed data to PDF document</li>
<li>save PDF document</li>
</ol>

<p>As I understand the first step is important because without that the PKCS#7 signed data would be wrong.</p>
","<p>If I correctly understand your question, your pkcs#7 is signing the whole content of the PDF. That is, all PDF file bytes.
In this case the answer is you can't.</p>

<p>When you sign a PDF file you don't sign all its bytes ""as is"".
Before signing a PDF you have to create two ""byte ranges"" in the PDF, 
leaving in the midle of the PDF enough room to include the signature.
Then you have to concatenate these two byte ranges, sign these bytes and include the signature in the space you left inside the PDF.</p>

<p>Take a look at<br>
* <a href=""https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSig/Acrobat_DigitalSignatures_in_PDF.pdf"" rel=""nofollow"">https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSig/Acrobat_DigitalSignatures_in_PDF.pdf</a> (www.adobe.com)</p>
","3006","<java><pdf><digital-signature><pkcs#7>","2","5","2","2015-03-27 16:32:37","29304383","2","0","1563721","","2015-03-27 16:32:37","2015-03-27 15:13:50",""
"29304071","JAVA - How to create signed PDF using original PDF and separate PKCS#7 signed data","<p>I have a original PDF document and separate file as PKCS#7 signed data.
I would like to combine these to create signed PDF document so that it could be shown in for example Adobe reader that it is signed and who signed the document.</p>

<p>Are there any libraries in Java that could be used to create such signed PDF document programatically? I need to load that PDF and add the signature to it somehow, then save it as a new PDF document. </p>

<p>Sample code would be appreciated.</p>

<p><strong>EDIT:</strong></p>

<p>The resulting code should take the PDF document as input parameter and do the following:</p>

<ol>
<li>prepare data to be signed</li>
<li>provide data to be signed to external signing mechanism that produces PKCS#7 signed data file</li>
<li>provide PKCS#7 signed data file</li>
<li>add signed data to PDF document</li>
<li>save PDF document</li>
</ol>

<p>As I understand the first step is important because without that the PKCS#7 signed data would be wrong.</p>
","<p>Try Apache PDFBox</p>

<p>Also, check out the following posts it goes over signing PDFs.</p>

<p><a href=""https://stackoverflow.com/questions/12426064/how-to-sign-pdf-in-java-using-pdfbox"">How to sign pdf in Java using pdfbox</a></p>
","3006","<java><pdf><digital-signature><pkcs#7>","2","0","2","2015-03-27 16:32:37","29304383","2","0","1563721","","2015-03-27 16:32:37","2015-03-27 15:13:50",""
"1995757","digital signature - detached Pkcs#7 to XML-DSIG","<p>I am struggling with the following scenario:</p>

<ol>
<li><p>an XML-message is created client-side and digitally signed using mozilla's window.crypto.signText. After signing, the message and the signature are transmitted via a webservice (.net) to the server. Everything is fine until this point.</p></li>
<li><p>on the server, the XML shall be included in another XML-document, which is publicly accessible. The signature should be published as well in order to grant non-repudiation. </p></li>
</ol>

<p>Q: Is there a smooth option to convert the detached Pkcs#7 into XML-DSIG (e.g. functionality within the .net framework)? </p>

<p>Q2: Or is it possible to create the XML-DSIG already client-side without using external plugins?</p>

<p>Tnx for your help!</p>

<p>Alois Paulin</p>
","<p>Due to the nature of both digital signature formats XML and PKCS#7, it is not possible to convert from one to the other. </p>

<p>In a very simplified explanation, the signature in <a href=""http://tools.ietf.org/html/rfc2315"" rel=""nofollow noreferrer"">PKCS#7</a> format contains, among other stuff, some specific data structure called DigestInfo that contains the data digest and an OID (object identifier), and has been ciphered with the user's private key. The <a href=""http://www.w3.org/TR/xmldsig-core/"" rel=""nofollow noreferrer"">XML-Dsig</a> format applies the final step of the cryptographic algorithm (again with the user's private key) to a different data value calculated from digesting the original XML data and some specific XML-DSig data structures. Therefore, since both ciphered values will not be the same, it is only possible to generate the XML-DSig signature by signing the data with the user's private key, which you will not have access to (thus the name private). </p>

<p>From that explanation, the answer to your first question is <strong>""No, there is no smooth option, it is not possible at all""</strong>.</p>

<p>Therefore the only option is to generate the XML-DSig directly at the client side. That is not possible using standard Javascript, definitely not with Firefox's window.crypto (which only generates PKCS7 detached signatures). At my company (<a href=""http://www.isigma.es"" rel=""nofollow noreferrer"">www.isigma.es</a>), we solve that by using an applet, it is a common solution in the digital signature industry (there are many commercial and also some open source solutions). That may not be an option in your case, if you do not want browser plugins. </p>

<p>CAPICOM (the windows-based active/X component that you may use in a Microsoft setup) also does not generate XML-DSig, only CMS/PKCS7.</p>
","2924","<xml><xml-signature><pkcs#7>","1","4","1","2011-08-05 15:45:22","2504658","0","","680925","","2011-08-05 15:45:22","2010-01-03 18:13:10",""
"6398606","Is there any reason to use CAdES over XAdES for advanced electronic signatures?","<p>I haven't been able to find any reason of why should anyone prefer to implement a CAdES oriented electronic signature software solution over a XAdES oriented one.</p>

<p>There are a lot more open libraries and implementation cases and examples of XAdES on the internet, but still, I don't believe that is the reason why people decide on using XAdES over CAdES.</p>

<p>Is it because XAdES is XML oriented and software developers tend to love anything XML related? Is there any scenario where CAdES is just outright the best option to use over XAdES?</p>

<p>For reference: </p>

<ul>
<li>CAdES is CMS/PKCS#7 in advanced form (supports timestamping)</li>
<li>XAdES is XML-DSig in advanced form (supports timestamping) </li>
</ul>
","<p>One advantage of CAdES is that it <em>generally</em> causes less interoperability problems because the XML-DSig standard allows <strong>many</strong> options including XSLT, XPointer Framework, XML canonicalization and more. CAdES would be less demanding if only dealing with strictly DER-encoded signatures (The picture changes once you need to deal with BER encodings).</p>

<p>CAdES outperforms XAdES in scenarios where producing ""attached"" signatures on large data chunks is necessary (You want the result to be one single chunk of data that contains both the original data and the signature). The equivalent of an attached CAdES signature (The original input data is stored in the EncapContentInfo element of the CMS structure) is an <a href=""http://www.w3.org/TR/xmldsig-core1/#def-SignatureEnveloping"" rel=""nofollow noreferrer"">Enveloping Signature</a>. If you are required to produce such a kind of signature there is a high probability that you will run into problems when dealing with large input data if your XAdES implementation is DOM-based (those I know of are) - your machine will eventually run out of memory.</p>

<p>Performance would be another argument where CAdES is favoured. The message digest computation of CAdES is typically done directly on the raw bytes of the input data, XML signatures that are computed on XML documents involve a lot of overhead such as evaluation of XPath expressions, XSLT transforms, Base64 en-/decoding and Canonicalization, and potentially several Transform elements.   </p>

<p>If you are building an archiving system for long-term validation of signatures where a lot of signatures are stored, CAdES is the preferred format due to its compactness in comparison to the textual XAdES format.</p>
","2904","<xml><content-management-system><pkcs#7><xml-signature><electronic-signature>","5","6","2","2019-07-25 14:12:24","6576952","0","2","1033581","","2019-03-23 05:00:33","2011-06-18 20:08:11",""
"6398606","Is there any reason to use CAdES over XAdES for advanced electronic signatures?","<p>I haven't been able to find any reason of why should anyone prefer to implement a CAdES oriented electronic signature software solution over a XAdES oriented one.</p>

<p>There are a lot more open libraries and implementation cases and examples of XAdES on the internet, but still, I don't believe that is the reason why people decide on using XAdES over CAdES.</p>

<p>Is it because XAdES is XML oriented and software developers tend to love anything XML related? Is there any scenario where CAdES is just outright the best option to use over XAdES?</p>

<p>For reference: </p>

<ul>
<li>CAdES is CMS/PKCS#7 in advanced form (supports timestamping)</li>
<li>XAdES is XML-DSig in advanced form (supports timestamping) </li>
</ul>
","<p>CAdES over XAdES:</p>

<ul>
<li>Less options to implement</li>
<li>(Way) Easier to verify</li>
<li>Works with any sort of data, including XML</li>
<li>Easier for ASiC</li>
<li>Windows API more robust to build it</li>
<li>No need for complex canonicalizations</li>
<li>Can be used with S/MIME</li>
<li>Allows multiple signatures</li>
<li>It is used in PAdES</li>
<li>Faster</li>
</ul>

<p>XAdES over CAdES:</p>

<ul>
<li>Signed XML files can still be read by encryption-unaware applications</li>
<li>Multiple elements can be signed with one pass</li>
<li>You do not need an ASN.1 compiler</li>
</ul>

<p>The only reason I would use XAdES is the first one, personal opinion. But then, an unaware application might modify the file, rendering the signature invalid. Also, using the *AdES types means that you want to be compatible with the EU regulations and, this usually means PDF documents signed with PAdES. When you simply want to sign an e-mail, CAdES is not very much useful as it is not validated by most S/MIME clients. The AdES stuff is european laws, so not so many US apps are aware of it.</p>

<p>Also, these forms are not just the old ones with timestamps, there are a lot of addons. See <a href=""https://www.w3.org/TR/XAdES/"" rel=""nofollow noreferrer"">https://www.w3.org/TR/XAdES/</a> and <a href=""https://www.secureblackbox.com/kb/articles/8-CAdES.rst"" rel=""nofollow noreferrer"">https://www.secureblackbox.com/kb/articles/8-CAdES.rst</a>.</p>

<p>I have also implemented them in C++ for Windows, check <a href=""https://www.codeproject.com/Articles/1256991/AdES-An-implementation-of-CAdES-for-Windows-in-Cpl"" rel=""nofollow noreferrer"">here</a> and <a href=""https://www.turboirc.com/ades"" rel=""nofollow noreferrer"">here</a> for my complete toolset.</p>
","2904","<xml><content-management-system><pkcs#7><xml-signature><electronic-signature>","5","3","2","2019-07-25 14:12:24","6576952","0","2","1033581","","2019-03-23 05:00:33","2011-06-18 20:08:11",""
"24059417","How to decrypt smime.p7m file in DER format using OpenSSL in C code.","<p>I am trying to decrypt emails using openssl. </p>

<p>I am getting smime.p7m file from the server. But it is in DER format. </p>

<p>I can decrypt this file using command prompt, with the command </p>

<pre><code>openssl smime -decrypt -in openssl_working_smime.p7m -inform DER -inkey mycert.pem &gt; dec_mail.eml
</code></pre>

<p>But now I want to do this using C code. </p>

<p>Right now I am trying to do using - </p>

<pre><code>SMIME_read_PKCS7()
</code></pre>

<p>But this returns null with </p>

<pre><code>SMIME_read_ASN1:no content type:asn_mime.c:451: 
</code></pre>

<p>error</p>

<p>Any ideas how to do it? </p>
","","2892","<encryption><openssl><pkcs#7><der>","1","","0","2014-06-05 11:48:02","","2","","","","","2014-06-05 11:48:02",""
"17784735","Decrypting s/mime messages in p7m format with OpenSSL","<p>I'm trying to decrypt p7m with OpenSSL but I cannot go through the error in the following part of the code:</p>

<pre><code>PKCS7 *p7 = NULL;

in = BIO_new_file(convertedResourcePath, ""r"");

    if (in) {
        NSLog(@""opening p7m file"");
    }
    else
        NSLog(@""cannot found p7m file"");

    out = BIO_new_file(convertedDecrFilePath, ""w"");

    if (out) {
        NSLog(@""file for decription has been created"");
    }
    else
        NSLog(@""failed to create decription file"");


    p7 = SMIME_read_PKCS7(in, NULL);

if (p7) {
        NSLog(@""start reading p7m file"");

    }
    else {
        NSLog(@""cannot read p7m file"");
        ERR_print_errors_fp(stderr);
    }

 if (PKCS7_decrypt(p7, pkey, cert, out, 0)) {
        NSLog(@""file decrypted sucessfully!"");
    }
    else
        NSLog(@""cannot decrypt file"");
</code></pre>

<p>I got the following in output:</p>

<blockquote>
  <p>opening p7m file 2013-07-22 12:45:22.951 smimePrototype[10827:c07]
  file for decription has been created 2013-07-22 12:45:22.952
  smimePrototype[10827:c07] cannot read p7m file
  2900150892:error:0D0D40D1:asn1 encoding routines:SMIME_read_ASN1:no
  content type:asn_mime.c:451:
  2013-07-22 12:45:22.953 smimePrototype[10827:c07] cannot decrypt file</p>
</blockquote>

<p>Looking for your help, maybe p7 variable can be initialized in other way?</p>
","<p>I tried to use </p>

<pre><code>p7=d2i_PKCS7_bio(in,NULL);
</code></pre>

<p>instead of</p>

<pre><code>p7 = SMIME_read_PKCS7(in, NULL);
</code></pre>

<p>and it works great.</p>

<p>I hope it will help someone.</p>
","2827","<objective-c><openssl><pkcs#7>","1","5","1","2013-07-23 15:21:37","17814361","4","","2606374","","2013-07-23 15:21:37","2013-07-22 10:03:04",""
"15937586","How to get certificate from pkcs7 file using bouncycastle?","<p>Hi, all! My problem is next: I have the .pkcs7 file which consists pre-packed CSR and I want to get CSR from it. How can I do it using bouncycastle?</p>

<p>I tried use PEMReader, but it didn't work.</p>

<p><pre><code>
    private void getCertificatesPKCS7File(String filename){
        try {
            certificates = new ArrayList();

            FileReader fileReader = new FileReader(filename);
            PEMReader pemReader = new PEMReader(fileReader);
           // Object obj = pemReader.readObject();
           // PKCS10CertificationRequest csr = (PKCS10CertificationRequest) obj;
            Object obj = pemReader.readPemObject().getContent();
            PKCS10CertificationRequest csr = new PKCS10CertificationRequest(obj);

            pemReader.close(); 

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

</code></pre></p>

<p>Exception is next:</p>

<p><pre><code>
Exception in thread ""main"" java.lang.IllegalArgumentException: unknown object in factory: org.bouncycastle.asn1.ASN1ObjectIdentifier
    at org.bouncycastle.asn1.pkcs.CertificationRequestInfo.getInstance(Unknown Source)
    at org.bouncycastle.asn1.pkcs.CertificationRequest.(Unknown Source)
    at org.bouncycastle.jce.PKCS10CertificationRequest.(Unknown Source)
</pre></code></p>

<p>Thank's all!</p>
","<p>I found solution.</p>

<p><pre><code>
        KeyStore keystore = KeyStore.getInstance(""PKCS12"", ""BC"");
        keystore.load (new FileInputStream(PATH+""//test.p12""), ""testpassword"".toCharArray());
        PrivateKey privateKey = (PrivateKey)keystore.getKey(""testclientcert"", ""testpassword"".toCharArray());

        PEMReader pemReader = new PEMReader(new FileReader(filename));
        ContentInfo object = (ContentInfo)pemReader.readObject();

        CMSEnvelopedDataParser envDataParser = new CMSEnvelopedDataParser(object.getEncoded());
        RecipientInformationStore recipients = envDataParser.getRecipientInfos();
        Collection envCollection = recipients.getRecipients();
        Iterator it = envCollection.iterator();
        RecipientInformation recipient = (RecipientInformation) it.next();
        byte[] result = recipient.getContent(privateKey, ""BC"");
        String base64Encoded = new String(Base64.encode(result));

        System.out.println(base64Encoded);

</code></pre></p>

<p>base64Encoded will be match with encoded csr.</p>
","2727","<java><bouncycastle><pkcs#7><csr>","2","0","1","2013-04-12 17:17:11","15977249","2","1","1809141","","2013-04-11 05:32:34","2013-04-10 22:25:42",""
"18700851","Extract certificate from a PKCS7 signature in php","<p>I need to extract the user certificate from a pkcs7 signature file. I can do it via the command line using the following:</p>

<pre><code>openssl pkcs7 -in somesign.pks7 -inform PEM -print_certs
</code></pre>

<p>This will give me the entire certificate chain and I can process the resulting file to extract what I want.</p>

<p>Is there any way to do that with the openssl_pkcs7_ commands? I saw that openssl_pkcs7_verify has the $outfilename where the certs would be stored but I don't have the signed message, but it seems the $filename should have both the signature and the message, which is not my case (signature is in a separate file).</p>
","<p>I have already using it via <code>exec()</code> function.</p>

<pre><code>exec('../../apache/bin/openssl.exe pkcs7 -in D:/mypkcs7.p7b -inform DER -print_certs').
</code></pre>

<p>But I think, the best choise is to use the structure of SMIME files. You can obtain the structure by analysing the source code of OpenSSL. Finding it maybe tough,but once you find it,you can use it anywhere. OpenSSL GitHub source code is available 
<a href=""https://github.com/openssl/openssl"" rel=""nofollow noreferrer"">here</a></p>
","2675","<php><openssl><signature><pkcs#7><smime>","13","2","2","2017-06-12 10:15:45","","2","1","558866","","2017-06-05 14:31:37","2013-09-09 14:42:19",""
"18700851","Extract certificate from a PKCS7 signature in php","<p>I need to extract the user certificate from a pkcs7 signature file. I can do it via the command line using the following:</p>

<pre><code>openssl pkcs7 -in somesign.pks7 -inform PEM -print_certs
</code></pre>

<p>This will give me the entire certificate chain and I can process the resulting file to extract what I want.</p>

<p>Is there any way to do that with the openssl_pkcs7_ commands? I saw that openssl_pkcs7_verify has the $outfilename where the certs would be stored but I don't have the signed message, but it seems the $filename should have both the signature and the message, which is not my case (signature is in a separate file).</p>
","<p>I'm not aware of a PHP library with straightforward API for this.</p>

<p>I've implemented several libraries however that could help with the task. <a href=""https://packagist.org/packages/sop/asn1"" rel=""nofollow noreferrer"">asn1</a>, <a href=""https://packagist.org/packages/sop/crypto-util"" rel=""nofollow noreferrer"">crypto-util</a> and <a href=""https://packagist.org/packages/sop/x509"" rel=""nofollow noreferrer"">x509</a> are available via composer.</p>

<p>Here's a barebones proof of concept that extracts all certificates from a PKCS7 PEM file:</p>

<pre><code>&lt;?php

use ASN1\Element;
use ASN1\Type\Constructed\Sequence;
use CryptoUtil\PEM\PEM;
use X509\Certificate\Certificate;

require __DIR__ . ""/vendor/autoload.php"";

$pem = PEM::fromFile(""path-to-your.p7b"");
// ContentInfo: https://tools.ietf.org/html/rfc2315#section-7
$content_info = Sequence::fromDER($pem-&gt;data());
// SignedData: https://tools.ietf.org/html/rfc2315#section-9.1
$signed_data = $content_info-&gt;getTagged(0)-&gt;asExplicit()-&gt;asSequence();
// ExtendedCertificatesAndCertificates: https://tools.ietf.org/html/rfc2315#section-6.6
$ecac = $signed_data-&gt;getTagged(0)-&gt;asImplicit(Element::TYPE_SET)-&gt;asSet();
// ExtendedCertificateOrCertificate: https://tools.ietf.org/html/rfc2315#section-6.5
foreach ($ecac-&gt;elements() as $ecoc) {
    $cert = Certificate::fromASN1($ecoc-&gt;asSequence());
    echo $cert-&gt;toPEM() . ""\n"";
}
</code></pre>

<p>ASN.1 handling is very error-prone. I've omitted all sanity checks from the above example, but the underlying library will throw exceptions on errors.</p>

<p>I hope this gives some pointers in case someone needs to parse PKCS #7 structures without relying on external programs.</p>
","2675","<php><openssl><signature><pkcs#7><smime>","13","3","2","2017-06-12 10:15:45","","2","1","558866","","2017-06-05 14:31:37","2013-09-09 14:42:19",""
"14037917","PKCS7 encrypt decrypt in Node.js","<p>I am using pkcs7 encrypt decrypt in current project. I want to change from PHP to Node.js. Is there pkcs7 encrypt/decrypt in Node.js ? </p>

<p>In PHP,</p>

<pre><code>&lt;?php

$data = &lt;&lt;&lt;EOD
Hello world
EOD;

// load key
$key = file_get_contents(""mypublickey.crt"");

// save message to file
$fp = fopen(""msg.txt"", ""w"");
fwrite($fp, $data);
fclose($fp);

// encrypt it
if (openssl_pkcs7_encrypt(""msg.txt"", ""enc.txt"", $key,array())) {
    // message encrypted - send it!

}
?&gt;
</code></pre>

<p>to decrypt</p>

<pre><code>&lt;?php
// The certification stuff
$public = file_get_contents(""mypublickey.crt"");
$private = array(file_get_contents(""myprivatekey.pem""), ""mypassword"");

$infile = tempnam("""", ""enc"");
file_put_contents($infile, $encrypted); 
$outfile = tempnam("""", ""dec"");

if(openssl_pkcs7_decrypt(""enc.txt"", ""dec.txt"", $public, $private))
{
    // Decryption successful
    echo file_get_contents(""dec.txt"");
}
?&gt;
</code></pre>

<p>Is there any similar function like this in Node.js ?</p>
","<p>I've faced the same issue and spent too much time but I found a way in the end.</p>

<p>I found and used <a href=""https://github.com/digitalbazaar/forge"" rel=""nofollow noreferrer"">forge</a> open source lib. You can simply add to your project by following:</p>

<pre><code>npm install node-forge
</code></pre>

<p>Then, code snippet below performs encryption with <code>PKCS#7</code> format.</p>

<pre><code>var forge = require('node-forge');

// create cert object
var cert = forge.pki.certificateFromPem(certOrPemString);
// create envelop data
var p7 = forge.pkcs7.createEnvelopedData();
// add certificate as recipient
p7.addRecipient(cert);
// set content 
p7.content = forge.util.createBuffer();
p7.content.putString('content to be encrypted');

// encrypt
p7.encrypt();

// obtain encrypted data with DER format
var bytes = forge.asn1.toDer(p7.toAsn1()).getBytes();
</code></pre>

<p>This code block will encrypt the content you provided and return a byte array with <code>DER</code> output format. </p>

<p>You can convert byte array to <code>UTF-8</code> string by following:</p>

<pre><code>var str = Buffer.from(bytes, 'binary').toString('utf8');
</code></pre>

<p>And you can decrypt the content as follows:</p>

<pre><code>var recipient = p7.findRecipient(cert);
// decrypt
p7.decrypt(p7.recipients[0], privateKey); 
</code></pre>

<p>Hope this may help.</p>
","2675","<node.js><openssl><pkcs#7>","4","6","1","2019-02-14 09:01:05","44619604","3","3","","","","2012-12-26 08:29:46",""
"12038725","Decrypt a PKCS7 file in c++ with OpenSSL","<p>I have a PKCS7 file, produced by M2Crypto python library, which looks like this:</p>

<pre><code>-----BEGIN PKCS7-----
MIIBWAYJKoZIhvcNAQcDo[cut]
-----END PKCS7-----
</code></pre>

<p>Is is binary content encripted by a public key.</p>

<p>Now I need to decrypt it in C++, but it seems not to recognize this format. I tried <code>d2i_PKCS7_bio()</code> and  <code>SMIME_read_PKCS7()</code>, but I always get errors like:</p>

<pre><code>8957:error:0D0680A8:asn1 encoding routines:ASN1_CHECK_TLEN:wrong tag:tasn_dec.c:1316:
8957:error:0D07803A:asn1 encoding routines:ASN1_ITEM_EX_D2I:nested asn1 error:tasn_dec.c:380:Type=PKCS7
</code></pre>

<p>and similar errors trying by command line like this:</p>

<pre><code>openssl smime -decrypt -inform DER -binary -inkey privkey.pem
</code></pre>

<p><strong>EDIT</strong><br>
I found the right command line option:</p>

<pre><code>openssl cms -decrypt -in samplepkcs7.pem  -inkey privkey.pem -inform pem
</code></pre>

<p>Now I need to find the corresponding function in C++.</p>

<p>Maybe I'm wrong, but it's really hard to find documentation on this. Any help would be appreciated.</p>
","<p>What you have is a PEM-format object; a DER-format object would look like garbage in a text editor (by virtue of being a binary format). Hence you want <code>PEM_read_PKCS7()</code>.</p>

<p>The OpenSSL documentation is inherently a mess, and it's very difficult to learn your way around without a guide of some sort. I recommend the O'Reilly <a href=""http://shop.oreilly.com/product/9780596002701.do"" rel=""nofollow"">Network Security with OpenSSL</a> text; while written for OpenSSL 0.9.6/0.9.7, it's still an excellent introduction to the library (the API hasn't changed very much) and will serve as a handy reference.</p>
","2670","<c++><openssl><pkcs#7>","1","0","1","2012-08-21 19:39:00","12061864","0","1","1581393","","2012-08-21 15:14:13","2012-08-20 13:35:09",""
"29102564","PHP How to parse pkcs7 signature blob?","<p>I have a PKCS7 signature which i can get parsed contents from with</p>

<pre><code>openssl pkcs7 -inform DER -in signature.pkcs7 -print_certs -text
</code></pre>

<p>But how do archieve the same output with PHPs openssl functions?</p>

<p>Edit. I succeeded in creating a correct PEM file with the following function:</p>

<pre><code>function der2pem($der_data, $type=""CERTIFICATE"") {
   $pem = chunk_split(base64_encode($der_data), 64, ""\n"");
   $pem = ""-----BEGIN $type-----\n"".$pem.""-----END $type-----\n"";
   return $pem;
}
$data = der2pem($der_data, ""PKCS7"");
</code></pre>

<p>Im not however successfull in parsing the data with any of the functions mentioned in the PHP manual. It works using openssl with: </p>

<pre><code>openssl pkcs7 -inform PEM -in signature.pkcs7 -print_certs -text
</code></pre>
","<p>What about this solution :) </p>

<pre><code>&lt;?php
    $result = shell_exec('openssl pkcs7 -inform DER -in signature.pkcs7 -print_certs -text');
    var_dump ($result);
    // you can use preg_match() if you want to parse something specific 
</code></pre>
","2642","<php><openssl><pkcs#7>","6","0","2","2019-02-20 00:36:34","29392598","2","2","196420","","2019-02-20 00:36:34","2015-03-17 15:02:34",""
"29102564","PHP How to parse pkcs7 signature blob?","<p>I have a PKCS7 signature which i can get parsed contents from with</p>

<pre><code>openssl pkcs7 -inform DER -in signature.pkcs7 -print_certs -text
</code></pre>

<p>But how do archieve the same output with PHPs openssl functions?</p>

<p>Edit. I succeeded in creating a correct PEM file with the following function:</p>

<pre><code>function der2pem($der_data, $type=""CERTIFICATE"") {
   $pem = chunk_split(base64_encode($der_data), 64, ""\n"");
   $pem = ""-----BEGIN $type-----\n"".$pem.""-----END $type-----\n"";
   return $pem;
}
$data = der2pem($der_data, ""PKCS7"");
</code></pre>

<p>Im not however successfull in parsing the data with any of the functions mentioned in the PHP manual. It works using openssl with: </p>

<pre><code>openssl pkcs7 -inform PEM -in signature.pkcs7 -print_certs -text
</code></pre>
","<p>Unfortunatelly, I believe there is not simple solution. If you want to parse PKCS#7 DER encoded signature in PHP, you need some ASN.1 parser. OpenSSL functions in PHP are not capable to do it. </p>

<p><a href=""https://stackoverflow.com/questions/6272020/do-any-php-libraries-exist-for-parsing-asn-1-or-generating-php-code-based-on-it"">Do any PHP libraries exist for parsing ASN.1 or generating PHP code based on it?</a></p>

<p>Try to decode your DER data with some of referenced parsers. If any parser will work, you should be able to see and extract required information. As first step, you can try online parser from phpseclib project.    </p>

<p><a href=""http://phpseclib.sourceforge.net/x509/asn1parse.php"" rel=""nofollow noreferrer"">http://phpseclib.sourceforge.net/x509/asn1parse.php</a></p>
","2642","<php><openssl><pkcs#7>","6","5","2","2019-02-20 00:36:34","29392598","2","2","196420","","2019-02-20 00:36:34","2015-03-17 15:02:34",""
"39378249","create PKCS7 with presigned data using bouncy castle","<p>I would like to create a detached signature in a PDF file using a PKCS7 container. The data (hash) is being signed beforehand on a different device with the private key. I want to create a PKCS7 containing the signed data along with the certificate with the public key. I can't seem to create the PKCS7 with bouncy castle without supplying the private key and having the library signing the data. This doesn't seem to work:</p>

<pre><code>        InputStream inStream = new FileInputStream(""1_public.pem"");
        BufferedInputStream bis = new BufferedInputStream( inStream );

        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

        List&lt;Certificate&gt; certList = new ArrayList&lt;Certificate&gt;();
        Certificate certificate = cf.generateCertificate(bis);
        certList.add(certificate);
        Store certs = new JcaCertStore(certList);

        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        gen.addCertificates( certs );
        CMSProcessableInputStream msg = new CMSProcessableInputStream( new ByteArrayInputStream( ""signedhash"".getBytes() ) );

        CMSSignedData signedData = gen.generate(msg, false);
        byte[] pkcs7 = signedData.getEncoded() ) );
</code></pre>
","<p>I managed to do this by providing a ContentSigner that doesn't sign, actually quite simple:</p>

<pre><code>        InputStream inStream = new FileInputStream(""1_public.pem"");
        BufferedInputStream bis = new BufferedInputStream( inStream );

        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

        List&lt;Certificate&gt; certList = new ArrayList&lt;Certificate&gt;();
        Certificate certificate = cf.generateCertificate(bis);
        certList.add(certificate);
        Store certs = new JcaCertStore(certList);
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        gen.addCertificates( certs );

        final byte[] signedHash = ""signedhash"".getBytes();

        ContentSigner nonSigner = new ContentSigner() {

            @Override
            public byte[] getSignature() {
                return signedHash;
            }

            @Override
            public OutputStream getOutputStream() {
                return new ByteArrayOutputStream();
            }

            @Override
            public AlgorithmIdentifier getAlgorithmIdentifier() {
                return new DefaultSignatureAlgorithmIdentifierFinder().find( ""SHA256WithRSA"" );
            }
        };

        org.bouncycastle.asn1.x509.Certificate cert = org.bouncycastle.asn1.x509.Certificate.getInstance(ASN1Primitive.fromByteArray(certificate.getEncoded()));
        JcaSignerInfoGeneratorBuilder sigb = new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build());
        sigb.setDirectSignature( true );
        gen.addSignerInfoGenerator(sigb.build(nonSigner, new X509CertificateHolder(cert)));
        CMSProcessableInputStream msg = new CMSProcessableInputStream( new ByteArrayInputStream( ""not used"".getBytes() ) );

        CMSSignedData signedData = gen.generate(msg, false);
        byte[] pkcs7 = signedData.getEncoded();
</code></pre>
","2638","<java><bouncycastle><pkcs#7>","2","5","2","2018-01-16 14:23:19","39408052","2","1","","","","2016-09-07 20:11:30",""
"39378249","create PKCS7 with presigned data using bouncy castle","<p>I would like to create a detached signature in a PDF file using a PKCS7 container. The data (hash) is being signed beforehand on a different device with the private key. I want to create a PKCS7 containing the signed data along with the certificate with the public key. I can't seem to create the PKCS7 with bouncy castle without supplying the private key and having the library signing the data. This doesn't seem to work:</p>

<pre><code>        InputStream inStream = new FileInputStream(""1_public.pem"");
        BufferedInputStream bis = new BufferedInputStream( inStream );

        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

        List&lt;Certificate&gt; certList = new ArrayList&lt;Certificate&gt;();
        Certificate certificate = cf.generateCertificate(bis);
        certList.add(certificate);
        Store certs = new JcaCertStore(certList);

        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        gen.addCertificates( certs );
        CMSProcessableInputStream msg = new CMSProcessableInputStream( new ByteArrayInputStream( ""signedhash"".getBytes() ) );

        CMSSignedData signedData = gen.generate(msg, false);
        byte[] pkcs7 = signedData.getEncoded() ) );
</code></pre>
","<p>In case the ""external signature"" is performed by a hardware device it is possible that it also contains ""signed attributes"". In this case the code must also contain:</p>

<pre><code>AttributeTable signedAttributes = signer.getSignedAttributes();
signerInfoBuilder.setSignedAttributeGenerator(new SimpleAttributeTableGenerator(signedAttributes));     
signatureGenerator.addSignerInfoGenerator(signerInfoBuilder.build(nonSigner, signCertificate));
</code></pre>

<p>you should also remove the </p>

<pre><code>signatureGenerator.setDirectSignature(true)
</code></pre>

<p>a complete example can be found here <a href=""https://www.len.ro/work/attach-payload-into-detached-pkcs7-signature/"" rel=""nofollow noreferrer"">https://www.len.ro/work/attach-payload-into-detached-pkcs7-signature/</a>. Since I spend a lot of time searching for a solution and this post provided a vital clue I thought I should complete with the information I still missed in an article. Thanks.</p>
","2638","<java><bouncycastle><pkcs#7>","2","0","2","2018-01-16 14:23:19","39408052","2","1","","","","2016-09-07 20:11:30",""
"2004096","Alternatives to Bouncy Castle java library for PKCS7 encryption/signing?","<p>We've always used the BouncyCastle library, I'm being asked if there are other viable alternatives, either open source or not. Or is the BouncyCastle library already the best one to use?</p>
","<p>You could try <a href=""http://savannah.gnu.org/projects/classpathx/"" rel=""nofollow noreferrer"">classpathx</a>.  However, from experience I would say that Bouncy Castle is definitely the best.</p>
","2634","<java><encryption><pkcs#7>","1","1","1","2010-01-05 04:04:38","2004106","1","1","","","","2010-01-05 03:59:28",""
"46430367","How to retrieve digital signature information from PDF with PHP?","<p>I have app that needs to retrieve some data (signer name) from digital signature ""attached"" on PDF files.</p>

<p>I have found only examples in Java and C# using the iText class AcroFields method GetSignatureNames</p>

<p><strong>edit:</strong> I've tried <em>pdftk</em> with dump_data_fields and generate_fpdf and the result was that (unfortunately):</p>

<pre><code>/Fields [
&lt;&lt;
/V /dftk.com.lowagie.text.pdf.PdfDictionary@3048918
/T (Signature1)
&gt;&gt;]
</code></pre>

<p>and</p>

<pre><code>FieldType: Signature
FieldName: Signature1
FieldFlags: 0
FieldJustification: Left
</code></pre>

<p>Thanks in Advance !</p>
","<p>Well, it's complicated (I would say even impossible, but who knows) to achieve this only with PHP.</p>

<p>At first, please read <a href=""https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSig/Acrobat_DigitalSignatures_in_PDF.pdf"" rel=""nofollow noreferrer"">article about digital signature in Adobe PDF</a></p>

<p>Second, after reading this you will know that signature is stored between b and c bytes according to /ByteRange[a b c d] indicator</p>

<p>Third, we can extract b and c from document and then extract signature itself (guide says it will be hexdecoded PKCS7# object). </p>

<pre><code>&lt;?php

 $content = file_get_contents('test.pdf');

 $regexp = '#ByteRange\[\s*(\d+) (\d+) (\d+)#'; // subexpressions are used to extract b and c

 $result = [];
 preg_match_all($regexp, $content, $result);

 // $result[2][0] and $result[3][0] are b and c
 if (isset($result[2]) &amp;&amp; isset($result[3]) &amp;&amp; isset($result[2][0]) &amp;&amp; isset($result[3][0]))
 {
     $start = $result[2][0];
     $end = $result[3][0];
     if ($stream = fopen('test.pdf', 'rb')) {
         $signature = stream_get_contents($stream, $end - $start - 2, $start + 1); // because we need to exclude &lt; and &gt; from start and end

         fclose($stream);
     }

     file_put_contents('signature.pkcs7', hex2bin($signature));
}
</code></pre>

<p>Forth, after third step we have PKCS#7 object in file signature.pkcs7. Unfortunately, I don't know methods to extract information from signature using PHP. So you must be able to run shell commands to use openssl</p>

<pre><code>openssl pkcs7 -in signature.pkcs7 -inform DER -print_certs &gt; info.txt
</code></pre>

<p>After running this command in file info.txt you will have a chain of certificates. Last one is the one you need. You can see the structure of the file and parse needed data.</p>

<p>Please also refer to <a href=""https://stackoverflow.com/questions/18700851/extract-certificate-from-a-pkcs7-signature-in-php"">this question</a>, <a href=""https://stackoverflow.com/questions/29102564/php-how-to-parse-pkcs7-signature-blob"">this question</a> and <a href=""http://qistoph.blogspot.bg/2012/01/manual-verify-pkcs7-signed-data-with.html"" rel=""nofollow noreferrer"">this topic</a></p>

<p><strong>EDIT at 2017-10-09</strong>
I knowingly advised you to see <a href=""https://stackoverflow.com/questions/18700851/extract-certificate-from-a-pkcs7-signature-in-php"">exactly this question</a>
There is a code that you can adjust to your needs.</p>

<pre><code>use ASN1\Type\Constructed\Sequence;
use ASN1\Element;
use X509\Certificate\Certificate;       

$seq = Sequence::fromDER($binaryData);
$signed_data = $seq-&gt;getTagged(0)-&gt;asExplicit()-&gt;asSequence();
// ExtendedCertificatesAndCertificates: https://tools.ietf.org/html/rfc2315#section-6.6
$ecac = $signed_data-&gt;getTagged(0)-&gt;asImplicit(Element::TYPE_SET)-&gt;asSet();
// ExtendedCertificateOrCertificate: https://tools.ietf.org/html/rfc2315#section-6.5
$ecoc = $ecac-&gt;at($ecac-&gt;count() - 1);
$cert = Certificate::fromASN1($ecoc-&gt;asSequence());
$commonNameValue = $cert-&gt;tbsCertificate()-&gt;subject()-&gt;toString();
echo $commonNameValue;
</code></pre>

<p>I've adjusted it for you, but please make the rest by yourself.</p>
","2630","<php><pdf><digital-signature><pkcs#7>","21","16","2","2019-01-24 19:20:58","46603440","7","7","284932","","2017-09-26 16:39:01","2017-09-26 15:23:34",""
"46430367","How to retrieve digital signature information from PDF with PHP?","<p>I have app that needs to retrieve some data (signer name) from digital signature ""attached"" on PDF files.</p>

<p>I have found only examples in Java and C# using the iText class AcroFields method GetSignatureNames</p>

<p><strong>edit:</strong> I've tried <em>pdftk</em> with dump_data_fields and generate_fpdf and the result was that (unfortunately):</p>

<pre><code>/Fields [
&lt;&lt;
/V /dftk.com.lowagie.text.pdf.PdfDictionary@3048918
/T (Signature1)
&gt;&gt;]
</code></pre>

<p>and</p>

<pre><code>FieldType: Signature
FieldName: Signature1
FieldFlags: 0
FieldJustification: Left
</code></pre>

<p>Thanks in Advance !</p>
","<p>I've used iText and found it to be very reliable, I highly recommend it.
you can always call the java code as a ""microservice"" from PHP.</p>
","2630","<php><pdf><digital-signature><pkcs#7>","21","0","2","2019-01-24 19:20:58","46603440","7","7","284932","","2017-09-26 16:39:01","2017-09-26 15:23:34",""
"15580065","AES/CBC/PKCS5Padding implementation in Ruby (for rails)","<p>I need to decrypt text encrypted using <code>AES/CBC/PKCS5Padding</code> scheme. The encrypted text I got was generated using some Java software.</p>

<p>All values below are changed by me to something fictional.</p>

<p>What I get is a Key <code>aHjgYFutF672eGIUGGVlgSETyM9VJj0K</code> (256-bit = 32-chars * 8-bit)
and IV: <code>rxYoks3c8hRRsL2P</code> (16-bit)</p>

<p>and (I supposed) Base64 encoded encrypted result <code>ETlAHS5ZcshKxQUaHVB8==</code></p>

<p>What I need is to decrypt in Ruby this <code>ETlAHS5ZcshKxQUaHVB8==</code> to get in the and a simple string, like 'blablablabla'</p>

<p>I tried to decrypt what I got using both Ruby and just common linux console openssl command.
NOTE: Key and IV below are not the ones used in real code:</p>

<pre><code># require 'openssl'
# require 'base64'
# decryption
aes = OpenSSL::Cipher::AES256.new(:CBC)
aes.decrypt
aes.padding = 1 # actually it's on by default
aes.key = ""aHjgYFutF672eGIUGGVlgSETyM9VJj0K""
aes.iv=""rxYoks3c8hRRsL2P""
aes.update(Base64::decode64(""ETlAHS5ZcshKxQUaHVB8==""))+aes.final
=&gt; OpenSSL::Cipher::CipherError: bad decrypt
</code></pre>

<p>Same as above but in console, key and iv converted to hex with:</p>

<pre><code>$ echo -n $key256 | hexdump -e '16/1 ""%02x""'
$ echo -n $iv     | hexdump -e '16/1 ""%02x""'

$ echo ""ETlAHS5ZcshKxQUaHVB8=="" | openssl enc -d -aes-256-cbc -a  -K 61486a675946757446363732654749554747566c67534554794d39564a6a304b -iv 7278596f6b73336338685252734c3250
bad decrypt
140378046432928:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:evp_enc.c:539:
</code></pre>

<p>BTW. to get back original key and iv in the console you an use:</p>

<pre><code>$ echo 61486a6... | xxd -r -p
#or , but then need to add \x before every character pair
$ eval `printf ""\x61\x48......""
</code></pre>

<p>Please give me some clues as I hoped in the beginning that I will be able to use <a href=""https://github.com/chicks/aes"" rel=""nofollow"">https://github.com/chicks/aes</a> gem. The gem seems fine, it's just a nice wrapper for <code>OpenSSL::Cipher::Cipher</code>.</p>

<p>Is it possible that ruby/openssl use different PKCS, let's say PKCS#7, Java uses PKCS#5 and I need to preprocess my data ? Or there is a vesion mismatch between ruby/openssl and that Java's PKCS #7 and #5? #5 is meant for 8byte data blocks and #7 is for 16byte? Just a wild guess ...</p>
","<p>The Ruby code in my first post is correct, the problem was this <code>AES/CBC/PKCS5Padding</code> used by Java part.</p>

<p>Java program should not use this scheme for <code>AES-CBC-256</code>. <code>PKCS5</code> pads to a 64 bit (8 byte) block size, but <code>AES-256-CBC</code> uses 16 byte blocks. Therefore, <code>PKCS7</code> must be used.</p>
","2600","<ruby><aes><pkcs#7><pkcs#5>","3","3","1","2013-04-02 15:31:49","15768151","3","1","470512","","2013-03-27 10:14:37","2013-03-22 21:21:37",""
"16284225","Using pycrypto PKCS#7 to create a signature","<p>I'm looking at the Apple docs for PassBook, and I need to:</p>

<ul>
<li>create a ""PKCS #7 detached signature of the manifest file"".</li>
</ul>

<p>I'd ideally like to do this with Python and I'd ideally like to use pycrypto for the task, the trouble is, I can't find any example code on the web on how to do this, there's lots of code like this:</p>

<pre><code>from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA

message = 'To be encrypted'
h = SHA.new(message)

key = RSA.importKey(open('pubkey.der').read())
cipher = PKCS1_v1_5.new(key)
ciphertext = cipher.encrypt(message+h.digest())
</code></pre>

<p>but not knowing enough about the specifics of PKCS#7, I don't know what I need to do...</p>

<p>Does anyone have any ideas?</p>

<p>Thanks</p>
","<p>With a lot of help from <a href=""https://stackoverflow.com/a/33726421"">this answer</a>, I did it!</p>

<p>I know op probably moved past this, but this answer is nowhere in the internet, so here's the solution, for posterity's sake!</p>

<pre><code>from OpenSSL import crypto

with open(cert) as cert_file:
    cert_buf = cert_file.read()

with open(key) as key_file:
    key_buf = key_file.read()

pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key_buf)
signcert = crypto.load_certificate(crypto.FILETYPE_PEM, cert_buf)

bio_in = crypto._new_mem_buf(text.encode())
PKCS7_NOSIGS = 0x4  # defined in pkcs7.h
pkcs7 = crypto._lib.PKCS7_sign(signcert._x509, pkey._pkey, crypto._ffi.NULL, bio_in, PKCS7_NOSIGS)  # noqa
bio_out = crypto._new_mem_buf()
crypto._lib.i2d_PKCS7_bio(bio_out, pkcs7)
sigbytes = crypto._bio_to_string(bio_out)
</code></pre>

<p>Keep in mind, it uses some undocumented pyopenssl functions.</p>
","2564","<python><pkcs#7>","5","10","2","2018-11-30 11:10:58","41553623","1","5","","","","2013-04-29 17:00:25",""
"16284225","Using pycrypto PKCS#7 to create a signature","<p>I'm looking at the Apple docs for PassBook, and I need to:</p>

<ul>
<li>create a ""PKCS #7 detached signature of the manifest file"".</li>
</ul>

<p>I'd ideally like to do this with Python and I'd ideally like to use pycrypto for the task, the trouble is, I can't find any example code on the web on how to do this, there's lots of code like this:</p>

<pre><code>from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA

message = 'To be encrypted'
h = SHA.new(message)

key = RSA.importKey(open('pubkey.der').read())
cipher = PKCS1_v1_5.new(key)
ciphertext = cipher.encrypt(message+h.digest())
</code></pre>

<p>but not knowing enough about the specifics of PKCS#7, I don't know what I need to do...</p>

<p>Does anyone have any ideas?</p>

<p>Thanks</p>
","<p>This works for me , I was trying to sign a string for NSDL, </p>

<pre><code>from OpenSSL import crypto
import base64
try:
    p12 = crypto.load_pkcs12(open(""/DSCPFX.pfx"", 'rb').read(), ""XXXX"")
    # print(""p12 : "", p12)
    signcert = p12.get_certificate()
    pkey = p12.get_privatekey()

    text = ""This is the text to be signed""
    bio_in = crypto._new_mem_buf(text.encode())
    PKCS7_NOSIGS = 0x4
    pkcs7 = crypto._lib.PKCS7_sign(signcert._x509, pkey._pkey, crypto._ffi.NULL, bio_in, PKCS7_NOSIGS)
    bio_out = crypto._new_mem_buf()
    crypto._lib.i2d_PKCS7_bio(bio_out, pkcs7)

    sigbytes = crypto._bio_to_string(bio_out)

    signed_data = base64.b64encode(sigbytes)
    return SUCCESS, signed_data
except Exception as err:
    print(""Exception happens in sign_data and error is: "", err)
    return 0, str(err)
</code></pre>
","2564","<python><pkcs#7>","5","1","2","2018-11-30 11:10:58","41553623","1","5","","","","2013-04-29 17:00:25",""
"15735354","php, openssl and GOST","<p>I'm trying to sign an S/MIME with PHP, using a pair of GOST-encrypted certificate and a private key.</p>

<p>When using openssl itself from a console everything is fine:</p>

<pre><code>/usr/local/openssl/bin/openssl cms -sign -in file.txt -out signedfile.txt -signer p12.pem
(signedfile.txt is created)

/usr/local/openssl/bin/openssl cms -verify -in signedfile.txt -out signedddata.txt -no_signer_cert_verify -issuer_checks -ignore_critical
Verification successful
</code></pre>

<p>When using PHP code I'm kinda stuck:</p>

<pre><code>$res = openssl_pkcs7_sign(""file.txt"", ""phpsignedfile.txt"", 'file://'.realpath('./p12.pem'), 'file://'.realpath('./p12.pem'), array(""To"" =&gt; ""foo@bar.com"", ""From: FooBar &lt;foo@bar.com&gt;"", ""Subject"" =&gt; ""Foo Bar""));

    if (!$res) {
        while ($msg = openssl_error_string())
            echo $msg . ""&lt;br /&gt;\n"";
        echo ""Failed to sign.\n""; exit;
    }
</code></pre>

<p>I get:</p>

<pre><code># /usr/local/php/bin/php sign-clear.php
PHP Warning:  openssl_pkcs7_sign(): error getting private key in /root/tests/sign-clear.php on line 3
error:0609E09C:digital envelope routines:PKEY_SET_TYPE:unsupported algorithm&lt;br /&gt;
error:0606F076:digital envelope routines:EVP_PKCS82PKEY:unsupported private key algorithm&lt;br /&gt;
error:0907B00D:PEM routines:PEM_READ_BIO_PRIVATEKEY:ASN1 lib&lt;br /&gt;
Failed to sign.
</code></pre>

<p>The 'error getting private key' is all the time here, except for when it really cannot be loaded I get the 'no start line error'. So this output really looks like PHP openssl module cannot find a proper cipher.</p>

<p>How do I tell PHP that this is a GOST cipher ? I'm telling this to openssl either using a config file, or using a direct '-engine gost' option. Is there a way to tell PHP the same thing ?</p>

<p>I have indeed a PHP compiled and linked to a GOST-enabled openss 1.0.1e (openssl module was built with PHP together):</p>

<pre><code># /usr/local/openssl/bin/openssl ciphers | grep -i GOST
ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:SRP-DSS-AES-256-CBC-SHA:SRP-RSA-AES-256-CBC-SHA:DHE-DSS-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA256:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:DHE-RSA-CAMELLIA256-SHA:DHE-DSS-CAMELLIA256-SHA:GOST2001-GOST89-GOST89:GOST94-GOST89-GOST89:ECDH-RSA-AES256-GCM-SHA384:ECDH-ECDSA-AES256-GCM-SHA384:ECDH-RSA-AES256-SHA384:ECDH-ECDSA-AES256-SHA384:ECDH-RSA-AES256-SHA:ECDH-ECDSA-AES256-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:CAMELLIA256-SHA:PSK-AES256-CBC-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:SRP-DSS-3DES-EDE-CBC-SHA:SRP-RSA-3DES-EDE-CBC-SHA:EDH-RSA-DES-CBC3-SHA:EDH-DSS-DES-CBC3-SHA:ECDH-RSA-DES-CBC3-SHA:ECDH-ECDSA-DES-CBC3-SHA:DES-CBC3-SHA:PSK-3DES-EDE-CBC-SHA:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:SRP-DSS-AES-128-CBC-SHA:SRP-RSA-AES-128-CBC-SHA:DHE-DSS-AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256:DHE-DSS-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA:DHE-RSA-SEED-SHA:DHE-DSS-SEED-SHA:DHE-RSA-CAMELLIA128-SHA:DHE-DSS-CAMELLIA128-SHA:ECDH-RSA-AES128-GCM-SHA256:ECDH-ECDSA-AES128-GCM-SHA256:ECDH-RSA-AES128-SHA256:ECDH-ECDSA-AES128-SHA256:ECDH-RSA-AES128-SHA:ECDH-ECDSA-AES128-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:SEED-SHA:CAMELLIA128-SHA:IDEA-CBC-SHA:PSK-AES128-CBC-SHA:ECDHE-RSA-RC4-SHA:ECDHE-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:RC4-SHA:RC4-MD5:PSK-RC4-SHA:EDH-RSA-DES-CBC-SHA:EDH-DSS-DES-CBC-SHA:DES-CBC-SHA:EXP-EDH-RSA-DES-CBC-SHA:EXP-EDH-DSS-DES-CBC-SHA:EXP-DES-CBC-SHA:EXP-RC2-CBC-MD5:EXP-RC4-MD5
</code></pre>

<p>(notice it's the default config output)</p>

<pre><code># ldd /usr/local/php/bin/php
        linux-vdso.so.1 =&gt;  (0x00007fff42455000)
        libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0x00007f1077404000)
        libresolv.so.2 =&gt; /lib/libresolv.so.2 (0x00007f10771ee000)
        librt.so.1 =&gt; /lib/librt.so.1 (0x00007f1076fe5000)
        libmcrypt.so.4 =&gt; /usr/lib/libmcrypt.so.4 (0x00007f1076db3000)
        libltdl.so.7 =&gt; /usr/lib/libltdl.so.7 (0x00007f1076baa000)
        libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007f10769a5000)
        libfreetype.so.6 =&gt; /usr/lib/libfreetype.so.6 (0x00007f107671d000)
        libz.so.1 =&gt; /usr/lib/libz.so.1 (0x00007f1076506000)
        libpng12.so.0 =&gt; /lib/libpng12.so.0 (0x00007f10762df000)
        libjpeg.so.62 =&gt; /usr/lib/libjpeg.so.62 (0x00007f10760bc000)
        libcrypto.so.1.0.0 =&gt; /usr/local/openssl/lib/libcrypto.so.1.0.0 (0x00007f1075ce2000)
        libssl.so.1.0.0 =&gt; /usr/local/openssl/lib/libssl.so.1.0.0 (0x00007f1075a78000)
        libmysqlclient.so.16 =&gt; /usr/lib/libmysqlclient.so.16 (0x00007f107565b000)
        libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007f107543f000)
        libnsl.so.1 =&gt; /lib/libnsl.so.1 (0x00007f1075226000)
        libm.so.6 =&gt; /lib/libm.so.6 (0x00007f1074fa4000)
        libxml2.so.2 =&gt; /usr/lib/libxml2.so.2 (0x00007f1074c53000)
        libc.so.6 =&gt; /lib/libc.so.6 (0x00007f10748f0000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f1077646000)
</code></pre>
","<p>There's actually a set of bug reports, all mentioning that ext/openssl/openssl.c should be patched; adding</p>

<pre><code>OPENSSL_config(NULL);
</code></pre>

<p>before a set of</p>

<pre><code>SSL_library_init();
OpenSSL_add_all_ciphers();
OpenSSL_add_all_digests();
</code></pre>

<p>calls. After that openssl starts to work with any engines from a config pointed OPENSSL_CONF variable with.</p>
","2519","<php><openssl><digital-signature><pkcs#7><gost3410>","1","1","1","2014-04-18 10:39:22","15735355","0","","642653","","2014-04-18 10:39:22","2013-03-22 15:52:27",""
"47970223","How to create a PKCS#7 detached signature with .Net Core?","<p>I want to create PKCS#7 detached signature with .Net Core (2.0).   </p>

<p>I read all answers here more or less relevant to my issue and found <a href=""https://stackoverflow.com/questions/15346009/detached-pkcs7-cms-with-strong-private-key-protection"">this</a> and <a href=""https://stackoverflow.com/questions/41779669/create-a-pkcs7-signed-message-in-c-sharp-with-a-precomputed-signature"">this</a> answers. All other were helpless. The first example do exactly what I need but it relies on .NetFramework.<br>
The second one use Bouncy Castle library and do little different but similar thing. I found <a href=""https://github.com/onovotny/bc-csharp"" rel=""nofollow noreferrer"">Portable.BouncyCastle</a> project worked on  .Net Core. As I can understand it is the only option for me.</p>

<p>This is the code from the first example with some modifications:</p>

<pre><code>    string s = ""data string"";
    byte[] data = Encoding.UTF8.GetBytes(s);        
    X509Certificate2 certificate = null;
    X509Store my = new X509Store(StoreName.My,StoreLocation.CurrentUser);
    my.Open(OpenFlags.ReadOnly);
    certificate = my.Certificates.Find(X509FindType.FindByThumbprint, ""my thumbprint"", false)[0];
    if (certificate == null) throw new Exception(""No certificates found."");

    ContentInfo content = new ContentInfo(new Oid(""1.2.840.113549.1.7.1""),data);
    SignedCms signedCms = new SignedCms(content, true);

    CmsSigner signer = new CmsSigner(certificate);
    signer.DigestAlgorithm = new Oid(""SHA256""); 

    // create the signature
    signedCms.ComputeSignature(signer);
    return signedCms.Encode();
</code></pre>

<p>It works fine in my case.  signedCms.Encode() returns 1835 bytes and this value pass validation.</p>

<p>But if I use BounceCastle I get another result. This is the code:</p>

<pre><code>                X509Certificate2 certificate = null;
        X509Store my = new X509Store(StoreName.My, StoreLocation.CurrentUser);
        my.Open(OpenFlags.ReadOnly);

        certificate = my.Certificates.Find(X509FindType.FindByThumbprint, ""my thumbprint"", false)[0];
        var privKey = DotNetUtilities.GetRsaKeyPair(certificate.GetRSAPrivateKey()).Private;
        var cert = DotNetUtilities.FromX509Certificate(certificate);

        var content = new CmsProcessableByteArray(data);

        var generator = new CmsSignedDataGenerator();

        generator.AddSigner(privKey, cert, CmsSignedGenerator.EncryptionRsa, CmsSignedGenerator.DigestSha256);

        var signedContent = generator.Generate(content, false);
        return signedContent.GetEncoded();
</code></pre>

<p>signedContent.GetEncoded() returns 502 bytes and this result can't be validated. I understand that I'm doing wrong something but I don't know what. </p>

<p>How should I modify the sample with Bouncy Castle that it get me the same result as the code above?</p>
","<p>I found an another <a href=""https://stackoverflow.com/questions/41779669/create-a-pkcs7-signed-message-in-c-sharp-with-a-precomputed-signature"">discussion</a> that gave me a clue. There is a link to a <a href=""https://github.com/jariq/Pkcs7SignatureGenerator/tree/master/src/Pkcs7SignatureGenerator"" rel=""noreferrer"">GitHub repo</a> with an example application. I modified it slightly and now it works as expected. Here is the code:</p>

<pre><code>            X509Certificate2 certificate = null;
        X509Store my = new X509Store(StoreName.My, StoreLocation.CurrentUser);
        my.Open(OpenFlags.ReadOnly);

        certificate = my.Certificates.Find(X509FindType.FindByThumbprint, ""thumbprint"", false)[0];
        var privKey = DotNetUtilities.GetRsaKeyPair(certificate.GetRSAPrivateKey()).Private;
        var cert = DotNetUtilities.FromX509Certificate(certificate);

        var content = new CmsProcessableByteArray(data);

        var generator = new CmsSignedDataGenerator();

        generator.AddSigner(privKey, cert, CmsSignedGenerator.EncryptionRsa, CmsSignedGenerator.DigestSha256);

        var signedContent = generator.Generate(content, false);

        string hashOid = OID.SHA256;

        var si = signedContent.GetSignerInfos();
        var signer = si.GetSigners().Cast&lt;SignerInformation&gt;().First();

        SignerInfo signerInfo = signer.ToSignerInfo();

        Asn1EncodableVector digestAlgorithmsVector = new Asn1EncodableVector();
        digestAlgorithmsVector.Add(
            new AlgorithmIdentifier(
                algorithm: new DerObjectIdentifier(hashOid),
                parameters: DerNull.Instance));

        // Construct SignedData.encapContentInfo
        ContentInfo encapContentInfo = new ContentInfo(
            contentType: new DerObjectIdentifier(OID.PKCS7IdData),
            content: null);

        Asn1EncodableVector certificatesVector = new Asn1EncodableVector();
        certificatesVector.Add(X509CertificateStructure.GetInstance(Asn1Object.FromByteArray(cert.GetEncoded())));

        // Construct SignedData.signerInfos
        Asn1EncodableVector signerInfosVector = new Asn1EncodableVector();
        signerInfosVector.Add(signerInfo.ToAsn1Object());

        // Construct SignedData
        SignedData signedData = new SignedData(
            digestAlgorithms: new DerSet(digestAlgorithmsVector),
            contentInfo: encapContentInfo,
            certificates: new BerSet(certificatesVector),
            crls: null,
            signerInfos: new DerSet(signerInfosVector));

        ContentInfo contentInfo = new ContentInfo(
            contentType: new DerObjectIdentifier(OID.PKCS7IdSignedData),
            content: signedData);

        return contentInfo.GetDerEncoded();
</code></pre>
","2497","<c#><.net-core><bouncycastle><pkcs#7>","3","5","1","2017-12-26 05:08:05","47974075","2","2","","","","2017-12-25 16:11:45",""
"29251895","PDF Signature digest","<p>I have a quick question about calculating the digest of a PDF document to use for a digital signature (somewhat related to one of my earlier questions, I'm trying to figure out why you would need to know a client's certificate to create the correct digest). 
In Adobe's documentation about the PDF format the following is specified:</p>

<blockquote>
  <p>A byte range digest shall be computed over a range of bytes in the file, that shall be indicated by the
  ByteRange entry in the signature dictionary. This range should be the entire file, including the signature
  dictionary but excluding the signature value itself (the Contents entry).</p>
</blockquote>

<p>So at this point things seem fairly simple, just digest everything except the /Contents entry in the /Sig dictionary. The actual data in the /Contents entry is specified as followed:</p>

<blockquote>
  <p>For public-key signatures, Contents should be either a DER-encoded
  PKCS#1 binary data object or a DER-encoded PKCS#7 binary data
  object.</p>
</blockquote>

<p>So still no problems, I can (probably) generate the digest, reserve space for the /Contents entry and attach this PKCS#7 object later on. The confusion starts when I read the following: </p>

<blockquote>
  <p>Revocation information is a signed attribute, which means that the
  signing software must capture the revocation information before signing. A similar requirement applies to the
  chain of certificates. The signing software must capture and validate the certificate's chain before signing.</p>
</blockquote>

<p>So the thing I'm not quite getting: Apparently the /Contents entry (containing the certificate and signed digest) is not digested, yet the chain of certificates is a signed attribute (and thus needs to be digested?).</p>

<p>I would appreciate it if someone could further specify exactly what is digested, and perhaps better explain the signed attributes to me. The main question that I want to answer is: Can I actually create a signable digest without knowing someone's certificate beforehand? (I'm working with a pkcs7 detached signature)</p>
","<h2>In short:</h2>

<blockquote>
  <p>Can I actually create a signable digest without knowing someone's certificate beforehand?</p>
</blockquote>

<p>In case of SubFilter <strong>ETSI.CAdES.detached</strong> or <strong>adbe.pkcs7.detached</strong> you can create the <strong>document digest</strong> <em>without knowing someone's certificate beforehand</em>.</p>

<p>You usually, though, have to know the signer certificate before starting to generate the CMS signature container to embed into the PDF.</p>

<h2>In detail:</h2>

<p>(Beware, the following is somewhat simplified.)</p>

<blockquote>
  <p>I can (probably) generate the digest, reserve space for the /Contents entry and attach this PKCS#7 object later on.</p>
</blockquote>

<p>If you <em>first reserve space</em> and <em>thereafter generate the digest</em>, this indeed is how things are done.</p>

<blockquote>
  <p>The confusion starts when I read the following:</p>
  
  <blockquote>
    <p>Revocation information is a signed attribute, which means that the signing software must capture the revocation information before signing. A similar requirement applies to the chain of certificates. The signing software must capture and validate the certificate's chain before signing.</p>
  </blockquote>
  
  <p>So the thing I'm not quite getting: Apparently the /Contents entry (containing the certificate and signed digest) is not digested, yet the chain of certificates is a signed attribute (and thus needs to be digested?).</p>
  
  <p>I would appreciate it if someone could further specify exactly what is digested, and perhaps better explain the signed attributes to me.</p>
</blockquote>

<p>The main fact one has to be aware of is that in case of PKCS#7/CMS signature containers <strong>signing usually does not merely include <em>one</em> hash calculation but at least <em>two</em>!</strong></p>

<p>The first hash, the document hash, is indeed calculated for <em>the entire file, including the signature dictionary but excluding the signature value itself (the <strong>Contents</strong> entry)</em> (you might want to read <a href=""https://security.stackexchange.com/a/35131/16096"">this answer</a> for more details).</p>

<p><img src=""https://i.stack.imgur.com/DkekJ.png"" alt=""Graphic sketch of hashed byte ranges""></p>

<p>But this is <strong>not</strong> the hash immediately used when applying the signature algorithm.</p>

<p>During the generation of the PKCS#7/CMS signature container (unless in its most primitive form) you create a structure called ""signed attributes"".</p>

<p>You fill this structure with multiple attributes (name-value-pairs), among them the already calculated document hash but also others, e.g. the Adobe-style revocation information you read about.</p>

<p>When you have finished creating that structure, you <em>hash this structure and generate a signature for it</em>.</p>

<p>You then can put together the PKCS#7/CMS signature container using these signed attributes, the signature, and some more information not signed by this signature, e.g. certificates, signature time stamps, ...</p>

<p>For more details concerning the signature container read <a href=""https://stackoverflow.com/a/28429984/1729265"">this answer</a>.</p>

<p>Finally you embed this signature container into the reserved space in the PDF.</p>

<blockquote>
  <p>The main question that I want to answer is: Can I actually create a signable digest without knowing someone's certificate beforehand? (I'm working with a pkcs7 detached signature)</p>
</blockquote>

<p>In case of SubFilter <strong>ETSI.CAdES.detached</strong> or <strong>adbe.pkcs7.detached</strong> you can create the <strong>document digest</strong> <em>without knowing someone's certificate beforehand</em>.</p>

<p>Depending on the CMS signature profile, though, you usually have to know the signer certificate before starting to generate the signature container because many profiles require the presence of a signed attribute referencing the signer certificate.</p>

<h2>Clarifications:</h2>

<p>The OP asked some follow-up questions in a comment:</p>

<blockquote>
  <p>1.: One of the signed attributes is the document hash(without the /contents), so if I understand correctly this is the unsigned hash?</p>
</blockquote>

<p>As the ""signed attributes"" eventually are hashed and signed, that document hash therein is <strong>not immediately, directly</strong> signed <strong>but</strong> it is <strong>indirectly</strong> signed as part of this structure of attributes. So I wouldn't call it unsigned...</p>

<blockquote>
  <ol start=""2"">
  <li>In the end when the user really generates a signature, he signs the hash of the PKCS#7 object?</li>
  </ol>
</blockquote>

<p>No, the hash of the ""Signed attributes"" structure which is only a part of the PKCS#7 object, not all of it. There are multiple parts of the PKCS#7/CMS object which are unsigned.</p>

<blockquote>
  <ol start=""3"">
  <li>Does the /Contents entry still have a PKCS#7 object that's actually readable for us? (To extract certificates etc for verification) </li>
  </ol>
</blockquote>

<p>The <strong>Contents</strong> entry does contain a full-fledged PKCS#7/CMS signature container object as a binary string. Thus, yes, you can read it (by reading the value of that binary string) and (if you have code that knows how to parse such a signature container) extract information from it.</p>

<p>Beware, though, the signature container may not contain all data required for verification: E.g., if you verify using the chain (not shell) validation model, you might have to extract the signing time from the respective PDF signature dictionary entry.</p>

<blockquote>
  <ol start=""4"">
  <li>When verifying a signature, do we simply extract the embedded PKCS#7 object, recalculate the digest, recalculate the digest of the PKCS#7 object and verify this against the signature using the certificate we get from the PKCS#7 object?</li>
  </ol>
</blockquote>

<p>You obviously also have to calculate the digest of the signed PDF byte ranges and compare that value with the signed attribute containing the original document digest.(You might have meant that by <em>recalculate the digest</em>.)</p>

<p>As mentioned in the answer to 3, you might have to retrieve additional information from the PDF for use in the PKCS#7 verification.</p>

<p>Furthermore you say <em>the certificate we get from the PKCS#7 object</em> - please be aware that the PKCS#7/CMS signature container may contain multiple certificates. You have to find the correct one. The CMS SignerInfo SignerIdentifier and the ESS signed attributes shall be used for that.</p>

<p>Furthermore you also have to verify validity and trust of the signer certificate.</p>

<blockquote>
  <ol start=""5"">
  <li>Is there any good documentation on what authenticated attributes there are?</li>
  </ol>
</blockquote>

<p>You can start reading</p>

<ul>
<li>section 11 ""Useful Attributes"" of <a href=""https://tools.ietf.org/html/rfc3852#section-11"" rel=""noreferrer"">RFC 3852</a> or <a href=""https://tools.ietf.org/html/rfc5652#section-11"" rel=""noreferrer"">RFC 5652</a>: basic CMS</li>
<li>section 12.8 of <a href=""http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf"" rel=""noreferrer"">ISO 32000-1</a>: basic PDF</li>
<li>all of <a href=""https://tools.ietf.org/html/rfc5126"" rel=""noreferrer"">RFC 5126</a>: CAdES</li>
<li>ETSI TS 102778, especially <a href=""http://www.etsi.org/deliver/etsi_ts/102700_102799/10277802/01.02.01_60/ts_10277802v010201p.pdf"" rel=""noreferrer"">part 2</a>, <a href=""http://www.etsi.org/deliver/etsi_ts/102700_102799/10277803/01.02.01_60/ts_10277803v010201p.pdf"" rel=""noreferrer"">part 3</a>, and <a href=""http://www.etsi.org/deliver/etsi_ts/102700_102799/10277804/01.01.02_60/ts_10277804v010102p.pdf"" rel=""noreferrer"">part 4</a>: PAdES</li>
</ul>
","2484","<pdf><digital-signature><digest><pkcs#7>","5","10","1","2015-04-08 21:45:36","29253469","1","2","589259","","2015-04-08 21:45:36","2015-03-25 09:31:56",""
"13604650","Java BC1.47: Need to extract signer's X509CertificateObject from a CMSSignedData object","<p>I'm trying to extract the signer's X509CertificateObject from a CMSSignedData object using java Bouncy Castle 1.47.
So far I have only been able to extract an org.bouncycastle.asn1.x509.Certificate object.
How do I get a X509CertificateObject from this?
Thanks a lot!</p>

<pre><code>public static X509CertificateObject extractSignersCert(CMSSignedData cmsSignedData)
    throws Exception
{
    SignerInformationStore signerInfoStore;
    SignerInformation signerInfo;
    Store certStore;
    Collection certCollection;
    X509CertificateHolder x509CertHolder;
    X509Certificate cert;
    X509CertificateObject certObj;
    JcaX509CertificateConverter certConverter;

    signerInfoStore = cmsSignedData.getSignerInfos();
    signerInfo = (SignerInformation) signerInfoStore.getSigners().iterator().next();

    certStore = cmsSignedData.getCertificates();
    certCollection = certStore.getMatches(signerInfo.getSID());
    x509CertHolder = (X509CertificateHolder) certCollection.iterator().next();

    certConverter = new JcaX509CertificateConverter();
    certConverter.setProvider(""BC"");

    cert = certConverter.getCertificate(x509CertHolder);
    certObj = (X509CertificateObject) cert;

    return certObj;
}
</code></pre>
","<p>Finally found a solution based on this <a href=""https://stackoverflow.com/a/8960906/1740926"">post</a>.
The trick is to use a JcaX509CertificateConverter() and feed it with the X509CertificateHolder you can easily get from the CMSSignedData.
Works just fine.</p>
","2475","<java><x509certificate><bouncycastle><pkcs#7>","1","0","2","2013-02-05 15:03:01","13644686","8","0","1740926","","2012-11-30 11:46:04","2012-11-28 12:03:50",""
"13604650","Java BC1.47: Need to extract signer's X509CertificateObject from a CMSSignedData object","<p>I'm trying to extract the signer's X509CertificateObject from a CMSSignedData object using java Bouncy Castle 1.47.
So far I have only been able to extract an org.bouncycastle.asn1.x509.Certificate object.
How do I get a X509CertificateObject from this?
Thanks a lot!</p>

<pre><code>public static X509CertificateObject extractSignersCert(CMSSignedData cmsSignedData)
    throws Exception
{
    SignerInformationStore signerInfoStore;
    SignerInformation signerInfo;
    Store certStore;
    Collection certCollection;
    X509CertificateHolder x509CertHolder;
    X509Certificate cert;
    X509CertificateObject certObj;
    JcaX509CertificateConverter certConverter;

    signerInfoStore = cmsSignedData.getSignerInfos();
    signerInfo = (SignerInformation) signerInfoStore.getSigners().iterator().next();

    certStore = cmsSignedData.getCertificates();
    certCollection = certStore.getMatches(signerInfo.getSID());
    x509CertHolder = (X509CertificateHolder) certCollection.iterator().next();

    certConverter = new JcaX509CertificateConverter();
    certConverter.setProvider(""BC"");

    cert = certConverter.getCertificate(x509CertHolder);
    certObj = (X509CertificateObject) cert;

    return certObj;
}
</code></pre>
","<p>You can use this method.</p>

<pre><code>/**
 * Get all x509 certificates from p7s File(.p7s or .p7b) Base64 format
 * @param p7sFileName
 * @return list of x509 certificates
 */
public static ArrayList&lt;X509Certificate&gt; getCertificates(final String p7sFileName){

    final ArrayList&lt;X509Certificate&gt; certListResult = new ArrayList&lt;X509Certificate&gt;();

    try {

        BufferedReader br = new BufferedReader(new FileReader(p7sFileName));
        StringBuilder str = new StringBuilder();
        br.readLine();
        while(br.ready()){

            String s = br.readLine();
            if(s.startsWith(""-----END PKCS7-----""))
                break;
            else str.append(s);

        }

        byte[] data = Base64.decode(str.toString().getBytes());

        CMSSignedData s = new CMSSignedData(data);
        Store   certStore = s.getCertificates();

        JcaX509CertificateConverter converter = new JcaX509CertificateConverter();

        @SuppressWarnings(""unchecked"")
        ArrayList&lt;X509CertificateHolder&gt; certificateHolders = (ArrayList&lt;X509CertificateHolder&gt;)certStore.getMatches(null); 

        for(X509CertificateHolder holder: certificateHolders){

                X509Certificate cert = converter.getCertificate(holder);
                certListResult.add(cert);

            }

    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (CMSException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (CertificateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    return certListResult;

}
</code></pre>
","2475","<java><x509certificate><bouncycastle><pkcs#7>","1","0","2","2013-02-05 15:03:01","13644686","8","0","1740926","","2012-11-30 11:46:04","2012-11-28 12:03:50",""
"19763645","C# AES PKCS #7 wrong padding bytes?","<p>I have set up a simple symmetric AES-en/decryption in C#, but I'm having problems with the padding. According to <a href=""http://msdn.microsoft.com/en-us/librar/system.security.cryptography.paddingmode.aspx"" rel=""nofollow"">MSDN</a>, the padding bytes for PKCS #7 are supposed to be <code>0x07</code>, but in my case it's just zero-bytes (<code>0x00</code>).</p>

<p><strong>How is this possible?</strong> It almost seems as if this was not correctly implemented in .NET...</p>

<p>Here is my code:</p>

<pre><code>Aes aes = new AesManaged();
aes.Key = new byte[] { /* ...  */ };
aes.IV = new byte[] { /* ... */ };
// Debugging shows:
// aes.Padding = PaddingMode.PKCS7

// the data to encrypt (1 byte only, to demonstrate padding)
byte[] plainData = new byte[1] { 0xFF };
byte[] encData;

// (encrypt)
using (MemoryStream encStream = new MemoryStream())
{
    using (CryptoStream cryptoStream = new CryptoStream(encStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
    {
        cryptoStream.Write(plainData, 0, plainData.Length);
    }
    encData = encStream.ToArray();
}

// (new length is 16 bytes (128 bits), incl. padding)
plainData = new byte[16];

// (decrypt)
using (MemoryStream decrStream = new MemoryStream(encData))
{
    using (CryptoStream cryptoStream = new CryptoStream(decrStream, aes.CreateDecryptor(), CryptoStreamMode.Read))
    {
        cryptoStream.Read(plainData, 0, plainData.Length);
    }
}

// output:
// 16 bytes,
// 1st byte = 0xFF,
// other 15 bytes = 0x00 (instead of 0x07!)
</code></pre>
","<p>The decryptor is correctly removing the padding that was applied by the encryptor, thus the zero bytes in your output are simply the un-touched bytes in the original <code>plainData</code> array. The <code>cryptoStream.Read(...)</code> call returns an integer indicating the number of bytes that were read (<code>1</code> in this case), which you should be using to determine how many bytes in the output array are valid data.</p>

<p>If for whatever reason you are interested in seeing the padding bytes, you can set <code>aes.Padding = PaddingMode.None;</code> <em>after</em> the encryption is performed, but <em>before</em> you create the decryptor. You will then find that <code>cryptoStream.Read(...)</code> returns <code>16</code>, and <code>plainData</code> has <code>0xff</code> as its first byte, followed by 15 bytes of <code>0x0f</code> padding (not sure why your question indicates you were expecting <code>0x07</code> though).</p>
","2458","<c#><aes><padding><pkcs#7>","0","9","2","2013-11-04 08:38:38","19763790","2","","","","","2013-11-04 07:56:58",""
"19763645","C# AES PKCS #7 wrong padding bytes?","<p>I have set up a simple symmetric AES-en/decryption in C#, but I'm having problems with the padding. According to <a href=""http://msdn.microsoft.com/en-us/librar/system.security.cryptography.paddingmode.aspx"" rel=""nofollow"">MSDN</a>, the padding bytes for PKCS #7 are supposed to be <code>0x07</code>, but in my case it's just zero-bytes (<code>0x00</code>).</p>

<p><strong>How is this possible?</strong> It almost seems as if this was not correctly implemented in .NET...</p>

<p>Here is my code:</p>

<pre><code>Aes aes = new AesManaged();
aes.Key = new byte[] { /* ...  */ };
aes.IV = new byte[] { /* ... */ };
// Debugging shows:
// aes.Padding = PaddingMode.PKCS7

// the data to encrypt (1 byte only, to demonstrate padding)
byte[] plainData = new byte[1] { 0xFF };
byte[] encData;

// (encrypt)
using (MemoryStream encStream = new MemoryStream())
{
    using (CryptoStream cryptoStream = new CryptoStream(encStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
    {
        cryptoStream.Write(plainData, 0, plainData.Length);
    }
    encData = encStream.ToArray();
}

// (new length is 16 bytes (128 bits), incl. padding)
plainData = new byte[16];

// (decrypt)
using (MemoryStream decrStream = new MemoryStream(encData))
{
    using (CryptoStream cryptoStream = new CryptoStream(decrStream, aes.CreateDecryptor(), CryptoStreamMode.Read))
    {
        cryptoStream.Read(plainData, 0, plainData.Length);
    }
}

// output:
// 16 bytes,
// 1st byte = 0xFF,
// other 15 bytes = 0x00 (instead of 0x07!)
</code></pre>
","<p>For PKCS7 mode it should be <code>blocksize - contentsize</code>, i.e. 16 - 1 = 15 in your case. Your mistake is that you expect it after decryption but padding happens internally before encryption. There are no guarantees that <code>plainData</code> will contain padded bytes according to mode choosen.</p>
","2458","<c#><aes><padding><pkcs#7>","0","0","2","2013-11-04 08:38:38","19763790","2","","","","","2013-11-04 07:56:58",""
"6561204","How to create an pkcs7 block for key exchange only (bouncy castle)","<p>I am trying to create a file containing a pkcs 7 block. In this container, I need my public key and my signer info (no signed data!!!). I have already tried several alternatives without any luck. This is my code:</p>

<p>First the signature info:</p>

<pre><code> List&lt;X509Certificate&gt; certs = new List&lt;X509Certificate&gt; { cert };
 IX509Store x509Certs = X509StoreFactory.Create(
      ""CERTIFICATE/COLLECTION"",
      new X509CollectionStoreParameters(certs));

 var ias = new IssuerAndSerialNumber(cert.IssuerDN, cert.SerialNumber);
 SignerIdentifier sid = new SignerIdentifier(ias);
 AlgorithmIdentifier algoDigId = new AlgorithmIdentifierCmsSignedGenerator.DigestSha1);
 AlgorithmIdentifier algoCryptId = new AlgorithmIdentifier(CmsSignedGenerator.EncryptionRsa);

 SignerInfo si = new SignerInfo(sid, algoDigId, null, algoCryptId,
                                      new DerOctetString(contentSignature), null);
</code></pre>

<p>the contentSignature byte[] contains a signed digest for some info.</p>

<p>Now, when I try to create the SignedData, everything goes down</p>

<pre><code>  var signedContent = new ContentInfo(CmsObjectIdentifiers.Data, DerNull.Instance);
  CmsSignedData csd = new CmsSignedData(signedContent);
</code></pre>

<p>I am not trying to send info, this is only for key exchange and verification purposes. I believe this is a valid scenario but somehow this does not work.</p>

<p>Thanks for your help.</p>

<p>UPDATE:</p>

<p>more context.</p>

<p>I am trying to sign a JAR from a .Net executable. I have pretty much done the rest of the process but jarsigner creates a pkcs7 file with:</p>

<ul>
<li><p>ContentInfo set to type Data and no content. So far, making new ContentInfo( CmsObjectIdentifiers.Data, null) just throws an exception while adding the content info to the CmsData</p></li>
<li><p>A SignerInfo is added, this SignerInfo includes a signature previously derived from the JAR's content.</p></li>
</ul>
","<p>Here is a simple example of what I think you want to do. NOTE: The code below is for the Java bouncycastle but I think the classes are very similar in the C# version of the library.</p>

<pre><code>import java.io.*;
import java.security.cert.*;
import java.util.ArrayList;
import java.util.List;

import org.bouncycastle.cert.jcajce.JcaCertStore;
import org.bouncycastle.cms.*;

public class PKCS7CertList1
{

    public static byte[] buildCMSCertThingy() throws Exception
    {
        final List&lt;X509Certificate&gt; certs = new ArrayList&lt;X509Certificate&gt;();
        final InputStream certIs = new FileInputStream(""google_com.p7b"");
        final CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        for (Certificate cert : cf.generateCertificates(certIs))
        {
            certs.add((X509Certificate) cert);
        }
        certIs.close();
        System.err.printf(""Number of certs parsed = %d%n"", certs.size());
        final CMSSignedDataGenerator cmsGen = new CMSSignedDataGenerator();
        cmsGen.addCertificates(new JcaCertStore(certs));
        final CMSSignedData sigData = cmsGen.generate(new CMSAbsentContent(), false);
        return sigData.getEncoded();
    }
    public static void main(String[] args) throws Exception
    {   
        FileOutputStream fos = new FileOutputStream(""signed_data.der"");
        fos.write(buildCMSCertThingy());
        fos.close();
    }

}
</code></pre>
","2438","<c#><rsa><bouncycastle><pkcs#7>","1","0","2","2011-08-10 15:06:55","7012920","3","","826598","","2011-07-05 20:31:19","2011-07-03 05:11:56",""
"6561204","How to create an pkcs7 block for key exchange only (bouncy castle)","<p>I am trying to create a file containing a pkcs 7 block. In this container, I need my public key and my signer info (no signed data!!!). I have already tried several alternatives without any luck. This is my code:</p>

<p>First the signature info:</p>

<pre><code> List&lt;X509Certificate&gt; certs = new List&lt;X509Certificate&gt; { cert };
 IX509Store x509Certs = X509StoreFactory.Create(
      ""CERTIFICATE/COLLECTION"",
      new X509CollectionStoreParameters(certs));

 var ias = new IssuerAndSerialNumber(cert.IssuerDN, cert.SerialNumber);
 SignerIdentifier sid = new SignerIdentifier(ias);
 AlgorithmIdentifier algoDigId = new AlgorithmIdentifierCmsSignedGenerator.DigestSha1);
 AlgorithmIdentifier algoCryptId = new AlgorithmIdentifier(CmsSignedGenerator.EncryptionRsa);

 SignerInfo si = new SignerInfo(sid, algoDigId, null, algoCryptId,
                                      new DerOctetString(contentSignature), null);
</code></pre>

<p>the contentSignature byte[] contains a signed digest for some info.</p>

<p>Now, when I try to create the SignedData, everything goes down</p>

<pre><code>  var signedContent = new ContentInfo(CmsObjectIdentifiers.Data, DerNull.Instance);
  CmsSignedData csd = new CmsSignedData(signedContent);
</code></pre>

<p>I am not trying to send info, this is only for key exchange and verification purposes. I believe this is a valid scenario but somehow this does not work.</p>

<p>Thanks for your help.</p>

<p>UPDATE:</p>

<p>more context.</p>

<p>I am trying to sign a JAR from a .Net executable. I have pretty much done the rest of the process but jarsigner creates a pkcs7 file with:</p>

<ul>
<li><p>ContentInfo set to type Data and no content. So far, making new ContentInfo( CmsObjectIdentifiers.Data, null) just throws an exception while adding the content info to the CmsData</p></li>
<li><p>A SignerInfo is added, this SignerInfo includes a signature previously derived from the JAR's content.</p></li>
</ul>
","<p>As this question is specifically related to signing an APK / JAR file, I will answer in that context.</p>

<p>Assuming that:</p>

<p>You have performed all the following setup steps:</p>

<ol>
<li>Generated a valid MANIFEST.MF</li>
<li>Generated a valid CERT.SF</li>
<li>Have a valid PFX file loaded into an X509Certificate2 variable named ""cert""</li>
<li>Have the binary contents of the CERT.SF file in a byte array named ""manifestSFBytes""</li>
</ol>

<p>The following code will generate a valid detached pkcs7 signature which is effectively your CERT.RSA content:</p>

<pre><code>string OID_DATA = ""1.2.840.113549.1.7.1"";

// setup the data to sign
ContentInfo content = new ContentInfo( new Oid( OID_DATA ), manifestSFBytes );
SignedCms signedCms = new SignedCms( content, true );
CmsSigner signer = new CmsSigner( SubjectIdentifierType.IssuerAndSerialNumber, cert );

// create the signature
signedCms.ComputeSignature( signer );
byte[] data = signedCms.Encode();
</code></pre>

<p>This code relies on the System.Security.Cryptography.Pkcs namespace and does not require BouncyCastle.</p>

<p>What is going on here is that the raw content (signature file binary data) is hashed and signed in one go by the ComputeSignature() call.</p>

<p>Therefore no ""null ContentInfo"" tricks are necessary i.e. the ContentInfo contains the raw data to be signed and hashed unlike the Java implementation which signs and hashes the content prior to PKCS7 generation.</p>

<p>HTH</p>

<p>-(e)</p>
","2438","<c#><rsa><bouncycastle><pkcs#7>","1","1","2","2011-08-10 15:06:55","7012920","3","","826598","","2011-07-05 20:31:19","2011-07-03 05:11:56",""
"11591089","Openssl PKCS#5/PKCS#7 padding","<p>I was wondering how openssl handles a message that is dividable by 8 bytes when using AES-128-CBC. How can openssl detect that there is no padding (PKCS#5/PKCS#7) to be removed? Especially when the message ends in a character with an ASCII code less than or equal to 8.</p>

<p>I hope my question is clear.
Thanks</p>
","<p>Well the answer is that padding is always added, even if the data can be divided by the block size. Thus a 8 byte string will be padded with 8 bytes (with ASCII code 8).</p>
","2437","<openssl><padding><pkcs#7><pkcs#5>","2","3","1","2014-01-04 18:25:57","11725687","0","1","759019","","2012-07-21 09:45:01","2012-07-21 09:41:20",""
"21555926","How to use openssl with a hardware encryption chip?","<p>I have a hardware that I use to generate RSA keys and signatures. I need two things:</p>

<p>1) Generate a certificate request. With the hardware I can get the public key for the certificate and do the signing part. I need the code to do the certificate generation, i.e., do the ASN.1/DER/PEM stuff.</p>

<p>2) Sign data using S/MIME. Again, I will use the hardware to do the signing part, but I need the code to do the format part: PKCS#7 to envelop both a signature and a x509 certificate resulting from the previous task.</p>

<p>So I could use openssl both to generate the CSR and the S/MIME formats, but openssl requires for such tasks a private key to sign, and as I said the signing I do it via hardware. I know there is a mechanism called ""engines"" to plug hardware functions to openssl, but it uses dynamic libraries, which are not supported on my platform (early uClinux for ARM).</p>

<p>So the question is: is there any other way I could force openssl to take an extern public key, and more importantly, to delegate the signing to my hardware? Otherwise, would you recommend another C/C++ library I could use to do this? I really don't need a cryptographic library, it would suffice with a library that knows how to generate those formats (certificate requests and S/MIME).</p>
","<p>Engines are still your way to go, as they are the only way to offload cryptographic tasks using OpenSSL away from the library itself. As far as I understand you, you can build anything but it has to be statically linked into OpenSSL because you cannot load shared libraries (or build them?). I don't actually know uClinux, so bear with me here.</p>

<p>From what I remember, loading shared library is actually done through an engine called <code>dynamic</code> and that is a special engine to support such loading. That means OpenSSL's default assumption is that you will link during compile time and the engine can be considered readily available inside OpenSSL.</p>

<p>So what you want to do is create an engine that is capable of performing crypto on existing keys and build it together <em>with</em> OpenSSL. As an example, try to build OpenSSL natively (without modification) and run <code>openssl engine</code>. It will readily show you all builtin engines (one of which is <code>dynamic</code> but there are others such as <code>chil</code> for nCipher HSMs.</p>

<p>I had a similar problem about two years ago (though I already had a working engine) where I first needed to create a CSR w/ private key and then do crypto with that (or a different) private key (actually PKCS#7 as well). My solution was to use the command line tools to generate the key and CSR and only use OpenSSL for the most important cryptographic operations, i.e. signing and decrypting (I actually only needed the RSA sign and dec functions).</p>

<p>OpenSSL is a horribly documented project and I had to read a lot of its source code to get thinks working correctly. To get your engine up and running, I suggest you read some source code of engines (among others, I worked with <code>e_capi.c</code> which I found fairly easy to understand). For the actual engine usage, you might find some of my <a href=""https://github.com/Javex/sscep/blob/develop/engine.c"" rel=""nofollow"">sscep</a> source code helpful.</p>

<p>The very nice thing about engines: Once they are initialized, they operate transparently which means you initialize an engine, load a key from it and then you are set: Passing this key to OpenSSLs crypto functions is no different than using a native key.</p>
","2410","<c++><encryption><openssl><certificate><pkcs#7>","0","3","1","2014-09-05 16:31:12","21566690","0","1","","","","2014-02-04 15:02:08",""
"22470156","Adding external PKCS1 byte array and Certificate to CMS container with Java","<p>We have client applications (Applets and Silverlight) that create a PKCS1 v2.1 digital signature. The digital signature is created as PKCS1 since the original content is not downloaded to the client, only the contents' hash is sent to the client to conserve bandwidth.</p>

<p>We are attempting to create a PKCS7/CMS container server side, <a href=""https://stackoverflow.com/questions/10424968/add-signed-authenticated-attributes-to-cms-signature-using-bouncycastle"">based on the information from this post</a>:</p>

<ol>
<li>Reading certificate and loading as X509Certificate type</li>
<li>Reading PKCS1 signature as base64 and loading as byte array</li>
<li>Instantiating new ASN1ObjectIdentifier and setting PKCS1 OID (1.2.840.113549.1.1)</li>
<li>Creating new CMSTypedData CMSProcessableByteArray, using asn1 object and signare byte[] as parameters</li>
<li>Create new CMSSignedGenerator and add certificates</li>
<li>Create new CMSSignedData as detached signature using CMSTypedData type</li>
</ol>

<p>However, when getting to steps 5 and 6 things break, as the BC CMSSignedGenerator and CMSSignedData classes do not support adding signers without the private key:</p>

<p>CMS creation:</p>

<pre><code>    // Add BC to environment
    Security.addProvider(new BouncyCastleProvider());

    // Read certificate and convert to X509Certificate
    CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
    Path certPath = Paths.get(""C:\\MyCertificate.cer"");
    byte[] certData = Files.readAllBytes(certPath);
    InputStream in = new ByteArrayInputStream(certData);
    X509Certificate cert = (X509Certificate)certFactory.generateCertificate(in);

    // Add signer certificates to List and add them to store
    List&lt;X509Certificate&gt; certList = new ArrayList&lt;X509Certificate&gt;();
    certList.add(cert);
    Store certs = new JcaCertStore(certList);

    // Get signature in Base64, decode and convert to byte array
    // Signature signature = Signature.getInstance(""SHA1WithRSA"", ""BC"");
    String signatureBase64 = ""gjTbsD0vSOi6nMlRVbpTLRQ5j+g2h8iEH1DgQx93PDBuwzWT47urKxMAS+75dAhQrkreLt9TGZaDN85e5xEpIF12mK1G+AgCNc370I1bjxOvUU67IVxHkZ+IX8kzSiD2uNuQtk3IrwUqyL30TIo+LDAXmY1AQVZwXAaOYG4bXxI="";
    BASE64Decoder decoder = new BASE64Decoder();
    byte[] signatureByte = decoder.decodeBuffer(signatureBase64);

    // Instantiate new ANS1ObjectIdentifier to identify PKCS1 signature
    ASN1ObjectIdentifier asn1OidPkcs1 = new ASN1ObjectIdentifier(""1.2.840.113549.1.1"");

    // Table generator
    /*AttributeTable attrT = new AttributeTable();
    SimpleAttributeTableGenerator sAttrTGen = new SimpleAttributeTableGenerator();*/

    // Instantiate new CMSProcessable object
    CMSTypedData msg = new CMSProcessableByteArray(asn1OidPkcs1, signatureByte);

    // Instantiate new CMSSignedDataGenerator object
    CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

    // ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").s
    gen.addCertificates(certs);
    CMSSignedData sigData = gen.generate(msg, false);


    // BASE64Encoder encoder = new BASE64Encoder();
    new File(""C:\\MyCMS.p7s"");
    FileOutputStream fileOuputStream = new FileOutputStream(""C:\\Users\\gregwerner\\Documents\\Archivos\\miFirma.p7s""); 
    fileOuputStream.write(sigData.getEncoded());
    fileOuputStream.flush();
    fileOuputStream.close();

}
</code></pre>

<p>Any ideas on how to complete CMS container? Perhaps using AttributeTable to add muliple OID's for time stamps, etc., but that doesn't seem to work either.</p>
","<p>I found the answer after looking at this reference project <a href=""https://code.google.com/p/j4ops/"" rel=""nofollow"">https://code.google.com/p/j4ops/</a>. This guide was also a big help although it deals specifically with PDFs using iText which use BC from crypto operations: <a href=""http://itextpdf.com/book/digitalsignatures20130304.pdf"" rel=""nofollow"">http://itextpdf.com/book/digitalsignatures20130304.pdf</a>. The trick is to delegate the signing operation to an external provider (PKCS11, PKCS12, etc) by implementing a Signer interface that uses a sign(byte[] toEncrypt) method, for example. This way, the provider can be set and then just call the sign method and leave the implementation details on how to sign to the provider itself.</p>

<p>Bouncy Castle uses a CMSSignedDataGenerator class with a SignerInf internal class to build the CMS container and the signer information, respectively. So the trick is to build a SignerInf object that doesn't need the private key, as sign() operation should be delegated to the provider. The private key may not even be available particularly when using smart cards. Additionally, the information that needs to be added as signed attributes and/or unsigned attributes needs to be considered when signing the hash and when building the CMS container. So these are the basic steps to solve the problem:</p>

<pre><code>// Build the items to encrypt, objects for method parameters would be obtained previously.
byte[] toEncrypt = externalSignerInfoGenerator.getCmsBytesToSign(hash, 
            signingTime, 
            PKCSObjectIdentifiers.data, 
            x509Cert, 
            timeStampToken, 
            ocsp);
// The externalSignerInfoGenerator.getCmsBytesToSign is a method from a re implemention of the 
// SignerInf inner class from CMSSignedDataGenerator and is used to get a byte array from an 
// org.bouncycastle.asn1.ASN1EncodableVector. To build the vector one should add attributes to
// their corresponding OID's using the org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers interface,
// for example:
ASN1EncodableVector signedAttrVector = buildSignedAttributes (hash, signingTime, contentType,
x509Cert, ocspResp);
// This would call the buildSignedAttributes method to build the signed attributes vector
ASN1EncodableVector signedAttrVector = new ASN1EncodableVector();
// Add CMS attributes
signedAttrVector.add (new Attribute(CMSAttributes.contentType, new DERSet (contentType)));
signedAttrVector.add (new Attribute (CMSAttributes.signingTime, new DERSet(new Time (signingTime))));
signedAttrVector.add(new Attribute(CMSAttributes.messageDigest, new DERSet(new DEROctetString(hash))));
// Not all attributes are considered in BC's CMSAttributes interface, therefore one would have to add 
// an additional step:
signedAttrVector.add(buildOcspResponseAttribute(ocspResp));
// This method would call buildOcspResponseAttribute to add the object as a PKCSObjectIdentifier
protected Attribute buildOcspResponseAttribute (byte[] ocspResp) throws IOException, CMSException {
    return new Attribute (PKCSObjectIdentifiers.id_aa_ets_revocationRefs, 
    new DERSet(DERUtil.readDERObject(ocspResp)));
}  

// Call sign method from provider, such as PKCS11, PKCS12, etc.
byte [] signature = getSignProvider().sign(toEncrypt);
// Now build standard org.bouncycastle.cms.SignerInfoGenerator with hash, signed data 
// and certificate to add to CMS, create attached or detached signature
// create signed envelope
CMSSignedData envdata = externalCMSSignedDataGenerator.generate(false);                
byte[] enveloped = envdata.getEncoded();
</code></pre>
","2397","<java><digital-signature><bouncycastle><pkcs#7>","4","4","1","2016-08-25 23:30:01","","2","1","-1","","2017-05-23 10:29:14","2014-03-18 04:04:14",""
"32083044","Warning: openssl_pkcs7_sign(): error getting private key using WAMP","<p>I am trying to sign PDF using TCPDF, but I have got this error: </p>

<pre><code>Warning: openssl_pkcs7_sign(): error getting private key in C:\wamp\www\tcpdf\tcpdf.php on line 7594.   
</code></pre>

<p>My PHP version is 5.5.12 and TCPDF 6.2.11. Windows 7. </p>

<p>Other examples run well but this fails. I have tried:</p>

<pre><code>'file://'.( dirname(FILE)).'./path/to/file' and again $certificate = 'file://'.realpath('../tcpdf.crt'); 
</code></pre>

<p>but does not work for me.</p>
","<p>I think <code>file://</code> is not correct. You fetch die real path with <code>dirname(__FILE__)</code> that should be enough. So i prefer:</p>

<pre><code>$certificate = __DIR__'/../tcpdf.crt';
</code></pre>

<p><code>__DIR__</code> or <code>dirname(FILE)</code> is the path to the file you've in. To you can go back with <code>/../../</code> to your file depends on your folder location for your certificate files. </p>
","2347","<php><openssl><tcpdf><pkcs#7>","4","0","2","2016-11-12 21:29:21","","0","1","5008845","","2015-08-19 00:01:57","2015-08-18 21:39:58",""
"32083044","Warning: openssl_pkcs7_sign(): error getting private key using WAMP","<p>I am trying to sign PDF using TCPDF, but I have got this error: </p>

<pre><code>Warning: openssl_pkcs7_sign(): error getting private key in C:\wamp\www\tcpdf\tcpdf.php on line 7594.   
</code></pre>

<p>My PHP version is 5.5.12 and TCPDF 6.2.11. Windows 7. </p>

<p>Other examples run well but this fails. I have tried:</p>

<pre><code>'file://'.( dirname(FILE)).'./path/to/file' and again $certificate = 'file://'.realpath('../tcpdf.crt'); 
</code></pre>

<p>but does not work for me.</p>
","<p>You need the 'file://' prefix and the realpath to file:</p>

<pre><code>//in your case
$certificate = 'file://'.realpath('../tcpdf.crt');
// OR for other cases
$certificate = 'file://'.realpath('/tcpdf.crt');
// OR
$certificate = 'file://'.realpath('C:/tcpdf.crt');
</code></pre>
","2347","<php><openssl><tcpdf><pkcs#7>","4","0","2","2016-11-12 21:29:21","","0","1","5008845","","2015-08-19 00:01:57","2015-08-18 21:39:58",""
"23906821","Sign Xml with digital certificate in format of PKCS#7 in DER (ITU-T Rec. X.690)","<p>I have a <code>.xml</code> file that has to be signed with <code>digital certificate</code> in format of <code>PKCS#7 version 1.5 (RFC 2315)</code> and <code>DER (ITU-T Recommendation X.690</code></p>

<p>That <code>.xml</code> will be send to a govt. <code>WebService</code> that only accept the format I mentioned upwards.</p>

<p>What I'm able to do - thanks to <a href=""http://rooseboom.net/?p=23"" rel=""nofollow"">this website</a> is digitaly sign <code>.xml</code> with the <code>.pfx</code> file that I generated with <code>Certificate Export Wizard</code> explained below. The class that I'm using to sign is down on mentioned website or <a href=""https://www.dropbox.com/sh/5phooctpyc6b0gw/b8hIFORKFJ/XmlDsig.cs"" rel=""nofollow"">here</a>.</p>

<p>From what I tried to understand so far I will need to sign the <code>.xml</code> with <code>.pfx</code> file according to <code>X.690</code> standards but I'm only able to access this namespace:</p>

<pre><code>using System.Security.Cryptography.X509Certificates;
</code></pre>

<p>which is obviously for X.509 format.</p>

<p>Note: </p>

<p>There are several things I'm confused about - to export the certificate into <code>.pfx</code> I'm using <code>Internet Explorer - Certificate Export Wizard</code> from there I'm able to:</p>

<p>Yes - export private keys - then it will be generated in <code>PKCS#12</code> but <code>.pfx</code></p>

<p>No - do not export private keys - Certificate according to standards <code>Cryptographic Message Syntax Standard - PKCS#7</code> that I guess I need but I would receive <code>.p7b</code> file</p>

<p>I must say that I am a newbie in certificates and digital signatures so I'm not even sure if I'm correctly exporting the certificat and the second thing is how I can sign according to <code>X.690</code> standards. </p>

<p>May I know how to sign according to X.690 format please?</p>

<p>Thank you everyone for your time and replies.</p>

<p>My code is following:</p>

<pre><code>bool res = false;
try
{
    byte[] certBytes = System.IO.File.ReadAllBytes(pvkPath);
    X509Certificate2 cert = new X509Certificate2(certBytes, certPass);
    XmlDocument doc = new XmlDocument();

    doc.Load(xmlPath);

    // sign the document with the private key of the certificate
    XmlDsig.SignXml(doc, cert);

    // save the document
    doc.Save(xmlSavePath);

    // verify that the document has a signature
    bool hasSignature = XmlDsig.HasSignatureElement(doc);
    return res = true;
}
catch (Exception)
{ return res; }
</code></pre>
","<p>foDigital signature in PKCS#7/CMS format is blob that contains your XML data + signer's x509 public key certificate (.cer file) + Digital signature. The entire blob is encoded in ASN 1.0 format(X690). There may be variations in the blob due to the absence of original data or the signer certificate, This variation is called detached signatures.</p>

<p>Digital signature is generated when you sign your xml file with the signer's private key. This signature can be verified when you send your XML file + signer's public key (as X509 .cer file)+ digital signature to the party who are interested in verifying it.</p>

<p>PFX/p12 is a container that contains both the signer's private key and public key. You get this key pair from either your government or your government approved key custodians. You will then use this PFX to perform digital signature.</p>

<p>PKCS#7 is supported by <a href=""http://msdn.microsoft.com/en-gb/library/windows/desktop/aa380252%28v=vs.85%29.aspx#message_functions"" rel=""nofollow"">cryptoAPI</a>.</p>

<p>The above are the basics. This should allow you make your queries more clearly.</p>
","2330","<c#><digital-signature><pkcs#7><pfx>","1","1","1","2014-05-29 15:36:45","23928891","0","","2538352","","2014-05-29 15:36:45","2014-05-28 08:46:46",""
"4689726","Creating and Verifying PKCS #7 signatures in VB.net","<p>Im trying to figure out how to generate and verify PKCS #7 signatures in VB.net. These signatures need to be stored in a separate file to the data they are verifying (eg test.dat and test.dat.sig).  Ive found code to generate signatures in another question, but cant figure out how to verify them</p>

<pre><code>Public Sub SignFile(ByVal theFilename As String, ByVal theCertFile As String, ByVal thePassword As String, ByVal theDestination As String)
    Dim aCertificate = New X509Certificates.X509Certificate2(theCertFile, thePassword)
    Dim aByteArray = IO.File.ReadAllBytes(theFilename)
    Dim anOid = New System.Security.Cryptography.Oid(""1.2.840.113549.1.7.2"")
    Dim aContentInfo = New Pkcs.ContentInfo(anOid, aByteArray)
    Dim aSignedCms = New Pkcs.SignedCms(aContentInfo, True)
    Dim aCmsSigner = New Pkcs.CmsSigner(Pkcs.SubjectIdentifierType.IssuerAndSerialNumber, aCertificate)

    aSignedCms.ComputeSignature(aCmsSigner)
    Dim aSignature = Convert.ToBase64String(aSignedCms.Encode())
    IO.File.WriteAllText(theDestination, aSignature)
End Sub
</code></pre>

<p>Thanks</p>
","<p>The following might help you for Verifying CMS/PKCS#7 Signatures</p>

<blockquote>
  <p><a href=""http://www.jensign.com/JavaScience/verify/index.html"" rel=""nofollow"">http://www.jensign.com/JavaScience/verify/index.html</a></p>
</blockquote>
","2324","<vb.net><pkcs#7>","0","0","1","2011-03-21 18:02:30","","0","","","","","2011-01-14 09:44:25",""
"8630300","How to print a BIO object in opensl or print time from ASN1_TYPE object","<p>How do I print the value stored in BIO object ""time"". Basically I need to extract signed time.</p>

<pre><code>ASN1_TYPE *asn1obj;         
if (!(asn1obj = PKCS7_get_signed_attribute(si, NID_pkcs9_signingTime))) {
    NSLog(@""Failed to retireve the signing time"");
}else{
    if (asn1obj-&gt;type == V_ASN1_UTCTIME) {
        BIO * time = data=BIO_new(BIO_s_bio());
        i = ASN1_UTCTIME_print(time,asn1obj-&gt;value.utctime);
        NSLog(@""return value from ASN1_UTCTIME_print %d "",i);                   
    }
}
</code></pre>

<p>Thanks</p>
","<p>This is how it get working</p>

<pre><code>if (asn1obj-&gt;type == V_ASN1_UTCTIME) {

    NSLog(@""---------------------------&gt;Retireve the signing time"");
    BIO * time = data=BIO_new(BIO_s_bio());                  

    BIO_printf(bio_out,""\n"");

    i = ASN1_UTCTIME_print(bio_out,asn1obj-&gt;value.utctime);   //used to display in console
    i = ASN1_UTCTIME_print(time,asn1obj-&gt;value.utctime);      //used to hold in BIO object

    BIO_printf(bio_out,""\n"");

    BIO *mem = BIO_new(BIO_s_mem());              
    //pass this mem BIO to hold the data
    i = ASN1_UTCTIME_print(mem,asn1obj-&gt;value.utctime);       //converting asn1 to memory BIO

    //Extract the BUF_MEM structure from a memory BIO and then free up the BIO:

    BUF_MEM *bptr;
    BIO_get_mem_ptr(mem, &amp;bptr);                  //converting memory BIO to BUF_MEM
    BIO_set_close(mem, BIO_NOCLOSE); /* So BIO_free() leaves BUF_MEM alone */

    char *buff = (char *)malloc(bptr-&gt;length);        //converting BUF_MEM  to Char * 
    memcpy(buff, bptr-&gt;data, bptr-&gt;length-1);         //to be used later
    buff[bptr-&gt;length-1] = 0;

    NSLog(@""---------------------------&gt;%s"",buff);        // this is my 
                                  // OUTPUT : Apr  5 14:30:53 2012 GM

    NSLog(@""---------------------------&gt;End"");
    BIO_free_all(mem);              
}
</code></pre>

<p>Hope this helps :)</p>
","2216","<openssl><asn.1><pkcs#7>","2","3","1","2012-04-05 15:12:33","10031257","0","1","199122","","2011-12-25 16:02:06","2011-12-25 15:48:19",""
"23143485","C library for CMS/X.509 manipulation","<p>Some context: I have a PKCS #11-compliant cryptographic engine. This engine will be used to handle signed/enveloped data, i.e. verify the data's ECDSA/SHA1 signature, unwrap the symmetric key with RSAES-OAEP, and decrypt this data. This means the symmetric key will be wrapped with my engine's public key: <strike>hence I'd like the certificate for this public key to actually read ""Subject Public Key Algorithm: RSAES-OAEP""</strike>.</p>

<p>I'm looking for a C library which will let me manipulate objects comforming to the Cryptographic Message Syntax (CMS) and X.509 standards in the following way:</p>

<ol>
<li><p>create a X.509 Certificate Signing Request (CSR), <strike>setting the Subject Public Key Algorithm to RSAES-OAEP</strike></p>

<ul>
<li><p><strong>let me handle the signing part:</strong> my private key is only accessible via a PKCS #11 handle, so I need the library to give me the bytes to sign, and then <strong>let me set the CSR's ProofOfPossession field</strong> with what my crypto engine computed</p></li>
<li><p>export the complete CSR to something (DER or PEM)</p></li>
</ul></li>
<li><p>create CMS structures to hold something like SignedData( EnvelopedData( stuff )). The library could handle the actual encryption/key wrapping/signature, or it could let some other software engine do it and just allow me to set the octet strings</p></li>
<li><p>let me easily parse back the message and recover those octet strings</p>

<ul>
<li>meaning I want to open a DER/PEM file which contains this CMS message, and get the bytes for the signature, the wrapped key and the encrypted stuff, so that I can feed them to my PKCS #11 interface</li>
</ul></li>
</ol>

<p>Before anyone suggests OpenSSL's libcrypto, I've looked at it (looked as in, ""<em>spent the last week trying to understand how the structures work, how the ASN.1 representation works, how I can recover the bytes I'm interested in from OpenSSL's structures...</em>""), and I have some issues with it (as of 1.0.1f):</p>

<ul>
<li><p><strike>(cf 1.) I cannot set the Subject Public Key Algorithm to RSAE-OAEP. Starting from <code>demos/x509/mkreq.c</code>, and going all the way back to the deep reaches of <code>x509t.h</code>'s weird <code>#define IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname)</code> macros, I think I can affirm that <code>X509_REQ_set_pubkey()</code> cannot handle OAEP.</strike></p></li>
<li><p>(cf 2.) Neither can the CMS part of the crypto lib, for that matter. <code>cms_RecipientInfo_ktri_encrypt()</code> calls <code>EVP_PKEY_CTX_ctrl()</code>, which I guess resolves to <code>crypto/rsa/rsa_pmeth.c:pkey_rsa_ctrl()</code>: when p2 is <code>EVP_PKEY_CTRL_CMS_ENCRYPT</code>, <code>p2</code> is not parsed, so RSA padding is not set (if it turns out I'm wrong and I just cannot read code correctly, please tell me).</p></li>
</ul>

<p>So while I'm glad <a href=""https://stackoverflow.com/questions/950662/should-one-use-cryptographic-message-syntax-cms-for-this-task"">this guy</a> managed to make it ""work like a charm"", I cannot share his enthusiasm.</p>

<p>I guess for 2. I <em>could</em> use OpenSSL to create CMS blank structures, compute the future EnvelopedData content (ie stuff encrypted with a symmetric key + symmetric key wrapped with RSA OAEP), and stuff this content into the structures, bypassing <code>CMS_encrypt()</code> completely, before encapsulating into a SignedData (I'm assuming <code>CMS_sign()</code> will handle ECDSA/SHA1). As long as I don't want to use fancy parameters for OAEP (although <a href=""https://stackoverflow.com/questions/22373305/rsa-public-key-encryption-openssl"">this other guy</a> managed to patch the lib to use OAEP with SHA-256).</p>

<p>But this might end up requiring a tad too much fiddling with OpenSSL's ASN.1 API. Hence my interrogation: does anyone know of a C library to <strong>build CMS structures</strong> and <strong>feed them the octet strings</strong> computed by some other engines? <strike>Also how to build certificates which read ""THIS KEY IS MEANT TO BE USED WITH RSAES-OAEP"".</strike></p>

<p>I've looked at libksba and cryptlib and while I guess they could work, I cannot see how to use them yet (might have something to do with my eyes bleeding from staring at OpenSSL's code so much - I do not mean to say that OpenSSL's code is bad or anything, just that I've been looking at it <em>hard</em>, and the doc is slightly lacking).</p>

<p>Actually, I guess, I <em>could</em> drop the C requirement (mainly there because communicating with the crypto engine is done in PKCS #11/C). Here's what the library should be able to do:</p>

<ol>
<li><p><strong>build a CSR</strong></p>

<ol>
<li><p><strike>... featuring ""RSAES-OAEP"" as Subject Public Key Algorithm</strike></p></li>
<li><p>give me the bytes to sign for the Proof-of-Possession part</p></li>
<li><p>take the signature and output a complete X.509 CSR</p></li>
</ol></li>
<li><p><strong>parse a CMS structure</strong></p>

<ol>
<li><p>(SignedData) give me the bytes corresponding to the signedInfo->signature and encapsulatedContentInfo fields so that I can verify them with some other engine</p></li>
<li><p>(EnvelopedData) give me the bytes corresponding to the keyTransRecipientInfo->encryptedKey and encryptedContentInfo->encryptedContent fields so that I can unwrap/decrypt with some other engine</p></li>
</ol></li>
<li><p><strong>build a CMS structure</strong>, either...</p>

<ol>
<li><p>letting some external engine set the fields mentioned above, and letting me specify the algorithms</p></li>
<li><p>actually implementing the algorithms, and building the CMS from just the data (... with RSAES-OAEP for key wrapping)</p></li>
</ol></li>
</ol>

<p>Right now I'm going with a ""all-OpenSSL"" approach, because I feel like I'm in too deep and should not start wandering somewhere else. If anybody has a better idea, I am all ears.</p>

<p><strike>As for setting that subject public key algorithm... Well, either I'll just leave regular RSA and have my application ""know"" that wrapping is RSAES-OAEP, or... I don't know.</strike> And as for signing the request... is POP all that useful anyway?
(This is not a serious question)</p>

<p><strong>NB:</strong> edited to remove the whole ""I want my certificate to read OAEP"", since I just found out about <a href=""https://tools.ietf.org/html/rfc5756"" rel=""nofollow noreferrer"">RFC 5756</a> (also found an <a href=""https://groups.google.com/forum/#!topic/sci.crypt/lGchnopQKtY"" rel=""nofollow noreferrer"">interesting discussion</a> from 2006 when this RFC was not out yet).</p>
","<p>Here's what I managed to get working so far.</p>

<h2>1. Building a CSR, signing it with some other engine</h2>

<p>I mostly followed <code>demos/x509/mqreq.c</code>, with some twists.</p>

<p>(NB: error checking, fancy modulus length/label/subject DN generation/handling has been left out for brevity and focus on actual flow).</p>

<pre><code>unsigned char* mod = NULL;
unsigned char* exp = NULL;
size_t mod_l = 0;
size_t exp_l = 0;

P11_handle h_key = P11_gen_rsa(&amp;mod, &amp;mod_l, &amp;exp, &amp;exp_l);

RSA* rsa = RSA_new();

rsa-&gt;n = BN_bin2bn(rsa_mod, rsa_mod_l, NULL);
rsa-&gt;e = BN_bin2bn(rsa_exp, rsa_exp_l, NULL);

EVP_PKEY* pkey = EVP_PKEY_new();

EVP_PKEY_assign_RSA(pkey, rsa);

X509_REQ* csr = X509_REQ_new();
X509_REQ_set_pubkey(csr, pkey);

/* Boring X509_NAME/X509_EXTENSION stuff */

X509_REQ_INFO* csr_req = csr-&gt;req_info;

unsigned char* pop_in = NULL;
size_t pop_in_l = ASN1_item_i2d((void*)csr_req, &amp;pop_in,
                                ASN1_ITEM_rptr(X509_REQ_INFO));

unsigned char* sig = NULL;
size_t sig_l = 0;

P11_make_pop(SIGN_RSA_PKCS, DIGEST_SHA256,
             pop_in, pop_in_l, &amp;sig, &amp;sig_l,
             h_key);

/* Add signature to CSR (heavily inspired from ASN1_item_sign_ctx())
 * (please don't ask about the flags) */

if (csr-&gt;signature-&gt;data != NULL) OPENSSL_free(csr-&gt;signature-&gt;data);
csr-&gt;signature-&gt;data = sig;
csr-&gt;signature-&gt;length = sig_l;
csr-&gt;signature-&gt;flags&amp;= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);
csr-&gt;signature-&gt;flags|= ASN1_STRING_FLAG_BITS_LEFT;

/* Add signature algorithm information to CSR */

int sig_algo_nid = 0;
OBJ_find_sigid_by_algs(&amp;sig_algo_nid,
                       EVP_MD_nid(EVP_sha256()), EVP_PKEY_RSA);

X509_ALGOR_set0(csr-&gt;sig_alg, OBJ_nid2obj(sig_algo_nid),
                V_ASN1_NULL, NULL));
</code></pre>

<p>After that, the X509_REQ structure is good for PEM export. <code>openssl req -verify</code> seems to validate the process, so as far as I'm concerned this works.</p>

<h2>2. Building nested CMS structures (as in SignedData(EnvelopedData(Data)))</h2>

<p>Finally got it, using 1.0.2 (any previous version would have needed patching or ASN.1-level parsing). Many thanks to Dr. Stephen Henson and Tom Francis for helping me with this via the mailing list.</p>

<pre><code>/* Make EnvelopedData structure */
BIO* in = BIO_new_file(in_path, ""rb"");

int flags = CMS_BINARY | CMS_USE_KEYID | CMS_PARTIAL | CMS_KEY_PARAM;

CMS_ContentInfo* edata = CMS_encrypt(NULL, NULL, cipher, flags);

CMS_RecipientInfo* r_info = CMS_add1_recipient_cert(edata, r_cert, flags);
EVP_PKEY_CTX* wrap_ctx = CMS_RecipientInfo_get0_pkey_ctx(r_info);

EVP_PKEY_CTX_set_rsa_padding(wrap_ctx, RSA_PKCS1_OAEP_PADDING);
EVP_PKEY_CTX_set_rsa_oaep_md(wrap_ctx, EVP_sha256());
EVP_PKEY_CTX_set_rsa_mgf1_md(wrap_ctx, EVP_sha256());
EVP_PKEY_CTX_set0_rsa_oaep_label(wrap_ctx, oaep_label, oaep_label_l);
/* NB: oaep_label must be heap-allocated, and will be freed by OSSL */

CMS_final(edata, in, NULL, flags);

BIO* tmp = BIO_new(BIO_s_mem());
i2d_CMS_bio(tmp, edata);

/* Make SignedData structure */

flags|= CMS_NOSMIMECAP | CMS_NOCERTS;
flags&amp;= ~(CMS_KEY_PARAM);

CMS_ContentInfo* sdata = CMS_sign(NULL, NULL, NULL, NULL, flags);

ASN1_OBJECT* ectype_edata = OBJ_nid2obj(NID_pkcs7_enveloped);
CMS_set1_eContentType(sdata, ectype_edata);

CMS_SignerInfo* s_info =
    CMS_add1_signer(sdata, s_cert, s_key, NULL, flags);

CMS_SignerInfo_sign(s_info);

CMS_final(sdata, tmp, NULL, flags);

BIO* out = BIO_new_file(out_path, ""wb"");
i2d_CMS_bio(out, sdata);
BIO_flush(out);
</code></pre>

<h2>3. Parsing the structure and getting the fields I need.</h2>

<p>I basically wrote my own CMS parser. ASN.1 is actually simple to parse when you know the spec. I've tried compiling the ASN.1 modules in the RFC using some ""ASN.1 to C structs"" compilers but had no luck (they kept choking on the syntax).</p>
","2209","<c><openssl><x509><pkcs#7>","1","1","1","2014-09-25 19:26:26","23422301","1","1","-1","","2017-05-23 12:01:40","2014-04-17 21:08:41",""
"20321302","Output AES/ECB/PKCS7 in c and java is not same","<p>Hi i am using AES/ECB/PKCS7 mode for encryption, individually in c&amp; java, encryption &amp; decryption working fine.  But  in c encrypted data is not same as encrypted data in java... </p>

<p>I am posting my code  in  C language and java. I need Encryption in c and Decryption  in java. Please assist me c code for aes/ecb/pkcs7 is correct ??.. I am using openssl </p>

<p>C code:</p>

<pre class=""lang-c prettyprint-override""><code>int Secure_encrypt(unsigned char *in, int inlen, unsigned char *out,int *outlen)
{
    int tmplen;
    // Key is 256 and is fixed.
    unsigned char key[256] =
    {   0x21,0x0a,0x03,0x23,0x45,0x29,0x78,0x12,0x35,0x45,0x67,0x78,0x21,0x13,
        0x34,0x56,0x67,0x45,0x12,0x89,0x38,0x0e,0xa0,0x15,0x21,
        0x0a,0x03,0x23,0x45,0x0b,0x15,0x0c
    };
    unsigned char *iv=0;
    EVP_CIPHER_CTX x;
    EVP_CIPHER_CTX_init(&amp;x);
    EVP_CIPHER_CTX_set_padding(&amp;x,1); // 1- padding, 0 - No Padding
    if (!EVP_EncryptInit_ex(&amp;x, EVP_aes_256_ecb(), 0, key, iv))
    {
        //printf(""\n ERROR!! \n"");
        return -1;
    }
    if (!EVP_EncryptUpdate(&amp;x, out, outlen,(const unsigned char*) in, inlen))
    {
        //printf(""\n ERROR!! \n"");
        return -2;
    }
    if (!EVP_EncryptFinal_ex(&amp;x,out + *outlen,&amp;tmplen)) {
        //printf(""\n ERROR!! \n"");
        return -3;
    }
    *outlen += tmplen;
#ifdef DEBUG
    printf (""AES encrypted data %d len\n"", *outlen);
    print_data (out, *outlen);
#endif
    EVP_CIPHER_CTX_cleanup(&amp;x);
    return 0;

}



/*AES DECRYPTION */
AES Decryption



int Secure_decrypt(unsigned char *in, int inlen, unsigned char *out,int *outlen)
{
    int tmplen;
    unsigned char *iv=0;
    unsigned char key[256]
    //AES/ECB/PKCS7 Padding
    EVP_CIPHER_CTX x;
    EVP_CIPHER_CTX_init(&amp;x);
    EVP_CIPHER_CTX_set_padding(&amp;x,1); // 1- padding, 0 - No Padding
    if (!EVP_DecryptInit_ex(&amp;x, EVP_aes_256_ecb(), 0, key, iv)) {
        //printf(""\n ERROR!! \n"");
        return -1;
    }
    if (!EVP_DecryptUpdate(&amp;x, out, outlen,(const unsigned char*) in, inlen))
    {
        //printf(""\n ERROR!! \n"");
        return -2;
    }
    if (!EVP_DecryptFinal_ex(&amp;x,out + *outlen,&amp;tmplen)) {
        //printf(""\n ERROR!! \n"");
        return -3;
    }
    *outlen += tmplen;

#ifdef DEBUG
    printf (""AES encrypted data %d len \n"", *outlen);
    print_data (out, *outlen);
#endif
    EVP_CIPHER_CTX_cleanup(&amp;x);
    return 0;
}
</code></pre>

<p>Java code:</p>

<pre class=""lang-java prettyprint-override""><code>import java.security.Security;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class doThis {

    public static void main(String[] args) {
        Security.addProvider(new BouncyCastleProvider());
        String strDataToEncrypt = ""Testing Encryption"";
        byte[] byteDataToTransmit = strDataToEncrypt.getBytes();
        //41 6E 6B 61 72 61 6F 20 49 74 74 61 64 69
        //byte[] byteDataToTransmit = new byte []
        {
            0x41,0x6E,0x6B,0x61,0x72,0x61,0x6F,0x20,0x49,0x74,0x74,0x61,0x64,0x69
        };
        try {

            byte [] keyBytes= new byte [] {0x21,0x0a,0x03,0x23,0x45,0x29,0x78,0x12,0x35,
                                           0x45,0x67,0x78,0x21,0x13,0x34,

                                           0x56,0x67,0x45,0x12,0x9,0x38,0x0e,0x20,
                                           0x15,0x21,0x0a,0x03,0x23,0x45,0x0b,0x15,0x0c
                                          };

            byte[] encrypted= aesEncrypt(byteDataToTransmit,keyBytes);

            System.out.println(""\n AES Encrypted Data is  ""+new String (encrypted));

            byte [] byteDecrypt=aesDecrypt(bytestrEncrypt, keyBytes);
            System.out.println(""\n AES Decrypted Data is""+byteDecrypt);
            // byte [] byteDecrypt=aesDecrypt(encrypted , keyBytes);

            //System.out.println(""\n AES Decrypted Data is""+new String(byteDecrypt));
        }
        catch(Exception exp)
        {
            System.out.println("" Exception caught "" + exp);
            exp.printStackTrace();
        }
    }

    public static byte[] aesEncrypt(byte[] original, byte[] key)
    {
        try
        {
            SecretKeySpec keySpec = null;
            Cipher cipher = null;
            {
                keySpec = new SecretKeySpec(key, ""AES/ECB/PKCS7Padding"");
                cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
                cipher.init(Cipher.ENCRYPT_MODE, keySpec); // encryption
            }
            return cipher.doFinal(original);
        }
        catch(Exception e)
        {
            //  Logger.e(e.toString());
        }
        return null;
    }

    public static byte[] aesDecrypt(byte[] encrypted, byte[] key)
    {
        try
        {
            SecretKeySpec keySpec = null;
            Cipher cipher = null;

            {
                keySpec = new SecretKeySpec(key, ""AES/ECB/PKCS7Padding"");

                cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
                cipher.init(Cipher.DECRYPT_MODE, keySpec);
            }

            System.out.println(""In Decryprion \n""+ new String (encrypted));
            return cipher.doFinal(encrypted);

        }
        catch(Exception e)
        {
            //  Logger.e(e.toString());
        }
        return null;
    }
}
</code></pre>
","<p>At least your handling of the returned amount of data is off. Check your buffer handling! Furthermore, in Java you use <code>new String (encrypted)</code> instead of converting the byte array to hexadecimals.</p>
","2208","<c><encryption><openssl><aes><pkcs#7>","1","0","1","2013-12-08 21:45:39","20458851","2","2","589259","","2013-12-08 21:42:32","2013-12-02 05:11:57",""
"19528000","How to Encode ASN.1 Context-specific using Openssl","<p>I am trying to encode the pkcs7 encapsulated content info:</p>

<pre><code>Sequence:
  OID
  [0] Context-specific
     OCTET STRING
</code></pre>

<p>My first problem is to encode Context-specific:</p>

<pre><code>[0] Context-specific
</code></pre>

<p>So I tried to create a 'SET Context-specific' with 'Octet String', but without success:</p>

<pre><code>// Create ASN1_OCTET
ASN1_OCTET_STRING *obj = ASN1_OCTET_STRING_new();
const BYTE* ptr = dataToSign.getData();
ASN1_OCTET_STRING_set(obj, ptr, dataToSign.getSize());

// Create ASN1_TYPE using ASN1_OCTET
ASN1_TYPE   *asn1Type   = ASN1_TYPE_new();
asn1Type-&gt;type = V_ASN1_OCTET_STRING;
asn1Type-&gt;value.octet_string = obj;

// Using i2d_ASN1_SET_OF_ASN1_TYPE
stack_st_ASN1_TYPE* sk = sk_ASN1_TYPE_new_null();
sk_ASN1_TYPE_push(sk,asn1Type);
int tamanho = i2d_ASN1_SET_OF_ASN1_TYPE(sk,(unsigned char **) NULL, i2d_ASN1_TYPE,V_ASN1_SET, V_ASN1_CONTEXT_SPECIFIC, IS_SET);
unsigned char* data = new BYTE[tamanho];
tamanho = i2d_ASN1_SET_OF_ASN1_TYPE(sk,(unsigned char **) &amp;data, i2d_ASN1_TYPE,V_ASN1_SET, V_ASN1_CONTEXT_SPECIFIC, IS_SET);
</code></pre>

<p>I have not found documentation on the website of <a href=""http://www.openssl.org/docs/"" rel=""nofollow"">openssl</a>.
This place is better <a href=""http://www.umich.edu/~x509/ssleay/"" rel=""nofollow"">umich - Openssl documentation</a></p>

<p>Am I on the right track?</p>
","<blockquote>
  <p>How to Encode ASN.1 Context-specific using Openssl?</p>
</blockquote>

<p>From <code>asn1.h</code>:</p>

<pre><code>#define V_ASN1_UNIVERSAL        0x00
#define V_ASN1_APPLICATION      0x40
#define V_ASN1_CONTEXT_SPECIFIC     0x80
#define V_ASN1_PRIVATE          0xc0
...

#define V_ASN1_BOOLEAN          1   /**/
#define V_ASN1_INTEGER          2
...
#define V_ASN1_UTF8STRING       12
#define V_ASN1_SEQUENCE         16
#define V_ASN1_SET          17
...
</code></pre>

<p>So you will need to use the tag <code>V_ASN1_CONTEXT_SPECIFIC</code>.</p>

<blockquote>
  <p>My first problem is to encode Context-specific</p>
</blockquote>

<p>From <a href=""http://www.zytrax.com/books/ldap/apb/asn1.pdf"" rel=""nofollow"">A Layman's Guide to a Subset of ASN.1, BER, and DER</a> (p. 12):</p>

<pre><code>&gt; Example 1: PKCS #7's ContentInfo type has an optional
&gt; content component with an explicit, context-specific tag:
&gt;
&gt; ContentInfo ::= SEQUENCE {
&gt;    contentType ContentType,
&gt;    content
&gt;    [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
&gt; 
&gt; Here the underlying type is ANY DEFINED BY contentType, the
&gt; class is absent (i.e., context-specific), and the tag number
&gt; within the class is 0.
</code></pre>

<p>Then, the document goes on to discuss the <code>ContentInfo</code>, the identifier octets, the encoding of <code>ANY</code> based on <code>contentInfo</code>, etc.</p>
","2166","<c++><encoding><openssl><pkcs#7>","2","0","2","2015-04-27 22:35:59","","0","1","823640","","2013-10-23 12:03:21","2013-10-22 20:45:42",""
"19528000","How to Encode ASN.1 Context-specific using Openssl","<p>I am trying to encode the pkcs7 encapsulated content info:</p>

<pre><code>Sequence:
  OID
  [0] Context-specific
     OCTET STRING
</code></pre>

<p>My first problem is to encode Context-specific:</p>

<pre><code>[0] Context-specific
</code></pre>

<p>So I tried to create a 'SET Context-specific' with 'Octet String', but without success:</p>

<pre><code>// Create ASN1_OCTET
ASN1_OCTET_STRING *obj = ASN1_OCTET_STRING_new();
const BYTE* ptr = dataToSign.getData();
ASN1_OCTET_STRING_set(obj, ptr, dataToSign.getSize());

// Create ASN1_TYPE using ASN1_OCTET
ASN1_TYPE   *asn1Type   = ASN1_TYPE_new();
asn1Type-&gt;type = V_ASN1_OCTET_STRING;
asn1Type-&gt;value.octet_string = obj;

// Using i2d_ASN1_SET_OF_ASN1_TYPE
stack_st_ASN1_TYPE* sk = sk_ASN1_TYPE_new_null();
sk_ASN1_TYPE_push(sk,asn1Type);
int tamanho = i2d_ASN1_SET_OF_ASN1_TYPE(sk,(unsigned char **) NULL, i2d_ASN1_TYPE,V_ASN1_SET, V_ASN1_CONTEXT_SPECIFIC, IS_SET);
unsigned char* data = new BYTE[tamanho];
tamanho = i2d_ASN1_SET_OF_ASN1_TYPE(sk,(unsigned char **) &amp;data, i2d_ASN1_TYPE,V_ASN1_SET, V_ASN1_CONTEXT_SPECIFIC, IS_SET);
</code></pre>

<p>I have not found documentation on the website of <a href=""http://www.openssl.org/docs/"" rel=""nofollow"">openssl</a>.
This place is better <a href=""http://www.umich.edu/~x509/ssleay/"" rel=""nofollow"">umich - Openssl documentation</a></p>

<p>Am I on the right track?</p>
","<p>Use i2d_ASN1_bytes function:</p>

<pre><code>// Initialize ASN1_STRING inplace (no need to free)
ASN1_STRING s = { 0, 0, NULL, 0};
// Initialize with our data
ASN1_STRING_set0(&amp;obj, dataToSign.getData(), dataToSign.getSize());

// Get resulting object length
int data_len = i2d_ASN1_bytes(obj, NULL, 0, V_ASN1_CONTEXT_SPECIFIC)
// Encode object with context tag 0
unsigned char* data = new BYTE[data_len];
unsigned char* p = data;
i2d_ASN1_bytes(obj, &amp;p, 0, V_ASN1_CONTEXT_SPECIFIC);
</code></pre>
","2166","<c++><encoding><openssl><pkcs#7>","2","1","2","2015-04-27 22:35:59","","0","1","823640","","2013-10-23 12:03:21","2013-10-22 20:45:42",""
"29939831","Obtaining the hash/digest from a PCKS7 signed PDF file with iText","<p>I'm writing a Java web service that signs PDF documents with iText from some clients in the network. Documents are being signed correctly, and can be verified with external tools. However, due to some legal restrictions in order to store this document in an official documentary repository I have to provide the hash/digest message from the signature.</p>

<p>I have tried almost anything to get to that hash, but the closest that I can get is to obtain the whole signature (CERT+HASH/DIGEST+TIMESTAMP) as a string with this code snippet (forgive the strings and [1] since I'm just testing how to do it):</p>

<pre><code>    PdfReader reader = new PdfReader(path);
    File temp = TempFileManager.createTempFile(""aasd2sd"", ""asdasda222cff"");
    PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(temp));
    stamper.setRotateContents(false);
    PdfString firma = (PdfString) stamper.getAcroFields().getSignatureDictionary(""Signature1"").get((PdfName)stamper.getAcroFields().getSignatureDictionary(""Signature1"").getKeys().toArray()[1]);
</code></pre>

<p>With that I get a DER-enconded PKCS7 Signature, as far as I know. But, I don't know how to decode/read this info in order to get to the hast.</p>

<p>Any idea?</p>

<p>Thanks,
Cris.</p>
","<p>First of all, there is not necessarily <strong><em>the</strong> hash/digest message from the signature</em>, in case of PKCS#7 / CMS signatures usually multiple hashes are involved, cf. <a href=""https://stackoverflow.com/a/28429984/1729265"">this answer to <em>Message digest of pdf in digital signature</em></a>.</p>

<p>Considering that you need the digest to fulfill some <em>legal restrictions</em>, though, I assume you are after the value of the signed attribute <code>MessageDigest</code> which (if it is present) for <strong>ETSI.CAdES.detached</strong> or <strong>adbe.pkcs7.detached</strong> type PDF signatures is the digest of the signed byte ranges.</p>

<hr>

<p>If you want to do that using iText classes (i.e. <em>not</em> security provider classes), you have to overcome the small issue that the value you are after is stored in a private member (<code>PdfPKCS7.digestAttr</code>). Some reflection allows you to access it, though:</p>

<pre><code>void extractHashes(PdfReader reader) throws Exception
{
    AcroFields acroFields = reader.getAcroFields();
    List&lt;String&gt; names = acroFields.getSignatureNames();

    for (String name: names)
    {
        PdfPKCS7 pdfPkcs7 = acroFields.verifySignature(name);
        pdfPkcs7.verify();

        Field digestAttrField = PdfPKCS7.class.getDeclaredField(""digestAttr"");
        digestAttrField.setAccessible(true);
        byte[] digestAttr = (byte[]) digestAttrField.get(pdfPkcs7);

        // process the digest value in digestAttr 
    }
}
</code></pre>

<p>You can find the method used in a more complete example <a href=""https://github.com/mkl-public/testarea-itext5/blob/master/src/test/java/mkl/testarea/itext5/signature/ExtractHash.java"" rel=""nofollow noreferrer"">ExtractHash.java</a> which outputs gigest algorithm and digest value of signature fields in a PDF document, e.g.:</p>

<pre><code>FirstPage11P0022AD_20150202164018_307494.pdf
  Signature1
    Digest algorithm: SHA1
    Hash: 4ac0ed7c2ec611d491f37b5ca74598237b85dbab
</code></pre>
","2156","<java><pdf><itext><pkcs#7>","1","4","1","2015-04-30 13:51:10","29969592","2","2","","","","2015-04-29 09:38:33",""
"14697702","Specifying input format type when calling openssl_pkcs7_verify in PHP","<p>I have a crypto/php question, I was hoping someone could help me with.
My issue is that I have a signed PKCS7 block that I am trying to verify in PHP.
However, when I run the following PHP command:</p>

<pre><code>openssl_pkcs7_verify($myfile, PKCS7_BINARY | PKCS7_NOVERIFY, $signers_file);
</code></pre>

<p>I get the following error:</p>

<pre><code>PKCS7 routines:SMIME_read_PKCS7:no content type
</code></pre>

<p>If I do it using ruby like so:</p>

<pre><code>p7container = OpenSSL::PKCS7.new(file_contents);
mystore = OpenSSL::X509::Store.new
p7container.verify(nil, store, nil, OpenSSL::PKCS7::NOVERIFY)
</code></pre>

<p>It works.</p>

<p>Also, if I run it through the OpenSSL commandline:</p>

<pre><code>openssl smime -verify -inform der -in my_data_file -noverify
</code></pre>

<p>It also works. However, if I run the following:</p>

<pre><code>openssl smime -verify -in my_data_file -noverify
</code></pre>

<p>Which is the same command, but without specifying the inform parameter, it fails with the same error message specified before, regarding the ""no content type"", which makes it seem I need to specify the input file format. Any ideas how I can do that through PHP?</p>

<p>Thanks in advance for your help,</p>
","<p>I got around that problem by calling openssl directly from PHP (using the <a href=""http://php.net/manual/en/function.exec.php"" rel=""nofollow"">exec</a> function). Be sure to add 2>&amp;1 to the command to redirect stderr to stdout as the message ""Verification successful"" is sent to stderr.</p>

<pre><code>function verify($signedData, &amp;$data = null) {
    @mkdir(""tmp"");
    $random = randomString(32);
    $signedFile = ""tmp/"" . $random . "".pem"";
    $file = ""tmp/"" . $random . "".dat"";
    file_put_contents($signedFile, $signedData);
    $output = exec(""openssl smime  -verify -in $signedFile -inform DER -noverify -out $file 2&gt;&amp;1"");
    if ($output == ""Verification successful"") {
        $data = file_get_contents($file);
        $result = true;
    } else {
        $result = false;
    }
    @unlink($signedFile);
    @unlink($file);
    return $result;
}
</code></pre>
","2132","<php><openssl><pkcs#7>","4","2","1","2013-03-01 17:59:37","15116990","0","1","1118109","","2013-02-05 01:08:20","2013-02-04 23:33:55",""
"7793706","How to generate PKCS7 format signature using IOS iphone SDK?","<p>I could Generate PKCS1 formatted raw signature.. and was able to verify it even. 
But could not find the resource to generate PCKS7 Formatted Signature using IPHONE IOS SDK.</p>

<p>I need to sign a simple text message.</p>

<p>Which library I have to use?</p>

<p>Can we use openssl for this? if yes? then how to include it in the XCODE library framework?</p>

<p>Pls help out.</p>
","<p>Yes you can use openssl for this, however you will need to compile it yourself and link your App against the static library.  If you want to run it in both the iPhone Simulator and a real iPhone Device (you do), you'll need to create a 'fat' library containing both armv7 and i386 architecture code.  If you want to support iPhone 3 instead then you'll need to include armv6 architecture code.  It's best therefore to build the library with all 3 architectures.</p>

<p>Here's a couple of resources that describe how to build openssl for iOS:</p>

<p><a href=""http://atastypixel.com/blog/easy-inclusion-of-openssl-into-iphone-app-projects/"" rel=""nofollow"">http://atastypixel.com/blog/easy-inclusion-of-openssl-into-iphone-app-projects/</a>
<a href=""https://github.com/st3fan/ios-openssl"" rel=""nofollow"">https://github.com/st3fan/ios-openssl</a></p>

<p><strong>EDIT</strong>:  I actually modified st3fan's build script, which I have pasted here:</p>

<p><a href=""http://pastebin.com/94RaeqX6"" rel=""nofollow"">setenv.sh</a> and <a href=""http://pastebin.com/fxEnLzZe"" rel=""nofollow"">build_openssl.sh</a></p>

<p>Download these scripts and keep them somewhere like ~/bin (review them and then <code>chmod</code> them 0755 once you are sure they are not malicious).</p>

<p>Next edit <code>setenv.sh</code> as it assumes there is a directory where you will install your 3rd-party libraries.  By default this is <code>/opt/local/ioslibs</code> so make sure that exists and is owned by you else the final bit will fail.  It's been configured for Xcode 4.2/iOS SDK 5 using the default locations so that might need correcting too.</p>

<p><code>build_openssl.sh</code> is configured to build a specific version of openssl (1.0.0e) and will download the source tarball if it's not in the current directory (you need <code>wget</code> for that, but if you cannot be bothered to install <code>wget</code> then manually download it using the link within the script).  When you run it, it will build the library in armv6, armv7 and i386 arch's and copy the correct files to the installation directory.</p>
","2116","<ios><ios4><openssl><pkcs#7>","1","0","1","2011-10-18 17:10:09","7794789","0","2","","","","2011-10-17 12:25:30",""
"17844519","Convert PKCS7 to PKCS12 using java.security.KeyStore","<p>When I try to import a renewed X509 certificate on Chrome / Firefox (and probably other browser), it does not recognize that the certificate I am trying to import uses the same private key stored in my expiring user certificate with the same DN. I don't know if this is a bug with the implementation of certificate import tool of all major browsers, but I can (somewhat) work around this problem by storing my user certificate inside a private key-less PKCS12 file using openssl tool like following.</p>

<blockquote>
  <p>openssl pkcs12 -export -in usercert.pem -nokeys -name ""CN: Same Name"" -out certonly.p12
  (-nokeys is the trick here)</p>
</blockquote>

<p>I don't know why this works, but I can then import certonly.p12 to Chrome / Firefox and it will attach my private key from the last year; although it creates a separate certificate entry so that I need to remove my old certificate manually. </p>

<p>So, I assume that, in order to renew my user certificate on my browser, I will need to package my certificate in PKCS12 format (with or without a pass-phrase).</p>

<p>Now, I need to do this in my Java application using java.security.KeyStore or similar libraries, because it is actually my web application which is generating user's renewed certificates. I don't want to ask our users to use the openssl command themselve to convert it to pkcs12 before importing to their browsers. My application should do this automatically, and provide them the renewed certificate contained inside a PKCS12 file.</p>

<p>I've looked many places, but so far I can't find a concrete example of how to do this using Java. Does anyone know how to output a pass-phrase less PKCS12 with only an issued certificate (or pkcs7) without a private key?</p>

<p>I tried something like following but it did not work.</p>

<pre><code>java.security.cert.Certificate[] chain  = CertificateManager.parsePKCS7(renewed_cert_in_pkcs7);
KeyStore p12 = KeyStore.getInstance(""PKCS12"");
p12.load(null, null);
p12.setKeyEntry(""USER Cert 123"", null, """".toCharArray(), chain); 
response.setContentType(""application/x-pkcs12"");
response.setHeader(""Content-Disposition"", ""attachment; filename=user_certificate_only.p12"");
p12.store(response.getOutputStream(), """".toCharArray());
</code></pre>
","","2098","<java><openssl><x509><pkcs#7>","2","","0","2013-07-24 20:47:50","","0","","","","","2013-07-24 20:47:50",""
"12910571","How to bypass the Certificate Expired validating when verifying the digital signature","<p>I have a problem when I verify a digital signature (PKCS#7) in Java using an expired public certificate.
For more detail, it's OK in case of signing data in .NET and then <strong>verify in Java</strong>, but there will be a Certificate Expired error in case of signing data in Java and <strong>verify in Java</strong>. In both of cases, I used the same verify method, the same private key and public certificate.</p>

<p>Please tell me why? And what should I do if I want to bypass the Certificate Expired validating when verifying the digital signature?</p>

<p>Thanks,</p>

<p>Sign method in C#.NET</p>

<pre><code>private static string SignData(byte[] data, string pkcs12FileUrl, string pkcs12Password)
    {
        X509Certificate2 signerCert = new X509Certificate2(pkcs12FileUrl, pkcs12Password);
        ContentInfo content = new ContentInfo(data);
        SignedCms signed = new SignedCms(content, true);
        CmsSigner signer = new CmsSigner(signerCert);
        signer.IncludeOption = X509IncludeOption.None;
        signed.ComputeSignature(signer);

        return Convert.ToBase64String(signed.Encode());
    }
</code></pre>

<p>Sign method in Java</p>

<pre><code>public static String SignData(byte[] data, String pkcs12File, String pkcs12Password)
    throws Exception
{
        if(Security.getProvider(""BC"")==null)
        {
            Security.addProvider(new BouncyCastleProvider());
        }
        KeyStore keyStore = getPkcs12Info(pkcs12File, pkcs12Password);

        Enumeration&lt;String&gt; aliasesList = keyStore.aliases();
        String aliasName = """";
        while (aliasesList.hasMoreElements())
        {
            aliasName = aliasesList.nextElement().toString();
        }

        X509Certificate signerCert = (X509Certificate) keyStore.getCertificate(aliasName);
        PrivateKey privateKey = (PrivateKey) keyStore.getKey(aliasName,pkcs12Password.toCharArray());

        CMSSignedDataGenerator Signer = new CMSSignedDataGenerator();
        Signer.addSigner(privateKey, signerCert, CMSSignedDataGenerator.DIGEST_SHA1);

        CMSProcessableByteArray digestContent = new CMSProcessableByteArray(data);

        CMSSignedData Signed = Signer.generate(digestContent, false, ""BC"");
        return Base64.encode(Signed.getEncoded());

}

private static  KeyStore getPkcs12Info(String pkcs12File, String pkcs12Password) throws Exception
{
    //KeyStore keyStore = KeyStore.getInstance(""PKCS12"", ""BC"");
        KeyStore keyStore = KeyStore.getInstance(""PKCS12"");
        keyStore.load(new FileInputStream(pkcs12File), pkcs12Password.toCharArray());
        return keyStore;
}
</code></pre>

<p>Verify method in Java</p>

<pre><code>public static boolean VerifySignature(byte[] data, String digitalSignature, InputStream publicCertFile) throws Exception
{
    if(Security.getProvider(""BC"")==null)
    {
        Security.addProvider(new BouncyCastleProvider());
    }
    CertificateFactory factory = CertificateFactory.getInstance(""X509"",""BC"");
    X509Certificate publicCert = (X509Certificate)factory.generateCertificate(publicCertFile);
    CMSProcessableByteArray digestContent = new CMSProcessableByteArray(data);
    CMSSignedData Signed = new CMSSignedData(digestContent,Base64.decode(digitalSignature));
    SignerInformation Signer=(SignerInformation)Signed.getSignerInfos().getSigners().iterator().next();
    return Signer.verify(publicCert, ""BC"");
}
</code></pre>
","<p>If you sign a document with a certificate that has already expired, it is already pointless. The certificate has already expired and should not be put to new uses. Verifying a document whose signing certificate has expired makes sense since at least you know the certificate was valid when the document was signed. Unless it was signed by .NET apparently. Sounds like a bug in .NET to me.</p>
","2070","<java><.net><digital-signature><pkcs#7>","2","1","2","2013-09-24 01:38:16","","2","","","","","2012-10-16 08:34:26",""
"12910571","How to bypass the Certificate Expired validating when verifying the digital signature","<p>I have a problem when I verify a digital signature (PKCS#7) in Java using an expired public certificate.
For more detail, it's OK in case of signing data in .NET and then <strong>verify in Java</strong>, but there will be a Certificate Expired error in case of signing data in Java and <strong>verify in Java</strong>. In both of cases, I used the same verify method, the same private key and public certificate.</p>

<p>Please tell me why? And what should I do if I want to bypass the Certificate Expired validating when verifying the digital signature?</p>

<p>Thanks,</p>

<p>Sign method in C#.NET</p>

<pre><code>private static string SignData(byte[] data, string pkcs12FileUrl, string pkcs12Password)
    {
        X509Certificate2 signerCert = new X509Certificate2(pkcs12FileUrl, pkcs12Password);
        ContentInfo content = new ContentInfo(data);
        SignedCms signed = new SignedCms(content, true);
        CmsSigner signer = new CmsSigner(signerCert);
        signer.IncludeOption = X509IncludeOption.None;
        signed.ComputeSignature(signer);

        return Convert.ToBase64String(signed.Encode());
    }
</code></pre>

<p>Sign method in Java</p>

<pre><code>public static String SignData(byte[] data, String pkcs12File, String pkcs12Password)
    throws Exception
{
        if(Security.getProvider(""BC"")==null)
        {
            Security.addProvider(new BouncyCastleProvider());
        }
        KeyStore keyStore = getPkcs12Info(pkcs12File, pkcs12Password);

        Enumeration&lt;String&gt; aliasesList = keyStore.aliases();
        String aliasName = """";
        while (aliasesList.hasMoreElements())
        {
            aliasName = aliasesList.nextElement().toString();
        }

        X509Certificate signerCert = (X509Certificate) keyStore.getCertificate(aliasName);
        PrivateKey privateKey = (PrivateKey) keyStore.getKey(aliasName,pkcs12Password.toCharArray());

        CMSSignedDataGenerator Signer = new CMSSignedDataGenerator();
        Signer.addSigner(privateKey, signerCert, CMSSignedDataGenerator.DIGEST_SHA1);

        CMSProcessableByteArray digestContent = new CMSProcessableByteArray(data);

        CMSSignedData Signed = Signer.generate(digestContent, false, ""BC"");
        return Base64.encode(Signed.getEncoded());

}

private static  KeyStore getPkcs12Info(String pkcs12File, String pkcs12Password) throws Exception
{
    //KeyStore keyStore = KeyStore.getInstance(""PKCS12"", ""BC"");
        KeyStore keyStore = KeyStore.getInstance(""PKCS12"");
        keyStore.load(new FileInputStream(pkcs12File), pkcs12Password.toCharArray());
        return keyStore;
}
</code></pre>

<p>Verify method in Java</p>

<pre><code>public static boolean VerifySignature(byte[] data, String digitalSignature, InputStream publicCertFile) throws Exception
{
    if(Security.getProvider(""BC"")==null)
    {
        Security.addProvider(new BouncyCastleProvider());
    }
    CertificateFactory factory = CertificateFactory.getInstance(""X509"",""BC"");
    X509Certificate publicCert = (X509Certificate)factory.generateCertificate(publicCertFile);
    CMSProcessableByteArray digestContent = new CMSProcessableByteArray(data);
    CMSSignedData Signed = new CMSSignedData(digestContent,Base64.decode(digitalSignature));
    SignerInformation Signer=(SignerInformation)Signed.getSignerInfos().getSigners().iterator().next();
    return Signer.verify(publicCert, ""BC"");
}
</code></pre>
","<p>I found this topic <a href=""https://stackoverflow.com/questions/11013111/java-implementation-of-c-sharp-signedcms?rq=1"">Java implementation of C# SignedCms</a> and tried to change my Sign method's code in Java. Finally, it works so well. Here my updated code in Java</p>

<pre><code>public static String SignData(byte[] data, String pkcs12File, String pkcs12Password)
    throws Exception
{
        ByteArrayOutputStream byteArrOut = new ByteArrayOutputStream();
        DEROutputStream derOut = new DEROutputStream(byteArrOut);
        try
        {
            if(Security.getProvider(""BC"")==null)
            {
                Security.addProvider(new BouncyCastleProvider());
            }
            KeyStore keyStore = getPkcs12Info(pkcs12File, pkcs12Password);

            Enumeration&lt;String&gt; aliasesList = keyStore.aliases();
            String aliasName = """";
            while (aliasesList.hasMoreElements())
            {
                aliasName = aliasesList.nextElement().toString();
            }

            X509Certificate signerCert = (X509Certificate) keyStore.getCertificate(aliasName);
            PrivateKey privateKey = (PrivateKey) keyStore.getKey(aliasName, pkcs12Password.toCharArray());

            List certList = new ArrayList();
            Store certs = new JcaCertStore(certList);

            JcaSimpleSignerInfoGeneratorBuilder builder = new JcaSimpleSignerInfoGeneratorBuilder().setProvider(""BC"").setDirectSignature(true);


            CMSSignedDataGenerator signer = new CMSSignedDataGenerator();
            signer.addSignerInfoGenerator(builder.build(""SHA1withRSA"", privateKey, signerCert));
            signer.addCertificates(certs);

            CMSTypedData msg = new CMSProcessableByteArray(data);
            CMSSignedData signed = signer.generate(msg, false);

            derOut.writeObject(signed.toASN1Structure().toASN1Primitive());
            return Base64.encode(byteArrOut.toByteArray());
        }
        catch(Exception ex)
        {
            throw ex;
        }
        finally
        {
            derOut.close();
            byteArrOut.close();
        }

}
</code></pre>
","2070","<java><.net><digital-signature><pkcs#7>","2","1","2","2013-09-24 01:38:16","","2","","","","","2012-10-16 08:34:26",""
"8449799","decrypt p7m file in C# or .NET with privateKey from file","<p>Hopefully someone can help me with code because I am working on it 3 months without any success. I tried almost anything from internet but nothing does not work.</p>

<p>Problem: I have encrypted file p7m (size 158KB) (it is crypted text). I have certificate in file pfx, under password ""a"". In this certificate is the public key which is needed to decrypt p7m file.</p>

<p>I need something that will read xyyv.p7m file, decrypt it with public key, and save it as XYZ.xyz</p>

<p>I do not put here any my code to do not confuse you. thanks</p>
","<p>A PKCS#7 structure can be <strong>very</strong> messy (and that's actually true for most ASN.1 structures). There's not much specific advice that can be given if we don't know what was used to produce this file.</p>

<p>In general there's code for reading them in <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.pkcs.aspx"" rel=""nofollow""><code>System.Security.Cryptography.Pkcs</code></a> but it's easy to create files (valid or invalid) that won't be processed correctly. Even more if they were generated using different tools.</p>

<p>Mono provides classes, inside <a href=""https://github.com/mono/mono/tree/master/mcs/class/Mono.Security"" rel=""nofollow""><code>Mono.Security</code></a>, to read them. They are very low-level API (with some helpers) so, in theory, they should be able to read anything... as long as you don't mind coding the processing your format itself.</p>

<p>Other libraries, <a href=""http://www.bouncycastle.org/csharp/"" rel=""nofollow"">BouncyCastle</a> comes to mind, will offer similar (low or high level) API to process PKCS#7 files.</p>
","2061","<c#><.net><encryption><private-key><pkcs#7>","0","0","1","2011-12-09 18:19:02","","2","","220643","","2011-12-09 18:19:02","2011-12-09 18:04:40",""
"35099408","Generate a CMS PKCS#7 file with BouncyCastle in C#","<p>I'm starting to cryptography.
I need to generate a PKCS # 7 file with XML, an RSA private key (which is not included in the certificate is a file extension .key) and a certificate .cer extension.</p>

<p>For this i'm using a BouncyCastle.</p>

<p>Edit:</p>

<p>Thanks @khlr for your help but I can not solve my problem. When sending the data to the AC returns me ""Invalid CMS"". 
I have this code:    </p>

<pre><code>public static byte[] FirmaBytesMensaje(byte[] argBytesMsg, X509Certificate2 argCertFirmante)
{
    try
    {
        //Add message in object ContentInfo 
        ContentInfo infoContenido = new ContentInfo(argBytesMsg);
        SignedCms cmsFirmado = new SignedCms(infoContenido);


        CmsSigner cmsFirmante = new CmsSigner(argCertFirmante);
        cmsFirmante.IncludeOption = X509IncludeOption.EndCertOnly;


        // Sign message PKCS #7 
        cmsFirmado.ComputeSignature(cmsFirmante);


        // Encodeo el mensaje PKCS #7. 
        return cmsFirmado.Encode();
    }
    catch (Exception excepcionAlFirmar)
    {
        throw new Exception(""***Error: "" + excepcionAlFirmar.Message);
    }
}
</code></pre>

<p>Signing on PKCS # 7 but this makes with a ""PFX"" certificate, that is, that contains the private key in a "".pfx"" file. 
When I use the OpenSSL command:</p>

<pre><code>openssl smime -sign -signer cert.crt -inkey private.key -out file.xml.cms -in file.xml -outform PEM -nodetach
</code></pre>

<p>The AC responds well.
How I can do this with BouncyCastle and cer and key files? I am going crazy! :-(</p>
","<p>Unfortunately there seems to be <a href=""https://stackoverflow.com/questions/13667828/c-sharp-resoursces-for-bouncy-castle-api"">no bouncycastle API documentation for C#</a>. Never the less there's a <a href=""https://www.bouncycastle.org/docs/pkixdocs1.4/org/bouncycastle/cms/CMSSignedData.html"" rel=""nofollow noreferrer"">Java reference</a> which is said to be quite similar to the C# API.</p>

<p>Hence the <code>getEncoded()</code>-method (look for a C# equivalent, e.g. <code>GetEncoded()</code>) yields a ASN.1 encoded <code>byte[]</code>.</p>

<p>You could then go ahead and get a string from that (note that I'm not familiar with ASN.1 encoding. This is just a guess üòâ):</p>

<pre><code>byte[] buffer = datosFirmados.GetEncoded();
string signedDataString = System.Text.Encoding.UTF8.GetString(buffer, 0, buffer.Length);
</code></pre>

<p>Edit:</p>

<p>Maybe the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.asnencodeddata.format(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>AsnEncodedData</code>-class</a> would be more appropriate for that task:</p>

<pre><code>byte[] buffer = datosFirmados.GetEncoded();
var asndata = new AsnEncodedData(buffer);
const bool multiline = true;
string signedDataString = asndata.Format(multiline);
</code></pre>
","2054","<c#><bouncycastle><sign><pkcs#7>","1","0","1","2016-02-01 07:04:38","","6","","3980065","","2016-02-01 07:04:38","2016-01-30 07:51:07",""
"14584903","Error signing file pkcs#7 and bouncycastle java","<p>I'm getting the following error when trying to sign a file.</p>

<p>Exception in thread ""main"" org.bouncycastle.operator.OperatorCreationException: exception on setup: java.security.NoSuchAlgorithmException: no such algorithm: 1.3.14.3.2.26 for provider SunPKCS11-eToken
    at org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1.get(Unknown Source)
    at org.bouncycastle.cms.SignerInfoGenerator.(Unknown Source)
    at org.bouncycastle.cms.SignerInfoGenerator.(Unknown Source)
    at org.bouncycastle.cms.SignerInfoGeneratorBuilder.createGenerator(Unknown Source)
    at org.bouncycastle.cms.SignerInfoGeneratorBuilder.build(Unknown Source)
    at org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder.build(Unknown Source)
    at org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder.build(Unknown Source)
    at testapp.Testapp.setUpProvider(Testapp.java:111)
    at testapp.Testapp.main(Testapp.java:74)
Caused by: java.security.NoSuchAlgorithmException: no such algorithm: 1.3.14.3.2.26 for provider SunPKCS11-eToken
    at sun.security.jca.GetInstance.getService(GetInstance.java:83)
    at sun.security.jca.GetInstance.getInstance(GetInstance.java:202)
    at java.security.Security.getImpl(Security.java:688)
    at java.security.MessageDigest.getInstance(MessageDigest.java:233)
    at org.bouncycastle.jcajce.ProviderJcaJceHelper.createDigest(Unknown Source)
    at org.bouncycastle.operator.jcajce.OperatorHelper.createDigest(Unknown Source)
    ... 9 more
Java Result: 1</p>

<p>Here is the code:</p>

<pre><code>    InputStream cnfStream = new ByteArrayInputStream(pkcs11config.getBytes());
    Provider p = new sun.security.pkcs11.SunPKCS11(cnfStream);
    Security.addProvider(p);
    KeyStore ks = KeyStore.getInstance(""PKCS11"", p);
    ks.load(null, PASSWORD);
    byte[] signedData = sign(data, ks, p);

public static byte[] sign(byte[] data, KeyStore ks, Provider p) throws Exception {

    String alias = ks.aliases().nextElement();

    List certList = new ArrayList();
    CMSTypedData msg = new CMSProcessableByteArray(data); //Data to sign

    X509Certificate cert = (X509Certificate) ks.getCertificate(alias);
    certList.add(cert); //Adding the X509 Certificate

    Store certs = new JcaCertStore(certList);

    CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
    //Initializing the the BC's Signer
    ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(p).build((PrivateKey)ks.getKey(alias, PASSWORD));

    gen.addSignerInfoGenerator(
            new JcaSignerInfoGeneratorBuilder(
            new JcaDigestCalculatorProviderBuilder().setProvider(p).build())
            .build(sha1Signer, cert));
    //adding the certificate
    gen.addCertificates(certs);
    //Getting the signed data
    CMSSignedData sigData = gen.generate(msg, false);
    return sigData.getEncoded();
}
</code></pre>

<p>Any idea?</p>

<p>Thanks in advance</p>
","<p>Ok, I ended up solving this on my own.Here is the working code:</p>

<pre><code>    private void findProvider() {
        String driver;
        byte[] pkcs11config;
        for (int i = indiceDrivers; i &lt; largoDrivers; i++) {
            driver = DRIVERS[i];
            File f = new File(REPO + driver);
            if (!f.exists()) {
                continue;
            }
            pkcs11config = String
                    .format(""name = eToken\n library = %s%s"", REPO, driver)
                    .getBytes();
            try {
                InputStream cnfStream = new ByteArrayInputStream(pkcs11config);
                provider = new sun.security.pkcs11.SunPKCS11(cnfStream);
                keyStore = KeyStore.getInstance(""PKCS11"", this.provider);
                Security.addProvider(provider);
                keyStore.load(null, password);
                System.out.println(""OK: "" + driver);
                break;
            } catch (Exception e) {
                //Solo con fines de prueba
                System.out.println(""ERROR: "" + driver);
            }
        }
        if (provider == null) {
            throw new RuntimeException(""Los drivers del token no estan instalados."");
        } else if (provider != null &amp;&amp; keyStore == null) {
            throw new RuntimeException(""El token no esta conectado."");
        }
    }

 public void sign(File input, File output) throws Exception {
        String alias = keyStore.aliases().nextElement();
        List certList = new ArrayList();
        CMSTypedData msg = new CMSProcessableFile(input);
        X509Certificate cert = (X509Certificate) keyStore.getCertificate(alias);
        certList.add(cert);
        Store certs = new JcaCertStore(certList);
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(provider).build((PrivateKey) keyStore.getKey(alias, password));
        Security.addProvider(new BouncyCastleProvider());
        gen.addSignerInfoGenerator(
                new JcaSignerInfoGeneratorBuilder(
                new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build())
                .build(sha1Signer, cert));
        gen.addCertificates(certs);
        CMSSignedData sigData = gen.generate(msg, true);

        FileOutputStream fileOuputStream = new FileOutputStream(output);
        fileOuputStream.write(sigData.getEncoded());
        fileOuputStream.flush();
        fileOuputStream.close();
    }
</code></pre>
","2033","<java><bouncycastle><pkcs#7><pkcs#11>","0","0","1","2015-09-10 11:21:39","","0","2","","","","2013-01-29 14:11:44",""
"13007823","X509_verify_cert returning 0 (ZERO)","<p>I am implementing the code below (Do see the comments)::</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;openssl/crypto.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/pem.h&gt;
#include &lt;openssl/rand.h&gt;

#pragma comment(lib, ""ssleay32.lib"")
#pragma comment(lib, ""libeay32.lib"")

void verifyCertificate() ;
X509 *loadCert(char*) ;
void loadToStore(char*, X509_STORE*&amp;) ;

void verifyCertificate()
{
    int i = 0 ;
    char argv[50] = ""C:\\My\\CA.pem"" ;  /* Details:: Issuer = Verisign Inc &amp; Subject = Verisign Inc
    char argv1[50] = ""C:\\My\\mid1.pem"" ;   /* Details:: Issuer = Thawte &amp; Subject = Verisign Inc
    char argv2[50] = ""C:\\My\\mid2.pem"" ;   /* Details:: Issuer = Verisign Inc &amp; Subject = Verisign Inc
    char argv3[50] = ""C:\\My\\Signer.pem"" ; /* Details:: Issuer = Verisign Inc &amp; Subject = SignerOrganisation

    X509 *cert = loadCert(argv3);
    X509_STORE *store = X509_STORE_new();

    loadToStore(argv, store);
    loadToStore(argv1, store);
    loadToStore(argv2, store);

    X509_STORE_CTX *ctx = X509_STORE_CTX_new();

    X509_STORE_CTX_init(ctx, store, cert, NULL);

    i = X509_verify_cert(ctx);
    printf(""i = %d\n"", i) ; // Returns i = 0
    if (i != 1)
      printf(""%s"", X509_verify_cert_error_string(ctx-&gt;error));
           // Returns ""Certificate Signature Failure""

    X509_STORE_CTX_cleanup(ctx);
    X509_STORE_CTX_free(ctx);
    X509_STORE_free(store);
    ctx = NULL;
    store = NULL;
}

void loadToStore(char* file, X509_STORE *&amp;store)
{
    X509 *cert = loadCert(file);
    if (cert != NULL)
        X509_STORE_add_cert(store, cert);
    else
        printf(""Can not load certificate"");
}

X509 *loadCert(char* file)
{
    FILE *fp = fopen(file, ""rb"");
    X509 *cert = PEM_read_X509(fp, NULL, NULL, NULL);
    fclose(fp);
    return cert;
}

int main(int argc, char** argv)
{
    verifyCertificate() ;
    return 0 ;
}
</code></pre>

<p>I have extracted each and every certificate contained and then loaded them in the store.</p>

<p><strong>Problem:: X509_verify_cert is returning Zero(0)</strong>. Any advises?</p>
","<p>X509_verify_cert returns success only for valid certificates chains i.e. each next certificate has to be signed by previous one (except 1st that has to be self-signed). To determine whether you have a valid chain full information about your pems should be provided. But considering your comments I see that CA.pem doesn't sign mid1.pem because CA.pem's subject (Verisign Inc) is not equal to mid1.pem's issuer (Thawte)</p>
","1980","<openssl><certificate><verification><x509><pkcs#7>","2","1","1","2014-08-12 07:09:31","","2","","1182192","","2012-10-22 09:05:25","2012-10-22 08:50:38",""
"6475106","Failed in reading PKCS7 signed file with s/mime format ( big size )","<p>I want to verify signed file with s/mime format and the pkcs7 file size is 500MB.</p>

<p>openssl smime -verify -in test.pk7 -inform DER </p>

<p>Error reading S/MIME message
715956256:error:07069041:memory buffer routines:BUF_MEM_grow_clean:malloc failure:buffer.c:152:
715956256:error:0D06B041:asn1 encoding routines:ASN1_D2I_READ_BIO:malloc failure:a_d2i_fp.c:229:</p>

<p>Is it possible with limited memory usage e.g.200MB ?</p>
","<p>Unfortunately, OpenSSL will load the whole file in memory.</p>

<p>If possible switching PKCS#7 detached signatures would reduce significantly the memory requirements. That means having the data and the signature as 2 separate files.</p>
","1979","<linux><openssl><pkcs#7><smime>","1","1","4","2014-04-03 07:53:15","22831165","0","","","","","2011-06-25 00:58:14",""
"6475106","Failed in reading PKCS7 signed file with s/mime format ( big size )","<p>I want to verify signed file with s/mime format and the pkcs7 file size is 500MB.</p>

<p>openssl smime -verify -in test.pk7 -inform DER </p>

<p>Error reading S/MIME message
715956256:error:07069041:memory buffer routines:BUF_MEM_grow_clean:malloc failure:buffer.c:152:
715956256:error:0D06B041:asn1 encoding routines:ASN1_D2I_READ_BIO:malloc failure:a_d2i_fp.c:229:</p>

<p>Is it possible with limited memory usage e.g.200MB ?</p>
","<p>I had this problem with a 1.4GB encrypted file, on 32bit host it failed on mallocs, on 64bit it got through.</p>
","1979","<linux><openssl><pkcs#7><smime>","1","0","4","2014-04-03 07:53:15","22831165","0","","","","","2011-06-25 00:58:14",""
"6475106","Failed in reading PKCS7 signed file with s/mime format ( big size )","<p>I want to verify signed file with s/mime format and the pkcs7 file size is 500MB.</p>

<p>openssl smime -verify -in test.pk7 -inform DER </p>

<p>Error reading S/MIME message
715956256:error:07069041:memory buffer routines:BUF_MEM_grow_clean:malloc failure:buffer.c:152:
715956256:error:0D06B041:asn1 encoding routines:ASN1_D2I_READ_BIO:malloc failure:a_d2i_fp.c:229:</p>

<p>Is it possible with limited memory usage e.g.200MB ?</p>
","<p>As Mathias mentions, you can stream process the data in OpenSSL if the signature is detached.</p>

<p>Now if your signature isn't detached, you should still be able detach it yourself. The PKCS#7 format is well-documented. asn1c can work in chunks so you should be able to work with that.</p>

<p>Of course, the proper solution is to get a detached signature in the first place.</p>
","1979","<linux><openssl><pkcs#7><smime>","1","0","4","2014-04-03 07:53:15","22831165","0","","","","","2011-06-25 00:58:14",""
"6475106","Failed in reading PKCS7 signed file with s/mime format ( big size )","<p>I want to verify signed file with s/mime format and the pkcs7 file size is 500MB.</p>

<p>openssl smime -verify -in test.pk7 -inform DER </p>

<p>Error reading S/MIME message
715956256:error:07069041:memory buffer routines:BUF_MEM_grow_clean:malloc failure:buffer.c:152:
715956256:error:0D06B041:asn1 encoding routines:ASN1_D2I_READ_BIO:malloc failure:a_d2i_fp.c:229:</p>

<p>Is it possible with limited memory usage e.g.200MB ?</p>
","<p>I have used NSS library which supports chunk-based processing and it worked perfectly.</p>
","1979","<linux><openssl><pkcs#7><smime>","1","0","4","2014-04-03 07:53:15","22831165","0","","","","","2011-06-25 00:58:14",""
"16014157","How to convert X509 certificate into PKCS7 using bouncycastle?","<p>Hi, all! My problem is following: I 'm trying to encrypt X509 certificate to PKCS7 but I receive a wrong result.</p>

<p>The first attempt is:(used bcmail-jdk16:1.46)</p>

<p><pre><code>
            Security.addProvider(new BouncyCastleProvider());

            keystore = KeyStore.getInstance(""PKCS12"", ""BC"");
            keystore.load (new FileInputStream(PATH+""//pkcs7-csr-cer//identity.p12""), ""testpassword"".toCharArray());
            PrivateKey privateKey = (PrivateKey)keystore.getKey(""testclientcert"", ""testpassword"".toCharArray());

            CMSSignedDataGenerator signedDataGen = new CMSSignedDataGenerator();

            signedDataGen.addSigner(privateKey, certificate, CMSSignedDataGenerator.ENCRYPTION_RSA, CMSSignedDataGenerator.DIGEST_SHA256);
            CMSProcessableFile pkcs7 = new CMSProcessableFile(new File(destinationfile));
            CMSSignedData signedData = signedDataGen.generate(pkcs7, true, ""BC"");
            signedData = new CMSSignedData(pkcs7, signedData.getEncoded());

</code></pre></p>

<p>...and it doesn't work.</p>

<p>The second attempt is next(used bcmail-jdk16-140):</p>

<p><pre><code>
        Security.addProvider(new BouncyCastleProvider());

        CMSEnvelopedDataGenerator envDataGen = new CMSEnvelopedDataGenerator();
        envDataGen.addKeyTransRecipient(certificate);

        CMSProcessable sData = new CMSProcessableByteArray(certificate.getEncoded());
        CMSEnvelopedData enveloped = envDataGen.generate(sData, CMSEnvelopedDataGenerator.AES256_CBC, ""BC"");
        return enveloped.getEncoded();
</code></pre></p>

<p>I get wrong results in both cases.
Help please who know a right way to do it. Thanks!</p>
","<p>I found the solution!</p>

<p><pre><code>
    private byte[] encryptCertToPKCS7(X509Certificate certificate, Key key) 
                throws CertificateEncodingException, CMSException, NoSuchProviderException, NoSuchAlgorithmException, IOException, OperatorCreationException {
        CMSSignedDataGenerator generator = new CMSSignedDataGenerator();

        ContentSigner sha256Signer = new JcaContentSignerBuilder(""SHA256withRSA"").setProvider(""BC"").build((PrivateKey) key);
        generator.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder()
                                                                               .setProvider(""BC"").build())
                                                                              .build(sha256Signer, certificate));
        generator.addCertificates(new JcaCertStore(certificates));
        CMSTypedData content = new CMSProcessableByteArray(certificate.getEncoded());

        CMSSignedData signedData = generator.generate(content, true);
        return signedData.getEncoded();
    }

</code></pre></p>
","1944","<java><bouncycastle><x509><pkcs#7>","1","0","1","2013-04-19 13:07:05","16105361","0","","1809141","","2013-04-15 18:10:48","2013-04-15 11:36:00",""
"16934954","padding with PKCS7 [C]","<p>I want to do padding with PKCS7 :</p>

<pre><code>char *test1 = ""azertyuiopqsdfgh"";
char *test2 = malloc(32*sizeof(char));

memcpy(test2, test1, strlen(test1));

char pad = (char)(32-strlen(test1));
printf(""pad = %d\n"", pad);

for(int i = strlen(test1) ; i &lt; 32 ; i++) {
    test2[i] = pad;
}
for (int i = 0 ; i &lt; 32 ; i++)
    printf(""%x "", test2[i]);
printf(""\n"");
</code></pre>

<p>I obtain :</p>

<pre><code>pad = 16

61 7a 65 72 74 79 75 69 6f 70 71 73 64 66 67 68 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
</code></pre>

<p>But i want :</p>

<pre><code>pad = 16

61 7a 65 72 74 79 75 69 6f 70 71 73 64 66 67 68 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
</code></pre>

<p>How can i modify my code ?</p>

<p>Thanks in advance.</p>
","<p>With </p>

<pre><code>printf(""%x "", test2[i]);
</code></pre>

<p>You are printing in hexadecimal (<strong>%x</strong>) whereas with </p>

<pre><code>printf(""pad = %d\n"", pad);` you are printing in decimal (%d). 
</code></pre>

<p>And <strong>(decimal) 16 => (hexa) 10</strong>, So you are displaying the right thing.</p>

<p>You could probably play a bit with your printing to display 16 instead of 10 but I don't think this is what you are searching for.</p>
","1884","<c><padding><pkcs#7>","0","0","1","2013-06-05 08:33:02","16935103","0","1","","","","2013-06-05 08:25:07",""
"9413006","PHP Reading a S/Mime email p7m attachment (Base64?)","<p>We have a system using Symantec's PGP Universal Web Messenger.</p>

<p>This means that emails are sent to me using s/mime encryption from a pkcs12 cert.</p>

<p>I'm having a bit of trouble reading the messages in PHP.</p>

<p>I have all the imap code but now how do I read the encrypted p7m attached file. Is it just Base64 encoded and signed? </p>

<p>EDIT: I have the public key.</p>

<p>Here is the mime info:-</p>

<pre><code>Content-Type: application/pkcs7-mime; smime-type=enveloped-data;\r\n\tname=""Message.p7m""\r\nContent-Transfer-Encoding: BASE64\r\nContent-Disposition: attachment; filename=""Message.p7m""
</code></pre>
","<p>The P7M file type is primarily associated with a <a href=""http://en.wikipedia.org/wiki/S/MIME"" rel=""nofollow""><code>PKCS #7 MIME Message</code></a>. See <a href=""http://tools.ietf.org/html/rfc2311#section-3.2"" rel=""nofollow"">Section 3.2 in RFC 2311</a>:</p>

<blockquote>
<pre><code>3.2 The application/pkcs7-mime Type

    The application/pkcs7-mime type is used to carry PKCS #7 objects of
    several types including envelopedData and signedData. The details of
    constructing these entities is described in subsequent sections. This
    section describes the general characteristics of the
    application/pkcs7-mime type.

    This MIME type always carries a single PKCS #7 object. The PKCS #7
    object must always be BER encoding of the ASN.1 syntax describing the
    object. The contentInfo field of the carried PKCS #7 object always
    contains a MIME entity that is prepared as described in section 3.1.
    The contentInfo field must never be empty.

    Since PKCS #7 objects are binary data, in most cases base-64 transfer
    encoding is appropriate, in particular when used with SMTP transport.
    The transfer encoding used depends on the transport through which the
    object is to be sent, and is not a characteristic of the MIME type.

    Note that this discussion refers to the transfer encoding of the PKCS
    \#7 object or ""outside"" MIME entity. It is completely distinct from,
    and unrelated to, the transfer encoding of the MIME entity secured by
    the PKCS #7 object, the ""inside"" object, which is described in
    section 3.1.

    Because there are several types of application/pkcs7-mime objects, a
    sending agent SHOULD do as much as possible to help a receiving agent
    know about the contents of the object without forcing the receiving
    agent to decode the ASN.1 for the object. The MIME headers of all
    application/pkcs7-mime objects SHOULD include the optional ""smime-
    type"" parameter, as described in the following sections.
</code></pre>
</blockquote>

<p>This is basically a secure E-mail file sent in encrypted form. If everything is set up properly you should have a public key necessary to decrypt the file. If not, download it.</p>

<p>In your case the transfer encoding is Base64. Decode the attachment first (if you don't have done this so far) and then process the binary data.</p>
","1877","<php><mime><pkcs#7><smime>","1","1","1","2015-07-20 15:34:39","9413110","0","1","911738","","2012-02-23 12:34:35","2012-02-23 12:23:46",""
"41767351","Create pkcs7 signature from file digest","<p>Currently i have a client-server application that, given a PDF file, signs it (with the server certificate), attachs the signature with the original file and returns the output back to the client (all of this is achieved with PDFBox). 
<br>
I have a Signature handler, which is my External Signing Support (where content is the PDF file)</p>

<pre><code>    public byte[] sign(InputStream content) throws IOException {
    try {
        System.out.println(""Generating CMS signed data"");
        CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
        ContentSigner sha1Signer = new JcaContentSignerBuilder(""Sha1WithRSA"").build(privateKey);
        generator.addSignerInfoGenerator(
                new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build())
                        .build(sha1Signer, new X509CertificateHolder(certificate.getEncoded())));
        CMSTypedData cmsData = new CMSProcessableByteArray(IOUtils.toByteArray(content));
        CMSSignedData signedData = generator.generate(cmsData, false);

        return signedData.getEncoded();
    } catch (GeneralSecurityException e) {
        throw new IOException(e);
    } catch (CMSException e) {
        throw new IOException(e);
    } catch (OperatorCreationException e) {
        throw new IOException(e);
    }
}
</code></pre>

<p>It works fine, but i was thinking - what if the PDF file is too big to be uploaded? ex: 100mb... it would take forever!
Given that, i am trying to figure out, if instead of signing the PDF file, is it possible to just sign the Hash (ex SHA1) of that file and than the client puts it all together in the end?</p>

<p><strong>Update:</strong></p>

<p>I have been trying to figure this out, and now my signing method is:</p>

<pre><code>    @Override
public byte[] sign(InputStream content) throws IOException {
    // testSHA1WithRSAAndAttributeTable
    try {
        MessageDigest md = MessageDigest.getInstance(""SHA1"", ""BC"");
        List&lt;Certificate&gt; certList = new ArrayList&lt;Certificate&gt;();
        CMSTypedData msg = new CMSProcessableByteArray(IOUtils.toByteArray(content));

        certList.add(certificate);

        Store certs = new JcaCertStore(certList);

        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

        Attribute attr = new Attribute(CMSAttributes.messageDigest,
                new DERSet(new DEROctetString(md.digest(IOUtils.toByteArray(content)))));

        ASN1EncodableVector v = new ASN1EncodableVector();

        v.add(attr);

        SignerInfoGeneratorBuilder builder = new SignerInfoGeneratorBuilder(new BcDigestCalculatorProvider())
                .setSignedAttributeGenerator(new DefaultSignedAttributeTableGenerator(new AttributeTable(v)));

        AlgorithmIdentifier sha1withRSA = new DefaultSignatureAlgorithmIdentifierFinder().find(""SHA1withRSA"");

        CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
        InputStream in = new ByteArrayInputStream(certificate.getEncoded());
        X509Certificate cert = (X509Certificate) certFactory.generateCertificate(in);

        gen.addSignerInfoGenerator(builder.build(
                new BcRSAContentSignerBuilder(sha1withRSA,
                        new DefaultDigestAlgorithmIdentifierFinder().find(sha1withRSA))
                                .build(PrivateKeyFactory.createKey(privateKey.getEncoded())),
                new JcaX509CertificateHolder(cert)));

        gen.addCertificates(certs);

        CMSSignedData s = gen.generate(new CMSAbsentContent(), false);
        return new CMSSignedData(msg, s.getEncoded()).getEncoded();

    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        throw new IOException(e);
    }

}
</code></pre>

<p>And i am merging the signature with the PDF with pdfbox</p>

<pre><code>            ExternalSigningSupport externalSigning = document.saveIncrementalForExternalSigning(output);
        byte[] cmsSignature = sign(externalSigning.getContent());
        externalSigning.setSignature(cmsSignature);
</code></pre>

<p>The problem is that Adobe says the signature is invalid because the ""document has been altered or corrupted since it was signed"".
Can anyone help?</p>
","<p>In his update the OP nearly has it right, there merely are two errors:</p>

<ul>
<li><p>He tries to read the <code>InputStream</code> parameter content twice:</p>

<pre><code>CMSTypedData msg = new CMSProcessableByteArray(IOUtils.toByteArray(content));
[...]
Attribute attr = new Attribute(CMSAttributes.messageDigest,
        new DERSet(new DEROctetString(md.digest(IOUtils.toByteArray(content)))));
</code></pre>

<p>Thus, all data had already been read from the stream before the second attempt which consequently returned an empty <code>byte[]</code>. So the message digest attribute contained a wrong hash value.</p></li>
<li><p>He creates the final CMS container in a convoluted way:</p>

<pre><code>return new CMSSignedData(msg, s.getEncoded()).getEncoded();
</code></pre></li>
</ul>

<p>Reducing the latter to what is actually needed, it turns out that there is no need for the <code>CMSTypedData msg</code> anymore. Thus, the former is implicitly resolved.</p>

<p>After re-arranging the digest calculation to the top of the method and additionally switching to SHA256 (as SHA1 is deprecated in many contexts, I prefer to use a different hash algorithm) and allowing for a certificate <code>chain</code> instead of a single <code>certificate</code>, the method looks like this:</p>

<pre><code>// Digest generation step
MessageDigest md = MessageDigest.getInstance(""SHA256"", ""BC"");
byte[] digest = md.digest(IOUtils.toByteArray(content));

// Separate signature container creation step
List&lt;Certificate&gt; certList = Arrays.asList(chain);
JcaCertStore certs = new JcaCertStore(certList);

CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

Attribute attr = new Attribute(CMSAttributes.messageDigest,
        new DERSet(new DEROctetString(digest)));

ASN1EncodableVector v = new ASN1EncodableVector();

v.add(attr);

SignerInfoGeneratorBuilder builder = new SignerInfoGeneratorBuilder(new BcDigestCalculatorProvider())
        .setSignedAttributeGenerator(new DefaultSignedAttributeTableGenerator(new AttributeTable(v)));

AlgorithmIdentifier sha256withRSA = new DefaultSignatureAlgorithmIdentifierFinder().find(""SHA256withRSA"");

CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
InputStream in = new ByteArrayInputStream(chain[0].getEncoded());
X509Certificate cert = (X509Certificate) certFactory.generateCertificate(in);

gen.addSignerInfoGenerator(builder.build(
        new BcRSAContentSignerBuilder(sha256withRSA,
                new DefaultDigestAlgorithmIdentifierFinder().find(sha256withRSA))
                        .build(PrivateKeyFactory.createKey(pk.getEncoded())),
        new JcaX509CertificateHolder(cert)));

gen.addCertificates(certs);

CMSSignedData s = gen.generate(new CMSAbsentContent(), false);
return s.getEncoded();
</code></pre>

<p><em>(<a href=""https://github.com/mkl-public/testarea-pdfbox2/blob/master/src/test/java/mkl/testarea/pdfbox2/sign/CreateSignature.java#L225"" rel=""nofollow noreferrer"">CreateSignature</a> method <code>signWithSeparatedHashing</code>)</em></p>

<p>Used in a fairly minimal signing code frame</p>

<pre><code>void sign(PDDocument document, OutputStream output, SignatureInterface signatureInterface) throws IOException
{
    PDSignature signature = new PDSignature();
    signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);
    signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);
    signature.setName(""Example User"");
    signature.setLocation(""Los Angeles, CA"");
    signature.setReason(""Testing"");
    signature.setSignDate(Calendar.getInstance());
    document.addSignature(signature);
    ExternalSigningSupport externalSigning =
            document.saveIncrementalForExternalSigning(output);
    byte[] cmsSignature = signatureInterface.sign(externalSigning.getContent());
    externalSigning.setSignature(cmsSignature);
}
</code></pre>

<p><em>(<a href=""https://github.com/mkl-public/testarea-pdfbox2/blob/master/src/test/java/mkl/testarea/pdfbox2/sign/CreateSignature.java#L135"" rel=""nofollow noreferrer"">CreateSignature</a> method <code>sign</code>)</em></p>

<p>like this</p>

<pre><code>try (   InputStream resource = getClass().getResourceAsStream(""test.pdf"");
        OutputStream result = new FileOutputStream(new File(RESULT_FOLDER, ""testSignedWithSeparatedHashing.pdf""));
        PDDocument pdDocument = PDDocument.load(resource)   )
{
    sign(pdDocument, result, data -&gt; signWithSeparatedHashing(data));
}
</code></pre>

<p><em>(<a href=""https://github.com/mkl-public/testarea-pdfbox2/blob/master/src/test/java/mkl/testarea/pdfbox2/sign/CreateSignature.java#L116"" rel=""nofollow noreferrer"">CreateSignature</a> test method <code>testSignWithSeparatedHashing</code>)</em></p>

<p>results in properly signed PDFs, as proper at least as the certificates and private key in question are for the task at hand.</p>

<hr>

<p>One remark:</p>

<p>The OP used <code>IOUtils.toByteArray(content))</code> (and so do I in the code above). But considering the OP's starting remark</p>

<blockquote>
  <p>what if the PDF file is too big to be uploaded? ex: 100mb </p>
</blockquote>

<p>doing so is not such a great idea as it loads a big file into memory at once only for hashing. If one really wants to consider the resource footprint of one's application, one should read the stream a few KB at a time and consecutively digest the data using <code>MessageDigest.update</code> and only use <code>MessageDigest.digest</code> at the end to get the result hash value.</p>
","1860","<java><pdfbox><pkcs#7>","3","3","1","2017-01-25 09:50:58","41848320","3","6","2149348","","2017-01-24 16:56:03","2017-01-20 15:39:56",""
"304658","What is the algorithm identifier when using AES in CBC mode with ISO 10126 padding inside of PKCS#7?","<p>I want to use PKCS#7 as a container format for some encrypted, signed content and we need to use AES in CBC mode with ISO 10126 based padding. I can't seem to find a concrete reference to an algorithm identifier to use for this combination. I can invent my own but would then lose interoperability with other tools.</p>
","<p>It turns out that the padding mode does not need to be specified, only the crypto algorithm matters.</p>
","1819","<encryption><standards><aes><pkcs#7>","2","1","3","2011-09-14 16:04:56","5825420","0","1","","","","2008-11-20 08:42:00",""
"304658","What is the algorithm identifier when using AES in CBC mode with ISO 10126 padding inside of PKCS#7?","<p>I want to use PKCS#7 as a container format for some encrypted, signed content and we need to use AES in CBC mode with ISO 10126 based padding. I can't seem to find a concrete reference to an algorithm identifier to use for this combination. I can invent my own but would then lose interoperability with other tools.</p>
","<p>The padding mode does not need to be specified. This is true because PKCS#7 (like many other cryptographic containers) uses ASN.1/BER encoding. As the BER encoding contains the exact length of the message inside the padded plain text, the actual value of the padding doesn't matter.</p>
","1819","<encryption><standards><aes><pkcs#7>","2","4","3","2011-09-14 16:04:56","5825420","0","1","","","","2008-11-20 08:42:00",""
"304658","What is the algorithm identifier when using AES in CBC mode with ISO 10126 padding inside of PKCS#7?","<p>I want to use PKCS#7 as a container format for some encrypted, signed content and we need to use AES in CBC mode with ISO 10126 based padding. I can't seem to find a concrete reference to an algorithm identifier to use for this combination. I can invent my own but would then lose interoperability with other tools.</p>
","<p>I believe if you are using PKCS#7 as your format, the padding is dictated to be, well, ""PKCS7"" padding (n octets of value 'n', see <a href=""http://www.ietf.org/rfc/rfc2315.txt"" rel=""nofollow"">RFC 2315</a>, section 10.3.2).</p>

<p>The algorithm identifier(s) for AES/CBC are given in e.g. <a href=""http://www.ietf.org/rfc/rfc3565.txt"" rel=""nofollow"">RFC 3565</a>:</p>

<pre><code>-- AES information object identifiers --

aes OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840)
               organization(1) gov(101) csor(3)_ nistAlgorithms(4)  1 }

-- AES using CBC-chaining mode for key sizes of 128, 192, 256

id-aes128-CBC OBJECT IDENTIFIER ::= { aes 2 }
id-aes192-CBC OBJECT IDENTIFIER ::= { aes 22 }
id-aes256-CBC OBJECT IDENTIFIER ::= { aes 42 }
</code></pre>

<p>So, e.g. the OID for 128-bit AES in CBC mode is 2.16.840.1.101.3.4.1.2</p>

<p>Technically, these are for <a href=""http://www.ietf.org/rfc/rfc3852.txt"" rel=""nofollow"">CMS</a>, which is essentially the updated PKCS#7.</p>
","1819","<encryption><standards><aes><pkcs#7>","2","1","3","2011-09-14 16:04:56","5825420","0","1","","","","2008-11-20 08:42:00",""
"12438379","Converting BIO* to PKCS7* in C++ using OpenSSL library","<p>I've got a problem regarding BIO* to PKCS7* conversion. I want to call PKCS7_decrypt() function to decrypt a cipher text. Before that, I have this section of code:</p>

<pre><code>in = BIO_new_mem_buf(chEnc, iLength);
if (!in) {
    fprintf(stderr, ""\nError in BIO_new_mem_buf in verifyEC. STDERR: "");
    ERR_print_errors_fp(stderr);
    return 0;
}

p7 = d2i_PKCS7_bio(in, NULL);
if (!p7) {
    fprintf(stderr, ""Error in d2i_PKCS7_bio.\n"");
    ERR_print_errors_fp(stderr);
    return 0;
}
</code></pre>

<p>d2i_PKCS7_bio() always fails and returns this error message:</p>

<p>140172957116064:error:0D0680A8:asn1 encoding routines:ASN1_CHECK_TLEN:wrong tag:tasn_dec.c:1319:
140172957116064:error:0D07803A:asn1 encoding routines:ASN1_ITEM_EX_D2I:nested asn1 error:tasn_dec.c:381:Type=PKCS7</p>

<p>Any idea how to fix it? Is it the problem due to encoding? or is it a conversion problem?</p>

<p>Thanks in advance</p>
","<p>This is probably due to a wrong input format:
d2i_PKCS7_bio expect a binary der PKCS7.</p>

<p>On the other hand, if your input is in a pem format you should call PEM_read_bio_PKCS7 instead.</p>
","1795","<c++><c><openssl><pkcs#7>","0","0","1","2012-09-19 10:06:38","","0","","","","","2012-09-15 14:53:57",""
"39507483","Signing a PDF with adbe.pkcs7.detached","<p>I have a PDF generator written in C, and now I want to add digital signatures to it. I started with a minimal PDF, signed it with <a href=""http://jsignpdf.sourceforge.net/"" rel=""nofollow"">JSignPdf</a>, and am now trying to get my own program to produce a file that Adobe Acrobat Reader will interpret identically. I've checked the <a href=""https://stackoverflow.com/questions/378247/digitally-sign-pdf-files"">Digitally sign PDF files</a> question, but the comments there seemed to conclude that one should use iText instead of trying to do it yourself. I don't want that.</p>

<p><em>Update:</em>
I have indeed also read both the PDF Reference for 1.7 and the ""32000"" specification linked below, but sometimes I get a bit lost by the number of references. Starting with a working example is often the easiest way for me to understand how everything fits together. Sorry for not making this clear in my initial post.</p>

<p>I've gotten Acrobat Reader to acknowledge that there is a signature in the file, but something is still wrong. In the Signature Panel it says ""Signed by Unknown"" instead of using the correct name from the key. When opening ""Signature Properties"" it says ""This signature is invalid because there are errors in the formatting or information contained in this signature"". On the ""Advanced Signature Properties"", the Hash Algorithm is ""Not available"".</p>

<p>The PDF from JSignPdf is correct, according to Acrobat Reader. After telling it to accept my self signed certificate, it displays a nice green checkbox for the signature. To find the minimal additions needed, I've cleared one PDF tag after another, carefully not changing the offset for the remaining tags. This gives the same ""This signature is invalid..."" error message as above, but it still shows ""The signer's identity is valid"", as well as showing the Hash Algorithm as ""SHA1"".</p>

<p>The question is what the reason is for this difference, and if there are any tools that can give a more detailed explanation of what is wrong?</p>

<p>In the /Type/Catalog dictionary, I have an /AcroForm. I've tried putting it both in place and as a reference, but that makes no difference. The /AcroForm contains /SigFlags 3 and /Fields [ x 0 R ], where x is the id of a /Type/Annot with /Subtype/Widget. (The ""endobj"" is moved to the "">>"" line to save some space here.)</p>

<p><em>Update:</em> There are some dictionaries, even though I don't remember their name right now, where the ""in place"" vs ""reference"" is significant. Especially the implementation notes in the 1.7 spec has a few of these, as well as a few ""the spec says this field is optional, but actually it's required"".</p>

<pre><code>2 0 obj &lt;&lt;
 /Type /Catalog
 /Pages 3 0 R
 /AcroForm &lt;&lt;
  /Fields [ 8 0 R ]
  /SigFlags 3
  &gt;&gt;
 &gt;&gt; endobj
</code></pre>

<p>In the /Type/Page object, I have /Annots [ x 0 R ], which seemed to be required to get Acrobat Reader to accept that there was any signature here at all.</p>

<p><em>Update:</em> With a working signature, things change a bit. Without this reference, Acrobat Reader does indeed say the signature is valid, but doesn't show any details about it. With it, the ""Signature Properties"" menu item is enabled again.</p>

<pre><code>4 0 obj &lt;&lt;
 /Type /Page
 /Parent 3 0 R
 /Resources &lt;&lt;
  /ProcSet [/PDF /Text]
  /Font &lt;&lt; /F1 6 0 R &gt;&gt;
  &gt;&gt;
 /MediaBox [0 0 595 842]
 /Contents 5 0 R
 /Annots [ 8 0 R ]
&gt;&gt; endobj
</code></pre>

<p>The /Annot dictionary contains /T(Signature1), /FT/Sig, /Rect[0 0 0 0], and /V y 0 R, where y is a /Type/Sig object. The JSignPdf version also contains ""/F 132"" and ""/P 4 0 R"", but I can't find them in the <a href=""http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf"" rel=""nofollow"">PDF Specification</a>. They don't seem to be required anyway.</p>

<p><em>Update:</em> Ah, I had missed the link from section 12.7.1 to 12.5.2.</p>

<pre><code>8 0 obj &lt;&lt;
 /Subtype/Widget
 /T(Signature1)
 /V 7 0 R
 /Type/Annot
 /FT/Sig
 /Rect [ 0 0 0 0 ]
&gt;&gt; endobj
</code></pre>

<p>The /Type/Sig object contains /Filter/Adobe.PPKLite, /SubFilter/adbe.pkcs7.detached, /M(D:20160907094326+02'00'), a /ByteRange array and a /Contents string.</p>

<p><em>Update:</em> I'm using this combination as it was recommended for PDF/A.</p>

<pre><code>7 0 obj &lt;&lt;
 /Contents &lt;3082031f...&gt;
 /Filter/Adobe.PPKLite
 /Type/Sig
 /ByteRange [ 0 904 2907 527 ]
 /SubFilter/adbe.pkcs7.detached
 /M(D:20160907094326+02'00')
&gt;&gt; endobj 
</code></pre>

<p>The /ByteArray has for values: 0, offset-of-last-byte-before-""&lt;""-in-Contents, offset-of-first-byte-after-"">"", and the length of the remainder of the file. If I take the file from JSignPdf, run this (where buf contains the file data):</p>

<pre><code>SHA1_Init(ctx);
SHA1_Update(ctx, buf + offset1, len1);
SHA1_Update(ctx, buf + offset2, len2);
SHA1_Final(digest, ctx);
</code></pre>

<p>I get the exact same data as in the PKCS7 data for the "":messageDigest"" tag. The same is true for my own file. So, I trust those values to be correct.</p>

<p>Using the same cert and key I get the exact same PKCS7 data, except of course the messageDigest and rsaEncryption hex dumps. However, copying the JSignPdf PKCS7 data to my file (as they are exactly the same length) doesn't work, it still complains about not finding the Hash Algorithm. My PKCS7 data in the JSignPdf works, but of course gives the wrong checksum. So, everything OpenSSL-related is most likely correct, the problem must be in the PDF tags somewhere. Is there a reference I've missed, or some tag or object ordering that must be followed?</p>

<p><strong>Solved:</strong> The only remaining thing to play with at this point was the values for the ByteRange tag. The first length was actually ok. However, the second offset was off by one in the implementation, being 1 too small. Adjusting this, I got a green checkbox for the signature!</p>
","<h3>In short,</h3>

<p>you might have a one-off issue, see at the bold paragraph near the end of the answer. If that turns out not to be your issue, please share the files in question for analysis.</p>

<h3>To begin with,</h3>

<p>please consider reading the specification for a format before attempting to manipulate files in that format.</p>

<p>The PDF specification is ISO 32000-1 (part 2 is under construction), and you can download a free copy with a very few changes (making clear that this is not the ISO copy) on Adobe's web site:</p>

<p><a href=""http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf"" rel=""nofollow noreferrer"">http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf</a></p>

<p>(In the middle of your question text you show that you do know that this document exists but you also show that you have not properly studied it.)</p>

<p>For a first overview on integrated PDF signatures, have a look at <a href=""https://security.stackexchange.com/a/35131/16096"">this answer</a> on Information Security Stack Exchange.</p>

<h3>In detail,</h3>

<p>that been said, let's look at your problems and point you to some appropriate section of the specification:</p>

<blockquote>
  <p>In the /Type/Catalog dictionary, I have an /AcroForm. I've tried putting it both in place and as a reference, but that makes no difference. The /AcroForm contains /SigFlags 3 and /Fields [ x 0 R ], where x is the id of a /Type/Annot with /Subtype/Widget. (The ""endobj"" is moved to the "">>"" line to save some space here.)</p>
</blockquote>

<p>The document catalog is specified in section 7.7.2.</p>

<p>The <strong>AcroForm</strong> dictionary there is specified as</p>

<blockquote>
  <blockquote>
    <p><strong>AcroForm</strong> dictionary <em>(Optional; PDF 1.2)</em> The document‚Äôs <em>interactive form (AcroForm) dictionary</em> (see 12.7.2, ""Interactive Form Dictionary"").</p>
  </blockquote>
</blockquote>

<p>In particular it does not specify whether it is to be a direct object or not. Thus, <em>""that makes no difference""</em> indeed.</p>

<p>The interactive form dictionary is specified in section 12.7.2.</p>

<p>In particular,</p>

<blockquote>
  <blockquote>
    <p><strong>SigFlags</strong> integer <em>(Optional; PDF 1.3)</em> A set of flags specifying various document-level characteristics related to signature fields (see Table 219, and 12.7.4.5, ‚ÄúSignature Fields‚Äù). Default value: 0.</p>
    
    <p>...</p>
    
    <p>1 ""SignaturesExist"" If set, the document contains at least one signature field. This flag allows a conforming reader to enable user interface items (such as menu items or pushbuttons) related to signature processing without having to scan the entire document for the presence of signature fields.</p>
    
    <p>2 ""AppendOnly"" If set, the document contains signatures that may be invalidated if the file is saved (written) in a way that alters its previous contents, as opposed to an incremental update. Merely updating the file by appending new information to the end of the previous version is safe (see H.7, ‚ÄúUpdating Example‚Äù). Conforming readers may use this flag to inform a user requesting a full save that signatures will be invalidated and require explicit confirmation before continuing with the operation.</p>
  </blockquote>
</blockquote>

<p>and</p>

<blockquote>
  <blockquote>
    <p><strong>Fields</strong> array <em>(Required)</em> An array of references to the document‚Äôs root fields(those with no ancestors in the field hierarchy).</p>
  </blockquote>
</blockquote>

<p>and the whole section 12.7 describing interactive forms.</p>

<blockquote>
  <p>In the /Type/Page object, I have /Annots [ x 0 R ], which seemed to be required to get Acrobat Reader to accept that there was any signature here at all.</p>
</blockquote>

<p>Section 12.5 describes annotations.</p>

<p>A signature field is a form field. Form fields can have visualizations on some pages. Such visualizations are <strong>Widget</strong> annotations. If a form field has only one widget annotation, the form field object and the widget object may be merged into a single object.</p>

<p>All the annotations on some page are referenced from the page's <strong>Annots</strong> array.</p>

<p>But no, you can have invisible signatures (they do appear in the Adobe Reader signature panel, merely not in the document) which do not require an annotation referenced from a page.</p>

<blockquote>
  <p>The /Annot dictionary contains /T(Signature1), /FT/Sig, /Rect[0 0 0 0], and /V y 0 R, where y is a /Type/Sig object. The JSignPdf version also contains ""/F 132"" and ""/P 4 0 R"", but I can't find them in the PDF Specification. They don't seem to be required anyway.</p>
</blockquote>

<p>Ah, so you do know the specification. Please use it!</p>

<p><strong>T</strong>, <strong>FT</strong>, and <strong>V</strong> are form field entries, cf. section 12.7.3.</p>

<p><strong>Rect</strong>, <strong>Type</strong>, <strong>F</strong>, and <strong>P</strong> are annotation entries, cf. section 12.5.2.</p>

<blockquote>
  <p>The /Type/Sig object contains /Filter/Adobe.PPKLite, /SubFilter/adbe.pkcs7.detached, /M(D:20160907094326+02'00'), a /ByteRange array and a /Contents string.</p>
</blockquote>

<p>All of these entries are specified ion section 12.8.1 and more extensively in the remainder of 12.8.</p>

<blockquote>
  <p>The /ByteArray has for values: 0, offset-of-last-byte-before-""&lt;""-in-Contents, offset-of-first-byte-after-"">"", and the length of the remainder of the file.</p>
</blockquote>

<p>It is specified as</p>

<blockquote>
  <blockquote>
    <p><strong>ByteRange</strong> array <em>(Required for all signatures that are part of a signature field and usage rights signatures referenced from the UR3 entry in the permissions dictionary)</em> An array of pairs of integers (starting byte offset, length in bytes) that shall describe the exact byte range for the digest calculation. Multiple discontiguous byte ranges shall be used to describe a digest that does not include the signature value (theContents entry) itself.</p>
    
    <p>..</p>
    
    <p>This range should be the entire file, including the signature dictionary but excluding the signature value itself (the <strong>Contents</strong> entry).</p>
  </blockquote>
</blockquote>

<p>(Even though this merely is a recommendation, signatures not following this recommendation usually are not accepted.)</p>

<hr>

<p><strong>Your <em>offset-of-last-byte-before-""&lt;""-in-Contents</em> seems odd, it should be the offset of the ""&lt;"", i.e. the length of the part before the ""&lt;"".</strong></p>

<p>Aside from that you seem to have correctly recognized the values in question. If this is not the cause of your problem, therefore, I assume there are still other problems in your PDF or the signature container you inject. Please share the files in question (e.g. via a public dropbox or google drive share) for further analysis.</p>

<hr>

<p>This all being said, depending on the use case you develop your signing code for you probably should look into PAdES style signatures instead of the good ol'fashioned ones.</p>
","1782","<openssl><pdf-generation><pkcs#7>","2","2","2","2018-02-07 16:57:09","39514099","2","","6834221","","2016-09-16 08:46:32","2016-09-15 09:25:52",""
"39507483","Signing a PDF with adbe.pkcs7.detached","<p>I have a PDF generator written in C, and now I want to add digital signatures to it. I started with a minimal PDF, signed it with <a href=""http://jsignpdf.sourceforge.net/"" rel=""nofollow"">JSignPdf</a>, and am now trying to get my own program to produce a file that Adobe Acrobat Reader will interpret identically. I've checked the <a href=""https://stackoverflow.com/questions/378247/digitally-sign-pdf-files"">Digitally sign PDF files</a> question, but the comments there seemed to conclude that one should use iText instead of trying to do it yourself. I don't want that.</p>

<p><em>Update:</em>
I have indeed also read both the PDF Reference for 1.7 and the ""32000"" specification linked below, but sometimes I get a bit lost by the number of references. Starting with a working example is often the easiest way for me to understand how everything fits together. Sorry for not making this clear in my initial post.</p>

<p>I've gotten Acrobat Reader to acknowledge that there is a signature in the file, but something is still wrong. In the Signature Panel it says ""Signed by Unknown"" instead of using the correct name from the key. When opening ""Signature Properties"" it says ""This signature is invalid because there are errors in the formatting or information contained in this signature"". On the ""Advanced Signature Properties"", the Hash Algorithm is ""Not available"".</p>

<p>The PDF from JSignPdf is correct, according to Acrobat Reader. After telling it to accept my self signed certificate, it displays a nice green checkbox for the signature. To find the minimal additions needed, I've cleared one PDF tag after another, carefully not changing the offset for the remaining tags. This gives the same ""This signature is invalid..."" error message as above, but it still shows ""The signer's identity is valid"", as well as showing the Hash Algorithm as ""SHA1"".</p>

<p>The question is what the reason is for this difference, and if there are any tools that can give a more detailed explanation of what is wrong?</p>

<p>In the /Type/Catalog dictionary, I have an /AcroForm. I've tried putting it both in place and as a reference, but that makes no difference. The /AcroForm contains /SigFlags 3 and /Fields [ x 0 R ], where x is the id of a /Type/Annot with /Subtype/Widget. (The ""endobj"" is moved to the "">>"" line to save some space here.)</p>

<p><em>Update:</em> There are some dictionaries, even though I don't remember their name right now, where the ""in place"" vs ""reference"" is significant. Especially the implementation notes in the 1.7 spec has a few of these, as well as a few ""the spec says this field is optional, but actually it's required"".</p>

<pre><code>2 0 obj &lt;&lt;
 /Type /Catalog
 /Pages 3 0 R
 /AcroForm &lt;&lt;
  /Fields [ 8 0 R ]
  /SigFlags 3
  &gt;&gt;
 &gt;&gt; endobj
</code></pre>

<p>In the /Type/Page object, I have /Annots [ x 0 R ], which seemed to be required to get Acrobat Reader to accept that there was any signature here at all.</p>

<p><em>Update:</em> With a working signature, things change a bit. Without this reference, Acrobat Reader does indeed say the signature is valid, but doesn't show any details about it. With it, the ""Signature Properties"" menu item is enabled again.</p>

<pre><code>4 0 obj &lt;&lt;
 /Type /Page
 /Parent 3 0 R
 /Resources &lt;&lt;
  /ProcSet [/PDF /Text]
  /Font &lt;&lt; /F1 6 0 R &gt;&gt;
  &gt;&gt;
 /MediaBox [0 0 595 842]
 /Contents 5 0 R
 /Annots [ 8 0 R ]
&gt;&gt; endobj
</code></pre>

<p>The /Annot dictionary contains /T(Signature1), /FT/Sig, /Rect[0 0 0 0], and /V y 0 R, where y is a /Type/Sig object. The JSignPdf version also contains ""/F 132"" and ""/P 4 0 R"", but I can't find them in the <a href=""http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf"" rel=""nofollow"">PDF Specification</a>. They don't seem to be required anyway.</p>

<p><em>Update:</em> Ah, I had missed the link from section 12.7.1 to 12.5.2.</p>

<pre><code>8 0 obj &lt;&lt;
 /Subtype/Widget
 /T(Signature1)
 /V 7 0 R
 /Type/Annot
 /FT/Sig
 /Rect [ 0 0 0 0 ]
&gt;&gt; endobj
</code></pre>

<p>The /Type/Sig object contains /Filter/Adobe.PPKLite, /SubFilter/adbe.pkcs7.detached, /M(D:20160907094326+02'00'), a /ByteRange array and a /Contents string.</p>

<p><em>Update:</em> I'm using this combination as it was recommended for PDF/A.</p>

<pre><code>7 0 obj &lt;&lt;
 /Contents &lt;3082031f...&gt;
 /Filter/Adobe.PPKLite
 /Type/Sig
 /ByteRange [ 0 904 2907 527 ]
 /SubFilter/adbe.pkcs7.detached
 /M(D:20160907094326+02'00')
&gt;&gt; endobj 
</code></pre>

<p>The /ByteArray has for values: 0, offset-of-last-byte-before-""&lt;""-in-Contents, offset-of-first-byte-after-"">"", and the length of the remainder of the file. If I take the file from JSignPdf, run this (where buf contains the file data):</p>

<pre><code>SHA1_Init(ctx);
SHA1_Update(ctx, buf + offset1, len1);
SHA1_Update(ctx, buf + offset2, len2);
SHA1_Final(digest, ctx);
</code></pre>

<p>I get the exact same data as in the PKCS7 data for the "":messageDigest"" tag. The same is true for my own file. So, I trust those values to be correct.</p>

<p>Using the same cert and key I get the exact same PKCS7 data, except of course the messageDigest and rsaEncryption hex dumps. However, copying the JSignPdf PKCS7 data to my file (as they are exactly the same length) doesn't work, it still complains about not finding the Hash Algorithm. My PKCS7 data in the JSignPdf works, but of course gives the wrong checksum. So, everything OpenSSL-related is most likely correct, the problem must be in the PDF tags somewhere. Is there a reference I've missed, or some tag or object ordering that must be followed?</p>

<p><strong>Solved:</strong> The only remaining thing to play with at this point was the values for the ByteRange tag. The first length was actually ok. However, the second offset was off by one in the implementation, being 1 too small. Adjusting this, I got a green checkbox for the signature!</p>
","<p>A certificate is always certified by a certification authority. So, a certificate is signed by an authority. To check a certificate, means to verify this signature and so you need the authority certificate witch must be avalable to process in some root CA.
Your signing pdf certifiacte is self certified. You need to put your self-signed certificate in root CA hive in your cert keystore.</p>
","1782","<openssl><pdf-generation><pkcs#7>","2","0","2","2018-02-07 16:57:09","39514099","2","","6834221","","2016-09-16 08:46:32","2016-09-15 09:25:52",""
"33512409","Automate export x509 certificate w/chain from Server 2008 R2 to a p7b file WITHOUT external tools?","<p>I manage the Domain Controllers centrally, but the site admins manage their own digital senders locally. I can easily export an X509 certificate (private key not needed) with the whole chain from a Windows Server 2008 R2 Domain Controller to a p7b file through the wizard:</p>

<p>~~~~~~~~~~~~~~~~~</p>

<p>...5. The Certificate Export Wizard opens. Click Next.</p>

<ol start=""6"">
<li><p>In the Export File Format dialog box, do the following:</p>

<p>a. Select Cryptographic Message Syntax Standard ‚Äì PKCS #7 Certificates (.P7B).</p>

<p>b. Check Include all certificates in the certification path if possible.</p>

<p>c. Click Next.</p></li>
<li><p>In the File to Export dialog box, click Browse.</p></li>
<li><p>In the Save As dialog box, do the following:</p>

<p>a. In the File Name box, type ciroots.p7b.</p>

<p>b. In the Save as type box, select PKCS #7 Certificates (*.p7b).</p>

<p>c. Click Save.</p></li>
<li><p>In the File to Export dialog box, click Next.</p></li>
<li><p>On the Completing the Certificate Export Wizard page, click Finish.</p></li>
</ol>

<p>~~~~~~~~~~~~~~~~~</p>

<p>It works great. The resulting file imports just fine into a digital sender for authentication. It gives the site admins access to the other certs in the chain if they have not already imported them. It does not need to contain the private key, since it works fine without it. </p>

<p>The trouble is, I would need to do this manually, literally dozens of times, once for each business site, since each has their own Domain Controllers, each with their own certificate. There must be a way I can automate this certificate export (PowerShell w/.NET, certutil.exe, etc.). Maybe something that uses System.Security.Cryptography.X509Certificates X509IncludeOption with WholeChain, but I can't get it to work: </p>

<p>$Cert = (dir Cert:\localmachine\my)[0]</p>

<p># PKCS7 cert export with .p7b file extension.</p>

<p>$CertCollection = New-Object </p>

<p>System.Security.Cryptography.X509Certificates.X509Certificate2Collection</p>

<p>$Cert | %{[void]$CertCollection.Add($_)}</p>

<p>$Exported_pkcs7 = $CertCollection.Export('Pkcs7')</p>

<p>$out_FileName = $ENV:COMPUTERNAME + "".p7b""</p>

<p>$My_Export_Path = 'd:\CertFiles\' +  $out_FileName</p>

<p>Set-Content -path $My_Export_Path -Value $Exported_pkcs7 -encoding Byte</p>

<p>With this code, I only get the certificate, not the rest of the certificates in its chain. I don't need the whole script, just the part that duplicates the export w/chain that I can already do manually through the GUI. </p>
","<p>You need to build the certificate chain to get chain certificates and add them to collection:</p>

<pre><code>function Export-Certificate {
[CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [Security.Cryptography.X509Certificates.X509Certificate2]$Certificate,
        [Parameter(Mandatory = $true)]
        [IO.FileInfo]$OutputFile,
        [switch]$IncludeAllCerts
    )
    $certs = New-Object Security.Cryptography.X509Certificates.X509Certificate2Collection
    if ($IncludeAllCerts) {
        $chain = New-Object Security.Cryptography.X509Certificates.X509Chain
        $chain.ChainPolicy.RevocationMode = ""NoCheck""
        [void]$chain.Build($Certificate)
        $chain.ChainElements | ForEach-Object {[void]$certs.Add($_.Certificate)}
        $chain.Reset()
    } else {
        [void]$certs.Add($Certificate)
    }
    Set-Content -Path $OutputFile.FullName -Value $certs.Export(""pkcs7"") -Encoding Byte
}
</code></pre>
","1734","<powershell><x509><pkcs#7><certutil>","3","4","1","2015-11-04 18:55:48","","0","2","","","","2015-11-04 01:54:04",""
"1839596","SignedCms.CheckSignature() with renewed cert -> new serial?","<p>i am using</p>

<p>SignedCms.CheckSignature(certColl, true)</p>

<p>(with only one cert in certColl) to verify the signature of a pkcs-7 message. My problem is that i dont want to change the (public part of the) signers certificate on my server after the signer has renewed his certificate :-( The public key, issuer and subject are remaining unchanged after signer has renewed his certificate! So this has to work - at least in my opinion, even if i¬¥m not a crypto-geek :-)  </p>

<p>..but, unfortunately the .NET-Framework throws a Cryptographic Exception ""Cannot find the original signer"" like the stacktrace says exactly at:</p>

<p>SignerInfo.CheckSignature(X509Certificate2Collection extraStore, Boolean verifySignatureOnly)</p>

<p>This must be because the serial number of the signers certificate has changed and the SignerIdentifier property is readonly and set to IssuerAndSerialNumber. </p>

<p>Does anyone know how workaround this? </p>

<p>Or do i have to implement a ""handmade"" signature verifying with sth like: signedMessage.ComputeSignature(signer, false)?</p>

<p>Thanks in advance and happy programming,
Krile</p>
","<p>For all interested on this issue:</p>

<p>Someone told me that this is due to the PKCS #7 specification, which states that the SubjectKeyIdentifier is always set to IssuerAndSerialNumber. </p>
","1731","<certificate><digital-signature><x509certificate2><pkcs#7>","0","0","1","2009-12-15 13:27:19","1907458","0","1","","","","2009-12-03 12:29:01",""
"25358931","Unable to decrypt AES encrypted string from Objective C","<p>I want encrypt and decrypt in Android and IOS and PHP. </p>

<p>In android and in PHP using </p>

<ul>
<li>Encryption type: AES</li>
<li>Encryption Mode: CBC</li>
<li>Padding : PKCS7Padding</li>
<li>Hash Algorithm: SHA-256</li>
</ul>

<p>when i encrypt and decrypt on android it works perfectly. but when I try to decrypt IOS or PHP encrypted String that is in Base64 or Hex2Binary. On android it decrypt string but first 16 character for IOS case and 19 character for PHP code it doest not decrypt showing other characters. I am pasting android code </p>

<pre><code>            // Ignore this line this is for encoding
            //String input = ""Congratulation, You've sucessfully decoded!"";

            final byte[] iv = new byte[16];
            Arrays.fill(iv, (byte) 0x00);
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

            // When I tried with this its gives ""pad block corrupted"" exception else work as above i told

            /*byte[] key = CommonUtilities.encryptionKey.getBytes(""UTF-8"");
            System.out.println(key.length);
            MessageDigest sha = MessageDigest.getInstance(""SHA-256"");
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); // use only first 128 bit
            System.out.println(key.length);
            System.out.println(new String(key,""UTF-8""));
            SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");*/

            // encryptionKey = ""12345678901234561234567890123456""; Same in IOS and PHP
            SecretKeySpec skeySpec = new SecretKeySpec(CommonUtilities.encryptionKey.getBytes(""UTF-8""), ""AES"");
            Cipher ecipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");

            // Ignore these lines these are for encoding
            /*ecipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);
            byte[] dstBuff = ecipher.doFinal(input.getBytes(""UTF-8""));              
            System.out.println(""encrypted: "" + new String(dstBuff, ""UTF-8"")); 
            String enbin2hex = com.byte2hex(dstBuff);    
            String en = Base64.encodeToString(dstBuff, Base64.DEFAULT);*/    


            // this is Hex2Binay that IOS gives me to decrypt
            // Original Text: ""hello shani how are you doing , Stuck in encryption ?""
            String strBin2Hex = ""30BEF4AB063D0D72F91D8D11A7ADEE1B1EC58F67C4D9CC20F59FB56B8B23B7C665198CFF805897BD1AFB82E578AC82C6C18C0EA909E17540D0B95A81E8446168"";



            ecipher.init(Cipher.DECRYPT_MODE, skeySpec, ivParameterSpec);
            byte[] de = ecipher.doFinal(com.hex2Byte(strBin2Hex));  

            //de = removeTrailingNulls(de);
            //int bytesDecryptedAfter = de.length;

            System.out.println(""decrypted: "" + new String(de, ""UTF-8""));
            // Decrypted String ""igohj&amp;t`hnh""kkr&amp;are you doing , Stuck in encryption ?""
</code></pre>

<p>Here you can see unable to decrypt full string ""hello shani how "" missing characters.</p>

<p>In IOS using </p>

<ul>
<li>AES256</li>
<li><p>kCCOptionPKCS7Padding</p>

<pre><code>// IOS encrypt code
- (NSData *)AES256EncryptWithKey:(NSString *)key {
char keyPtr[kCCKeySizeAES256+1];     bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)




// fetch key data
[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];

 NSUInteger dataLength = [self length];

 //See the doc: For block ciphers, the output size will always be less than or
 //equal to the input size plus the size of one block.
 //That's why we need to add the size of one block here
 size_t bufferSize = dataLength + kCCBlockSizeAES128;
 void *buffer = malloc(bufferSize);

 size_t numBytesEncrypted = 0;
 CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                                  keyPtr, kCCKeySizeAES256,
                                  ""0000000000000000"" /* initialization vector (optional) */,
                                  [self bytes], dataLength, /* input */
                                  buffer, bufferSize, /* output */
                                  &amp;numBytesEncrypted);
 if (cryptStatus == kCCSuccess) {
     //the returned NSData takes ownership of the buffer and will free it on deallocation
     return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
 }

 free(buffer); //free the buffer;
 return nil;
 }
</code></pre></li>
</ul>

<p>Any idea what i am doing wrong.</p>

<p>Thanks for you time</p>
","<p>I see the issues:</p>

<ul>
<li>Cipher mode (CBC in android code) isn't specified on iOS</li>
<li>Algorithm is specified explicitly on iOS (AES128), and not on Android</li>
<li>Algorithm does not accord to the key size on iOS 128/256.</li>
<li>Initial vector is different</li>
</ul>

<p>So, instead of</p>

<pre><code>CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                                  keyPtr, kCCKeySizeAES256,
                                  ""0000000000000000"" /* initialization vector (optional) */,
                                  [self bytes], dataLength, /* input */
                                  buffer, bufferSize, /* output */
                                  &amp;numBytesEncrypted);
 if (cryptStatus == kCCSuccess) {
     //the returned NSData takes ownership of the buffer and will free it on deallocation
     return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
 }
</code></pre>

<p>I would try</p>

<pre><code>char iv[kCCBlockSizeAES128 + 1]; bzero(iv, sizeof(iv))
CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES, kCCOptionPKCS7Padding,
                                  keyPtr, kCCKeySizeAES128,
                                  iv,
                                  [self bytes], dataLength, /* input */
                                  buffer, bufferSize, /* output */
                                  &amp;numBytesEncrypted);
 if (cryptStatus == kCCSuccess) {
     //the returned NSData takes ownership of the buffer and will free it on deallocation
     return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
 }
</code></pre>

<p>Ensure, that Android also uses AES128</p>
","1712","<android><ios><aes><sha256><pkcs#7>","0","3","1","2017-08-07 05:07:57","25361274","10","7","1675469","","2014-08-18 09:46:22","2014-08-18 08:16:14",""
"31163542","Can't find class org.bouncycastle.cms.CMSSignedData","<p>I have to load and verify pkcs7 file in java. I found many tutorials that talk about CMSSignedData but I can't find the package <code>org.bouncycastle.cms.*</code>, there is just <code>org.bouncycastle.asn1.cms.*</code> and it doesn't contain the class CMSSignedData.</p>

<p>I downloaded these libraries: <code>bcprov-jdk15on-152.jar</code>, <code>bcprov-ext-jdk15on-152.jar</code> and <code>bcmail-jdk15on-152.jar</code>.</p>

<p>Is there other package that I didn't add ?</p>
","<p>Finally I found the answer, the <code>bcpkix-jdk15on-152.jar</code> was missing. The class CMSSignedData is embedded in this jar. </p>

<p>Most tutorials that i followed mentioned that only the three jar above are necessary.</p>
","1711","<java><security><bouncycastle><pkcs#7><smime>","0","4","1","2015-07-02 08:46:01","31179712","0","","4800139","","2015-07-01 14:06:38","2015-07-01 14:01:17",""
"9443576","Decode PKCS-7 request","<p>I have a servlet and the content type of my request is of type : application-pkcs-7 </p>

<p>And how do i decode the request ?</p>

<p>Any ideas ?</p>

<p>I learnt that i can use openssl to decode , but not much docs on that . </p>
","<p>That's probably a signature or an encrypted piece of data. It's old name is PKCS-7 (of RSA labs, publicly available standard) but it is also known as CMS (Cryptographic Message Syntax, publicly available RFC). CMS is a container format for different kinds of encryption. You can parse it in Java using the open source Bouncy Castle libraries - ""bcmail"" in particular, but you probably need some kind of key if it is encrypted. If it is signed, you could simply parse the plain text data from it and ignore the signature, I guess, depends on the application really.</p>

<p>[UPDATE] Since 1.47 the necessary functionality is in the PKIX library of Bouncy Castle.</p>
","1701","<java><servlets><encryption><request><pkcs#7>","0","3","2","2013-03-21 12:41:16","9444024","2","","1033422","","2013-03-21 12:41:16","2012-02-25 11:26:36",""
"9443576","Decode PKCS-7 request","<p>I have a servlet and the content type of my request is of type : application-pkcs-7 </p>

<p>And how do i decode the request ?</p>

<p>Any ideas ?</p>

<p>I learnt that i can use openssl to decode , but not much docs on that . </p>
","<p>Should work in this way</p>

<pre><code>CMSSignedData cmsSignedData = new CMSSignedData(byte[] signedData);
CMSProcessable cmsProcessable = cmsSignedData.getSignedContent();
</code></pre>

<p>In my case it didn't though, because of unknown tag entry while parsing data</p>
","1701","<java><servlets><encryption><request><pkcs#7>","0","1","2","2013-03-21 12:41:16","9444024","2","","1033422","","2013-03-21 12:41:16","2012-02-25 11:26:36",""
"2817501","PKCS#7 Signed Code Image extracting","<p>I wanted to extract the Signer Informations from PKCS#7 Signed Code Image using C/CPP. I wanted to know the openssl API's. <a href=""http://bouncycastle.sourcearchive.com/documentation/1.33/jdk1_83_2org_2bouncycastle_2mail_2smime_2test_2SMIMESignedTest_8java-source.html"" rel=""nofollow noreferrer"">I am Able to extract Using bouncy castle (CMSSignedData)</a>.</p>

<p>Please let me know the openssl API's which I can use in C/CPP to extract the each signers and signer informations and verify the Signers.</p>

<p>is there any API like X509_LOOKUP_buffer() instead of X509_LOOKUP_file() ???</p>

<p>Thanks in advance opensid</p>
","<p>I had a similar problem. I had to extract signingTime attribute from a PKCS#7 signature. I couldn't find the ultimate solution on the Internet but I could pick up bits and parts from various places and came up to this. Maybe there is a nicer/better/safer way, it's the first time I amd doing this but it seems to work.</p>

<p>In a function I have p_pkcs7SigSize bytes of PKCS#7 signature in a buffer pointing by const void *p_pkcs7Sig. I got signing time by this. I've removed the error handling, do not use this code verbose!</p>

<pre><code>BIO                         *v_in          = NULL;
PKCS7                       *v_p7          = NULL;
STACK_OF(PKCS7_SIGNER_INFO) *v_signerInfos = NULL;
PKCS7_SIGNER_INFO           *v_signerInfo  = NULL;
ASN1_TYPE                   *v_asn1SigningTime  = NULL;

/* make BIO for input buffer */
v_in = BIO_new_mem_buf( (void*)(uintptr_t) p_pkcs7Sig, p_pkcs7SigSize );

/* make a PKCS7 object of it */
v_p7 = d2i_PKCS7_bio( v_in, NULL);

/* get all signer infos */
v_signerInfos = PKCS7_get_signer_info( v_p7 );

/* if you need all signer infos then loop through all, 
 * count you get by k_PKCS7_SIGNER_INFO_num(v_signerInfos) 
 */

/* get the first signer info */
v_signerInfo = sk_PKCS7_SIGNER_INFO_value(v_signerInfos,0);

/* get signing time */
v_asn1SigningTime = PKCS7_get_signed_attribute( v_signerInfo, NID_pkcs9_signingTime );

/* You should got a v_asn1SigningTime-&gt;type == V_ASN1_UTCTIME, 
 * if yes then the actual value is in the string buffer at
 * v_asn1SigningTime-&gt;value.utctime-&gt;data 
 */

if ( v_in )
{
   BIO_free_all( v_in );
   v_in = NULL;
}
</code></pre>
","1678","<openssl><x509certificate><x509><pkcs#7>","1","0","1","2010-05-21 06:03:21","2871813","0","","","","","2010-05-12 09:31:15",""
"19288627","RC2 and PKCS7 Encryption in iOS and Android","<p>I'm trying to encrypt data using RC2 algorithm with PKCS7 padding in Android and iOS, but results are different.</p>

<p>I need to get the exact results. The KEY and IV are already provided but I'm not sure what to do with them. I need to get the same result as the codes in ios.</p>

<p>Values for </p>

<pre><code>IV = ""11223344""
KEY = ""Sample""
</code></pre>

<p>IOS Code:</p>

<pre><code>NSString *iv = IV ;

NSData *data = [s dataUsingEncoding:NSASCIIStringEncoding];
//key
NSString *key = KEY;

const char *keyPtr = [key cStringUsingEncoding:NSASCIIStringEncoding];
const char *cIv = [iv cStringUsingEncoding:NSASCIIStringEncoding];

NSUInteger dataLength = [data length];

size_t bufferSize = dataLength + kCCBlockSizeRC2;
void *buffer = malloc(bufferSize);
//kCCBlockSizeAES128
size_t numBytesEncrypted = 0;
CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
                                      kCCAlgorithmRC2,
                                      kCCOptionPKCS7Padding,keyPtr,
                                      [key length],
                                      cIv,
                                      [data bytes],
                                      dataLength,
                                      buffer,
                                      bufferSize,
                                      &amp;numBytesEncrypted);
</code></pre>

<p>Android Code:</p>

<pre><code> SecretKeySpec skeySpec = new SecretKeySpec(Constant.RC2_KEY.getBytes(""US-ASCII""), ""PBEWITHSHAAND128BITRC2-CBC"");
 IvParameterSpec iv = new IvParameterSpec(Constant.RC2_IV.getBytes(""US-ASCII""));
 Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
 cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
 byte[] encrypted = cipher.doFinal(data);
 return encrypted;
</code></pre>

<p>With this code, the cipher.init() does not execute and it results to an error. but when i change <strong>""AES/CBC/PKCS7Padding""</strong> or <strong>""AES/CBC/PKCS5Padding""</strong> to <strong>""PBEWITHSHAAND128BITRC2-CBC""</strong> it doesn't. It encrypts the data but different from the ios code's result.</p>

<pre><code> Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
 cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
</code></pre>

<p>Can anyone please help me solve this encryption thingy?</p>
","<p>Your Java code looks quite broken - you certainly don't want to be referencing AES as your algorithm.</p>

<p>The following code will use RC2 correctly. I don't have the capability to test your iOS code, so perhaps there are other problems too.</p>

<pre><code>byte[] iv = ""87654321"".getBytes(""US-ASCII"");
byte[] key = ""SampleKey"".getBytes(""US-ASCII"");
byte[] data = new byte[30]; // for example

SecretKeySpec skeySpec = new SecretKeySpec(key, ""RC2"");

RC2ParameterSpec ivSpec = new RC2ParameterSpec(key.length * 8, iv);

Cipher cipher = Cipher.getInstance(""RC2/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);
byte[] encrypted = cipher.doFinal(data);

// ....
</code></pre>

<p><em>Note the use of <code>RC2ParameterSpec</code>, which is required by the algorithm, plus the reference to <code>PKCS5Padding</code> rather than <code>PKCS7Padding</code>.</em></p>
","1654","<android><ios><encryption><pkcs#7>","1","0","1","2013-10-23 03:44:09","","1","5","1601964","","2013-10-23 03:44:09","2013-10-10 06:30:47",""
"33634379","PKCS #7 detached signature with Python and PyOpenSSL","<p>I need to get a detached PKCS #7 signature of some string in Python, using PyOpenSSL. I've got a key in .p12 file.</p>

<p>So far, I'm trying to do so:</p>

<pre class=""lang-py prettyprint-override""><code> from OpenSSL.crypto import load_pkcs12, sign

 pkcs12 = load_pkcs12(key_dat, key_pwd)
 algo = pkcs12.get_certificate().get_signature_algorithm()
 pkey = pkcs12.get_privatekey()
 sg = sign(pkey, manifest, algo)
</code></pre>

<p>But it's not what required. </p>

<p>I've searched net, but most examples are related to signing email chunks and use M2Crypto. Is there any way of doing it in bare PyOpenSSL?</p>
","<p>The PKCS#7 OpenSSL functions that you need for this do not seem to be exported by the Python OpenSSL wrapper. You could try to do this via the internals of the crypto module, for example like the following snippet:</p>

<pre><code>&gt;&gt;&gt; with open('cleg.p12', 'r') as f:
...   p12data=f.read()
&gt;&gt;&gt; p12=crypto.load_pkcs12(p12data,'passphrase')
&gt;&gt;&gt; signcert=p12.get_certificate()
&gt;&gt;&gt; pkey=p12.get_privatekey()
&gt;&gt;&gt; bio_in=crypto._new_mem_buf(manifest)
&gt;&gt;&gt; PKCS7_DETACHED=0x40
&gt;&gt;&gt; pkcs7=crypto._lib.PKCS7_sign(signcert._x509, pkey._pkey, crypto._ffi.NULL, bio_in, PKCS7_DETACHED)
&gt;&gt;&gt; bio_out=crypto._new_mem_buf()
&gt;&gt;&gt; crypto._lib.i2d_PKCS7_bio(bio_out, pkcs7)
1
&gt;&gt;&gt; sigbytes=crypto._bio_to_string(bio_out)
</code></pre>

<p>After this, <code>sigbytes</code> contains the signature, ASN.1 DER encoded. The constant value for <code>PKCS7_DETACHED</code> is defined in the <code>pkcs7.h</code> header file in OpenSSL.</p>

<p>As you probably know, any identifiers that start with <code>_</code> are internal to the <code>crypto</code> module and are not supposed to be used by you directly. Therefore, this answer is just for illustration purposes. A proper solution (with correct memory management) should be added to the <code>crypto</code> module itself.</p>
","1652","<python><pkcs#7><pyopenssl>","2","6","1","2015-11-16 01:51:02","","0","4","","","","2015-11-10 16:06:40",""
"11311831","Decrypt char* using PKCS7_decrypt() in openssl","<p>I want to encrypt and decrypt using <code>PKCS7_encrypt()</code> and <code>PKCS7_decrypt()</code> functions in openSSL. I have used the example in openSSL Demo. What I want to do is to encrypt a message in the format of <code>char*</code> and decrypt using that <code>char*</code>. I don't want to read and write into file. Here is the code to encrypt, which perfectly works and has no problem:</p>

<pre><code>in = BIO_new_file(""encr.txt"", ""r"");
if (!in)
    return 0;

/* encrypt content */
p7 = PKCS7_encrypt(recips, in, EVP_des_ede3_cbc(), flags);
if (!p7)
    return 0;

char* chEnc = new char[1000];

BIO* memorybio = BIO_new(BIO_s_mem());
BIO* base64bio = BIO_new(BIO_f_base64());
BIO* outbio = BIO_push(base64bio, memorybio);

/* Copy PKCS#7 */
long ll = i2d_PKCS7_bio(outbio, p7);
BIO_flush(outbio);
BIO_set_flags(memorybio, BIO_FLAGS_MEM_RDONLY);
BIO_get_mem_data(memorybio, &amp;chEnc);
cout &lt;&lt; chEnc &lt;&lt; ""\n"";
</code></pre>

<p>Now, when I want to do the reverse and decrypt the <code>char*</code> chEnc, I did as below:</p>

<pre><code>BIO *in = NULL, *out = NULL, *tbio = NULL;
X509 *rcert = NULL;
EVP_PKEY *rkey = NULL;
PKCS7 *p7 = NULL;
int ret = 1;

OpenSSL_add_all_algorithms();
ERR_load_crypto_strings();

/* Read in recipient certificate and private key */
tbio = BIO_new_file(""signer.pem"", ""r"");

if (!tbio)
    return 0;

rcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);
BIO_reset(tbio);
rkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);
if (!rcert || !rkey)
    return 0;

BIO* memorybio = BIO_new(BIO_s_mem());
int iLength = BIO_puts(memorybio, chEnc);

BIO* base64bio = BIO_new(BIO_f_base64());
BIO* inbio = BIO_push(base64bio, memorybio);

/* Copy PKCS#7 */
BIO_flush(inbio);
BIO_set_flags(inbio, BIO_FLAGS_MEM_RDONLY);
p7 = d2i_PKCS7_bio(inbio, &amp;p7);
if (!PKCS7_decrypt(p7, rkey, rcert, out, 0))
    return 0;

ret = 0;

if (ret) {
    fprintf(stderr, ""Error Signing Data\n"");
    ERR_print_errors_fp(stderr);
}

if (p7)
    PKCS7_free(p7);
if (rcert)
    X509_free(rcert);
if (rkey)
    EVP_PKEY_free(rkey);

if (in)
    BIO_free(in);
if (out)
    BIO_free(out);
if (tbio)
    BIO_free(tbio);

return ret;
</code></pre>

<p>The problem is that the <code>PKCS7_decrypt</code> does not work and it does not decrypt into <code>out</code> variable. After the line <code>if (!PKCS7_decrypt(p7, rkey, rcert, out, 0)) return 0;</code> , it returns from the function. Is the procedure to decrypt correct? Shall I use other APIs of openSSL to convert or something? </p>

<p>Looking forward to your suggestions and comments.</p>

<p>Thanks</p>
","<p>Are you on your recipient list? Because you need to be the recipient to decrypt the message. Make sure you use the correct key and certificates.</p>
","1638","<c++><openssl><pkcs#7><openca>","1","0","2","2017-10-10 09:39:05","","0","","1578528","","2017-10-10 09:39:05","2012-07-03 13:19:36",""
"11311831","Decrypt char* using PKCS7_decrypt() in openssl","<p>I want to encrypt and decrypt using <code>PKCS7_encrypt()</code> and <code>PKCS7_decrypt()</code> functions in openSSL. I have used the example in openSSL Demo. What I want to do is to encrypt a message in the format of <code>char*</code> and decrypt using that <code>char*</code>. I don't want to read and write into file. Here is the code to encrypt, which perfectly works and has no problem:</p>

<pre><code>in = BIO_new_file(""encr.txt"", ""r"");
if (!in)
    return 0;

/* encrypt content */
p7 = PKCS7_encrypt(recips, in, EVP_des_ede3_cbc(), flags);
if (!p7)
    return 0;

char* chEnc = new char[1000];

BIO* memorybio = BIO_new(BIO_s_mem());
BIO* base64bio = BIO_new(BIO_f_base64());
BIO* outbio = BIO_push(base64bio, memorybio);

/* Copy PKCS#7 */
long ll = i2d_PKCS7_bio(outbio, p7);
BIO_flush(outbio);
BIO_set_flags(memorybio, BIO_FLAGS_MEM_RDONLY);
BIO_get_mem_data(memorybio, &amp;chEnc);
cout &lt;&lt; chEnc &lt;&lt; ""\n"";
</code></pre>

<p>Now, when I want to do the reverse and decrypt the <code>char*</code> chEnc, I did as below:</p>

<pre><code>BIO *in = NULL, *out = NULL, *tbio = NULL;
X509 *rcert = NULL;
EVP_PKEY *rkey = NULL;
PKCS7 *p7 = NULL;
int ret = 1;

OpenSSL_add_all_algorithms();
ERR_load_crypto_strings();

/* Read in recipient certificate and private key */
tbio = BIO_new_file(""signer.pem"", ""r"");

if (!tbio)
    return 0;

rcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);
BIO_reset(tbio);
rkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);
if (!rcert || !rkey)
    return 0;

BIO* memorybio = BIO_new(BIO_s_mem());
int iLength = BIO_puts(memorybio, chEnc);

BIO* base64bio = BIO_new(BIO_f_base64());
BIO* inbio = BIO_push(base64bio, memorybio);

/* Copy PKCS#7 */
BIO_flush(inbio);
BIO_set_flags(inbio, BIO_FLAGS_MEM_RDONLY);
p7 = d2i_PKCS7_bio(inbio, &amp;p7);
if (!PKCS7_decrypt(p7, rkey, rcert, out, 0))
    return 0;

ret = 0;

if (ret) {
    fprintf(stderr, ""Error Signing Data\n"");
    ERR_print_errors_fp(stderr);
}

if (p7)
    PKCS7_free(p7);
if (rcert)
    X509_free(rcert);
if (rkey)
    EVP_PKEY_free(rkey);

if (in)
    BIO_free(in);
if (out)
    BIO_free(out);
if (tbio)
    BIO_free(tbio);

return ret;
</code></pre>

<p>The problem is that the <code>PKCS7_decrypt</code> does not work and it does not decrypt into <code>out</code> variable. After the line <code>if (!PKCS7_decrypt(p7, rkey, rcert, out, 0)) return 0;</code> , it returns from the function. Is the procedure to decrypt correct? Shall I use other APIs of openSSL to convert or something? </p>

<p>Looking forward to your suggestions and comments.</p>

<p>Thanks</p>
","<p><code>PKCS7_decrypt(p7, rkey, rcert, out, 0)</code> is failing because the BIO ""out"" that you are passing to the routine is a null pointer.</p>

<p>If you do not want to write the output into a file, try passing a memory BIO: </p>

<pre><code>BIO *out = BIO_new(BIO_s_mem());
</code></pre>

<p>Then you can access the decrypted data directly from out, and once you are done with it you can destroy it.</p>
","1638","<c++><openssl><pkcs#7><openca>","1","0","2","2017-10-10 09:39:05","","0","","1578528","","2017-10-10 09:39:05","2012-07-03 13:19:36",""
"45782506","Is there any python package for parsing pkcs7?","<p>I'm extracting features from Android .APK files with <a href=""https://github.com/androguard/androguard"" rel=""nofollow noreferrer"">androguard</a> and right now I need to extract the serial number(*) from its signature file (usually CERT.RSA). I've found <a href=""https://github.com/wbond/asn1crypto"" rel=""nofollow noreferrer"">asn1crypto</a>, but I don't quite understand, how to use it with pkcs7. So is there any python package suitable for this purpose? </p>

<p>(*):
<a href=""https://i.stack.imgur.com/dau6N.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dau6N.png"" alt=""Serial number""></a></p>
","<blockquote>
  <p><strong>Comment</strong>:  I have pkcs7 as a memory object, not a file  </p>
</blockquote>

<p><code>PyOpenSSL</code> does not read from <em>file</em>!</p>

<blockquote>
  <p>OpenSSL.crypto.load_pkcs7_data(type, buffer)</p>
  
  <p>Load pkcs7 data from the string buffer encoded with the type type.<br>
     The type type must either FILETYPE_PEM or FILETYPE_ASN1).</p>
</blockquote>

<p><code>from</code><a href=""https://stackoverflow.com/questions/45104923/pyopenssls-pkcs7-object-provide-very-little-information-how-can-i-get-the-sha1#answer-45111623""><code>SO Answer 45111623</code></a><code>import get_certificates</code>  </p>

<pre><code>from OpenSSL import crypto
pkcs7 = crypto.load_pkcs7_data(crypto.FILETYPE_ASN1, 
                               open('certs/signature.der', 'rb').read())
certs = get_certificates(pkcs7)
for cert in certs:
    print('Subject:{}, Serial Nnumber:{}'.
        format(cert.get_subject(), cert.get_serial_number()))

&gt;&gt;&gt;Subject:&lt;X509Name object '/CN=key1'&gt;, Serial Nnumber:13315126025841024674
&gt;&gt;&gt;Subject:&lt;X509Name object '/CN=key2'&gt;, Serial Nnumber:14142490995367396705
</code></pre>

<hr>

<blockquote>
  <p><strong>Question</strong>: python package for parsing pkcs7?</p>
</blockquote>

<p>You can convert PKCS#7 to PEM using openssl, PEM is readable using <a href=""https://pyopenssl.org/en/stable/api/crypto.html#x509-objects"" rel=""nofollow noreferrer"">PyOpenSSL</a></p>

<pre><code>openssl pkcs7 -print_certs -in sample.p7b -out sample.cer
</code></pre>

<hr>

<p>Read that relevant SO Answer: <a href=""https://stackoverflow.com/a/45111623/7414759"">pyOpenSSL's PKCS7</a></p>
","1605","<android><python><pkcs#7><androguard>","0","3","1","2019-08-27 07:04:00","45786051","0","","5790918","","2017-08-20 14:45:24","2017-08-20 13:08:03",""
"17879682","Decrypt PKCS#7 Message in C#","<p>I have a PKCS#7 message in an <code>EnvelopedCms</code> instance. </p>

<p>I also have a private key loaded from a certificate.</p>

<p>Is there a way after decrypting the <code>EnvelopedCms.RecipientInfos[0].EncryptedKey</code> (with the private key) to use the session key in a managed decryption algorithm to decrypt the <code>EnvelopedCms.ContentInfo.Content</code> ?</p>

<p>P.S: I don't want to use <code>EnvelopedCms.Decrypt()</code>, I know it exists, but I don't want to use it.</p>
","<p>It is easy to check for the <code>EnvelopedCms.ContentEncryptionAlgorithm.Oid.FriendlyName</code> property to know which algorithm was used to encrypt the content. The encryption algorithm is chosen by the Outlook user from (Options -> Trust Center -> Trust Center Settings -> Email Security -> Encrypted Email -> Default Settings). Since the encryption algorithm is typically a symmetric algorithm, the KeySize, BlockSize, SymmetricKey, and Initial Vector are usually needed. The value for BlockSize is known from the algorithm. The KeySize could either be known from the name of the algorithm (e.g. AES256 means the KeySize is 256) or by checking the value of <code>EnvelopedCms.ContentEncryptionAlgorithm.KeyLength</code>. The SymmetricKey is given by assumption. The Initial Vector is found in <code>EnvelopedCms.ContentEncryptionAlgorithm.Parameters</code>.</p>

<p>However, you have to watch for the padding of the content or a ""Length of data is invalid"" exception is thrown. Therefore, there's a padding of 6 characters which must be trimmed before attempting to decrypt using the symmetric cipher, <strong>however, I don't have an authoritative resource why these 6 zero-characters exist and whether is it safe to assume that they are always to be trimmed.</strong></p>

<p>For the RC2-64 algorithm, the KeyLength property returns 0, therefore make sure to set the KeySize property to 64 before invoking the cipher.</p>
","1584","<c#><encryption><pkcs#7>","1","1","1","2013-08-05 05:34:59","17921873","2","","2256464","","2013-08-05 05:34:59","2013-07-26 11:02:14",""
"53139243","Java AES Encryption with CBC and PKCS7Padding","<p>I have been struggling with this for a couple of days now. I'm required to consume an API that takes an encrypted parameter. The API was written in C#. The encryption requested is the following:</p>

<hr>

<p>Algorithm:  AES<br>
Cipher mode:    CBC<br>
Padding mode:   PKCS7<br>
Block size: 128<br>
Key size:   256  </p>

<p>Key: String --> The key is generated by converting a provided string to a byte array of size 32: Encoding.ASCII.GetBytes(‚Ä¶). The API states that the String is generated by them using MD5 hashing function of a string.</p>

<p>IV: IV array is generated by converting a provided string to a byte array of size 16: Encoding.ASCII.GetBytes(‚Ä¶).</p>

<p>Representation of encrypted string: Base64 </p>

<hr>

<p>After searching and trying so many things that were suggested online, I'm still unable to produce the same encrypted value (Specially that PKCS7 is not supported by default and PKCS5 should be working the same, but it's not). Here are some things that I've tried:<br>
1) Using bouncy castle jar to use PKCS7<br>
2) Adding JCE compliance to be able to remove the limit on key and block sizes.  </p>

<p>After contacting them, they sent me an android snippet that's working (which if I run in plain java 8 complains about the provider (NoSuchAlgorithmException: Cannot find any provider supporting AES/CBC/PKCS7Padding)):</p>

<pre><code>public static String encrypt(String value) {
        String plainText = value;
        String escapedString;
        try {
            byte[] key = ENCRYPT_KEY.getBytes(""UTF-8"");
            byte[] ivs = ENCRYPT_IV.getBytes(""UTF-8"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(ivs);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, paramSpec);
            escapedString = Base64.encodeToString(cipher.doFinal(plainText.getBytes(""UTF-8"")), Base64.DEFAULT).trim();

            return escapedString;
        } catch (Exception e) {
            e.printStackTrace();
            return value;
        }
    }  
</code></pre>

<p>Please any help would be really appreciated.</p>

<p>Here's a code snippet from what I tried:</p>

<pre><code>package com.melhem.TestJava;

import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.Security;
import java.util.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class StringFunc {


    final static String key = ""API_KEY_32_CHARs"";
    final static String iv = ""API_IV_16_CHARs"";
    final static String algorithm = ""AES/CBC/PKCS7Padding"";
    private static Cipher cipher = null;
    private static SecretKeySpec skeySpec = null;
    private static IvParameterSpec  ivSpec = null;

    public static void main(String[] args) {
        System.out.println(encrypt(""STRING_TO_ENCODE""));
    }

    private static void setUp(){
        try{
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); 
            skeySpec = new SecretKeySpec(key.getBytes(""ASCII""), ""AES"");
            ivSpec = new IvParameterSpec(iv.getBytes(""ASCII""));
            cipher = Cipher.getInstance(algorithm);
        }catch(NoSuchAlgorithmException | NoSuchPaddingException ex){

            ex.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

    public static String encrypt(String str){
        try{
//            Integer strL = (int) Math.ceil(str.length() / 8.0);
//            Integer strB = strL*8;
//            str = padRight(str, ' ', strB);
            setUp();
            try {
                cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);
                System.out.println(""Block size: "" + cipher.getBlockSize() * 8);
                System.out.println(""Algorithm name: "" + cipher.getAlgorithm());
                System.out.println(""Key size: "" + skeySpec.getEncoded().length * 8);
            } catch (InvalidAlgorithmParameterException ex) {
                ex.printStackTrace();
                return """";
            }
            byte[] enc = cipher.doFinal(str.getBytes(""ASCII""));
            String s = new String(Base64.getEncoder().encode(enc));
            s = s.replace(""+"", ""__plus__"");
            s = s.replace(""/"", ""__slash__"");
            return s;
        }catch(InvalidKeyException | IllegalBlockSizeException | BadPaddingException ex){
            ex.printStackTrace();
            return """";            
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return """";
        }
    }

    public static String padRight(String msg, char x, int l) {
        String result = """";
        if (!msg.isEmpty()) {
            for (int i=0; i&lt;(l-msg.length()); i++) {
                result = result + x;
            }
            result = msg + result;
        }
        return result;
    }
}
</code></pre>
","<p>Java <a href=""https://docs.oracle.com/javase/8/docs/api/javax/crypto/Cipher.html"" rel=""nofollow noreferrer"">Cipher package</a> only supports PKCS#7 padding; <code>AES/CBC/PKCS5Padding</code>. Use this;</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
</code></pre>

<p>The #5 and #7 are interchangeable for the most block ciphers. See the question on <a href=""https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding"">Crypto.StackExchange</a>  </p>

<p>and, for using AES with 256-bit key size;</p>

<p>Java standard cipher library limited to 128-bit key size. You must go and download Java <a href=""https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html"" rel=""nofollow noreferrer"">Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 6</a></p>
","1557","<java><encryption><aes><pkcs#7>","1","0","1","2018-11-04 14:36:57","","3","","2810176","","2018-11-04 14:36:57","2018-11-04 09:11:41",""
"9478164","How to get certificate from pkcs7 file","<p>I have a pkcs#7 file with included signers certificate, CA certificate, CRL. Now, to verify signature from this file I get the certificate from it. I try to do:</p>

<pre><code>HANDLE hFile; 
if(!(hFile = CreateFile(L""c:\\users\\timur\\desktop\\sign_pkcs7.sig"",
                            GENERIC_READ,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL)))
{
    printf(""Error opening file %d\n"", GetLastError());
}

HCERTSTORE hPkcsStore = 0;
if(!(hPkcsStore = CertOpenStore(
                    CERT_STORE_PROV_PKCS7,
                    MY_TYPE,
                    NULL,
                    CERT_STORE_OPEN_EXISTING_FLAG,
                    hFile)))
{
    printf(""Cert not found in pkcs7 store error %d.\n"",GetLastError());
}
</code></pre>

<p>But while calling CertOpenStore program fails with <strong>Access violation reading location 0x0000001c.</strong></p>
","<p>You can use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380264%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">CryptQueryObject</a> to open the P7B file or files in many other formats (the code will be the same as <a href=""https://stackoverflow.com/a/7282440/315935"">here</a>).</p>
","1532","<c++><cryptoapi><pkcs#7>","0","1","1","2012-03-03 11:31:22","","0","","","","","2012-02-28 07:46:51",""
"13518264","Convert message and signature to BouncyCastle CMSSignedData object","<p>I have an X509CertificateObject, a matching RSAPublicKey and managed to create a byte array containing a valid digital certificate for some message object also as a byte array.</p>

<p>Unfortunately the system I'm building upon only accepts <code>CMSSignedData</code> objects as input.
How do I convert my basic building blocks into such a valid <code>CMSSignedData</code> object?</p>

<p>Background:  I'm experimenting with Java Bouncy Castle RSA blind signatures according to <a href=""http://java2s.com/Open-Source/Java/Security/Bouncy-Castle/org/bouncycastle/crypto/test/PSSBlindTest.java.htm"">this example</a> (digest is SHA512) and need to feed the result into the standard signature processing.</p>
","<p>First, you'll probably want to sign your data with a private key. The idea being that the signature should be something only you can create. One you get that the rest should be as follows:</p>

<pre><code>
X509Certificate signingCertificate = getSigningCertificate();
//The chain of certificates that issued your signing certificate and so on
Collection&ltX509Certificate&gt certificateChain = getCertificateChain();
PrivateKey pk = getPrivateKey();
byte[] message = ""SomeMessage"".getBytes();

CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
certificateChain.add(signingCertificate);
generator.addCertificates(new CollectionStore(certificateChain));

JcaDigestCalculatorProviderBuilder jcaDigestProvider = new JcaDigestCalculatorProviderBuilder();
jcaDigestProvider.setProvider(new BouncyCastleProvider());
JcaSignerInfoGeneratorBuilder singerInfoGenerator = new JcaSignerInfoGeneratorBuilder(jcaDigestProvider.build());

AlgorithmIdentifier sigAlgId = new DefaultSignatureAlgorithmIdentifierFinder().find(""SHA1withRSA"");
AlgorithmIdentifier digAlgId = new DefaultDigestAlgorithmIdentifierFinder().find(sigAlgId);
AsymmetricKeyParameter privateKeyParam = PrivateKeyFactory.createKey(pk.getEncoded());
ContentSigner cs = new BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(privateKeyParam);

SignerInfoGenerator sig = singerInfoGenerator.build(cs, signingCertificate);
generator.addSignerInfoGenerator(sig);

CMSSignedData data = generator.generate(new CMSProcessableByteArray(message), true);
</code></pre>
","1474","<java><rsa><digital-signature><bouncycastle><pkcs#7>","5","0","1","2013-02-22 23:05:59","","0","","474189","","2012-11-23 08:36:13","2012-11-22 18:24:40",""
"508538","PHP Encryption openssl_pkcs7_encrypt() failing","<p>I have this code:</p>

<pre><code> $fp = fopen($unenc_path, ""w"");
 fwrite($fp, $msg);
 fclose($fp);

 $easy_access_emails = 'person@##.com';
 $headers =   ""From: support@##.com &lt;support@##.com&gt;\n"" . 
              ""Reply-to: support@##.com\n"" . 
              ""Subject: "" . $subject . ""\n"";

 $key = implode("""", file(""../newcert.pem""));

 $ArrayMessageProperties = explode(""\n"", $headers);

 $unenc_path = '..\\tmp\\'. preg_replace('/[^0-9]/','', microtime()) . rand(0,1000) . ""msg.txt"";
 $enc_path = '..\\tmp\\'. preg_replace('/[^0-9]/','', microtime()) . rand(0,1000) . ""enc.txt"";

 if (openssl_pkcs7_encrypt($unenc_path, $enc_path, $key, $ArrayMessageProperties))
 {
    $info = file_get_contents($enc_path);

    foreach ($easy_access_emails as $email)
    {
         mail($email, $subject, $info, $headers);
    }
} else {
    die(""Failed Encryption"");
}
</code></pre>

<p>Which works correctly on my local dev environment (Macbook running LAMP).  I moved it to a windows server for testing and now <code>openssl_pkcs7_encrypt</code> fails every time.  I assume this is a permissions issue, since the function needs to write to <code>$enc_path</code>; But I've made the directory on the windows server about as open as is possible. (set full control to just about every user / group that might have something to do with it. Anyone know a good method to debug this?  It appears the function simply returns false when it fails with no indication as to why.</p>

<p>Upon further investigation it appears the script has write access the directory.  It writes to the $unenc_path no problem, just fails on the call to <code>openssl_pkcs7_encrypt</code>.</p>

<p><strong>Another update:</strong> I'm using filemon to watch the request some in and i see it opening and writing to the unencrypted file but there's no output for it even trying to write to the encrypted file.</p>

<p>Also added the line that loads the key. I've verified it's loading by echoing it out and it seems to be good.</p>

<p><strong>Another update:</strong>  Watching filemon again, around the time it should be calling <code>openssq_pkcs7_encrypt</code> I'm seeing an entry that it's looking for the unencrypted message in the windows tmp directory.  </p>

<pre><code>w3wp.exe:4172  C:\windows\system32\tmp\04277530010012336..msg.txt 
PATH NOT FOUND  Options: Open Access: Read
</code></pre>
","<p>Are you loading the key in <code>$key</code> somewhere in your code? I can't see it on the snippet</p>
","1473","<php><encryption><permissions><openssl><pkcs#7>","1","1","2","2017-07-07 08:40:10","509051","2","4","424099","Michael Lasky","2017-07-07 08:40:10","2009-02-03 19:29:07",""
"508538","PHP Encryption openssl_pkcs7_encrypt() failing","<p>I have this code:</p>

<pre><code> $fp = fopen($unenc_path, ""w"");
 fwrite($fp, $msg);
 fclose($fp);

 $easy_access_emails = 'person@##.com';
 $headers =   ""From: support@##.com &lt;support@##.com&gt;\n"" . 
              ""Reply-to: support@##.com\n"" . 
              ""Subject: "" . $subject . ""\n"";

 $key = implode("""", file(""../newcert.pem""));

 $ArrayMessageProperties = explode(""\n"", $headers);

 $unenc_path = '..\\tmp\\'. preg_replace('/[^0-9]/','', microtime()) . rand(0,1000) . ""msg.txt"";
 $enc_path = '..\\tmp\\'. preg_replace('/[^0-9]/','', microtime()) . rand(0,1000) . ""enc.txt"";

 if (openssl_pkcs7_encrypt($unenc_path, $enc_path, $key, $ArrayMessageProperties))
 {
    $info = file_get_contents($enc_path);

    foreach ($easy_access_emails as $email)
    {
         mail($email, $subject, $info, $headers);
    }
} else {
    die(""Failed Encryption"");
}
</code></pre>

<p>Which works correctly on my local dev environment (Macbook running LAMP).  I moved it to a windows server for testing and now <code>openssl_pkcs7_encrypt</code> fails every time.  I assume this is a permissions issue, since the function needs to write to <code>$enc_path</code>; But I've made the directory on the windows server about as open as is possible. (set full control to just about every user / group that might have something to do with it. Anyone know a good method to debug this?  It appears the function simply returns false when it fails with no indication as to why.</p>

<p>Upon further investigation it appears the script has write access the directory.  It writes to the $unenc_path no problem, just fails on the call to <code>openssl_pkcs7_encrypt</code>.</p>

<p><strong>Another update:</strong> I'm using filemon to watch the request some in and i see it opening and writing to the unencrypted file but there's no output for it even trying to write to the encrypted file.</p>

<p>Also added the line that loads the key. I've verified it's loading by echoing it out and it seems to be good.</p>

<p><strong>Another update:</strong>  Watching filemon again, around the time it should be calling <code>openssq_pkcs7_encrypt</code> I'm seeing an entry that it's looking for the unencrypted message in the windows tmp directory.  </p>

<pre><code>w3wp.exe:4172  C:\windows\system32\tmp\04277530010012336..msg.txt 
PATH NOT FOUND  Options: Open Access: Read
</code></pre>
","<p>Turned out Windows / <code>openssl_pkcs7_encrypt</code> didn't like that relative path, giving a full path after messing with forward and backslashes (<code>/. \\</code>) for a bit fixed it.  </p>
","1473","<php><encryption><permissions><openssl><pkcs#7>","1","4","2","2017-07-07 08:40:10","509051","2","4","424099","Michael Lasky","2017-07-07 08:40:10","2009-02-03 19:29:07",""
"4513155","How to extract pkcs7 envelop contents and verify digital signature?","<p>I want to verify the digital signature of the pkcs7 envelop .
PKCS7 envelop has message content,signer certificate, signature in it.
How to extract this parts ?
And how to verify digital signature ?</p>

<p>Also I want to check the authenticity of the signer certificate which is a x509 digital certificate .</p>
","<p>If you have the PKCS7 message in an OpenSSL <code>PKCS7 *</code> object, you can simply use <code>PKCS7_verify()</code>.  It will verify the signature and the certificate using the supplied trusted certificate store.</p>

<p>If the message is in <code>S/MIME</code> format, the <code>SMIME_read_PKCS7()</code> function can be used to turn it into a <code>PKCS7 *</code> object.</p>
","1464","<c><openssl><x509certificate><pkcs#7>","0","2","1","2014-04-04 13:23:11","","0","","608639","","2014-04-04 13:23:11","2010-12-22 19:54:51",""
"9224757","How can I extract signature from pkcs7 envelop?","<p>I want to extract signature from pkcs7 envelop.
How can i do it ?</p>
","<p>Use <code>STACK_OF(PKCS7_SIGNER_INFO) *PKCS7_get_signer_info(PKCS7 *p7)</code> to retrieve the individual SignerInfos contained in your PKCS7.
To get the actual signature from an individual SignerInfo, you will have to access the corresponding pointer manually. PKCS7_SIGNER_INFO is defined as:</p>

<pre><code>typedef struct pkcs7_signer_info_st
{
ASN1_INTEGER            *version;   /* version 1 */
PKCS7_ISSUER_AND_SERIAL     *issuer_and_serial;
X509_ALGOR          *digest_alg;
STACK_OF(X509_ATTRIBUTE)    *auth_attr; /* [ 0 ] */
X509_ALGOR          *digest_enc_alg;
ASN1_OCTET_STRING       *enc_digest;
STACK_OF(X509_ATTRIBUTE)    *unauth_attr;   /* [ 1 ] */

/* The private key to sign with */
EVP_PKEY            *pkey;
} PKCS7_SIGNER_INFO;
</code></pre>

<p>The correct field is (slightly misleading) <code>enc_digest</code>.</p>
","1443","<openssl><pkcs#7>","2","4","1","2012-02-11 06:13:51","9238285","0","","","","","2012-02-10 08:22:01",""
"15095773","CMS digital signature with JavaCard","<p><strong>What I want</strong></p>

<p>To create a detached digital signature in standard format (CMS / CAdES-EPES).</p>

<p><strong>How I create digital signature now</strong></p>

<p>I create hash from document (SHA-256), get hash algorithm ID and give it all into a message, that is sent to smartcard (JavaCard). Detached signature is generated for this message(RSA-512) and sent back. I am able to verify this signature using pure Java (so far no BouncyCastle) using code:</p>

<pre><code>RSAPublicKey pubK = (RSAPublicKey) cert.getPublicKey();
Signature sig = Signature.getInstance(""SHA256withRSA"", ""BC"");
sig.initVerify(pubK);
//load signed file and update sig
...
sig.verify(signedMessage)
</code></pre>

<p><strong>Problems</strong></p>

<p>My goal is to get CMS(PKCS#7) signature from already signed data. Hovever, as mentioned here -> <a href=""https://stackoverflow.com/questions/12796545/how-can-we-convert-pkcs1-to-pkcs-7-if-i-have-the-certificate"">How can we Convert PKCS#1 to PKCS #7 if I have the Certificate?</a> - it is not that easy to ""convert"" to CMS beacuse of signed attributes. Well, let's just say, I want to try it anyway (just to have backup solution). First I tried to use BouncyCastle. However, I couldn't find way to do it with already signed data and with no access to primary key (as it is on smartcard a CANNOT be exported). So i tried it with native java libraries like this:</p>

<pre><code>X500Name xName = X500Name.asX500Name(cert.getSubjectX500Principal());
BigInteger serial   = cert.getSerialNumber();
AlgorithmId digestAlgorithmId = new AlgorithmId(AlgorithmId.SHA512_oid);
AlgorithmId signAlgorithmId = new AlgorithmId(AlgorithmId.RSAEncryption_oid);

//SignerInfo
SignerInfo sInfo = new SignerInfo(xName, serial, digestAlgorithmId, signAlgorithmId, signatureBytes);
//Create ContentInfo
ContentInfo cInfo = new ContentInfo(ContentInfo.DATA_OID, new DerValue(DerValue.tag_OctetString, dataToSign));
//create PKCS7 signature
PKCS7 p7 = new PKCS7(new AlgorithmId[] { digestAlgorithmId }, cInfo,
        new java.security.cert.X509Certificate[] { cert },
        new SignerInfo[] { sInfo });
//Write PKCS7 to bYteArray
ByteArrayOutputStream bOut = new DerOutputStream();
p7.encodeSignedData(bOut);
byte[] encodedPKCS7 = bOut.toByteArray();
</code></pre>

<p>This approach seems ""not right"" to me to be honest and I was not even able to verify it using PKCS7.verify() method (it returns null, which is unsuccessfull verification and no exceptions are thrown).</p>

<p>So my questions are:</p>

<ol>
<li><strong>Is there any way to get directly a CMS signature from JavaCard?</strong></li>
<li><strong>Is it possible to create CMS signature from already generated signature only with signers certificate (without acces to private key)?</strong></li>
<li><strong>Do you see any problem with ""conversion"" code above?</strong> </li>
<li><strong>Do you know any tool, that can be used to verify detached signatures? (to be able to check my outcomes)</strong></li>
</ol>

<p>A was looking for answers for 2 weeks now and I am really desperate. Thanks for ANY kind of information/help.</p>
","<blockquote>
  <p>(1) Is there any way to get directly a CMS signature from JavaCard?</p>
</blockquote>

<p>As JavaCards are quite versatile if you are the one programming them, that just might be possible. The communication required to retrieve those CMS containers, though, would be quite proprietary, most likely only usable by your code (which can be good or bad for you; for the customer it generally is bad) and by code from people hacking your solution.</p>

<blockquote>
  <p>(2) Is it possible to create CMS signature from already generated signature only with signers certificate (without acces to private key)?</p>
</blockquote>

<p>You can create very primitive CMS signature containers if you already have PKCS#1 signatures, cf. the question <a href=""https://stackoverflow.com/questions/12796545/how-can-we-convert-pkcs1-to-pkcs-7-if-i-have-the-certificate"">How can we Convert PKCS#1 to PKCS #7 if I have the Certificate</a> you refer to.</p>

<p>If you intend to be interoperable with other signature verification software, though, such primitive signatures (which have a huge potential for manipulation) most likely will be rejected.</p>

<blockquote>
  <p>(3) Do you see any problem with ""conversion"" code above?</p>
</blockquote>

<p>Please also supply sample PKCS#1 input signatures and sample CMS results. Furthermore, as @owlstead commented, <em>You should not use Sun inner classes, they may be altered, renamed or even removed without further notice.</em> (I actually would prefer to replace <em>should</em> by <em>shall</em>.)</p>

<blockquote>
  <p>(4) Do you know any tool, that can be used to verify detached signatures? (to be able to check my outcomes)</p>
</blockquote>

<p>OpenSSL contains verification tools. Furthermore there are many web services providing signature verification services. Which of them would be appropriate for you, does very much depend on the PKI and legal environment of your signatures.</p>
","1443","<digital-signature><pkcs#7><javacard>","0","1","1","2013-02-27 11:47:27","15111330","4","","-1","","2017-05-23 11:51:22","2013-02-26 17:46:04",""
"32477436","Decrypt PKCS7 in Ruby on Rails","<p>I try to decrypt PKCS7 data, but always receive error <code>OpenSSL::PKCS7::PKCS7Error - wrong content type</code> on method <code>""pkcs7.decrypt(key, cer)""</code>.</p>

<p>example:</p>

<pre><code>cer = OpenSSL::X509::Certificate.new(File.read(""path/cert.cer""))
key = OpenSSL::PKey::RSA.new(File.read(""path/private.key""), ""111111"")
crypted_data = File.read('path/pkcs7') # contains xml-file and signature ""-----BEGIN PKCS7----- ... -----END PKCS7-----""
pkcs7 = OpenSSL::PKCS7.new(crypted_data)
decrypted_data = pkcs7.decrypt(key, cer) # error is here
</code></pre>

<p>need help! how to get data from the encrypted string?</p>

<p>updated:
on bash I can solve this task by following code: </p>

<pre><code>openssl smime -verify -noverify -inform PEM -nointern -certfile ""path/cert.cer"" -CAfile ""path/cert.cer"" &lt; path/pkcs7
</code></pre>

<p>returns xml file.</p>
","<p>Solution founded!!!</p>

<pre><code>cert_store = OpenSSL::X509::Store.new
my_cert =  OpenSSL::X509::Certificate.new(File.read(""remote.cer""))
signature = OpenSSL::PKCS7.new(File.read('pkcs7-resp.file'))
signature.verify([my_cert], cert_store, nil, OpenSSL::PKCS7::NOVERIFY)
signature.data
</code></pre>
","1426","<ruby><openssl><pkcs#7>","1","4","1","2015-09-10 21:38:21","32512030","0","","1150504","","2015-09-09 12:59:30","2015-09-09 10:46:08",""
"21029101","Decrypting CMS Using OpenSSL in Python","<p>I am currently trying to decrypt some CMS encrypted text with Python.  I have been unable to find a library that can use the CMS implementation in OpenSSL (Tried M2Crypto, PyOpenSSL, PyCrypto).  </p>

<p>The messages being sent to me contain data encrypted with the following Java:</p>

<pre><code>public static byte[] cmsEncrypt(byte[] data, Certificate cert) throws NoSuchAlgorithmException, NoSuchProviderException, CMSException, IOException {
    CMSEnvelopedDataGenerator gen = new CMSEnvelopedDataGenerator();
    gen.addKeyTransRecipient((X509Certificate) cert);
    CMSProcessable cmsData = new CMSProcessableByteArray(data);
    CMSEnvelopedData enveloped = gen.generate(cmsData, CMSEnvelopedDataGenerator.AES128_CBC, 128, ""BC"");
    return enveloped.getEncoded();
}
</code></pre>

<p>This Java contains some deprecated methods, which I unfortunately have no control over.  Is there a Python OpenSSL module that I can use that will decrypt this CMS encrypted data?  As of right now, I am shelling out and using the bash OpenSSL commands to decrypt, with this Python:</p>

<pre><code>from subprocess import call
decrypt = call(['openssl', 'cms', '-decrypt', '-binary', '-inkey', 'key.pem', '-in', 'message.msg'])
</code></pre>

<p>I would prefer to do this entirely in Python without having to use the shell OpenSSL commands.</p>
","","1421","<python><openssl><pkcs#7>","4","","0","2014-01-09 19:13:42","","2","2","","","","2014-01-09 19:13:42",""
"28308401","SignedCms.CheckSignature checks the signature against which certificates?","<p>I have a signed message and I want to know against what certificate is this code checking the signature.
Does the SignedCms always have the signing certificate in it (and it is used to verify the signature) or sometimes the certificate isn't inside the message and it is taken from the verifying machine Certificate Store's?
Basically I'm interested in identifying who is the User that signed that message.</p>

<p>Here is the example of code that makes that verification (from msdn: <a href=""https://msdn.microsoft.com/en-us/library/aedbc064(v=vs.110).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/aedbc064(v=vs.110).aspx</a> )</p>

<pre><code>// Create a ContentInfo object from the inner content obtained independently from encodedMessage.
ContentInfo contentInfo = new ContentInfo(innerContent);
// Create a new, detached SignedCms message.
SignedCms signedCms = new SignedCms(contentInfo, true);
// encodedMessage is the encoded message received from  the sender.
signedCms.Decode(encodedMessage);
// Verify the signature without validating the certificate.
signedCms.CheckSignature(true); //&lt;-- Here is the verification
</code></pre>

<p>Thank you, and sorry for my poor english.</p>
","<p>SignedCms is represented by an ASN.1 structure SignedData defined in RFC 2315</p>

<pre><code> SignedData ::= SEQUENCE {
     version Version,
     digestAlgorithms DigestAlgorithmIdentifiers,
     contentInfo ContentInfo,
     certificates
        [0] IMPLICIT ExtendedCertificatesAndCertificates
          OPTIONAL,
     crls
       [1] IMPLICIT CertificateRevocationLists OPTIONAL,
     signerInfos SignerInfos }
</code></pre>

<p>Property <code>certificates</code> as described by RFC 2315</p>

<blockquote>
  <p>is a set of PKCS #6 extended certificates and X.509 certificates. It
  is intended that the set be sufficient to contain chains from a
  recognized ""root"" or ""top-level certification authority"" to all of the
  signers in the signerInfos field. There may be more certificates than
  necessary, and there may be certificates sufficient to contain chains
  from two or more independent top-level certification authorities.
  There may also be fewer certificates than necessary, if it is expected
  that those verifying the signatures have an alternate means of
  obtaining necessary certificates (e.g., from a previous set of
  certificates).</p>
</blockquote>

<p>But it is optional.</p>

<p>signerInfos is described as</p>

<blockquote>
  <p>signerInfos is a collection of per-signer information. There may be any number of elements in the collection, including zero.</p>
</blockquote>

<p>SignerInfo contains IssuerAndSerialNumber element that describes what certificate was used to sign the content.</p>

<p>More info in <a href=""http://tools.ietf.org/html/rfc2315"" rel=""nofollow"">RFC 2315</a></p>

<p>In c# you can get the certificate with this code:</p>

<pre><code>signedCms.SignerInfos[0].Certificate
</code></pre>
","1397","<c#><x509certificate2><pkcs#7>","1","1","1","2015-02-04 08:51:10","28317093","0","0","","","","2015-02-03 20:45:12",""
"23986946","Error when verifying a clear signed SMIME message","<p>I've a message like this in file testSmimeMsg.txt:</p>

<pre><code>ABC is our biggest acquisition ever and as you can imagine, customers
and partners alike are eager to hear how we plan to integrate it into
XYZ.  Specifically, how are we going to bring the two traditionally
separate silos of desktop and mobile together?
To help explain our vision for uniting we released a
video describing our architecture and
technology integration plans.  Definitely watch the video to learn more,
and the rest of this blog will give you a summary of our plans and a bit
more color on certain areas.
</code></pre>

<p>I use following command to make a clear signed message:</p>

<pre><code>$ openssl smime -sign -in testSmimeMsg.txt -out testSmimeClearTextMessage.txt -signer sender.pem
</code></pre>

<p>The sender.pem is generated from a .p12 file and it has CERTIFICATE and RSA PRIVATE KEY contents.
Then I use the following command to verify the signed message I just created.</p>

<pre><code>$ openssl smime -verify -in testSmimeClearTextMessage.txt -noverify -out testSmimeVerifiedClearTextMessage.txt
</code></pre>

<p>The result is Verification Successful and content in testSmimeVerifiedClearTextMessage.txt is same as testSmimeMsg.txt. Perfect!
Now Lets say I want to verify the same by the PKCS7_verify() method.
C code</p>

<pre><code>jbyteArray aw_SMIME_Verify_Signature_And_Get_Message(JNIEnv *env, jobject obj, jbyteArray signedMsg, jstring senderCertPath, jstring rootCertPath)
{
    //SenderCertPath and rootCertPath are currently NULL. For now, I just want openssl
    //to extract the signer cert from message and verify message. Root certificate and chain
    //of trust verification etc is ignored for now.

    jbyteArray cmsContent = NULL;


    PKCS7 *pkcs7 = NULL;

    OpenSSL_add_all_algorithms();
    ERR_load_crypto_strings();
    ERR_load_X509_strings();
    ERR_load_PKCS7_strings();
    ERR_load_BIO_strings();

    pkcs7 = getP7FromEncryptedMessage_SMIME(env, signedMsg); //this works. pkcs7 is non null.

    if (pkcs7 == NULL) {
        LOGE (""aw_SMIME_Verify_Signature_And_Get_Message: Error reading p7 from message. Returning"");
        goto exit_free;
    }
    cmsContent = verify_Signature_And_Get_Message(env, pkcs7, senderCertPath, rootCertPath);

    exit_free:
    if (pkcs7) {
        PKCS7_free(pkcs7);
        pkcs7 = NULL;
    }

    return cmsContent;
}

------------------------------
PKCS7 *getP7FromEncryptedMessage_SMIME(JNIEnv *env, jbyteArray encryptedSMIMEMessage) {

    BIO *in = NULL;
    int encryptedMessageLength = 0;
    const unsigned char *encryptedBuf = NULL;
    PKCS7 *p7 = NULL;

    //obtain the p7 structure from the encrypted message
    encryptedMessageLength = env-&gt;GetArrayLength(encryptedSMIMEMessage);                    //get size of encrypted message byte[]
    encryptedBuf = (const unsigned char *)env-&gt;GetByteArrayElements(encryptedSMIMEMessage, 0);                                              //create a buffer of that size
    in = BIO_new(BIO_s_mem());
    BIO_set_mem_eof_return(in, 0);
    BIO_write(in, encryptedBuf, encryptedMessageLength);                                    //create a BIO with the char* of encrypted message

    p7 = SMIME_read_PKCS7(in, NULL);                                            //get the p7 structure

    if(in) {
        BIO_free(in);
    }
    if (encryptedBuf) {
        env-&gt;ReleaseByteArrayElements(encryptedSMIMEMessage, (jbyte *)encryptedBuf, 0);
    }

    return p7;

}
----------------------
jbyteArray verify_Signature_And_Get_Message(JNIEnv *env, PKCS7 *pkcs7, jstring senderCertPath, jstring rootCertPath)
{
    X509* rootCert = NULL;
    X509* senderCert = NULL;
    STACK_OF(X509) *st1 = NULL;
    X509_STORE* m_store = NULL;
    BIO *out = BIO_new(BIO_s_mem());
    BIO_set_fp(out, stdout, BIO_NOCLOSE);
    BUF_MEM *bptr = NULL;
    jbyteArray cmsContent = NULL;
    int cmsLen = 0;

    if(rootCertPath != NULL) {
        rootCert = getCertificateFromPath(env, rootCertPath);
        m_store = X509_STORE_new();
        //TODO: check what to be in cert store
        X509_STORE_add_cert(m_store,rootCert);
    }

    if(senderCertPath != NULL) {
        senderCert = getCertificateFromPath(env, senderCertPath);
        st1 = sk_X509_new_null();
        sk_X509_push(st1, senderCert);
    }
    //st1 and m_store are NULL as they are not used for now.
    int verifyResult = PKCS7_verify( pkcs7, st1, m_store, NULL, out, PKCS7_NOVERIFY);
    if(verifyResult != 1) {   //FAILS HERE!!!!
        LOGE (""verify_Signature_And_Get_Message: Error verifying signer certificate. Returning"");
        LOGE(ERR_error_string(ERR_get_error(), NULL));
        goto exit_free;
    }
    BIO_get_mem_ptr(out, &amp;bptr);

    cmsLen = bptr-&gt;length;
    cmsContent = env-&gt;NewByteArray(cmsLen);
    env-&gt;SetByteArrayRegion(cmsContent, 0, cmsLen, (jbyte *)bptr-&gt;data);

    exit_free:
    if (serverCert) {
        X509_free(serverCert);
        serverCert = NULL;
    }
    if (rootCert) {
        X509_free(rootCert);
        rootCert = NULL;
    }
    if (m_store) {
        X509_STORE_free(m_store);
        m_store = NULL;
    }
    if (st1) {
        sk_X509_pop_free(st1, X509_free);
    }
    if (out) {
        BIO_free_all(out);
        out = NULL;
    }

    return cmsContent;
}
</code></pre>

<p>When run, I get error:</p>

<pre><code> verify_Signature_And_Get_Message: Error verifying signer certificate. Returning
 error:2107507A:PKCS7 routines:PKCS7_verify:no content
</code></pre>

<p>Can someone please tell me whats wrong?
Please note that if I pass a signed-data message, with the code unchanged, it works. I get the verification successful and plaintext data back but when I'm sending a clear signed data, it fails.
Please help.</p>
","<p>I fixed the issue. The problem was that I wasn't using the content parameter of PKCS7_read_SMIME() API. If the message is clear signed, the message content is returned in this parameter which is then needed to be passed to PKCS7_verify() method along with NODETACHED flag. See opeenssl doc for both APIs for more details.</p>
","1381","<openssl><pkcs#7><smime>","0","0","1","2014-06-06 17:29:38","24087536","0","","3645686","","2014-06-02 15:58:53","2014-06-02 03:27:53",""
"48319392","Detached signature in CMSSignedData verifies using Bouncy Castle but NOT using java.security.Signature","<p>I have been traversing the web for some days now to find the cause of this but without success. </p>

<p><strong>I am doing this</strong>:</p>

<ul>
<li>generating fresh certificates (signer cert and his parent)</li>
<li>creating signature using CMSSignedDataGenerator (<strong>bouncycastle 1.45</strong>)</li>
<li>verifying it by java.security.Signature -> FAILS</li>
<li>verifying it by BC classes -> SUCCESS</li>
</ul>

<p><strong>Facts I found out</strong>:</p>

<ul>
<li>Creation and verification of signature uses same algorithm - SHA1withRSA.</li>
<li>No exception is thrown anywhere in the process.</li>
</ul>

<p><strong>Questions</strong>:</p>

<ul>
<li>Any idea what I am doing wrong?</li>
</ul>

<p><strong>Ideas to consider</strong>:</p>

<p>I think that the cause lies in the generation of the signature but I suppose I am doing it according to docs. Or - the validation process may expect some kind of different structure like PKCS1 while the generator provides PKCS7. Nothing actually tells me what to search next.</p>

<p>Here is a piece of code which should illustrate the problem and output (after providing your own certificates and a private key):</p>

<pre><code>import org.bouncycastle.cms.*;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import java.security.PrivateKey;
import java.security.Security;
import java.security.Signature;
import java.security.cert.CertStore;
import java.security.cert.CollectionCertStoreParameters;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import static org.bouncycastle.cms.CMSSignedGenerator.DIGEST_SHA1;
import static org.bouncycastle.jce.provider.BouncyCastleProvider.PROVIDER_NAME;


public final class VerifyCMSSignedData {

    private static final byte[] DATA_TO_BE_SIGNED = ""data"".getBytes();
    private static final String SHA_1_WITH_RSA = ""SHA1WithRSA"";
    private static final boolean DATA_NOT_ATTACHED = false;
    private static final String COLLECTION_STORE_TYPE = ""Collection"";

    private static X509Certificate signer;
    private static PrivateKey signerPrivateKey;
    private static X509Certificate parent;

    private VerifyCMSSignedData() {
    }

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        setUpCertificates();

        shouldVerifySignature();
    }

    public static void shouldVerifySignature() throws Exception {
        CMSSignedData signature = createSignature();

        shouldVerifyBySignature(signature.getEncoded());

        shouldVerifyByBC(signature.getEncoded());
    }

    private static void shouldVerifyByBC(byte[] signatureBytes) {
        boolean verified = false;

        try {
            CMSSignedData cms = new CMSSignedData(new CMSProcessableByteArray(DATA_TO_BE_SIGNED), signatureBytes);
            CertStore certStore = cms.getCertificatesAndCRLs(COLLECTION_STORE_TYPE, PROVIDER_NAME);
            SignerInformationStore signers = cms.getSignerInfos();
            Collection c = signers.getSigners();
            for (Object aC : c) {
                SignerInformation signer = (SignerInformation) aC;
                Collection certCollection = certStore.getCertificates(signer.getSID());
                Iterator certIt = certCollection.iterator();
                X509Certificate cert = (X509Certificate) certIt.next();
                verified = signer.verify(cert, PROVIDER_NAME);
            }
        } catch (Exception e) {
            e.printStackTrace();
            verified = false;
        }

        System.out.println(verified ? ""VERIFIED BY BC"" : ""! Not verified through BC !"");
    }

    private static void shouldVerifyBySignature(byte[] signatureBytes) throws Exception {
        Signature signatureVerifier = Signature.getInstance(SHA_1_WITH_RSA, PROVIDER_NAME);
        signatureVerifier.initVerify(signer.getPublicKey());
        signatureVerifier.update(DATA_TO_BE_SIGNED);
        boolean verified = signatureVerifier.verify(signatureBytes);

        System.out.println(verified ? ""VERIFIED BY SIGNATURE CLASS"" : ""! Not verified by Signature class !"");
    }

    private static CMSSignedData createSignature() throws Exception {
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

        gen.addSigner(signerPrivateKey, signer, DIGEST_SHA1);

        List&lt;X509Certificate&gt; allCerts = new ArrayList&lt;&gt;();
        if (parent != null) {
            allCerts.add(parent);
        }
        allCerts.add(signer);

        CertStore store = CertStore.getInstance(
                COLLECTION_STORE_TYPE,
                new CollectionCertStoreParameters(allCerts),
                PROVIDER_NAME
        );

        gen.addCertificatesAndCRLs(store);

        return gen.generate(new CMSProcessableByteArray(DATA_TO_BE_SIGNED), DATA_NOT_ATTACHED, PROVIDER_NAME);
    }

    private static void setUpCertificates() throws Exception {
        // TODO setup your certificates here
    }
}
</code></pre>

<p><strong>Output</strong>:</p>

<blockquote>
  <p>! Not verified by Signature class !</p>
  
  <p>VERIFIED BY BC</p>
  
  <p>Process finished with exit code 0</p>
</blockquote>
","<p>You are verifying different things. The verification can never be succesful because Java <code>SHA1withRSA</code> verification requires a RSA PKCS#1_v15 signature, but you have generated a CMS signature </p>

<p><a href=""https://tools.ietf.org/html/rfc5652"" rel=""nofollow noreferrer"">CMS</a> encapsulates digital signatures or encrypted messages and some additional elements such as certificates. Your CMS message includes a PCKS#1 signature, but if if you want to verify it directly using the Java Api, note that the signed hash is not computed on the data to be signed. It contains some additional elements such as the reference to signing certificate in ASN.1 syntax, so you would need to compute the hash in the same way</p>
","1376","<java><digital-signature><bouncycastle><verify><pkcs#7>","2","3","2","2018-02-06 01:56:49","48320033","0","1","","","","2018-01-18 10:44:41",""
"48319392","Detached signature in CMSSignedData verifies using Bouncy Castle but NOT using java.security.Signature","<p>I have been traversing the web for some days now to find the cause of this but without success. </p>

<p><strong>I am doing this</strong>:</p>

<ul>
<li>generating fresh certificates (signer cert and his parent)</li>
<li>creating signature using CMSSignedDataGenerator (<strong>bouncycastle 1.45</strong>)</li>
<li>verifying it by java.security.Signature -> FAILS</li>
<li>verifying it by BC classes -> SUCCESS</li>
</ul>

<p><strong>Facts I found out</strong>:</p>

<ul>
<li>Creation and verification of signature uses same algorithm - SHA1withRSA.</li>
<li>No exception is thrown anywhere in the process.</li>
</ul>

<p><strong>Questions</strong>:</p>

<ul>
<li>Any idea what I am doing wrong?</li>
</ul>

<p><strong>Ideas to consider</strong>:</p>

<p>I think that the cause lies in the generation of the signature but I suppose I am doing it according to docs. Or - the validation process may expect some kind of different structure like PKCS1 while the generator provides PKCS7. Nothing actually tells me what to search next.</p>

<p>Here is a piece of code which should illustrate the problem and output (after providing your own certificates and a private key):</p>

<pre><code>import org.bouncycastle.cms.*;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import java.security.PrivateKey;
import java.security.Security;
import java.security.Signature;
import java.security.cert.CertStore;
import java.security.cert.CollectionCertStoreParameters;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import static org.bouncycastle.cms.CMSSignedGenerator.DIGEST_SHA1;
import static org.bouncycastle.jce.provider.BouncyCastleProvider.PROVIDER_NAME;


public final class VerifyCMSSignedData {

    private static final byte[] DATA_TO_BE_SIGNED = ""data"".getBytes();
    private static final String SHA_1_WITH_RSA = ""SHA1WithRSA"";
    private static final boolean DATA_NOT_ATTACHED = false;
    private static final String COLLECTION_STORE_TYPE = ""Collection"";

    private static X509Certificate signer;
    private static PrivateKey signerPrivateKey;
    private static X509Certificate parent;

    private VerifyCMSSignedData() {
    }

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        setUpCertificates();

        shouldVerifySignature();
    }

    public static void shouldVerifySignature() throws Exception {
        CMSSignedData signature = createSignature();

        shouldVerifyBySignature(signature.getEncoded());

        shouldVerifyByBC(signature.getEncoded());
    }

    private static void shouldVerifyByBC(byte[] signatureBytes) {
        boolean verified = false;

        try {
            CMSSignedData cms = new CMSSignedData(new CMSProcessableByteArray(DATA_TO_BE_SIGNED), signatureBytes);
            CertStore certStore = cms.getCertificatesAndCRLs(COLLECTION_STORE_TYPE, PROVIDER_NAME);
            SignerInformationStore signers = cms.getSignerInfos();
            Collection c = signers.getSigners();
            for (Object aC : c) {
                SignerInformation signer = (SignerInformation) aC;
                Collection certCollection = certStore.getCertificates(signer.getSID());
                Iterator certIt = certCollection.iterator();
                X509Certificate cert = (X509Certificate) certIt.next();
                verified = signer.verify(cert, PROVIDER_NAME);
            }
        } catch (Exception e) {
            e.printStackTrace();
            verified = false;
        }

        System.out.println(verified ? ""VERIFIED BY BC"" : ""! Not verified through BC !"");
    }

    private static void shouldVerifyBySignature(byte[] signatureBytes) throws Exception {
        Signature signatureVerifier = Signature.getInstance(SHA_1_WITH_RSA, PROVIDER_NAME);
        signatureVerifier.initVerify(signer.getPublicKey());
        signatureVerifier.update(DATA_TO_BE_SIGNED);
        boolean verified = signatureVerifier.verify(signatureBytes);

        System.out.println(verified ? ""VERIFIED BY SIGNATURE CLASS"" : ""! Not verified by Signature class !"");
    }

    private static CMSSignedData createSignature() throws Exception {
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

        gen.addSigner(signerPrivateKey, signer, DIGEST_SHA1);

        List&lt;X509Certificate&gt; allCerts = new ArrayList&lt;&gt;();
        if (parent != null) {
            allCerts.add(parent);
        }
        allCerts.add(signer);

        CertStore store = CertStore.getInstance(
                COLLECTION_STORE_TYPE,
                new CollectionCertStoreParameters(allCerts),
                PROVIDER_NAME
        );

        gen.addCertificatesAndCRLs(store);

        return gen.generate(new CMSProcessableByteArray(DATA_TO_BE_SIGNED), DATA_NOT_ATTACHED, PROVIDER_NAME);
    }

    private static void setUpCertificates() throws Exception {
        // TODO setup your certificates here
    }
}
</code></pre>

<p><strong>Output</strong>:</p>

<blockquote>
  <p>! Not verified by Signature class !</p>
  
  <p>VERIFIED BY BC</p>
  
  <p>Process finished with exit code 0</p>
</blockquote>
","<p>You was wrong here:</p>

<p><strong>signatureVerifier.update(DATA_TO_BE_SIGNED);</strong></p>

<p>and here:</p>

<p><strong>boolean verified = signatureVerifier.verify(signatureBytes);</strong></p>

<p><a href=""https://stackoverflow.com/a/48320033/7942587"">See pedrofb's answer for more details.</a></p>

<p>Modify your <strong>shouldVerifyBySignature</strong> method to work:</p>

<pre><code>private static void shouldVerifyBySignature(byte[] signatureBytes) throws Exception {
    boolean verified = false;
    CMSSignedData cms = new CMSSignedData(new CMSProcessableByteArray(DATA_TO_BE_SIGNED), signatureBytes);
    CertStore certStore = cms.getCertificatesAndCRLs(COLLECTION_STORE_TYPE, PROVIDER_NAME);
    SignerInformationStore signers = cms.getSignerInfos();
    Collection c = signers.getSigners();
    for (Object aC : c) {
        SignerInformation si = (SignerInformation) aC;
        Signature signatureVerifier = Signature.getInstance(SHA_1_WITH_RSA, PROVIDER_NAME);
        signatureVerifier.initVerify(signer.getPublicKey());


        signatureVerifier.update(si.getEncodedSignedAttributes());
        verified = signatureVerifier.verify(si.getSignature());
    }

    System.out.println(verified ? ""VERIFIED BY SIGNATURE CLASS"" : ""! Not verified by Signature class !"");
}
</code></pre>

<p>I hope this will help you!</p>
","1376","<java><digital-signature><bouncycastle><verify><pkcs#7>","2","2","2","2018-02-06 01:56:49","48320033","0","1","","","","2018-01-18 10:44:41",""
"7476303","conversion from opaque pkcs7 p7m to detached smime","<p>Hi I couldn't find a way to convert an opaque pkcs#7(p7m) in a clear text deatached smime so that the signed content could be processed by regular mime libraries.</p>

<p>I'd like to take p7m file and convert it to an smime message keping a valid signature.</p>

<p>The steps should be:</p>

<ul>
<li><p>extract signed content from p7m</p></li>
<li><p>extract cms structure from p7m</p></li>
<li><p>pack everything in a new smime structure with detached signature</p></li>
</ul>

<p>Is this operation possible ?</p>

<p>I've searched through openssl manuals but I couldn't find a way to do it.</p>
","<p>I was able to convert opaque-signed messages to a detached ones with the following code:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;openssl/evp.h&gt;
#include &lt;openssl/bio.h&gt;
#include &lt;openssl/pkcs7.h&gt;

int main(int argc, char **argv)
{
    BIO *data = NULL, *bin = NULL, *bout = NULL;
    PKCS7 *p7, *p7b;

    OpenSSL_add_all_algorithms();

    bin = BIO_new_file(""opaque.p7m"", ""rb"");
    p7 = SMIME_read_PKCS7(bin, &amp;data);
    p7b = PKCS7_dup(p7);

    data = PKCS7_dataInit(p7, NULL);

    PKCS7_set_detached(p7b, 1);

    bout = BIO_new_file(""detached.p7m"", ""wb"");
    SMIME_write_PKCS7(bout, p7b, data, PKCS7_BINARY | SMIME_DETACHED);
}
</code></pre>

<p>To test the program I generate the opaque.p7m with the following command:</p>

<pre><code>$ openssl smime -sign -in foo.txt -signer my.crt -inkey my.key -nodetach -out opaque.p7m
</code></pre>

<p>To be terse, the code above has no checks. To accept different input formats, you can change <code>SMIME_read_PKCS7</code> to <code>PEM_read_bio_PKCS7</code> (PEM) or <code>d2i_PKCS7_bio</code> (DER).</p>
","1373","<openssl><digital-signature><pkcs#7><smime>","6","1","1","2013-12-04 15:39:24","20379579","0","2","445517","","2013-02-09 15:23:53","2011-09-19 19:34:14",""
"2334536","How do I create an encrypted PayPal button dynamically in Google App Engine?","<p>So far I have found an <a href=""http://jonatkinson.co.uk/paypal-encrypted-buttons-django/"" rel=""nofollow noreferrer"">example</a> for Django that uses <a href=""http://sandbox.rulemaker.net/ngps/m2/"" rel=""nofollow noreferrer"">M2Crypto</a>, but because M2Crypto is based on a C library, it cannot be run on GAE. Does anyone have a working code for creating an encrypted PayPal button dynamically in Google App Engine?</p>

<p>In a nutshell, I need to translate the following Ruby code into Python. It's taken from <a href=""https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&amp;content_ID=developer/library_download_sdks#WPST"" rel=""nofollow noreferrer"">PayPal's Website Payments Standard toolkit</a> for Ruby.</p>

<pre><code>def self.encrypt_data(paypal_cert, my_business_cert, my_business_key,
                      my_business_key_password, myparams  )     
  paypal_cert      = OpenSSL::X509::Certificate.new(paypal_cert)     
  my_business_cert = OpenSSL::X509::Certificate.new(my_business_cert)      
  my_business_key  = OpenSSL::PKey::RSA.new(
    my_business_key,
    my_business_key_password)   
  info = """"
  myparams.each_pair {|key,value| info &lt;&lt; ""#{key}=#{value}\n""}    
  signedInfo       = OpenSSL::PKCS7::sign(
    my_business_cert,
    my_business_key,
    info,
    [],
    OpenSSL::PKCS7::BINARY)
  OpenSSL::PKCS7::encrypt(
    [paypal_cert],
    signedInfo.to_der,
    OpenSSL::Cipher::Cipher::new(""DES3""),
    OpenSSL::PKCS7::BINARY)           
end
</code></pre>
","<p>Have a look to <a href=""http://www.keyczar.org/"" rel=""nofollow"">Keyczar</a> library, it should work on Google App Engine allowing you to sign using <em>RSA</em> and encrypt with <em>DES3</em> .</p>

<p>Check the documentation <a href=""http://keyczar.googlecode.com/svn/trunk/python/doc/pycrypt.pdf"" rel=""nofollow"">here</a>.</p>
","1347","<google-app-engine><encryption><paypal><pkcs#7>","3","0","1","2011-04-21 15:42:53","","0","2","","","","2010-02-25 14:16:37",""
"5997326","Extract pkcs7 (byte[]) from a pdf file using IText or ITextSharp or BouncyCastle","<p>How can I extract, from a pdf signed file, the PKCS7 package encoded, using either IText or BouncyCastle, so i can either store or validate in another framework?
In fact, how can I get, at all, a PKCS7 encoded package from a pdf signed file?</p>
","<p>A friend of mine helped me on getting the answer.</p>

<pre><code>public static byte[] ExtractPKCS7From(string path)
{
    AcroFields acroFields = new PdfReader(path).AcroFields;
    List&lt;string&gt; names = acroFields.GetSignatureNames();

    foreach(var name in names)
    {
        PdfDictionary dict = acroFields.GetSignatureDictionary(name);
        PdfString contents =
            (PdfString)PdfReader.GetPdfObject(dict.Get(PdfName.CONTENTS));

        return contents.GetOriginalBytes();
    }
    return null;
}
</code></pre>

<p>Pretty straight forward, isn't it?</p>
","1344","<c#><java><itextsharp><itext><pkcs#7>","2","1","2","2015-12-21 21:52:26","6022912","0","","141345","","2011-05-16 13:28:38","2011-05-13 20:20:53",""
"5997326","Extract pkcs7 (byte[]) from a pdf file using IText or ITextSharp or BouncyCastle","<p>How can I extract, from a pdf signed file, the PKCS7 package encoded, using either IText or BouncyCastle, so i can either store or validate in another framework?
In fact, how can I get, at all, a PKCS7 encoded package from a pdf signed file?</p>
","<p>Code for Java, do whatever you want with the pkcs7 object! :)</p>

<pre><code>PdfReader r = new PdfReader(fOs);
AcroFields af = r.getAcroFields();
ArrayList&lt;String&gt; listNames = af.getSignatureNames();
for(String x : listNames){
    PdfPKCS7 pkcs7 = af.verifySignature(signature);
}
</code></pre>

<p>Good luck!</p>
","1344","<c#><java><itextsharp><itext><pkcs#7>","2","0","2","2015-12-21 21:52:26","6022912","0","","141345","","2011-05-16 13:28:38","2011-05-13 20:20:53",""
"13660901","pkcs7 with timestamp","<p>I am looking at it for a day now, and I am still baffled. 
I want to add digital signature to a PDF with timestamp from a <em>TSA</em> (TimeStamp Authority). </p>

<p>I am okay with sending the request to a TSA and receiving a binary response, but how do I append that timestamp to my pkcs7 digital signature. </p>

<p>I am using PHP with TCPDF and the <code>openssl_pkcs7_sign()</code> function. 
Do I need to to add the timestamp as an extra certificate?
Thanks!</p>
","<p>With PHP is not possible, afraid.
I would do it in a C++ server side pkcs#7 builder.</p>
","1322","<php><tcpdf><pkcs#7><trusted-timestamp>","4","-2","2","2017-10-26 17:15:38","","3","2","142616","","2012-12-01 19:40:22","2012-12-01 15:35:12",""
"13660901","pkcs7 with timestamp","<p>I am looking at it for a day now, and I am still baffled. 
I want to add digital signature to a PDF with timestamp from a <em>TSA</em> (TimeStamp Authority). </p>

<p>I am okay with sending the request to a TSA and receiving a binary response, but how do I append that timestamp to my pkcs7 digital signature. </p>

<p>I am using PHP with TCPDF and the <code>openssl_pkcs7_sign()</code> function. 
Do I need to to add the timestamp as an extra certificate?
Thanks!</p>
","<p>I have created a simple library project called <strong>phpcmstimestamper</strong> precisely for this purpose, and you can use it like this:</p>

<pre><code>&lt;?php
$originalCmsAsPem = ""-----BEGIN CMS-----
MIIFiAYJKoZIhvcNAQcCoIIFeTCCBXUCAQExDTALBglghkgBZQMEAgEwHQYJKoZI
...
1lUaWopfF7uZf5LXZt2Ru5UPr+51ULJRcEeUTA==
-----END CMS-----"";
$updatedCms = CmsTimestamper::addTimestampToCms($originalCmsAsPem, ""http://tsa.starfieldtech.com"");
</code></pre>

<p>You can get more details and a fully working example at <a href=""https://github.com/hablutzel1/phpcmstimestamper"" rel=""nofollow noreferrer"">https://github.com/hablutzel1/phpcmstimestamper</a>.</p>
","1322","<php><tcpdf><pkcs#7><trusted-timestamp>","4","0","2","2017-10-26 17:15:38","","3","2","142616","","2012-12-01 19:40:22","2012-12-01 15:35:12",""
"21849460","Sign file using .NET OpenSSL wrapper","<p>I was trying to copy this line</p>

<pre><code>openssl smime -sign -signer &lt;chain_crt_file&gt; -in &lt;infile&gt; -out &lt;outfile&gt; -inkey &lt;privatekey&gt; -outform der
</code></pre>

<p>into C# However it didn't turn out to be as easy as I thought. So far I came only this point</p>

<pre><code>OpenSSL.Core.BIO crtBio = OpenSSL.Core.BIO.File(""C:/asl/chain.crt"", ""r"");
OpenSSL.Core.BIO keyBio = OpenSSL.Core.BIO.File(""C:/asl/keydec.txt"", ""r"");
OpenSSL.X509.X509Chain crt = new OpenSSL.X509.X509Chain(crtBio);
OpenSSL.Crypto.RSA key = OpenSSL.Crypto.RSA.FromPrivateKey(keyBio);

String str = ""test"";
byte[] bytes = new byte[str.Length * sizeof(char)];
System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
</code></pre>

<p>Where (hopefully) I'm importing chain certificate and decoded private key. 
Now the thing is how to sign a file and export is as DER. 
OpenSSL.NET wrapper lacks documentation and examples I found on the internet are 'how to encrypt and decrypt messages using public/private key' which is not a case  here.</p>

<p>To get started I tried to sign this ""test"" string (as file in/out should be pretty straightfoward) but I have no clue where to start.</p>

<p>The thing is that I need to <strong>sign</strong> this string thus I will need both key and certificates chain.</p>

<p>Thanks a lot for your help.</p>
","<blockquote>
  <p>To get started I tried to sign this ""test"" string (as file in/out should be pretty straightfoward) but I have no clue where to start.</p>
</blockquote>

<p>The OpenSSL source is probably a good place to start. OpenSSL provides the source for <code>smime</code> in <code>&lt;openssl dir&gt;/apps/smime.c</code>.</p>

<p>OpenSSL's <code>smime</code> utility just calls <code>PKCS7_sign</code> with the appropriate parameters. From around line 688:</p>

<pre><code>else if (operation &amp; SMIME_SIGNERS)
    {
    int i;
    /* If detached data content we only enable streaming if
     * S/MIME output format.
     */
    if (operation == SMIME_SIGN)
        {
        if (flags &amp; PKCS7_DETACHED)
            {
            if (outformat == FORMAT_SMIME)
                flags |= PKCS7_STREAM;
            }
            else if (indef)
                flags |= PKCS7_STREAM;

           flags |= PKCS7_PARTIAL;
           p7 = PKCS7_sign(NULL, NULL, other, in, flags);
           if (!p7)
               goto end;
        }
        ...
</code></pre>

<p>With knowledge of <code>PKCS7_sign</code>, you can visit OpenSSL's docs at <a href=""https://www.openssl.org/docs/crypto/PKCS7_sign.html"" rel=""nofollow""><code>PKCS7_sign(3)</code></a>. Or, you can hunt for an example.</p>

<p>I don't know about the wrapper you are using.</p>
","1300","<c#><.net><openssl><pkcs#7><x509>","2","0","1","2014-02-18 16:20:38","","2","","1597707","","2014-02-18 09:35:24","2014-02-18 09:34:00",""
"23425030","Message-digesting process in PKCS#7 (signature in PDF)","<p>The problem occurs in the verification of the signature in PDF file. It is said in the standard that:</p>

<blockquote>
  <p>The result of the message digest calculation process depends on whether the signedAttrs field is present. When the field is absent, the result is just the message digest of the content as described above. When the field is present, however, the result is the message digest of the complete DER encoding of the SignedAttrs value contained in the signedAttrs field.</p>
</blockquote>

<p>I parsed signature and got <code>signedAttrs</code>:</p>

<pre><code>[0](4 elem)
   SEQUENCE(2 elem)
      OBJECT IDENTIFIER1.2.840.113549.1.9.3            // ContentType
      SET(1 elem)
        OBJECT IDENTIFIER1.2.840.113549.1.7.1
   SEQUENCE(2 elem)
      OBJECT IDENTIFIER1.2.840.113549.1.9.5            // SigningTime
      SET(1 elem)
        UTCTime2014-04-13 02:58:41 UTC
   SEQUENCE(2 elem)
      OBJECT IDENTIFIER1.2.840.113549.1.9.4            // MessageDigest
      SET(1 elem)
        OCTET STRING(20 byte) 194E0BA9C4B9A53D5E9E5B7B94D7DB42BEA4C28F
   SEQUENCE(2 elem)
      OBJECT IDENTIFIER1.2.840.113549.1.9.15
      SET(1 elem)
        SEQUENCE(8 elem)
          SEQUENCE(1 elem)
            OBJECT IDENTIFIER2.16.840.1.101.3.4.1.42
          SEQUENCE(1 elem)
            OBJECT IDENTIFIER2.16.840.1.101.3.4.1.22
          SEQUENCE(1 elem)
            OBJECT IDENTIFIER2.16.840.1.101.3.4.1.2
          SEQUENCE(1 elem)
            OBJECT IDENTIFIER1.2.840.113549.3.7
          SEQUENCE(2 elem)
            OBJECT IDENTIFIER1.2.840.113549.3.2
            INTEGER128
          SEQUENCE(2 elem)
            OBJECT IDENTIFIER1.2.840.113549.3.2
            INTEGER64
          SEQUENCE(1 elem)
            OBJECT IDENTIFIER1.3.14.3.2.7
          SEQUENCE(2 elem)
            OBJECT IDENTIFIER1.2.840.113549.3.2
            INTEGER40
</code></pre>

<p>and DER encoding: </p>

<blockquote>
  <p>A081D8301806092A864886F70D010903310B06092A864886F70D010701301C06092A864886F70D010905310F170D3134303431333032353834315A302306092A864886F70D01090431160414194E0BA9C4B9A53D5E9E5B7B94D7DB42BEA4C28F307906092A864886F70D01090F316C306A300B060960864801650304012A300B0609608648016503040116300B0609608648016503040102300A06082A864886F70D0307300E06082A864886F70D030202020080300D06082A864886F70D0302020140300706052B0E030207300D06082A864886F70D0302020128</p>
</blockquote>

<p>I calculated its digest and compared to the result of decryption of encrypted digest. But it failed.</p>

<p>I should calculate digest on entire <code>signedAttrs</code> field or on some Attributes or on anything else?</p>

<p><strong>Edit</strong>: 
This is <a href=""https://www.mediafire.com/?uypwh54kmgg1g5d"" rel=""nofollow"">PDF file</a> I want to verify</p>
","<blockquote>
  <p>I calculated its digest and compared to the result of decryption of encrypted digest. But it failed.</p>
  
  <p>I should calculate digest on entire signedAttrs field or on some Attributes or on anything else?</p>
</blockquote>

<p>Have you considered that </p>

<blockquote>
  <blockquote>
    <p>the message digest of the complete DER encoding of the SignedAttrs value contained in the signedAttrs field</p>
  </blockquote>
</blockquote>

<p>implies that <strong>it is not the hash of <em>the SignedAttrs value</em> itself but <em>its complete DER encoding</em></strong>? The difference is that the <em>SignedAttrs value</em> is implicitly 0-tagged:</p>

<pre><code>signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL
</code></pre>

<p>while <em>its complete DER encoding</em> is not. The standard even explicitly says this:</p>

<blockquote>
  <blockquote>
    <p>A separate encoding
       of the signedAttrs field is performed for message digest calculation.
       The IMPLICIT [0] tag in the signedAttrs is not used for the DER
       encoding, rather an EXPLICIT SET OF tag is used.  That is, the DER
       encoding of the EXPLICIT SET OF tag, rather than of the IMPLICIT [0]
       tag, MUST be included in the message digest calculation along with
       the length and content octets of the SignedAttributes value.</p>
    
    <p><em>(cf. section 5.4 of both <a href=""https://tools.ietf.org/html/rfc3852#section-5.4"" rel=""nofollow"">RFC 3852</a> and <a href=""https://tools.ietf.org/html/rfc5652#section-5.4"" rel=""nofollow"">RFC 5652</a>)</em></p>
  </blockquote>
</blockquote>

<p>Thus, you have to replace the leading 0xA0 in your</p>

<blockquote>
  <p>A081D8301806092A864886F70D010903310B06092A864886F70D010701301C06092A864886F70...</p>
</blockquote>

<p>accordingly before calculating the digest.</p>

<p>Have you furthermore considered that <em>result of decryption of encrypted digest</em> (I hope you are talking about old-fashioned RSA signing, otherwise <em>decryption</em> is not helpful) is <strong>not</strong> the naked digest but instead the digest wrapped in a <code>DigestInfo</code> structure?</p>

<pre><code>DigestInfo ::= SEQUENCE {
  digestAlgorithm DigestAlgorithmIdentifier,
  digest Digest }
</code></pre>

<p><strong>ADDITION</strong></p>

<p>Even after these clarifications there were some problems, cf. the comment</p>

<blockquote>
  <p>I calculated digest on the complete DER encoding but it was different from digest after decrypted</p>
</blockquote>

<p>Thus, here a bit of Java code using Bouncy Castle (maybe not used optimally, I'm more at home with a propriety crypto library) to calculate the hash of the signed attributes and extract the hash from the RSA signature:</p>

<pre><code>    // The CMS container
    CMSSignedData cms = new CMSSignedData(bytes);

    // Calculating the digest of the signed attributes
    SignerInformation signerInformation = (SignerInformation) (cms.getSignerInfos().getSigners().iterator().next());
    byte[] derSignedAttributes = signerInformation.getEncodedSignedAttributes();
    MessageDigest sha1 = MessageDigest.getInstance(""SHA-1"");
    byte[] derSignedAttributesHash = sha1.digest(derSignedAttributes);

    // Retrieving the public key from the (single) certificate in the container
    X509CertificateHolder cert = (X509CertificateHolder) cms.getCertificates().getMatches(new Selector() {
        public boolean match(Object arg0) { return true; }
        public Object clone()             { return this; }
    }).iterator().next();
    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(cert.getSubjectPublicKeyInfo().getEncoded());
    KeyFactory keyFactory = KeyFactory.getInstance(publicKeySpec.getFormat());
    Key key = keyFactory.generatePublic(publicKeySpec);

    // Decrypting the DigestInfo from the RSA signature
    Cipher asymmetricCipher = Cipher.getInstance(""RSA"", ""BC"");
    asymmetricCipher.init(Cipher.DECRYPT_MODE, key);
    byte[] digestInfo = asymmetricCipher.doFinal(signerInformation.getSignature());
    DigestInfo digestInfoObject = new DigestInfo(ASN1Sequence.getInstance(digestInfo));

    System.out.println(""Signed Attributes: "" + toHex(derSignedAttributes));
    System.out.println(""Signed Attributes Hash: "" + toHex(derSignedAttributesHash));
    System.out.println(""DigestInfo: "" + toHex(digestInfo));
    System.out.println(""DigestInfo Hash: "" + toHex(digestInfoObject.getDigest()));
</code></pre>

<p>Applied to the signature in the provided PDF file signed_1047_ctsv.pdf the output is:</p>

<pre><code>Signed Attributes: 31 81 D8 30 18 06 09 2A 86 48 86 F7 0D 01 09 03 31 0B 06 09 2A 86 48 86 F7 0D 01 07 01 30 1C 06 09 2A 86 48 86 F7 0D 01 09 05 31 0F 17 0D 31 34 30 34 31 33 30 32 35 38 34 31 5A 30 23 06 09 2A 86 48 86 F7 0D 01 09 04 31 16 04 14 19 4E 0B A9 C4 B9 A5 3D 5E 9E 5B 7B 94 D7 DB 42 BE A4 C2 8F 30 79 06 09 2A 86 48 86 F7 0D 01 09 0F 31 6C 30 6A 30 0B 06 09 60 86 48 01 65 03 04 01 2A 30 0B 06 09 60 86 48 01 65 03 04 01 16 30 0B 06 09 60 86 48 01 65 03 04 01 02 30 0A 06 08 2A 86 48 86 F7 0D 03 07 30 0E 06 08 2A 86 48 86 F7 0D 03 02 02 02 00 80 30 0D 06 08 2A 86 48 86 F7 0D 03 02 02 01 40 30 07 06 05 2B 0E 03 02 07 30 0D 06 08 2A 86 48 86 F7 0D 03 02 02 01 28 
Signed Attributes Hash: 7A 2D D8 92 B0 F4 AC 5A 2C 93 03 6B 06 94 74 62 71 D0 06 17 
DigestInfo: 30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14 7A 2D D8 92 B0 F4 AC 5A 2C 93 03 6B 06 94 74 62 71 D0 06 17 
DigestInfo Hash: 7A 2D D8 92 B0 F4 AC 5A 2C 93 03 6B 06 94 74 62 71 D0 06 17 
</code></pre>

<p>As you see, the values <em>Signed Attributes Hash</em> and <em>DigestInfo Hash</em> are the same.</p>
","1282","<pdf><message><signature><digest><pkcs#7>","2","5","1","2014-05-05 13:40:47","","0","3","3456529","","2014-05-03 08:12:53","2014-05-02 09:37:45",""
"15618132","how to create PKCS7 signedData structure with openssl or any other library with signing on smart card?","<p>i need to create PKCS7 signedData structure with signing performed on smart card. It is almost what openssl function PKCS7_sign does, except the signing. Maybe somebody can advice something for this question, i.e. how to do this with openssl or any other c/c++ crossplatform library.
As for openssl, it seems flags PKCS7_PARTIAL or PKCS7_STREAM of PKCS7_sign function can be usefull. If i use any of this flags i can get almost full PKCS7 structure. In this case the structure is full except that it does not contain ""data"" and ""sign"". So i need only add these elements. But i did not found the way how to do this. Does anybody know?</p>
","<p>You generally do not want (or are technically blocked) from extracting the private key from a smartcard. As this is sort of the very point of a smartcard - a tamper proof bit of crypto memory and connected CPU that will never divulge your private key.</p>

<p>So instead you need to ask the chipcard nicely to do the signing for you.</p>

<p>OpenSSL can do this - but needs to know how to talk to the chipcard. That is generally done with an 'engine'. Most commonly a pkcs#11 of #15 is used for this - in conjunction with the vendors chipcard (reader) driver. </p>

<p>You then typically need to get the slot and key identifiers:</p>

<pre><code># Extracting slot, auth ids and key id's for later use/reference
#
set `pkcs11-tool --module /usr/lib/opensc-pkcs11.so --list-slots | grep Slot | grep SCM`
SLOT=$2
set `pkcs15-tool --list-keys | grep ID`
AID=$4
KID=$7
</code></pre>

<p>After which you can do 'things' on the card:</p>

<pre><code>/usr/bin/openssl &lt;&lt; EOM
engine dynamic -pre SO_PATH:/Library/OpenSC/lib/engines/engine_pkcs11.so  -pre ID:pkcs11 -pre LIST_ADD:1 -pre LOAD -pre MODULE_PATH:opensc-pkcs11.so
XXX -engine pkcs11 -b-key slot_$SLOT-id_$KID -keyform engine  ....
EOM
</code></pre>

<p>One such thing can be signing a pkcs7. From code - pretty much do the same thing. I usually use the app/util convenience stuf from openssl it's apps directory to make live a bit easier.</p>
","1281","<c++><openssl><smartcard><pkcs#7>","4","3","1","2013-05-30 08:59:45","","5","3","","","","2013-03-25 15:01:20",""
"18649453","Implement PKCS #7 Padding Scheme for AES in Python","<p>I've written a small command line utility to encrypt single files with AES, using Python 3. As I'm sure we all know, AES works on 16-byte blocks, so if I want to encrypt a file that isn't exactly a multiple of 16, then I'll have to pad the file to make it a multiple of 16. PKCS #7 padding scheme says that I should pad the last chunk with N bytes all of value N. This is how I do that in my encryption function.</p>

<pre><code>for chunk in getChunks(plainFile, chunkSizeBytes):
    padLength = ((AES.block_size - len(chunk)) % AES.block_size)
    # We have to have padding!
    if padLength == 0:
        padLength = 16
    pad = chr(padLength) * padLength
    chunk += pad.encode('utf-8')

    # Write the encrypted chunk to an output file.
    cipherFile.write(en.encrypt(chunk))
</code></pre>

<p>However, I'm unsure about how I should read this data from that last chunk of a decrypted file. Is there a way to read in files in reverse order? What's the correct way to do this? </p>
","<blockquote>
  <p>I should pad the last chunk with N bytes all of value N.</p>
</blockquote>

<p>In this sentence, the first N is equal to the second N, which means the value of the byte determines how much characters you need to remove for decoding.</p>

<p>For example, if you only have 9 characters in your last chunk, pad with <strong>7</strong> characters of value <strong>7</strong> (7 turns out to be the BEL character, but that doesn't matter).</p>
","1275","<python-3.x><aes><padding><pkcs#7>","2","1","1","2014-05-04 23:42:39","","0","","1419891","","2014-05-04 23:42:39","2013-09-06 03:35:05",""
"37930528","How can I check signature of a SignedCms envelope?","<p>I don't really understand how to work with PKCS#7 messages.</p>

<p>I sign some byte array with a X509Certificate2 I have and get also a byte array.</p>

<pre><code>byte[] data = new byte[5] { 110, 111, 112, 113, 114 }, signedData;

X509Certificate2 cert = new X509Certificate2(certPath, password);

ContentInfo content = new ContentInfo(data);
SignedCms envelope = new SignedCms(content);
CmsSigner cmsSigner = new CmsSigner(cert);
envelope.ComputeSignature(cmsSigner);
signedData = envelope.Encode();
</code></pre>

<p>The signedData is transmitted to some remote recipient and he gets the SignedCms envelope.</p>

<pre><code>SignedCms envelope = new SignedCms();
envelope.Decode(signedData);
</code></pre>

<p>How can he decode the envelope? He doesn't pass my public key as a parameter. There's my public key in the envelope, in SignerInfo property, but is there any reason for that, cause anyone can replace it with the whole signature?</p>

<p>He can the recipient make sure, using my public key that he has, that the actual sender of the envelope is me?</p>

<p>There's method <code>envelope.CheckSignature(new X509Certificate2Collection(certificate), true);</code> but I tried to use wrong certificate and there was no exception thrown.</p>
","<p>A PKCS#7 by itself is just a signature, could it be replaced? sure. envelope.CheckSiganture just validates that pkcs#7 has the right format and length, in other words checks if a pkcs#7 is well constructed. </p>

<p>Broadly putted, you need to implement a PKI (Private Key Infrastructure). Where in one end you construct your pkcs#7 using a public key, and on the other end you must validate that the pkcs#7 you have actually has a valid certificate that you recognize as your own. You must implement an OCSP to validate those certificates and if everything checks out all right you should and must request a timestamp to a third party to vouch for your pkcs#7. Also you will need a vault (database) to keep track of everything: pkcs#7's, data hashes, timestamps, original data, ocsp responses...</p>

<p>But if you are only interested in knowing how to identify a pkcs#7, there are various tools you could use to decode a PKCS#7, this action gives back all the information contained in it. Or you could create your own using c#.</p>
","1274","<c#><digital-signature><x509certificate2><pkcs#7>","0","0","2","2016-07-03 22:42:15","37949866","0","1","4220815","","2016-06-20 19:48:29","2016-06-20 19:40:12",""
"37930528","How can I check signature of a SignedCms envelope?","<p>I don't really understand how to work with PKCS#7 messages.</p>

<p>I sign some byte array with a X509Certificate2 I have and get also a byte array.</p>

<pre><code>byte[] data = new byte[5] { 110, 111, 112, 113, 114 }, signedData;

X509Certificate2 cert = new X509Certificate2(certPath, password);

ContentInfo content = new ContentInfo(data);
SignedCms envelope = new SignedCms(content);
CmsSigner cmsSigner = new CmsSigner(cert);
envelope.ComputeSignature(cmsSigner);
signedData = envelope.Encode();
</code></pre>

<p>The signedData is transmitted to some remote recipient and he gets the SignedCms envelope.</p>

<pre><code>SignedCms envelope = new SignedCms();
envelope.Decode(signedData);
</code></pre>

<p>How can he decode the envelope? He doesn't pass my public key as a parameter. There's my public key in the envelope, in SignerInfo property, but is there any reason for that, cause anyone can replace it with the whole signature?</p>

<p>He can the recipient make sure, using my public key that he has, that the actual sender of the envelope is me?</p>

<p>There's method <code>envelope.CheckSignature(new X509Certificate2Collection(certificate), true);</code> but I tried to use wrong certificate and there was no exception thrown.</p>
","<p>A PKCS#7 / CMS / S/MIME signed message is a data container which has (in addition to some other metadata):</p>

<pre>
EncapsulatedContentInfo
  ContentInfoType
  EncapsulatedContent (the message bytes)
Certificates (Optional)
CRLs (Optional)
SignerInfos
  DigestAlgorithm (e.g. SHA-1)
  SignedAttributes (Optional, allows other context information to be signed)
  SignatureAlgorithm (e.g. RSA, DSA, ECDSA)
  SignatureValue (the signature bytes)
  UnsignedAttributes (Optional, allows for after-signing information, like counter-signatures)
</pre>

<p>(This is a summary of <a href=""https://tools.ietf.org/html/rfc2630#section-5"" rel=""nofollow"">RFC 2630 (Cryptographic Message Syntax) Section 5</a>)</p>

<p>SignedCms.Decode reads the encoded message and populates members. Every direct signatory to the message can be read from the SignedCms::SignerInfos property (counter-signers, or entities which have signed that they witnessed the original signature, can be read from SignerInfo::CounterSignerInfos).</p>

<p>When you call SignedCms.CheckSignature, it checks every SigerInfo and verifies that the signature can be successfully verified (or throws an exception), as well as that every counter-signer signature can be worked out.</p>

<p>What it doesn't know is that any of the signers ""made sense"".  For that check you would need to loop over each SignerInfo and look at (for example) the Certificate property; then perform a suitability check:</p>

<ul>
<li>Perhaps it is a pre-registered public key</li>
<li>Perhaps it chains up to a well-known root or intermediate CA</li>
<li>Perhaps it has some sort of Extension which shows it to be suitable</li>
</ul>

<p>This part SignedCms cannot realistically do for you, since there's no default notion of ""suitable"" for messages, unlike the hostname verification of TLS.</p>

<p>If you want to assess the signature of a single signer, you can call SignedInfo::CheckSignature, but that's redundant if you also called SignedCms::CheckSignature.</p>

<blockquote>
  <p>There's method envelope.CheckSignature(new X509Certificate2Collection(certificate), true); but I tried to use wrong certificate and there was no exception thrown.</p>
</blockquote>

<p>The <code>extraCerts</code> overloads provide <em>extra</em> certificates. It's valid to have a SignedCms message which does not embed the signer certificates, leaving it up to the recipient to have known the valid certs ahead of time (e.g. using a per-user database of pre-registered certificates). You didn't get an exception because the correct certificates were found within the provided certificates collection.</p>

<p>You can see what was in the provided certificates collection via the X509Certificate2Collection.Import methods; they can read a PKCS#7 signed-data message and populate the collection with the optional embedded certificates.</p>
","1274","<c#><digital-signature><x509certificate2><pkcs#7>","0","0","2","2016-07-03 22:42:15","37949866","0","1","4220815","","2016-06-20 19:48:29","2016-06-20 19:40:12",""
"23728234","How to create a degenerate PKCS7 file using OpenSSL C library?","<p><strong>How can I create a degenerate PKCS#7 file given a single X509 certificate using OpenSSL C libraries?</strong>  </p>

<p><em>Details:</em></p>

<p>I extended the _pkcs7.i SWIG interface file in M2Crypto by adding a new function called <code>pkcs7_create_deg</code>.</p>

<p>I get a segmentation fault when I use the the below C code in the SWIG interface file.  <strong>Why?</strong></p>

<pre class=""lang-c prettyprint-override""><code>/* _pkcs7.i */
//
// Following 2 lines are part of the SWIG interface definition. Uncommented in _pkcs7.i file.
// %threadallow pkcs7_create_deg;
// %inline %{
//

PKCS7 *pkcs7_create_deg(X509 *x509) {
    PKCS7 *p7 = NULL;
    PKCS7_SIGNED *p7s = NULL;
    STACK_OF(X509_CRL) *crl_stack = NULL;
    STACK_OF(X509) *cert_stack = NULL;

    int ret = 1;

    if ((p7=PKCS7_new()) == NULL) goto end;
    if ((p7s=PKCS7_SIGNED_new()) == NULL) goto end;  
    p7-&gt;type=OBJ_nid2obj(NID_pkcs7_signed);
    p7-&gt;d.sign=p7s;
    p7s-&gt;contents-&gt;type=OBJ_nid2obj(NID_pkcs7_data);

    if (!ASN1_INTEGER_set(p7s-&gt;version,1)) goto end;
    if ((crl_stack=sk_X509_CRL_new_null()) == NULL) goto end;
    p7s-&gt;crl=crl_stack;
    if ((cert_stack=sk_X509_new_null()) == NULL) goto end;
    p7s-&gt;cert=cert_stack;

    sk_X509_push(cert_stack, x509);
    // Shouldn't this mean take cert struct pointed to by x509
    // and push it on to cert_stack?  
    // I think this is WHY I am getting the segfault

end:
    if (p7 != NULL) PKCS7_free(p7);

    return (p7);    /* need to return a PKCS7* */

}

// Next line part of SWIG interface definition
// %}
</code></pre>

<pre class=""lang-py prettyprint-override""><code># deg.py
#
from M2Crypto import *

cert = X509.load_cert('ra.crt')
print (cert)

p7_ptr = m2.pkcs7_create_deg(cert._ptr())
# Here I pass the X509 pointer to my cert object
# to the SWIG interface function I created above
# that is supposed to return a pointer to a PKCS#7 object

print (p7_ptr)
p7 = SMIME.PKCS7(p7_ptr)
print (p7)

bio = BIO.MemoryBuffer()
print (bio)

p7.write_der(bio)
# This is WHEN I get the segfault

f = open('deg.p7s', 'w')
f.write(bio.read())
f.close()
</code></pre>

<pre class=""lang-bash prettyprint-override""><code>(venv)x-wing-air13:.test hansooloo$ python deg.py
&lt;M2Crypto.X509.X509 instance at 0x106275710&gt;
&lt;Swig Object of type 'PKCS7 *' at 0x10625ea80&gt;
&lt;M2Crypto.SMIME.PKCS7 instance at 0x1062577e8&gt;
&lt;M2Crypto.BIO.MemoryBuffer instance at 0x1062757e8&gt;
Segmentation fault: 11
</code></pre>
","<p>Ended up forking M2Crypto to add a new function that would create a degenerate PKCS7 object. <a href=""https://github.com/HanSooloo/M2Crypto-martinpaljak"" rel=""nofollow"">https://github.com/HanSooloo/M2Crypto-martinpaljak</a></p>

<p>The steps involved were the following:</p>

<ol>
<li>Fork M2Crypto from Martin Paljak's repo to a new one.</li>
<li>Modify <code>_pkcs7.i</code> SWIG interface file to add the function below.</li>
</ol>

<h1>_pkcs7.i Modifications</h1>

<pre class=""lang-c prettyprint-override""><code>// Adding X.509 related header files to be able to use their data types.
#include &lt;openssl/x509.h&gt;
#include &lt;openssl/x509v3.h&gt;

// Adding PKCS7_SIGNED data type to help create the degenerate data structure.
%apply Pointer NONNULL { PKCS7_SIGNED * };

// Additional interface definitions for degenerate PKCS#7 object creation.
// Inspired by the crl2p7.c file from OpenSSL.  Will need to clean up a bit for function returns.
%threadallow pkcs7_create_degenerate;
%inline %{
int pkcs7_create_degenerate(STACK_OF(X509) *cert_stack, BIO *bio) {
    int ret=1;
    PKCS7 *p7=NULL;
    PKCS7_SIGNED *p7s=NULL;
    X509_CRL *crl=NULL;
    STACK_OF(X509_CRL) *crl_stack=NULL;

    if ((p7=PKCS7_new()) == NULL) goto end;
    if ((p7s=PKCS7_SIGNED_new()) == NULL) goto end;  

    p7-&gt;type=OBJ_nid2obj(NID_pkcs7_signed);
    p7-&gt;d.sign=p7s;
    p7s-&gt;contents-&gt;type=OBJ_nid2obj(NID_pkcs7_data);

    if (!ASN1_INTEGER_set(p7s-&gt;version,1)) goto end;
    if ((crl_stack=sk_X509_CRL_new_null()) == NULL) goto end;
    p7s-&gt;crl=crl_stack;
    p7s-&gt;cert=cert_stack;

    ret=i2d_PKCS7_bio(bio, p7);

end:
    p7s-&gt;cert=NULL;

    if (p7 != NULL) {
//      printf(""about to free p7: "");
        PKCS7_free(p7);
//      printf(""freed.\n"");
    }

    return ret;

}
%}
</code></pre>

<h1>Function Details</h1>

<p>The function takes an X509 stack pointer and BIO pointer as inputs and returns an integer indicating success.</p>

<p>The X509 stack pointer needs to point to a stack that contains the certificates one wishes to place in the degenerate PKCS#7 object.  </p>

<p>The BIO pointer needs to point to an empty BIO structure that will later be populated with the PKCS#7 object.</p>

<h1>Python code example that uses the above function:</h1>

<pre class=""lang-py prettyprint-override""><code>from M2Crypto import X509, BIO, m2

sk = X509.X509_Stack()

cert = X509.load_cert('ra.crt')
num = sk.push(cert)
cert = X509.load_cert('ca.crt')
num = sk.push(cert)

# At this point, the X509 stack contains 2 certificates.
print('num: %d' %num)

# Create the BIO that will hold the PKCS#7 object.    
bio = BIO.MemoryBuffer()

# Request to create the degenerate PCKS#7 object.
ret = m2.pkcs7_create_degenerate(sk._ptr(), bio._ptr())

# Open the file for writing.
f = open('deg.p7s', 'w')

# Read from BIO and write to file.
b = bio.read()
f.write(b)

# Close the file.
f.close()
</code></pre>
","1248","<python><c><swig><pkcs#7><m2crypto>","0","1","1","2016-03-17 00:00:26","23879244","0","","","","","2014-05-19 00:34:00",""
"37010864","Creating a PKCS #7 detached signature for Apple Wallet passes using PHP","<p>This is an entirely new concept to me, so I'm shooting in the dark.</p>

<blockquote>
  <p>To create the signature file, make a PKCS #7 detached signature of the
  manifest file, using the private key associated with your signing
  certificate. Include the WWDR intermediate certificate as part of the
  signature. You can download this certificate from Apple‚Äôs website.
  Write the signature to the file signature at the top level of the pass
  package. Include the date and time that the pass was signed using the
  S/MIME signing-time attribute.</p>
</blockquote>

<h2>My understanding:</h2>

<blockquote>
  <p>To create the signature file, make a PKCS #7 detached signature of the manifest file</p>
</blockquote>

<p>I'll be using the <a href=""http://php.net/manual/en/function.openssl-pkcs7-sign.php"" rel=""nofollow""><code>openssl_pkcs7_sign</code></a> function using the flag <code>PKCS7_DETACHED</code>.</p>

<blockquote>
  <p>using the private key associated with your signing certificate.</p>
</blockquote>

<p>I'll be using the location of my ssl <code>cert.pem</code> file as the <code>signcert</code> parameter and the location of the <code>cert.key</code> file as the <code>privkey</code> parameter.</p>

<blockquote>
  <p>Include the WWDR intermediate certificate as part of the signature.</p>
</blockquote>

<p>I'll include the path to the WWDR certificate in the <code>extracerts</code> parameter</p>

<blockquote>
  <p>Include the date and time that the pass was signed using the S/MIME signing-time attribute.</p>
</blockquote>

<p>I'll include a an array with a key <code>signing-time</code> and value something like <code>2015-05-03 10:40:00</code> for the <code>headers</code> parameter.</p>

<h2>My code:</h2>

<pre><code>private function createSignature($dir)
{
    $cert = '/etc/ssl/cert.pem';
    $key = '/etc/ssl/private/cert.key';
    $wwdr = '/location/of/apple/wwdr/cert.cer';
    $headers = [
        'signing-time' =&gt; (new DateTime())-&gt;format('o-m-d H:i:s'),
    ];

    return openssl_pkcs7_sign(""$dir/manifest.json"", ""$dir/signature"", $cert, $key, $headers, PKCS7_DETACHED, $wwdr);
}
</code></pre>

<h2>Other questions:</h2>

<p>I've noticed in the examples of the documentation for the <code>openssl_pkcs7_sign</code> function that <em>some</em> locations of the files are prefixed with <code>file://</code>. Why is this?</p>
","<ol>
<li>Generate a Pass Type ID at <a href=""https://developer.apple.com/account/ios/identifier/passTypeId"" rel=""nofollow noreferrer"">https://developer.apple.com/account/ios/identifier/passTypeId</a></li>
<li>Create a certificate for that Pass Type ID at <a href=""https://developer.apple.com/account/ios/certificate/create/"" rel=""nofollow noreferrer"">https://developer.apple.com/account/ios/certificate/create/</a></li>
<li>Download the certificate and put it in your keychain</li>
<li>Find the certificate in your keychain and export it as <code>Certificates.p12</code> with no password</li>
<li>Open terminal, run <code>openssl pkcs12 -in Certificates.p12 -clcerts -nokeys -out pass_cert.pem -passin pass:</code> to generate the certificate</li>
<li>In terminal, run <code>openssl pkcs12 -in Certificates.p12 -nocerts -out pass_key.pem -passin pass: -passout pass:YourPassword</code> to generate the key</li>
<li>Download the WWDR Certificate from <a href=""https://www.apple.com/certificateauthority/"" rel=""nofollow noreferrer"">https://www.apple.com/certificateauthority/</a> and put it in your keychain</li>
<li>Export the WWDR Certificate from your keychain as <code>wwdr.pem</code></li>
</ol>

<p>The function to create the detached signature:</p>

<pre><code>public function createSignature()
{
    $cert = ""file://location/of/pass_cert.pem"";
    $key = ""file://location/of/pass_key.pem"";
    $wwdr = ""/location/of/wwdr.pem"";

    openssl_pkcs7_sign(""/location/of/manifest.json"", ""/location/of/signature"",
        $cert, [$key, 'YourPassword'], [], PKCS7_BINARY | PKCS7_DETACHED, $wwdr);

    // convert pem to der
    $signature = file_get_contents(""/location/of/signature"");
    $begin = 'filename=""smime.p7s""';
    $end = '------';
    $signature = substr($signature, strpos($signature, $begin) + strlen($begin));
    $signature = substr($signature, 0, strpos($signature, $end));
    $signature = trim($signature);
    $signature = base64_decode($signature);

    file_put_contents(""/location/of/signature"", $signature);
}
</code></pre>

<p>References:</p>

<ul>
<li><a href=""https://www.raywenderlich.com/20734/beginning-passbook-part-1"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/20734/beginning-passbook-part-1</a></li>
<li><a href=""https://github.com/tschoffelen/PHP-PKPass/blob/master/PKPass.php"" rel=""nofollow noreferrer"">https://github.com/tschoffelen/PHP-PKPass/blob/master/PKPass.php</a></li>
</ul>
","1242","<php><ios><ssl><sign><pkcs#7>","2","4","1","2018-11-08 18:07:03","37124072","0","","","","","2016-05-03 17:42:22",""
"31115861","C# and PHP encryption compatibility - 3DES ECB with PKCS7","<p>I have a common problem but none of the various solutions in the web seems working for me.</p>

<p>I have C# code which make an encrypt 3DES-ECB with PKCS7. I have to do the same in PHP, but I'm getting different results.</p>

<p>This is my C# code:</p>

<pre><code>        public string Encrypt(string toEncrypt, string key)
    {
        byte[] keyArray;
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);
        System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();
            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
            //Always release the resources and flush data
            // of the Cryptographic service provide. Best Practice
            hashmd5.Clear();            
        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;
        tdes.Padding = PaddingMode.PKCS7;
        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] resultArray =
          cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
        tdes.Clear();
        return Convert.ToBase64String(resultArray, 0, resultArray.Length);
    }
</code></pre>

<p>I've made a lot of tries in php... this is only one of them:</p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}
</code></pre>

<p>I'm using a random key, you can find it in the php sample code.</p>

<p>When the input is ""<strong>00010</strong>"", the C# code returns ""<strong>FcXBCikZU64=</strong>"" while the php gives to me ""<strong>FIg+xqod9iY=</strong>"".</p>

<p>Why? I think I'm doing all the stuff I've found in the blogs/tutorials/etc... so, what's the problem in my case?</p>

<p>UPDATE:</p>

<p>I have add, but still bad news...</p>

<p><strong>$key .= substr($key,0,8);</strong></p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key .= substr($key,0,8); // append the first 8 bytes onto the end

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb'); //, $iv);
  return base64_encode($encData);
}
</code></pre>

<p>now the output is <strong>hbJpiCNmXz8=</strong>... still not what I need..</p>

<p><strong>UPDATE2</strong>: the problem is that, on c# side, I make an hash and I don't know how to do it in php.. look the code ""tabbed"", is where I do the hash in c# side.. how can I do it in php one?</p>

<p><strong>SOLUTION</strong>: </p>

<pre><code>function apiEncode($data)
{    
  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key = ""6702BC24DD0527E7"";
  $key = md5($key,TRUE);
  $key .= substr($key,0,8);
  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}

 $crypt = apiEncode(""00010"");     
    echo ""CRYPT: $crypt"";
</code></pre>
","<p>PHP code:</p>

<pre><code>$key = ""6702BC24DD0527E7"";
$key = md5($key,TRUE);
$key .= substr($key,0,8);
</code></pre>

<p>The C# code is ""ok"" as it is.</p>

<p>""ok"" is a big word here. I would probably use SHA256 and trim it to 24 bytes:</p>

<p>C#:</p>

<pre><code>SHA256Managed sha256 = new SHA256Managed();
keyArray = sha256.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
Array.Resize(ref keyArray, 24);
//Always release the resources and flush data
// of the Cryptographic service provide. Best Practice
sha256.Clear(); 
</code></pre>

<p>and PHP:</p>

<pre><code>$key = ""6702BC24DD0527E7"";
$key = hash(""sha256"",$key,TRUE);
$key = substr($key,0,24);
</code></pre>

<p>and still would be ""lower case OK""... Normally you should use AES and one of the various block chaining modes, like CBC (that requires a IV), and the password should be ""strenghtened"" with an algorithm, like PBKDF2 (requires PHP >= 5.5)</p>
","1232","<c#><php><encryption><pkcs#7><3des>","2","2","2","2015-07-08 10:24:13","31117920","13","1","819161","","2015-06-29 14:21:24","2015-06-29 12:34:45",""
"31115861","C# and PHP encryption compatibility - 3DES ECB with PKCS7","<p>I have a common problem but none of the various solutions in the web seems working for me.</p>

<p>I have C# code which make an encrypt 3DES-ECB with PKCS7. I have to do the same in PHP, but I'm getting different results.</p>

<p>This is my C# code:</p>

<pre><code>        public string Encrypt(string toEncrypt, string key)
    {
        byte[] keyArray;
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);
        System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();
            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
            //Always release the resources and flush data
            // of the Cryptographic service provide. Best Practice
            hashmd5.Clear();            
        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;
        tdes.Padding = PaddingMode.PKCS7;
        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] resultArray =
          cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
        tdes.Clear();
        return Convert.ToBase64String(resultArray, 0, resultArray.Length);
    }
</code></pre>

<p>I've made a lot of tries in php... this is only one of them:</p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}
</code></pre>

<p>I'm using a random key, you can find it in the php sample code.</p>

<p>When the input is ""<strong>00010</strong>"", the C# code returns ""<strong>FcXBCikZU64=</strong>"" while the php gives to me ""<strong>FIg+xqod9iY=</strong>"".</p>

<p>Why? I think I'm doing all the stuff I've found in the blogs/tutorials/etc... so, what's the problem in my case?</p>

<p>UPDATE:</p>

<p>I have add, but still bad news...</p>

<p><strong>$key .= substr($key,0,8);</strong></p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key .= substr($key,0,8); // append the first 8 bytes onto the end

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb'); //, $iv);
  return base64_encode($encData);
}
</code></pre>

<p>now the output is <strong>hbJpiCNmXz8=</strong>... still not what I need..</p>

<p><strong>UPDATE2</strong>: the problem is that, on c# side, I make an hash and I don't know how to do it in php.. look the code ""tabbed"", is where I do the hash in c# side.. how can I do it in php one?</p>

<p><strong>SOLUTION</strong>: </p>

<pre><code>function apiEncode($data)
{    
  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key = ""6702BC24DD0527E7"";
  $key = md5($key,TRUE);
  $key .= substr($key,0,8);
  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}

 $crypt = apiEncode(""00010"");     
    echo ""CRYPT: $crypt"";
</code></pre>
","<p>Ok, solved the issue. Look <a href=""https://programmingistheway.wordpress.com/2015/07/08/triple-des-with-pcsk7-and-ecb-between-php-and-net/"" rel=""nofollow"">this link</a>, I wrote all there.</p>
","1232","<c#><php><encryption><pkcs#7><3des>","2","0","2","2015-07-08 10:24:13","31117920","13","1","819161","","2015-06-29 14:21:24","2015-06-29 12:34:45",""
"34625271","Getting PKCS7 signer chain in python","<p>I have PKCS7 message which is signed. It contains a data and a signing certificate (with the whole chain of trust).</p>

<p>I have a code which uses m2crypto to get a certificate out of it.</p>

<pre><code>bio = BIO.MemoryBuffer(pkcs7message)
p7 = SMIME.PKCS7(m2.pkcs7_read_bio_der(bio._ptr()))
sk = X509.X509_Stack()
certStack = p7.get0_signers(sk)
</code></pre>

<p>It works. However, certStack returns only one certificate (instead of returning the whole chain of certificates.</p>

<p>Two questions:</p>

<ul>
<li>Am I missing something (may be there is an option to let it know that I need the whole chain)</li>
<li>Are there other methods how to get the whole chain (may be using pyopenssl)?</li>
</ul>
","<p>I guess you are making a confusion between signers and certificate chain of a signer. <a href=""https://www.openssl.org/docs/manmaster/crypto/PKCS7_get0_signers.html"">PKCS7_get0_signers</a> return the list of signers.</p>

<p>In order to building a PKCS7 message with 2 signers, you can use following steps:</p>

<ol>
<li><p>Build key and certificate for first signer:</p>

<pre><code>openssl genrsa -out key1.pem
openssl req -new -key key1.pem -subj ""/CN=key1"" | openssl x509 -req -signkey key1.pem -out cert1.pem
</code></pre></li>
<li><p>Build key and certificate for second signer:</p>

<pre><code>openssl genrsa -out key2.pem
openssl req -new -key key2.pem -subj ""/CN=key2"" | openssl x509 -req -signkey key2.pem -out cert2.pem
</code></pre></li>
<li><p>Create an PKCS7 message using both signers :</p>

<pre><code>echo ""Hello"" | openssl smime -sign -nodetach \
  -out signature.der -outform DER \
  -inkey key1.pem -signer cert1.pem -inkey key2.pem -signer cert2.pem 
</code></pre></li>
</ol>

<p>Then signers could be printed running your python script:</p>

<pre><code>from M2Crypto import *

bio=BIO.File(open('signature.der'))
smime_object = SMIME.PKCS7(m2.pkcs7_read_bio_der(bio._ptr()))    
signers = smime_object.get0_signers(X509.X509_Stack())

for cert in signers:
    print(cert.get_issuer().as_text())
</code></pre>

<p>It give the signers' issuer:</p>

<blockquote>
  <p>CN=key1<br>
  CN=key2<br></p>
</blockquote>
","1225","<python><certificate><pkcs#7><m2crypto><pyopenssl>","14","5","1","2016-01-12 22:50:55","","0","1","3102264","","2016-01-09 17:30:57","2016-01-06 03:43:10",""
"28615837","Which data from a CMSSignedData object must I pass to generate a valid Timestamp?","<p>I have a valid PKCS7 file loaded into a CMSSignedData object. 
This PKCS7 file includes a plain text message and a valid attached digital signature (all in the same file).</p>

<p>Now I want to timestamp this file. This is the code I'm using (<a href=""http://itext-general.2136553.n4.nabble.com/Signature-timestamp-td2142844.html"" rel=""nofollow"">source</a>):</p>

<pre><code> private static CMSSignedData addTimestamp(CMSSignedData signedData)
throws Exception {
        Collection ss = signedData.getSignerInfos().getSigners();
        SignerInformation si = (SignerInformation) ss.iterator().next();

        TimeStampToken tok = getTimeStampToken();

        ASN1InputStream asn1InputStream = new ASN1InputStream
(tok.getEncoded());
        DERObject tstDER = asn1InputStream.readObject();
        DERSet ds = new DERSet(tstDER);

        Attribute a = new Attribute(new
DERObjectIdentifier(""1.2.840.113549.1.9.16.2.14""), ds);
        DEREncodableVector dv = new DEREncodableVector();
        dv.add(a);
        AttributeTable at = new AttributeTable(dv);
        si = SignerInformation.replaceUnsignedAttributes(si, at);
        ss.clear();
        ss.add(si);
        SignerInformationStore sis = new SignerInformationStore(ss);

        signedData = CMSSignedData.replaceSigners(signedData, sis);
        return signedData;
    }


 private static TimeStampToken getTimeStampToken() throws
Exception {
        Security.addProvider (new
org.bouncycastle.jce.provider.BouncyCastleProvider());

        PostMethod post = new PostMethod(""http://My-TrustedTimeStampProvier.com"");

// I'm omitting the part where I pass the user and password

        TimeStampRequestGenerator reqGen = new TimeStampRequestGenerator();
        //request TSA to return certificate
        reqGen.setCertReq (true); // In my case this works

        //make a TSP request this is a dummy sha1 hash (20 zero bytes)
        TimeStampRequest request =
            reqGen.generate(TSPAlgorithms.SHA1, new byte[20], BigInteger.valueOf(100));

        byte[] enc_req = request.getEncoded();
        ByteArrayInputStream bais = new ByteArrayInputStream(enc_req);

        post.setRequestBody(bais);
        post.setRequestContentLength (enc_req.length);
        post.setRequestHeader(""Content-type"",""application/timestamp-query"");

        HttpClient http_client = new HttpClient();
        http_client.executeMethod(post);
        InputStream in = post.getResponseBodyAsStream();

        //read TSP response
        TimeStampResponse resp = new TimeStampResponse (in);

        resp.validate(request);

        TimeStampToken  tsToken = resp.getTimeStampToken();       
        return tsToken;
    }  
</code></pre>

<p>I can get a valid TimeStamp, and I could put it into my CMSSignedData object and save it to a file writting the bytes from signedData.getEncoded() to the harddisk. But when I validate my new shinny timestamped file with a <a href=""http://www.xolido.com/lang/productosxolidosign/xolidosignescritorio/"" rel=""nofollow"">third party software</a>, this software tells the original signature is ok, but the Timestamp doesn't correspond with the signature. This software also can show me the original plain text message.</p>

<p>I think the problem is in this line:</p>

<pre><code>TimeStampRequest request =
    reqGen.generate(TSPAlgorithms.SHA1, new byte[20], BigInteger.valueOf(100));
</code></pre>

<p>I think I have to pass a digest instead of a dummy byte array, but I don't know which digest, or what are the right bytes I have to timeStamp.
I successfully could get and verify a <code>SignerInformation</code> object from my <code>signedData</code>. Then I tried to pass to the <code>reqGen.generate()</code> function the bytes from <code>mySignerInformation.getSignature()</code>. The timestamp verification failed. Then I passed a Sha1 digest of <code>mySignerInformation.getSignature()</code>, but my timestamp verification failed again.</p>

<p>The <a href=""https://www.ietf.org/rfc/rfc3161.txt"" rel=""nofollow"">RFC3161 specification</a> says:</p>

<blockquote>
  <p>2.4.1. Request Format</p>
  
  <p>A time-stamping request is as follows:</p>
  
  <p>TimeStampReq ::= SEQUENCE  {    version                      INTEGER 
  { v1(1) },    messageImprint               MessageImprint,
       --a hash algorithm OID and the hash value of the data to be</p>
  
  <p>(...)</p>
  
  <p>The messageImprint field SHOULD contain the hash of the datum to be
  time-stamped.  The hash is represented as an OCTET STRING.  Its<br>
  length MUST match the length of the hash value for that algorithm<br>
  (e.g., 20 bytes for SHA-1 or 16 bytes for MD5).</p>
  
  <p>MessageImprint ::= SEQUENCE  {
          hashAlgorithm                AlgorithmIdentifier,
          hashedMessage                OCTET STRING  }</p>
</blockquote>

<p>But it doesn't tell me where or how I get the MessageImprint data if I want to TimeStamp the bytes inside a CMSSignedData object.</p>

<p>I'm a newbie in this digital signature stuff.</p>
","<p>You're right, the problem is that you're timestamping the incorrect data. The rest of the code seems correct to me.</p>

<p>So the thing is that you've to timestamp the hash of the signature. To get the signature from your <code>CMSSignedData</code> and hash it; you can use the follow code (supposing that you've only one signer in your <code>PKCS7</code> and you're using <code>SHA1</code> hash algorithm): </p>

<pre><code>CMSSignedData signedData = ...
// get the signers of your CMSSignedData signedData
Collection ss = signedData.getSignerInfos().getSigners();
SignerInformation si = (SignerInformation) ss.iterator().next();
// hash the signature
byte[] signDigest = MessageDigest
      .getInstance(TSPAlgorithms.SHA1, new BouncyCastleProvider())
      .digest(si.getSignature()); // since you're adding the bc provider with Security.addProvider you can use ""BC"" instead of passing the new BouncyCastleProvider() 
TimeStampRequestGenerator reqGen = new TimeStampRequestGenerator();
// generate the TSRequest
TimeStampRequest request =
            reqGen.generate(TSPAlgorithms.SHA1, signDigest, BigInteger.valueOf(100));
...
</code></pre>

<p>Hope this helps,</p>
","1196","<java><validation><bouncycastle><pkcs#7><trusted-timestamp>","3","3","1","2015-02-20 15:02:27","28616946","0","1","1218618","","2015-02-20 15:02:27","2015-02-19 20:03:19",""
"10986930","Java AES PKCS7 - last block incomplete in decryption","<p>I have an Python application that creates a few files encrypted with AES/PKCS7. I have to read those files with a Java service. But my code is throwing an exception:</p>

<p>""javax.crypto.IllegalBlockSizeException: last block incomplete in decryption""</p>

<p>Here's my decryption code:</p>

<pre><code>public String Decrypt(String strText)
{
    try
    {
        // Text to decrypt
        byte[] test = strText.getBytes();

        //bytKey is the same key as Python app
        SecretKeySpec objKey = new SecretKeySpec(bytKey, ""AES"");
        Cipher objCipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");
        objCipher.init(Cipher.DECRYPT_MODE, objKey);

        // Here I got an exception &gt;&gt;
        byte[] bytValue = objCipher.doFinal(test);

        return new String(bytValue);
    }
    catch (Exception exc)
    {
        exc.printStackTrace();
    }

    return """";

}
</code></pre>

<p>If I decode the encrypted text before step into <code>doFinal</code> I get another exception:</p>

<p>""javax.crypto.BadPaddingException: pad block corrupted""</p>

<pre><code>public String Decrypt(String strText)
{
    try
    {

        BASE64Decoder decoder = new BASE64Decoder();
        byte[] test = decoder.decodeBuffer(strText);

        SecretKeySpec objKey = new SecretKeySpec(bytKey, ""AES"");
        Cipher objCipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");
        objCipher.init(Cipher.DECRYPT_MODE, objKey);

        byte[] bytValue = objCipher.doFinal(test);

        return new String(bytValue);
    }
    catch (Exception exc)
    {
        exc.printStackTrace();
    }

    return """";

}
</code></pre>

<p>I'm not an expert on encrypt/decrypt and I guess it's quite simple to solve.
Any ideas to solve this issue? Thanks in advance!</p>
","","1192","<java><aes><encryption><pkcs#7>","1","","0","2012-06-11 20:15:29","","2","3","","","","2012-06-11 20:15:29",""
"33034896","How to get certificate from .p7b file","<p>Can anyone help how to extract certificate from .p7b file in C# and BouncyCastle?</p>
","<pre><code>var certificateStore = new CmsSignedData(new FileStream(""chain.p7b"", FileMode.Open));
IX509Store x509Certs = certificateStore.GetCertificates(""Collection"");
ArrayList a = new ArrayList(x509Certs.GetMatches(null));
X509Certificate signerCert = (X509Certificate) a[0];

var gen = new CmsSignedDataGenerator();
gen.AddCertificates(x509Certs);
gen.AddSigner(_privateKey, signerCert, CmsSignedGenerator.DigestSha1);

CmsProcessable msg = new CmsProcessableByteArray(Encoding.ASCII.GetBytes(FullUnsignedMessage));

CmsSignedData signedData = gen.Generate(msg, true);
</code></pre>
","1176","<c#><bouncycastle><pkcs#7>","-3","0","1","2015-10-09 10:35:35","33035587","2","","107625","","2015-10-09 10:14:22","2015-10-09 09:40:20","2016-01-14 06:12:57"
"52344287","extract signed data from pkcs7 in python","<p>i have a usb cryptotoken and able to sign data and pack it in pkcs file. then i can extract certificate and data from that file using openssl as follows:</p>

<pre><code>openssl cms -verify -in signature.p7s -inform DER -noverify -outform DER -signer cert.pem -out textdata
</code></pre>

<p>so my question is how to do the same using python (pyopenssl)?</p>

<p>i've tried to do as described <a href=""https://stackoverflow.com/questions/38123106/pyopenssl-to-verify-the-file-signature"">here</a>, but there is different case - i have attached signature and do not have separate signature and certificate file - i have ASN.1 encoded file, which contains as certificates as data and signature</p>
","<p>There are several hurdles to overcome to achieve what you are looking for.</p>

<p>First, the <code>pyopenssl</code> binding itself is  limited when it comes to its <code>crypto</code> module, where you desired functionality resides. In fact, <a href=""https://pyopenssl.org/en/stable/api/crypto.html"" rel=""nofollow noreferrer"">the <code>pyopenssl crypto</code> documentation</a> states:
<a href=""https://i.stack.imgur.com/fcTyf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fcTyf.png"" alt=""enter image description here""></a>
The <a href=""https://github.com/pyca/cryptography"" rel=""nofollow noreferrer""><code>pyca/cryptography</code></a> module mentioned is exposed via two internal attributes of the <code>pyopenssl crypto</code> module, with the names <code>_lib</code> and <code>_ffi</code>, which need to be used to get to the required functionality.</p>

<p>Then the <code>CMS_verify()</code> function that would be your logical choice for this is not included in the <code>pyca/cryptography</code> bindings either. However, for your purpose it is probably good enough to use <code>PKCS7_verify()</code> -- you can read all about that in a StackExchange question <a href=""https://security.stackexchange.com/q/41399/59016"">OpenSSL PKCS#7 vs. S/MIME</a>. The function <a href=""https://pyopenssl.org/en/stable/api/crypto.html#OpenSSL.crypto.load_pkcs7_data"" rel=""nofollow noreferrer""><code>crypto.load_pkcs7_data()</code></a> comes in handy.</p>

<p>All that said, the following code snippet might do it for you -- although from your description it is not clear to me whether the certificate of the signer is included in the <code>.p7s</code> file (in that case you do not have to give <code>-signer</code> as an argument to <code>openssl cms -verify</code> like you did). It worked for me, so give it a try:</p>

<pre><code>from OpenSSL import crypto
from OpenSSL._util import (
    ffi as _ffi,
    lib as _lib,
)

# Or, alternatively:
# from cryptography.hazmat.bindings.openssl.binding import Binding
# _lib = Binding.lib
# _ffi = Binding.ffi

with open('message_der.p7s', 'rb') as f:
    p7data = f.read()
p7 = crypto.load_pkcs7_data(crypto.FILETYPE_ASN1, p7data)

bio_out =crypto._new_mem_buf()
res = _lib.PKCS7_verify(p7._pkcs7, _ffi.NULL, _ffi.NULL, _ffi.NULL, bio_out, _lib.PKCS7_NOVERIFY)
if res == 1:
    databytes = crypto._bio_to_string(bio_out)
    print(databytes)
else:
    errno = _lib.ERR_get_error()
    errstrlib = _ffi.string(_lib.ERR_lib_error_string(errno))
    errstrfunc = _ffi.string(_lib.ERR_func_error_string(errno))
    errstrreason = _ffi.string(_lib.ERR_reason_error_string(errno)) 
</code></pre>

<p>In case you decide to use this approach, here is <a href=""https://cryptography.io/en/latest/hazmat/bindings/openssl/"" rel=""nofollow noreferrer"">a caveat about using this OpenSSL bindings module directly</a>:
<a href=""https://i.stack.imgur.com/7tWwM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7tWwM.png"" alt=""enter image description here""></a></p>
","1171","<python><openssl><x509><pem><pkcs#7>","3","1","1","2018-10-12 18:21:29","52352077","0","","7414759","","2018-09-16 09:43:50","2018-09-15 11:31:22",""
"19772103","Objective-c AES CBC decryption with IV","<p>I have been struggling with this problem for several days now and i can't seem to figure it out</p>

<p>I tried using CCCrypt to decrypt an encrypted string, I have the encrypted string encoded with Base64 encode, I have the key and the iv. The encryption is AES256 CBC with PKCS7Padding.</p>

<p>This is the code i am using right now:</p>

<pre><code>- (NSData *)AES256DecryptWithKey:(NSString *)key
{
    char keyPtr[kCCKeySizeAES128+1];
    bzero(keyPtr, sizeof(keyPtr));

    NSUInteger dataLength = [self length];

    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc( bufferSize );

    unsigned char *iv = [@""IV String"" cStringUsingEncoding:NSUTF8StringEncoding];

    size_t numBytesDecrypted = 0;

    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
                                      kCCAlgorithmAES128,
                                      kCCOptionPKCS7Padding,
                                      keyPtr, kCCKeySizeAES256,
                                      iv,
                                      [self bytes],
                                      dataLength,
                                      buffer,
                                      bufferSize,
                                      &amp;numBytesDecrypted);

    if( cryptStatus == kCCSuccess )
    {
        return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];
    }

    free( buffer );
    return nil;
}
</code></pre>

<p>But <code>cryptStatus</code> keeps returning 0 and I couldn't find a way to figure out why.
What am i doing wrong? </p>

<p>Thanks in advance! </p>
","","1146","<objective-c><encryption><aes><pkcs#7><cbc-mode>","0","","0","2013-11-04 16:19:23","","3","","","","","2013-11-04 16:19:23",""
"21549328","Certificate chain in iTextSharp with deferred signing","<p>I'm signing a PDF document with a mobile signing service. I recieve a certificate from the service after it has signed the hash of the document. I am able to replace zero padded signature container in the document with the certificate without any problems, but I""m having problems with including a certificate chain.  </p>

<p>I have the root, intermediate and leaf certificates with the application, but I'm not able to include them in the signature. What I thought I would be able to do was to create a chain in code and then inject the encoded bytes from that chain, but this results in an invalid certificate.  </p>

<p>The code I'm using to do that is as follows:</p>

<pre><code>X509CertificateParser cp = new X509CertificateParser();

var certFromServer = getCertFromServer();

var rootCert = cp.ReadCertificate(new X509Certificate2(rootCertPath).RawData);
var interCert = cp.ReadCertificate(new X509Certificate2(interCertPath)RawData);
var leafCert = cp.ReadCertificate(new X509Certificate2(leafCertPath).RawData);

List&lt;X509Certificate&gt; intermediateCerts = new List&lt;X509Certificate&gt; {
    interCert, 
    leafCert
};

X509CertificateParser parser = new X509CertificateParser();
PkixCertPathBuilder builder = new PkixCertPathBuilder();

X509CertStoreSelector holder = new X509CertStoreSelector {
    Certificate = parser.ReadCertificate(certFromServer)
};

intermediateCerts.Add(holder.Certificate);

HashSet rootCerts = new HashSet {new TrustAnchor(rootCert, null)};

PkixBuilderParameters builderParams = new PkixBuilderParameters(rootCerts, holder)
    {
        IsRevocationEnabled = false
    };

X509CollectionStoreParameters intermediateStoreParameters =
    new X509CollectionStoreParameters(intermediateCerts);

builderParams.AddStore(X509StoreFactory.Create(
    ""Certificate/Collection"", intermediateStoreParameters)
);

PkixCertPathBuilderResult result = builder.Build(builderParams);


byte[] certChainBytes = result.CertPath.GetEncoded(""PKCS7""); 

// ExternalSignatureContainer is a container that simply returns the cert bytes 
// from its Sign method without changing them.
IExternalSignatureContainer container = new ExternalSignatureContainer(certChainBytes);

MakeSignature.SignDeferred(reader, _signatureFieldName, baos, container);
</code></pre>

<p>The method to create the chain is from the following StackOverflow question: <a href=""https://stackoverflow.com/questions/10724594/build-certificate-chain-in-bouncycastle-in-c-sharp"">Build certificate chain in BouncyCastle in C#</a></p>

<p>What is the correct way to build a certificate chain for the signature container in iTextSharp? </p>
","","1135","<c#><pdf><itextsharp><itext><pkcs#7>","0","","0","2014-02-18 14:52:23","","6","","-1","","2017-05-23 11:43:48","2014-02-04 10:06:51",""
"15979542","Verify signature of PKCS#7 signed file using Python","<p>On Linux, I need to verify the signature of a PKCS#7 signed file and retrieve its original contents using Python and its standard libraries.</p>

<p>Currently, I can verify the contents of this file (and retrieve its actual contents) using OpenSSL terminal utility as follows:</p>

<pre><code>openssl smime -verify -in myfile.xml -inform DER -noverify
</code></pre>

<p>I have received this command from a friend. I don't really understand the options and directives. Is there any way to do this with Python without using any 3rd party libraries?</p>

<p>Thanks in advance.</p>
","","1128","<python><linux><openssl><pkcs#7>","1","","0","2013-04-12 19:36:16","","5","","","","","2013-04-12 19:36:16",""
"49071730","X509Certificate2 - Access Denied Exception if use ECC certificate","<p>I try to encrypt and decrypt data with <code>System.Security.Cryptography.Pkcs</code>, but it works only with <strong>RSA</strong> certificates, if I used an <strong>ECC</strong> (curve ECDH_brainpoolP512r1) certificate the constructor of <code>X509Certificate2</code> crashes with an <code>Access Denied</code> Exception.</p>

<h3>Create SelfSignedCertificate in Powershell</h3>

<pre><code>New-SelfSignedCertificate `
 -Subject ""CN=Test Code Signing RSA"" `
 -Type DocumentEncryptionCert `
 -KeyUsage ""DigitalSignature"" `
 -FriendlyName ""Test Code Signing"" `
 -NotAfter (get-date).AddYears(5) `
 -KeyExportPolicy Exportable `
 -SmimeCapabilities ` 
 -KeyAlgorithm ECDH_brainpoolP512r1
</code></pre>

<h3>Read SelfSignedCertificate in code</h3>

<pre><code>var base64cert = ""MIIF/wIBAzCCBbsGCSqGSIb3DQEHAaCCBawEggWoMIIFpDCCAkcGCSqGSIb3DQEHAaCCAjgEggI0MIICMDCCAiwGCyqGSIb3DQEMCgECoIIBNjCCATIwHAYKKoZIhvcNAQwBAzAOBAi2P5j9EliEaQICB9AEggEQyJLkopAMyHJh0jQXtnlwK4yjpE0WqYXf9sNPPLOFXgaxNU7gLKc3F6kPJUxLCxnvjOe7bRJS3v4A0GQBBqeFEJjBT9hd88RaQ2NsNxDrQEh/ZAyTUg+l6CyApUtcJb5uehPVnj7xnWtu4vvxDh5hRqSVxSR50wOjk/MKlyX1hhF1JybzRiqESKIMLx84HWJqZ6Fp87asJ0/0isL+kVxarqLrTkv0CGt2QaLxZzu9YDGj6nuGy2EBQwGHwMCEVTFupX55njV4aU3YTG2U+BHFl667NekTtOXH5GXDbp6D+9PntXBxW2d3E68v7lBVMjPKfTsTeCs4aLOwQzsXIFgvouw6GgGsZCrYaQwMNuGayC4xgeIwDQYJKwYBBAGCNxECMQAwEwYJKoZIhvcNAQkVMQYEBAEAAAAwXQYJKoZIhvcNAQkUMVAeTgB0AGUALQA0ADYANwBmADEAOAAxAGMALQBiAGQAZQA0AC0ANAA5AGUANgAtAGEANABjADMALQA4ADQAOAAwADYAMgBmADIANgA4ADEAMTBdBgkrBgEEAYI3EQExUB5OAE0AaQBjAHIAbwBzAG8AZgB0ACAAUwBvAGYAdAB3AGEAcgBlACAASwBlAHkAIABTAHQAbwByAGEAZwBlACAAUAByAG8AdgBpAGQAZQByMIIDVQYJKoZIhvcNAQcBoIIDRgSCA0IwggM+MIIDOgYLKoZIhvcNAQwKAQOgggLdMIIC2QYKKoZIhvcNAQkWAaCCAskEggLFMIICwTCCAiagAwIBAgIQXQFCNRCYc4hHLhQAD247rTAJBgcqhkjOPQQBMDAxLjAsBgNVBAMMJVRlc3QgQ29kZSBTaWduaW5nIEVDQyBicmFpbnBvb2xQNTEycjEwHhcNMTgwMzAyMTQyMTQ1WhcNMjMwMzAyMTQzMTQ2WjAwMS4wLAYDVQQDDCVUZXN0IENvZGUgU2lnbmluZyBFQ0MgYnJhaW5wb29sUDUxMnIxMIGbMBQGByqGSM49AgEGCSskAwMCCAEBDQOBggAETcwT2kPzMxF5upq+xb2NpTmRk2Gkp1mThVESNI9A1tgWk3wIylN72b1t5yHxveiWdopn3LkeT0hTaXSJ4fZsHmYRo0KZS5fKZbSSiFlLbxAwndgG99HLakz/I59WtXzSenSaM6HkP+Nz0Kmxvvy0umOXLg0bU8qpX5tLUtEFAxOjgd8wgdwwDgYDVR0PAQH/BAQDAgeAMBQGA1UdJQQNMAsGCSsGAQQBgjdQATCBlAYJKoZIhvcNAQkPBIGGMIGDMAsGCWCGSAFlAwQBKjALBglghkgBZQMEAS0wCwYJYIZIAWUDBAEWMAsGCWCGSAFlAwQBGTALBglghkgBZQMEAQIwCwYJYIZIAWUDBAEFMAoGCCqGSIb3DQMHMAcGBSsOAwIHMA4GCCqGSIb3DQMCAgIAgDAOBggqhkiG9w0DBAICAgAwHQYDVR0OBBYEFMmLfUI9zvfjMlvbolK8pP0zeZNhMAkGByqGSM49BAEDgYkAMIGFAkEAlCq9PiR4Yl0A+kIZO1yyfmKpcmJI6++jZJJ1P2LxZIi9ZgIJQLIWjmBTMP1nswAzNbnqetOBuJy55+SkO2OsngJAGXIYtW8RBFcTmRYnhCLeIsB/De3khytnaeHNBZVB/x0n/gFqVNMaPZp6l4MPGhEBS8pcvLN4zvO7phxR0Xt3HDFKMBMGCSqGSIb3DQEJFTEGBAQBAAAAMDMGCSqGSIb3DQEJFDEmHiQAVABlAHMAdAAgAEMAbwBkAGUAIABTAGkAZwBuAGkAbgBnAAAwOzAfMAcGBSsOAwIaBBSas13IRWnhNtoPLKp29FJpLmCptgQUkF0JRqyYiDG0Ql7zAPED2uVWzykCAgfQ"";
new System.Security.Cryptography.X509Certificates.X509Certificate2(Convert.FromBase64String(base64cert), ""qwert"");
</code></pre>

<h3>Exception</h3>

<pre><code>Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException: Access Denied
   at Internal.Cryptography.Pal.CertificatePal.FilterPFXStore(Byte[] rawData, SafePasswordHandle password, PfxCertStoreFlags pfxCertStoreFlags)
   at Internal.Cryptography.Pal.CertificatePal.FromBlobOrFile(Byte[] rawData, String fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
   at System.Security.Cryptography.X509Certificates.X509Certificate..ctor(Byte[] rawData, String password, X509KeyStorageFlags keyStorageFlags)
   at System.Security.Cryptography.X509Certificates.X509Certificate2..ctor(Byte[] rawData, String password)
   at PkcsEncryption.Program.Certificate(Boolean rsa) in c:\git\PkcsEncryption\PkcsEncryption\Program.cs:line 88
   at PkcsEncryption.Program.Encrypt(Byte[] dataPlain, Boolean useRsa) in c:\git\PkcsEncryption\PkcsEncryption\Program.cs:line 56
   at PkcsEncryption.Program.Main(String[] args) in c:\git\PkcsEncryption\PkcsEncryption\Program.cs:line 22
</code></pre>
","<p>The PFX which you have encoded as base64 there has internally set the marker indicating it was exported from a machine keystore.  Your Access Denied indicates that you are not running as an administrator (and thus do not have the permission to add keys to the machine's keystore).</p>

<p>To ensure that keys from a PFX get added to the current user's key store set the <code>X509KeyStorageFlags.UserKeySet</code> flag.  Or, if you've installed the early access build (or, in the future, the released build) of .NET Framework v4.7.2 you can use <code>EphemeralKeySet</code> to keep the private key in memory and avoid the keystore altogether.</p>

<pre><code>new System.Security.Cryptography.X509Certificates.X509Certificate2(
    Convert.FromBase64String(base64cert),
    ""qwert"",
    X509KeyStorageFlags.UserKeySet);
</code></pre>
","1113","<c#><public-key-encryption><x509certificate2><elliptic-curve><pkcs#7>","1","7","1","2018-03-09 16:19:08","49197965","0","1","1776231","","2018-03-09 08:57:23","2018-03-02 15:00:13",""
"11163760","Chain error and Verifying certificate","<p>I got a problem with <a href=""http://en.wikipedia.org/wiki/PKCS"" rel=""nofollow"">PKCS #7</a> that's driving me nuts. Here's is the thing:</p>

<ol>
<li><p>I have an <a href=""http://en.wikipedia.org/wiki/ASP.NET"" rel=""nofollow"">ASP.NET</a> webservice that makes requests to another third-party server and receives a PKCS #7 signed token in response (it's actually not important where this token comes from). My web service then checks the token's signature (and validity) and returns the enclosed data to the user that invoked the method.</p></li>
<li><p>The web service is configured to run in a dedicated application pool, which runs under a Windows <a href=""http://en.wikipedia.org/wiki/Active_Directory"" rel=""nofollow"">AD</a> user account, <a href=""http://en.wikipedia.org/wiki/Internet_Information_Services"" rel=""nofollow"">IIS</a> 6.</p></li>
<li><p>To perform the verification, I do this (signature has the token):</p>

<pre><code>public static byte[] VerifyAndExtractEnvelopedData(byte[] signature)
{
    if (signature == null)
        throw new ArgumentNullException(""signature"");

    // Decode the signature
    SignedCms cms = new SignedCms();
    cms.Decode(signature);
    cms.CheckSignature(false);

    if (cms.Detached)
        throw new InvalidOperationException(""Cannot extract enveloped content from a detached signature."");

    return cms.ContentInfo.Content;
}
</code></pre></li>
<li><p>I deployed the web service (IIS 6). When I try to run the afore mentioned webmethod, upon the signature verification, I get the error:</p>

<blockquote>
  <p>A certificate chain could not be built to a trusted root authority</p>
</blockquote></li>
</ol>

<p>In order to simplify things, I wrote a little Windows Forms application with the exact same code. I logged in interactively to the same server where the web service is hosted, using the same user account in the application pool's. Run the EXE file there and it works fine, that is,  were able to verify the signature perfectly. IMO, this rules out any problem like a missing  <a href=""http://en.wikipedia.org/wiki/Certificate_authority"" rel=""nofollow"">certificate authority</a> (CA) certificate and so on (in fact, I have the signer's .CER file, I open it in Windows, and it tells me that the chain is OK).</p>

<p>So apparently the only difference is that in the first case my process is a web service and in the second a desktop EXE file. What else could be happening that prevents me to perform the verification in the first case?</p>
","<p>I think you could be hitting different trust stores on the relying party, see <em><a href=""http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/sag_cmuncertstor.mspx?mfr=true"" rel=""nofollow"">Certificate stores</a></em>.</p>

<p>Also, check out the involved certificates with PKIF, PITT, Portecle or similar tools for validity, proper OIDs, chaining, etc.</p>
","1100","<.net><web-services><certificate><keychain><pkcs#7>","0","0","1","2013-06-12 17:10:31","","0","","63550","","2013-06-12 17:06:22","2012-06-22 20:37:32",""
"38594334","Adding Certificates to CMS Signed Data","<p>I am currently using the java Bouncy Castle libraries in order to create CMS signed data (or PKCS7 signed data). I seem however to be stuck with adding certificates (even though the certificate signer is properly added).</p>

<p>I checked out <a href=""https://stackoverflow.com/questions/10424968/add-signed-authenticated-attributes-to-cms-signature-using-bouncycastle"">this question</a> about properly signing data, but it didn't respond the needs of my SCEP server. The code I used was from EJBCA but doesn't seem to add certificates to the PKCS7 signed data.</p>

<p>When I parse the signed data with the <code>openssl cms</code> tool, I see that the ""certificates"" field is ""EMPTY"". Additionally, when I try to the print the certs with <code>openssl pkcs7 [...] -print_certs</code>, I get nothing.</p>

<p>Here is how I sign my data with Bouncy Castle (it's a lot code but enough to reproduce the issue):</p>

<pre><code>CMSEnvelopedDataGenerator edGen = new CMSEnvelopedDataGenerator();
CMSTypedData msg;
List&lt;X509Certificate&gt; certList = new ArrayList&lt;&gt;();
// Make sure the certificate is not null
if (this.certificate != null) {
    certList.add((X509Certificate) this.certificate);
}

/**
* Create the signed CMS message to be contained inside the envelope
* this message does not contain any message, and no signerInfo
**/
CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
Collection&lt;JcaX509CertificateHolder&gt; x509CertificateHolder = new ArrayList&lt;&gt;();
try {
    for (X509Certificate certificate : certList) {
        x509CertificateHolder.add(new JcaX509CertificateHolder(certificate));
    }
    CollectionStore&lt;JcaX509CertificateHolder&gt; store = new CollectionStore&lt;&gt;(x509CertificateHolder);
    gen.addCertificates(store);
} catch (Handle all exceptions) {}
</code></pre>

<p>This snippet of code above should normally add certificates. I took this from EJBCA.</p>

<p>Here is how I complete the signed data:    </p>

<pre><code>CMSSignedDataGenerator gen1 = new CMSSignedDataGenerator();
// I add ALL of my attributes here
// Once they're added...
Certificate caCert = this.caCertificate;
try {
    String provider = BouncyCastleProvider.PROVIDER_NAME;
    ContentSigner contentSigner = new JcaContentSignerBuilder(signatureAlgorithmName).
            setProvider(provider).
            build(signerKey);
    JcaDigestCalculatorProviderBuilder calculatorProviderBuilder = new JcaDigestCalculatorProviderBuilder().
            setProvider(provider);
    JcaSignerInfoGeneratorBuilder builder = new JcaSignerInfoGeneratorBuilder(calculatorProviderBuilder.build());
    builder.setSignedAttributeGenerator(new DefaultSignedAttributeTableGenerator(new AttributeTable(attributes)));
    gen1.addSignerInfoGenerator(builder.build(contentSigner, (X509Certificate) ca));
} catch (Handle all exceptions) {}

// Create the signed data
CMSSignedData sd = gen1.generate(msg, true);
byte[] results = sd.getEncoded();
</code></pre>

<p>The bytes array results is the DER formatted PKCS7 signed data... but no certificate is added.</p>

<p>Am I missing something? Thank you for your help!</p>
","<p>The <code>CMSSignedDataGenerator gen1</code> has to explicitly add the certificate, which I wasn't aware of.</p>

<p>It can simply be done by:</p>

<ul>
<li>Adding the certificates to a <code>List</code> of <code>X509Certificates</code>;</li>
<li>Converting that <code>List</code> into a <code>Collection</code> of <code>JcaX509CertificateHolder</code>;</li>
<li>Adding this collection to a <code>CollectionStore</code> of <code>JcaX509CertificateHolder</code>;</li>
<li>Adding the store the <code>CMSSignedDataGenerator</code>.</li>
</ul>

<p>Code sample:</p>

<pre><code> CMSSignedDataGenerator gen1 = new CMSSignedDataGenerator();
 List&lt;X509Certificate&gt; certificates = new ArrayList&lt;&gt;();

 // I chose to add the CA certificate
 certificates.add((X509Certificate) this.caCertificate);

 // In this case, this is a certificate that I need to add
 if (this.certificate != null)
     certificates.add((X509Certificate) this.certificate);

 // This is the recipient certificate
 if (this.recipientCert != null)
     certificates.add((X509Certificate) this.recipientCert);
 Collection&lt;JcaX509CertificateHolder&gt; x509CertificateHolder = new ArrayList&lt;&gt;();

 // Of course, we need to handle the exceptions...
 for (X509Certificate certificate : certificates) {
     x509CertificateHolder.add(new JcaX509CertificateHolder(certificate));
 }
 CollectionStore&lt;JcaX509CertificateHolder&gt; store = new CollectionStore&lt;&gt;(x509CertificateHolder);

// The final stage.
 gen1.addCertificates(store);
</code></pre>

<p>Hope this helps anyone in the future.</p>
","1099","<java><openssl><bouncycastle><pkcs#7>","1","0","1","2016-07-27 11:59:15","38612328","0","","-1","","2017-05-23 12:08:04","2016-07-26 15:40:01",""
"35846427","PdfPKCS7 .verify() return false","<p>I have been working with itextpdf-5.5.5, and the Integrity check return false. </p>

<pre><code>PdfPKCS7 pkcs7 = fields.verifySignature(name);

pkcs7.verify();&lt;------ HERE return false
</code></pre>

<p>But Adobe Acrobat Reader say: Signed and all signatures are valid. :( </p>

<p>This is the document: <a href=""http://itext.2136553.n4.nabble.com/file/n4661004/Test.pdf"" rel=""nofollow"">Test.pdf</a>. </p>

<p>Could someone explain what is happening?. </p>

<p>Thanks in advance</p>
","<p>The CMS signature container embedded in your PDF has some questionable properties. In particular it has an encapsulated content, even though it merely is a byte array of length 0. This makes iText include this value in a test which then fails. I would propose creating cleaner signature containers.</p>

<h2>In detail</h2>

<p>The CMS object type <code>EncapsulatedContentInfo</code> is specified as:</p>

<blockquote>
  <h2>5.2.  EncapsulatedContentInfo Type</h2>
  
  <p>The content is represented in the type EncapsulatedContentInfo:</p>

<pre><code> EncapsulatedContentInfo ::= SEQUENCE {
    eContentType ContentType,
    eContent [0] EXPLICIT OCTET STRING OPTIONAL }

 ContentType ::= OBJECT IDENTIFIER
</code></pre>
  
  <p>The fields of type EncapsulatedContentInfo have the following
     meanings:</p>
  
  <blockquote>
    <p>eContentType is an object identifier.  The object identifier
          uniquely specifies the content type.</p>
    
    <p>eContent is the content itself, carried as an octet string.  The
          eContent need not be DER encoded.</p>
  </blockquote>
  
  <p>The optional omission of the eContent within the
     EncapsulatedContentInfo field makes it possible to construct
     ""external signatures"".  In the case of external signatures, the
     content being signed is absent from the EncapsulatedContentInfo value
     included in the signed-data content type.  If the eContent value
     within EncapsulatedContentInfo is absent, then the signatureValue is
     calculated and the eContentType is assigned as though the eContent
     value was present.</p>
  
  <p><em>(<a href=""https://tools.ietf.org/html/rfc5652#section-5.2"" rel=""nofollow"">RFC 5652 section 5.2</a>)</em></p>
</blockquote>

<p>So for signature containers embedded into a PDF, <code>eContent</code> should be omitted to indicate that not this <code>eContent</code> is signed but separate data, the surrounding PDF data.</p>

<p>The signature container of the OP's signed document contains this <code>EncapsulatedContentInfo</code> object:</p>

<pre><code>    &lt;30 0F&gt;
  43   15:       SEQUENCE {
    &lt;06 09&gt;
  45    9:         OBJECT IDENTIFIER data (1 2 840 113549 1 7 1)
         :           (PKCS #7)
    &lt;A0 02&gt;
  56    2:         [0] {
    &lt;04 00&gt;
  58    0:           OCTET STRING
         :           }
         :         }
</code></pre>

<p>Thus, this signature container does not have omitted the <code>eContent</code> and so makes iText include this array into its checks to eventually fail.</p>

<h2>This actually is a bug, though</h2>

<p>I formulated the above in a fairly restrained manner for a simple reason: Even though that use of the <code>EncapsulatedContentInfo</code> type is misleading, it is <strong>not outright invalid</strong> in the case at hand!</p>

<p>For the original ISO 32000-1 integrated signatures, that norm specified</p>

<blockquote>
  <p>When PKCS#7 signatures are used, the value of <strong>Contents</strong> shall be a DER-encoded PKCS#7 binary data
  object containing the signature. The PKCS#7 object shall conform to RFC3852 Cryptographic Message
  Syntax. Different subfilters may be used and shall be registered in accordance with Annex E. <strong>SubFilter</strong> shall
  take one of the following values:</p>
  
  <ul>
  <li><p><strong>adbe.pkcs7.detached</strong>: The original signed message digest over the document‚Äôs byte range shall be
  incorporated as the normal PKCS#7 SignedData field. No data shall be encapsulated in the PKCS#7
  SignedData field.</p></li>
  <li><p><strong>adbe.pkcs7.sha1</strong>: The SHA1 digest of the document‚Äôs byte range shall be encapsulated in the PKCS#7
  SignedData field with ContentInfo of type Data. The digest of that SignedData shall be incorporated as the
  normal PKCS#7 digest.</p></li>
  </ul>
  
  <p><em>(<a href=""http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf"" rel=""nofollow"">ISO 32000-1</a> section 12.8.3.3 PKCS#7 Signatures as used in ISO 32000)</em></p>
</blockquote>

<p>So for such signatures there either was no encapsulated data (not even a zero-length byte array) or the encapsulated data were a digest value to check.</p>

<p>This is why iText's verification code in one place assumes it is in the latter case: As there is some encapsulated content, it must be a hash to check.</p>

<hr>

<p>The signature at hand, though, is not of one of those original types but it uses <strong>SubFilter ETSI.CAdES.detached</strong>. These signatures are originally specified by ETSI:</p>

<blockquote>
  <h2>4.2 General Requirements</h2>
  
  <p>For all profiles covered in the present document: </p>
  
  <p>b) A DER-encoded SignedData object as specified in CMS (RFC 3852) shall be included as the PDF
  signature in the entry with the key <strong>Content</strong> of the signature dictionary as described in ISO 32000-1,
  clause 12.8.1. This CMS object forms a CAdES signature described in TS 101 733 as it may contain
  several attributes required by the rules given in the following clauses. </p>
  
  <p>d) Requirements specified in ISO 32000-1, clauses 12.8.3.2 (PKCS#1) and 12.8.3.3 (PKCS#7) signatures as
  used in ISO 32000-1 do not apply. </p>
  
  <h2>4.6.2 Document Digest</h2>
  
  <p>The verifier shall check that the document digest matches that in the signature as specified in ISO 32000-1,
  clause 12.8.1 </p>
  
  <p><em>(<a href=""https://www.etsi.org/deliver/etsi_ts/102700_102799/10277803/01.01.02_60/ts_10277803v010102p.pdf"" rel=""nofollow"">ETSI TS 102 778-3 V1.1.2 (2009-12)</a>)</em></p>
</blockquote>

<p>So for signatures as in the case at hand, the section from ISO 32000-1 partially quoted before does not apply, and the hash in the signature (the message-digest attribute) has to match the document digest (calculated as defined by ISO 32000-1, i.e. only for the defined byte ranges) without consideration of the encapsulated content.</p>

<h2>A workaround</h2>

<p>If you slightly patch the <code>PdfPKCS7</code> object <em>before</em> calling <code>PdfPKCS7.verify()</code>, you can positively verify the document with iText, cf. the test <a href=""https://github.com/mkl-public/testarea-itext5/blob/master/src/test/java/mkl/testarea/itext5/signature/VerifySignature.java"" rel=""nofollow"">VerifySignature.java</a>:</p>

<p>While the original verification</p>

<pre><code>System.out.println(""Signature name: "" + name);
System.out.println(""Signature covers whole document: "" + acroFields.signatureCoversWholeDocument(name));
PdfPKCS7 pk = acroFields.verifySignature(name);
System.out.println(""Subject: "" + CertificateInfo.getSubjectFields(pk.getSigningCertificate()));
System.out.println(""Document verifies: "" + pk.verify());
</code></pre>

<p>returns a failure</p>

<pre><code>Signature name: Signature1
Signature covers whole document: false
Subject: {SURNAME=[CHARPENTIER DIAZ], C=[CR], OU=[CIUDADANO], SN=[CPF-01-1093-0964], CN=[JOSE ALBERTO CHARPENTIER DIAZ (FIRMA)], GIVENNAME=[JOSE ALBERTO], O=[PERSONA FISICA]}
Document verifies: false
</code></pre>

<p>the patched verification</p>

<pre><code>System.out.println(""Signature name: "" + name);
System.out.println(""Signature covers whole document: "" + acroFields.signatureCoversWholeDocument(name));
PdfPKCS7 pk = acroFields.verifySignature(name);
System.out.println(""Subject: "" + CertificateInfo.getSubjectFields(pk.getSigningCertificate()));

Field rsaDataField = PdfPKCS7.class.getDeclaredField(""RSAdata"");
rsaDataField.setAccessible(true);
Object rsaDataFieldContent = rsaDataField.get(pk);
if (rsaDataFieldContent != null &amp;&amp; ((byte[])rsaDataFieldContent).length == 0)
{
    System.out.println(""Found zero-length encapsulated content: ignoring"");
    rsaDataField.set(pk, null);
}
System.out.println(""Document verifies: "" + pk.verify());
</code></pre>

<p>returns a success:</p>

<pre><code>Signature name: Signature1
Signature covers whole document: false
Subject: {SURNAME=[CHARPENTIER DIAZ], C=[CR], OU=[CIUDADANO], SN=[CPF-01-1093-0964], CN=[JOSE ALBERTO CHARPENTIER DIAZ (FIRMA)], GIVENNAME=[JOSE ALBERTO], O=[PERSONA FISICA]}
Found zero-length encapsulated content: ignoring
Document verifies: true
</code></pre>

<p>(The patch attempts to be gentle and only patches zero-length byte arrays to <code>null</code>.)</p>
","1096","<pdf><itext><digital-signature><pkcs#7>","0","3","1","2016-03-08 11:39:49","35863488","0","2","3587281","","2016-03-07 23:13:35","2016-03-07 14:36:52",""
"22211319","PKCS7_sign returns null","<p>I've been trying to get a pkcs#7 signature to happen in c++, and I've only succeeded in growing more gray hairs.</p>

<p>I get a *.cer file from Apple, and build a *.p12 file using <a href=""http://www.youtube.com/watch?v=1X10zCzhukI"" rel=""nofollow"" title=""Keychain Access"">Keychain Access</a>.  Once I have that, I fire up Eclipse, and slurp in the p12 file that I generated.  The rest can be found below:</p>

<pre><code>BIO *bio = BIO_new(BIO_s_mem());
FILE *fp = fopen((char *)""/path/to/cert.p12"", ""rb"");
EVP_PKEY *pkey = EVP_PKEY_new();
X509 *cert = X509_new();
STACK_OF(X509) *ca = sk_X509_new_null();
PKCS12 *p12 = NULL;
PKCS7 *p7 = NULL;

BIO_read_filename(bio, '/path/to/data.txt');

if (!fp) {
  fprintf(stderr, ""Error opening cert.p12\n"");
  exit(1);
}

d2i_PKCS12_fp(fp, &amp;p12);

if (!p12) {
  fprintf(stderr, ""Error reading PKCS#12 file\n"");
  ERR_print_errors_fp(stderr);
  exit (1);
}

// That's amazing.  I have the same combination on my luggage!
if (!PKCS12_parse(p12, (char *)""12345"", &amp;pkey, &amp;cert, &amp;ca)) {
  fprintf(stderr, ""Error parsing PKCS#12 file\n"");
  ERR_print_errors_fp(stderr);
  exit (1);
}

p7 = PKCS7_sign(cert, pkey, ca, bio, PKCS7_TEXT);
</code></pre>

<p>I tried dumping out the cert, pkey and chain to a file.  It all worked as expected (the chain was empty, but I wasn't expecting anything).  It looks like p7 is still null after the signature.  I tried to use the p7 object, and I get a segmentation fault.</p>

<p>Anyone ever come across anything like this?</p>
","<blockquote>
  <p>Anyone ever come across anything like this?</p>
</blockquote>

<p>Do you mean hard to use and documentation with an opportunity for improvement? Yes.</p>

<p>Here's the official OpenSSL docs: <a href=""https://www.openssl.org/docs/crypto/PKCS7_sign.html"" rel=""nofollow"">PKCS7_sign(3)</a>.</p>

<hr>

<pre><code>$ cd openssl-1.0.1f/apps
$ grep -R PKCS7_sign *
smime.c: p7 = PKCS7_sign(NULL, NULL, other, in, flags);
</code></pre>

<p>Here's the sample code from <code>smime.c</code>:</p>

<pre><code>PKCS7 *p7 = NULL;
BIO *in = NULL, *out = NULL;
STACK_OF(X509) *other = NULL;
const EVP_MD *sign_md  
int flags = 0;

other = load_certs(bio_err,certfile,FORMAT_PEM, NULL, e, ""certificate file"");

sign_md = EVP_get_digestbyname(""sha256"");

flags |= PKCS7_STREAM;
flags |= PKCS7_PARTIAL;
p7 = PKCS7_sign(NULL, NULL, other, in, flags);

for (i = 0; i &lt; sk_OPENSSL_STRING_num(sksigners); i++) {
    ...
    signer = load_cert(bio_err, signerfile,FORMAT_PEM, NULL, e, ""signer certificate"");
    PKCS7_sign_add_signer(p7, signer, key, sign_md, flags))
}

PKCS7_final(p7, in, flags);
...

PEM_write_bio_PKCS7(out, p7);
</code></pre>
","1086","<c++><ios><openssl><pkcs#7><pkcs#12>","1","1","1","2014-03-06 10:07:54","","1","0","","","","2014-03-05 23:03:07",""
"27562220","PKCS#7 Decryption Code in Java","<p>I am very new to this area. I'm trying to develop a simply PCKS#7 encrypt/decrypt function in Java. 
The encrypt is without signing yet, I just want to test the encrypt/decrypt (the key is from a keystore) </p>

<p>Below is my encryption code.</p>

<pre><code>private static byte[] encryptData() throws Exception {

    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    FileInputStream fIn = new FileInputStream(_keyStorePath);
    KeyStore keystore = KeyStore.getInstance(""JKS"");
    keystore.load(fIn, _password);
    Certificate cert = keystore.getCertificate(""abc"");
    fIn.close();

    // set up the generator
    CMSEnvelopedDataGenerator gen = new CMSEnvelopedDataGenerator();

    gen.addRecipientInfoGenerator(new JceKeyTransRecipientInfoGenerator((X509Certificate) cert).setProvider(""BC""));

    // create the enveloped-data object
    CMSProcessable data = new CMSProcessableByteArray(""Hello World!"".getBytes());
    CMSEnvelopedData enveloped = gen.generate((CMSTypedData) data,new JceCMSContentEncryptorBuilder(CMSAlgorithm.DES_EDE3_CBC).setProvider(""BC"").build());
    return  enveloped.getEncoded();
}
</code></pre>

<p>How do I code a very simple decryption function(no verify signing) to decryption my file ?</p>

<p>I do some research online, 1 of the sample code I google it is `RecipientId recId = new RecipientId();</p>

<pre><code>    recId.setSerialNumber(cert.getSerialNumber());
    recId.setIssuer(cert.getIssuerX500Principal().getEncoded());

    RecipientInformationStore recipients = enveloped.getRecipientInfos();
    RecipientInformation recipient = recipients.get(recId);

    byte[] recData = recipient.getContent(key, ""BC"");`
</code></pre>

<p>However, the ""RecipientId recId = new RecipientId();"" is not working, error msg : Cannot instantiate the type RecipientId </p>

<p>Thank you very much.</p>
","<p>I think there is some changes for the new API.</p>

<p>Below should be the correct one,</p>

<pre><code>X509Certificate cert9 = (X509Certificate) keystore.getCertificate(""abc"");
    KeyTransRecipientId recId = new JceKeyTransRecipientId(cert9.getIssuerX500Principal(), cert9.getSerialNumber());
</code></pre>
","1071","<java><encryption><pkcs#7>","0","0","1","2015-01-08 02:05:36","","0","","","","","2014-12-19 08:30:03",""
"24095929","PHP PKCS7 Padding bug","<p>I am trying to apply PKCS7 padding to my PHP code. I derived my code from this gist</p>

<p><a href=""https://gist.github.com/Halama/5956871"" rel=""nofollow"">https://gist.github.com/Halama/5956871</a></p>

<p>The blocksize is expected to be 16 bytes.
The data is ""password"" with a length of 8 bytes.
After getting the pad, it will append it at the end of the data to be encrypted.</p>

<pre><code>$blockSize = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, $thisMCRYPT_MODE_CBCmode);
$pad = $blockSize - (strlen($data) % $blockSize);
$data = $data . str_repeat(chr($pad), $pad);
</code></pre>

<p>The problem is there are (a lot) of instances that where the data fails to decrypt it.</p>

<p>Provided below are base64 encoded sample data. The first 16 bytes of the decoded sample represents the IV</p>

<blockquote>
  <p><strong>working:</strong> cjg1RYWxlc8bDH2de43t0bv1ug36i8ayjWDQTela938= (pad length: 8)</p>
  
  <p><strong>not working:</strong> 9wWI+MyYj5ZVj2sC4xr7EgOsgNSoeTZW1yM8ddmqg18= (pad length:
  122)</p>
</blockquote>

<p>The pad length mentioned above is retrieved using this</p>

<pre><code>$pad = ord($data[strlen($data) - 1]);
</code></pre>

<p>I am using mcrypt_enrypt to encrypt the string ""password"". The key I am using for mcrypt is</p>

<blockquote>
  <p>lGbsVE+qVO1P2ue0iCjrTPMU5hKX9aHE7r1aUUeqFag=</p>
</blockquote>
","<p>The padding/unpadding routine looks correct. What it does not provide is a safeguard against padding values higher than the block size.</p>

<p>If a ciphertext is decrypted using a wrong key, or if the ciphertext is corrupted (and for short sized ciphertext, even if the IV is incorrect), the result will be a (padded) plaintext that has seemingly random data. So the last byte can have any random value during the unpadding of the incorrect result.</p>

<p>To protect against such failures, use a MAC value over the ciphertext, preferably using a different key. For now, the issue is not likely to be the (un)padding routine.</p>
","1057","<php><encryption><padding><mcrypt><pkcs#7>","0","0","2","2014-06-09 09:39:57","24117502","0","","","","","2014-06-07 09:49:19",""
"24095929","PHP PKCS7 Padding bug","<p>I am trying to apply PKCS7 padding to my PHP code. I derived my code from this gist</p>

<p><a href=""https://gist.github.com/Halama/5956871"" rel=""nofollow"">https://gist.github.com/Halama/5956871</a></p>

<p>The blocksize is expected to be 16 bytes.
The data is ""password"" with a length of 8 bytes.
After getting the pad, it will append it at the end of the data to be encrypted.</p>

<pre><code>$blockSize = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, $thisMCRYPT_MODE_CBCmode);
$pad = $blockSize - (strlen($data) % $blockSize);
$data = $data . str_repeat(chr($pad), $pad);
</code></pre>

<p>The problem is there are (a lot) of instances that where the data fails to decrypt it.</p>

<p>Provided below are base64 encoded sample data. The first 16 bytes of the decoded sample represents the IV</p>

<blockquote>
  <p><strong>working:</strong> cjg1RYWxlc8bDH2de43t0bv1ug36i8ayjWDQTela938= (pad length: 8)</p>
  
  <p><strong>not working:</strong> 9wWI+MyYj5ZVj2sC4xr7EgOsgNSoeTZW1yM8ddmqg18= (pad length:
  122)</p>
</blockquote>

<p>The pad length mentioned above is retrieved using this</p>

<pre><code>$pad = ord($data[strlen($data) - 1]);
</code></pre>

<p>I am using mcrypt_enrypt to encrypt the string ""password"". The key I am using for mcrypt is</p>

<blockquote>
  <p>lGbsVE+qVO1P2ue0iCjrTPMU5hKX9aHE7r1aUUeqFag=</p>
</blockquote>
","<p>solved it. the ""+"" signs in the base64 encoded data is being converted to spaces when transported through http thus resulting into different values.</p>

<p>What I did is the client encoded the binary data to base64 and passed it through urlencode() function. The PHP side handled the data by using <strong>rawurldecode</strong> so it will ignore the ""+"" signs.</p>
","1057","<php><encryption><padding><mcrypt><pkcs#7>","0","0","2","2014-06-09 09:39:57","24117502","0","","","","","2014-06-07 09:49:19",""
"3090258","Signature Generation using PKCS#7 Specifications","<p>I want to prepare a digital signature over some content using PKCS#7 specifications(only Signed Data). I am getting signer certificates by accessing SMART card device. I am using BouncyCastle as a provider in Java and using getEncoded method of CMSSignedData class but the output i am getting is not right and its not working. Can anybody tell me the correct procedure or some sample code to doing the same</p>
","<p>prepare a signedData using </p>

<pre><code>crypto.signText(""textTosign"",""ask"")
</code></pre>

<p>'byteArr' will be ur signedData it  will BASE64 encoded do decode it pass that to CMSSignedData</p>

<pre><code>CMSSignedData csd = new CMSSignedData(byteArr);
CertStore cStore = csd.getCertificatesAndCRLs(""Collection"", ""BC"");
        SignerInformationStore signers = csd.getSignerInfos();
        Collection&lt;SignerInformation&gt; lstSigner = signers.getSigners();
</code></pre>
","1045","<java><digital-signature><pkcs#7>","1","1","1","2010-10-28 05:54:41","","0","","134176","","2010-06-22 04:25:11","2010-06-22 04:23:15",""
"12465931","Encode PKCS7 in Google App Engine (python, passbook)","<p>This question pertains to Passbook which is under NDA for the next few days, but this is a generic PKCS7 question.</p>

<p>I have a .p12 file that is exported from my keychain.  I am able to separate this into 2 pems using the following commands</p>

<pre><code>openssl pkcs12 -in ""mycert.p12"" -clcerts -nokeys -out certificate.pem
openssl pkcs12 -in ""mycert.p12"" -nocerts -out key.pem
</code></pre>

<p>The next step is to use this key and certificate to create a signed PKCS7 file.  This is easy to do with openssl:</p>

<pre><code>openssl smime -binary -sign \
    -signer certificate.pem -inkey key.pem \
    -in &lt;datafile&gt; -out signature \
    -outform DER
</code></pre>

<p>The question is, what is the best way to do this in Google App Engine, assuming I have the certificate and key?  Unfortunately I'm a little new to cryptography, but I've been googling around and found PyCrypto and keyczar.  Is there an accepted way to do this on App Engine, or will I need to write something?  Any recommendations on which package to start with?<br>
I know that openssl is not available on AppEngine, but PyCrypto is if you use python 2.7, right?  And I've seen posts of people getting keyczar to work with it.  I have not been able to find a simple way of generating PKCS7-encoded data given the key and certificate, though.</p>

<p>Thanks in advance for any guidance.</p>
","<p>Here's a way using M2Crypto taken from <a href=""https://github.com/devartis/passbook"" rel=""nofollow"">https://github.com/devartis/passbook</a></p>

<pre><code>def passwordCallback(*args, **kwds):
    return password

smime = SMIME.SMIME()
smime.load_key('key.pem', 'certificate.pem', callback=passwordCallback)        
pk7 = smime.sign(SMIME.BIO.MemoryBuffer(manifest), flags=SMIME.PKCS7_DETACHED | SMIME.PKCS7_BINARY)                
pem = SMIME.BIO.MemoryBuffer()
pk7.write(pem)
# convert pem to der
der = ''.join(l.strip() for l in pem.read().split('-----')[2].splitlines()).decode('base64')        

open('signature', 'w').write(der)
</code></pre>
","1034","<python><google-app-engine><encryption><pkcs#7><passbook>","3","1","1","2012-10-09 01:21:20","","1","2","","","","2012-09-17 19:31:41",""
"32048703","PKCS#7 signature verifies with OpenSSL, but not with M2Crypto","<p>I have a signed PKCS#7 structure <code>data-signed.pem</code>:</p>

<pre><code>$ openssl smime -sign -binary -in data.txt -inkey key.pem -outform pem -out p7.pem -signer cert.pem
</code></pre>

<p>It verifies successfully via OpenSSL command line:</p>

<pre><code>$ openssl smime -verify -CAfile cert.pem -content data.txt -in p7.pem -inform pem
[...]
Verification successful
</code></pre>

<p>But the same operation (IMO) fails with M2Crypto:</p>

<pre><code>$ python
&gt;&gt;&gt; from M2Crypto import SMIME, X509, BIO
&gt;&gt;&gt; sm_obj = SMIME.SMIME()
# The certificate is self-signed, so I add it to both
# trusted CA store and certificate stack:
&gt;&gt;&gt; x509 = X509.load_cert('cert.pem')
&gt;&gt;&gt; sk = X509.X509_Stack()
&gt;&gt;&gt; sk.push(x509)
&gt;&gt;&gt; sm_obj.set_x509_stack(sk)
&gt;&gt;&gt; st = X509.X509_Store()
&gt;&gt;&gt; st.load_info('cert.pem')
&gt;&gt;&gt; sm_obj.set_x509_store(st)
# Now the actual verification:
&gt;&gt;&gt; p7 = SMIME.load_pkcs7('p7.pem')
&gt;&gt;&gt; data_bio = BIO.MemoryBuffer('data.txt')
&gt;&gt;&gt; sm_obj.verify(p7, data_bio)
Traceback (most recent call last):
  File ""&lt;stdin&gt;"", line 1, in &lt;module&gt;
  File ""/usr/local/lib/python2.7/dist-packages/M2Crypto-0.22.3-py2.7-linux-i686.egg/M2Crypto/SMIME.py"", line 217, in verify
    blob = m2.pkcs7_verify1(p7, self.x509_stack._ptr(), self.x509_store._ptr(), data_bio._ptr(), flags)
M2Crypto.SMIME.PKCS7_Error: digest failure
</code></pre>

<p>If I create a non-detached signature, it verifies successfully:</p>

<pre><code>$ openssl smime -sign -nodetach -binary -in data.txt -inkey key.pem -outform pem -out data-nodetach-signed.pem -signer cert.pem
$ python
[...]
&gt;&gt;&gt; p7 = SMIME.load_pkcs7('data-nodetach-signed.pem')
&gt;&gt;&gt; content = sm_obj.verify(p7)
&gt;&gt;&gt;
</code></pre>

<p>How to use M2Crypto verification with detached signature?</p>
","<p>There was a silly mistake in what I was doing with M2Crypto: </p>

<pre><code>&gt;&gt;&gt; data_bio = BIO.MemoryBuffer('data.txt')
</code></pre>

<p>This, of course, does not read file 'data.txt', but reads the string 'data.txt', which does not verify. The correct line is</p>

<pre><code>&gt;&gt;&gt; data_bio = BIO.openfile('data.txt')
</code></pre>
","987","<python><openssl><digital-signature><pkcs#7><m2crypto>","0","1","1","2015-10-16 17:54:02","33176668","0","","3608247","","2015-10-15 19:28:02","2015-08-17 11:01:50",""
"34197756","Validate pkcs7 SignedData by Bouncy Castle in Java","<p>I am working on an implementation of C# SignedCms functionality in Java.</p>

<p>I have a pkcs7 <strong>SignedData</strong> (see my attachement: <a href=""https://www.dropbox.com/s/yivani7dvh98wpa/SignedData.bin?dl=0"" rel=""nofollow"">https://www.dropbox.com/s/yivani7dvh98wpa/SignedData.bin?dl=0</a>), it can be validated in C#:</p>

<pre><code>    //signed data is loaded from my attached file.
    bool VerifyPKCS7(byte[] signedData)
    {
        try
        {
            SignedCms signedCms = new SignedCms();
            signedCms.Decode(signedData);

            signedCms.CheckSignature(true);

            return true;
        }
        catch
        {

        }

        return false;
    }
</code></pre>

<p>But it can't be validated using Bouncy Castle libs(bcprov-jdk15on-153.jar, bcpkix-jdk15on-153.jar) in Java:</p>

<pre><code>  //encapSigData is loaded from my attached file.      
  CMSSignedDataParser     sp = new CMSSignedDataParser(new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build(), encapSigData);

  sp.getSignedContent().drain();

  Store                   certStore = sp.getCertificates();
  SignerInformationStore  signers = sp.getSignerInfos();

  Collection              c = signers.getSigners();
  Iterator                it = c.iterator();

  while (it.hasNext())
  {
      SignerInformation   signer = (SignerInformation)it.next();
      Collection          certCollection = certStore.getMatches(signer.getSID());

      Iterator        certIt = certCollection.iterator();
      X509CertificateHolder cert = (X509CertificateHolder)certIt.next();

      System.out.println(""verify returns: "" + signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert)));
  }
</code></pre>

<p>I got a exception at the first code line(<code>CMSSignedDataParser</code> constructor):</p>

<pre><code>java.lang.ClassCastException: org.bouncycastle.asn1.DERSequenceParser cannot be cast to org.bouncycastle.asn1.ASN1OctetStringParser
at org.bouncycastle.cms.CMSSignedDataParser.&lt;init&gt;(Unknown Source)
at org.bouncycastle.cms.CMSSignedDataParser.&lt;init&gt;(Unknown Source)
at org.bouncycastle.cms.CMSSignedDataParser.&lt;init&gt;(Unknown Source)
</code></pre>

<p>After some analyze, I find that the <strong>content</strong> of <strong>contentInfo</strong> in <strong>SignedData</strong> is a Sequence. It seems that bouncycastle can't accept a Sequence to be the <strong>content</strong>.</p>

<p>How can I get this <strong>SignedData</strong> to be validated using bouncycastle in Java?</p>
","<p>The issue here is that unlike a regular CMS message, this is really a PKCS7 one. Support for these has now been added to the bcpkix API in Bouncy Castle. </p>

<p>You can find it in the latest beta at <a href=""http://www.bouncycastle.org/betas"" rel=""nofollow"">http://www.bouncycastle.org/betas</a> 154b12 or later.</p>
","981","<java><c#><validation><pkcs#7>","0","1","1","2015-12-15 23:44:07","34301574","0","","","","","2015-12-10 09:14:12",""
"21053935","PHP openssl_pkcs7_* needs files, security issue","<p>I want to use these openssl_pkcs7_* functions to verify, sign, encrypt and decrypt mails.
I realized that these functions only accept filenames for the ""keyfile"", the certificate or the ""mail"" itself. </p>

<p>Imho thats a big security issue since there could be issues causing temporary files created for these files not being deleted. In that case, system operators, e.g. could read the encrypted message because its somewhere in the filesystem temporarily.</p>

<p>Now, I just want you guys to ask if any of you has an idea how I could ""fake"" a file on linux. e.g. using some /dev/ device like /dev/stdin or something like that. Any idea? Would be awesome. </p>

<p>These ""files"" should be read- and writable by ""www-data"".</p>

<p>Hope you guys have some amazing ideas for me.</p>

<p>With best regards,
Max</p>

<p>EDIT: ""tmpfile"" is a physically located file, there is no 100% guarantee of deletion tho.</p>

<p>EDIT2: Well, I am actually thinking about creating a socket (AF_UNIX and a socket-File) and let openssl write to it since its executed from the same process. But I dont get this to work, any suggestions?</p>
","<p>It's not very elegant, but you could use <code>ob_start</code> and stream wrappers to trick <code>openssl_pkcs7_decrypt</code> to not output a file.</p>

<pre><code>function pkcs7_decrypt_in_mem($infile, $cert, $key) {
    ob_start();
    $rtn = openssl_pkcs7_decrypt($infile, 'php://stdout', $cert, $key);
    $decrypted = ob_get_contents();
    ob_end_clean();

    if (!$rtn) { return FALSE; }
    return $decrypted;
}
</code></pre>

<p>The only <em>file</em> required to exist is <code>$infile</code>.  Both <code>$cert</code> and <code>$key</code> as passed by value, not by  file name.</p>
","980","<php><openssl><pkcs#7><pkcs#12>","2","3","2","2014-09-07 00:42:31","21070408","3","","1328527","","2014-01-11 13:56:20","2014-01-10 20:36:33",""
"21053935","PHP openssl_pkcs7_* needs files, security issue","<p>I want to use these openssl_pkcs7_* functions to verify, sign, encrypt and decrypt mails.
I realized that these functions only accept filenames for the ""keyfile"", the certificate or the ""mail"" itself. </p>

<p>Imho thats a big security issue since there could be issues causing temporary files created for these files not being deleted. In that case, system operators, e.g. could read the encrypted message because its somewhere in the filesystem temporarily.</p>

<p>Now, I just want you guys to ask if any of you has an idea how I could ""fake"" a file on linux. e.g. using some /dev/ device like /dev/stdin or something like that. Any idea? Would be awesome. </p>

<p>These ""files"" should be read- and writable by ""www-data"".</p>

<p>Hope you guys have some amazing ideas for me.</p>

<p>With best regards,
Max</p>

<p>EDIT: ""tmpfile"" is a physically located file, there is no 100% guarantee of deletion tho.</p>

<p>EDIT2: Well, I am actually thinking about creating a socket (AF_UNIX and a socket-File) and let openssl write to it since its executed from the same process. But I dont get this to work, any suggestions?</p>
","<blockquote>
  <p>I  want to use these openssl_pkcs7_* functions to verify, sign, encrypt and decrypt mails.</p>
</blockquote>

<p>The problem seems to be the choice of PHP's functions (or PHP's OpenSSL offerings). Perhaps you should use something else, like a library that provides what you need.</p>

<hr>

<p>Here's what is really available from OpenSSL. From <a href=""https://www.openssl.org/docs/crypto/PKCS7_encrypt.html"" rel=""nofollow"">PKCS7_encrypt(3)</a>:</p>

<pre><code>PKCS7 *PKCS7_encrypt(STACK_OF(X509) *certs, BIO *in, const EVP_CIPHER *cipher, int flags);
</code></pre>

<p>You use a <code>BIO</code> for the <code>in-data</code>, and that can be a memory <code>BIO</code>. There's no reason to write a disk file.</p>

<p>You have similar for <a href=""https://www.openssl.org/docs/crypto/PKCS7_decrypt.html"" rel=""nofollow"">PKCS7_decrypt(3)</a>:</p>

<pre><code>int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags);
</code></pre>

<p>Now, for the keys. The keys can be read (and written) using <code>BIO</code>s too. That means they can use a memory bio. But I'm not sure how useful that would be since the keys have to be stored somewhere.</p>

<p>For the reference, see <a href=""https://www.openssl.org/docs/crypto/pem.html"" rel=""nofollow"">pem(3)</a>. There's almost too many functions to list:</p>

<blockquote>
  <p>PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey,
  PEM_write_bio_PrivateKey, PEM_write_PrivateKey,
  PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey,
  PEM_write_bio_PKCS8PrivateKey_nid, PEM_write_PKCS8PrivateKey_nid,
  PEM_read_bio_PUBKEY, PEM_read_PUBKEY, PEM_write_bio_PUBKEY,
  PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey,
  PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey,
  PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey,
  PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey,
  PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY,
  PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY,
  PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey,
  PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey,
  PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY,
  PEM_write_bio_DSA_PUBKEY, PEM_write_DSA_PUBKEY,
  PEM_read_bio_DSAparams, PEM_read_DSAparams, PEM_write_bio_DSAparams,
  PEM_write_DSAparams, PEM_read_bio_DHparams, PEM_read_DHparams,
  PEM_write_bio_DHparams, PEM_write_DHparams, PEM_read_bio_X509,
  PEM_read_X509, PEM_write_bio_X509, PEM_write_X509,
  PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX,
  PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ,
  PEM_write_bio_X509_REQ, PEM_write_X509_REQ,
  PEM_write_bio_X509_REQ_NEW, PEM_write_X509_REQ_NEW,
  PEM_read_bio_X509_CRL, PEM_read_X509_CRL, PEM_write_bio_X509_CRL,
  PEM_write_X509_CRL, PEM_read_bio_PKCS7, PEM_read_PKCS7,
  PEM_write_bio_PKCS7, PEM_write_PKCS7,
  PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE,
  PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE</p>
</blockquote>

<hr>

<p>If you find something that offers more of OpenSSL, you might look into the <code>CMS_*</code> functions, too. They are easy to work with, too.</p>

<p>You can see examples of how to use them in <code>&lt;openssl dir&gt;/demos/cms_enc.c</code>, <code>&lt;openssl dir&gt;/demos/cms_dec.c</code>, <code>&lt;openssl dir&gt;/demos/cms_sign.c</code> and <code>&lt;openssl dir&gt;/demos/cms_verify.c</code>.</p>

<p>Two of the functions of interest are:</p>

<pre><code>CMS_ContentInfo *CMS_encrypt(STACK_OF(X509) *certs, BIO *in, const EVP_CIPHER *cipher, unsigned int flags);
</code></pre>

<p>and </p>

<pre><code>int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pkey, X509 *cert, BIO *dcont, BIO *out, unsigned int flags);
</code></pre>
","980","<php><openssl><pkcs#7><pkcs#12>","2","0","2","2014-09-07 00:42:31","21070408","3","","1328527","","2014-01-11 13:56:20","2014-01-10 20:36:33",""
"21572886","Adding a certificate chain to a PKCS#7/CMS container in C#","<p>I'm getting a PKCS#7/CMS container from a service I'm using that includes a user certificate and a signature.   </p>

<p>I am able to see the single certificate using <code>SignedCms</code>   </p>

<pre><code>var cert = GetCertFromServer();

SignedCms signedCms = new SignedCms();
signedCms.Decode(cert);

// The user certificate
X509Certificate2 userCert = signedCms.Certificates[0];  
</code></pre>

<p>But I need to add the intermediate and root certificate to that chain. <code>SignedCms.Certificates</code> seems to be immutable, so I can't add the certificates directly to the collection and I am not able to replace the certificates collection the following way  </p>

<pre><code>// root, inter and leaf certs are X509Certificate2 objects read from files
X509Certificate2[] certArr = new[] {rootCert, interCert, leafCert, userCert};

X509Certificate2Collection chain = new X509Certificate2Collection(certArr);

signedCms.Certificates = chain; // Error: No setter
</code></pre>

<p>Since <code>SignedCms.Certificates</code> has no setter. I haven't been able to find a way to create a new container from this one. I have also not had any luck finding info on how to do this in bouncy castle or any other library.   </p>

<p>I need to have a container containing the certificate chain and a signature and write the bytes from that container to a PDF file I'm signing. Is there a way to add certificates to the chain in the container? </p>
","<p>I know it's been several years since this question was asked, but I recently ran into the same question.</p>

<p>For anyone with the same issue, the <code>X509Certificate2Collection</code> class has an Export method.</p>

<pre><code>X509Certificate2[] certArr = certificates.ToArray();
X509Certificate2Collection chain = new X509Certificate2Collection(certArr);
byte[] result = chain.Export(X509ContentType.Pkcs7);
</code></pre>
","978","<c#><x509certificate><x509><pkcs#7>","2","1","2","2019-08-19 14:54:58","","2","","1729265","","2014-02-05 09:50:34","2014-02-05 09:12:52",""
"21572886","Adding a certificate chain to a PKCS#7/CMS container in C#","<p>I'm getting a PKCS#7/CMS container from a service I'm using that includes a user certificate and a signature.   </p>

<p>I am able to see the single certificate using <code>SignedCms</code>   </p>

<pre><code>var cert = GetCertFromServer();

SignedCms signedCms = new SignedCms();
signedCms.Decode(cert);

// The user certificate
X509Certificate2 userCert = signedCms.Certificates[0];  
</code></pre>

<p>But I need to add the intermediate and root certificate to that chain. <code>SignedCms.Certificates</code> seems to be immutable, so I can't add the certificates directly to the collection and I am not able to replace the certificates collection the following way  </p>

<pre><code>// root, inter and leaf certs are X509Certificate2 objects read from files
X509Certificate2[] certArr = new[] {rootCert, interCert, leafCert, userCert};

X509Certificate2Collection chain = new X509Certificate2Collection(certArr);

signedCms.Certificates = chain; // Error: No setter
</code></pre>

<p>Since <code>SignedCms.Certificates</code> has no setter. I haven't been able to find a way to create a new container from this one. I have also not had any luck finding info on how to do this in bouncy castle or any other library.   </p>

<p>I need to have a container containing the certificate chain and a signature and write the bytes from that container to a PDF file I'm signing. Is there a way to add certificates to the chain in the container? </p>
","<p>.NET Core 3.0 has added <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.pkcs.signedcms.addcertificate?view=dotnet-plat-ext-3.0"" rel=""nofollow noreferrer"">SignedCms.AddCertificate</a>.  You can't control the ordering (SignedCms.Encode() writes the data using the DER encoding rules, which dictates that this particular collection be sorted smallest first), but that's okay... X509Chain straightens it out.</p>

<pre><code>SignedCms signedCms = new SignedCms();
signedCms.Decode(data);

signedCms.AddCertificate(leafCert);
signedCms.AddCertificate(interCert);
signedCms.AddCertificate(rootCert);

byte[] reencoded = signedCms.Encode();
</code></pre>
","978","<c#><x509certificate><x509><pkcs#7>","2","0","2","2019-08-19 14:54:58","","2","","1729265","","2014-02-05 09:50:34","2014-02-05 09:12:52",""
"28129130","How to generate a pkcs7 signature envelope using pkcs11interop","<p>To prevent the token password dialog, I usually use pkcs11interop to login to the usbkey and do data signature use capi or some COM+ control in C#.</p>

<p>But now I have a new usbkey. When I do signature the first time it still display the login dialog. This key's pkcs11 dll does not implement function C_SignUpdate, so when I try to do signature use SunPkcs11 and BouncyCastle in Java it throw a exception:</p>

<pre class=""lang-java prettyprint-override""><code>    public static void main(String args[]) throws Exception {
        String configName = ""d:\\javakey_My.cfg"";
        String PIN = ""123456"";
        Provider prv = new SunPKCS11(configName);
        Security.addProvider(prv);
        KeyStore credentials = KeyStore.getInstance(""PKCS11"");
        char[] pin = PIN.toCharArray();
        credentials.load(null, pin);

        Key key = (PrivateKey) credentials.getKey(""My Cert ID"", null);
        Certificate[] chain = credentials
                .getCertificateChain(""My Cert ID"");
        X509Certificate cert = (X509Certificate) chain[0];
        Store certs = new JcaCertStore(Arrays.asList(chain));
        // set up the generator
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        gen.addSignerInfoGenerator(new JcaSimpleSignerInfoGeneratorBuilder()
                .setProvider(""SunPKCS11-MyKey"").build(""SHA1withRSA"",
                        (PrivateKey) key, cert));
        gen.addCertificates(certs);
        // create the signed-data object
        CMSTypedData data = new CMSProcessableByteArray(
                ""Hello World!"".getBytes());
        CMSSignedData signed = gen.generate(data, false);
    }
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>Exception in thread ""main"" java.security.ProviderException: sun.security.pkcs11.wrapper.PKCS11Exception: CKR_FUNCTION_NOT_SUPPORTED
	at sun.security.pkcs11.P11Signature.engineUpdate(P11Signature.java:436)
	at java.security.Signature$Delegate.engineUpdate(Unknown Source)
	at java.security.Signature.update(Unknown Source)
	at java.security.Signature.update(Unknown Source)
	at org.bouncycastle.operator.jcajce.JcaContentSignerBuilder$SignatureOutputStream.write(Unknown Source)
	at org.bouncycastle.cms.SignerInfoGenerator.generate(Unknown Source)
	at org.bouncycastle.cms.CMSSignedDataGenerator.generate(Unknown Source)
	at Tryit.main(Tryit.java:108)
Caused by: sun.security.pkcs11.wrapper.PKCS11Exception: CKR_FUNCTION_NOT_SUPPORTED
	at sun.security.pkcs11.wrapper.PKCS11.C_SignUpdate(Native Method)
	at sun.security.pkcs11.P11Signature.engineUpdate(P11Signature.java:430)
	... 7 more</code></pre>
</div>
</div>
</p>

<p>Is there any way to do a P7 signature use this key? by .Net or Java, without login dialog.</p>
","","962","<signature><pkcs#7><pkcs#11><envelope>","1","","0","2015-01-24 19:04:51","","1","0","4490380","","2015-01-24 19:04:51","2015-01-24 18:59:02",""
"26281963","Decode PKCS#7 Signature via Windows API?","<p>I wish to parse and display the contents of an Authenticode PKCS#7 signature as extracted from a Window PE binary's Security Directory.</p>

<p>I can use OpenSSL to do this on the command line with ""<code>openssl pkcs7 -text -in extracted_signature.pks -inform DER -print_certs</code>"", however I need to do this via C/C++ and the Windows API. I cannot use the OpenSSL library itself.</p>

<p>Using the <code>CryptDecodeObjectEx</code> API I can begin to decode the extracted signature:</p>

<pre><code>CRYPT_CONTENT_INFO * content_info;
DWORD len;

CryptDecodeObjectEx(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    PKCS_CONTENT_INFO,
    pointer_to_extracted_signature,
    length_of_extracted_signature,
    CRYPT_DECODE_ALLOC_FLAG,
    NULL,
    &amp;content_info,
    &amp;len
);
</code></pre>

<p>The above call completes successfully and <code>content_info-&gt;pszObjId</code> will have an OID of ""1.2.840.113549.1.7.2"" (szOID_RSA_signedData) however I am unable to find the structures needed to continue decoding. The available OID's for CryptDecodeObjectEx are listed <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa378145(v=vs.85).aspx"" rel=""nofollow"">here</a>.</p>

<p>Can anybody please advise how to decode an Authenticode PKCS#7 signature via the Windows API?</p>
","<p>I have found the correct way to decode an Authenticode PKCS#7 signature is to use <code>CryptQueryObject</code> with the <code>CERT_QUERY_OBJECT_BLOB</code> and <code>CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED</code> flags set. Code snippit below for anybody who might need to do this.</p>

<pre><code>CERT_BLOB cert_blob;
HCERTSTORE cert_store = NULL;
HCRYPTMSG cert_msg    = NULL;

cert_blob.pbData = pointer_to_extracted_signature;
cert_blob.cbData = length_of_extracted_signature;

CryptQueryObject(
    CERT_QUERY_OBJECT_BLOB,
    &amp;cert_blob,
    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
    CERT_QUERY_FORMAT_FLAG_BINARY,
    0,
    NULL,
    NULL,
    NULL,
    &amp;cert_store,
    &amp;cert_msg,
    NULL
);

PCCERT_CONTEXT next_cert = NULL;

while( (next_cert = CertEnumCertificatesInStore( cert_store, next_cert ) ) != NULL )
{
    // process next_cert...
}
</code></pre>
","936","<windows><pkcs#7><authenticode>","1","1","1","2014-10-10 14:09:53","26301408","0","","","","","2014-10-09 15:11:45",""
"39143180","Generate valid CMS Signature file adding external PKCS#1 with Java","<p>I'm generating CMS signature files with external PKCS#1 based on this <a href=""https://stackoverflow.com/questions/22470156/adding-external-pkcs1-byte-array-and-certificate-to-cms-container-with-java"">thread</a>. <br><br>
The first step is obtain the signed attributes from the original file to be signed in external application which is returning PKCS#1 byte array.</p>

<p>Then build standard org.bouncycastle.cms.SignerInfoGenerator with original file hash, signed data (PKCS#1) and certificate to add to CMS, and finally create the <strong>attached signature</strong>.</p>

<p>But when i'd tried to validate it using this code:</p>

<pre><code>        String originalFile = ""aG9sYQ0KYXNkYXMNCg0KYWZzDQo="";
        String cmsSignedFile = ""MIAGCSqGSIb3DQEHAqCAMIACAQExDzANBg...j2Dwytp6kzQNwtXGO8QbWty1lOo8oYm+6LR8EWba3ikO/m9ol/G808vit9gAAAAAAAA=="";
        byte[] signedByte = DatatypeConverter.parseBase64Binary(cmsSignedFile);

        Security.addProvider(new BouncyCastleProvider());

        CMSSignedData s = new CMSSignedData(new CMSProcessableByteArray(DatatypeConverter.parseBase64Binary(originalFile)), signedByte);
        SignerInformationStore signers = s.getSignerInfos();
        SignerInformation signerInfo = (SignerInformation)signers.getSigners().iterator().next();

        FileInputStream fis = new FileInputStream(""C:/myCertificate.cer"");
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        X509Certificate cert = (X509Certificate)cf.generateCertificates(fis).iterator().next();

        boolean result = signerInfo.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert.getPublicKey())); 
        System.out.println(""Verified: ""+result);
</code></pre>

<p><br>I get Verified: false</p>

<p>I'm adding Content Type, Signing time, Message digest and OCSP as signed attributes and TSP Token as unsigned attribute (I'm not sure if this is right).</p>

<p>I'm also trying to recover data from CMS signature, using the code below:</p>

<pre><code>        //load cms signed file with attached data
        CMSSignedData cms = new CMSSignedData(FileUtils.readFileToByteArray(new File(""C:/tmp/tempFile1864328163858309463.cms"")));

        System.out.println(cms.getSignerInfos().getSigners().iterator().next().getDigestAlgorithmID().getAlgorithm().getId());
        System.out.println(Hex.encodeHexString(cms.getSignerInfos().getSigners().iterator().next().getSignature()));

        //recover signer certificate info
        Store certs = cms.getCertificates();
        Collection&lt;X509CertificateHolder&gt; col = certs.getMatches(null);
        X509CertificateHolder []h1 = col.toArray(new X509CertificateHolder[col.size()]);
        X509CertificateHolder firmante = h1[0];
        System.out.println(firmante.getSubject());
        System.out.println(h1[1].getSubject());
        SignerInformation sinfo = cms.getSignerInfos().getSigners().iterator().next();

        //recover OCSP information
        //THIS FAILS :(
//          Store infocspbasic = cms.getOtherRevocationInfo(OCSPObjectIdentifiers.id_pkix_ocsp_basic);
//          Object basic = infocspbasic.getMatches(null).iterator().next();


        //recover signing time
        if (sinfo.getSignedAttributes() != null) {

            Attribute timeStampAttr = sinfo.getSignedAttributes().get(PKCSObjectIdentifiers.pkcs_9_at_signingTime);
            ASN1Encodable attrValue = timeStampAttr.getAttrValues().getObjectAt(0);

            final Date signingDate;
            if (attrValue instanceof ASN1UTCTime) {
                ASN1UTCTime time =  ASN1UTCTime.getInstance(attrValue);
                Date d = time.getDate();
                System.out.println(""ASN1UTCTime:"" + d);
            } else if (attrValue instanceof Time) {
                signingDate = ((Time) attrValue).getDate();
            } else if (attrValue instanceof ASN1GeneralizedTime) {
                System.out.println(""ASN1GeneralizedTimeASN1GeneralizedTime"");
            } else {
                signingDate = null;
            }
        }


        //recover timestamp TOken
        //unsigned attributes are null :(
        if (sinfo.getUnsignedAttributes() != null) {

            Attribute timeStampAttr = sinfo.getUnsignedAttributes().get(PKCSObjectIdentifiers.id_aa_signatureTimeStampToken);

            for (ASN1Encodable value : timeStampAttr.getAttrValues().toArray()) {
                TimeStampToken token = new TimeStampToken(new CMSSignedData(value.toASN1Primitive().getEncoded()));
                System.out.println(token.getTimeStampInfo().getGenTime());
            }

        }
</code></pre>

<p>But I can't retrieve OCSP response nor TSP Token information. Additionally I've downloaded this <a href=""https://www.signfiles.com/p7s-viewer/"" rel=""nofollow noreferrer"">viewer software</a> to help verify it:</p>

<p><img src=""https://i.stack.imgur.com/oreqP.png"" alt=""P7S Viewer""></p>

<p>Any help would be very appreciated.</p>
","<p>I found a project named <a href=""https://sourceforge.net/p/j4sign/discussion/432583/thread/22748439/"" rel=""nofollow"">j4sign</a> which implements CMS signature with external PKCS#1. The link goes to the project's forum where I posted the code sample using their classes and the final correction to make the validation works.</p>
","889","<java><digital-signature><bouncycastle><pkcs#7><pkcs#1>","2","0","1","2016-09-14 07:49:00","39485132","0","","-1","","2017-05-23 11:51:44","2016-08-25 10:44:51",""
"52757037","How to generate PKCS#7 signature from digest?","<p>I want to sign the pdf using pdf digest. I have created the hash using below code,</p>

<pre><code>byte[] buffer = new byte[1024];
int numOfBytesRead =0;
MessageDigest md = null;
md = MessageDigest.getInstance(""SHA256"",""BC"");
while((numOfBytesRead = content.read(buffer)) != -1 ){
     md.update(buffer, 0, numOfBytesRead);
}
byte[] digest = md.digest();
</code></pre>

<p>At the end I need to attach this signature to my pdf. I have found one solution <a href=""https://stackoverflow.com/questions/41767351/create-pkcs7-signature-from-file-digest]"">Create pkcs7 signature from file digest</a>, but the algorithm used in the link is <strong>SHA256withRSA</strong>. My privatekey is genearted using <strong>EC</strong> algorithm and I need to use <strong>SHA256withECDSA</strong>.Is it possible to just sign the Hash using <strong>SHA256withECDSA</strong> and attach the signature to the pdf using <strong>PDFBox ExternalSigning</strong> Interface.</p>
","<p>I tried below code still the pdf says Signature is invalid. Can you please check the code,</p>

<pre><code>System.out.println(""Hash Signing started"");
    List&lt;Certificate&gt; certList = getFormatCertificate(strCertificate);
    PrivateKey privateKey;
    CMSSignedData s = null;
    Security.addProvider(new BouncyCastleProvider());
    byte[] signature = null;
    try {
        privateKey = loadPrivateKey(strPrivatekey);
        byte[] buffer = new byte[1024];
        int numOfBytesRead =0;
        MessageDigest md = null;
        md = MessageDigest.getInstance(""SHA256"",""BC"");
        while((numOfBytesRead = content.read(buffer)) != -1 ){
            md.update(buffer, 0, numOfBytesRead);
        }
        byte[] digest = md.digest();

        // Separate signature container creation step
        JcaCertStore certs = new JcaCertStore(certList);

        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

        Attribute attr = new Attribute(CMSAttributes.messageDigest,
                new DERSet(new DEROctetString(digest)));

        ASN1EncodableVector v = new ASN1EncodableVector();

        v.add(attr);

        SignerInfoGeneratorBuilder builder = new SignerInfoGeneratorBuilder(new BcDigestCalculatorProvider())
                .setSignedAttributeGenerator(new DefaultSignedAttributeTableGenerator(new AttributeTable(v)));

        //AlgorithmIdentifier sha256withECDSA = new DefaultSignatureAlgorithmIdentifierFinder().find(signerAlgorithm);

        CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
        InputStream in = new ByteArrayInputStream(certList.get(certList.size()-1).getEncoded());
        X509Certificate cert = (X509Certificate) certFactory.generateCertificate(in);

        gen.addSignerInfoGenerator(builder.build(
                new JcaContentSignerBuilder(signerAlgorithm).build(privateKey),
                new JcaX509CertificateHolder(cert)));
        //DErse
//      gen.addSignerInfoGenerator(builder.build(
//              new JcaContentSignerBuilder(sha256withRSA,
//                      new DefaultDigestAlgorithmIdentifierFinder().find(sha256withRSA))
//                              .build(PrivateKeyFactory.createKey(privateKey.getEncoded())),
//              new JcaX509CertificateHolder(cert)));

        gen.addCertificates(certs);

        s = gen.generate(new CMSAbsentContent(), false);
        System.out.println(""Hash sign completed"");
        signature = s.getEncoded();// ConstructEcdsaSigValue(s.getEncoded());
    } catch (GeneralSecurityException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""GeneralSecurityException ::""+e.toString());
    } catch (OperatorCreationException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""OperatorCreationException ::""+e.toString());
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""IOException ::""+e.toString());
    } catch (CMSException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""CMSException ::""+e.toString());
    }finally{
        return signature;
    }
</code></pre>

<p>I have attached the pdf . <a href=""https://drive.google.com/open?id=14_n5-HV37SsrOYlnAYrQ9Sd6lvDMFPSD"" rel=""nofollow noreferrer"">Pdf file created</a></p>

<p>@Mkl/Tilman : I have created 2 pdf files, PDFA is signed using the digest of the pdf content with below code,</p>

<pre><code>System.out.println(""Hash Signing started"");
    List&lt;Certificate&gt; certList = getFormatCertificate(strCertificate);
    PrivateKey privateKey;
    CMSSignedData s = null;
    Security.addProvider(new BouncyCastleProvider());
    byte[] signature = null;
    try {
        privateKey = loadPrivateKey(strPrivatekey);

        /*byte[] buffer = new byte[1024];
        int numOfBytesRead =0;
        MessageDigest md = null;
        //md = MessageDigest.getInstance(""SHA256"",""BC"");
        md = MessageDigest.getInstance(""SHA-256"");
        while((numOfBytesRead = content.read(buffer)) != -1 ){
            md.update(buffer, 0, numOfBytesRead);
        }
        byte[] digest = md.digest();*/
        MessageDigest md = MessageDigest.getInstance(""SHA256"", ""BC"");
        byte[] digest = md.digest(IOUtils.toByteArray(content));

        // Separate signature container creation step
        JcaCertStore certs = new JcaCertStore(certList);

        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

        Attribute attr = new Attribute(CMSAttributes.messageDigest,
                new DERSet(new DEROctetString(digest)));

        ASN1EncodableVector v = new ASN1EncodableVector();

        v.add(attr);

        SignerInfoGeneratorBuilder builder = new SignerInfoGeneratorBuilder(new BcDigestCalculatorProvider())
                .setSignedAttributeGenerator(new DefaultSignedAttributeTableGenerator(new AttributeTable(v)));

        //AlgorithmIdentifier sha256withECDSA = new DefaultSignatureAlgorithmIdentifierFinder().find(signerAlgorithm);

        CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
        InputStream in = new ByteArrayInputStream(certList.get(certList.size()-1).getEncoded());
        X509Certificate cert = (X509Certificate) certFactory.generateCertificate(in);

        gen.addSignerInfoGenerator(builder.build(
                new JcaContentSignerBuilder(signerAlgorithm).build(privateKey),
                new JcaX509CertificateHolder(cert)));
        //DErse
//      gen.addSignerInfoGenerator(builder.build(
//              new JcaContentSignerBuilder(sha256withRSA,
//                      new DefaultDigestAlgorithmIdentifierFinder().find(sha256withRSA))
//                              .build(PrivateKeyFactory.createKey(privateKey.getEncoded())),
//              new JcaX509CertificateHolder(cert)));

        gen.addCertificates(certs);

        s = gen.generate(new CMSAbsentContent(), false);
        System.out.println(""Hash sign completed"");
        signature = s.getEncoded();// ConstructEcdsaSigValue(s.getEncoded());
    } catch (GeneralSecurityException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""GeneralSecurityException ::""+e.toString());
    } catch (OperatorCreationException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""OperatorCreationException ::""+e.toString());
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""IOException ::""+e.toString());
    } catch (CMSException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        System.out.println(""CMSException ::""+e.toString());
    }finally{
        return signature;
    }
</code></pre>

<p><a href=""https://drive.google.com/open?id=132-P95iUEirzk0PMY5Ccnh8lmchzFU89"" rel=""nofollow noreferrer"">PDFA</a>   </p>

<p>PDFB is created with the same private key and certificate, but instead of digest I am using pdf document content directly which gives me valid signed pdf, PDFB code below,</p>

<pre><code>SignatureInterface signatureInterface = new SignatureInterface() {
                    @SuppressWarnings(""rawtypes"")
                    @Override
                    public byte[] sign(InputStream content) throws IOException {
                        try {
                            byte[] certificateByte = null;

                            Store certs = new JcaCertStore(certificates);

                            //PAdES - PDF Advanced Electronic Signature
                            //ESS - Enhanced Security Services
                            //ASN1 - Abstract Syntax Notation One-standard interface description language for defining data structures that can be serialized and deserialized in a cross-platform way
                            // Generating certificate hash
                            MessageDigest md = MessageDigest.getInstance(""SHA-256"");
                            md.update(certificates.get(certificates.size()-1).getEncoded());
                            byte[] certHash = md.digest();
                            // Generating certificate hash ends
                            System.out.println(""Cert hash generated"");
                            //ESSCertIDv2 identifies the certificate from the hash
                            ESSCertIDv2 essCert1 =
                                    new ESSCertIDv2(new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256), certHash);
                            ESSCertIDv2[] essCert1Arr =
                                    {
                                            essCert1
                                    };
                            SigningCertificateV2 scv2 = new SigningCertificateV2(essCert1Arr);
                            Attribute certHAttribute =
                                    new Attribute(PKCSObjectIdentifiers.id_aa_signingCertificateV2, new DERSet(scv2));
                            ASN1EncodableVector v = new ASN1EncodableVector();
                            v.add(certHAttribute);

                            AttributeTable at = new AttributeTable(v);

                            //Create a standard attribute table from the passed in parameters - certhash
                            CMSAttributeTableGenerator attrGen = new DefaultSignedAttributeTableGenerator(at){
                                protected Hashtable createStandardAttributeTable(Map parameters)
                                {
                                    Hashtable result = super.createStandardAttributeTable(parameters);
                                    result.remove(CMSAttributes.signingTime);
                                    return result;
                                }
                            };
                            //PAdES-end
                            System.out.println(""CMSAttributeTableGenerator generated"");
                            SignerInfoGeneratorBuilder genBuild =
                                    new SignerInfoGeneratorBuilder(new BcDigestCalculatorProvider());
                            genBuild.setSignedAttributeGenerator(attrGen);
                            //Get single certificate
                            org.spongycastle.asn1.x509.Certificate certas1 = org.spongycastle.asn1.x509.Certificate.getInstance(ASN1Primitive.fromByteArray(certificates.get(certificates.size()-1).getEncoded()));
                            // ContentSigner interface creates SHA256withECDSA signer using PvtKey
                            ContentSigner sha1Signer = new JcaContentSignerBuilder(signerAlgorithm).build(privateKey);
                            //Creates SignerInfoGenerator using X.509 cert and ContentSigner
                            SignerInfoGenerator sifGen = genBuild.build(sha1Signer, new X509CertificateHolder(certas1));

                            // CMSSignedDataGenerator generates a pkcs7-signature message 
                            CMSSignedDataGenerator gen = new CMSSignedDataGenerator();

                            gen.addCertificates(certs);
                            gen.addSignerInfoGenerator(sifGen);
                            //Creates CMS message from PDF
                            CMSProcessableInputStream msg = new CMSProcessableInputStream(content);
                            //Generate a CMS Signed Data object which can be carrying a detached CMS signature
                            //msg - content to be signed
                            CMSSignedData signedData = gen.generate(msg, false);
                            System.out.println(""CMSSignedData is done"");
                            return signedData.getEncoded();
                        } catch (GeneralSecurityException e) {
                            throw new IOException(e);
                        } catch (CMSException e) {
                            throw new IOException(e);
                        } catch (OperatorCreationException e) {
                            throw new IOException(e);
                        }
                }

            };
            System.out.println(""CMSSignedData is done2"");
            PDDocument pdDocument =  PDDocument.load(inputfile);

            System.out.println(""pdDocument loaded"");
            pdDocument.addSignature(signature, signatureInterface);
</code></pre>

<p><a href=""https://drive.google.com/open?id=1_2DXCgQDbuNSCYl7POVHlXwIf86Gzp2T"" rel=""nofollow noreferrer"">PDFB</a></p>

<p>I think something is missing in the signing part of PDFA which I couldn't figure out.</p>
","865","<android><digital-signature><bouncycastle><pdfbox><pkcs#7>","1","0","2","2018-10-15 15:19:21","","2","","1559247","","2018-10-11 10:11:45","2018-10-11 09:46:14",""
"52757037","How to generate PKCS#7 signature from digest?","<p>I want to sign the pdf using pdf digest. I have created the hash using below code,</p>

<pre><code>byte[] buffer = new byte[1024];
int numOfBytesRead =0;
MessageDigest md = null;
md = MessageDigest.getInstance(""SHA256"",""BC"");
while((numOfBytesRead = content.read(buffer)) != -1 ){
     md.update(buffer, 0, numOfBytesRead);
}
byte[] digest = md.digest();
</code></pre>

<p>At the end I need to attach this signature to my pdf. I have found one solution <a href=""https://stackoverflow.com/questions/41767351/create-pkcs7-signature-from-file-digest]"">Create pkcs7 signature from file digest</a>, but the algorithm used in the link is <strong>SHA256withRSA</strong>. My privatekey is genearted using <strong>EC</strong> algorithm and I need to use <strong>SHA256withECDSA</strong>.Is it possible to just sign the Hash using <strong>SHA256withECDSA</strong> and attach the signature to the pdf using <strong>PDFBox ExternalSigning</strong> Interface.</p>
","<p>There are several situations in which Adobe calls a signer's certificate invalid even though apparently it is valid; in the case at hand in particular:</p>

<ul>
<li>Key usage or Extended key usage values not appropriate</li>
<li>PAdES signature misses an ESS signing-certificate-v2 attribute</li>
</ul>

<h3>Key usage or Extended key usage values not appropriate</h3>

<p><em>This is based on the information the OP first published as <a href=""https://stackoverflow.com/a/52763251/1729265"">an answer</a></em></p>

<blockquote>
  <p><em>I tried below code still the pdf says Signature is invalid. Can you please check the code,</em></p>
  
  <p><em>[...]</em></p>
  
  <p><em>I have attached the pdf . <a href=""https://drive.google.com/open?id=14_n5-HV37SsrOYlnAYrQ9Sd6lvDMFPSD"" rel=""nofollow noreferrer"">Pdf file created</a></em></p>
</blockquote>

<p>Indeed, Adobe Reader says the signature is invalid, but look more closely:</p>

<p><a href=""https://i.stack.imgur.com/33XQL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/33XQL.png"" alt=""Signature panel""></a></p>

<p>It says ""Document has not been modified since this signature was applied"" - This means that <strong>the signature is mathematically correct!</strong></p>

<p>The issue is that the ""Signer's certificate is invalid"", and the reason for this can be seen when digging into the signature property dialogues:</p>

<p><a href=""https://i.stack.imgur.com/g3WYb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/g3WYb.png"" alt=""Certificate Details""></a></p>

<p>Thus, the problem is that your signer certificate is <strong>Not valid for usage</strong>.</p>

<p>This is due to the highlighted attribute, while the Key Usage <em>Digital Signature</em> is ok, the ""Extended key usage"" <em>1.3.6.1.5.5.8.2.2</em> (OID for <em>IPSEC Protection</em>) is not!</p>

<p>According to the Adobe <a href=""https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSig/changes.html#id1"" rel=""nofollow noreferrer"">Digital Signatures Guide for IT</a>, Adobe Acrobat accepts only</p>

<ul>
<li><p>one or more of the following Key usage values (if any)</p>

<ul>
<li>nonRepudiation</li>
<li>signTransaction (11.0.09 only)</li>
<li>digitalSignature (11.0.10 and later)</li>
</ul></li>
<li><p>and one or more of the following Extended key usage values (if any)</p>

<ul>
<li>emailProtection</li>
<li>codeSigning</li>
<li>anyExtendedKeyUsage</li>
<li>1.2.840.113583.1.1.5 (Adobe Authentic Documents Trust)</li>
</ul></li>
</ul>

<p>Due to its <em>IPSEC Protection</em> extended key usage value, therefore, your certificate is not considered valid for signing PDF documents.</p>

<p><em>This probably only is an issue in legacy ISO 32000-1 signatures, probably not in PAdES signatures.</em></p>

<h3>PAdES signature misses an ESS signing-certificate-v2 attribute</h3>

<p><em>This is based on the information the OP first published as <a href=""https://stackoverflow.com/a/52763251/1729265"">an answer</a></em></p>

<blockquote>
  <p><em>I have created 2 pdf files, PDFA is signed using the digest of the pdf content with below code,</em></p>
  
  <p><em>[...]</em></p>
  
  <p><em><a href=""https://drive.google.com/open?id=132-P95iUEirzk0PMY5Ccnh8lmchzFU89"" rel=""nofollow noreferrer"">PDFA</a></em></p>
  
  <p><em>PDFB is created with the same private key and certificate, but instead of digest I am using pdf document content directly which gives me valid signed pdf, PDFB code below,</em></p>
  
  <p><em>[...]</em></p>
  
  <p><em><a href=""https://drive.google.com/open?id=1_2DXCgQDbuNSCYl7POVHlXwIf86Gzp2T"" rel=""nofollow noreferrer"">PDFB</a></em></p>
  
  <p><em>I think something is missing in the signing part of PDFA which I couldn't figure out.</em></p>
</blockquote>

<p>Here the main difference is not whether you explicitly calculate the hash yourself or allow it to be calculated implicitly, the main difference is that the signature in PDFB includes an ESS signing-certificate-v2 attribute while the one in PDFA does not. This attribute is generated between</p>

<pre><code>//PAdES - PDF Advanced Electronic Signature
</code></pre>

<p>and</p>

<pre><code>//PAdES-end
</code></pre>

<p>As the comments already hint, this is only necessary for PAdES signatures, not for legacy ISO 32000-1 ones. <a href=""https://stackoverflow.com/a/41848320/1729265"">The answer the OP took his original code from</a> referred to creating a legacy ISO 32000-1 signature (and, therefore, works alright) while the OP creates a PAdES signature.</p>

<p>The presence of an ESS signing certificate attribute is required by the PAdES specification ETSI EN 319 142-1: </p>

<blockquote>
  <p>e) Generators shall use either the signing certificate or the signing-certificate v2 attribute, depending on the hash function, in accordance with ETSI EN 319 122-1.</p>
</blockquote>

<p><em>(ETSI EN 319 142-1, section 6.3 PAdES baseline signatures)</em></p>

<p>It references the CAdES specification ETSI EN 319 122-1 which in turn requires</p>

<blockquote>
  <p>h) Requirement for SPO: ESS <code>signing-certificate</code>. The ESS <code>signing-certificate</code> attribute shall be used if the SHA-1 hash algorithm is used.</p>
  
  <p>i) Requirement for SPO: ESS <code>signing-certificate-v2</code>. The ESS <code>signing-certificate-v2</code> attribute shall be used when another hash algorithms than SHA-1 is used.</p>
</blockquote>

<p><em>(ETSI EN 319 122-1, section 6.3 Requirements on components and services)</em></p>
","865","<android><digital-signature><bouncycastle><pdfbox><pkcs#7>","1","1","2","2018-10-15 15:19:21","","2","","1559247","","2018-10-11 10:11:45","2018-10-11 09:46:14",""
"31763647","why doesn't message signed with openssl_pkcs7_sign validate with openssl_pkcs7_verify?","<p>The signing code is based off of the example at <a href=""http://php.net/openssl-pkcs7-sign"" rel=""nofollow"">http://php.net/openssl-pkcs7-sign</a>. The private key corresponds to the public key in the cert. The cert is valid from one year ago to Dec 31, 9999, so the date range isn't an issue.</p>

<p>Does the key usage extension need to be set? And if that is the issue then to what does it need to be set? And if that's not the case then what exactly do I need to be doing to get this to work?</p>

<p>Here's my code:</p>

<pre><code>&lt;?php
$data = &lt;&lt;&lt;EOD

You have my authorization to spend $10,000 on dinner expenses.

The CEO
EOD;
// save message to file
$fp = fopen(""msg.txt"", ""w"");
fwrite($fp, $data);
fclose($fp);

$key = '-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQCzJV1Z0UKXLkl9TrhuRR9ndtf+UpLyxduWffFiDXsruojd7B6A
XAdsnyTH+/fDpBDYBmpwnHRkh2R0OQ/0tpN6ShFcZDuBLMoNuqP3VhJZn01bjpeq
TO3Np8zYSHUrGcMv+h/f/HG1o8kKndWbAQrzj0DUOrn0Di336mULscF/gwIDAQAB
AoGACNnhwNxL8/g/fUd0aU5U/OGsTk56IDCSZt8WHAgae9CdjolqAGGLpFxAjvju
BuaGRoYaoDG6tnTSC8P9+9NBegYfzh4G2aYKtt67Qd0wgxZtIMwQjBrxPxWDEh6L
u3KkxcsA6vDuuGi7QGIpDDDvHNdqEnDWbef7jxqb5AwU9yECQQDbdDwMIJbD6F++
IpLCrbwfyhb0JOmXEyMdfin052HhaV6o/ta8KHZrUrufDh9DM/wN8Sn6Mw6ZFJ8y
A0DLhdPbAkEA0Pq3NMRyzHhMT4Jz4NfdTilbmElPsXpeG3ONd54St58y5WQ+E2f5
iC6/yG4d0YB93g6HtaB0DRjJSkAPhs4neQJBAL/zz4IcD0OUwgohW5WFOYPk1GcA
0oEecByf+jsJGIh+DhprrZAvJEWDvDDHvXiew92+ECWU+zPS4dxxE//xMvkCQQCr
7soSSNnmLcci10I9J3x1FQO9y/scGoAYd75ZPp1Jo1n9bra/wpiDGWtCHI690cg8
jJnMraEtMUpSo1fi4fOJAkBnX2woZpZvGWSTwswqGAlh1iz9+ekjY2V8TTVKcfX3
H2tHvg27KE2r/7S1N+MEcpJBF5S/zXo4hwLzrLzG3z6Y
-----END RSA PRIVATE KEY-----';

$cert = '-----BEGIN CERTIFICATE-----
MIIBwzCCASygAwIBAgIUP7VZQpJYe8YHW4Fdd+FaukIezEcwDQYJKoZIhvcNAQEF
BQAwHjEcMBoGA1UECgwTcGhwc2VjbGliIGRlbW8gY2VydDAeFw0xNTA4MDExNjA3
NDNaFw0xNjA4MDExNjA3NDNaMB4xHDAaBgNVBAoME3BocHNlY2xpYiBkZW1vIGNl
cnQwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALMlXVnRQpcuSX1OuG5FH2d2
1/5SkvLF25Z98WINeyu6iN3sHoBcB2yfJMf798OkENgGanCcdGSHZHQ5D/S2k3pK
EVxkO4Esyg26o/dWElmfTVuOl6pM7c2nzNhIdSsZwy/6H9/8cbWjyQqd1ZsBCvOP
QNQ6ufQOLffqZQuxwX+DAgMBAAEwDQYJKoZIhvcNAQEFBQADgYEArmQMGP2XPQTI
b0ppXGTlAqLGx979GDYeWglCLSlUYw3Ohr3Jonhs7KnhX04Y3ePVqIKuqSDvZz/D
C3Xgaiqmq0OsHtro7O0BamauKANON6bwq/YthrbeNBUoy7XZ86WsRZGSPlts7jdQ
tiqqWvr+oWxNb8WkxqVCshifjSOTlOQ=
-----END CERTIFICATE-----';


// encrypt it
openssl_pkcs7_sign(
    'msg.txt',
    'signed.txt',
    $cert,
    $key,
    array(
        'To' =&gt; 'joes@example.com',  // keyed syntax
        'From: HQ &lt;ceo@example.com&gt;',// indexed syntax
        'Subject"" =&gt; ""Eyes only'
    )
);

echo file_get_contents('signed.txt');

var_dump(openssl_pkcs7_verify('signed.txt', 0));
</code></pre>
","<p>This is expected behavior. You have a self-signed certificate. In your case you should use <br /></p>

<pre><code>openssl_pkcs7_verify('signed.txt', PKCS7_NOVERIFY)
</code></pre>

<p>Then a self-signed certificate is acceptable.</p>
","848","<php><openssl><pkcs#7><php-openssl>","3","2","1","2015-08-04 13:20:42","31810488","0","","","","","2015-08-01 16:18:01",""
"25343130","digitally sign pdf using itext with pkcs 7 files","<p>I was using pkcs 12 (.pfx)for signing pdf document but how to achieve using pkcs 7 in C#.is there any sample or documentation for signing pdf using pkcs 7? I have p7b and cer file.</p>
","<p>You can't sign the data using a file in PKCS#7 format. This is because PKCS#7 contains only certificates without private keys, and to sign something you need to have a private key. </p>
","834","<pdf><itext><pkcs#7>","0","1","1","2014-08-20 10:07:55","25389873","0","0","47961","","2014-08-20 10:07:55","2014-08-16 19:19:59",""
"51812671","Instantiate java.security classes PrivateKey and X509Certificate from .key and .cer files","<p><strong>The original goal is:</strong></p>

<p>Generate a https url where one of parameters is PKCS7 detached signature (RSA, SHA-256, UTF-8, BASE64).</p>

<p><strong>What do I have:</strong></p>

<ol>
<li>private key (.key file begin with ""-----BEGIN RSA PRIVATE KEY-----"",
end like this ""kIng0BFt5cjuur81oQqGJgvU+dC4vQio+hVc+eAQTGmNQJV56vAHcq4v
-----END RSA PRIVATE KEY-----"")</li>
<li>self signed certificate (.cer file begin with ""-----BEGIN CERTIFICATE-----"",
end like this ""xwRtGsSkfOFL4ehKn/K7mgQEc1ZVPrxTC7C/g+7grbKufvqNmsYW4w==
-----END CERTIFICATE-----"")</li>
<li>data to sign</li>
</ol>

<p>I found a java code that do almost what I need.</p>

<p>Method signature:</p>

<pre><code> public static String sign(PrivateKey privateKey,
                           X509Certificate certificate,
                           String data);
</code></pre>

<p>Now I'm stuck on how to get PrivateKey and X509Certficiate classes from given files.</p>

<p>I looked at many examples and got confused by these moments:</p>

<p>1.</p>

<pre><code>KeyStore ks = KeyStore.getInstance(""pkcs12"");
</code></pre>

<p>or</p>

<pre><code>PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
</code></pre>

<p>Didn't find alternatives for PKCS7 standard.</p>

<ol start=""2"">
<li><p>A snippet of method that builds PrivateKey using bouncycastle library:</p>

<pre><code>    inputStream = Files.newInputStream(privateKeyFile.toPath());
    reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
    pemParser = new PEMParser(reader);
    PEMDecryptorProvider decryptorProvider = new JcePEMDecryptorProviderBuilder()
            .setProvider(PROVIDER)
            .build(privateKeyPassword.toCharArray());
    PEMEncryptedKeyPair encryptedKeyPair = (PEMEncryptedKeyPair) pemParser.readObject();
    PEMKeyPair keyPair = encryptedKeyPair.decryptKeyPair(decryptorProvider);
    ...
</code></pre></li>
</ol>

<p>In this example I have to provide some privateKeyPassword to PEMDecryptorProvider. What is the point of this password and where can I get it?</p>

<p>From keyPair value I can get both privateKey and publicKey.</p>

<p>What is the connection between publicKey from PEMKeyPair and my certificate ? Are they the same?</p>

<p>Any help will be appreciated, thanks!</p>
","<p>You don't need bouncycastle to read in the public key as Java's CertificateFactory directly supports the format of your .cer file.</p>

<p>The private key appears to be in a PKCS1 format that openssl can produce. If you wish to keep that format <a href=""https://stackoverflow.com/a/41953072/238704"">this answer</a> shows how to extract the private key. Combining the two, here is a short snippet to read in a certificate and a private key.</p>

<pre><code>import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMKeyPair;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;

import java.io.FileInputStream;
import java.io.FileReader;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.Security;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

public class Main {

    private static PrivateKey readPrivateKey(String filename) throws Exception {
        PEMParser pemParser = new PEMParser(new FileReader(filename));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(""BC"");
        PEMKeyPair pemKeyPair = (PEMKeyPair) pemParser.readObject();
        KeyPair kp = converter.getKeyPair(pemKeyPair);
        return kp.getPrivate();
    }

    private static X509Certificate readCertificate(String filename) throws Exception {
        CertificateFactory certificateFactory = CertificateFactory.getInstance(""X.509"");
        return (X509Certificate) certificateFactory.generateCertificate(new FileInputStream(filename));
    }

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());
        PrivateKey privateKey = readPrivateKey(""myKey.priv"");
        X509Certificate cert = readCertificate(""mycert.cer"");
    }
}
</code></pre>
","832","<java><encryption><bouncycastle><pkcs#7>","0","2","1","2018-08-23 18:26:35","","7","","13302","","2018-08-23 18:26:35","2018-08-12 20:40:19",""
"18915964","OpenSSL C program becomes non-responsive at PKCS7_sign function","<p>I'm trying to run the following code to sign a self made certificate but the program becomes non-responsive at the following piece of code. It doesn't crash or anything but the cursor just sits there blinking.</p>

<pre><code>if (sign) {
            if (!(pkcs7 = PKCS7_sign (cert, pkey, chain, in, 0))) { &lt;----Here seems to be the problem
                fprintf (stderr, ""Error making the PKCS#7 object\n"");
                goto err;
            }
}
</code></pre>

<p>From debugging, all the variables seem to have values except chain, gdb prints out:</p>

<pre><code>(gdb) p *chain
Cannot access memory at address 0x0
</code></pre>

<p>Here is the entire code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/crypto.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/pem.h&gt;
#include &lt;openssl/rand.h&gt;

/*
* This code appearing before the main function is all for X509_STORE setup.
*/

/* these are defintions to make the example simpler */
#define CA_FILE ""CAfile.pem""
#define CA_DIR ""/etc/ssl""
#define CRL_FILE ""CRLfile.pem""

int
verify_callback (int ok, X509_STORE_CTX * stor)
{
    if (!ok)
        fprintf (stderr, ""Error: %s\n"",
                 X509_verify_cert_error_string (stor-&gt;error));
    return ok;
}

X509_STORE *
create_store (void)
{
    X509_STORE *store;
    X509_LOOKUP *lookup;

    /* create the cert store and set the verify callback */
    if (!(store = X509_STORE_new ())) {
        fprintf (stderr, ""Error creating X509_STORE_CTX object\n"");
        goto err;
    }
    X509_STORE_set_verify_cb_func (store, verify_callback);

    /* load the CA certificates and CRLs */
    if (X509_STORE_load_locations (store, CA_FILE, CA_DIR) != 1) {
        fprintf (stderr, ""Error loading the CA file or directory\n"");
        goto err;
    }

    if (X509_STORE_set_default_paths (store) != 1) {
        fprintf (stderr, ""Error loading the system-wide CA certificates\n"");
        goto err;
    }

    if (!(lookup = X509_STORE_add_lookup (store, X509_LOOKUP_file ()))) {
        fprintf (stderr, ""Error creating X509_LOOKUP object\n"");
        goto err;
    }

    if (X509_load_crl_file (lookup, CRL_FILE, X509_FILETYPE_PEM) != 1) {
        fprintf (stderr, ""Error reading the CRL file\n"");
        goto err;
    }

    /* set the flags of the store so that CRLs are consulted */
    X509_STORE_set_flags (store, X509_V_FLAG_CRL_CHECK |
                          X509_V_FLAG_CRL_CHECK_ALL);
    return store;

err:
    return NULL;
}

int
main (int argc, char *argv[])
{
    int sign;
    X509 *cert;
    EVP_PKEY *pkey;
    STACK_OF (X509) * chain = NULL;
    X509_STORE *store;
    PKCS7 *pkcs7;
    FILE *fp;
    BIO *in, *out, *pkcs7_bio;

    OpenSSL_add_all_algorithms ();
    ERR_load_crypto_strings ();
    /*seed_prng ();*/ /*seed_prng(1024);Borked DOONT LEAVE OUT*/


    --argc, ++argv;
    if (argc &lt; 2) {
        fprintf (stderr,
                 ""Usage: sv (sign|verify) [privkey.pem] cert.pem ...\n"");
        goto err;
    }
    if (!strcmp (*argv, ""sign""))
        sign = 1;
    else if (!strcmp (*argv, ""verify""))
        sign = 0;
    else {
        fprintf (stderr,
                 ""Usage: sv (sign|verify) [privkey.pem] cert.pem ...\n"");
        goto err;
    }
    --argc, ++argv;

    /* setup the BIO objects for stdin and stdout */
    if (!(in = BIO_new_fp (stdin, BIO_NOCLOSE)) ||
            !(out = BIO_new_fp (stdout, BIO_NOCLOSE))) {
        fprintf (stderr, ""Error creating BIO objects\n"");
        goto err;
    }
    if (sign) {

        /* read the signer private key */
        if (!(fp = fopen (*argv, ""r"")) ||
                !(pkey = PEM_read_PrivateKey (fp, NULL, NULL, NULL))) {
            fprintf (stderr, ""Error reading signer private key in %s\n"", *argv);
            goto err;
        }
        fclose (fp);
        --argc, ++argv;
    } else {
        /* create the cert store and set the verify callback */
        if (!(store = create_store ()))
            fprintf (stderr, ""Error setting up X509_STORE object\n"");
    }

    /* read the signer certificate */
    if (!(fp = fopen (*argv, ""r"")) ||
            !(cert = PEM_read_X509 (fp, NULL, NULL, NULL))) {
        ERR_print_errors_fp (stderr);
        fprintf (stderr, ""Error reading signer certificate in %s\n"", *argv);
        goto err;
    }
    fclose (fp);
    --argc, ++argv;

    if (argc)
        chain = sk_X509_new_null ();
    while (argc) {
        X509 *tmp;

        if (!(fp = fopen (*argv, ""r"")) ||!(tmp = PEM_read_X509 (fp, NULL, NULL, NULL))) {
            fprintf (stderr, ""Error reading chain certificate in %s\n"", *argv);
            goto err;
        }
        sk_X509_push (chain, tmp);
        fclose (fp);
        --argc, ++argv;
    }

    if (sign) {
        if (!(pkcs7 = PKCS7_sign (cert, pkey, chain, in, 0))) {
            fprintf (stderr, ""Error making the PKCS#7 object\n"");
            goto err;
        }
        if (SMIME_write_PKCS7 (out, pkcs7, in, 0) != 1) {
            fprintf (stderr, ""Error writing the S/MIME data\n"");
            goto err;
        }
    } else {            /* verify */
        if (!(pkcs7 = SMIME_read_PKCS7 (in, &amp;pkcs7_bio))) {
            fprintf (stderr, ""Error reading PKCS#7 object\n"");
            goto err;
        }
        if (PKCS7_verify (pkcs7, chain, store, pkcs7_bio, out, 0) != 1) {
            fprintf (stderr, ""Error writing PKCS#7 object\n"");
            goto err;
        } else
            fprintf (stdout, ""Certifiate and Signature verified!\n"");
    }

    return 0;
err:
    return -1;
}
</code></pre>

<p>If anybody has any ideas I would appreciate a comment!</p>
","<p>Just got it! Read <a href=""http://www.openssl.org/docs/crypto/PKCS7_sign.html"" rel=""nofollow"">here</a></p>

<blockquote>
  <p>""In OpenSSL 1.0.0 the certs, signcert and pkey parameters can all be
  NULL if the PKCS7_PARTIAL flag is set.""</p>
</blockquote>

<p>Changed the code to:</p>

<pre><code>if (sign) {
    if (!(pkcs7 = PKCS7_sign (cert, pkey, chain, in, PKCS7_PARTIAL))) {
        fprintf (stderr, ""Error making the PKCS#7 object\n"");
        goto err;
    }
}
</code></pre>

<p>And it's all good!</p>
","821","<c><openssl><ssl-certificate><pkcs#7>","1","0","1","2013-09-20 11:59:49","18916263","0","","","","","2013-09-20 11:44:01",""
"35551815","Encrypt Data by using Digital signature in PKCS7 format with base 64 encoding","<p>We are writing to validate user data by using API. For validating purpose, i need to pass two variable in post method call and Two variables are data and signature. So Digital signature of data in PKCS7 format with base 64 encoding.</p>

<p>For encryption they gave pem file to encrypt the data to generate signature in PKCS7 format with base 64 encoding.</p>

<p>So kindly advise me how to do this encryption and i am doing this project in PHP.</p>

<p>Also i have tried with following code but no results</p>

<pre><code>$data = 'Test Data';
$key = file_get_contents(""certificate.pem"");
$fp = fopen(""msg.txt"", ""w"");
fwrite($fp, $data);
fclose($fp);
openssl_pkcs7_encrypt(""msg.txt"", ""enc.txt"", $key,[]);
</code></pre>

<p>Output:</p>

<pre><code>MIME-Version: 1.0
Content-Disposition: attachment; filename=""smime.p7m""
Content-Type: application/x-pkcs7-mime; smime-type=enveloped-data; name=""smime.p7m""
Content-Transfer-Encoding: base64

MIICCgYJKoZIhvcNAQcDoIIB+zCCAfcCAQAxggG1MIIBsQIBADCBmDCBkDELMAkG
A1UEBhMCSU4xKjAoBgNVBAoTIWVNdWRocmEgQ29uc3VtZXIgU2VydmljZXMgTGlt
aXRlZDEdMBsGA1UECxMUQ2VydGlmeWluZyBBdXRob3JpdHkxNjA0BgNVBAMTLWUt
TXVkaHJhIFN1YiBDQSBmb3IgQ2xhc3MgMyBPcmdhbmlzYXRpb24gMjAxNAIDI2nL
MA0GCSqGSIb3DQEBAQUABIIBAEoKNU5O/NSlM62cVyq1CJ2qN6VA0kDRJaJVrUze
Tbd8OJZdzdcn3T+ZNh2myDRliW3B8Q+u4qZN8NZ1GM9e5OkmdxgWPD0wDhUZyMhu
796XOIdlZVLlyaNDr/QGYb4XxFrsJAqMXYFh3QPIATHhpaBGTnlB2fvFwtLSHocv
TzGT/UgL9aS3BiDh/S7sULsOXZoMNlHP4rnzRnjRsU+QJogtYnKBXGcKuzxeXRDL
dd7OxHTDgf4MFJcBdwdk6xwtbrVfyNCnIwzzFC4UwR5I/w6js+sBTg+EXAcCZqtG
rouNxu+SBkYMh63r+5LX0C8rL6xp6jzt49dgttKxh8Q+xc0wOQYJKoZIhvcNAQcB
MBoGCCqGSIb3DQMCMA4CAgCgBAiKcFDFzN93RIAQprj+fHrW8KA1XSSEY0fH3Q==
</code></pre>

<p>But it is not accepted from remote. Please help me</p>

<p>Thank you</p>
","<p>It seems to me that your pem file contains the certificate + a private key and you need to make a signature instead of encrypt the data.</p>

<p>Use therefore <code>openssl_pkcs7_sign()</code> instead of encrypt.</p>
","820","<php><pkcs#7>","0","0","1","2016-02-22 13:03:37","","5","","3955758","","2016-02-22 12:28:31","2016-02-22 10:56:41",""
"16022688","How to encrypt CSR into PKCS7 using bouncycastle?","<p>Hi, guys! My problem is next: I have the CSR certificate, certificate X509 of client and file .p12 with private key of CSR. I want to encrypt my CSR into PKCS7 and in future get it and verify.</p>

<p>In the next code I'm trying to read my CSR and put it in PKCS7 container:</p>

<p><pre><code>
        //get client X509 certificate
        FileInputStream fis = new FileInputStream(PATH+""//pkcs7-csr-cer//identity.cer"");
        X509Certificate certificate = (X509Certificate) CertificateFactory.getInstance(""X.509"").generateCertificate(fis);
        fis.close();

        //read my csr file and create pkcs10 based on it
        FileReader fileReader = new FileReader(csrfilename);
        PemReader pemReader = new PemReader(fileReader);
        PKCS10CertificationRequest pkcs10 = new PKCS10CertificationRequest(pemReader.readPemObject().getContent());

        //trying to encrypt the pkcs10 in pkcs7
        CMSEnvelopedDataGenerator generator = new CMSEnvelopedDataGenerator();
        generator.addKeyTransRecipient(certificate);

        CMSProcessable sdata = new CMSProcessableByteArray(pkcs10.getEncoded());
        CMSEnvelopedData envelopedData = generator.generate(sdata, CMSEnvelopedDataGenerator.AES256_CBC, ""BC"");
        bytes[] pkcs10Encrypted = envelopedData.getEncoded();


        //trying to get from encrypted csr
        CMSEnvelopedDataParser envDataParser = new CMSEnvelopedDataParser(enveloped);
        RecipientInformationStore recipients = envDataParser.getRecipientInfos();
        Collection envCollection = recipients.getRecipients();
        Iterator it = envCollection.iterator();
        RecipientInformation recipient = (RecipientInformation) it.next();
        byte[] result = recipient.getContent(privateKey, ""BC"");
        String base64Encoded = new String(Base64.encode(result));
</code></pre></p>

<p>And I receive exception:</p>

<p><pre><code>
Exception in thread ""main"" org.bouncycastle.cms.CMSException: bad padding in message.
    at org.bouncycastle.cms.KeyTransRecipientInformation.getSessionKey(Unknown Source)
    at org.bouncycastle.cms.KeyTransRecipientInformation.getContentStream(Unknown Source)
    at org.bouncycastle.cms.RecipientInformation.getContent(Unknown Source)

</code></pre></p>

<p>I googled and found same problem, but solution was incorrect private key, but my is true. 
Help, please. Maybe who knows some tutorials Bouncy Castle? Thanks!</p>
","","801","<java><encryption><bouncycastle><pkcs#7><csr>","0","","0","2013-04-17 15:56:04","","2","","1809141","","2013-04-17 15:56:04","2013-04-15 18:53:14",""
"30565504","Converting decimal to hexadecimal byte in Java Card","<p>I would like to convert a decimal (integer or short types) in Java to hexadecimal byte in a Java Card environment (only supports byte and short types and possibly int types).</p>

<p>Example:</p>

<pre><code>int num = 254
</code></pre>

<p>Print out result:</p>

<pre><code>0xFD
</code></pre>

<p>My current method of using switches and if-else to handle all 256 scenarios are totally inelegant and would like something much more elegant than simply switches or if-else.</p>

<p>The reason is I want to manually handle PKCS 5/7 paddings on the Java Card in the event the PKCS5 Ciphers are not available somehow as a fallback method.</p>
","<p>It slipped my mind that you could do:</p>

<pre><code>if (num &lt; 256) {
   return (byte) num;
}
</code></pre>

<p>That should have settled it for now considering the num which is the amount to pad is less than 256 for PKCS 5 and 7 padding as per RFC-1423, RFC-2898 and RFC-5652.</p>
","793","<hex><javacard><pkcs#7><pkcs#5>","0","0","3","2016-01-21 03:40:39","30565788","0","","","","","2015-06-01 04:09:30",""
"30565504","Converting decimal to hexadecimal byte in Java Card","<p>I would like to convert a decimal (integer or short types) in Java to hexadecimal byte in a Java Card environment (only supports byte and short types and possibly int types).</p>

<p>Example:</p>

<pre><code>int num = 254
</code></pre>

<p>Print out result:</p>

<pre><code>0xFD
</code></pre>

<p>My current method of using switches and if-else to handle all 256 scenarios are totally inelegant and would like something much more elegant than simply switches or if-else.</p>

<p>The reason is I want to manually handle PKCS 5/7 paddings on the Java Card in the event the PKCS5 Ciphers are not available somehow as a fallback method.</p>
","<p>There is a class named <a href=""http://www.win.tue.nl/pinpasjc/docs/apis/jc222/javacardx/framework/math/BCDUtil.html#convertToBCD(byte[],%20short,%20short,%20byte[],%20short)"" rel=""nofollow""><code>BCDTool</code></a> inside <code>javacardx.framework.math</code> package. </p>

<blockquote>
  <h3>Method Summary</h3>
  
  <p><code>static short convertToBCD(byte[] hexArray, short bOff,short bLen, byte[] bcdArray, short outOff)</code></p>
  
  <p>Converts the input hexadecimal data into BCD format.</p>
  
  <p><code>static short convertToHex(byte[] bcdArray, short bOff, short bLen, byte[] hexArray, short outOff)</code> </p>
  
  <p>Converts the input BCD data into hexadecimal format.</p>
  
  <p><code>static short getMaxBytesSupported()</code></p>
  
  <p>This method returns the largest value that can be used with the BCD utility functions.</p>
  
  <p><code>static boolean   isBCDFormat(byte[] bcdArray,short bOff, short bLen)</code> </p>
  
  <p>Checks if the input data is in BCD format.</p>
</blockquote>

<p>Note that this package is optional and your card maybe or maybe not support it. </p>
","793","<hex><javacard><pkcs#7><pkcs#5>","0","0","3","2016-01-21 03:40:39","30565788","0","","","","","2015-06-01 04:09:30",""
"30565504","Converting decimal to hexadecimal byte in Java Card","<p>I would like to convert a decimal (integer or short types) in Java to hexadecimal byte in a Java Card environment (only supports byte and short types and possibly int types).</p>

<p>Example:</p>

<pre><code>int num = 254
</code></pre>

<p>Print out result:</p>

<pre><code>0xFD
</code></pre>

<p>My current method of using switches and if-else to handle all 256 scenarios are totally inelegant and would like something much more elegant than simply switches or if-else.</p>

<p>The reason is I want to manually handle PKCS 5/7 paddings on the Java Card in the event the PKCS5 Ciphers are not available somehow as a fallback method.</p>
","<p>There is no such thing as an hexadecimal byte. In Java a byte consists of 8 bits. When viewed as a number these bits contain a 8 bit two-complement number from -128 to 127. Hexadecimals is a textual representation of values - such as the Java byte - for human consumption.</p>

<p>Integers are usually not supported on Java Card classic, so I'll just show how to convert short values to bytes.</p>

<p>If you are already sure that the short <code>s</code> contains a byte in the lower 8 bits then conversion is simple:</p>

<pre><code>byte b = (byte) s;
</code></pre>

<p>if you are not sure you must decide if you want to allow. If you just care about the 8 lower bits: see above.</p>

<p>If you however want to have a positive number 0..255 stored in the byte, you can check using:</p>

<pre><code>if (s &lt; 0 || s &gt; BYTE_MAX_UNSIGNED) {
    // do something nasty
}
byte b = (byte) s;
</code></pre>

<p>or for the negative values -128 to 127:</p>

<pre><code>if (s &lt; BYTE_MIN || s &gt; BYTE_MAX) {
    // do something nasty
}
byte b = (byte) s;
</code></pre>

<p>Of course the values of the constants is:</p>

<pre><code>private static final short BYTE_MAX = 0x7F;
private static final short BYTE_MIN = -0x80;
private static final short BYTE_MAX_UNSIGNED = 0xFF;
</code></pre>

<p>If you keep them <code>private static final</code> then these constants will be inlined into your bytecode by the converter.</p>

<p>As you can see the final byte encoding is identical for both cases. This is why two-complement is the default encoding in about every computer on the planet.</p>

<p>Note that regardless of the value of the short, the byte will hold a value from -128 to 127. If you want to convert the byte to a positive value for calculations, you can use:</p>

<pre><code>short s = b &amp; BYTE_MAX_UNSIGNED;
</code></pre>

<p>to get back a positive value from 0 to 255.</p>
","793","<hex><javacard><pkcs#7><pkcs#5>","0","1","3","2016-01-21 03:40:39","30565788","0","","","","","2015-06-01 04:09:30",""
"40328927","Disable PKCS#7 padding on an AES cipher object?","<p>i am programming a fuse file system and i've a poblem.</p>

<p>I am ciphering the data in the disk by using CBC AES. The problem is the padding. It is no problem when the size to cipher is for example 15 bytes because it adds 1 byte extra. The problem is that when i am trying to cipher 4096 bytes it also adds me 16 bytes of padd and it is fail for me. I do not know why it is adding padding because 4096 is multiple of 128 (size aes block). I need to modify my c code for say to openssl that only add padding when it will be neccesary but not always...</p>

<p>I know that if the plaintext is not multiple of 128 it is going to add padding. But why if not? What can i do?</p>

<p>Here my cipher code:</p>

<pre><code>    int encrypt_data(unsigned char *plaintext, int plaintext_len, unsigned char *key,
                unsigned char *iv, unsigned char *ciphertext, int algorithm_pos)
{
        EVP_CIPHER_CTX *ctx;

        int len;

        int ciphertext_len;

        /* Create and initialise the context */
        if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();

        /* Initialise the encryption operation. IMPORTANT - ensure you use a key
         * and IV size appropriate for your cipher
         * In this example we are using 256 bit AES (i.e. a 256 bit key). The
         * IV size for *most* modes is the same as the block size. For AES this
         * is 128 bits */
        if(1 != EVP_EncryptInit_ex(ctx, ciphers[algorithm_pos].algorithm(), NULL, key, iv))
                handleErrors();

        /* Provide the message to be encrypted, and obtain the encrypted output.
         * EVP_EncryptUpdate can be called multiple times if necessary
         */
        if(1 != EVP_EncryptUpdate(ctx, ciphertext, &amp;len, plaintext, plaintext_len))
                handleErrors();
        ciphertext_len = len;

        /* Finalise the encryption. Further ciphertext bytes may be written at
         * this stage.
         */
        if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &amp;len)) handleErrors();
        ciphertext_len += len;

        /* Clean up */
        EVP_CIPHER_CTX_free(ctx);

        return ciphertext_len;
}
</code></pre>
","<p>See <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7"" rel=""nofollow noreferrer"">PKCS#7 padding</a>. The reason for padding an exact multiple of the block size is there would be no way to tell if there was no padding so padding must either always or never be used. Consider if the data was 4096 bytes and the last byte was 0x01. Looks like one byte of padding but it isn't, it is part of the data.</p>

<p>But you should be using a disk sector encrypting mode such as XTS, XTS is only recommended for full-disk encryption. That is what it was designed for by the IEEE Standard 1619.</p>

<p>See <a href=""https://security.stackexchange.com/a/102600/5121"">Explanation of the XTS Encryption Mode</a>.</p>

<p>Also NIST: <a href=""http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38e.pdf"" rel=""nofollow noreferrer"">The XTS-AES Mode for Confidentiality on Storage Devices</a></p>
","774","<c><encryption><openssl><aes><pkcs#7>","1","3","2","2016-11-03 05:43:04","","1","","608639","","2016-11-03 05:43:04","2016-10-30 12:14:11","2016-11-03 05:46:32"
"40328927","Disable PKCS#7 padding on an AES cipher object?","<p>i am programming a fuse file system and i've a poblem.</p>

<p>I am ciphering the data in the disk by using CBC AES. The problem is the padding. It is no problem when the size to cipher is for example 15 bytes because it adds 1 byte extra. The problem is that when i am trying to cipher 4096 bytes it also adds me 16 bytes of padd and it is fail for me. I do not know why it is adding padding because 4096 is multiple of 128 (size aes block). I need to modify my c code for say to openssl that only add padding when it will be neccesary but not always...</p>

<p>I know that if the plaintext is not multiple of 128 it is going to add padding. But why if not? What can i do?</p>

<p>Here my cipher code:</p>

<pre><code>    int encrypt_data(unsigned char *plaintext, int plaintext_len, unsigned char *key,
                unsigned char *iv, unsigned char *ciphertext, int algorithm_pos)
{
        EVP_CIPHER_CTX *ctx;

        int len;

        int ciphertext_len;

        /* Create and initialise the context */
        if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();

        /* Initialise the encryption operation. IMPORTANT - ensure you use a key
         * and IV size appropriate for your cipher
         * In this example we are using 256 bit AES (i.e. a 256 bit key). The
         * IV size for *most* modes is the same as the block size. For AES this
         * is 128 bits */
        if(1 != EVP_EncryptInit_ex(ctx, ciphers[algorithm_pos].algorithm(), NULL, key, iv))
                handleErrors();

        /* Provide the message to be encrypted, and obtain the encrypted output.
         * EVP_EncryptUpdate can be called multiple times if necessary
         */
        if(1 != EVP_EncryptUpdate(ctx, ciphertext, &amp;len, plaintext, plaintext_len))
                handleErrors();
        ciphertext_len = len;

        /* Finalise the encryption. Further ciphertext bytes may be written at
         * this stage.
         */
        if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &amp;len)) handleErrors();
        ciphertext_len += len;

        /* Clean up */
        EVP_CIPHER_CTX_free(ctx);

        return ciphertext_len;
}
</code></pre>
","<blockquote>
  <p>The problem is that when i am trying to cipher 4096 bytes it also adds me 16 bytes of padd and it is fail for me. I do not know why it is adding padding because 4096 is multiple of 128 (size aes block). </p>
</blockquote>

<p>As Zaph stated, PKCS#7 padding is being added. The padding is deterministic, so an exact multiple of 16 byts is also padded to ensure removal. Otherwise, how does a generalized algorithm know when (1) plain text ends on a 16-byte boundary, versus (2) plain text <em>not</em> ends on a 16-byte boundary and padded?</p>

<p>You can disable the padding behavior on the cipher object with <a href=""http://www.openssl.org/docs/man1.0.2/crypto/EVP_CIPHER_CTX_ctrl.html"" rel=""nofollow noreferrer""><code>EVP_CIPHER_CTX_ctrl</code></a> and <a href=""http://www.openssl.org/docs/man1.0.2/crypto/EVP_CIPHER_CTX_ctrl.html"" rel=""nofollow noreferrer""><code>EVP_CIPHER_CTX_set_padding</code></a>. <code>EVP_CIPHER_CTX_set_padding</code> is a macro'd version of <code>EVP_CIPHER_CTX_ctrl</code>. Here is what it looks like:</p>

<pre class=""lang-c prettyprint-override""><code>int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
</code></pre>

<p>From the man page:</p>

<blockquote>
  <p>EVP_CIPHER_CTX_set_padding() enables or disables padding. By default
  encryption operations are padded using standard block padding and the
  padding is checked and removed when decrypting. If the pad parameter
  is zero then no padding is performed, the total amount of data
  encrypted or decrypted must then be a multiple of the block size or an
  error will occur.</p>
</blockquote>

<hr>

<blockquote>
  <p>I know that if the plaintext is not multiple of 128 it is going to add padding. But why if not? What can i do?</p>
</blockquote>

<p>Disable padding on your cipher context object. Here's how the library does it:</p>

<pre class=""lang-none prettyprint-override""><code>$ grep -IR EVP_CIPHER_CTX_set_padding *
CHANGES:  *) New function EVP_CIPHER_CTX_set_padding() this is used to
apps/enc.c:            EVP_CIPHER_CTX_set_padding(ctx, 0);
apps/speed.c:                EVP_CIPHER_CTX_set_padding(&amp;ctx, 0);
crypto/cms/cms_pwri.c:    EVP_CIPHER_CTX_set_padding(&amp;kekctx, 0);
crypto/evp/evp.h:int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);
crypto/evp/evp_enc.c:int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)
crypto/evp/evp_test.c:        EVP_CIPHER_CTX_set_padding(&amp;ctx, 0);
crypto/evp/evp_test.c:        EVP_CIPHER_CTX_set_padding(&amp;ctx, 0);
</code></pre>
","774","<c><encryption><openssl><aes><pkcs#7>","1","0","2","2016-11-03 05:43:04","","1","","608639","","2016-11-03 05:43:04","2016-10-30 12:14:11","2016-11-03 05:46:32"
"47884782","How to create an x-pkcs7-signature s/mime message?","<p>I am trying to create x-pkcs7-signature s/mime messages in C#. I've been experimenting with Mimekit and can only make pkcs7 messages.</p>

<p>Does anyone know what I need to do to create x-pkcs messages or point me to some examples?</p>

<p>Regards</p>
","<p>There are 2 different ways to sign a message using S/MIME:</p>

<ol>
<li><code>application/[x-]pkcs7-mime; smime-type=signed-data</code></li>
<li><code>application/[x-]pkcs7-signature</code></li>
</ol>

<p>To sign the first way, do this:</p>

<pre><code>var signer = new MailboxAddress ("""", ""signer@example.com"");
var signed = ApplicationPkcs7Mime.Sign (signer, DigestAlgorithm.Sha256, entity);
</code></pre>

<p>The other way is done like this:</p>

<pre><code>using (var ctx = new WindowsSecureMimeContext ()) {
    var signer = new MailboxAddress ("""", ""signer@example.com"");
    var signed = MultipartSigned.Sign (ctx, signer, DigestAlgorithm.Sha256, entity);
}
</code></pre>

<p>In both cases, you can also use a <code>MimeKit.Cryptography.CmsSigner</code> instead of a <code>MailboxAddress</code>. You could also use a <code>SecureMailboxAddress</code> if you know the fingerprint of the certificate.</p>
","769","<c#><pkcs#7><smime>","4","0","1","2017-12-19 20:47:04","","1","","98579","","2017-12-19 10:53:17","2017-12-19 10:22:55",""
"30264339","Saving one or multiple X509Certificates to a PKCS#7 File / Container?","<p>I have multiple X509Certificates. Now I want to save one or more of them into a PKCS#7 File / Container with Java.</p>

<p>I could read in one or more Certificates from a PKCS#7 file, but I don't know how to write them to a PKCS#7 file. I only know that the data in this file is PEM encoded and this data is within the tags <code>--- BEGINN PKCS7 ---</code> and <code>--- END PKCS7 ---</code>.</p>
","<p>At first, read the whole RFC for PKCS#7/CMS for better understanding. Please follow this <a href=""https://tools.ietf.org/html/rfc5652"" rel=""nofollow"">RFC link</a>. 
</p>
For easy implementation use bouncycastle library. Now, There are different types of PKCS#7.CMS data (like signedData, envelopedData etc.). Lets take, you want to use signeData format. Then, you need to generate <a href=""https://www.bouncycastle.org/docs/pkixdocs1.4/org/bouncycastle/cms/CMSSignedData.html"" rel=""nofollow"">CMSSignedData</a> data. For that, you need to prepare private key and Certificate chain. Here, I am assuming, you already have those. Now prepare <a href=""https://www.bouncycastle.org/docs/pkixdocs1.4/org/bouncycastle/cms/CMSProcessableByteArray.html"" rel=""nofollow"">CMSProcessableByteArray</a>.
</p>
Sample code for CMSProcessableByteArray:</p>

<pre><code>CMSProcessableByteArray msg = new CMSProcessableByteArray(""Hello World"".getBytes());
</code></pre>

<p>hen declare CMSSignedDataGenerator and add signerInfo and certificates.</p>

<pre><code>CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(......));
gen.addCertificates(certs);
</code></pre>

<p>Then generate CMSSignedData with CMSSignedDataGenerator and CMSProcessableByteArray.</p>

<pre><code>CMSSignedData cmsData = gen.generate(msg, true);
</code></pre>

<p>Now, there are two formats for you to write the file in: Pem and Der. You want to write in pem encoded. So then, Take the whole data in a ContentInfo.</p>

<pre><code>ContentInfo ci = ContentInfo.getInstance(ASN1Object.fromByteArray(signedData));
</code></pre>

<p>Now, use Pemwriter to write the contentInfo object in p7b format. Open the file and see user certificates.</p>

<pre><code>PEMWriter pemWriter = new PEMWriter(new FileWriter(""Demo-CMS.p7b""));
pemWriter.writeObject(obj);
pemWriter.flush();
pemWriter.close();
</code></pre>
","763","<java><export><x509certificate><pkcs#7>","-1","1","1","2015-05-26 11:19:50","30457076","0","","2422776","","2015-05-18 07:04:14","2015-05-15 16:23:35",""
"42300197","Reading the certificate of PKCS#7 Signed Data using pure python","<p>There is already a lot of questions out there but the problem is, none of them have sufficient answers how to do it, especially when using python3.</p>

<p>Basically, I want to read JAR/APK certificates, like this one: <a href=""http://lapo.it/asn1js/#308206AE06092A864886F70D010702A082069F3082069B020101310B300906052B0E03021A0500300B06092A864886F70D010701A08204AC308204A830820390A003020102020900936EACBE07F201DF300D06092A864886F70D0101050500308194310B3009060355040613025553311330110603550408130A43616C69666F726E6961311630140603550407130D4D6F756E7461696E20566965773110300E060355040A1307416E64726F69643110300E060355040B1307416E64726F69643110300E06035504031307416E64726F69643122302006092A864886F70D0109011613616E64726F696440616E64726F69642E636F6D301E170D3038303232393031333334365A170D3335303731373031333334365A308194310B3009060355040613025553311330110603550408130A43616C69666F726E6961311630140603550407130D4D6F756E7461696E20566965773110300E060355040A1307416E64726F69643110300E060355040B1307416E64726F69643110300E06035504031307416E64726F69643122302006092A864886F70D0109011613616E64726F696440616E64726F69642E636F6D30820120300D06092A864886F70D01010105000382010D00308201080282010100D6931904DEC60B24B1EDC762E0D9D8253E3ECD6CEB1DE2FF068CA8E8BCA8CD6BD3786EA70AA76CE60EBB0F993559FFD93E77A943E7E83D4B64B8E4FEA2D3E656F1E267A81BBFB230B578C20443BE4C7218B846F5211586F038A14E89C2BE387F8EBECF8FCAC3DA1EE330C9EA93D0A7C3DC4AF350220D50080732E0809717EE6A053359E6A694EC2CB3F284A0A466C87A94D83B31093A67372E2F6412C06E6D42F15818DFFE0381CC0CD444DA6CDDC3B82458194801B32564134FBFDE98C9287748DBF5676A540D8154C8BBCA07B9E247553311C46B9AF76FDEECCC8E69E7C8A2D08E782620943F99727D3C04FE72991D99DF9BAE38A0B2177FA31D5B6AFEE91F020103A381FC3081F9301D0603551D0E04160414485900563D272C46AE118605A47419AC09CA8C113081C90603551D230481C13081BE8014485900563D272C46AE118605A47419AC09CA8C11A1819AA48197308194310B3009060355040613025553311330110603550408130A43616C69666F726E6961311630140603550407130D4D6F756E7461696E20566965773110300E060355040A1307416E64726F69643110300E060355040B1307416E64726F69643110300E06035504031307416E64726F69643122302006092A864886F70D0109011613616E64726F696440616E64726F69642E636F6D820900936EACBE07F201DF300C0603551D13040530030101FF300D06092A864886F70D010105050003820101007AAF968CEB50C441055118D0DAABAF015B8A765A27A715A2C2B44F221415FFDACE03095ABFA42DF70708726C2069E5C36EDDAE0400BE29452C084BC27EB6A17EAC9DBE182C204EB15311F455D824B656DBE4DC2240912D7586FE88951D01A8FEB5AE5A4260535DF83431052422468C36E22C2A5EF994D61DD7306AE4C9F6951BA3C12F1D1914DDC61F1A62DA2DF827F603FEA5603B2C540DBD7C019C36BAB29A4271C117DF523CDBC5F3817A49E0EFA60CBD7F74177E7A4F193D43F4220772666E4C4D83E1BD5A86087CF34F2DEC21E245CA6C2BB016E683638050D2C430EEA7C26A1C49D3760A58AB7F1A82CC938B4831384324BD0401FA12163A50570E684D318201CA308201C60201013081A2308194310B3009060355040613025553311330110603550408130A43616C69666F726E6961311630140603550407130D4D6F756E7461696E20566965773110300E060355040A1307416E64726F69643110300E060355040B1307416E64726F69643110300E06035504031307416E64726F69643122302006092A864886F70D0109011613616E64726F696440616E64726F69642E636F6D020900936EACBE07F201DF300906052B0E03021A0500300D06092A864886F70D01010105000482010097F573FC2453BCCD534950C572AE222B0E54CB8483A67F675903657DE94BAB6B1B222F056496B37AF12C24A8840112E8968DFAF369B7EB03FE2FA7EBA65E66FE89B6600FEB7BE8273F0C57E069B7397BA7A5DA1DBBA529BA85443B7AEB723FF5DAF53F47A1EA31CF1716616DCE81E2271964974FA1C064B4738A0A04E87A34AFB3BBA74D2DEB974C3DCD6609D2F61338612DC143F17E8CCB12179DBD22D344FE5D8E3AF0BF8B2E8F11635F7F540042924C82D7C8D49553F16EB57A5875B0249204F1AB6417A754A2955823F595D2926DEAF91F9515BFF8A10BD03D3A2CBC222A423018175A6EFEDE59F3D7FA6D39ACA599831D04E583CBC423D4244718ED2F42"" rel=""nofollow noreferrer"">Link to ASN1 Decoder, with Android Test Signing Key</a></p>

<p>There are now several alternatives:</p>

<ul>
<li>pyasn1: seems to work, but only can parse the raw ASN.1 format</li>
<li>M2Crypto: only works on py2</li>
<li>Chilkat: Not free, although CkCert seems to be free</li>
<li>cryptography: Can not load the certificate, as the X509 certificate is inside the PKCS#7 container</li>
</ul>

<p>I found a way to use pyasn1 to unpack the cert from the pkcs#7 message, then use cryptography to read it:</p>

<pre><code>from pyasn1.codec.der.decoder import decode
from pyasn1.codec.der.encoder import encode
from cryptography import x509
from cryptography.hazmat.backends import default_backend

cdata = open(""CERT.RSA"", ""rb"").read()
cert, rest = decode(cdata)
# The cert should be located there
realcert = encode(cert[1][3])
realcert = realcert[2 + (realcert[1] &amp; 0x7F) if realcert[1] &amp; 0x80 &gt; 1 else 2:]  # remove the first DER identifier from the front
x509.load_der_x509_certificate(realcert, default_backend())
</code></pre>

<p>which gives</p>

<pre><code>&lt;Certificate(subject=&lt;Name([&lt;NameAttribute(oid=&lt;ObjectIdentifier(oid=2.5.4.6, name=countryName)&gt;, value='US')&gt;, &lt;NameAttribute(oid=&lt;ObjectIdentifier(oid=2.5.4.8, name=stateOrProvinceName)&gt;, value='California')&gt;, &lt;NameAttribute(oid=&lt;ObjectIdentifier(oid=2.5.4.7, name=localityName)&gt;, value='Mountain View')&gt;, &lt;NameAttribute(oid=&lt;ObjectIdentifier(oid=2.5.4.10, name=organizationName)&gt;, value='Android')&gt;, &lt;NameAttribute(oid=&lt;ObjectIdentifier(oid=2.5.4.11, name=organizationalUnitName)&gt;, value='Android')&gt;, &lt;NameAttribute(oid=&lt;ObjectIdentifier(oid=2.5.4.3, name=commonName)&gt;, value='Android')&gt;, &lt;NameAttribute(oid=&lt;ObjectIdentifier(oid=1.2.840.113549.1.9.1, name=emailAddress)&gt;, value='android@android.com')&gt;])&gt;, ...)&gt;
</code></pre>

<p>Is there no other way to have it clean and tidy?</p>
","<p>There are now libraries to do this in pure python. One is asn1crypto: <a href=""https://github.com/wbond/asn1crypto#readme"" rel=""nofollow noreferrer"">https://github.com/wbond/asn1crypto#readme</a>
This is also impemented in androguard, including examples how to use it: <a href=""https://androguard.readthedocs.io/en/latest/intro/certificates.html"" rel=""nofollow noreferrer"">https://androguard.readthedocs.io/en/latest/intro/certificates.html</a></p>
","759","<python><x509><pkcs#7>","3","-1","1","2018-09-08 18:35:37","52238288","0","","446140","","2017-02-17 14:48:44","2017-02-17 14:19:34",""
"34188310","How create signature file to sent web push notification in safari from nodejs server","<p>now I have a server can send push notification to chrome, I want extend for safari too, in apple doc (<a href=""https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/NotificationProgrammingGuideForWebsites/PushNotifications/PushNotifications.html"" rel=""nofollow noreferrer"">https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/NotificationProgrammingGuideForWebsites/PushNotifications/PushNotifications.html</a>) but I don't know how make the signature file in nodeJS</p>

<blockquote>
  <p>The Signature </p>
  
  <p>The signature is a PKCS #7 detached signature of the
  manifest file. Sign the manifest file with the private key associated
  with your web push certificate that you obtained while registering
  with Apple. In PHP, you can do this with the openssl_pkcs7_sign
  function. The create_signature function in the attached
  createPushPackage.php companion file (the link is near the top of the
  page) shows how you can do this.</p>
  
  <p>If the contents of your push package ever change, you‚Äôll need to
  recompute your signature.</p>
</blockquote>

<p>in the same page apple put a example in php:</p>

<pre><code>// Creates a signature of the manifest using the push notification certificate.
function create_signature($package_dir, $cert_path, $cert_password) {
    // Load the push notification certificate
    $pkcs12 = file_get_contents($cert_path);
    $certs = array();
    if(!openssl_pkcs12_read($pkcs12, $certs, $cert_password)) {
        return;
    }

    $signature_path = ""$package_dir/signature"";

    // Sign the manifest.json file with the private key from the certificate
    $cert_data = openssl_x509_read($certs['cert']);
    $private_key = openssl_pkey_get_private($certs['pkey'], $cert_password);
    openssl_pkcs7_sign(""$package_dir/manifest.json"", $signature_path, $cert_data, $private_key, array(), PKCS7_BINARY | PKCS7_DETACHED);

    // Convert the signature from PEM to DER
    $signature_pem = file_get_contents($signature_path);
    $matches = array();
    if (!preg_match('~Content-Disposition:[^\n]+\s*?([A-Za-z0-9+=/\r\n]+)\s*?-----~', $signature_pem, $matches)) {
        return;
    }
    $signature_der = base64_decode($matches[1]);
    file_put_contents($signature_path, $signature_der);
}
</code></pre>

<p>somebody know how make the same function in nodeJS?</p>
","<p>ok I finally found how to do this, you must first convert the certificate and key to PEM format</p>

<pre><code>$ openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem
$ openssl pkcs12 -in key.p12 -out key.pem -nodes
</code></pre>

<p>after that, you can sign your manifest with smime module (i use <a href=""https://github.com/hipush/smime"" rel=""nofollow"">https://github.com/hipush/smime</a> ) and we are ready, we have a signature :) :) :) </p>
","755","<node.js><safari><apple-push-notifications><pkcs#7>","1","2","1","2019-03-23 17:04:26","34312081","0","1","1033581","","2019-03-23 17:04:26","2015-12-09 20:25:41",""
"16603438","Ways to create a PKCS7 signature file using perl","<p>I have been working on an application that create apples new ios pass.I am new to perl modules and i need some answers about how can we create signature files that uses PKCS7 encryption from a json file. any help would be appreciated.I have certificates and teamid for creating passes.
or 
more simply how to create a signature for a json file using PKCS7 encryption.</p>

<p>and have certificates of format p12 , pem cer.</p>
","<p>To handle PKCS7 you can use <a href=""http://search.cpan.org/~madwolf/OpenCA-PKCS7-0.3.0a/PKCS7.pm"" rel=""nofollow"">OpenCA-PKCS7</a> module. To deal with JSON you can use <a href=""http://search.cpan.org/~makamaka/JSON-2.57/lib/JSON.pm"" rel=""nofollow"">JSON</a> module. CPAN documentation gives all the needed info to work with those modules. Enjoy.</p>
","745","<perl><encryption><openssl><passbook><pkcs#7>","2","-1","1","2013-05-17 15:41:55","","0","1","2045980","","2013-05-17 10:46:49","2013-05-17 07:11:44",""
"31872459","Java - Verify PKCS7 signature using sun classes","<p>How to verify PKCS7 signature using <code>sun</code> classes? I know that it is bad thing to do, but for some reasons I can't use BouncyCastle of any other external libraries.</p>

<p>I can get the content from PKCS7 using the following code:</p>

<pre><code>str = str.replace(""-----BEGIN PKCS7-----\n"", """").replace(""-----END PKCS7-----"", """");
PKCS7 pkcs7 = new PKCS7(Base64.decodeBase64(str.getBytes(""UTF-8"")));
byte[] b = new byte[pkcs7.getContentInfo().getContent().getData().available()];
pkcs7.getContentInfo().getContent().getData().getBytes(b);
String s = new String(b, ""UTF-8"");
return s.substring(s.indexOf(""&lt;"")); //there are some strange symbols before &lt;?xml
</code></pre>

<p>But I need to verify signature first. Of course I have a certificate to do this:
<code>private X509Certificate certVerify;</code>. </p>

<p>Thanks!</p>
","<p>You'll have to write a CMS and underlying ASN.1 BER/DER library yourself. Sun doesn't contain any official API to handle the CMS messages specified by PKCS#7 (or the followup RFC's).</p>

<hr>

<p>The JRE may contain useful code in the <em>implementation</em> of Java. Note that these classes are <em>not</em> part of the API and may change over different versions of Sun's / Oracle's Java. Furthermore, they may not be present <em>at all</em> in 3<sup>rd</sup> party implementations of Java.</p>

<pre><code>import sun.security.util.*;
import sun.security.x509.AlgorithmId;
import sun.security.x509.X500Name;
import sun.security.x509.KeyUsageExtension;
import sun.security.x509.PKIXExtensions;
import sun.misc.HexDumpEncoder;
</code></pre>

<p>These API's <em>should not</em> be used. They even cannot be used without making an change in the access conditions of the runtime in e.g. Eclipse.</p>

<hr>

<p>Note that the Bouncy Castle libraries have a <em>very</em> permissive license; you could even copy the source code to your application (as long as you leave the initial statement in there, <em>read the license</em> for more details). If your employer tells you that you cannot use even that then there might be something seriously wrong in the organization.</p>
","725","<java><security><encryption><digital-signature><pkcs#7>","1","2","1","2015-08-07 12:59:57","","0","","","","","2015-08-07 07:56:47",""
"46682750","Warning: openssl_pkcs7_sign: error creating PKCS7 structure","<p>We are trying to sign the PAN no. with Digital Signature. We are taking the PAN No. in in.txt file but we are getting error -</p>

<p><strong>Warning: openssl_pkcs7_sign(): error creating PKCS7 structure!</strong></p>

<pre><code>openssl_pkcs7_sign(realpath(""in.txt""), ""out.txt"",
                'file://'.realpath('digitalsign.cer'),
               'file://'.realpath('private_key.pem'),
                array (), PKCS7_NOSIGS
            );  
</code></pre>

<p>Kindly suggest what we can do to resolve this issue.</p>
","<p>I think your digital certificate and the Private key is an issue. Kindly create the Digital Certificate and Private Key with below command.</p>

<pre><code>openssl req -x509 -days 365 -newkey rsa:1024 -keyout enc_key.pem -out selfcert.pem
</code></pre>

<p>Then after that use that certificate and private key and that will work for you. It worked for me and if still you face issue do comment.</p>
","717","<php><openssl><digital-signature><pkcs#7>","0","2","1","2017-10-27 07:20:58","46969591","0","1","3007197","","2017-10-14 09:23:28","2017-10-11 07:52:27",""
"44704289","Retrieving CMSSignedData from ASN.1 encoding in Bouncy Castle","<p>In the following piece of code I sign a message using Bouncy Castle:</p>

<pre><code>import org.bouncycastle.cms.CMSProcessableByteArray;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import org.bouncycastle.cms.CMSTypedData;
import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
import org.bouncycastle.util.encoders.Base64;

import java.io.FileInputStream;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.Security;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;

public class Sign {

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        String certPath = ""certPath"";
        FileInputStream inPublic = new FileInputStream(certPath);
        CertificateFactory factory = CertificateFactory.getInstance(""X.509"");
        X509Certificate cert = (X509Certificate) factory.generateCertificate(inPublic);


        String keyPrivatePath = ""keyPath"";
        Path path = Paths.get(keyPrivatePath);
        Files.readAllBytes(Paths.get(keyPrivatePath));
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(Files.readAllBytes(Paths.get(keyPrivatePath)));
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        PrivateKey privateKey = kf.generatePrivate(spec);

        CMSProcessableByteArray msg = new CMSProcessableByteArray(""My message"".getBytes());
        CMSSignedDataGenerator sGen = new CMSSignedDataGenerator();

        ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(privateKey);
        sGen.addSignerInfoGenerator(
                new JcaSignerInfoGeneratorBuilder(
                        new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                ).build(sha1Signer, cert)
        );

        CMSSignedData sd = sGen.generate(msg);

        CMSTypedData cmsBytes = new CMSProcessableByteArray(sd.getEncoded());
        // How to reconstruct a CMSSignedData from cmsBytes again?
        byte[] bytes = (byte[]) cmsBytes.getContent();
        CMSSignedData retrieved = new CMSSignedData(bytes);
        System.out.println(retrieved.getSignedContent()); // Doesn't work, is null
    }
}
</code></pre>

<p>My question is how to retrieve the original <code>CMSSignedData</code> (wanting to read the original message, and verify it), using only the byte array of the ASN.1 encoding of this object.</p>

<p>The reason I am asking this, is that I want to decrypt a certain encrypted and signed message. I am able to decrypt this message, but it results in an ASN.1 encoded byte array (which does correspond to my original message), but I am not able to process this decrypted message any further.</p>
","<p>You can use the classes <code>org.bouncycastle.asn1.cms.ContentInfo</code> and <code>org.bouncycastle.asn1.ASN1Sequence</code>:</p>

<pre><code>CMSTypedData cmsBytes = new CMSProcessableByteArray(sd.getEncoded());
byte[] bytes = (byte[]) cmsBytes.getContent();

// reconstruct CMSSignedData from the byte array
ContentInfo ci = ContentInfo.getInstance(ASN1Sequence.fromByteArray(bytes));
CMSSignedData sig = new CMSSignedData(ci);
</code></pre>

<p>Also note that you must create a <code>CMSSignedData</code> with the content encapsulated in the signature, so you must change this:</p>

<pre><code>CMSSignedData sd = sGen.generate(msg);
</code></pre>

<p>To this:</p>

<pre><code>CMSSignedData sd = sGen.generate(msg, true);
</code></pre>
","708","<java><bouncycastle><asn.1><pkcs#7>","1","0","1","2017-06-22 18:41:23","44704741","0","","","user7605325","2017-06-22 16:07:52","2017-06-22 15:56:30",""
"38614963","Delete the digitally signed signature from pdf","<p>i have used an itextsharp tool to sign the pdf with digital signature. I need to know the possibility way of detaching the old signature from the pdf which is signed previously and the same file need to be signed with the new digital signature. I would like to get the response ASAP.</p>
","","700","<c#><asp.net><itext><pkcs#7>","0","","0","2016-07-28 03:45:46","","6","1","5658312","","2016-07-28 03:45:46","2016-07-27 13:53:28",""
"43579744","Extra data when convert PKCS7 to PEM certificate","<p>I converted a PEM certificate in PEM format to PKCS7 format, now I
am following <a href=""https://www.sslshopper.com/ssl-converter.html"" rel=""nofollow noreferrer"">here</a> to convert back a PKCS7 (P7B) certificate file to PEM format. The result PEM file have content similar with the original PEM file, but its has an extra part of text as the begin.
The command is:</p>

<pre><code>openssl pkcs7 -print_certs -in certificate.p7b -out certificate.cer
</code></pre>

<p>The output file (certificate.cer) contain an extra part of data <strong>before</strong> the ""<strong>-----BEGIN CERTIFICATION-----</strong>"", like below:
The first two lines: subject and issuer are the extra lines.</p>

<blockquote>
  <p>subject=/C=VN/ST=HN/L=H/O=MyCompany/OU=MyCompany/CN=192.168.5.113</p>
  
  <p>issuer=/C=VN/ST=HN/O=MyCompany/OU=MyCompany Certificate
  Authority/CN=MyCompany Intermediate CA</p>
  
  <p>-----BEGIN CERTIFICATE-----</p>
  
  <p>MIIFwzCCA6ugAwIBAgICEBQwDQYJKoZIhvcNAQELBQAwgYMxCzAJBgNVBAYTAlZO
  
  MIGHMQswCQYDVQQGEwJWTjEMMAoGA1UECAwDVFRIMQowCAYDVQQHDAFIMRQwEgYD</p>
  
  <p>VQQKDAtWaWVncmlkIEpTQzEqMCgGA1UECwwhVmllZ3JpZCBKU0MgQ2VydGlmaWNh</p>
  
  <p>dGUgQXV0aG9yaXR5MRwwGgYDVQQDDBNWaWVncmlkIEpTQyBSb290IENBggIQAjAO</p>
  
  <p>BgNVHQ8BAf8EBAMCBaAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQEL</p>
  
  <p>BQADggIBAIrU8AyCq2OQzQaAzZeSJMrNCZg8/pukQcRhdOP+Gg9uIPFU+Sgjodt/</p>
  
  <p>vxczipxZii+qUOk7GGISvVRNFioSojVm8nawI0j5YvXss3+Zilwo7iqWP71NtO8u</p>
  
  <p>HGsk5GloCKO8cwbk9jQ1YrGXBi2829w1bJZBP1fuspgcdgDcDP0++IXdnYfyZ0eQ</p>
  
  <p>dQ/nwF4EaL2mP6kbZ24pqxem5DBwd3bvP3TMsyboVgKEnFGFZHIQ36y/wIjWp2xn</p>
  
  <p>CSWgi6byohaE6DmSMQ4yzCio38sgQ3fDM3VHnY81AijpFzCeBsIMhQJ9FF8SK+AL</p>
  
  <p>u2IaPU5+8XsPyIR6fsuwvuALa7a97gbP3mDoQKwUoIBOmh56cOoJDPj/+pbfg43i</p>
  
  <p>IJIXqk6/1ppxWhYS4/CtHBPas6bbcvQISif5WmEFV+kXmyXitmNCXOS9JSiinlBD</p>
  
  <p>8lvggpzczqa8fOACIipdJ4zdh4a+lUKrAno+sdy+PDGUpmnG5VLdNNBRoYqovTe1</p>
  
  <p>fUcBZxRqVwO1ebZeBpJbQemw1CF/UzQgy1WixddSz/QNTbA821Ym/8OqoaUhy+PS</p>
  
  <p>idzOIV10iVXP6AOU8chPPnAZmXBgRbibHn8GrjrjXT0ll8YeysBlrmmre2CtY47V</p>
  
  <p>L9u++VhNjqBAht/gZnXS8GfGOkN9vNIFTu0MbWn4rrhJrr+tz09t</p>
  
  <p>-----END CERTIFICATE-----</p>
</blockquote>

<p>I want to omit this part when converting, tried with parameters like -noout, -text but nothing works. How can I do it?</p>
","<p>After Googling, I found the solution here:
<a href=""https://www.bo.infn.it/alice/introgrd/certmgr/node20.html"" rel=""nofollow noreferrer"">https://www.bo.infn.it/alice/introgrd/certmgr/node20.html</a></p>

<p>The ""extra part"" is ""bag attributes"". It can be removed by:</p>

<pre><code>openssl x509 -in cert.pem -out certout.pem 
</code></pre>
","670","<openssl><converter><pem><pkcs#7>","0","1","1","2017-04-24 07:31:38","","1","","","","","2017-04-24 04:18:18",""
"20704464","Parsing PKCS10 from PKCS7 in PHP","<p>Background: I'm implementing an MDM solution for WP8, on initial enrolment, the binary security token is a base 64 encoded PKCS10 CSR.  On certificate renewal, the soap request is exactly the same, only the token type specified is ""Renew"" and the binary security token is a base 64 encoded PKCS7.</p>

<p>I am trying to obtain a PKCS10 from a PKCS7 base64 encoded string - I've tried openssl_pkcs7_verify which takes a filename for content. I'm assuming the content that is written contains the CSR.  However, I cannot get this function to succeed and eventually resorted to the following which works - </p>

<pre><code>private function parsePKCS10( $insb64PKCS7 ) {
    $decodedPKCS7 = base64_decode( $insb64PKCS7 );

    $buffer = """";
    $b64PKCS10 = """";
    $lengthPKCS7 = strlen( $decodedPKCS7 );
    for ( $i = 0; $i &lt; $lengthPKCS7; ++$i ) {
        $currentChar = $decodedPKCS7[ $i ];
        if ( mb_detect_encoding( $currentChar ) == ""ASCII"" &amp;&amp; strlen( $currentChar ) != 0 ) {
            $buffer .= $currentChar;
        } else if ( (strlen( $currentChar ) != 0) || ($i + 1 &lt; $lengthPKCS7 &amp;&amp; strlen( $decodedPKCS7[ $i + 1 ] ) == 0) ) {
            if ( strlen( $buffer ) &gt; strlen( $b64PKCS10 ) ) {
                $b64PKCS10 = $buffer;
            }
            $buffer = """";
        }
    }

    return preg_replace( '/[\x00-\x1F\x80-\xFF]/', '', $b64PKCS10 ); //remove non-printable chars
}
</code></pre>

<p>I found an example online doing this in C# - </p>

<pre><code>private static string extractPKCS10(string PKCS7blob)
        {
            SignedCms cms = new SignedCms();
            cms.Decode(System.Convert.FromBase64String(PKCS7blob));
            byte[] csr = cms.ContentInfo.Content;

            return Encoding.Unicode.GetString(csr);
        }
</code></pre>

<p>Does anyone know a better way of doing this in PHP, or should I stick with my current function which does the job?</p>

<p>Thanks</p>

<p>EDIT - </p>

<p>I found a better solution using PHPSecLib - </p>

<pre><code>$asn1 = new File_ASN1();
$certDump = $asn1-&gt;decodeBER( base64_decode( $cert ) );
$csr = extractPKCS10( $certDump );
print( $csr );


function extractPKCS10( $pkcs7, $parent = null ){

    $pkcs7DataOID = '1.2.840.113549.1.7.1';

    foreach( $pkcs7 as $key =&gt; $value ){
        if( $key == 'content' &amp;&amp; $value == $pkcs7DataOID ){
            $csrBlob = $parent[1]['content'][0]['content'];
            return base64_encode( $csrBlob );
        }

        if( is_array( $value ) ){
            $pkcs10 = extractPKCS10( $value, $pkcs7 );
            if( null !== $pkcs10 ){
                return $pkcs10;
            }
        }
    }

    return null;
}
</code></pre>
","","667","<php><windows-phone-8><mdm><phpseclib><pkcs#7>","1","","0","2014-04-24 09:48:04","","0","","2822540","","2014-04-24 09:48:04","2013-12-20 13:14:50",""
"8120329","Can I convert a Rawsignature to PKCS#7 in xcode using Openssl","<p>I could susscessfuly genearte pkcs7 signature using PEM(private key)file in Openssl.
But, how do I convert a RAWsignature generated using security.framework to pkcs7 using Openssl.</p>

<p>Edit: 
load data > load PEM(private key)file > generate pkcs7 data using Openssl ....this is successfull</p>

<p>but</p>

<p>Load private key (SecKeyRef) from keychian > (how to pass this key to OPenssl to generate Pkcs7)?</p>
","<p>IOS doesnt have feature to generate PKCS#7 Signature. We have to use OpenSSL with no other Alternative I suppose.</p>

<p>And IOS protects the keys using KEYCHAIN it provides. So the SecKeyRef is only a readable and not transferable. Better dont ever try to write to some file or transport it. </p>

<p>IOS features can generate only PKCS#1 Singnatures.</p>

<p>And if the RAWSignature is genereated using a PKCS#12 file, PKCS#7 singature can be generated out of it, using Bouncy Castle...server side....</p>

<p>did it... and it works... :)</p>
","659","<iphone><openssl><pkcs#7>","0","0","1","2012-04-05 15:33:09","10031586","0","","999118","","2011-11-14 12:38:15","2011-11-14 10:37:00",""
"43945101","Decode string with PKC7 in Java","<p>I have some <code>Java</code> code, and I have a <code>String</code> type which includes the following content:</p>

<pre><code>-----BEGIN PKCS7-----
MIIIzwYJKoZIhvcNAQcCoIIIwDCCCLwCAQExDzANBglghkgBZQMEAgEFADALBgkq
hkiG9w0BBwGgggZbMIIGVzCCBT+gAwIBAgIELhJ2QDANBgkqhkiG9w0BAQUFADCB
mDELMAkGA1UEBhMCREUxEDAOBgNVBAoMB1NpZW1lbnMxETAPBgNVBAUTCFpaWlpa
WlkyMTowOAYDVQQLDDFDb3B5cmlnaHQgKEMpIFNpZW1lbnMgQUcgMjAxMyBBbGwg
UmlnaHRzIFJlc2VydmVkMSgwJgYDVQQDDB9TaWVtZW5zIElzc3VpbmcgQ0EgRUUg
QXV0aCAyMDEzMB4XDTE0MDcxODEzNTcwM1oXDTE3MDcxODEzNTcwM1owYzERMA8G
A1UEBRMIWjAwMzBBTUgxDzANBgNVBCoMBkFsZXhleTERMA8GA1UEBAwIU2Vkb3lr
aW4xEDAOBgNVBAoMB1NpZW1lbnMxGDAWBgNVBAMMD1NlZG95a2luIEFsZXhleTCC
ASAwCwYJKoZIhvcNAQEBA4IBDwAwggEKAoIBAQCKahNgWzDPSnOwba2ljWQb8Lni
uvAGZHEvdd5zm8H7Kw56WMxdixKHoKSChXWf1zGE3RZAsQOdHOpcgiqnRF2xLe2l
LjCLoE9sC4DfUVD4mKe3kcxtnsxkoLc1A/3QXJSOzpk7rPJeqehmuj06yCtPjpdF
Gmtf4bkskiQuK8u4RJfnmzffWQppd2Ld+u8tLxQKyHnZtOnPyYQGRQJXJKhruDnn
LonlveVXKzEzmo88E5udB+/6jDWDfuyfKHMFyOhk80qGeYDOYQHxiq/PJbAyQU6X
PONbfsCgILKxx7uHaBlhNALxjFZSeNNtfg0bx82O1DoJEcWcOjZQtQMuNUjvAgMB
AAGjggLdMIIC2TAdBgNVHQ4EFgQUE5jDSnfWWnlUWMKztQ6zYfgohUkwUwYDVR0R
BEwwSqArBgorBgEEAYI3FAIDoB0MG2FsZXhleS5zZWRveWtpbkBzaWVtZW5zLmNv
bYEbYWxleGV5LnNlZG95a2luQHNpZW1lbnMuY29tMA4GA1UdDwEB/wQEAwIHgDCC
AQQGCCsGAQUFBwEBBIH3MIH0MDIGCCsGAQUFBzAChiZodHRwOi8vYWguc2llbWVu
cy5jb20vcGtpP1paWlpaWlkyLmNydDBBBggrBgEFBQcwAoY1bGRhcDovL2FsLnNp
ZW1lbnMubmV0L0NOPVpaWlpaWlkyLEw9UEtJP2NBQ2VydGlmaWNhdGUwSQYIKwYB
BQUHMAKGPWxkYXA6Ly9hbC5zaWVtZW5zLmNvbS9DTj1aWlpaWlpZMixvPVRydXN0
Y2VudGVyP2NBQ2VydGlmaWNhdGUwMAYIKwYBBQUHMAGGJGh0dHA6Ly9vY3NwLnBr
aS1zZXJ2aWNlcy5zaWVtZW5zLmNvbTAfBgNVHSMEGDAWgBTelD9Lal9YThQYyUbX
FDnCnCE8KTAMBgNVHRMBAf8EAjAAMBoGA1UdIAQTMBEwDwYNKwYBBAGhaQcCAgMB
ATCBygYDVR0fBIHCMIG/MIG8oIG5oIG2hiZodHRwOi8vY2guc2llbWVucy5jb20v
cGtpP1paWlpaWlkyLmNybIZBbGRhcDovL2NsLnNpZW1lbnMubmV0L0NOPVpaWlpa
WlkyLEw9UEtJP2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3SGSWxkYXA6Ly9jbC5z
aWVtZW5zLmNvbS9DTj1aWlpaWlpZMixvPVRydXN0Y2VudGVyP2NlcnRpZmljYXRl
UmV2b2NhdGlvbkxpc3QwMwYDVR0lBCwwKgYIKwYBBQUHAwIGCCsGAQUFBwMEBgor
BgEEAYI3FAICBggrBgEFBQgCAjANBgkqhkiG9w0BAQUFAAOCAQEAmzrYxmkRuSPM
itK0rnR98BXlnB88ldVXjyz+rjHg9QghoZ5+8u7wHnxMSXida4XvYbhN5maUQs3D
dWebvXP6CXt/OErVgYHlEAT8d5iqvin7/6eEgS0ge9DOxD2Rv+LYltPmAsjgxUS/
0MecbUJpyBct6mDNfPI7riCu+mCcw6v9OKLWnXTIZsV9Z/WqaFbqVeJ5wo1+MUGW
CGrDVkn7XnCKAQN8xEEO+Dq/TSVyv8tlDUzWps1yb3l9cYDc030s5AwFXa99v76p
YJUZ08qQsieXOrs3qyQxMalM/Y042N17bwf9XkGT6iKN8o8U0YS1Vkaz8iroBRKk
iA2pRNN4AjGCAjgwggI0AgEBMIGhMIGYMQswCQYDVQQGEwJERTEQMA4GA1UECgwH
U2llbWVuczERMA8GA1UEBRMIWlpaWlpaWTIxOjA4BgNVBAsMMUNvcHlyaWdodCAo
QykgU2llbWVucyBBRyAyMDEzIEFsbCBSaWdodHMgUmVzZXJ2ZWQxKDAmBgNVBAMM
H1NpZW1lbnMgSXNzdWluZyBDQSBFRSBBdXRoIDIwMTMCBC4SdkAwDQYJYIZIAWUD
BAIBBQCgaTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEP
Fw0xNzA1MDMxNDI3NTFaMC8GCSqGSIb3DQEJBDEiBCBCA/fR9wGftKzKFZRuIDJV
bYiaHzsDteoUoUL55kMrYDANBgkqhkiG9w0BAQEFAASCAQA6HtP3xr36VLj+WMao
PRrszLfMJTE7lKIX3Vjybj2W3yj4qanPamZBb4KyEDIvQA8r65j4dbzcDePoFsRB
5eYRnfB/djuXPAZdL9xdFMH3iRzfcseSFXulZ8FrG/9cuqDQkYVIx/Fk43yLtlpx
OncVG3vZVW306yKQLu7Tsy+/GEkNDBMt6akqNPWp+9zqQTj7TaCXg7qr7mTlSStZ
E15USoAOelisALpwPdizvfaJOqP03IobwDXMfRaCjzEANVl/M3woL1sNLu6BtuMe
mAdls8tnJWDF+wpD4Y256Dso4FvDe2iK923jNElzq4iyc6ZosqGORS3nTh/1FQyp
gkC1
-----END PKCS7-----
</code></pre>

<p>How can I convert this <code>String</code> into a readable state? </p>

<p>So far, I've used the following website just to test: <a href=""https://certlogik.com/decoder/"" rel=""nofollow noreferrer"">https://certlogik.com/decoder/</a></p>
","<p>Well, even if you never posted an approach showing us what you've tried before for achieving your task and even if you said that you are not a programmer <em>(I wonder how are you going to understand then).</em></p>

<p>I wanted to play around with this and this is what I got so far...</p>

<hr>

<h2>Notes</h2>

<p>Since you are new to this, consider the following:</p>

<ul>
<li>Use <strong><em>bouncycastle</em></strong> library within your project, include the <code>bcprov-jdk16-1.46.jar</code> file to the Build Path.</li>
<li>In order to use <strong><em>bouncycastle</em></strong> library, you'll need the ""Java Cryptography Extension"" JARs and, in order to do so, replace the <code>local_policy.jar</code> and <code>US_export_policy.jar</code> files located at <code>C:\path\to\Java\jdk1.7.0_79\jre\lib\security</code> with the ones from here: <a href=""http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html"" rel=""nofollow noreferrer"">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a> </li>
</ul>

<p><em>(the link will download a ZIP file with the JARs for Java 7 since I am using that version, you should download the right ones for the Java version that you are using)</em>.</p>

<h2>Project structure</h2>

<p>Just created a simple Java Project and defined this structure:</p>

<p><a href=""https://i.stack.imgur.com/nGVR6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nGVR6.png"" alt=""enter image description here""></a></p>

<h2>Java code</h2>

<p>Things to consider...</p>

<ul>
<li><p>There are many attributes to obtain from the certificate and getting some of them are a bit tricky (you'll need to do some research here in order to get them all, same way as: <a href=""https://certlogik.com/decoder/"" rel=""nofollow noreferrer"">https://certlogik.com/decoder/</a> currently does).</p></li>
<li><p>I've changed the header/footer: <code>BEGIN PKCS7/END PKCS7</code> from the certificate, because of the following: <a href=""http://openssl.cs.utah.edu/docs/apps/pkcs7.html"" rel=""nofollow noreferrer"">http://openssl.cs.utah.edu/docs/apps/pkcs7.html</a> (read under ""Notes"" section) and because the certificate <code>String</code> can't be parsed as a <code>X509Certificate</code> object when not using the other ones, which are: <code>BEGIN CERTIFICATE/END CERTIFICATE</code>. Also, something that I noticed was that after decoding the certificate on the website that you provided, the <code>BEGIN PKCS7/END PKCS7</code> header/footer are replaced in your certificate <code>String</code> with the other ones that I was talking about before.</p></li>
</ul>

<p>Obtained from above link:</p>

<blockquote>
  <p>The PEM PKCS#7 format uses the header and footer lines:</p>
  
  <p>-----BEGIN PKCS7-----<br>
   -----END PKCS7-----</p>
  
  <p>For compatibility with some CAs it will also accept:</p>
  
  <p>-----BEGIN CERTIFICATE-----<br>
   -----END CERTIFICATE-----</p>
</blockquote>

<p>Then, here goes the runnable Java class:</p>

<pre><code>package com.cert.example.main;

import java.io.IOException;
import java.io.StringReader;
import java.security.Security;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPublicKey;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMReader;

public class CertificateDecoder {

    public static void main(String[] args) throws IOException {

        String certStr = ""-----BEGIN CERTIFICATE-----\r\n"" + 
                ""MIIIzwYJKoZIhvcNAQcCoIIIwDCCCLwCAQExDzANBglghkgBZQMEAgEFADALBgkq\r\n"" + 
                ""hkiG9w0BBwGgggZbMIIGVzCCBT+gAwIBAgIELhJ2QDANBgkqhkiG9w0BAQUFADCB\r\n"" + 
                ""mDELMAkGA1UEBhMCREUxEDAOBgNVBAoMB1NpZW1lbnMxETAPBgNVBAUTCFpaWlpa\r\n"" + 
                ""WlkyMTowOAYDVQQLDDFDb3B5cmlnaHQgKEMpIFNpZW1lbnMgQUcgMjAxMyBBbGwg\r\n"" + 
                ""UmlnaHRzIFJlc2VydmVkMSgwJgYDVQQDDB9TaWVtZW5zIElzc3VpbmcgQ0EgRUUg\r\n"" + 
                ""QXV0aCAyMDEzMB4XDTE0MDcxODEzNTcwM1oXDTE3MDcxODEzNTcwM1owYzERMA8G\r\n"" + 
                ""A1UEBRMIWjAwMzBBTUgxDzANBgNVBCoMBkFsZXhleTERMA8GA1UEBAwIU2Vkb3lr\r\n"" + 
                ""aW4xEDAOBgNVBAoMB1NpZW1lbnMxGDAWBgNVBAMMD1NlZG95a2luIEFsZXhleTCC\r\n"" + 
                ""ASAwCwYJKoZIhvcNAQEBA4IBDwAwggEKAoIBAQCKahNgWzDPSnOwba2ljWQb8Lni\r\n"" + 
                ""uvAGZHEvdd5zm8H7Kw56WMxdixKHoKSChXWf1zGE3RZAsQOdHOpcgiqnRF2xLe2l\r\n"" + 
                ""LjCLoE9sC4DfUVD4mKe3kcxtnsxkoLc1A/3QXJSOzpk7rPJeqehmuj06yCtPjpdF\r\n"" + 
                ""Gmtf4bkskiQuK8u4RJfnmzffWQppd2Ld+u8tLxQKyHnZtOnPyYQGRQJXJKhruDnn\r\n"" + 
                ""LonlveVXKzEzmo88E5udB+/6jDWDfuyfKHMFyOhk80qGeYDOYQHxiq/PJbAyQU6X\r\n"" + 
                ""PONbfsCgILKxx7uHaBlhNALxjFZSeNNtfg0bx82O1DoJEcWcOjZQtQMuNUjvAgMB\r\n"" + 
                ""AAGjggLdMIIC2TAdBgNVHQ4EFgQUE5jDSnfWWnlUWMKztQ6zYfgohUkwUwYDVR0R\r\n"" + 
                ""BEwwSqArBgorBgEEAYI3FAIDoB0MG2FsZXhleS5zZWRveWtpbkBzaWVtZW5zLmNv\r\n"" + 
                ""bYEbYWxleGV5LnNlZG95a2luQHNpZW1lbnMuY29tMA4GA1UdDwEB/wQEAwIHgDCC\r\n"" + 
                ""AQQGCCsGAQUFBwEBBIH3MIH0MDIGCCsGAQUFBzAChiZodHRwOi8vYWguc2llbWVu\r\n"" + 
                ""cy5jb20vcGtpP1paWlpaWlkyLmNydDBBBggrBgEFBQcwAoY1bGRhcDovL2FsLnNp\r\n"" + 
                ""ZW1lbnMubmV0L0NOPVpaWlpaWlkyLEw9UEtJP2NBQ2VydGlmaWNhdGUwSQYIKwYB\r\n"" + 
                ""BQUHMAKGPWxkYXA6Ly9hbC5zaWVtZW5zLmNvbS9DTj1aWlpaWlpZMixvPVRydXN0\r\n"" + 
                ""Y2VudGVyP2NBQ2VydGlmaWNhdGUwMAYIKwYBBQUHMAGGJGh0dHA6Ly9vY3NwLnBr\r\n"" + 
                ""aS1zZXJ2aWNlcy5zaWVtZW5zLmNvbTAfBgNVHSMEGDAWgBTelD9Lal9YThQYyUbX\r\n"" + 
                ""FDnCnCE8KTAMBgNVHRMBAf8EAjAAMBoGA1UdIAQTMBEwDwYNKwYBBAGhaQcCAgMB\r\n"" + 
                ""ATCBygYDVR0fBIHCMIG/MIG8oIG5oIG2hiZodHRwOi8vY2guc2llbWVucy5jb20v\r\n"" + 
                ""cGtpP1paWlpaWlkyLmNybIZBbGRhcDovL2NsLnNpZW1lbnMubmV0L0NOPVpaWlpa\r\n"" + 
                ""WlkyLEw9UEtJP2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3SGSWxkYXA6Ly9jbC5z\r\n"" + 
                ""aWVtZW5zLmNvbS9DTj1aWlpaWlpZMixvPVRydXN0Y2VudGVyP2NlcnRpZmljYXRl\r\n"" + 
                ""UmV2b2NhdGlvbkxpc3QwMwYDVR0lBCwwKgYIKwYBBQUHAwIGCCsGAQUFBwMEBgor\r\n"" + 
                ""BgEEAYI3FAICBggrBgEFBQgCAjANBgkqhkiG9w0BAQUFAAOCAQEAmzrYxmkRuSPM\r\n"" + 
                ""itK0rnR98BXlnB88ldVXjyz+rjHg9QghoZ5+8u7wHnxMSXida4XvYbhN5maUQs3D\r\n"" + 
                ""dWebvXP6CXt/OErVgYHlEAT8d5iqvin7/6eEgS0ge9DOxD2Rv+LYltPmAsjgxUS/\r\n"" + 
                ""0MecbUJpyBct6mDNfPI7riCu+mCcw6v9OKLWnXTIZsV9Z/WqaFbqVeJ5wo1+MUGW\r\n"" + 
                ""CGrDVkn7XnCKAQN8xEEO+Dq/TSVyv8tlDUzWps1yb3l9cYDc030s5AwFXa99v76p\r\n"" + 
                ""YJUZ08qQsieXOrs3qyQxMalM/Y042N17bwf9XkGT6iKN8o8U0YS1Vkaz8iroBRKk\r\n"" + 
                ""iA2pRNN4AjGCAjgwggI0AgEBMIGhMIGYMQswCQYDVQQGEwJERTEQMA4GA1UECgwH\r\n"" + 
                ""U2llbWVuczERMA8GA1UEBRMIWlpaWlpaWTIxOjA4BgNVBAsMMUNvcHlyaWdodCAo\r\n"" + 
                ""QykgU2llbWVucyBBRyAyMDEzIEFsbCBSaWdodHMgUmVzZXJ2ZWQxKDAmBgNVBAMM\r\n"" + 
                ""H1NpZW1lbnMgSXNzdWluZyBDQSBFRSBBdXRoIDIwMTMCBC4SdkAwDQYJYIZIAWUD\r\n"" + 
                ""BAIBBQCgaTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEP\r\n"" + 
                ""Fw0xNzA1MDMxNDI3NTFaMC8GCSqGSIb3DQEJBDEiBCBCA/fR9wGftKzKFZRuIDJV\r\n"" + 
                ""bYiaHzsDteoUoUL55kMrYDANBgkqhkiG9w0BAQEFAASCAQA6HtP3xr36VLj+WMao\r\n"" + 
                ""PRrszLfMJTE7lKIX3Vjybj2W3yj4qanPamZBb4KyEDIvQA8r65j4dbzcDePoFsRB\r\n"" + 
                ""5eYRnfB/djuXPAZdL9xdFMH3iRzfcseSFXulZ8FrG/9cuqDQkYVIx/Fk43yLtlpx\r\n"" + 
                ""OncVG3vZVW306yKQLu7Tsy+/GEkNDBMt6akqNPWp+9zqQTj7TaCXg7qr7mTlSStZ\r\n"" + 
                ""E15USoAOelisALpwPdizvfaJOqP03IobwDXMfRaCjzEANVl/M3woL1sNLu6BtuMe\r\n"" + 
                ""mAdls8tnJWDF+wpD4Y256Dso4FvDe2iK923jNElzq4iyc6ZosqGORS3nTh/1FQyp\r\n"" + 
                ""gkC1\r\n"" + 
                ""-----END CERTIFICATE-----"";

        // Init bouncycastle
        Security.addProvider(new BouncyCastleProvider());

        // Get certificate
        StringReader sr = new StringReader(certStr);
        PEMReader pr = new PEMReader(sr);
        X509Certificate cert = (X509Certificate)pr.readObject();
        pr.close();

        // Get Public Key as RSA in order to get extra attributes
        RSAPublicKey rsaPublicKey = (RSAPublicKey)cert.getPublicKey();

        System.out.println(printCertInfo(cert, rsaPublicKey));
    }

    static String printCertInfo(X509Certificate cert, RSAPublicKey rsaPublicKey) {
        StringBuilder sb = new StringBuilder();

        sb.append(""Certificate:\r\n"");
        sb.append(""Data:\r\n"");
        sb.append(""\tVersion: "" + cert.getVersion() + ""\r\n"");
        sb.append(""\tSerial Number: "" + cert.getSerialNumber() + ""\r\n"");
        sb.append(""\tSignature Algorithm: "" + cert.getSigAlgName() + ""\r\n"");
        sb.append(""\tIssuer: "" + cert.getIssuerDN().getName() + ""\r\n"");
        sb.append(""\tSignature Algorithm: "" + cert.getSigAlgName() + ""\r\n"");
        sb.append(""\tValidity\r\n"");
        sb.append(""\t\tNot Before: "" + cert.getNotBefore() + ""\r\n"");
        sb.append(""\t\tNot After: "" + cert.getNotAfter() + ""\r\n"");
        sb.append(""\tSubject: "" + cert.getSubjectDN() + ""\r\n"");
        sb.append(""\tSubject Public Key Info:\r\n"");
        sb.append(""\t\tPublic Key Algorithm: "" + rsaPublicKey.getAlgorithm() + ""\r\n"");
        sb.append(""\t\t\tPublic-Key: "" + rsaPublicKey.getModulus().bitLength() + "" bit \r\n"");
        sb.append(""\t\t\tModulus:\r\n"");
        sb.append(""\t\t\t\t"" + rsaPublicKey.getModulus().toString(16) + ""\r\n"");
        sb.append(""\t\t\tExponent: "" + rsaPublicKey.getPublicExponent() + ""\r\n"");

        // TODO: Print other attributes, do some research to get them all...

        return sb.toString();
    }

}
</code></pre>

<h2>Output</h2>

<p>If I get the time, I'll try to get all the attributes, same way as the website that you provided does. Right now, the code from above will output the following:</p>

<pre><code>Certificate:
Data:
    Version: 3
    Serial Number: 772961856
    Signature Algorithm: SHA1WithRSAEncryption
    Issuer: C=DE,O=Siemens,SERIALNUMBER=ZZZZZZY2,OU=Copyright (C) Siemens AG 2013 All Rights Reserved,CN=Siemens Issuing CA EE Auth 2013
    Signature Algorithm: SHA1WithRSAEncryption
    Validity
        Not Before: Fri Jul 18 09:57:03 EDT 2014
        Not After: Tue Jul 18 09:57:03 EDT 2017
    Subject: SERIALNUMBER=Z0030AMH,GIVENNAME=Alexey,SURNAME=Sedoykin,O=Siemens,CN=Sedoykin Alexey
    Subject Public Key Info:
        Public Key Algorithm: RSA
            Public-Key: 2048 bit 
            Modulus:
                8a6a13605b30cf4a73b06dada58d641bf0b9e2baf00664712f75de739bc1fb2b0e7a58cc5d8b1287a0a48285759fd73184dd1640b1039d1cea5c822aa7445db12deda52e308ba04f6c0b80df5150f898a7b791cc6d9ecc64a0b73503fdd05c948ece993bacf25ea9e866ba3d3ac82b4f8e97451a6b5fe1b92c92242e2bcbb84497e79b37df590a697762ddfaef2d2f140ac879d9b4e9cfc9840645025724a86bb839e72e89e5bde5572b31339a8f3c139b9d07effa8c35837eec9f287305c8e864f34a867980ce6101f18aafcf25b032414e973ce35b7ec0a020b2b1c7bb876819613402f18c565278d36d7e0d1bc7cd8ed43a0911c59c3a3650b5032e3548ef
            Exponent: 65537
</code></pre>
","650","<java><string><decode><pkcs#7>","0","0","1","2017-05-13 01:10:28","43948175","5","","1178686","","2017-05-13 01:05:42","2017-05-12 19:25:06",""
"45278296","Convert PEM to PKCS7 (Java)","<p>I have a List of Byte arrays (representing each certificate from a chain), in PEM format, and I would like to know if there's a way to convert these to a unique PKCS7 formatted String, in Java.</p>

<p>Thank you in advance.</p>
","<p>This is an example to build a PKCS#7 file using a <code>X509Certificate[]</code> array based on this <a href=""https://stackoverflow.com/a/29671316/6371459"">answer</a>. It does not require the private key</p>

<pre><code>//Export a certificate list to PKCS#7
public static byte[] exportCertificatesAsPkcs7(X509Certificate certs[]) throws Exception {

    List certList = new ArrayList();
    for (X509Certificate certificate: certs){
        certList.add(new X509CertificateHolder(certificate.getEncoded()));
    }
    Store certStore = new JcaCertStore(certList);

    CMSProcessableByteArray msg = new CMSProcessableByteArray(""Hello World"".getBytes());
    CMSSignedDataGenerator    gen = new CMSSignedDataGenerator(); 
    gen.addCertificates(certStore);
    CMSSignedData data = gen.generate(msg, ""BC""); 
    return data.getEncoded();

}
</code></pre>
","643","<java><certificate><pem><pkcs#7>","1","2","1","2017-07-24 13:03:45","45281402","5","","","","","2017-07-24 10:33:32",""
"40685111","Why OpenSSL's PKCS7_verify() requires ""smimesign"" certificate purpose?","<p>Man page for <code>PKCS7_verify()</code> states that</p>

<p><code>...Each signer's certificate is chain verified using the smimesign purpose...
</code></p>

<p>Why is exactly this one purpose always required? I understand it so that a signed PKCS7 structure can be used for many things, S/MIME being just one of them.</p>

<p>If my signing certificate does not have <code>smimeSign</code> among its <code>extendedKeyUsage</code> extensions, <code>PKCS7_verify()</code> fails. I'd need to manually adjust the <code>purpose</code> in order to do the verification. Am I missing something here?</p>
","<p>Simply verifying the signature, checking that the signer's certificate is authentic and that the chain leads to a trusted root is not enough. Any verification code also must ensure that the certificate holder was entitled to perform the signing for the particular purpose. The vetting to get a certificate that has <code>smimeSign</code> privilege is a lot less stringent than the vetting for, say a code signing certificate.</p>

<p>Imagine a software development company where every employee has been issued a certificate for the purpose of email signing and encryption. This company also releases a software product, and provides a PKCS#7 signed distribution package of its product. If PKCS#7 verification functions did not check the purpose of the signing certificate (in this case we'd want <code>codesign</code>), a bad actor in the employ of the company could create a compromised version of the software product, and sign it with their E-Mail certificate (which only has the purpose <code>smimesign</code>.) </p>

<p>In the case of OpenSSL's <code>pkcs7_verify()</code>, the API was designed to imply a purpose instead of explicitly requiring one to be passed in, and <code>smimeSign</code> was chosen as default. I'm guessing that since S/MIME is the most common use of PKCS#7, it made sense, and it allows someone to verify PKCS#7 in most use cases without having to learn about <code>extendedKeyUsage</code>.</p>

<p>[Below my original answer, to address your pre-edit question '<em>Can I specify that I want to verify a signature in a PKCS7 against some other purpose'</em>:]</p>

<p>A certificate can contain an (optional) attribute called ""Extended Key Usage"". This attribute is used to indicate what the certificate is allowed to be used for. Some possible X509.v3 usages are:</p>

<ul>
<li>serverAuthentication</li>
<li>clientAuthentication</li>
<li>codeSigning</li>
<li>emailProtection</li>
<li>ipSecEndSystem</li>
<li>ipSecTunnel</li>
<li>timeStamping</li>
<li>ocspSigning</li>
<li>smartCardLogin</li>
<li>pkiPeerAuth</li>
</ul>

<p>You can check the <a href=""https://www.openssl.org/docs/man1.0.1/apps/x509v3_config.html"" rel=""nofollow noreferrer"">x509v3_config</a> man page for the key usage flags that openssl is aware of.</p>

<p>PKCS#7 is a general container format that allows for both signing and or encrypting the content of the container. S/MIME uses PKCS#7 for signing and/or encrypting email message, and in that case, the certificate being used should have the emailProtection usage.</p>

<p>If you wanted to distribute some code, and you want to make sure that the recipient can verify that the distribution is from you, and unaltered, you could use PKCS#7 to distribute, and in that case your certificate should have the codeSigning enhanced key usage attribute.
It is possible for a certificate to have multiple key usages, but in general it's a good idea to have a separate key (and therefore certificate) for different usage types.</p>

<p>Openssl, on the command line, supports specifying the desired purpose of the certificate when using the ""openssl smime"" command. For example,</p>

<pre><code>    openssl smime -verify -in myfile.p7b -inform DER -out my-p7-content -purpose any
</code></pre>

<p>will verify the signature in the file 'my file.p7p', it will write the content of the PKCS#7 container in file 'my-p7-content' and it will accept any valid certificate, no matter what its indicated purpose is. (-purpose any). Please note that the openssl man page for smime does not list the -purpose switch as an option, but it is indeed supported. </p>

<p>Since you quote the PKCS7_verify API documentation, programmatically, you can specify the purpose via the <a href=""https://www.openssl.org/docs/man1.0.1/crypto/X509_VERIFY_PARAM_set_flags.html"" rel=""nofollow noreferrer"">X509_VERIFY_PARAM_set_purpose</a> method when you're setting up your X509_STORE object. The following fragment should give you an idea of the process:</p>

<pre><code>X509_STORE store;
int purpose;

store = X509_STORE_new();
verify_params = X509_Store_get0_param(store);
purpose = X509_PURPOSE_get_by_sname(""sslclient"");
X509_VERIFY_PARAM_set_purpose(verify_params, purpose)
...
PKCS7_verify(..., store, ...);
</code></pre>

<p>This will set the purpose to SSL Client when verifying.</p>
","634","<openssl><digital-signature><x509><pkcs#7>","3","4","1","2016-12-25 21:25:39","41317775","0","","3608247","","2016-12-25 15:46:22","2016-11-18 20:01:55",""
"17875035","Rolling my own PKCS#7 padding in PL/SQL","<p>I need to do some encryption in PL/SQL + Oracle using the outdated DBMS_OBFUSCATION_TOOLKIT package, but it has to be decryptable (if that's even a word) in both Java and Javascript.  The Java and JS decryptions use for PKCS#7 / PCKS#5 padding.  It's simple (I think) to implement Zero padding, and I could change the Java and JS, but I don't know if I'll ever have problems with the zero padding being irreversible.</p>

<p>Therefore, I'd like to roll my own PKCS#7, but I'm having some trouble producing the right output.  This code compares what I have side by size with the output from DBMS_CRYPTO, which has PKCS#5 implemented, but is not available to all employees, due to permissions issues:</p>

<pre><code>  FUNCTION  DESWithPKCS5Padding(trash VARCHAR2) 
  RETURN VARCHAR2 
  IS 
    lv_encrypted_data           VARCHAR2 (2000); 
    lv_decrypted_data           VARCHAR2 (2000); 
    piv_str                     VARCHAR2 (2000) := 'apples'; 
    piv_pass_key                VARCHAR2 (2000) := 'testForNathan123testForN'; 
    a_var                       VARCHAR2 (100);
    num_padding_bytes               Int;
    padding_bytes               raw(100);
    test_byte                   raw(1);
    zero_byte                   raw(1);
    piv_raw                     raw(2000);
    piv_raw_orig                raw(2000);
    error_in_input_buffer_length EXCEPTION; 
    PRAGMA EXCEPTION_INIT (error_in_input_buffer_length, -28232); 
    input_buffer_length_err_msg VARCHAR2 (100) := 
  BEGIN 
      dbms_output.Put_line ('Input_string-&gt;:' 
                            || piv_str );

  -- Since 3DES needs data to be in multiples of 8 bytes we had pad the data, if the 
  -- data did not meet the 8 bytes boundary requirement. 
  num_padding_bytes := MOD(Length(piv_str),8);

  piv_raw_orig := utl_raw.cast_to_raw(piv_str);

  IF (num_padding_bytes) != 0 THEN 
    padding_bytes := '';
    zero_byte := '0';
    test_byte := utl_raw.cast_to_raw(8-num_padding_bytes);
    test_byte := utl_raw.bit_and(test_byte, '0F');

    for lcntr in 1..8-num_padding_bytes
      loop
      padding_bytes := UTL_RAW.CONCAT(padding_bytes, test_byte);
      end loop;

      piv_raw := utl_raw.concat(utl_raw.cast_to_raw(piv_str), padding_bytes);
  END IF;

  dbms_output.put_line('Without padding: ' || piv_raw_orig);
  dbms_output.put_line('After padding: '|| piv_raw);

  lv_encrypted_data := dbms_obfuscation_toolkit.Des3encrypt ( 
                       input =&gt; piv_raw, key =&gt; utl_raw.cast_to_raw(piv_pass_key),
                       which =&gt; 1);

  dbms_output.Put_line ('Encrypted Data OBFS: ' 
                        || lv_encrypted_data);

  lv_encrypted_data := dbms_crypto.encrypt (src =&gt; piv_raw_orig,
      KEY =&gt; utl_raw.cast_to_raw(piv_pass_key), typ =&gt;  dbms_crypto.des3_cbc_pkcs5);

  dbms_output.Put_line ('Encrypted Data CRYPTO: ' 
                        || (lv_encrypted_data));                            

  lv_decrypted_data := dbms_crypto.Decrypt (src =&gt; lv_encrypted_data,
      KEY =&gt; utl_raw.cast_to_raw(piv_pass_key), typ =&gt;  dbms_crypto.des3_cbc_pkcs5);

  dbms_output.Put_line('Decrypted: ' || utl_raw.cast_to_varchar2(lv_decrypted_data)); 
END;
</code></pre>

<p>And the output:</p>

<pre><code>Input_string-&gt;:apples
Without padding: 6170706C6573
After padding: 6170706C65730202
Encrypted Data OBFS: 36DEFCBBC60BC58A
Encrypted Data CRYPTO: CF7676DF282DCC5C
Decrypted: apples
</code></pre>

<p>As you can see, it appears the padding is being applied correctly (0202 present at the end of the After padding RAW), but DBMS_CRYPTO is producing a different result than the DBMS_OBFUSCATION_TOOLKIT.  Any ideas why?</p>

<p>Thanks in advance!</p>
","<blockquote>
  <p>"" the output from DBMS_CRYPTO, which has PKCS#5 implemented, but is
  not available to all employees, due to permissions issues:""</p>
</blockquote>

<p>The other employees don't need access to DBMS_CRYPTO, they just need access to <em>your</em> function.  So you can build a function which uses the restricted functionality in a specific and approved fashion, and make it widely available without violating the broader permissions issues.</p>

<p>Of course, I am assuming your application has implemented schemas in a sensible manner, which allows for dispersal of minimum necessary privileges on objects.  I wrote a blog article on a similar issue quite recently, if you would like to <a href=""http://radiofreetooting.blogspot.co.uk/2013/06/let-me-sleep.html"" rel=""nofollow"">find out more</a>.</p>
","628","<oracle><encryption><plsql><bit-manipulation><pkcs#7>","1","0","2","2013-08-01 09:44:26","17917563","0","","","","","2013-07-26 07:07:24",""
"17875035","Rolling my own PKCS#7 padding in PL/SQL","<p>I need to do some encryption in PL/SQL + Oracle using the outdated DBMS_OBFUSCATION_TOOLKIT package, but it has to be decryptable (if that's even a word) in both Java and Javascript.  The Java and JS decryptions use for PKCS#7 / PCKS#5 padding.  It's simple (I think) to implement Zero padding, and I could change the Java and JS, but I don't know if I'll ever have problems with the zero padding being irreversible.</p>

<p>Therefore, I'd like to roll my own PKCS#7, but I'm having some trouble producing the right output.  This code compares what I have side by size with the output from DBMS_CRYPTO, which has PKCS#5 implemented, but is not available to all employees, due to permissions issues:</p>

<pre><code>  FUNCTION  DESWithPKCS5Padding(trash VARCHAR2) 
  RETURN VARCHAR2 
  IS 
    lv_encrypted_data           VARCHAR2 (2000); 
    lv_decrypted_data           VARCHAR2 (2000); 
    piv_str                     VARCHAR2 (2000) := 'apples'; 
    piv_pass_key                VARCHAR2 (2000) := 'testForNathan123testForN'; 
    a_var                       VARCHAR2 (100);
    num_padding_bytes               Int;
    padding_bytes               raw(100);
    test_byte                   raw(1);
    zero_byte                   raw(1);
    piv_raw                     raw(2000);
    piv_raw_orig                raw(2000);
    error_in_input_buffer_length EXCEPTION; 
    PRAGMA EXCEPTION_INIT (error_in_input_buffer_length, -28232); 
    input_buffer_length_err_msg VARCHAR2 (100) := 
  BEGIN 
      dbms_output.Put_line ('Input_string-&gt;:' 
                            || piv_str );

  -- Since 3DES needs data to be in multiples of 8 bytes we had pad the data, if the 
  -- data did not meet the 8 bytes boundary requirement. 
  num_padding_bytes := MOD(Length(piv_str),8);

  piv_raw_orig := utl_raw.cast_to_raw(piv_str);

  IF (num_padding_bytes) != 0 THEN 
    padding_bytes := '';
    zero_byte := '0';
    test_byte := utl_raw.cast_to_raw(8-num_padding_bytes);
    test_byte := utl_raw.bit_and(test_byte, '0F');

    for lcntr in 1..8-num_padding_bytes
      loop
      padding_bytes := UTL_RAW.CONCAT(padding_bytes, test_byte);
      end loop;

      piv_raw := utl_raw.concat(utl_raw.cast_to_raw(piv_str), padding_bytes);
  END IF;

  dbms_output.put_line('Without padding: ' || piv_raw_orig);
  dbms_output.put_line('After padding: '|| piv_raw);

  lv_encrypted_data := dbms_obfuscation_toolkit.Des3encrypt ( 
                       input =&gt; piv_raw, key =&gt; utl_raw.cast_to_raw(piv_pass_key),
                       which =&gt; 1);

  dbms_output.Put_line ('Encrypted Data OBFS: ' 
                        || lv_encrypted_data);

  lv_encrypted_data := dbms_crypto.encrypt (src =&gt; piv_raw_orig,
      KEY =&gt; utl_raw.cast_to_raw(piv_pass_key), typ =&gt;  dbms_crypto.des3_cbc_pkcs5);

  dbms_output.Put_line ('Encrypted Data CRYPTO: ' 
                        || (lv_encrypted_data));                            

  lv_decrypted_data := dbms_crypto.Decrypt (src =&gt; lv_encrypted_data,
      KEY =&gt; utl_raw.cast_to_raw(piv_pass_key), typ =&gt;  dbms_crypto.des3_cbc_pkcs5);

  dbms_output.Put_line('Decrypted: ' || utl_raw.cast_to_varchar2(lv_decrypted_data)); 
END;
</code></pre>

<p>And the output:</p>

<pre><code>Input_string-&gt;:apples
Without padding: 6170706C6573
After padding: 6170706C65730202
Encrypted Data OBFS: 36DEFCBBC60BC58A
Encrypted Data CRYPTO: CF7676DF282DCC5C
Decrypted: apples
</code></pre>

<p>As you can see, it appears the padding is being applied correctly (0202 present at the end of the After padding RAW), but DBMS_CRYPTO is producing a different result than the DBMS_OBFUSCATION_TOOLKIT.  Any ideas why?</p>

<p>Thanks in advance!</p>
","<pre><code>  function ApplyPKCS5Padding (v_to_pad raw)
  return raw
  IS 
    a_var                       VARCHAR2 (100);
    num_padding_bytes               Int;
    padding_bytes               raw(100);
    test_byte                   raw(1);
    zero_byte                   raw(1);
    output                      raw(2000); 
  BEGIN                          
      -- Since DES needs data to be in multples of 8 bytes we pad the data, if the 
      -- data did not meet the 8 bytes boundry requirment.
      num_padding_bytes := MOD(Length(utl_raw.cast_to_varchar2(v_to_pad)),8);
      output := v_to_pad;

      IF (num_padding_bytes) != 0 THEN 
        padding_bytes := '';
        zero_byte := '0';

        test_byte := utl_raw.cast_to_raw(8-num_padding_bytes);
        test_byte := utl_raw.bit_and(test_byte, '0F');

        for lcntr in 1..8-num_padding_bytes
          loop
          padding_bytes := UTL_RAW.CONCAT(padding_bytes, test_byte);
          end loop;

          output := utl_raw.concat(v_to_pad, padding_bytes);
        ELSE
        padding_bytes := '0808080808080808';
        output := utl_raw.concat(v_to_pad, padding_bytes);
      END IF;

  return output;

  END;
</code></pre>

<p>The default IV is... I have no idea, but the OBFS toolkit and DBMS_CRYPTO have a different one.  I just had to specify it, I did the testing with a 0 IV.  Also, the default for OBFS is 2-key 3des, so I needed the <code>which =&gt; 1</code> to change it to 3key.  Thanks for the help!</p>

<p>EDIT:
The original ""solution"" actually failed on Strings with length%8 == 0, due to a misinterpretation of the PKCS#7/5 spec...  I've update the solution above to show the entire/functioning code.</p>
","628","<oracle><encryption><plsql><bit-manipulation><pkcs#7>","1","0","2","2013-08-01 09:44:26","17917563","0","","","","","2013-07-26 07:07:24",""
"36833012","How to read/extract signature details field from a signed PDF using java","<p>As I'm working on an initiative project which verifies whether the document produced by the customer is tampered or not? Whose objectives are as follows:<br>
1.To check the data integrity of content provided in the signed PDF ?
2.To validate whether the signature is tampered or not?
3.Also verifying whether the series of CA is valid by ensuring the revocation list </p>

<p>I've gone through e-sign API document, Basics of PDF,Basics of X.509 certificate, OpenSSL tool (which helped only viewing X.509 certificate and not #PKCS7 standard format)
So can anyone please let me know How can I extract/read the signature dictionary from the signed PDF using Java?
Any other tool to achieve my objective is also okay but since I'm using java as language to code, it would be preferable in java.
Thanks in advance!</p>
","","619","<java><pdf><openssl><itext><pkcs#7>","1","","0","2016-04-25 10:32:01","","0","","5725789","","2016-04-25 10:32:01","2016-04-25 05:58:09",""
"22063310","Adding authenticated attributes using MS CryptoApi","<p>I'm struggling adding authenticated attributes (OCSP data) to my message using CryptoApi. I first used CryptoApi's simplified message functions, but now switch to the low-level message functions, thinking that I would be able to control the message structure better. But I am once again stuck. My process is as follows:</p>

<ul>
<li>Initialize CMSG_SIGNER_ENCODE_INFO and CMSG_SIGNED_ENCODE_INFO structure</li>
<li>I create a CRYPT_ATTRIBUTE for the ocsp date and specifies it in the CMSG_SIGNER_ENCODE_INFO structure</li>
<li>I then call CryptMsgCalculateEncodedLength to get the size</li>
<li>CryptMsgOpenToEncode with CMSG_SIGNED as the message type</li>
<li>CryptMsgUpdate, to insert my content into the message</li>
<li>CryptMsgGetParam with CMSG_CONTENT_PARAM to get the encoded blob</li>
<li>CryptMsgClose, I'm done with the message for now.</li>
</ul>

<p>I open the message again to get the CMSG_ENCRYPTED_DIGEST, which is sent to a TSA and the result is added as an unaunthenticated attribute using CryptMsgControl.</p>

<p>I'm using this to sign signature tags in Adobe. So when there is no authenticated attributes, I receive three green check from Adobe:</p>

<ol>
<li>The document has not been modified...</li>
<li>The document is signed by the current user</li>
<li>The signature includes an embedded timestamp (and the timestamp is validate)</li>
</ol>

<p>But as soon as the authenticated attribute is added the signer's identity is invalidated and the timestamp data in incorrect. The CMSG_COMPUTED_HASH_PARAM when authenticated attributes are added and when not, differs. Should this not be the same? Since the document digest is of the content of the document and not of the authenticated attribute.</p>

<p>Is there another way to add authenticated attributes? I've tried to add it as a signer using CryptMsgControl, but that did not help either...</p>
","<p>how about this step on adding the authenticated attributes for signing, example time stamping,</p>

<pre><code>CryptEncodeObject(PKCS_7_ASN_ENCODING, szOID_RSA_signingTime, &amp;curtime, pTime, &amp;szTime);
pTime = (BYTE *)LocalAlloc(GPTR, szTime);
CryptEncodeObject(PKCS_7_ASN_ENCODING, szOID_RSA_signingTime, &amp;curtime, pTime, &amp;szTime);
time_blob.cbData = szTime;
time_blob.pbData = pTime;
attrib[0].pszObjId = szOID_RSA_signingTime;
attrib[0].cValue = 1;
attrib[0].rgValue = &amp;time_blob;
CosignerInfo.cAuthAttr = 1;
CosignerInfo.rgAuthAttr = attrib;
</code></pre>

<p>and that Cosigner params is from CMSG_SIGNER_ENCODE_INFO CosignerInfo;</p>
","608","<signing><cryptoapi><pkcs#7>","0","0","1","2014-12-11 19:14:22","","0","1","1699210","","2014-12-11 19:14:22","2014-02-27 08:47:48",""
"44684023","How do you decode/decrypt a SignedCMS/PKCS#7 in C# PCL","<p>So, I have an WebAPI that is returning a PKCS#7 file to a client. The client is written as a C# PCL so it can be used in Xamarin iOS and Android projects.</p>

<p>My initial tests worked fine because I was encoding and decoding in my unit tests and could use the Pkcs library. It seems I can't find any way of decoding the data on the client because I don't know of any Pkcs library that works with a PCL.</p>

<p>Can someone tell me how/if this can be done?</p>
","<p>I currently use <a href=""https://github.com/AArnott/PCLCrypto"" rel=""nofollow noreferrer"">PCLCrypto</a> to encrypt and decrypt using PKCS#7 on the client (in a Xamarin Forms project). I assume it will do what you need as well.</p>

<p>The PKCS#7 wiki example can be found <a href=""https://github.com/AArnott/PCLCrypto/wiki/Crypto-Recipes#perform-aes-encryptiondecryption"" rel=""nofollow noreferrer"">here</a></p>
","599","<c#><xamarin><asp.net-web-api2><portable-class-library><pkcs#7>","2","0","2","2017-06-22 14:12:49","44701963","0","1","","","","2017-06-21 18:51:09",""
"44684023","How do you decode/decrypt a SignedCMS/PKCS#7 in C# PCL","<p>So, I have an WebAPI that is returning a PKCS#7 file to a client. The client is written as a C# PCL so it can be used in Xamarin iOS and Android projects.</p>

<p>My initial tests worked fine because I was encoding and decoding in my unit tests and could use the Pkcs library. It seems I can't find any way of decoding the data on the client because I don't know of any Pkcs library that works with a PCL.</p>

<p>Can someone tell me how/if this can be done?</p>
","<p>So, I did end up switching my project to .netstandard 1.4 and using Portable.BouncyCastle to decode the Cms created on the server side.</p>

<p>Here is the code that I used to decode the Cms. I'm sort of trusting that this is also checking the signature since there is no explicit method for doing that in BouncyCastle like there is via the framework code i.e. CheckSignature().</p>

<pre><code>var cmsParser = new Org.BouncyCastle.Cms.CmsSignedDataParser(dataBytes);
var cmsSignedContent = cmsParser.GetSignedContent();
var contentStream = cmsSignedContent.ContentStream;
var memoryStream = new MemoryStream();
contentStream.CopyTo(memoryStream);
byte[] contentBytes = memoryStream.ToArray();
var decodedContent = Encoding.UTF8.GetString(contentBytes);
</code></pre>

<p>In addition I added this to verify the signer info:</p>

<pre><code>cmsParser.GetSignedContent().Drain();
var certStore = cmsParser.GetCertificates(""Collection"");
var signerInfos = cmsParser.GetSignerInfos();
var signers = signerInfos.GetSigners();

foreach (SignerInformation signer in signers)
{
    var certCollection = certStore.GetMatches(signer.SignerID);
    foreach (Org.BouncyCastle.X509.X509Certificate cert in certCollection)
    {
        var result = signer.Verify(cert);
        if (!result)
        {
            throw new Exception(""Certificate verification error, the signer could not be verified."");
        }
    }
}
</code></pre>

<p>I'm not 100% sure if this is all I need to do but my client's will communicate via SSL and they are using an HMAC auth with an appId and client secret so I'm not so concerned with in transit issues. I'm basically transferring a ""license"" file and I want to make sure the contents are not tampered with after it has been saved on the client device.</p>

<p>If anyone has any suggestions or concerns with this please let me know.
Thanks.</p>
","599","<c#><xamarin><asp.net-web-api2><portable-class-library><pkcs#7>","2","2","2","2017-06-22 14:12:49","44701963","0","1","","","","2017-06-21 18:51:09",""
"33165314","CryptoStream error Padding is invalid and cannot be removed","<p>i have problem with my code.
Problem occures in function Decryptor.</p>

<p>FlushFinalBlock throw
""Padding is invalid and cannot be removed""</p>

<p>In function Decryptor i get myData of length 6048,
when line cryptoStream.Write(myData, 0, myData.Length); is done i get length 6032 in memoryStream
and then the line cryptoStream.FlushFinalBlock(); throws an error ""Padding is invalid and cannot be removed.""</p>

<p>As you can see i am using Padding = PaddingMode.PKCS7;</p>

<pre><code>static RijndaelManaged rmCrypto;
static object lockCryptoStream = new object();

public static void SetrmCrypto()
{
    rmCrypto = new RijndaelManaged();
    rmCrypto.Padding = PaddingMode.PKCS7;
    rmCrypto.KeySize = 128;
    rmCrypto.Key = new ASCIIEncoding().GetBytes(""xxxxxxxxxxxxxxxx"");
    rmCrypto.IV = new ASCIIEncoding().GetBytes(""yyyyyyyyyyyyyyyy"");
}

public static byte[] Encryptor(byte[] myData)
{
    lock (lockCryptoStream)
    {
        using (var memoryStream = new MemoryStream())
        {
            using (var cryptoStream = new CryptoStream(memoryStream, rmCrypto.CreateEncryptor(rmCrypto.Key, rmCrypto.IV), CryptoStreamMode.Write))
            {
                cryptoStream.Write(myData, 0, myData.Length);
                cryptoStream.FlushFinalBlock();
                cryptoStream.Close();
                return memoryStream.ToArray();
            }
        }
    }
}

public static byte[] Decryptor(byte[] myData)
{
    lock (lockCryptoStream)
    {
        using (var memoryStream = new MemoryStream())
        {
            using (var cryptoStream = new CryptoStream(memoryStream, rmCrypto.CreateDecryptor(rmCrypto.Key, rmCrypto.IV), CryptoStreamMode.Write))
            {
                cryptoStream.Write(myData, 0, myData.Length);
                cryptoStream.FlushFinalBlock();
                cryptoStream.Close();
                return memoryStream.ToArray();
            }
        }
    }
}
</code></pre>

<p>Encryptor is used on server, and data are sent through UDP.
Client using Decryptor than decrypt the data.
Code works for most of the packets and lets say it works for some hours but then after while i get that error on Flushing.</p>
","<p>upper code works great. 
problem in my case was on server which was typed in c++ and i had problems with that encryption (thread problems on receiving and sending)</p>
","598","<c#><pkcs#7><rijndaelmanaged><cryptostream>","0","0","1","2015-10-21 07:49:15","","1","","2983443","","2015-10-16 09:19:20","2015-10-16 07:57:48",""
"33856589","Verify RSA signature from PKCS#7 using Web Crypto","<p>I'm trying to verify a PKCS#7 signature using JavaScript. I know PKCS#7 isn't supported by the Web Cryptography API, but I'm only trying to verify the raw RSA signature, not the complete PKCS#7 structure. </p>

<p>I'm able to parse the PKCS#7, verify the certificate chain, extract the signed data and verify the signature using <a href=""http://digitalbazaar.com/forge/"" rel=""nofollow"">forge</a>. I don't understand why this signature can't be verified using the Web Cryptography API.</p>

<p>Consider this example:</p>

<pre><code>var publicKey_pem = ""\
    -----BEGIN PUBLIC KEY-----\n\
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyKy7Fm7M5eKVVsOWvpDY\n\
    7OrJ4WJY8kRupJFY2TmsfeOxcZTztx7igt3PRhUtk/P9hNbRge1Hh2lQbnlEozn3\n\
    i335jkGHoHbqGhBim6o4PUikByxEY46NEzxa0p4MdmnmcWh8oqhNH6k0T1ss1eAM\n\
    kCJZNwXqGM64+VuJ58k+H0f1NYFDmmnZVkXNeiRcS7T8MtJEDv0Kni06Brl9KMQa\n\
    xEUx1DLEwmTtW3tV/EA6erIYwpI/yWLdLxT/LxYdtAo9sx55sXXSgFKzTJkLwlhE\n\
    vrgVywIbOsmG0tcRw2NSP4R3XFpETxcwVRjkhbFpcDMjtjilEXZBrB8gaeI4gvX+\n\
    TwIDAQAB\n\
    -----END PUBLIC KEY-----""
    .replace(/^\s+/gm, """");

var signature_b64 = ""\
    nuzPQx94kofXoc3TZlcBH+bAFG6b73cq9OXvGeE/mQ4qRDeWPKWZNC0HfkKtSyng\n\
    kTBWRDw7GeIvOQTY9OXtHunnrn3epPO+HzTmDpCwvv0oNVxoTPlnuBuLzP1mpuIT\n\
    RIgiOJ/xTEqzpjwoCG/HxySb5n4KNu3ii4XB+c914x6V/YU3wDCt60+p71QW3tz0\n\
    lvQPlG3CoMouSYi7sGhAdJMPJA1J5B24FAdqCrOB3xXTuX++HqH0fe6eR5cuzDJN\n\
    xkkjV+GDciyVPSrQb42gf9gl7qtOLvhrwor7efin+FhlWvL5plLn53Ao04scghTf\n\
    hZZLxrEkliWG5E3iGarvXA==""
    .replace(/(\n|\x20)/g, """");

var data_b64 = ""\
    MYGxMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTE1\n\
    MTExNjAwNTMxMFowLwYJKoZIhvcNAQkEMSIEIMcfOGYfrzbx+5cHx8CvoxB6M+25\n\
    Jd+QuGubzoJJjts7MEYGCyqGSIb3DQEJEAITMTcwNTAzMDEwLzALBglghkgBZQME\n\
    AgEEIJ3unWyG0PypTJy/MC9YWBUFjDUAG9AdNs1Byq3tpp23""
    .replace(/(\n|\x20)/g, """");

// using forge 0.7.x
var pki = forge.pki,
    util = forge.util,
    md = forge.md,
    raw = util.binary.raw;
var publicKey = pki.publicKeyFromPem(publicKey_pem);
var signature = new util.ByteBuffer(atob(signature_b64));
var data = new util.ByteBuffer(atob(data_b64));

var hash = md.createMessageDigest(""sha256"")
    .update(data).digest();
var verified = publicKey.verify(hash, signature,
    ""RSASSA-PKCS1-V1_5"");
console.info(""Verification using forge: "" + verified);

var modulus_b64 = ""\
    yKy7Fm7M5eKVVsOWvpDY7OrJ4WJY8kRupJFY2TmsfeOxcZTztx7igt3PRhUtk/P9\n\
    hNbRge1Hh2lQbnlEozn3i335jkGHoHbqGhBim6o4PUikByxEY46NEzxa0p4Mdmnm\n\
    cWh8oqhNH6k0T1ss1eAMkCJZNwXqGM64+VuJ58k+H0f1NYFDmmnZVkXNeiRcS7T8\n\
    MtJEDv0Kni06Brl9KMQaxEUx1DLEwmTtW3tV/EA6erIYwpI/yWLdLxT/LxYdtAo9\n\
    sx55sXXSgFKzTJkLwlhEvrgVywIbOsmG0tcRw2NSP4R3XFpETxcwVRjkhbFpcDMj\n\
    tjilEXZBrB8gaeI4gvX+Tw==""
    .replace(/(\n|\x20|=)/g, """")
    .replace(/\//g, ""_"")
    .replace(/\+/g, ""-"");

var key = {
    kty: ""RSA"",
    alg: ""RS256"",
    e: ""AQAB"",
    n: modulus_b64
};
var algo = {
    name: ""RSASSA-PKCS1-v1_5"",
    hash: {name: ""SHA-256""}
};
var use = [""verify""];

var crypto = window.crypto.subtle;
crypto.importKey(""jwk"", key, algo, false, use).then(function(publicKey) {
    var sig = raw.decode(signature.copy().getBytes());
    var dat = raw.decode(data.copy().getBytes());
    return crypto.verify(algo, publicKey, sig, dat);
}).then(function(res) {
    console.info(""Verification using Web Crypto: "" + res);
}, function(error) {
    console.error(error);
});
</code></pre>

<p>Verification using forge succeeds but verification using the Web Cryptography API fails. I don't see how this could be because they are using the same algorithm specification.</p>

<p>I am able to verify signatures generated by the Web Cryptography API using OpenSSL. Examining the two signatures using OpenSSL there's a slight difference:</p>

<pre><code># verify the external signature using OpenSSL
openssl rsautl -in sig.bin -verify -inkey pub.pem -pubin -asn1parse

    0:d=0  hl=2 l=  47 cons: SEQUENCE          
    2:d=1  hl=2 l=  11 cons:  SEQUENCE          
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=1  hl=2 l=  32 prim:  OCTET STRING      
      0000 - 83 8f e4 de ba 8b b7 24-7a db 6d 43 12 c8 57 f5   .......$z.mC..W.
      0010 - 9c 80 1d 53 1b bf 7e 66-a3 d8 d6 fa ee 2a 4e 8a   ...S..~f.....*N.

# verify the web crypto signature using OpenSSL
openssl rsautl -in sig.bin -verify -inkey pub.pem -pubin -asn1parse

    0:d=0  hl=2 l=  49 cons: SEQUENCE          
    2:d=1  hl=2 l=  13 cons:  SEQUENCE          
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL              
   17:d=1  hl=2 l=  32 prim:  OCTET STRING      
      0000 - a5 91 a6 d4 0b f4 20 40-4a 01 17 33 cf b7 b1 90   ...... @J..3....
      0010 - d6 2c 65 bf 0b cd a3 2b-57 b2 77 d9 ad 9f 14 6e   .,e....+W.w....n
</code></pre>

<p>Could this be the cause of the problem? If so, can the external signature be converted to the encoding used by the Web Cryptography API?</p>
","","595","<javascript><openssl><rsa><pkcs#7><webcrypto-api>","3","","0","2015-11-22 15:36:01","","0","1","","","","2015-11-22 15:36:01",""
"29351173","How to edit Java BC CMSSignedData PKCS#7?","<p>I have a BouncyCastle <code>CMSSignedData</code> object represented as PKCS#7 signed data.</p>

<p>How can I edit the <code>CMSSignedData</code> to remove the value (octet string) of contentInfo 
(OID 1.2.840.113549.1.7.1)?</p>
","<p>Method <code>CMSSignedDataGenerator.generate()</code> is using <code>CMSObjectIdentifiers.signedData [1.2.840.113549.1.7.2]</code> as <code>contentType</code> when constructing a <code>CMSSignedData</code> object. You could rewrite <code>CMSSignedDataGenerator.java</code> or better craft your own generator class and use a different <code>ObjectIdentifier</code>.</p>

<p>The <code>bcpkix</code> sources are available at <a href=""https://www.bouncycastle.org/latest_releases.html"" rel=""nofollow"">bouncycastle</a>.</p>

<p>Note that <code>id-signedData</code> is the official <a href=""https://tools.ietf.org/html/rfc5652#section-5.1"" rel=""nofollow"">RFC 5652</a> content type for signed-data <a href=""https://tools.ietf.org/html/rfc5652"" rel=""nofollow"">CMS</a>  objects:</p>

<pre><code>id-signedData OBJECT IDENTIFIER ::=
{ iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
</code></pre>
","582","<bouncycastle><signed><pkcs#7><oid>","1","1","1","2015-12-29 22:23:14","29357786","0","","4370109","","2015-12-29 22:23:14","2015-03-30 16:16:42",""
"17206425","Sign PDF file with PKCS7 detached using smart card C#","<p>I have ID smart card with SDK, the SDK is signing the binary content of the file and returns signature as byte array.</p>

<p>I used PKCS7 detached method supported by the SDK, the private key is not accessible, how can I add the signature bytes array to the pdf file? </p>
","","577","<c#><smartcard><pkcs#7>","0","","0","2013-06-20 06:09:03","","3","","","","","2013-06-20 06:09:03",""
"43227984","iOS/Swift x509 certificate, sign string","<p>I have x509 certificate (.crt) and private key (.key)
I need to sign some string using a certificate in PKCS#7 detached signature(UTF8)</p>

<p>Can you explain how to distribute certificate (key) and sign?</p>

<p>UPDATE: it seems that i need analog of Cryptographic Message Syntax Services for iOs
Is openSsl only one way to sign message using certificate?</p>
","","560","<ios><swift><certificate><signing><pkcs#7>","2","","0","2017-04-11 15:35:52","","1","","2664167","","2017-04-11 15:35:52","2017-04-05 10:04:19",""
"53243943","Understand why pkcs7 block failed during verification using openssl","<p>I've got PKCS#7 Der formatted file called <code>p7</code> 
and an x509 certificate file called <code>mroot.der.cer</code> which matches the root certificate of p7 chain.</p>

<p>I'd like to verify my p7 certificate chain using openssl using the following commands :</p>

<pre><code>First - convert my mroot trusted cert file to pem format. 
openssl x509 -in mroot.der.cer -inform der -outform PEM -out mroot.pem.cer

Second - verify the root chain using mroot.pem.cer
openssl  smime -verify -CAfile mroot.pem.cer -in p7 -inform DER -out blabla
</code></pre>

<p>However, I got the following error : </p>

<blockquote>
  <p>Verification failure
  140735569544136:error:21075075:PKCS7 routines:PKCS7_verify:certificate verify error:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22.50.2/libressl/crypto/pkcs7/pk7_smime.c:343:Verify error:unable to get local issuer certificate</p>
</blockquote>

<p>I also tried to add the last command, the  <code>-noverify</code> flag but got a different error. </p>

<blockquote>
  <p>Verification failure
  140735569544136:error:21071065:PKCS7 routines:PKCS7_signatureVerify:digest failure:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22.50.2/libressl/crypto/pkcs7/pk7_doit.c:1084:
  140735569544136:error:21075069:PKCS7 routines:PKCS7_verify:signature failure:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22.50.2/libressl/crypto/pkcs7/pk7_smime.c:412:</p>
</blockquote>

<p>The pkcs7 structure should be fine as I've extracted it from the PE file <code>iexlorer.exe</code> and from its chain I've extracted the root certificate, and refer to it as a trusted one. </p>

<p>What am I doing wrong here ? </p>

<p>P.s. 
To observe the same failures I did, I've uploaded the files to the following links : </p>

<p><a href=""https://ufile.io/vrqpt"" rel=""nofollow noreferrer"">https://ufile.io/vrqpt</a></p>

<p><a href=""https://ufile.io/ajgex"" rel=""nofollow noreferrer"">https://ufile.io/ajgex</a></p>
","<p>Your uploaded example files have a few properties which prevent it from being verified.</p>

<p>First, the certificate of the signer in the <code>p7</code> file has expired on <code>Apr 24 22:33:39 2014 GMT</code>. You will have to disable checking of the expiration date if you want to verify the chain. This is programmatically done with the verify flag <code>X509_V_FLAG_NO_CHECK_TIME</code>, or the option <code>-no_check_time</code> for the OpenSSL <code>smime -verify</code> tool.</p>

<p>Then, your ""root of trust"", found in the <code>mroot.pem.cer</code> file is not the right one. You extracted the <code>Microsoft Time-Stamp PCA</code> certificate whereas the signer of the <code>p7</code> file chains up to the <code>Microsoft Code Signing PCA</code> certificate.</p>

<p>Let's say that you extract that correct certificate to a file called <code>trust.pem.cer</code>. That certificate is not self-signed: its issuer is the <code>Microsoft Root Certificate Authority</code>. You will have to indicate that you are using a so-called partial chain if you want such a certificate to be at the end of the chain.  This is programmatically done with the verify flag <code>X509_V_FLAG_PARTIAL_CHAIN</code>, or the option <code>-partial_chain</code> for the OpenSSL <code>smime -verify</code> tool.</p>

<p>Also, it looks like the OpenSSL implementation of the PKCS7 verification requires your certificate to include the extended key usage of S/MIME signing, which your certificate does not include. It looks like this can be worked around by setting a code-signing purpose for the OpenSSL <code>X509_STORE</code>. The OpenSSL <code>smime -verify</code> tool does not expose this kind of setting so you will have to do this programmatically by setting the <code>XKU_CODE_SIGN</code> purpose. <code>XKU</code> stands for eXtended Key Usage and, as a caveat, the OpenSSL documentation around that is virtually non-existent. You have to thoroughly test this if you decide to use it.</p>

<p>The piece of code below (return code checking omitted) successfully verifies the certificate chain in your <code>p7</code> file, but not the signature:</p>

<pre><code>BIO *bio_p7 = BIO_new_file(""p7"", ""r"");
PKCS7 *p7 = d2i_PKCS7_bio(bio_p7, NULL);
X509_STORE *store = X509_STORE_new();
X509_LOOKUP *lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());
X509_LOOKUP_load_file(lookup, ""trust.pem.cer"", X509_FILETYPE_PEM);
X509_STORE_set_purpose(store, XKU_CODE_SIGN); /* see caveat above */
X509_VERIFY_PARAM_set_flags(
    X509_STORE_get0_param(store),
    X509_V_FLAG_NO_CHECK_TIME | X509_V_FLAG_PARTIAL_CHAIN);
int retcode = PKCS7_verify(p7, NULL, store, NULL, NULL, PKCS7_NOSIGS);
</code></pre>

<p>For a verification of the signature itself: the function <a href=""https://sourceforge.net/p/osslsigncode/osslsigncode/ci/master/tree/osslsigncode.c#l2063"" rel=""nofollow noreferrer"">verify_pe_pkcs7() in <code>osslsigncode.c</code></a> gives example code to do that. Its <code>PKCS7_verify()</code> invocation does not verify the certificate chain, but it does check the signature. This requires extraction of a hash which is stored in a Microsoft-specific element in the p7 of a type called <code>SpcIndirectDataContent</code>, as pointed out by @dave_thompson_085 below. It is possible to verify the signature that was taken over that hash. For a complete verification, you will also need to re-calculate the hash over the PE file itself and compare it to the hash value found in the p7. </p>

<p>This answer is based on OpenSSL 1.1.1. Just now, I realize that you are using libressl, which is based on a (much) older version of OpenSSL. It might not work in your case. For example, for my version of libressl, the <code>smime -verify</code> tool does not support the <code>partial_chain</code> and <code>no_time_check</code> options because those were introduced in the OpenSSL 1.1.0 branch.</p>
","559","<openssl><x509certificate><pkcs#7>","1","2","1","2018-11-13 03:05:11","53246954","0","1","4333809","","2018-11-10 22:26:35","2018-11-10 22:12:32",""
"48253497","iText7: How to verify signature in detached PKCS7?","<p>I am writing a service that receives PKCS7 data (extracted from signed PDF documents) and needs to verify it. </p>

<p>I am using iText7 PdfPKCS7 for that, but the signature verification always fails. I can read all other information from the PKCS7 (certificates, timestamps etc., I have verified that also with OpenSSL). Only the signature appears as invalid.</p>

<p>Here's the test case:</p>

<pre><code>public static void main(String[] args) throws IOException, GeneralSecurityException,
    NoSuchFieldException, IllegalArgumentException, IllegalAccessException {

    Logger logger = Logger.getLogger(PKCS7Test.class.getName());

    BouncyCastleProvider provider = new BouncyCastleProvider();
    Security.addProvider(provider);

    String path =""/tmp/signed.pdf"";

    PdfDocument pdf = new PdfDocument(new PdfReader(path));
    SignatureUtil signatureUtil = new SignatureUtil(pdf);
    List&lt;String&gt; names = signatureUtil.getSignatureNames();
    String outerRevisionName = names.get(names.size()-1);

    PdfPKCS7 pkcs7In = signatureUtil.verifySignature(outerRevisionName);

    boolean isValidSignature = pkcs7In.verify();
    logger.log(Level.INFO, ""pkcs7In signature is "" + ((isValidSignature)?"""":""not "") + ""valid"");

    // get hash of original document       
    Field digestAttrField = PdfPKCS7.class.getDeclaredField(""digestAttr"");
    digestAttrField.setAccessible(true);
    byte[] originalDigest = (byte[]) digestAttrField.get(pkcs7In);

    // get pkcs7 structure of original signature                
    PdfDictionary dict = signatureUtil.getSignatureDictionary(outerRevisionName);        
    PdfString contents = dict.getAsString(PdfName.Contents);
    byte [] originalBytes = contents.getValueBytes();
    String originalPkcs7 = Base64.getEncoder().encodeToString(originalBytes);

    // now reverse process and import PKCS7 data back into object
    byte[] pkcs7Bytes = Base64.getDecoder().decode(originalPkcs7);
    PdfPKCS7 pkcs7Out = new PdfPKCS7(pkcs7Bytes, PdfName.Adbe_pkcs7_detached, provider.getName());

    isValidSignature = pkcs7Out.verify();
    logger.log(Level.INFO, ""pkcs7Out signature is "" + ((isValidSignature)?"""":""not "") + ""valid"");

    // get hash of original document from imported signature     
    digestAttrField = PdfPKCS7.class.getDeclaredField(""digestAttr"");
    digestAttrField.setAccessible(true);
    byte [] importedDigest = (byte[]) digestAttrField.get(pkcs7Out);

    logger.log(Level.INFO, ""Hash values are "" + ((Arrays.areEqual(originalDigest, importedDigest))?"""":""not "") + ""equal"");
</code></pre>

<p>The output is invariably:</p>

<pre><code>pkcs7In signature is valid
pkcs7Out signature is not valid
Hash values are equal
</code></pre>

<p>I suppose I'm doing something wrong with the import, but just can't find out what...</p>

<p>Btw. <code>/tmp/signed.pdf</code> validates OK (signature and content) in other PDF tools (Adobe DC, PdfOnline etc.)</p>

<p>Edit:
I tried to verify the signature with BouncyCastle, which fails too ...</p>

<pre><code>    CMSSignedData signature = new CMSSignedData(pkcs7Bytes);        

    Store                   certStore = signature.getCertificates();
    SignerInformationStore  signers = signature.getSignerInfos();
    Collection              c = signers.getSigners();
    Iterator                it = c.iterator();

    while (it.hasNext())
    {
        SignerInformation   signer = (SignerInformation)it.next();
        Collection          certCollection = certStore.getMatches(signer.getSID());

        Iterator              certIt = certCollection.iterator();
        X509CertificateHolder cert = (X509CertificateHolder)certIt.next();

       try {
            signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert));
        }
        catch (Exception ex) {
            logger.log(Level.INFO, ""Failed to verify with: "" + cert.getSubject().toString() + "": "" + ex.getLocalizedMessage());
            byte [] contentDigest = signer.getContentDigest();
            bi = new BigInteger(1, contentDigest);
            String hash = String.format(""%0"" + (contentDigest.length &lt;&lt; 1) + ""x"", bi);
            logger.log(Level.INFO, ""Bouncycastle Hash from pkcs7Out is {0}"", hash);
        }
    }
</code></pre>

<p>The result is <code>Failed to verify with: ... message-digest attribute value does not match calculated value</code>, and the hash value obviously differs from the real one...</p>

<p>Edit 2:
Workaround by adding separate <code>verify(byte[] msgDigestBytes)</code> method to PdfPKCS7:</p>

<pre><code>public boolean verify(final byte[] msgDigestBytes) throws GeneralSecurityException {
    if (verified)
        return verifyResult;
    if (isTsp) {
        TimeStampTokenInfo info = timeStampToken.getTimeStampInfo();
        MessageImprint imprint = info.toASN1Structure().getMessageImprint();
        byte[] md = msgDigestBytes; // was: messageDigest.digest();
        byte[] imphashed = imprint.getHashedMessage();
        verifyResult = Arrays.equals(md, imphashed);
    } else {
        if (sigAttr != null || sigAttrDer != null) {
            // was: final byte[] msgDigestBytes = messageDigest.digest();
            boolean verifyRSAdata = true;
            // Stefan Santesson fixed a bug, keeping the code backward compatible
            boolean encContDigestCompare = false;
            if (rsaData != null) {
                verifyRSAdata = Arrays.equals(msgDigestBytes, rsaData);
                encContDigest.update(rsaData);
                encContDigestCompare = Arrays.equals(encContDigest.digest(), digestAttr);
            }
            boolean absentEncContDigestCompare = Arrays.equals(msgDigestBytes, digestAttr);
            boolean concludingDigestCompare = absentEncContDigestCompare || encContDigestCompare;
            boolean sigVerify = verifySigAttributes(sigAttr) || verifySigAttributes(sigAttrDer);
            verifyResult = concludingDigestCompare &amp;&amp; sigVerify &amp;&amp; verifyRSAdata;
        } else {
            if (rsaData != null)
                sig.update(msgDigestBytes); // was: sig.update(messageDigest.digest());
            verifyResult = sig.verify(digest);
        }
    }
    verified = true;
    return verifyResult;
}
</code></pre>

<p>For this to work, I need the originally signed hash of the document from a trusted source, which in my case I have. Does this still verify that the signature made over the hash is correct?</p>
","<p>From </p>

<pre><code>PdfPKCS7 pkcs7Out = new PdfPKCS7(pkcs7Bytes, PdfName.Adbe_pkcs7_detached, provider.getName());

isValidSignature = pkcs7Out.verify();
</code></pre>

<p>you cannot expect a proper validation result of the signature: This <code>PdfPKCS7</code> only knows the CMS signature container, the signature <strong>SubFilter</strong>, and the security provider to provide algorithm implementations. Thus, it has no information on the very PDF the signature actually is meant to sign. So that piece of code has no means to validate the signature in question, in particular not whether it properly signs its alleged signed data!</p>

<p>If you want to validate the signature using that <code>PdfPKCS7</code> object, you have to finish initializing it so it does have the required information from the PDF.</p>

<p>To see what is required have a look at the <code>SignatureUtil</code> method <code>verifySignature</code>:</p>

<pre><code>PdfPKCS7 pk = null;
if (sub.equals(PdfName.Adbe_x509_rsa_sha1)) {
    PdfString cert = signature.getPdfObject().getAsString(PdfName.Cert);
    if (cert == null)
        cert = signature.getPdfObject().getAsArray(PdfName.Cert).getAsString(0);
    pk = new PdfPKCS7(PdfEncodings.convertToBytes(contents.getValue(), null), cert.getValueBytes(), provider);
}
else
    pk = new PdfPKCS7(PdfEncodings.convertToBytes(contents.getValue(), null), sub, provider);
updateByteRange(pk, signature);
PdfString date = signature.getDate();
if (date != null)
    pk.setSignDate(PdfDate.decode(date.toString()));
String signName = signature.getName();
pk.setSignName(signName);
String reason = signature.getReason();
if (reason != null)
    pk.setReason(reason);
String location = signature.getLocation();
if (location != null)
    pk.setLocation(location);
</code></pre>

<p>Thus, you have to </p>

<ul>
<li>update the digest of the signed data like <code>SignatureUtil.updateByteRange</code> does; this is the step that informs the <code>PdfPKCS7</code> object about the actually signed data to allow actual validation; and</li>
<li>copy several pieces of information from the signature dictionary to the <code>PdfPKCS7</code> object; for validation purposes in particular the signing time may be of interest.</li>
</ul>
","546","<java><pdf><itext7><pkcs#7>","0","2","1","2018-01-16 14:20:28","48254083","2","","6427954","","2018-01-16 14:20:28","2018-01-14 19:47:10",""
"9426418","How to read pkcs#7 file properly","<p>I have a file with detached pkcs#7 signature of size 267 bytes. I create it after executing </p>

<pre><code>CryptSignMessage(
    &amp;SigParams,
    TRUE,
    1,
    MessageArray,
    MessageSizeArray,
    pbSignedMessageBlob,
    &amp;cbSignedMessageBlob)
</code></pre>

<p>function and then I write content of pbSignedMessageBlob:</p>

<pre><code>pbSignedMessageBlob[cbSignedMessageBlob] = '\0';
 FILE *file;
 file = fopen(""c:\\path\\sign_pkcs7.pk7"", ""wb"");
 fwrite(pbSignedMessageBlob, sizeof(BYTE), cbSignedMessageBlob, file);
 fclose(file);
</code></pre>

<p>Then I try to verify this signature and read this file:</p>

<pre><code>BYTE *pkcsContent;
FILE *file3;
file3 = fopen(""c:\\users\\timur\\desktop\\sign_pkcs7.pk7"", ""rb"");
pkcsContent = MyReadFile(file3, cbArray);
BYTE* MyReadFile(FILE *f, DWORD &amp;len)
{
    size_t result;
    BYTE *buffer;
    if (f == NULL) 
    {
        fputs (""File error"", stderr); 
        exit (1);
    }

fseek (f, 0, SEEK_END);
len = ftell (f);
rewind (f);

//buffer = (BYTE*) malloc (sizeof(char)*lSize);
buffer = new BYTE[len + 1];
if (buffer == NULL) 
{
    fputs (""Memory error"", stderr); 
    exit (2);
}

result = fread (buffer, 1, len, f);
if (result != len) 
{
    fputs (""Reading error"",stderr); 
    exit (3);
}
buffer[len] = '\0';

fclose (f);

    return buffer;
}
</code></pre>

<p>But the file content I get into pkcsContent is only 37 bytes length.
I also tried to manage files using std::fstream, but result is the same. Maybe the way I'm writing file to disk is wrong?</p>
","<p>Are you trying to compute the length of <code>pkcsContent</code> with <code>strlen</code> (this is my guess since you're null-terminating the buffer in <code>MyReadFil</code>)? You can't do that because PKCS#7 is binary data and it can contain 0 anywhere.</p>
","542","<c++><io><cryptoapi><pkcs#7>","0","0","1","2012-02-24 07:20:01","","0","","983507","","2012-02-24 06:40:38","2012-02-24 06:32:45",""
"42026850","Any way to obtain the EC2 Identity Document private key?","<p>Is it possible to obtain the private key used to sign the EC2 Identity Document (<a href=""http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html"" rel=""nofollow noreferrer"">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html</a>) from within the instance, or in any other way? Assuming that one signs the Identity Document with this key I'm looking for, the OpenSSL command would be:</p>

<p><code>openssl smime -sign -in document.txt -out document.p7 -outform pem -nodetach -inkey &lt;private_key&gt; -signer AWSpubkey
</code></p>

<p>Where <code>&lt;private_key&gt;</code> is the key I'm looking for.</p>

<p>I'm trying to determine if someone could potentially forge the PKCS7 signature in <a href=""http://169.254.169.254/latest/dynamic/instance-identity/pkcs7"" rel=""nofollow noreferrer"">http://169.254.169.254/latest/dynamic/instance-identity/pkcs7</a> by creating a <code>document.txt</code> and signing it with the private key.</p>

<p>Thanks.</p>
","<p>I'm pretty sure the point of Amazon doing this is that they don't publish the private key so there is no way for someone to forge the signature. Unless there are some breakthroughs in quantum computing soon, you should be confident that the signature hasn't been forged.</p>

<p>There's a <a href=""https://security.stackexchange.com/"">different Stack Exchange site</a> where you are more likely to have your question answered by a cryptographic specialist. </p>
","539","<amazon-web-services><amazon-ec2><openssl><certificate><pkcs#7>","1","0","1","2017-02-03 14:57:58","42027086","2","","","","","2017-02-03 14:45:36",""
"38392800","Embeding Sigend data with pdf using iText","<p>I have a encoded signed data in a string ("" >MIILwwYJKoZIhvcNAQcCoIILtDCCC7ACAQExDzANB........ "")</p>

<p>And I need to combine it with the pdf for signatures.</p>

<p>I am using following code</p>

<pre><code>public class MyExternalSignatureContainer  implements ExternalSignatureContainer {
 protected byte[] sig;
 // String b64String;

    public MyExternalSignatureContainer(byte[] sig) {
    this.sig = sig;
}

@Override
public void modifySigningDictionary(PdfDictionary arg0) {
}

/**
String PKCS7Resp = ""MIILwwYJKoZIhvcNAQcCoIILtDCCC7ACAQEx.........;
Base64Encoder b = new Base64Encoder();
    byte[] signedData = b.decode(PKCS7Resp.getBytes());

    PdfReader reader = new PdfReader(""D:\\AADHAAR.pdf"");
    FileOutputStream os = new FileOutputStream(""D:\\AADHAAR1.pdf"");

    ExternalSignatureContainer external = new MyExternalSignatureContainer(signedData);
    MakeSignature.signDeferred(reader, ""}"", os, external);

 *
 * @param arg0
 * @return
 * @throws GeneralSecurityException
 */
 @Override
public byte[] sign(java.io.InputStream in) throws GeneralSecurityException {
    throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
}

public static void main(String [] args) throws DocumentException, IOException, GeneralSecurityException{
      Base64Encoder b = new Base64Encoder();
        byte[] signedData = b.decode(PKCS7Resp.getBytes());
       PdfReader reader = new PdfReader(""D:\\AADHAAR.pdf"");
      FileOutputStream os = new FileOutputStream(""D:\\AADHAAR1.pdf"");          
      ExternalSignatureContainer external = new MyExternalSignatureContainer(signedData);
         MakeSignature.signDeferred(reader, ""}"", os, external);
         }
          }
</code></pre>

<p>but its showing error</p>

<pre><code>Exception in thread ""main"" com.itextpdf.text.DocumentException: No field
at com.itextpdf.text.pdf.security.MakeSignature.signDeferred(MakeSignature.java:246)
at test.MyExternalSignatureContainer.main(MyExternalSignatureContainer.java:131)
  C:\Users\admin\AppData\Local\NetBeans\Cache\8.1\executor-snippets\run.xml:53: Java returned: 1
</code></pre>

<p>BUILD FAILED (total time: 1 second)</p>

<p>In line    </p>

<blockquote>
  <p>MakeSignature.signDeferred(reader, ""}"", os, external);</p>
</blockquote>

<p>Reference code</p>

<pre><code>KeyStore ks = KeyStore.getInstance(""pkcs12"");
ks.load(new FileInputStream(""my_private_key.pfx""), ""my_password"".toCharArray());
String alias = (String)ks.aliases().nextElement();
PrivateKey key = (PrivateKey)ks.getKey(alias, ""my_password"".toCharArray());
Certificate[] chain = ks.getCertificateChain(alias);
PdfReader reader = new PdfReader(""original.pdf"");
FileOutputStream fout = new FileOutputStream(""signed.pdf"");
PdfStamper stp = PdfStamper.createSignature(reader, fout, '\0');
PdfSignatureAppearance sap = stp.getSignatureAppearance();
sap.setCrypto(key, chain, null, PdfSignatureAppearance.WINCER_SIGNED);
sap.setReason(""I'm the author"");
sap.setLocation(""Lisbon"");
// comment next line to have an invisible signature
sap.setVisibleSignature(new Rectangle(100, 100, 200, 200), 1, null);
sap.setExternalDigest(new byte[128], new byte[20], ""RSA"");
sap.preClose();
MessageDigest messageDigest = MessageDigest.getInstance(""SHA1"");
byte buf[] = new byte[8192];
int n;
InputStream inp = sap.getRangeStream();
while ((n = inp.read(buf)) &gt; 0) {
   messageDigest.update(buf, 0, n);
}
byte hash[] = messageDigest.digest();
PdfSigGenericPKCS sg = sap.getSigStandard();
PdfLiteral slit = (PdfLiteral)sg.get(PdfName.CONTENTS);
byte[] outc = new byte[(slit.getPosLength() - 2) / 2];
PdfPKCS7 sig = sg.getSigner();
Signature sign = Signature.getInstance(""SHA1withRSA"");
sign.initSign(key);
sign.update(hash);
sig.setExternalDigest(sign.sign(), hash, ""RSA"");
PdfDictionary dic = new PdfDictionary();
byte[] ssig = sig.getEncodedPKCS7();
System.arraycopy(ssig, 0, outc, 0, ssig.length);
dic.put(PdfName.CONTENTS, new PdfString(outc).setHexWriting(true));
sap.close(dic);
</code></pre>

<p>Am i doing it wrong?</p>
","<p>In your first step you create a signature field with an automatically generated name:</p>

<pre><code>sap.setVisibleSignature(new Rectangle(100, 100, 200, 200), 1, null);
</code></pre>

<p>Confer the associated JavaDocs:</p>

<blockquote>
<pre><code>/**
 * Sets the signature to be visible. It creates a new visible signature field.
 * @param pageRect the position and dimension of the field in the page
 * @param page the page to place the field. The fist page is 1
 * @param fieldName the field name or &lt;CODE&gt;null&lt;/CODE&gt; to generate automatically a new field name
 */
public void setVisibleSignature(Rectangle pageRect, int page, String fieldName)
</code></pre>
</blockquote>

<p>Later on, though, you act as if the signature field name was ""}"":</p>

<pre><code>MakeSignature.signDeferred(reader, ""}"", os, external);
</code></pre>

<p>Confer the associated JavaDocs:</p>

<blockquote>
<pre><code>/**
 * Signs a PDF where space was already reserved.
 * @param reader the original PDF
 * @param fieldName the field to sign. It must be the last field
 * @param outs the output PDF
 * @param externalSignatureContainer the signature container doing the actual signing. Only the 
 * method ExternalSignatureContainer.sign is used
 * @throws DocumentException
 * @throws IOException
 * @throws GeneralSecurityException 
 */
public static void signDeferred(PdfReader reader, String fieldName, OutputStream outs, ExternalSignatureContainer externalSignatureContainer) throws DocumentException, IOException, GeneralSecurityException
</code></pre>
</blockquote>

<p>Thus, change your code to make those names match, i.e. either use a fixed name you know not to be used by some other form field in the document or query the generated name used by iText using the <code>PdfSignatureAppearance</code> method</p>

<blockquote>
<pre><code>/**
 * Gets the field name.
 * @return the field name
 */
public java.lang.String getFieldName()
</code></pre>
</blockquote>
","538","<java><itext><digital-signature><pkcs#7>","-1","0","1","2016-07-16 22:15:20","","10","2","6184985","","2016-07-16 04:37:41","2016-07-15 09:38:58",""
"44874341","PHP openssl_pkcs7_verify Not Working","<p>I`m using pkcs7 to sign a document and everything works fine, the problem is that the command to verify the sign is not working, always return false. I try to use the terminal command into the file and works fine.</p>

<p><b>Sign command:</b></p>

<pre><code>openssl_pkcs7_sign(
    $tempdoc,
    $tempsign,
    $this-&gt;signature_data['signcert'],
    array($this-&gt;signature_data['privkey'],
    $this-&gt;signature_data['password']),
    array(),
    PKCS7_BINARY | PKCS7_DETACHED);
</code></pre>

<p><b>Verify command:</b></p>

<pre><code>openssl_pkcs7_verify($tempsign, PKCS7_NOVERIFY)
</code></pre>

<p><b>Terminal command:</b></p>

<pre><code>openssl pkcs7 -inform DER -in signature.pkcs7 -print_certs -text
</code></pre>

<p><br/></p>

<p><b>EDIT 1</b>
<br/>
I make tests in my code and discover if i create my sign with only PKCS7_DETACHED or PKCS7_BINARY works fine the <b>verify</b>, but both together i receive the error. Why this is happening?</p>
","<p>Here with PHP 7 i can reproduce your problem. With both flags the verify fails. </p>

<p>Maybe <a href=""http://openssl.6102.n7.nabble.com/smime-tool-binary-and-verify-td44099.html"" rel=""noreferrer"">THIS URL</a> can help you., this part talks about it.</p>

<blockquote>
  <p>SMIME -sign ""detached"" ""attaches"" content similarly as-is  with
  -binary and text-canonicalized without, and signs that.  SMIME -verify recognizes ""detached"", but (in multi_split)  always canonicalizes both
  parts before using them. For content  that was sent noncanonical (with
  -sign -binary or equivalent)  this changes the signed content, and verify fails.  Content that was canonical as sent (originally
  canonical  or canonicalized by sender) does verify and similarly  is
  output without determining if sender changed it.</p>
</blockquote>

<p>In the <a href=""https://www.openssl.org/docs/man1.0.2/apps/smime.html"" rel=""noreferrer"">docs</a> you can read that the parser isn't that smart:</p>

<blockquote>
  <p><strong>BUGS</strong></p>
  
  <p>The MIME parser isn't very clever: it seems to handle most messages
  that I've thrown at it but it may choke on others.</p>
</blockquote>

<p>Hope it helps!</p>
","534","<php><pkcs#7><php-openssl>","6","3","1","2017-07-06 19:33:14","44957430","5","1","4601342","","2017-07-04 16:05:21","2017-07-02 19:15:07",""
"54356538","How to extract and verify PDF signature (PKCS7) with openssl?","<p>I would like to detect signed PDFs in PHP and verify if the signature is valid. From this <a href=""https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSig/Acrobat_DigitalSignatures_in_PDF.pdf"" rel=""nofollow noreferrer"">document</a> I have written this PHP code below. </p>

<p>What it does is: </p>

<ol>
<li>Extract the PKCS7 code (it works because I can get the details from Openssl)</li>
<li>Compute the SHA256 hash of the document. </li>
</ol>

<p>At the end I has a PKCS7 file and a SHA256. </p>

<p>Now, I would like to verify my signature against my PKCS7 file. How can I do this? I initially looked to the <code>digest_enc_alg</code>/<code>sha256WithRSAEncryption</code>/<code>enc_digest</code>, but it seems it is not what I am looking about. </p>

<pre><code>class VerifyPDF
{
    public static function getByteRange($filename)
    {
        $content = file_get_contents($filename);
        if (!preg_match_all('/ByteRange\[\s*(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s*\]/',
            $content, $matches))
        {
            throw new \Exception('Unable to get certificate');
        }

        return [
            intval($matches[1][0]), // Offset of the first part (usually 0)
            intval($matches[2][0]), // Size of the first part
            intval($matches[3][0]), // Offset to the second part
            intval($matches[4][0])  // Size of the second part
        ];
    }

    public static function get_pkcs7($filename)
    {
        [$o1, $l1, $o2, $l2] = self::getByteRange($filename);

        if (!$fp = fopen($filename, 'rb')) {
            throw new \Exception(""Unable to open $filename"");
        }

        $signature = stream_get_contents($fp, $o2 - $l1 - 2, $l1 + 1);
        fclose($fp);

        file_put_contents('out.pkcs7', hex2bin($signature));
    }

    public static function compute_hash($filename)
    {
        [$o1, $l1, $o2, $l2] = self::getByteRange($filename);

        if (!$fp = fopen($filename, 'rb')) {
            throw new \Exception(""Unable to open $filename"");
        }

        $i = stream_get_contents($fp, $l1, $o1);
        $j = stream_get_contents($fp, $l2, $o2);

        if (strlen($i) != $l1 || strlen($j) != $l2) {
            throw new \Exception('Invalid chunks');
        }

        fclose($fp);

        return hash('sha256', $i . $j);
    }
}
</code></pre>

<p>The HASH I get is:</p>

<pre><code>5036ae43aba11ce626f6f9b1d5246ba0700e217655b9ff927e31fbefadfa2182
</code></pre>

<p>So inspired from <a href=""http://qistoph.blogspot.com/2012/01/manual-verify-pkcs7-signed-data-with.html"" rel=""nofollow noreferrer"">this</a> I did the following: </p>

<pre><code>#!/bin/bash
PKCS7='out.pkcs7'

# Extract Digest (SHA256)
OFFSET=$(openssl asn1parse -inform der -in $PKCS7 | \
    perl -ne 'print $1 + $2 if /(\d+):d=\d\s+hl=(\d).*?256 prim.*HEX DUMP/m')
dd if=$PKCS7 of=signed-sha256.bin bs=1 skip=$OFFSET count=256

# Extract Public key 
openssl pkcs7 -print_certs -inform der -in $PKCS7 | \
    tac | sed '/-----BEGIN/q' | tac &gt; client.pem
openssl x509 -in client.pem -pubkey -noout &gt; client.pub.pem

# Verify the signature
openssl rsautl -verify -pubin -inkey client.pub.pem &lt; signed-sha256.bin &gt; verified.bin

# Get Hash and compare with the computed hash from the PDF
openssl asn1parse -inform der -in verified.bin | grep -Po '\[HEX DUMP\]:\K\w+$' | tr A-F a-f
</code></pre>

<p>Which gives me this:</p>

<pre><code>C8581962753927BB57B66B1D0D0F4B33A29EF3E03DA12D2329DB72763AC7EDB6
</code></pre>

<p>So unfortunately by two hashes do not match...</p>

<p>Am I missing something?</p>
","<p>The <a href=""http://qistoph.blogspot.com/2012/01/manual-verify-pkcs7-signed-data-with.html"" rel=""nofollow noreferrer"">blog</a> you were <em>inspired from</em> shows the following graphics to explain the PKCS#7 signature container structure</p>

<p><a href=""https://i.stack.imgur.com/QTSO2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QTSO2.png"" alt=""screen shot""></a></p>

<p>Actually, though, this represents only the most simple structure defined by PKCS#7. If you look at the <code>SignerInfo</code> specification (<code>content - signerInfos - SignerInfo</code>), you'll see</p>



<pre class=""lang-none prettyprint-override""><code>   SignerInfo ::= SEQUENCE {
     version Version,
     issuerAndSerialNumber IssuerAndSerialNumber,
     digestAlgorithm DigestAlgorithmIdentifier,
     authenticatedAttributes
       [0] IMPLICIT Attributes OPTIONAL,
     digestEncryptionAlgorithm
       DigestEncryptionAlgorithmIdentifier,
     encryptedDigest EncryptedDigest,
     unauthenticatedAttributes
       [1] IMPLICIT Attributes OPTIONAL }
</code></pre>

<p><em>(<a href=""https://tools.ietf.org/html/rfc2315#section-9.2"" rel=""nofollow noreferrer"">RFC 2315 section 9.2 ""SignerInfo type""</a>)</em></p>

<p>In particular there are the OPTIONAL <code>authenticatedAttributes</code> which you don't find in the sketch above. But in any current signature profile to be taken seriously these <code>authenticatedAttributes</code> (aka signed attributes) are actually required!</p>

<p>Furthermore, if there are <code>authenticatedAttributes</code> in a PKCS#7 signature container signer info object, the encrypted digest is <em>not</em> the digest of the document data but instead the digest of the <code>authenticatedAttributes</code> structure. In this case the digest of the document data is stored as the value of a specific signed attribute, the ""messageDigest"" attribute. Thus, in this case you try to extract the wrong value to compare the document digest with.</p>

<p>For example in case of the example document you shared in your <a href=""https://stackoverflow.com/q/54361974/1729265"">follow-up question</a> there are <code>authenticatedAttributes</code>, so the inspiring blog led you astray.</p>
","530","<php><bash><pdf><digital-signature><pkcs#7>","0","1","1","2019-01-28 17:07:44","54406999","1","","2612235","","2019-01-25 08:38:44","2019-01-24 22:51:16",""
"49451395","Swift (Linux): Extract CMS/PKCS#7 Certs and Validate Container Signature?","<p>I am writing a set of services in Swift 4 that will run on Linux.  One of the things I need to do is receive a payload that is digitally signed using the Cryptographic Message Syntax (CMS) format, extract the certificate used to sign it, and then validate the signature.  I know that Swift on Linux doesn't contain a Security or CommonCrypto framework for this sort of thing, so I've linked in OpenSSL to try and help with this.  I'm about 2 years removed from my C/C++ programming days, so I readily admit I'm in over my head on this portion of the code.</p>

<p>I have 2 simple classes to act as wrappers for OpenSSL <code>BIO</code> and <code>PKCS7</code> data structures.  They look like this:</p>

<pre><code>import Foundation
import OpenSSL

public final class BIOWrapper {

    public var bio = BIO_new(BIO_s_mem())

    public init(data: Data) {
        data.withUnsafeBytes { pointer -&gt; Void in
            BIO_write(self.bio, pointer, Int32(data.count))
        }
    }

    public init() {}

    deinit {
        BIO_free(self.bio)
    }
}

public final class PKCS7Wrapper {

    public var pkcs7: UnsafeMutablePointer&lt;PKCS7&gt;

    public init(pkcs7: UnsafeMutablePointer&lt;PKCS7&gt;) {
        self.pkcs7 = pkcs7
    }

    deinit {
        PKCS7_free(self.pkcs7)
    }
}
</code></pre>

<p>I am able to successfully extract the PKCS#7 container data and validate that the data type code value is <code>NID_pkcs7_signed</code> using this code:</p>

<pre><code>let reqData = Data(bytes: reqBytes)
        guard reqData.count &gt; 0 else {
            print(""Empty request body"")
            return nil
        }

        let bioWrapper = BIOWrapper(data: reqData)
        guard let container = d2i_PKCS7_bio(bioWrapper.bio, nil) else {
            print(""No container"")
            return nil
        }

        let pkcs7Wrapper = PKCS7Wrapper(pkcs7: container)
        let dataTypeCode = OBJ_obj2nid((pkcs7Wrapper.pkcs7.pointee.d.sign).pointee.contents.pointee.type)
        print(""dataTypeCode : \(dataTypeCode)"")

        if dataTypeCode == NID_pkcs7_data {
            print(""GOT DATA!"")
        } else {
            print(""Didn't get data"")
            return nil
        }

       let pkcs7SignedTypeCode = OBJ_obj2nid(pkcs7Wrapper.pkcs7.pointee.type)
        if let signed = pkcs7SignedTypeCode == NID_pkcs7_signed {
            print(""Signed : \(signed)"")
        }
</code></pre>

<p>However, I've now reached a point where I'm stuck.  How can I obtain the X.509 certificate data from the PKCS#7 payload?  I can see that the <code>pkcs7Wrapper.pkcs7.pointee.d.sign.pointee.cert</code> data structure should contain the certificate chain data.  Its data type is <code>UnsafeMutablePointer&lt;stack_st_x509&gt;</code> and I think I can figure out the code to use OpenSSL's <code>PKCS7_verify</code> method once I get the X.509 certificate data in memory.  I just don't know how to do THAT part.</p>

<p>I found <a href=""http://swiftrien.blogspot.com/2015/05/osx-receipt-validation-in-swift-part-6.html"" rel=""noreferrer"">this resource</a> that talks about validating receipts on OSX/iOS that touches on a lot of the same issues.  They obtain the X.509 certificate from the file system and pass the data into the <code>PKCS7_verify</code> method.  I just need to know how to get the certificate data from the PKCS#7 container to pass in.</p>

<p>Can anyone help me with this?  I recognize that calling C from Swift is not ideal, but in the absence of a good security/cryptography framework for Swift I'm not aware of any other options.</p>
","<p>The core part of the answer is in the code you linked:</p>

<pre><code>let store = X509_STORE_new()
X509_STORE_add_cert(store, appleRootX509)
OpenSSL_add_all_digests()
let result = PKCS7_verify(receiptPKCS7, nil, store, nil, nil, 0)
if result != 1 {
    log.atLevelDebug(id: 0, source: ""Main"", message: ""Receipt signature verification failed"")
    exit(errorCode)
}
</code></pre>

<p>What you seem to be missing is the fact that you don't have to extract the X509 certificate from the PKCS7 data yourself. The <code>PKCS7_verify</code> <a href=""https://www.openssl.org/docs/man1.0.2/crypto/PKCS7_verify.html"" rel=""nofollow noreferrer"">function will do it</a> as part of verification:</p>

<blockquote>
  <p>An attempt is made to locate all the signer's certificates, first looking in the certs parameter (if it is not NULL) and then looking in any certificates contained in the p7 structure itself. If any signer's certificates cannot be located the operation fails.</p>
</blockquote>

<p>Therefore the only certificate you need to load yourself is the root certificate which you have observed they load from the file system in the <a href=""http://swiftrien.blogspot.com/2015/05/osx-receipt-validation-in-swift-part-6.html"" rel=""nofollow noreferrer"">linked code</a>.</p>

<p>If you still really need a Swift solution to extract the certificate out of the PKCS7 data for some reason, you will have to build an ASN.1 parser for PKCS7. Not sure if this is readily available for Swift, <a href=""https://gist.github.com/Jugale/2daaec0715d4f6d7347534d42bfa7110"" rel=""nofollow noreferrer"">this simple code</a> is what a quick search yielded, and <a href=""https://github.com/torvalds/linux/blob/master/crypto/asymmetric_keys/pkcs7.asn1"" rel=""nofollow noreferrer"">this</a> is a nice description of the PKCS7 data.</p>
","516","<c><swift><openssl><digital-signature><pkcs#7>","7","4","1","2018-03-27 02:39:12","49503557","4","2","","","","2018-03-23 14:01:06",""
"7348118","Apple Live Streaming, encryption and padding to PKCS7","<p>I've written a segmenter and have just added AES encryption, but I'm a little puzzled by the PKCS7 padding. When playing on the iPad, I get glitches every 12 seconds, which is my segment length.</p>

<p>If my file is 4 bytes short of being on a 16 byte boundary, I add <code>0x04 x 4</code>.<BR>
If it's 8 bytes short I add <code>0x08 x 8</code>.<BR>
If it's 12 bytes short I add <code>0x0c x 12</code>.<BR>
I then encrypt the package using the multiple of 16 size, is this correct?</p>

<p>Next question is, do I send the full encoded packet, so it's a multiple of 16, or do I send the real length (before padding)?</p>
","","508","<encryption><aes><http-live-streaming><pkcs#7>","2","","0","2014-01-21 22:23:22","","5","","881229","","2014-01-21 22:23:22","2011-09-08 12:37:36",""
"31266416","Error in compiling a certificate verifier program","<p>I want to compile <a href=""http://www.jensign.com/JavaScience/javacrypto/BCVerifyISig.txt"" rel=""nofollow"">this</a> program in IntelliJ IDE. But it returns the following three errors:</p>

<p><strong>1.for this line :</strong></p>

<pre><code>CertStore certs = s.getCertificatesAndCRLs(""Collection"", ""BC"");
</code></pre>

<p>this error:</p>

<pre><code>error: cannot find symbol method getCertificatesAndCRLs(String,String)
</code></pre>

<p><strong>2.for this line:</strong></p>

<pre><code>Collection certCollection = certs.getCertificates(signer.getSID());
</code></pre>

<p>this error:</p>

<pre><code>error: method getCertificates in class CertStore cannot be applied to given types;
required: CertSelector
found: SignerId
reason: actual argument SignerId cannot be converted to CertSelector by method invocation conversion
</code></pre>

<p><strong>3.and for this line:</strong></p>

<pre><code>if (signer.verify(cert.getPublicKey(), ""BC"")) verified++;
</code></pre>

<p>this error:</p>

<pre><code>error: method verify in class SignerInformation cannot be applied to given types;
required: SignerInformationVerifier
found: PublicKey,String
reason: actual and formal argument lists differ in length
</code></pre>

<hr>

<p><strong>These are my imports top of my program :</strong></p>

<pre><code>import java.io.*;
import java.util.*;
import java.security.*;
import java.security.Security;
import java.security.cert.*;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.cms.*;
</code></pre>

<p>and I am added <code>jdk1.7.0_15</code> libraries + <code>bcpkix-jdk15on-151.jar</code> and <code>bcprov-jdk16-1.45.jar</code> to my project. </p>

<p>Can anybody please help me to handle this issues?</p>
","<p>Please follow the following steps. Hope it will help you because it is tested.
<br><br>
<strong>Step 01:</strong> <br>
Read byte array from file or convert data object to byte array. <br>
Sample Code: <br></p>

<pre><code>FileInputStream fis = new FileInputStream(file);
byte fileContent[] = new byte[(int)file.length()];
fis.read(fileContent);
</code></pre>

<p><strong>Step 02:</strong> <br>
create CMSSignedData object from the byte array. <br>
Sample Code: </p>

<pre><code>CMSSignedData data = new CMSSignedData(fileContent);
</code></pre>

<p><strong>Step 03:</strong> <br>
Get CertStore from the CMSSignedData. <br>
Sample Code:<br></p>

<pre><code>CertStore certs = data.getCertificatesAndCRLs(""Collection"", ""BC"");
</code></pre>

<p>Be sure to add BouncyCastleProvider in Security at the first:</p>

<pre><code>Security.addProvider(new BouncyCastleProvider());'
</code></pre>

<p><strong>Step 04:</strong> <br>
Get Certificate collection using Signer Information. <br>
Sample Code:</p>

<pre><code>SignerInformation signer = (SignerInformation) i.next();
Collection&lt;? extends Certificate&gt; certCollection = certs.getCertificates(signer.getSID());
</code></pre>

<p><strong>Step 05:</strong> <br>
Verify sign from signer for each certificate. <br>
Sample Code:</p>

<pre><code>if (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert)) ) 
{   
     }
</code></pre>

<p><br> <br>
Please check that, to fulfuill your objective, you have completed above steps.
<br><br>
I am guessing, either you are making CMSSignedData from wrong data input or the dependent libraries are conflicting each other (<em>most probable cause</em>). I have used <strong>bcprov-jdk16-1.46.jar</strong> and <strong>bcmail-jdk16-1.46.jar</strong> to complete all the tasks.</p>
","499","<java><digital-signature><pkcs#7>","1","0","1","2015-07-10 06:08:46","","2","","147024","","2015-07-07 19:51:17","2015-07-07 10:46:00",""
"46689478","Sign pdf asynchronously using digest","<p>I'm trying to do the following setup for signing pdfs, broken down into asynchronous steps between a client and a server:</p>

<ol>
<li>A server receives a pdf and computes it's digest.</li>
<li>Server sends the digest to a client.</li>
<li>Client signs the hash at a later time.</li>
<li>Client sends the signature to server.</li>
<li>Server embeds the signature into the pdf.</li>
</ol>

<p>I'm basing myself mainly in <a href=""https://stackoverflow.com/questions/29251895/pdf-signature-digest"">PDF Signature digest</a> and <a href=""https://stackoverflow.com/questions/41767351/create-pkcs7-signature-from-file-digest"">Create pkcs7 signature from file digest</a></p>

<p>The second question allowed me to write most of the code, however I'm getting that the integrity of the file has been compromised. I can't seem to serialize the intermediary pdf for embedding the signature later (to make sure no timestamps are altered, etc). But from the first SO question, it seems to be a harder problem than I thought. Can it actually be done? </p>

<p>I'm using pdfbox.</p>

<p>Server code:</p>

<pre><code>        PDDocument document = PDDocument.load(documentFile);
        PDSignature signature = new PDSignature();
        signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);
        signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);
        signature.setName(""Example User"");
        signature.setLocation(""Los Angeles, CA"");
        signature.setReason(""Testing"");
        Calendar date = Calendar.getInstance();
        signature.setSignDate(date);
        document.addSignature(signature);

        ExternalSigningSupport externalSigningSupport = document.saveIncrementalForExternalSigning(null);

        byte[] content = IOUtils.toByteArray(externalSigningSupport.getContent());
        MessageDigest md = MessageDigest.getInstance(""SHA256"", new BouncyCastleProvider());
        byte[] digest = md.digest(content); // this is sent to client
</code></pre>

<p>What I'm basically doing is sending that digest to the client to sign and then on the server redoing the above steps and setting the client signature:</p>

<pre><code>        ExternalSigningSupport externalSigning = document.saveIncrementalForExternalSigning(fos);
        externalSigning.setSignature(encodedSignature); // encodedSignature is received from client and computed based on the digest sent by the server
</code></pre>

<p>This setup ends up with the integrity of the file being corrupted, since I'm creating a new PDSignature once I have the <code>encodedSignature</code> on the server to embed it. Is there a way to serialize the PDDocument created after calling addSignature, so I can later deserialize it on the server and add the client's  signature?</p>
","<blockquote>
  <p>What I'm basically doing is sending that digest to the client to sign and then on the server redoing the above steps and setting the client signature</p>
</blockquote>

<p>If you want those <em>above steps</em> to generate identical documents, you need to</p>

<ul>
<li>make sure the inputs to those steps are identical and</li>
<li>provide the same revision id seed value.</li>
</ul>

<p>If you do so, the outputs of the <em>above steps</em> are identical as is required for your task.</p>

<h3>Making sure the inputs are identical</h3>

<p>One step of your <em>above steps</em> is prone to result in different inputs:</p>

<pre><code>Calendar date = Calendar.getInstance();
signature.setSignDate(date);
</code></pre>

<p>To guarantee identical inputs, you have to determine <code>date</code> only once and use that single value every time you execute those steps for the same signing transaction.</p>

<h3>Providing the same revision id seed value</h3>

<p>As recommended by the specification, PDFBox attempts to give each PDF revision its unique ID. In the case at hand, though, we need the same revision ID both times the <em>above steps</em> are executed.</p>

<p>Fortunately, PDFBox allows us to provide the seed value it uses to make the revision ID unique enough. </p>

<p>As we don't want to same revision ID all the time we sign the same document but merely during the current signing transaction, we should use the same seed value only in the same transaction. As the seed value is a long, we can simply use the time in milliseconds corresponding to the <code>date</code> already discussed above, i.e.:</p>

<pre><code>pdDocument.setDocumentId(date.getTimeInMillis());
</code></pre>
","484","<java><pdf><pdfbox><pkcs#7>","1","2","1","2017-10-12 09:51:19","46706529","0","5","","","","2017-10-11 13:28:23",""
"56013953","How to verify a file and a p7s detached signature with openssl?","<p>Would be possible to validate a file with p7s detached signature? I'm trying to do that using Openssl, but I got a default message about openssl and <code>unknown option -verify</code></p>

<p>here is my command:</p>

<p><code>openssl pkcs7 -inform DER -verify -noverify -in file.docx.p7s -out file.docx</code></p>

<p>is this possible to do a file verification and p7s signature using openssl?</p>

<p><strong>-- edit...</strong></p>

<p>Just to let you know. I got an p7s file with an pdf file. I'd like to know how to validate that.</p>
","<p>Finally, I understand a litte bit about p7s file. This is pretty common to securing e-mail messages, but, I can use p7s files, that contains an PKCS#7 detached signatures with an certificate, to ensure the veracity of a file.</p>

<p>So, I sepparate my explanation, in parts to get easy to explain what I'm doing here. Please, correct me if there's something wrong!</p>

<p><strong>First, Initial Config:</strong></p>

<ol>
<li>create private key and certificate</li>
</ol>

<pre><code>openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
</code></pre>

<ol start=""2"">
<li>Add to trusted certificates, to let openssl allow your certificate as valid</li>
</ol>

<pre><code>sudo cp cert.pem /usr/local/share/ca-certificates/
sudo update-ca-certificates
</code></pre>

<p><strong>Second, Creating an p7s File</strong></p>

<ol>
<li>Run the command below to sign an pdf file, with private key, certificate and generate an p7s file that contains a signed hash of file and the certificate </li>
</ol>

<pre><code>openssl smime -sign -in test.pdf -inkey key.pem -outform DER -binary -signer cert.pem -out test.pdf.p7s
</code></pre>

<p><strong>Finally, Verifying p7s File</strong></p>

<ol>
<li>Now, I have to extract pkcs7 signature from p7s file</li>
</ol>

<pre><code>openssl pkcs7 -inform der -in test.pdf.p7s -out test.pdf.pkcs7
</code></pre>

<ol start=""2"">
<li>After that, I extracted the certificate from pkcs7 file</li>
</ol>

<pre><code>openssl pkcs7 -print_certs -in test.pdf.pkcs7 -out test.pdf.pkcs7.cert
</code></pre>

<ol start=""3"">
<li>Then, verify pkcs7, certificate and file together. Just to validate if that file belongs to that certificate</li>
</ol>

<pre><code>openssl smime -verify -binary -inform PEM -in test.pdf.pkcs7 -content test.pdf -certfile test.pdf.pkcs7.cert -nointern -noverify &gt; /dev/null
</code></pre>

<p>PS.: To remove this certificate, just run the commands below. This will remove and update the certificates</p>

<pre><code>sudo rm -f /usr/local/share/ca-certificates/cert.pem
sudo update-ca-certificates --fresh
</code></pre>
","483","<openssl><ssl-certificate><pkcs#7>","0","0","1","2019-05-07 03:49:47","56015231","0","","2130322","","2019-05-07 00:54:10","2019-05-07 00:22:16",""
"47483413","Invalid PKCS #7 block padding found when using Crypto++","<p>We are using the code below with the Crypto++ library. We need to encrypt and decrypt <code>char*</code>. Encryption is working fine without any issue and we are able to get the cipher text. But getting an error while decrypting as ""invalid pkcs #7 block padding found"". What could be the issue...?</p>

<p>Encryption Block:</p>

<pre><code>char* cspl_crypto::encrypt_rijndael(byte key[], byte iv[], int keysize, char plainText[], int plainTextSize)
{
    vector&lt;byte&gt; cipher;

    std::vector&lt;byte&gt; plain(plainText, plainText + plainTextSize);

    CBC_Mode&lt;AES&gt;::Encryption enc; 
    enc.SetKeyWithIV(key, keysize, iv, keysize);

    // Make room for padding
    cipher.resize(plain.size()+AES::BLOCKSIZE);
    ArraySink cs(&amp;cipher[0], cipher.size());

    ArraySource(plain.data(), plain.size(), true,
        new StreamTransformationFilter(enc, new Redirector(cs)));

    // Set cipher text length now that its known
    cipher.resize(cs.TotalPutLength());
    char returnValue[cipher.size()];
    copy(cipher.begin(), cipher.end(), returnValue);

    return returnValue;
}
</code></pre>

<p>Decyption Block:</p>

<pre><code>char* cspl_crypto::decrypt_rijndael(byte key[], byte iv[], int keysize, char cipher[], int size )
{
    std::vector&lt;byte&gt; v(cipher, cipher + size);
    vector&lt;byte&gt; recover;
    CBC_Mode&lt;AES&gt;::Decryption dec;
    dec.SetKeyWithIV(key, keysize, iv, keysize);

    // Recovered text will be less than cipher text
    recover.resize(v.size());
    ArraySink rs(&amp;recover[0], recover.size());

    ArraySource(v.data(), v.size(), true,
        new StreamTransformationFilter(dec, new Redirector(rs)));

    // Set recovered text length now that its known
    recover.resize(rs.TotalPutLength());

    char returnValue[recover.size()];
    copy(recover.begin(), recover.end(), returnValue);

    return returnValue;
}
</code></pre>
","","481","<c++><encryption><crypto++><pkcs#7>","0","","0","2017-11-27 13:43:36","","2","0","608639","","2017-11-27 13:43:36","2017-11-25 06:55:17",""
"47474980","Invalid PKCS #7 block padding when using Crypto++","<p>We are using cryptopp library. We are using the below coding. Encryption is working file without any issue and we are able to get the cipher text. But getting an error while decrypting as ""Block padding found"". What could be the issue...?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

#include ""cryptlib.h""
#include ""filters.h""
#include ""files.h""
#include ""modes.h""
#include ""hex.h""
#include ""aes.h""
#include ""osrng.h""
using namespace CryptoPP;
using CryptoPP::AutoSeededRandomPool;

class cspl_crypto{

public:
  cspl_crypto();
  byte* generate_block(int size);
  char* encrypt_rijndael(byte[], byte[], int, char*, int);
  char* decrypt_rijndael(byte[], byte[], int, char*, int);
  string readFile();
  void writeFile(string);
};

cspl_crypto::cspl_crypto()
{

}

int main(int argc, char* argv[])
{
  vector&lt;byte&gt; plain;
  cspl_crypto ccrypto;
  AutoSeededRandomPool prng;

    byte key[AES::DEFAULT_KEYLENGTH];
    prng.GenerateBlock(key, sizeof(key));

    byte iv[AES::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
</code></pre>

<p>Converting string to char *</p>

<pre><code>  string str(""testing""); //ccrypto.readFile()
char plainArray[str.size()];
strcpy(plainArray, str.c_str());

char* cipher  = ccrypto.encrypt_rijndael(key, iv, sizeof(key), plainArray, 
sizeof(plainArray));

//char cipherCharArray[cipherText.size()];
// strcpy(cipherCharArray, cipherText.c_str());

char* recover = ccrypto.decrypt_rijndael(key, iv, sizeof(key), cipher, 
sizeof(cipher));

// cout &lt;&lt; ""Recovered text: "" &lt;&lt; recoverText &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>Encryption Block:</p>

<pre><code>char* cspl_crypto::encrypt_rijndael(byte key[], byte iv[], int keysize, char 
plainText[], int plainTextSize){
    vector&lt;byte&gt; cipher;

       std::vector&lt;byte&gt; plain(plainText, plainText + plainTextSize);

    CBC_Mode&lt;AES&gt;::Encryption enc;
enc.SetKeyWithIV(key, keysize, iv, keysize);

// Make room for padding
cipher.resize(plain.size()+AES::BLOCKSIZE);
ArraySink cs(&amp;cipher[0], cipher.size());

ArraySource(plain.data(), plain.size(), true,
        new StreamTransformationFilter(enc, new Redirector(cs)));

// Set cipher text length now that its known
cipher.resize(cs.TotalPutLength());
    char returnValue[cipher.size()];
    copy(cipher.begin(), cipher.end(), returnValue);

    return returnValue;
}
</code></pre>

<p>Decyption Block:</p>

<pre><code>char* cspl_crypto::decrypt_rijndael(byte key[], byte iv[], int keysize, char 
cipher[], int size ){
 std::vector&lt;byte&gt; v(cipher, cipher + size);
 vector&lt;byte&gt; recover;
  CBC_Mode&lt;AES&gt;::Decryption dec;
  dec.SetKeyWithIV(key, keysize, iv, keysize);

  // Recovered text will be less than cipher text
  recover.resize(v.size());
  ArraySink rs(&amp;recover[0], recover.size());

  ArraySource(v.data(), v.size(), true,
    new StreamTransformationFilter(dec, new Redirector(rs)));

  // Set recovered text length now that its known
  recover.resize(rs.TotalPutLength());

        char returnValue[recover.size()];
        copy(recover.begin(), recover.end(), returnValue);

    return returnValue;
}
</code></pre>

<p>Library:</p>

<pre><code>string cspl_crypto::readFile(){

  string line;
  string returnValue = """";
  ifstream myfile (""N07.txt"");
  if (myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
      returnValue +=  line + '\n';
    }
    myfile.close();
  }

  else returnValue = ""Unable to open file""; 

return returnValue;

}
</code></pre>
","","462","<c++><encryption><crypto++><pkcs#7>","0","","0","2017-11-27 13:47:55","","2","","608639","","2017-11-27 13:47:55","2017-11-24 14:07:23",""
"48090064","OpenSSL::PKCS7::PKCS7Error: decrypt error","<pre><code>smime = OpenSSL::PKCS7.read_smime(File.read('encrypted_smime.p7m'))
p_key = OpenSSL::PKey::RSA.new(File.read('pr_key.pem'))
cert = OpenSSL::X509::Certificate.new(File.read('cert.pem'))
smime.decrypt(p_key, cert)
</code></pre>

<p>In the <code>decrypt</code> line above, I am getting the error <em><code>OpenSSL::PKCS7::PKCS7Error: decrypt error</code></em>.</p>

<p>I am not sure why this error is causing, as I am able to decrypt the <code>smime</code> using <code>openssl</code> command line tool properly. Also I have verified that the <code>cert</code> I am using is signed using the same private key that I am using in <code>p_key</code>.</p>

<p>Following is the command which is getting me the expected output -</p>

<pre><code>openssl smime -decrypt -in encrypted_smime.p7m -inkey pr_key.pem -out decrypt_smime.pem
</code></pre>

<p>What is the problem, and how do I fix it?</p>
","","456","<ruby><encryption><openssl><pkcs#7><smime>","0","","0","2018-01-04 07:21:22","","3","","608639","","2018-01-04 07:21:22","2018-01-04 06:49:31",""
"45372197","Which is the equivalent openssl commad to this c# signing code","<p>I have the following code to sign a file:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Pkcs;
using System.Text;
using System.Threading.Tasks;
using Disig.TimeStampClient;
using System.Xml.Linq;

namespace ClientTest
{
    class Program
    {
        static void Main(string[] args)
        {

            var certificate = GetCertificate(""mycert.pfx"", ""password"");
            var data = File.ReadAllBytes(""data.bin"");
            var signature = ComputeSignature(data, certificate);
            SavePemSignature(signature, ""file-signature.pem"");
        }

        static void SavePemSignature(byte[] signature, string filePath)
        {
            var base64 = Convert.ToBase64String(signature);
            using (var writer = new StreamWriter(filePath, false, Encoding.Default))
            {

                writer.WriteLine(""-----BEGIN CMS-----"");
                var pos = 0;
                while (pos &lt; base64.Length)
                {
                    var len = Math.Min(64, base64.Length - pos);
                    var line = base64.Substring(pos, len);
                    writer.WriteLine(line);
                    pos += len;
                }
                writer.WriteLine(""-----END CMS-----"");
            }
        }



        static byte[] ComputeSignature(byte[] data, X509Certificate2 certificate)
        {
            if (data == null) throw new ArgumentNullException(""data"");
            if (certificate == null)
                throw new ArgumentNullException(""certificate"");
            ContentInfo content = new ContentInfo(data);
            SignedCms signedCms = new SignedCms(content, true);
            CmsSigner signer = new CmsSigner(SubjectIdentifierType.SubjectKeyIdentifier, certificate);
            signer.DigestAlgorithm = System.Security.Cryptography.Oid.FromFriendlyName(""SHA256"", System.Security.Cryptography.OidGroup.HashAlgorithm);
            signedCms.ComputeSignature(signer);
            return signedCms.Encode();
        }

        static X509Certificate2 GetCertificate(string filePath, string password)
        {
            X509Certificate2Collection collection = new X509Certificate2Collection();
            collection.Import(filePath, password, X509KeyStorageFlags.PersistKeySet);
            var cert = collection.Cast&lt;X509Certificate2&gt;()
                .FirstOrDefault(x =&gt; x.PrivateKey != null &amp;&amp; x.Extensions.OfType&lt;X509KeyUsageExtension&gt;().FirstOrDefault(c =&gt; (c.KeyUsages &amp; X509KeyUsageFlags.DigitalSignature) == X509KeyUsageFlags.DigitalSignature) != null);
            return cert;
        }
    }
}
</code></pre>

<p>Which is the equivalent openssl command?</p>

<p>I tried the following, but I had not luck, the pem files are different:</p>

<pre><code>openssl cms -in data.bin -sign -signer mycert.pem -md SHA256 -binary -noattr -outform pem -out file-signature.pem
</code></pre>
","","453","<c#><openssl><digital-signature><pkcs#7>","0","","0","2017-07-28 11:24:33","","4","","","","","2017-07-28 11:20:26",""
"30484162","How to use SHA256 during signing with OpenSSL::PKCS7.sign?","<p>I need to use sha256 instead of the default sha1. How to override the same?</p>

<pre><code>pkcs7 = OpenSSL::PKCS7.sign certificate, private_key, content 
signed = OpenSSL::PKCS7.write_smime pkcs7, content
pkcs7 = OpenSSL::PKCS7.encrypt receiver_certificate, signed, OpenSSL::Cipher::Cipher::new(""des-ede3-cbc"")
encrypted_data = OpenSSL::PKCS7.write_smime pkcs7
</code></pre>

<p>This the code that I have tried, I have 2 things to be done. Need to override the signing algorithm and also the encryption algorithm. In the code I have mentioned <code>OpenSSL::Cipher::Cipher::new(""des-ede3-cbc"")</code>, but that I not working, the encryption happening is aes-256-cbc.</p>
","","452","<ruby-on-rails><ruby><openssl><pkcs#7>","1","","0","2015-05-28 20:59:17","","2","","608639","","2015-05-28 20:59:17","2015-05-27 13:37:16",""
"21290975","CMS (PKCS#7) RecipientInfo","<p>I am actually working on a function which should extract RecipientInfo from PKCS7 mime encrypted message. The reason why I want to do this is, that I want to get all mail addresses (or at least the keyids/fingerprints) the message is encrypted for.</p>

<p>Well - I tried something out and created something like this (indata is a *.p7m attachment content, indata_len the strlen of indata):</p>

<pre><code>char *indata;
int indata_len, i;
PKCS7 *p7 = NULL;
BIO *bcont = NULL;
CMS_ContentInfo *cms = NULL;
STACK_OF(CMS_RecipientInfo) *recipients = NULL;
CMS_RecipientInfo *recip = NULL;
BIO *encMessage = BIO_new(BIO_s_mem());
if (encMessage == NULL) {
    goto clean_exit;
}

if(!BIO_write(encMessage, indata, indata_len)) {
    goto clean_exit;
}

cms = SMIME_read_CMS(encMessage,NULL);
if (cms == NULL ) {
    goto clean_exit;
}

recipients = CMS_get0_RecipientInfos(cms);
if (recipients == NULL) {
    goto clean_exit;
}

for (i=0; i&lt; sk_CMS_RecipientInfo_num(recipients); i++) {
    recip = sk_CMS_RecipientInfo_value(recipients, i);
    if( recip == NULL || CMS_RecipientInfo_type(recip) != CMS_RECIPINFO_TRANS ) {
        continue;
    }

    int r;
    ASN1_OCTET_STRING **keyid;
    X509_NAME **issuer;
    ASN1_INTEGER **sno;

    r = CMS_RecipientInfo_ktri_get0_signer_id(recip, keyid, issuer, sno);
    if (!r) {
        continue;
    }

    printf(""Key: %s\n"", keyid);
}
</code></pre>

<p>I get no error (checked with ERR_get_error()) but keyid, issuer and sno stay ""null"", output of above code is:</p>

<blockquote>
  <p>Key: (null)</p>
</blockquote>

<p>So my question is, is it even possible to get that information of an encrypted message or is there just an error in reasoning on my side?</p>

<p>If it is possible to get that data, can someone give me a hint?
If it is not possible, whats the default (best) way to check which private key to use for decryption. Since there can be more than one S/Mime certificate/key for a single user. E.g. creating new key since the old one is lost or just get a new cert/key combination from provider, ...
Imho, looping through all keys could take some time if the message is really big.</p>

<p>Best regards,
Max</p>
","<p>So does nobody know the best way to detect which recipient key has to be used to decrypt the received message if there are more than one? </p>
","451","<c><encryption><openssl><pkcs#7><smime>","2","0","2","2019-04-24 14:16:34","","0","1","1328527","","2014-01-22 18:36:23","2014-01-22 18:26:24",""
"21290975","CMS (PKCS#7) RecipientInfo","<p>I am actually working on a function which should extract RecipientInfo from PKCS7 mime encrypted message. The reason why I want to do this is, that I want to get all mail addresses (or at least the keyids/fingerprints) the message is encrypted for.</p>

<p>Well - I tried something out and created something like this (indata is a *.p7m attachment content, indata_len the strlen of indata):</p>

<pre><code>char *indata;
int indata_len, i;
PKCS7 *p7 = NULL;
BIO *bcont = NULL;
CMS_ContentInfo *cms = NULL;
STACK_OF(CMS_RecipientInfo) *recipients = NULL;
CMS_RecipientInfo *recip = NULL;
BIO *encMessage = BIO_new(BIO_s_mem());
if (encMessage == NULL) {
    goto clean_exit;
}

if(!BIO_write(encMessage, indata, indata_len)) {
    goto clean_exit;
}

cms = SMIME_read_CMS(encMessage,NULL);
if (cms == NULL ) {
    goto clean_exit;
}

recipients = CMS_get0_RecipientInfos(cms);
if (recipients == NULL) {
    goto clean_exit;
}

for (i=0; i&lt; sk_CMS_RecipientInfo_num(recipients); i++) {
    recip = sk_CMS_RecipientInfo_value(recipients, i);
    if( recip == NULL || CMS_RecipientInfo_type(recip) != CMS_RECIPINFO_TRANS ) {
        continue;
    }

    int r;
    ASN1_OCTET_STRING **keyid;
    X509_NAME **issuer;
    ASN1_INTEGER **sno;

    r = CMS_RecipientInfo_ktri_get0_signer_id(recip, keyid, issuer, sno);
    if (!r) {
        continue;
    }

    printf(""Key: %s\n"", keyid);
}
</code></pre>

<p>I get no error (checked with ERR_get_error()) but keyid, issuer and sno stay ""null"", output of above code is:</p>

<blockquote>
  <p>Key: (null)</p>
</blockquote>

<p>So my question is, is it even possible to get that information of an encrypted message or is there just an error in reasoning on my side?</p>

<p>If it is possible to get that data, can someone give me a hint?
If it is not possible, whats the default (best) way to check which private key to use for decryption. Since there can be more than one S/Mime certificate/key for a single user. E.g. creating new key since the old one is lost or just get a new cert/key combination from provider, ...
Imho, looping through all keys could take some time if the message is really big.</p>

<p>Best regards,
Max</p>
","<p>I don't know how to fix your code, but I have a couple of <code>openssl</code> commands and a python script to solve your task:</p>

<p>You can run the following command to get the list of all serial numbers
of the recipient keys in an encrypted file <code>MYMAIL</code>:</p>

<pre><code>openssl smime -pk7out -inform DER -in MYMAIL \
    | openssl pkcs7 -noout -print \
    | grep serial
</code></pre>

<p>This will print the serial number as decimal numbers of all recipients, i.e. serial numbers of certificates for which the file <code>MYMAIL</code> has been encrypted for. For a given certificate file <code>CERTFILE.0</code>, the command</p>

<pre><code>openssl x509 -in CERTFILE.0 -serial -noout
</code></pre>

<p>prints its serial number as a hexadecimal number. Now, you can to combine the serial numbers of the certificates you have with the serial numbers mentioned in <code>MYMAIL</code>.</p>

<p>I've wrote a python script that does this and that can be used to replace the default <a href=""http://www.mutt.org/doc/manual/#smime-decrypt-command"" rel=""nofollow noreferrer"">smime_decrypt_command</a> in mutt, such that when decrypting an E-Mail, the correct private key is chosen for decryption: <a href=""https://github.com/t-wissmann/dotfiles/blob/master/utils/smime-recipient-list.py"" rel=""nofollow noreferrer"">https://github.com/t-wissmann/dotfiles/blob/master/utils/smime-recipient-list.py</a>
For the case that the url breaks, I'm pasting the entire script below.</p>

<pre class=""lang-py prettyprint-override""><code>#!/usr/bin/env python3
""""""
Given an smime encrypted file and some smime certificates,
tell for which of the smime certificates, the encrypted file has been
encrypted for.
""""""

import argparse
import os
import re
import subprocess
import sys
import textwrap

class Openssl:
    def __init__(self, openssl_command):
        self.openssl_command = openssl_command

    def get_certificate_serial_number(self, certificate_file):
        """"""Given a certificate_file filepath, return its serial number as an int""""""
        command = [self.openssl_command, 'x509', '-in', certificate_file, '-serial', '-noout']
        proc = subprocess.run(command, stdout=subprocess.PIPE)
        # output should be of the form 'serial=HEXADECIMALNUMBER'
        try:
            return int(proc.stdout.decode().replace('serial=', ''), 16)
        except ValueError:
             print(""Can not read file: {}"".format(certificate_file), file=sys.stderr)

    def smime_pk7out(self, encrypted_file):
        """"""run smime -pk7out, return its output""""""
        command = [self.openssl_command, 'smime', '-pk7out']
        command += ['-inform', 'DER', '-in', encrypted_file]
        proc = subprocess.run(command, stdout=subprocess.PIPE)
        return proc.stdout.decode()

    def pkcs7_serial_numbers(self, pk7buf):
        """"""extract all serial numbers via openssl pkcs7 -noout -print""""""
        command = [self.openssl_command, 'pkcs7', '-noout', '-print']
        proc = subprocess.run(command, stdout=subprocess.PIPE, text=True, input=pk7buf)
        for match in re.finditer('serial: ([0-9]+)', proc.stdout):
            yield int(match.group(1))

    def list_recipient_serial_numbers(self, encrypted_file):
        """"""Do essentially:
            openssl smime -pk7out -inform DER -in MYMAIL \
                | openssl pkcs7 -noout -print \
                | grep serial
        """"""
        pk7out = self.smime_pk7out(encrypted_file)
        return list(self.pkcs7_serial_numbers(pk7out))

    def smime_decrypt(self, private_key, certificate, filepath, passin='stdin'):
        """"""encrypt the given filepath and print to stdout""""""
        command = [self.openssl_command, 'smime', '-decrypt', '-passin', passin]
        command += ['-inform', 'DER', '-in', filepath]
        command += ['-inkey', private_key]
        command += ['-recip', certificate]
        subprocess.run(command)

def main():
    """"""main""""""
    description = ""Detect recipients of smime encrypted files""
    epilog = textwrap.dedent(r""""""
    E.g. you can decrypt an email with the command that picks the
    private key automatically:

        {} \
            --passin stdin --decrypt \
            --private-key ~/.smime/keys/* \
            -- mymail ~/.smime/certificates/*

    If you use mutt, you can set

    set smime_decrypt_command=""\
        ~/path/to/smime-recipient-list.py --passin stdin --decrypt \
        --private-key ~/.smime/keys/* \
        -- %f ~/.smime/certificates/KEYPREFIX.*""

    where KEYPREFIX is the prefix of your key (i.e. without the .0 or .1 suffix).
    """""".format(sys.argv[0]))
    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('encryptedfile', help='the encrypted file')
    parser.add_argument('certificates',
                        nargs='+',
                        help='the smime certificate files')
    parser.add_argument('--openssl', default='openssl', help='openssl command name')
    parser.add_argument('--list-serials', action='store_true',
                        help='list serial numbers of certifacts')
    parser.add_argument('--print-path', action='store_true',
                        help='print path of recipient certificates')
    parser.add_argument('--private-keys', nargs='*', default=[], help='private keys for decrypt')
    parser.add_argument('--decrypt', action='store_true',
                        help='decrypt using one of the private keys passed.\
                              the key must have the same file name as the certificate.')
    parser.add_argument('--passin', default='stdin',
                        help='default openssl -passin parameter for decrypt')
    args = parser.parse_args()
    openssl = Openssl(args.openssl)

    # get the serial number of every smime-certfile:
    serialnum2cert = {}
    for i in args.certificates:
        serialnum2cert[openssl.get_certificate_serial_number(i)] = i
    if args.list_serials:
        for serialnum, keyfile in serialnum2cert.items():
            print(""{} --&gt; {}"".format(keyfile, serialnum))
    recipients = openssl.list_recipient_serial_numbers(args.encryptedfile)
    if args.print_path or args.decrypt:
        matching_keys = []
        for i in recipients:
            if i in serialnum2cert:
                matching_keys.append(serialnum2cert[i])
    if args.print_path:
        for i in matching_keys:
            print(i)
    if args.decrypt:
        private_keys = {}
        for filepath in args.private_keys:
            private_keys[os.path.basename(filepath)] = filepath
        key_found = None
        for fp in matching_keys:
            if os.path.basename(fp) in private_keys:
                priv_key_path = private_keys[os.path.basename(fp)]
                # print(""We can use {} and {}"".format(priv_key_path, fp))
                key_found = (priv_key_path, fp)
        if key_found is None:
            print(""No matching private key found."", file=sys.stderr)
            sys.exit(1)
        openssl.smime_decrypt(key_found[0], key_found[1],
                              args.encryptedfile, passin=args.passin)

if __name__ == ""__main__"":
    main()
</code></pre>
","451","<c><encryption><openssl><pkcs#7><smime>","2","0","2","2019-04-24 14:16:34","","0","1","1328527","","2014-01-22 18:36:23","2014-01-22 18:26:24",""
"47771005","PKCS#7 signature in PHP using PKCS#11 without a CLI call","<p>Is there a way to create a PKCS#7 (S/MIME) signature with a PKCS#11 compliant HSM device (card reader) using pure PHP, i.e. without explicit shell command call, e.g. using <a href=""http://php.net/manual/en/book.openssl.php"" rel=""nofollow noreferrer"">PHP OpenSSL</a> library or some other glue?</p>

<p>I can successfully create a PKCS#7 signature using CLI <code>openssl</code> with PKCS#11 engine like so:</p>

<pre class=""lang-php prettyprint-override""><code>putenv('PIN='.$secret_card_pin);
shell_exec(""export PIN; OPENSSL_CONF=openssl.cnf openssl smime -sign -engine pkcs11 -md sha1 -binary -in {$tmpFileIn} -out {$tmpFileOut} -outform der -keyform engine -inkey id_ed0007 -signer pubcert.pem"");
</code></pre>

<p>I want to clean this but it seems impossible using pure PHP because as far as I can tell <a href=""http://php.net/manual/en/function.openssl-pkcs7-sign.php"" rel=""nofollow noreferrer"">openssl_pkcs7_sign()</a> function can only be used with a private key file without any support for <code>pkcs11-engine</code> provided keys. Am I missing something?</p>
","<p>There is not, while there are PKCS#11 bindings for many languages there is not one for PHP. </p>

<p>You would need this, then you could then construct a PKCS#7 and sign it using that library. </p>

<p>Unfortunately absent that you will need to use a CLI.</p>
","451","<php><openssl><pkcs#11><pkcs#7><opensc>","0","1","1","2017-12-19 13:21:27","47843316","0","","1347707","","2017-12-19 13:21:27","2017-12-12 11:01:59",""
"15526568","PKCS7_Sign does not sign","<p>here is part of code:</p>

<pre><code>flags = 0;
flags |= PKCS7_BINARY;
flags |= PKCS7_NOATTR;
pkcs7 = PKCS7_sign( cert, pkey, NULL, bio_data, flags );
if ( !pkcs7 )
    return;

iErr = i2d_PKCS7_bio( bio_out_der, pkcs7 );
if ( iErr != 1 )
    return;
</code></pre>

<p>There are no errors when running, but i do not understand why output data does not contain sign. Output data is correct PKCS7 signedData structure, but it has prepared for singing data instead of sign itself. This is example of data which is in the end of output PKCS7 structure:</p>

<pre><code>04400001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF003021300906052B0E03021A0500041440BD001563085FC35165329EA1FF5C5ECBDBBEEF
</code></pre>

<p>i.e. this is OID of SHA1, SHA1 of data to be signed, padding, i.e. data which must be signed with private key. Why signing is not performed?</p>
","","449","<openssl><sign><pkcs#7>","0","","0","2013-03-20 14:38:41","","2","1","35060","","2013-03-20 14:38:41","2013-03-20 14:37:02",""
"26661153","Can I use AES128/ECB/PKCS7 encryption with Java 1.4","<p>I have a string holding some parameters that needs to be encrypted in AES-128 in ECB mode with PKCS7 padding, and then Base-64 encoded.</p>

<p>My code base is Java 1.4. Is this possible with Java 1.4 api ?</p>
","<p>Yes, you can. You would need a separate library for the base 64 encoding/decoding though. For the encryption you can use <code>Cipher.getInstance(""AES/ECB/PKCS5Padding"")</code>. Note that PKCS#5 padding <a href=""https://crypto.stackexchange.com/q/9043/1172"">is the same as PKCS#7 padding</a>.</p>
","449","<encryption><aes><pkcs#7><java1.4><ecb>","0","0","1","2014-11-01 22:37:49","","1","2","","","","2014-10-30 18:55:11",""
"44639175","Bouncycastle - how to distinguish attached from detached signature file programmatically","<p>I am working on an application that is used to sign/verify files according to pkcs7. I am using bouncycastle. The problem is that whenever i pass in (to verify!) a file containing a signature i cannot find a way to distinguish whether the file contains both signature and signed data or just a signature. The point is to ask the user to select a second file if the first one contains only signature /and display appropriate error/.
Is there any way around this problem? </p>
","<p>To construct the CMSSignedData (the first time, before you know whether it has encapsulated content), just use the CMSSignedData(byte[]) constructor, where byte[] is the full contents of the file.</p>

<p>Once you have the CMSSignedData instance, then getSignedContent() simply returns null if the content was not encapsulated.</p>

<p>Once you have the basics working, if you are dealing with very large files, you may want to look at CMSSignedDataParser as a more advanced option that will avoid reading in the entire file.</p>
","443","<bouncycastle><pkcs#7>","0","2","1","2017-06-20 07:27:31","44646517","3","","","","","2017-06-19 20:14:48",""
"33178788","M2Crypto: read PKCS#7 structure in DER format?","<p>M2Crypto SMIME object has methods to load itself from PKCS#7 file in PEM format:</p>

<pre><code>smime_object = SMIME.load_pkcs7('file.pem')
</code></pre>

<p>I do not see any method to load from PKCS#7 file in DER format. How can this be done?</p>
","<p>In order to load a PKCS#7 in DER format, you should use an intermediate BIO like :</p>

<pre><code>file = open('file.der')
bio = BIO.File(file)
smime_object = SMIME.PKCS7(m2.pkcs7_read_bio_der(bio._ptr()))
</code></pre>
","427","<python><pkcs#7><m2crypto><smime><der>","0","0","2","2017-05-05 23:08:58","34696935","0","","","","","2015-10-16 20:10:46",""
"33178788","M2Crypto: read PKCS#7 structure in DER format?","<p>M2Crypto SMIME object has methods to load itself from PKCS#7 file in PEM format:</p>

<pre><code>smime_object = SMIME.load_pkcs7('file.pem')
</code></pre>

<p>I do not see any method to load from PKCS#7 file in DER format. How can this be done?</p>
","<p>A function <code>SMIME.load_pkcs7_der()</code> has been added in M2Crypto 0.26.0.</p>
","427","<python><pkcs#7><m2crypto><smime><der>","0","1","2","2017-05-05 23:08:58","34696935","0","","","","","2015-10-16 20:10:46",""
"3995894","Update original data in detached signature created by crypto.signText","<p>I got the BASE64 encoded text by using crypto.signText method. but that dose not contain original to data which is signed.</p>

<p>can anyone tell me how to update that encoded text to attach data to it.</p>
","<p>Done.</p>

<pre><code>CMSSignedData csd = new CMSSignedData(byteArr);

if (csd.getSignedContent() == null) {
            byte[] contentBytes;
            if (!isIE) {
                contentBytes = data.getBytes();
            } else {
                //UnicodeLittleUnmarked = Sixteen-bit Unicode Transformation Format, little-endian byte order 
                contentBytes = data.getBytes(""UnicodeLittleUnmarked"");
            }
            CMSProcessable cmsProcesableContent = new CMSProcessableByteArray(contentBytes);
            csd = new CMSSignedData(cmsProcesableContent, byteArr);
        }
</code></pre>
","425","<digital-signature><pkcs#7>","1","1","1","2010-10-28 06:03:52","4040227","1","0","","","","2010-10-22 10:21:22",""
"43472002","Sign an S/MIME message with openssl or pure node.js","<p>I received <code>.pem</code>, <code>.cer</code>, <code>.p12</code> files and related passPhrase for these from  from Bank tech team .</p>

<p>I should sign a string like this:</p>

<pre><code>8ad281ad-1fdf-4ef9-a308-31388b617c3c-b6767a8a-dbc7-4be0-86ff-d27b47ed0df3
</code></pre>

<p>to generate a valid signed-data like this:</p>

<pre><code>MIME-Version: 1.0
Content-Disposition: attachment; filename=""smime.p7m""
Content-Type: application/x-pkcs7-mime; smime-type=signed-data; name=""smime.p7m""
Content-Transfer-Encoding: base64

MIIHnQYJKoZIhvcNAQ...cQfLnkhnZGwg7d
</code></pre>

<p>I've tried using <code>openssl</code> commands like this:</p>

<pre><code>openssl smime -sign -nosigs -in msg.txt -out out.txt -passin pass:SOMEPASS -signer certificate.pem
</code></pre>

<p>But it does not generate like what I mentioned above.</p>

<pre><code>MIME-Version: 1.0
Content-Type: multipart/signed; protocol=""application/x-pkcs7-signature""; micalg=""sha-256""; boundary=""----1F579F2DD2078A7D3BE2F25D30C33EFC""

This is an S/MIME signed message

------1F579F2DD2078A7D3BE2F25D30C33EFC
8ad281ad-1fdf-4ef9-a308-31388b617c3c-b6767a8a-dbc7-4be0-86ff-d27b47ed0df3
------1F579F2DD2078A7D3BE2F25D30C33EFC
Content-Type: application/x-pkcs7-signature; name=""smime.p7s""
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=""smime.p7s""

MIIHUAYJKoZIhvcNAQc...Nwr/k3x
EkGgGg==

------1F579F2DD2078A7D3BE2F25D30C33EFC--
</code></pre>

<p>Also tried this:</p>

<pre><code>openssl smime -encrypt -nosigs -in msg.txt -out out.txt -passin pass:SOMEPASS  certificate.pem
</code></pre>

<p>and I receive this which is clearly different <code>smime-type</code> in header:</p>

<pre><code>MIME-Version: 1.0
Content-Disposition: attachment; filename=""smime.p7m""
Content-Type: application/x-pkcs7-mime; smime-type=enveloped-data; name=""smime.p7m""
Content-Transfer-Encoding: base64

MIIBewYJKoZIhvc...
</code></pre>

<p>And I've tried several NodeJs packages to do this sign in pure node but as I don't know much about this field, can not get result.</p>

<p>I get results with PHP sample code I received from bank, here is sample:</p>

<pre><code>openssl_pkcs7_sign(realpath(""msg.txt""), realpath(""signed.txt""), ""file://C:/myCert/certificate.pem"",
    array(""file://C:/myCert/certificate.pem"", ""SOMEPASS""),
    array(),PKCS7_NOSIGS
);
</code></pre>
","","423","<node.js><openssl><digital-signature><pkcs#7><smime>","2","","0","2017-04-22 05:03:26","","0","1","1028632","","2017-04-22 05:03:26","2017-04-18 12:21:35",""
"53527693","How to convert PEM certificate chain to PKCS7 in native Go?","<p>I am looking for any practical method for converting a <strong>PEM</strong>-encoded x509 certificate chain into <strong>PKCS7</strong> format in the Go language.</p>

<p>This openssl command line illustrates what I am trying to achieve in native Go.</p>

<pre><code>openssl crl2pkcs7 -nocrl -certfile certificate-chain.pem &gt; pkcs7.pem
</code></pre>

<p>I am able to run the openssl command line from within a Go program using the <code>exec</code> package, but I am looking for an efficient solution in Go.</p>

<p>The input file contains a sequence of certificates in PEM format, starting with -----BEGIN CERTIFICATE-----\n and <code>base64</code> encoded data.  The desired output needs to be in PKCS7 format, starting with -----BEGIN PKCS7-----.</p>

<p>I am looking for an efficient solution, because I am not actually reading and writing files, but handling lots of certificates as strings in memory.</p>

<p>Any suggestions appreciated.</p>
","<p>First of all, just to be clear, both the input and output you are requesting are in PEM format. The input is a sequence of PEM-encoded X509 certificates, and the output you request is a PEM-encoded PKCS#7 degenerate ""certs only"" structure. OpenSSL can output the raw ASN.1 DER for the PKCS#7 structure if you give it the <code>-outform DER</code> option, but it will PEM-encode its output by default.</p>

<p>There are a number of Go packages out there that can build this kind of PKCS#7 structure. The following example uses <a href=""https://godoc.org/github.com/fullsailor/pkcs7"" rel=""nofollow noreferrer"">this one</a>.</p>

<p>If you have your input in a PEM-encoded string, and you want your output to be a PEM-encoded string, then the basic steps are:</p>

<ol>
<li>Extract each PEM-block from your input, decode it, and collect its raw bytes.</li>
<li>Create a PKCS7 structure from those bytes.</li>
<li>PEM-encode that structure to an array of bytes.</li>
<li>Convert that array of bytes to a string.</li>
</ol>

<p>Here's a simple example:</p>

<pre><code>package main

import (
    ""encoding/pem""
    ""fmt""
    ""log""

    ""github.com/fullsailor/pkcs7""
)

var certChain = `-----BEGIN CERTIFICATE-----
MIIEKjCCAhKgAwIBAgIQVUzJj/mbV3n8PS0CHQTfzzANBgkqhkiG9w0BAQsFADBk
MQswCQYDVQQGEwJVUzEWMBQGA1UECBMNTmV3IEhhbXBzaGlyZTETMBEGA1UEBxMK
UG9ydHNtb3V0aDEoMCYGA1UEAxMfU2ltcGxlQ0EgTm9uLVB1YmxpYyBUZXN0IElz
c3VlcjAeFw0xODExMjgyMzMwNDVaFw0xOTAyMjYyMzMwNDVaMBUxEzARBgNVBAMT
CkphbmUgU21pdGgwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC3iiYS
42eqJOJfF81MekU0w+8UTQgL9D9fh0BYAljgvKx1jvlg6l2CX1OPfNMxOWjDo7DB
ICRrPKxq/FH/tsPumzNWLp6Fsu559MgzkudzRHDVdCF0pa/qujeJeiDLXs7mtekc
rKW6SyrKceknSoPCAwnWr/CEBL09pG3lef7vUMfmkuSMW+L7upHpL/sHyqnyoAnh
9b7IeeQ832rg7b7VOX6zmDcCr6qndhXt6L/neidFbX736wH+fF+iKyTw7XJNflqT
YvifUvnI9rGriDZdAPVa1/a94tKHbFzil/2UEDzNo61mcucbcHqhUL4Iezpi/s5I
iyXqM9oMoMQKPSAlAgMBAAGjJzAlMAsGA1UdDwQEAwIDqDAWBgNVHSUBAf8EDDAK
BggrBgEFBQcDAjANBgkqhkiG9w0BAQsFAAOCAgEAXe8ipocWVv+Bc78ci6QjAb6N
1DN0n9X7Ai6nvekDP1hqvNUhqKmKhV8pEL7GapyH7Rz3shYJyLEwlV0zUgS3/Uvv
38Ae5xl2uQLl4eoMz4T9NXewZyRmeSyfwz1za93wKGKz6IhoYRepI4EwaPjYowok
nNrocMRFuZHeUysSdLNXtgxKvtRYFI63rjNikJNM7C8mKOzeVobdegZipALxonDb
FcVUhikyu6YkT3Rc5X/oW5I2LfCl9v8mhjbuIPmLsZJyTcDBK81AFIX8g7Iavb8L
buRBIgSTShQISPrunnxbcQg3YimdNCn0n5llDmUP3jxWqiuvEZ7pSAUU6aVY7x8B
fAq9utHTz63FqVCLyl8us/oYZmeYpxpw5HSFhqwujKzJhvO1raaoU+3zsybrsxAy
tzgm05WucSoMTjhOBZFr8OVQxKnMHwgNudwsxuXqqFhUBV5JLkhxWIZxUoH3fhgz
9b2yH0pf/Vgurglfk/onMYR33B0grAT6/NW294oUOKCP9jdwNPQr+eRgoDU6hZ/P
UZMfr+dhVpIHPouSKCrkNXKLrBLFZsg8UiyMXiNB27OBK+mWCH8gUv5EPjW1PUCV
338v19sruqtHRRs7ZnWYMMxGeWosJ4eK/ysTjCespenOeC1HBVEnHQE+H/JvN7Pc
GN3nlK0GRJl5j3y6nmw=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEKzCCAhOgAwIBAgIRAKju/EHi+Hw4PQZENuj9F1AwDQYJKoZIhvcNAQELBQAw
ZDELMAkGA1UEBhMCVVMxFjAUBgNVBAgTDU5ldyBIYW1wc2hpcmUxEzARBgNVBAcT
ClBvcnRzbW91dGgxKDAmBgNVBAMTH1NpbXBsZUNBIE5vbi1QdWJsaWMgVGVzdCBJ
c3N1ZXIwHhcNMTgxMTI4MjMzMTQ2WhcNMTkwMjI2MjMzMTQ2WjAVMRMwEQYDVQQD
EwpGcmVkIEpvbmVzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt4om
EuNnqiTiXxfNTHpFNMPvFE0IC/Q/X4dAWAJY4LysdY75YOpdgl9Tj3zTMTlow6Ow
wSAkazysavxR/7bD7pszVi6ehbLuefTIM5Lnc0Rw1XQhdKWv6ro3iXogy17O5rXp
HKyluksqynHpJ0qDwgMJ1q/whAS9PaRt5Xn+71DH5pLkjFvi+7qR6S/7B8qp8qAJ
4fW+yHnkPN9q4O2+1Tl+s5g3Aq+qp3YV7ei/53onRW1+9+sB/nxfoisk8O1yTX5a
k2L4n1L5yPaxq4g2XQD1Wtf2veLSh2xc4pf9lBA8zaOtZnLnG3B6oVC+CHs6Yv7O
SIsl6jPaDKDECj0gJQIDAQABoycwJTALBgNVHQ8EBAMCA6gwFgYDVR0lAQH/BAww
CgYIKwYBBQUHAwIwDQYJKoZIhvcNAQELBQADggIBAImzRaStB2tb0tCs0x9d0NTy
Z8Q3Fkexvt816xfBGiRS1AtetnV59sJKJvPe9qRoKQDRk7Q+/HO80Iu1o7dWfp7S
h29g9a1uhIVCY1ijr8cW8La9H/OF2KxgGX8TOldrftUl60sA3riJ7lQYOW0NkU+o
wrRsIlMCLhP8NZYjKn2Wf066JtV6Z4Be2CgVpaXkuTIE3h4BOv0kG9OsMvuRMqZw
n7z6EqhduSujwHevB2dIZgixacnE5v5hnpZm1ujzlgbAAZWh7uFthktXL5fBbkW7
heoOv320GOTvqkGVVlc4Pac5kR+P6JWfCDETfIVvtyTtfei5tDm606rBa3BHtiRu
kO4m63fnYziUzRXrF/bDcAzVx5jHQWugpxeI5UcaF6e5psOvhlP6O0sIeN6ThY/I
f+zZN6kf8eZ0OYk+61fVPbbpkF05AFhKkduIRfywUy5+iXrPK4iuQxhM/kRCO0H3
rxXcDlc+9Ol1JiJNNF2lV8+U1APsPFK0gnrxoYLFyRsejCiV8/D67v8oEk0gfiMm
/uZUhC2jYJ05lfK7aGV72Cf82g46zAuNAiH4zwvmxvC/2tcqcaYFyK15D1dQGqOg
z3LR6viX/ncO72ywQWgjRc5hdR5vLinIEXTRlNKm4EW+AoLY3x+Erhmq69EEnGMr
4/GUXRuNB7Is+lFM3JYE
-----END CERTIFICATE-----`

func main() {

    // Decode each PEM block in the input and append the ASN.1
    // DER bytes for each certificate therein to the data slice.

    input := []byte(certChain)
    data := []byte{}

    for len(input) &gt; 0 {
        var block *pem.Block
        block, input = pem.Decode(input)
        data = append(data, block.Bytes...)
    }

    // Build a PKCS#7 degenerate ""certs only"" structure from
    // that ASN.1 certificates data.

    var err error
    data, err = pkcs7.DegenerateCertificate(data)
    if err != nil {
        log.Fatalf(""couldn't create degenerate PKCS7 object: %v"", err)
    }

    // Convert the PKCS#7 structure to a PEM-encoded string.

    pemString := string(pem.EncodeToMemory(&amp;pem.Block{
        Type:  ""PKCS7"",
        Bytes: data,
    }))

    // Print the string, or do whatever you want with it.

    fmt.Printf(""%s"", pemString)
}
</code></pre>

<p>and to show it gives the same output as your OpenSSL command:</p>

<pre><code>paul@mac:certstop7$ cat certs.pem
-----BEGIN CERTIFICATE-----
MIIEKjCCAhKgAwIBAgIQVUzJj/mbV3n8PS0CHQTfzzANBgkqhkiG9w0BAQsFADBk
MQswCQYDVQQGEwJVUzEWMBQGA1UECBMNTmV3IEhhbXBzaGlyZTETMBEGA1UEBxMK
UG9ydHNtb3V0aDEoMCYGA1UEAxMfU2ltcGxlQ0EgTm9uLVB1YmxpYyBUZXN0IElz
c3VlcjAeFw0xODExMjgyMzMwNDVaFw0xOTAyMjYyMzMwNDVaMBUxEzARBgNVBAMT
CkphbmUgU21pdGgwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC3iiYS
42eqJOJfF81MekU0w+8UTQgL9D9fh0BYAljgvKx1jvlg6l2CX1OPfNMxOWjDo7DB
ICRrPKxq/FH/tsPumzNWLp6Fsu559MgzkudzRHDVdCF0pa/qujeJeiDLXs7mtekc
rKW6SyrKceknSoPCAwnWr/CEBL09pG3lef7vUMfmkuSMW+L7upHpL/sHyqnyoAnh
9b7IeeQ832rg7b7VOX6zmDcCr6qndhXt6L/neidFbX736wH+fF+iKyTw7XJNflqT
YvifUvnI9rGriDZdAPVa1/a94tKHbFzil/2UEDzNo61mcucbcHqhUL4Iezpi/s5I
iyXqM9oMoMQKPSAlAgMBAAGjJzAlMAsGA1UdDwQEAwIDqDAWBgNVHSUBAf8EDDAK
BggrBgEFBQcDAjANBgkqhkiG9w0BAQsFAAOCAgEAXe8ipocWVv+Bc78ci6QjAb6N
1DN0n9X7Ai6nvekDP1hqvNUhqKmKhV8pEL7GapyH7Rz3shYJyLEwlV0zUgS3/Uvv
38Ae5xl2uQLl4eoMz4T9NXewZyRmeSyfwz1za93wKGKz6IhoYRepI4EwaPjYowok
nNrocMRFuZHeUysSdLNXtgxKvtRYFI63rjNikJNM7C8mKOzeVobdegZipALxonDb
FcVUhikyu6YkT3Rc5X/oW5I2LfCl9v8mhjbuIPmLsZJyTcDBK81AFIX8g7Iavb8L
buRBIgSTShQISPrunnxbcQg3YimdNCn0n5llDmUP3jxWqiuvEZ7pSAUU6aVY7x8B
fAq9utHTz63FqVCLyl8us/oYZmeYpxpw5HSFhqwujKzJhvO1raaoU+3zsybrsxAy
tzgm05WucSoMTjhOBZFr8OVQxKnMHwgNudwsxuXqqFhUBV5JLkhxWIZxUoH3fhgz
9b2yH0pf/Vgurglfk/onMYR33B0grAT6/NW294oUOKCP9jdwNPQr+eRgoDU6hZ/P
UZMfr+dhVpIHPouSKCrkNXKLrBLFZsg8UiyMXiNB27OBK+mWCH8gUv5EPjW1PUCV
338v19sruqtHRRs7ZnWYMMxGeWosJ4eK/ysTjCespenOeC1HBVEnHQE+H/JvN7Pc
GN3nlK0GRJl5j3y6nmw=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEKzCCAhOgAwIBAgIRAKju/EHi+Hw4PQZENuj9F1AwDQYJKoZIhvcNAQELBQAw
ZDELMAkGA1UEBhMCVVMxFjAUBgNVBAgTDU5ldyBIYW1wc2hpcmUxEzARBgNVBAcT
ClBvcnRzbW91dGgxKDAmBgNVBAMTH1NpbXBsZUNBIE5vbi1QdWJsaWMgVGVzdCBJ
c3N1ZXIwHhcNMTgxMTI4MjMzMTQ2WhcNMTkwMjI2MjMzMTQ2WjAVMRMwEQYDVQQD
EwpGcmVkIEpvbmVzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt4om
EuNnqiTiXxfNTHpFNMPvFE0IC/Q/X4dAWAJY4LysdY75YOpdgl9Tj3zTMTlow6Ow
wSAkazysavxR/7bD7pszVi6ehbLuefTIM5Lnc0Rw1XQhdKWv6ro3iXogy17O5rXp
HKyluksqynHpJ0qDwgMJ1q/whAS9PaRt5Xn+71DH5pLkjFvi+7qR6S/7B8qp8qAJ
4fW+yHnkPN9q4O2+1Tl+s5g3Aq+qp3YV7ei/53onRW1+9+sB/nxfoisk8O1yTX5a
k2L4n1L5yPaxq4g2XQD1Wtf2veLSh2xc4pf9lBA8zaOtZnLnG3B6oVC+CHs6Yv7O
SIsl6jPaDKDECj0gJQIDAQABoycwJTALBgNVHQ8EBAMCA6gwFgYDVR0lAQH/BAww
CgYIKwYBBQUHAwIwDQYJKoZIhvcNAQELBQADggIBAImzRaStB2tb0tCs0x9d0NTy
Z8Q3Fkexvt816xfBGiRS1AtetnV59sJKJvPe9qRoKQDRk7Q+/HO80Iu1o7dWfp7S
h29g9a1uhIVCY1ijr8cW8La9H/OF2KxgGX8TOldrftUl60sA3riJ7lQYOW0NkU+o
wrRsIlMCLhP8NZYjKn2Wf066JtV6Z4Be2CgVpaXkuTIE3h4BOv0kG9OsMvuRMqZw
n7z6EqhduSujwHevB2dIZgixacnE5v5hnpZm1ujzlgbAAZWh7uFthktXL5fBbkW7
heoOv320GOTvqkGVVlc4Pac5kR+P6JWfCDETfIVvtyTtfei5tDm606rBa3BHtiRu
kO4m63fnYziUzRXrF/bDcAzVx5jHQWugpxeI5UcaF6e5psOvhlP6O0sIeN6ThY/I
f+zZN6kf8eZ0OYk+61fVPbbpkF05AFhKkduIRfywUy5+iXrPK4iuQxhM/kRCO0H3
rxXcDlc+9Ol1JiJNNF2lV8+U1APsPFK0gnrxoYLFyRsejCiV8/D67v8oEk0gfiMm
/uZUhC2jYJ05lfK7aGV72Cf82g46zAuNAiH4zwvmxvC/2tcqcaYFyK15D1dQGqOg
z3LR6viX/ncO72ywQWgjRc5hdR5vLinIEXTRlNKm4EW+AoLY3x+Erhmq69EEnGMr
4/GUXRuNB7Is+lFM3JYE
-----END CERTIFICATE-----
paul@mac:certstop7$ openssl crl2pkcs7 -nocrl -certfile certs.pem &gt; openssl_p7.pem
paul@mac:certstop7$ ./certstop7 &gt; generated_p7.pem
paul@mac:certstop7$ diff generated_p7.pem openssl_p7.pem
paul@mac:certstop7$ 
</code></pre>
","416","<ssl><go><pem><pkcs#7>","0","2","1","2018-11-29 00:19:58","53530077","0","","","","","2018-11-28 20:36:59",""
"39215818","c# - PKCS - Exporting to readable format","<p>I have to sign and encrypt a message using PKCS:</p>

<pre><code>EnvelopedCms envelopedCms = ...
// Add recipients
envelopedCms.Encrypt(recip1);
//
msg = envelopedCms.Encode();
</code></pre>

<p>I need the results in the format:</p>

<pre><code>-----BEGIN PKCS7-----
base64 encoded msg
-----END PKCS7-----
</code></pre>

<p>Do you know how to export in this format in c#/.net?</p>

<p>Thanks</p>
","<p>Is this what you need?  (from <a href=""https://stackoverflow.com/questions/18225897/api-secured-by-pkcs7-cryptographic-message?rq=1"">this post</a>)</p>

<pre><code>SignedCms signedCms = new SignedCms();
resultString = resultString.Replace(""\n"", """").Replace(""-----BEGIN PKCS7-----"", """").Replace(""-----END PKCS7-----"", """");
signedCms.Decode(Convert.FromBase64String(resultString));
</code></pre>

<p>To encode a string to a base64 string in C# .NET you can do this:
(I've added this because your question is unclear but states ""base64 encoded msg"")</p>

<pre><code>// Get the bytes.
var bytes = System.Text.Encoding.UTF8.GetBytes(yourString);

return System.Convert.ToBase64String(bytes);
</code></pre>
","405","<c#><pkcs#7>","-1","0","1","2016-08-29 22:11:44","","1","","","","","2016-08-29 21:57:52",""
"37814759","Sign data using CMS based format in UWP","<p>I need to transfer data between WCF service and UWP app. So I sign and verify data after receive data. I have a problem. The signed data result in WCF is differences in UWP app.(Of course, I can't verify data)  This is my source code:</p>

<pre><code>// WCF
private String Sign(string Message)
{
    ContentInfo cont = new ContentInfo(Encoding.UTF8.GetBytes(Message));
    SignedCms signed = new SignedCms(cont, true);
    _SignerCert = new X509Certificate2(""Path"", ""Password"");
    CmsSigner signer = new CmsSigner(_SignerCert);
    signer.IncludeOption = X509IncludeOption.None;
    signed.ComputeSignature(signer);
    return Convert.ToBase64String(signed.Encode());
}
</code></pre>

<p>and</p>

<pre><code>//UWP
public static async Task&lt;String&gt; Sign(String Message)
{
    StorageFolder appInstalledFolder = Windows.ApplicationModel.Package.Current.InstalledLocation;
    var CerFile = await appInstalledFolder.GetFileAsync(@""Assets\PAYKII_pkcs12.p12"");
    var CerBuffer = await FileIO.ReadBufferAsync(CerFile);
    string CerData = CryptographicBuffer.EncodeToBase64String(CerBuffer);

    await CertificateEnrollmentManager.ImportPfxDataAsync
        (CerData, ""Password"",
        ExportOption.NotExportable,
        KeyProtectionLevel.NoConsent,
        InstallOptions.None,
        ""RASKey2"");

    var Certificate = (await CertificateStores.FindAllAsync(new CertificateQuery() { FriendlyName = ""RASKey2"" })).Single();

    IInputStream pdfInputstream;
    InMemoryRandomAccessStream originalData = new InMemoryRandomAccessStream();
    await originalData.WriteAsync(CryptographicBuffer.ConvertStringToBinary(Message,BinaryStringEncoding.Utf8));
    await originalData.FlushAsync();
    pdfInputstream = originalData.GetInputStreamAt(0);
    CmsSignerInfo signer = new CmsSignerInfo();
    signer.Certificate = Certificate;
    signer.HashAlgorithmName = HashAlgorithmNames.Sha1;
    IList&lt;CmsSignerInfo&gt; signers = new List&lt;CmsSignerInfo&gt;();

    signers.Add(signer);

    IBuffer signature = await CmsDetachedSignature.GenerateSignatureAsync(pdfInputstream, signers, null);
    return CryptographicBuffer.EncodeToBase64String(signature);
}
</code></pre>
","<p>I stumbled over your post, because I wanted to achieve something very similar: sign a message in an UWP app and verifying the signature in my WCF Service. After reading <a href=""http://www.codeproject.com/Tips/679142/How-to-sign-data-with-SignedCMS-and-signature-chec"" rel=""nofollow"">http://www.codeproject.com/Tips/679142/How-to-sign-data-with-SignedCMS-and-signature-chec</a>, I finally managed to make this fly (with a detached signature, ie you need to have the original message for verification):</p>

<p>UWP:</p>

<pre><code>public async static Task&lt;string&gt; Sign(Windows.Security.Cryptography.Certificates.Certificate cert, string messageToSign) {
    var messageBytes = Encoding.UTF8.GetBytes(messageToSign);
    using (var ms = new MemoryStream(messageBytes)) {
        var si = new CmsSignerInfo() {
            Certificate = cert,
            HashAlgorithmName = HashAlgorithmNames.Sha256
        };

        var signature = await CmsDetachedSignature.GenerateSignatureAsync(ms.AsInputStream(), new[] { si }, null);
        return CryptographicBuffer.EncodeToBase64String(signature);
    }
}
</code></pre>

<p>WCF:</p>

<pre><code>public static bool Verify(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, string messageToCheck, string signature) {
    var retval = false;

    var ci = new ContentInfo(Encoding.UTF8.GetBytes(messageToCheck));
    var cms = new SignedCms(ci, true);
    cms.Decode(Convert.FromBase64String(signature));

    // Check whether the expected certificate was used for the signature.
    foreach (var s in cms.SignerInfos) {
        if (s.Certificate.Equals(cert)) {
            retval = true;
            break;
        }
    }

    // The following will throw if the signature is invalid.
    cms.CheckSignature(true);

    return retval;
}
</code></pre>

<p>The trick for me was to understand that the desktop <code>SignedCms</code> needs to be constructed with the original content and then decode the signature to perform the verification.</p>
","386","<c#><wcf><uwp><sign><pkcs#7>","1","1","1","2016-08-20 16:36:47","","0","1","1466583","","2016-06-14 14:27:08","2016-06-14 14:22:43",""
"38794056","Verifying a PKCS#7 Signature with BouncyCastle in Scala","<p>I need to verify a detached PKCS#7 Signature in Scala using BouncyCastle (version 1.54). The signed data are not enveloped in the PKCS#7 signature.</p>

<p>The PKCS#7 signature is performed using a single certificate.</p>

<p>I wrote a simple function based on the Javadoc of BouncyCastle to verify the signature:</p>

<pre><code>      def verify(data: File): Boolean = {
        val signedData = new CMSSignedData(new CMSProcessableFile(data), Base64.decode(this.value))
        val certStore = signedData.getCertificates
        val signers = signedData.getSignerInfos.getSigners
        val signer = signers.iterator.next
        val certs = certStore.getMatches(signer.getSID)
        val cert = certs.iterator.next.asInstanceOf[X509CertificateHolder]
        signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert))
      }
</code></pre>

<p>When I compile the code , I obtain the following error:</p>

<pre><code>[error] LogVerifier.scala:26: type mismatch;
[error]  found   : org.bouncycastle.cms.SignerId
[error]  required: org.bouncycastle.util.Selector[?0]
[error]     val certs = certStore.getMatches(signer.getSID)
</code></pre>

<p>Could you please help me solve this compilation issue?</p>

<p>Thanks in advance!</p>
","<p>The problem is that <code>CMSSignedData.getCertificates</code> returns an untyped <code>Store</code>:</p>

<p><a href=""https://www.bouncycastle.org/docs/pkixdocs1.5on/org/bouncycastle/cms/CMSSignedData.html#getCertificates()"" rel=""nofollow noreferrer"">https://www.bouncycastle.org/docs/pkixdocs1.5on/org/bouncycastle/cms/CMSSignedData.html#getCertificates()</a></p>

<pre class=""lang-java prettyprint-override""><code>public org.bouncycastle.util.Store getCertificates()
</code></pre>

<p>The Scala compiler interprets this is <code>Store[_]</code>, which is shorthand for the existential type <code>Store[?0] forSome { type ?0 }</code> (see the answer to <a href=""https://stackoverflow.com/questions/3293318/what-is-scala-trying-to-tell-me-and-how-do-i-fix-this-required-java-util-lis"">this</a> question), i.e. the <code>Store</code> is parameterized with some specific, arbitrary type and not with <code>Any</code>.</p>

<p>Additionally, <code>SignerId</code> extends an untyped <code>Selector</code>.</p>

<p>Now, the following code causes a type mismatch since the type parameter values for <code>certStore</code> (<code>Store[_]</code>) and <code>signer.getSID</code> (<code>Selector[_]</code>) are not compatible.</p>

<pre class=""lang-scala prettyprint-override""><code>val certs = certStore.getMatches(signer.getSID)
</code></pre>

<p>To resolve the problem, it should help to explicitly cast <code>certStore</code> to <code>Store[X509CertificateHolder]</code> and <code>signerId</code> to <code>Selector[X509CertificateHolder]</code> (not tested):</p>

<pre class=""lang-scala prettyprint-override""><code>val certStore = signedData.getCertificates.
  asInstanceOf[Store[X509CertificateHolder]]

val certs = certStore.getMatches(
  signer.getSID.asInstanceOf[Selector[X509CertificateHolder]])
</code></pre>
","373","<scala><compiler-errors><bouncycastle><pkcs#7>","1","1","1","2016-08-08 08:10:53","","1","","","","","2016-08-05 16:38:25",""
"6408028","Certificate question (pkcs7)","<p>Accoring to the PKCS#7 standard certificate has some definite attributes. But I didn't find any information about the following:</p>

<ol>
<li>What is OID?</li>
<li>What is RDN?</li>
<li>What is the format of Public Key?</li>
</ol>
","<p>PKCS#7 and X.509 Certificates are both encoded in <a href=""http://www.itu.int/ITU-T/asn1/introduction/"" rel=""noreferrer"">ASN.1</a>.</p>

<ul>
<li>OID (Object Identifiers) is a basic ASN.1 type used for referencing objects in a unique and universal way. For instance, the OID 2.5.4.3 references <a href=""http://www.alvestrand.no/objectid/2.5.4.3.html"" rel=""noreferrer"">commonName</a>.</li>
<li>RDN (Relative Distinguished Name) is one element of a DN.</li>
<li><p>In PKCS#7 and X.509, the format of the Public Key depends on the algorithm. As an example, the ASN.1 schema for RSA public keys is</p>

<pre><code>RSAPublicKey ::= SEQUENCE {
    modulus           INTEGER,  -- n
    publicExponent    INTEGER   -- e
}
</code></pre></li>
</ul>
","373","<certificate><pkcs#7>","0","5","1","2011-06-20 17:30:01","6415087","0","","451969","","2011-06-20 07:28:07","2011-06-20 07:26:26",""
"43387548","EnvelopedCms decryption does not work with Azure Key Vault","<p>I've been struggeling with this for days now and RFC 2315 is a bit hard to understand.</p>

<p>I'm trying to implement my own version of <code>EnvelopedCms.Decrypt()</code>, so that I can use the certificate operations of Azure Key Vault to <code>UnwrapKey</code> and/or <code>Decrypt</code> a PKCS#7 message (CMS Object) in a correct way. I use EnevelopedCms in .Net to <code>Decode</code> the message, then I try to <code>Decrypt</code> the <code>EnvelopedCms.ContentInfo.Content</code>.</p>

<p>This is what I try to do;</p>

<pre><code>public static async Task&lt;byte[]&gt; DecryptCustom(string certificateId, string encryptedBase64Content)
{
    var bytes = Convert.FromBase64String(encryptedBase64Content);
    var contentInfo = new ContentInfo(bytes);
    var envelopedCms = new EnvelopedCms(contentInfo);
    envelopedCms.Decode(bytes);
    // envelopedCms.Decrypt()  &lt;-- no go. Can't extract certificate from Key Vault

    // My (naive) attempt to decrypt CMS content using Azure Key Vault certificates
    byte[] decryptedContent;
    using (var client = new KeyVaultClient(GetKeyVaultToken))
    {
        var decryptionresult = await client.DecryptAsync(GetKeyUrl(certificateId), ""RSA1_5"", envelopedCms.ContentInfo.Content);
        decryptedContent = decryptionresult.Result;
    }
    return decryptedContent;
}
</code></pre>

<p>I was hoping it could be that easy, but it gives me the following error;</p>

<blockquote>
  <p>Unable to decrypt specified value with this key.</p>
</blockquote>

<p>I read something about octets in RFC 2315, so maybe the stream (byte-array) needs some reordering before I decrypt. Do I need to unwrap some symmetric key to decrypt the real payload? I'm on thin ice here.</p>

<p>I'm not a cryptography professional so I might have missed something obvious, too. I was hoping someone knew what to do in this case as I really want to keep my certificates inside the Key Vault (HSM)</p>
","<p>CMS envelope contents are encrypted using a session key, and this key is encrypted with each recipients (there can be many) public key before transmission.</p>

<p>What you need is to extract your recipient's encrypted session key, and unwrap it with the private key stored in key vault. I'm not near Visual Studio right now, but here is the pseudocode:</p>

<pre><code>// Extract the first (and often only) receiver's encrypted session key
var key = envelopedCms.Receivers[0].EncryptionKey; 
// Unwrap the sessionKey using the receiver's private key stored in key vault:
var sessionKey = (await keyVaultClient.Unwrap(uri, ""certificatename"", key)).Result;
</code></pre>

<p>Finally, using the sessionKey, you can decrypt the envelope contents (ContentInfo.Content). The encryption type is specified in the envelope's encryption algorithm-property.</p>
","365","<c#><.net><encryption><pkcs#7><azure-keyvault>","3","3","1","2017-04-19 20:42:22","43399956","0","1","62532","","2017-04-19 20:42:22","2017-04-13 08:47:25",""
"51031446","C# PKCS7 Smartcard Digital Signature - Document has been altered or corrupted since it was signed","<p>I try to sign a pdf file using my smartcard (USB token) but encounter <code>""Document has been altered or corrupted since it was signed""</code> error when I open the signed pdf file in Adobe. The error is not so descriptive and I'm not sure where to look at because the code seems good to me but apparently it's not..</p>

<p>The code that I use is:</p>

<pre><code>var signer = smartCardManager.getSigner(""myTokenPassword"");
var toBeSignedHash = GetHashOfPdf(File.ReadAllBytes(@""xxx\pdf.pdf""), cert.asX509Certificate2().RawData, ""dsa"", null, false);
var signature = signer.sign(toBeSignedHash);
var signedPdf = EmbedSignature(cert.getBytes(), signature);
File.WriteAllBytes(@""xxx\signedpdf.pdf"", signedPdf);

public byte[] GetHashOfPdf(byte[] unsignedFile, byte[] userCertificate, string signatureFieldName, List&lt;float&gt; location, bool append)
{
    byte[] result = null;

    var chain = new List&lt;Org.BouncyCastle.X509.X509Certificate&gt;
    {
        Org.BouncyCastle.Security.DotNetUtilities.FromX509Certificate(new X509Certificate2(userCertificate))
    };
    Org.BouncyCastle.X509.X509Certificate certificate = chain.ElementAt(0);
    using (PdfReader reader = new PdfReader(unsignedFile))
    {
        using (var os = new MemoryStream())
        {
            PdfStamper stamper = PdfStamper.CreateSignature(reader, os, '\0', null, append);
            PdfSignatureAppearance appearance = stamper.SignatureAppearance;
            appearance.SetVisibleSignature(new iTextSharp.text.Rectangle(0,0,0,0), 1, signatureFieldName);
            appearance.Certificate = certificate;
            IExternalSignatureContainer external = new ExternalBlankSignatureContainer(PdfName.ADOBE_PPKLITE, PdfName.ADBE_PKCS7_DETACHED);
            MakeSignature.SignExternalContainer(appearance, external, 8192);
            Stream data = appearance.GetRangeStream();
            byte[] hash = DigestAlgorithms.Digest(data, ""SHA256"");
            var signatureContainer = new PdfPKCS7(null, chain, ""SHA256"", false);
            byte[] signatureHash = signatureContainer.getAuthenticatedAttributeBytes(hash, null, null, CryptoStandard.CMS);
            result = DigestAlgorithms.Digest(new MemoryStream(signatureHash), ""SHA256"");
            this.hash = hash;
            this.os = os.ToArray();
            File.WriteAllBytes(@""xxx\temp.pdf"", this.os);
        }
    }

    return result;
}

public byte[] EmbedSignature(byte[] publicCert, byte[] sign)
{
    var chain = new List&lt;Org.BouncyCastle.X509.X509Certificate&gt;
    {
        Org.BouncyCastle.Security.DotNetUtilities.FromX509Certificate(new X509Certificate2(publicCert))
    };
    var signatureContainer = new PdfPKCS7(null, chain, ""SHA256"", false);
    using (var reader = new PdfReader(this.os))
    {
        using (var os2 = new MemoryStream())
        {
            signatureContainer.SetExternalDigest(sign, null, ""RSA"");
            byte[] encodedSignature = signatureContainer.GetEncodedPKCS7(this.hash, null, null, null, CryptoStandard.CMS);
            IExternalSignatureContainer external = new MyExternalSignatureContainer(encodedSignature);
            MakeSignature.SignDeferred(reader, ""dsa"", os2, external);
            return os2.ToArray();
        }
    }
}
</code></pre>

<p>The pdf file that I try to sign is <a href=""https://drive.google.com/file/d/1jiPD3bgzCJRoN3W1kIO59p2EAzDe4YrK/view?usp=sharing"" rel=""nofollow noreferrer"">this</a>.</p>

<p>Temp pdf file that is created after adding signature fields is <a href=""https://drive.google.com/file/d/1FWXg0pdQjMzTGGLId_HXJuMZchjpSqOC/view?usp=sharing"" rel=""nofollow noreferrer"">this</a>.</p>

<p>Signed pdf file is <a href=""https://drive.google.com/file/d/1I6hUO8B3fnkgws9Pk1Puti9HjkRJE0Rq/view?usp=sharing"" rel=""nofollow noreferrer"">this</a>.</p>

<p>Base64 format of the hash that is signed is: <code>klh6CGp7DUzayt62Eusiqjr1BFCcTZT4XdgnMBq7QeY=</code></p>

<p>Base64 format of the signature is: <code>Uam/J6W0YX99rVP4M9mL9Lg9l6YzC2yiR4OtJ18AH1PtBVaNPteT3oPS7SUc+6ak2LfijgJ6j1RgdLamodDPKl/0E90kbBenry+/g1Ttd1bpO8lqTn1PWJU2TxeGHwyRyaFBOUga2AxpErIHrwxfuKCBcodB7wvAqRjso0jovnyP/4DluyOPm97QWh4na0S+rtUWOdqVmKGOuGJ3sBXuk019ewpvFcqWBX4Mvz7IKV56wcxQVQuJLCiyXsMXoazwyDCvdteaDz05K25IVwgEEjwLrppnc/7Ue9a9KVadFFzXWXfia7ndmUCgyd70r/Z+Oviu9MIAZL8GuTpkD7fJeA==</code></p>
","<p><em>I use hex encoding of byte arrays here. Your base64 encoded hash</em></p>

<pre><code>klh6CGp7DUzayt62Eusiqjr1BFCcTZT4XdgnMBq7QeY=
</code></pre>

<p><em>in hex encoding is equal to</em></p>

<pre><code>92587A086A7B0D4CDACADEB612EB22AA3AF504509C4D94F85DD827301ABB41E6
</code></pre>

<h3>In short</h3>

<p>Your code hashes the signed attributes twice. Simply don't hash the bytes returned by <code>signatureContainer.getAuthenticatedAttributeBytes(hash, null, null, CryptoStandard.CMS)</code> in <code>GetHashOfPdf</code> but instead use the authenticated attribute bytes themselves as return value.</p>

<h3>In detail</h3>

<p>Analyzing the signature in your example PDF it turns out that</p>

<ul>
<li><p>indeed the hash of the signed attributes is </p>

<pre><code>92587A086A7B0D4CDACADEB612EB22AA3AF504509C4D94F85DD827301ABB41E6
</code></pre></li>
<li><p>but the hash in the RSA encrypted <code>DigestInfo</code> object of the signature is</p>

<pre><code>1DC7CAA50D88243327A9D928D5FB4F1A61CBEFF9E947D393DDA705BD61B67F25
</code></pre></li>
<li><p>which turns out to be the hash of the before mentioned hash of the signed attributes.</p></li>
</ul>

<p>Thus, your</p>

<pre><code>var signature = signer.sign(toBeSignedHash);
</code></pre>

<p>call appears to hash the <code>toBeSignedHash</code> value again.</p>

<p>The most simple fix would be to replace</p>

<pre><code>byte[] signatureHash = signatureContainer.getAuthenticatedAttributeBytes(hash, null, null, CryptoStandard.CMS);
result = DigestAlgorithms.Digest(new MemoryStream(signatureHash), ""SHA256"");
</code></pre>

<p>by</p>

<pre><code>result = signatureContainer.getAuthenticatedAttributeBytes(hash, null, null, CryptoStandard.CMS);
</code></pre>

<p>in <code>GetHashOfPdf</code> to have only <code>signer.sign</code> do the hashing.</p>

<h3>Analyzing such issues</h3>

<p>In a comment you asked</p>

<blockquote>
  <p>how did you figure all this out :)?</p>
</blockquote>

<p>Well, yours is not the first question with a customized iText signing process resulting in errors or at least unwanted profiles.</p>

<p>In the course of the analysis of those questions the first step usually is to extract the embedded signature container and inspect it in an ASN.1 viewer.</p>

<p>In case of your PDF the main result of that inspection was that the signature as such looked ok and that your signed attributes don't contain any variable data.</p>

<p><sup><em>If there had been some variable data (e.g. a signing time attribute) in them, a candidate for the cause of the issue would have been that you build the signed attributes twice, once explicitly in <code>GetHashOfPdf</code>, once implicitly in <code>EmbedSignature</code>, with different values for the variable data. But as mentioned above, this was not the case.</em></sup></p>

<p>The next step here was to actually check the hashes involved. Checking the document hash is simple, one calculates the signed byte range hash and compares with the value of the <code>MessageDigest</code> signed attribute, cf. the <a href=""https://github.com/mkl-public/testarea-itext5/blob/master/src/test/java/mkl/testarea/itext5/signature/ExtractHash.java#L112"" rel=""nofollow noreferrer"">ExtractHash</a> test <code>testSotnSignedpdf</code> (in Java).</p>

<p><sup><em>The result for your PDF turned out to be ok.</em></sup></p>

<p>The following step was to inspect the signature container more thoroughly. In this context I once started to write some checks but did not get very far, cf. the <a href=""https://github.com/mkl-public/testarea-itext5/blob/master/src/main/java/mkl/testarea/signature/analyze/SignatureAnalyzer.java#L58"" rel=""nofollow noreferrer"">SignatureAnalyzer</a> class. I extended it a bit for the test of the hash of the signed attributes making use of the signature algorithm you used, the old <a href=""https://tools.ietf.org/html/rfc3447#section-8.2"" rel=""nofollow noreferrer"">RSASSA-PKCS1-v1_5</a>: In contrast to many other signature algorithms, this one allows to trivially extract the signed hash.</p>

<p><sup><em>Here the result for your PDF turned out not to be ok, the hash of the signed attributes differed from the signed hash.</em></sup></p>

<p>There are two often seen causes for a mismatch here,</p>

<ul>
<li><p>either the signed attributes are signed with a wrong encoding (it must be the regular DER encoding, not some arbitrary BER encoding and in particular not an encoding with the implicit tag the value stored in the signature has --- even larger players do this wrong sometimes, e.g. Docusign, cf. <a href=""https://ec.europa.eu/cefdigital/tracker/browse/DSS-1343"" rel=""nofollow noreferrer"">DSS-1343</a>)</p></li>
<li><p>or the hash was somehow transformed during signing (e.g. the hash is base64 encoded or hashed again).</p></li>
</ul>

<p><sup><em>As it turned out, the latter was the case here, the hash was hashed again.</em></sup></p>
","358","<c#><pdf><itext><digital-signature><pkcs#7>","2","2","1","2018-06-28 10:19:18","51071104","0","0","944592","","2018-06-25 21:14:08","2018-06-25 20:37:07",""
"30639872","Decrypt p7s file on iOS","<p>Working on a test <code>iOS</code> app I have faced the following problem.</p>

<p>From a remote webserver I recieve a <code>.p7s</code> file with the following contents (which are viewable in Mac's <code>TextEdit</code> app):</p>

<pre><code>0√Ñ  *√úH√úÀú
‚Ä†√Ñ0√Ñ10  +ÔøΩ0√Ñ    *√úH√úÀú
‚Ä†√Ñ$√Ñ√áÀö&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;!DOCTYPE plist PUBLIC ""-//Apple//DTD PLIST 1.0//EN"" ""http://www.apple.com/DTDs/PropertyList-1.0.dtd""&gt;
&lt;plist version=""1.0""&gt;
&lt;dict&gt;
    &lt;key&gt;CHALLENGE&lt;/key&gt;
    &lt;string&gt;panacya&lt;/string&gt;
    &lt;key&gt;IMEI&lt;/key&gt;
    &lt;string&gt;01 232700 828513 5&lt;/string&gt;
    &lt;key&gt;PRODUCT&lt;/key&gt;
    &lt;string&gt;iPad1,1&lt;/string&gt;
    &lt;key&gt;SERIAL&lt;/key&gt;
    &lt;string&gt;GB0269NJETU&lt;/string&gt;
    &lt;key&gt;UDID&lt;/key&gt;
    &lt;string&gt;2866681d94ae6c56d189485d39c54eaedecf211c&lt;/string&gt;
    &lt;key&gt;VERSION&lt;/key&gt;
    &lt;string&gt;9A5288d&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Ä†√á
[0√á√õ0√á\‚Ä†
u6√úŒ©~60
    *√úH√úÀú
ÔøΩ0Z10   UUS10U

Apple Inc.10UApple iPhone10UApple iPhone Device CA0
110808222517Z
140808222517Z0√Ö√â1-0+U$2890C19C-43F9-47C5-8534-A54F184E37DC10    UUS10   UCA10U  Cupertino10U
</code></pre>

<p>Here's the link to the original file - <a href=""https://www.dropbox.com/s/lm05gg866zdrz20/ota-response.p7s?dl=0"" rel=""nofollow"">https://www.dropbox.com/s/lm05gg866zdrz20/ota-response.p7s?dl=0</a></p>

<p>I then save the <code>NSData</code> as a <code>.p7s</code> file to disk.</p>

<p>I need to get the embedded <code>.plist</code> out of the file (judging from what I see it contains exactly that) or at least convert it to readable <code>NSString</code> which I can then display in <code>UILabel</code>.</p>

<p>Is it at all possible and how do I achieve it?</p>
","<p>You can read it into an <code>NSData</code> instnace and use</p>

<pre><code>- (NSRange)rangeOfData:(NSData *)dataToFind options:(NSDataSearchOptions)mask range:(NSRange)searchRange
</code></pre>

<p>to find the beginning and end of the plist. Then use</p>

<pre><code>- (NSData *)subdataWithRange:(NSRange)range
</code></pre>

<p>to optain just the plist data. Finally convert to a <code>NSString</code> with:</p>

<pre><code>- (instancetype)initWithData:(NSData *)data encoding:(NSStringEncoding)encoding
</code></pre>
","351","<ios><objective-c><cocoa-touch><nsdata><pkcs#7>","0","1","1","2015-06-04 11:38:05","30642847","1","1","909655","","2015-06-04 10:17:42","2015-06-04 09:19:35",""
"37041671","openssl_pkcs7_sign(): no certificates in file AppleWWDRCA.cer","<p>I need to create a detached PKCS7 signature for use with Apple Wallet passes.</p>

<h2>The code</h2>

<pre><code>private function createSignature()
{
    $cert = '/etc/ssl/local.crt';
    $key = '/etc/ssl/local.key';
    $wwdr = '/var/www/app/storage/passes/AppleWWDRCA.cer';
    $headers = [
        'signing-time' =&gt; (new DateTime())-&gt;format('o-m-d H:i:s'),
    ];

    return openssl_pkcs7_sign(""$this-&gt;dir/manifest.json"", ""$this-&gt;dir/signature"",
        $cert, $key, $headers, PKCS7_DETACHED, $wwdr);
}
</code></pre>

<h2>The error</h2>

<pre><code>openssl_pkcs7_sign(): no certificates in file, /var/www/app/storage/passes/AppleWWDRCA.cer
</code></pre>

<p><code>AppleWWDRCA.cer</code> was downloaded from <a href=""https://www.apple.com/certificateauthority/"" rel=""nofollow"">https://www.apple.com/certificateauthority/</a>. The exact certificate I downloaded was <code>WWDR Certificate (Expiring 02/07/23)</code>. I have viewed the file and confirmed it isn't blank. Am I missing a step?</p>
","<p>The issue was solved by adding the AppleWWDR.cer to my keychain and exporting it from the keychain as a <code>.pem</code> file.</p>
","334","<php><ios><ssl><digital-signature><pkcs#7>","1","4","1","2016-05-09 19:40:34","37124116","0","1","","","","2016-05-05 03:09:21",""
"49452793","PKCS7 and ""NONEwithRSA"" signature","<p>I need to compute some data signature, using un-encapsulated pkcs7 with sha256 and RSA.
No problem with raw content, using :</p>

<pre><code>public byte[] signRawContent(final byte[] content)
    throws CMSException, IOException, OperatorCreationException, CertificateEncodingException {

    // Create generator of pkcs7-signature message
    CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
    ContentSigner signer = new JcaContentSignerBuilder(""SHA256WithRSA"").setProvider(""BC"").build(privateKey);
    generator.addSignerInfoGenerator(
        new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()).build(signer, certificate));
    generator.addCertificate(new X509CertificateHolder(certificate.getEncoded()));

    CMSTypedData cmsTypedData = new CMSProcessableByteArray(content);
    CMSSignedData cmsSignedData = generator.generate(cmsTypedData, false);
    return cmsSignedData.getEncoded();
}
</code></pre>

<p>But I have another user cases, where I don't have the raw content, only its hash (sha256)
Bouncycastle doesn't support ""NONEwithRSA"" or ""RSA"" for pkcs7 signature, 
so I tried to use a custom ContentSigner, without obtaining the same 
signature that with the raw content version.</p>

<pre><code>public byte[] signHash(final byte[] sha256) throws IOException,
    OperatorCreationException, CertificateEncodingException, CMSException {

    // Create generator of pkcs7-signature message
    CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
    // custom content signer to bypass hash
    ContentSigner signer = new ContentSigner() {
        @Override public AlgorithmIdentifier getAlgorithmIdentifier() {
            return new DefaultSignatureAlgorithmIdentifierFinder().find(""SHA256WithRSA"");
        }

        @Override public OutputStream getOutputStream() {
            return new ByteArrayOutputStream();
        }

        @Override public byte[] getSignature() {
            try {
                Signature signer = Signature.getInstance(""NONEwithRSA"");
                signer.initSign(privateKey);
                signer.update(sha256);
                return signer.sign();
            } catch (Exception e){
            throw new RuntimeOperatorException(""exception obtaining signature: "" + e.getMessage(), e);
            }
        }
    };

    generator.addSignerInfoGenerator(
        new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()).build(signer, certificate));
    generator.addCertificate(new X509CertificateHolder(certificate.getEncoded()));

    CMSTypedData cmsTypedData = new CMSProcessableByteArray(sha256);
    CMSSignedData cmsSignedData = generator.generate(cmsTypedData, false);
    return cmsSignedData.getEncoded();
}
</code></pre>

<p>I even tried to rebuild the content digest, no luck</p>

<pre><code> // build digest
 MessageDigest messageDigest = MessageDigest.getInstance(""SHA-256"");
 messageDigest.update(sha256);
 byte[] outputDigest = messageDigest.digest();
 AlgorithmIdentifier sha256Aid = new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256, DERNull.INSTANCE);
 DigestInfo di = new DigestInfo(sha256Aid, outputDigest);

 //sign SHA256 with RSA
 Signature rsaSignature = Signature.getInstance(""RSA"");
 rsaSignature.initSign(privateKey);
 byte[] encodedDigestInfo = di.toASN1Primitive().getEncoded();
 rsaSignature.update(encodedDigestInfo);
 return rsaSignature.sign();
</code></pre>

<p>So is there a way to get a pkcs7 form a sha256?
Thanks</p>
","<p>Found a working solution:</p>

<pre><code>private static final String SIGNATURE_ALGO = ""SHA256WithRSA"";

/**
 * Get the pkcs7-signature from a document hash (sha256Hex)
 *
 * @param contentSha256Hex
 *     the original document content hash (sha256Hex) to be signed
 * @return the pkcs7 signature
 *
 * note: see TestSha1WithRsaAndAttributeTable() in bouncycastle/test/src/cms/test/SignedDataTest.cs
 * */
public byte[] signSha256Hex(final String contentSha256Hex)
    throws CertificateEncodingException, IOException, OperatorCreationException, CMSException, DecoderException {

    byte[] hash = Hex.decodeHex(contentSha256Hex);

    /*
     * The trick is to manually set digest attribute with hash value,
     * then generate signature without content.
     */

    // CMS attributes
    ASN1EncodableVector v = new ASN1EncodableVector();
    v.add(new Attribute(CMSAttributes.messageDigest, new DERSet(new DEROctetString(hash)))); // set digest (sha256)

    return signCms_Sha256WithRsa(
        new CMSAbsentContent(),
        new DefaultSignedAttributeTableGenerator(new AttributeTable(v)));

}

private byte[] signCms_Sha256WithRsa(CMSTypedData content, CMSAttributeTableGenerator signedAttributes)
    throws CMSException, IOException, CertificateEncodingException, OperatorCreationException {

    CMSSignedDataGenerator generator = new CMSSignedDataGenerator();

    // content signer
    ContentSigner signer = new JcaContentSignerBuilder(SIGNATURE_ALGO).setProvider(""BC"").build(privateKey);
    generator.addSignerInfoGenerator(
        new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build())
            .setSignedAttributeGenerator(signedAttributes)
            .build(signer, certificate));

    // add certificate
    generator.addCertificate(new X509CertificateHolder(certificate.getEncoded()));

    // sign
    CMSSignedData cmsSignedData = generator.generate(content, false);
    return cmsSignedData.getEncoded();
}
</code></pre>
","333","<java><rsa><bouncycastle><sha256><pkcs#7>","0","0","1","2018-06-20 07:32:57","50942691","0","","","","","2018-03-23 15:06:31",""
"27301841","How to extract the contents of a jarsigner-created META-INF/CERT.RSA with PHP?","<p>I specifically want to determine the expiration date of the key used to sign an Android APK.</p>

<p>The file appears to be DER-encoded PKCS#7, as this shows me the contents:</p>

<pre><code>openssl pkcs7 -inform DER -in CERT.RSA -noout -print_certs -text
</code></pre>

<p>Some approaches I have tried:</p>

<pre><code>/* try to open as pkcs#7.  prints FALSE. */

if( TRUE === openssl_pkcs7_verify ( 'CERT.RSA', 0 ) ) {
    echo ""TRUE\n"";
}
else {
    echo ""FALSE\n"";
}

/* try to open as an x509.  prints FALSE. */

$data = openssl_x509_parse(file_get_contents('CERT.RSA'));
if( $data === FALSE ) {
    echo ""FALSE\n"";
}

/*                                                                                                         
   un-DER with phpseclib                                                                                   

   prints a nestated data structure that clearly includes                                                  
   data from CERT.RDA, but unclear to me which value is                                                    
  the cert expiration date.                                                                               
*/

$ASN1 = new File_ASN1(file_get_contents('CERT.RSA'));
print_r( $ASN1-&gt;decodeBER(file_get_contents('CERT.RSA')) );`
</code></pre>

<p>I <em>could</em> just call openssl from an exec() or similar, but I'd rather have a pure-PHP solution.  Anybody got one?</p>
","","329","<php><apk><pkcs#7><php-openssl>","0","","0","2014-12-05 12:30:34","","2","","616587","","2014-12-05 12:30:34","2014-12-04 18:58:51",""
"44857481","How to generate .sig of XML of digitally signed XML document in C#?","<p>I have requirement of signing xml document with digital signature and with that document I need to generate .sig file of digitally signed xml. I am using PKCS7 Algorithm for the same. I am able to successfully put signature in xml. But not been able to generate .sig file. My code is as follows:</p>

<pre><code>public static void SignXmlDocumentWithCertificate(XmlDocument doc, X509Certificate2 cert)
{
    SignedXml signedxml = new SignedXml(doc);
    signedxml.SigningKey = cert.PrivateKey;
    Reference reference = new Reference();
    reference.Uri = """";
    reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
    signedxml.AddReference(reference);

    KeyInfo keyinfo = new KeyInfo();
    keyinfo.AddClause(new KeyInfoX509Data(cert));

    signedxml.KeyInfo = keyinfo;
    signedxml.ComputeSignature();

    XmlElement xmlsig = signedxml.GetXml();
    doc.DocumentElement.AppendChild(doc.ImportNode(xmlsig, true));
    //Console.WriteLine(doc.ImportNode(xmlsig,true));
}
</code></pre>

<p>Now I am generating .sig file like this:</p>

<pre><code>AsymmetricKeyParameter asymmetricKeyParameter = PublicKeyFactory.CreateKey(keyBytes);
RsaKeyParameters rsaKeyParameters = (RsaKeyParameters)asymmetricKeyParameter;
RSAParameters rsaParameters = new RSAParameters();
rsaParameters.Modulus = rsaKeyParameters.Modulus.ToByteArrayUnsigned();
rsaParameters.Exponent = rsaKeyParameters.Exponent.ToByteArrayUnsigned();

RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); rsa.ImportParameters(rsaParameters);

byte[] ciphertext = rsa.Encrypt(keyBytes, false);
string cipherresult = Convert.ToBase64String(ciphertext);
Console.WriteLine(cipherresult);
</code></pre>

<p>which is throwing an error of bad length \r\n. 
My xml after digitally signed is :</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;xml&gt;
&lt;CATALOG&gt;
 &lt;PLANT&gt;
    &lt;COMMON&gt;Grecian Windflower&lt;/COMMON&gt;
    &lt;BOTANICAL&gt;Anemone blanda&lt;/BOTANICAL&gt;
    &lt;ZONE&gt;6&lt;/ZONE&gt;
    &lt;LIGHT&gt;Mostly Shady&lt;/LIGHT&gt;
    &lt;PRICE&gt;$9.16&lt;/PRICE&gt;
    &lt;AVAILABILITY&gt;071099&lt;/AVAILABILITY&gt;
&lt;/PLANT&gt;
&lt;/CATALOG&gt;
&lt;Signature xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
&lt;SignedInfo&gt;
    &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""/&gt;
    &lt;SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1""/&gt;
    &lt;Reference URI=""""&gt;
      &lt;Transforms&gt;
        &lt;Transform Algorithm=""http://www.w3.org/2000/09/xmldsig#enveloped-signature""/&gt;
     &lt;/Transforms&gt;
     &lt;DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1""/&gt;

     &lt;DigestValue&gt;/VUzr4wRNv2e6SzE6TdHLM8c+/A=&lt;/DigestValue&gt;

    &lt;/Reference&gt;

    &lt;/SignedInfo&gt;
    &lt;SignatureValue&gt;i3gGf2Q......8Q==&lt;/SignatureValue&gt;
    &lt;KeyInfo&gt;
    &lt;X509Data&gt;
      &lt;X509Certificate&gt;MIID6D.......fFo=&lt;/X509Certificate&gt;
    &lt;/X509Data&gt;
    &lt;/KeyInfo&gt;

&lt;/Signature&gt;

&lt;/xml&gt;
</code></pre>

<p>Now I know I am either doing in wrong way or there is something I have missed out. My question is </p>

<ol>
<li>Is there a way out for generating .sig file with signed xml?</li>
<li>Is it possible for large xml file in PKCS7?</li>
</ol>

<p>As my requriement are:</p>

<ol>
<li>The digital signature will be generated as a part of PKCS7 envelop as a plain bytes. A PKCS7 envelop will contain the certificate used for signing as well as the digital signature itself.</li>
<li>The PKCS7 envelop will not be base-64 encoded. It will not contain any start aend identifiers. The plain PKCS7 envelop which is a sequence of bytes will be written into the .sig file.</li>
<li>The digital signature will be generated using SHA-2(512bits) algorithm for message digest and RSA-2048 algorithm for encryption</li>
</ol>
","<p>Try following code.  I merged your code with sample from msdn.  I also used default user certificate on PC :</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using System.IO;

namespace ConsoleApplication1
{
    class Program
    {
        const string FILENAME = @""c:\temp\test.xml"";
        static void Main(string[] args)
        {
            XmlDocument doc = new XmlDocument();
            doc.Load(FILENAME);
            string computerName = Environment.GetEnvironmentVariable(""COMPUTERNAME"");
            string userName = Environment.GetEnvironmentVariable(""USERNAME"");
            X509Certificate2 cert = GetCertificateFromStore(""CN="" + computerName + ""\\"" + userName);

            SignXmlDocumentWithCertificate(doc, cert);
            RSACryptoServiceProvider publicKey = (RSACryptoServiceProvider)cert.PublicKey.Key;

            byte[] unencryptedData = Encoding.UTF8.GetBytes(doc.OuterXml); 
            Stream stream = EncryptFile(unencryptedData,publicKey);

            Console.ReadLine();

        }
        public static void SignXmlDocumentWithCertificate(XmlDocument doc, X509Certificate2 cert)
        {
            SignedXml signedxml = new SignedXml(doc);
            signedxml.SigningKey = cert.PrivateKey;
            Reference reference = new Reference();
            reference.Uri = """";
            reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
            signedxml.AddReference(reference);

            KeyInfo keyinfo = new KeyInfo();
            keyinfo.AddClause(new KeyInfoX509Data(cert));

            signedxml.KeyInfo = keyinfo;
            signedxml.ComputeSignature();

            XmlElement xmlsig = signedxml.GetXml();
            doc.DocumentElement.AppendChild(doc.ImportNode(xmlsig, true));
            //Console.WriteLine(doc.ImportNode(xmlsig,true));

        }

        private static X509Certificate2 GetCertificateFromStore(string certName)
        {

            // Get the certificate store for the current user.
            X509Store store = new X509Store(StoreLocation.CurrentUser);
            try
            {
                store.Open(OpenFlags.ReadOnly);

                // Place all certificates in an X509Certificate2Collection object.
                X509Certificate2Collection certCollection = store.Certificates;
                // If using a certificate with a trusted root you do not need to FindByTimeValid, instead:
                // currentCerts.Find(X509FindType.FindBySubjectDistinguishedName, certName, true);
                X509Certificate2Collection currentCerts = certCollection.Find(X509FindType.FindByTimeValid, DateTime.Now, false);
                X509Certificate2Collection signingCert = currentCerts.Find(X509FindType.FindBySubjectDistinguishedName, certName, false);
                if (signingCert.Count == 0)
                    return null;
                // Return the first certificate in the collection, has the right name and is current.
                return signingCert[0];
            }
            finally
            {
                store.Close();
            }

        }
        // Encrypt a file using a public key.
        private static MemoryStream  EncryptFile(byte[] unencryptedData, RSACryptoServiceProvider rsaPublicKey)
        {
            MemoryStream stream = null;

            using (AesManaged aesManaged = new AesManaged())
            {
                // Create instance of AesManaged for
                // symetric encryption of the data.
                aesManaged.KeySize = 256;
                aesManaged.BlockSize = 128;
                aesManaged.Mode = CipherMode.CBC;
                using (ICryptoTransform transform = aesManaged.CreateEncryptor())
                {
                    RSAPKCS1KeyExchangeFormatter keyFormatter = new RSAPKCS1KeyExchangeFormatter(rsaPublicKey);
                    byte[] keyEncrypted = keyFormatter.CreateKeyExchange(aesManaged.Key, aesManaged.GetType());

                    // Create byte arrays to contain
                    // the length values of the key and IV.
                    byte[] LenK = new byte[4];
                    byte[] LenIV = new byte[4];

                    int lKey = keyEncrypted.Length;
                    LenK = BitConverter.GetBytes(lKey);
                    int lIV = aesManaged.IV.Length;
                    LenIV = BitConverter.GetBytes(lIV);

                    // Write the following to the FileStream
                    // for the encrypted file (outFs):
                    // - length of the key
                    // - length of the IV
                    // - ecrypted key
                    // - the IV
                    // - the encrypted cipher content


                    stream = new MemoryStream();
                    try
                    {

                        stream.Write(LenK, 0, 4);
                        stream.Write(LenIV, 0, 4);
                        stream.Write(keyEncrypted, 0, lKey);
                        stream.Write(aesManaged.IV, 0, lIV);

                        // Now write the cipher text using
                        // a CryptoStream for encrypting.
                        CryptoStream outStreamEncrypted = new CryptoStream(stream, transform, CryptoStreamMode.Write);
                        try
                        {

                            // By encrypting a chunk at
                            // a time, you can save memory
                            // and accommodate large files.
                            int count = 0;
                            int offset = 0;

                            // blockSizeBytes can be any arbitrary size.
                            int blockSizeBytes = aesManaged.BlockSize / 8;

                            do
                            {
                                if (offset + blockSizeBytes &lt;= unencryptedData.Length)
                                {
                                    count = blockSizeBytes;
                                }
                                else
                                {
                                    count = unencryptedData.Length - offset;
                                }
                                outStreamEncrypted.Write(unencryptedData, offset, count);
                                offset += count;
                            }
                            while (offset &lt; unencryptedData.Length);

                            outStreamEncrypted.FlushFinalBlock();
                        }
                        catch(Exception ex)
                        {
                            Console.WriteLine(""Error : {0}"", ex.Message);
                        }
                    }
                    catch(Exception ex)
                    {
                        Console.WriteLine(""Error : {0}"", ex.Message);
                    }
                    stream.Position = 0;
                }
            }
            return stream;
        }
    }
}
</code></pre>
","324","<c#><xml><digital-signature><pkcs#7><xml-signature>","1","0","1","2018-06-20 00:48:36","","0","0","472495","","2018-06-20 00:48:36","2017-07-01 04:57:51",""
"49176348","Why can't I verify signature with PKCS#11?","<p>Consider, I have created PKCS#7 message:</p>

<pre><code>ContentInfo contentInfo = new ContentInfo(someByteArrayToSign);
SignedCms signedCms = new SignedCms(contentInfo);

var certificateFromFile = new X509Certificate2(""myCert.pfx"");

var signer = new CmsSigner(certificateFromFile);
signer.DigestAlgorithm = new Oid(""1.3.14.3.2.26"");
signedCms.ComputeSignature(signer);

var myCmsMessage = signedCms.Encode();
SendBytesOverNetwork(myCmsMessage);
</code></pre>

<p>Now, I'd like to very signature. The following scenario works (using <code>BounceCastle</code> and <code>PKCS11.Interop</code>):</p>

<pre><code>var signedPayloadCms = new CmsSignedData(GetBytesFromNetwork());

var data = (byte[])signedPayloadCms.SignedContent.GetContent();
byte[] signature = null;

foreach (SignerInformation signer in signedPayloadCms.GetSignerInfos().GetSigners())
{
    if (signature != null)
    {
        throw new NotSupportedException(""Multiple signature"");
    }

    signature = signer.GetSignature();
}

var algCkm = CKM.CKM_SHA1_RSA_PKCS;
var mechanism = new Mechanism(algCkm);
Session.Verify(mechanism, somePublicKey.Handle, data, signature, out var isValid)
//isValid  == true
</code></pre>

<p>But when I use <code>CKM_RSA_PKCS</code> and manually calculate HASH, something is wrong:</p>

<pre><code>var algHash = CKM.CKM_SHA_1;
var dataHash = Session.Digest(new Mechanism(algHash), data);

var algCkm = CKM.CKM_RSA_PKCS;
var mechanism = new Mechanism(algCkm);
Session.Verify(mechanism, somePublicKey.Handle, dataHash, signature, out var isValid)
//isValid  == false
</code></pre>

<p>What I am missing? Why manually calculated hash is not valid?</p>
","<p>It turned out, that hash needs to be wraped with <em>DigestInfo</em> structure. The simplest ways to do is to add prefix: (prefix valid only for SHA-1 hashes):</p>

<pre><code>var dataHash = Session.Digest(new Mechanism(algHash), data);
dataHash = HexToByteArray(""30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14"")
             .Concat(dataHash).ToArray();

 var algCkm = CKM.CKM_RSA_PKCS
...
</code></pre>

<p>Found in RF3447C: <a href=""https://www.ietf.org/rfc/rfc3447.txt"" rel=""nofollow noreferrer"">https://www.ietf.org/rfc/rfc3447.txt</a></p>

<p>How to create <code>DigestInfo</code> by self: <a href=""https://stackoverflow.com/questions/3713774/c-sharp-how-to-calculate-asn-1-der-encoding-of-a-particular-hash-algorithm"">C# - How to calculate ASN.1 DER encoding of a particular hash algorithm?</a></p>
","320","<c#><.net-core><pkcs#11><pkcs#7><softhsm>","-1","0","1","2019-05-08 20:03:06","49191404","2","","10607772","","2019-05-08 20:03:06","2018-03-08 15:08:47",""
"47380716","Information used to verify PKCS#7 signature in Java","<p>I have 2 files : a PKCS#7 signature and a file, which has been signed by this signature. My question is how can I verify this signature properly? Which data exactly should I use and extract from the PKCS7 in order to do that? I've heard that the order of the actions looks like this:</p>

<ol>
<li>Check whether a certificate out of date or not</li>
<li>Check whether CA is out out of date or not</li>
<li>Check whether this public key is still valid</li>
<li>And perhaps extract the hash value from the attribute in PKCS7 file and check for equality to a hash file, which has been signed</li>
</ol>

<p>Am I correct? And how can I do it using Bouncy Castle? I've come across with this</p>

<pre><code>CMSSignedData data = new CMSSignedData(bytesArray)
</code></pre>

<p>But how can I check validality using only one method, if there is? This looks like overcomplicated - I should take every certificate, check it's expire date, writing custom method that does it.. And somehow check that the public key is still valid.. Is it possible to do it easier?</p>
","<p><a href=""https://docs.oracle.com/javase/tutorial/security/apisign/versig.html"" rel=""nofollow noreferrer"">https://docs.oracle.com/javase/tutorial/security/apisign/versig.html</a></p>

<p>You can find here a a quite good step by step description. Although this is not using Bouncy Castel but just </p>
","319","<java><digital-signature><bouncycastle><pkcs#7>","0","0","1","2017-11-19 19:20:12","","1","","","","","2017-11-19 18:53:32",""
"50620303","How to verify PKCS#7 signature in PHP","<p>I have a digital signature (encrypted format PKCS#7) needs to be verified So I have tried by using different PHP core methods(openssl_verify,  openssl_pkcs7_verify and even tried by external library such as phpseclib But nothing worked :(</p>

<p>I get a signature along with some extra params through by this link.. </p>

<blockquote>
  <p><a href=""http://URL?sign="" rel=""nofollow noreferrer"">http://URL?sign=</a>{'param':{'Id':'XXXXXXX','lang':'EN','Rc':'00','Email': 'test@yahoo.com'‚Äô},'signature':'DFERVgYJKoZIhvcNAQcCoIIFRzCCBUMCAQExCzAJBgUrDg
  MCGgUAMIGCBgkqhkiG9w0BBwGgdQRzeyJEYXRlIjoidG9fY2hhcihzeXNkYXRlJ0RETU1ZWVlZJykgIiwiSWQiOiJ
  VMDExODg3NyIsIklkaW9tYSI6IkNBUyIsIk51bUVtcCI6IlUwM23D4DEE3dSi...'} </p>
</blockquote>

<p>PHP code - returns always 0(false) instead of 1(true).</p>

<pre><code>       $JSONDATA               = str_replace(""'"", '""', @$_GET[""sign""]);
       $data                   = json_decode($JSONDATA, true);
       $this-&gt;email            = $data['param'][""EMAIL""];
       $this-&gt;signature        = $data['signature'];
       $this-&gt;signature_base64 =  base64_decode($this-&gt;signature);
       $this-&gt;dataencoded      = json_encode($data['param']);

       //SOLUTION 1 (By using phpseclib)  but didnt work..
       $rsa        = $this-&gt;phpseclib-&gt;load();
       $keysize    =  2048;
       $rsa-&gt;setPrivateKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS8);
       $rsa-&gt;setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_PKCS1);
       $d = $rsa-&gt;createKey($keysize);
       $Kver = $d['publickey'];
       $KSign = $d['privatekey'];

       // Signing
       $rsa-&gt;loadKey($KSign);
       $rsa-&gt;setSignatureMode(CRYPT_RSA_ENCRYPTION_PKCS1);
       $rsa-&gt;setHash('sha256');

       $signature = $rsa-&gt;sign($this-&gt;dataencoded);
       $signedHS = base64_encode($signature);

       // Verification
       $rsa-&gt;loadKey($Kver);
       $status = $rsa-&gt;verify($this-&gt;dataencoded, $this-&gt;firma_base64); // getting an error on this line Message: Invalid signature
       var_dump($status);  // reutrn false


        //SOLUTION 2 (By using code php methods)

        // obtener la clave p√∫blica desde el certifiado y prepararla
       $orignal_parse = parse_url(""https://example.com"", PHP_URL_HOST);
       $get = stream_context_create(array(""ssl"" =&gt; array(""capture_peer_cert"" =&gt; TRUE)));
       $read = stream_socket_client(""ssl://"".$orignal_parse."":443"", $errno, $errstr, 30, STREAM_CLIENT_CONNECT, $get);
       $cert = stream_context_get_params($read);
       $certinfo = openssl_x509_parse($cert['options']['ssl']['peer_certificate']);
       openssl_x509_export($cert[""options""][""ssl""][""peer_certificate""],$cert_key);
       $pubkeyid = openssl_pkey_get_public($cert_key);

       $dataencoded = json_encode($data['param']);

       echo $ok = openssl_x509_check_private_key($cert_key,$this-&gt;firma_base64); // return nothing
       echo $ok1 = openssl_verify($dataencoded, $this-&gt;firma_base64, $pubkeyid, OPENSSL_ALGO_SHA256); // returns 0
       echo $ok2 = openssl_verify($dataencoded, $this-&gt;firma_base64, $pubkeyid, OPENSSL_ALGO_SHA512);   // returns 0  
       echo $ok3 = openssl_verify($dataencoded, $this-&gt;firma_base64, $pubkeyid, OPENSSL_ALGO_SHA256);  // returns 0
        echo $ok4 = openssl_verify($dataencoded, $this-&gt;firma, $pubkeyid, OPENSSL_ALGO_SHA512);   // returns 0     
</code></pre>

<p>Java code - (this code works and returns true)</p>

<pre><code>private boolean verifySignautre(String frm) throws NetinfException, IOException, CMSException,
CertificateException, OperatorCreationException, Exception {
Security.addProvider(new BouncyCastleProvider());

//we extract the containers that make up the signature and the keystore used to sign included in the same signature.
CMSSignedData signedData = new CMSSignedData(Base64.decode(frm.getBytes()));
SignerInformationStore signers = signedData.getSignerInfos();
Store certStore = signedData.getCertificates();
Collection c = signers.getSigners();
Iterator it = c.iterator();

while (it.hasNext()) {
//retrieve the certificate with the recipient's id.
SignerInformation signerInfo = (SignerInformation) it.next();
Collection certCollection = certStore.getMatches(signerInfo.getSID());
Iterator certIt = certCollection.iterator();
X509CertificateHolder signerCertificateHolder = (X509CertificateHolder) certIt.next();

//create the container to validate signature.
ContentVerifierProvider contentVerifierProvider = new BcRSAContentVerifierProviderBuilder(new
DefaultDigestAlgorithmIdentifierFinder()).build(signerCertificateHolder);

//valid signature and then certificate validity date
try{
X509Certificate signedcert = new
JcaX509CertificateConverter().setProvider(""BC"").getCertificate(signerCertificateHolder);
signedcert.checkValidity();
signedcert.verify(signedcert.getPublicKey());
return true;
}catch(Exception e){
return false;
}
}
</code></pre>

<p>I simply need to convert this Java code into PHP. However, as you can see above that I tried different approaches but none of them worked.</p>

<p>Please support me to find the solution. </p>

<p>your support would be higly appreciated</p>
","","319","<ssl><openssl><ssl-certificate><phpseclib><pkcs#7>","1","","0","2018-05-31 09:38:14","","3","","9874839","","2018-05-31 09:38:14","2018-05-31 08:53:14",""
"43702228","Extract a CSR from PKCS7","<p>There is a requirement where I have to extract PKCS10 (CSR) from PKCS7 pem formatted string that I have. Although I can read the contents of the PKCS7, I see that it just a Certificate and not a CSR.</p>

<p>I also ran the pem string with the <a href=""https://certlogik.com/decoder/"" rel=""nofollow noreferrer"">https://certlogik.com/decoder/</a> to see what it consists of. All I can see is a valid certificate.
Is there a way where I can get the CSR from the below pem formatted string.</p>

<pre><code>-----BEGIN CERTIFICATE-----
MIIIjAYJKoZIhvcNAQcCoIIIfTCCCHkCAQExDzANBglghkgBZQMEAgEFADCCAyoG
CSqGSIb3DQEHAaCCAxsEggMXMIIDEzCCAfsCAQAwSjFIMEYGA1UEAww/MjNFNzEz
NjAtMjRDOS00NzEhdXJuOnV1aWQ6NUJFNEYwQ0YtMjExMS01OEM3LUE5MkUtREQ1
NzlDN0U1MTE5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp1BuQRtK
LQtXrl4x9hwSmIR0SteTFO4WGrlaKapnllM7q/WyClkZg/fAPCN5+Lkn/CItctkM
Wds/09aqzA+dAAdK4X1uuq+ux7zKYYTIkPmcO7oaFWxGvm8ZvOX+2TH1MN5/xyWD
VHveRrFy7aHKsR+yFuEtrYpsSGBCU9pUrXKPkRBgvC4Ml3M/hjnSp3t3JOjZzeVQ
GA5HyQG94KP5VMgXcF2r9TTnHHqxMUBPc00UGL25eqxC8xmPTPh/lt8U5tHly3cS
T434EHblgbQOa4wo7XxytYYqvAZEwiZLv8DgeKJS/lOjCSQNpF3tIDdxengx0S/d
R1HZZa/ZANeE8QIDAQABoIGDMIGABgkqhkiG9w0BCQ4xczBxMDwGCisGAQQBgjdC
AQAELnVybjp1dWlkOjVCRTRGMENGLTIxMTEtNThDNy1BOTJFLURENTc5QzdFNTEx
OQAwDgYDVR0PAQH/BAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMCMAwGA1UdEwEB
/wQCMAAwDQYJKoZIhvcNAQELBQADggEBADgabvOqPxhzUSpOaI9T/sPXQAvmVrcp
dIke2MVHeNnvyYjyg070yv3bbHXRDsjq3MgEkBDYRNOW8/dgtjyGxyRPEMJbfHoF
BJrgbnZXwqch3jeZjZKegn39OtfVvatc6kBzN9PssKGDuTl3C60e0w/qS6eCgsD3
nfkMKacpRcLL7jsh0hEk5nBI7XxtVRygb1uUe6ZqDZEYMEwa4ykID5WB/cgmvp2u
SXja2LgFi2N1bqHEeYqcVr+8YDlHHkZ9O8GOjsqUIuvNcXzbWElcfhPKLGL9PRJ9
wkBI+s4jDZrDwH1npDfu03sVNvhRZU85SqiUP1Ef6mtnk85lfnsi1W6gggPXMIID
0zCCArugAwIBAgIBZjANBgkqhkiG9w0BAQsFADAoMSYwJAYDVQQDEx1EZXZpY2Vz
IENlcnRpZmljYXRlIEF1dGhvcml0eTAeFw0xNzA0MjYwNTU0MTdaFw0xNzA2MjUw
NjA0MTdaMEoxSDBGBgNVBAMMPzIzRTcxMzYwLTI0QzktNDcxIXVybjp1dWlkOjVC
RTRGMENGLTIxMTEtNThDNy1BOTJFLURENTc5QzdFNTExOTCCASIwDQYJKoZIhvcN
AQEBBQADggEPADCCAQoCggEBALQzG3preB06ezMbHklWfMHLD6XtjPHMBtSl+76q
ZePnWcv/V0B9/vvmf9OOeGRFk4FZA7omHmu0yQZ38KOjnziV5L1zkD+4JDlLXvNE
YDNpB1jsFtxLv2c2fL31Dw0/O2Z/E2TbKKGfJjxXZfiLLxxag9Id6aXqc88jlmdG
B99pn3SSEi2C5pKO3dWwLD6vDDwohr8iXR9TLQg4HrG8b4vzhMDVVzhlGkeyvtYE
f4EH4q71draLzDe0G0meboSbEUzbkFXggPid4jHYN6Nv0je07l3pXn7FrLIssMAw
Wo9VsPky2IDGEvxb1oLTG+WlFJHApBYbAHGcyBH6rOw4EY8CAwEAAaOB5TCB4jA8
BgorBgEEAYI3QgEABC51cm46dXVpZDo1QkU0RjBDRi0yMTExLTU4QzctQTkyRS1E
RDU3OUM3RTUxMTkAMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcD
AjAMBgNVHRMBAf8EAjAAMFAGA1UdIwRJMEeAFDPgDOIez45DN/HKylyhPG8NJdF+
oSmkJzAlMSMwIQYDVQQDExpSb290IENlcnRpZmljYXRlIEF1dGhvcml0eYIEeDbF
SjAdBgNVHQ4EFgQUvSTP7MCmf6Nrpo5KswIdDmsyxc0wDQYJKoZIhvcNAQELBQAD
ggEBAH+LU8oSyknN5NQp6YWFBekOxid17J+opvinRB1gQBxYGmLLpNwnJ3jBx+1a
Qo7aMMupjDLyClP7hP0lqDLbSY8RFBjlVcqhv4wai/rVRNVigfakJJrjUtUPVNSe
/NVpBH7NdAqJVM//e0WEWFyGGgsJdP0f11tRy1d871+DuUSZX2Hzv5vTbE8rScnQ
YUdpQ1sJX7VbMW+E1SGc0XDUqJEQpDuYXPP00/Jxamch+MHLyHjX4HTcmPYRoo9c
NEzL+fOob0ZI8UdVrN6PmCoRiePEW6ol9z5UUGb6VU7hwqV9BoLthUQBT+6dHsxs
dpl+EE8rX2BnmrWxkD6A860f8noxggFYMIIBVAIBATAtMCgxJjAkBgNVBAMTHURl
dmljZXMgQ2VydGlmaWNhdGUgQXV0aG9yaXR5AgFmMA0GCWCGSAFlAwQCAQUAMA0G
CSqGSIb3DQEBAQUABIIBAF5bjUS5Su6nqrzveapNCOuJAZf8A6OtiuNFN7H4JdRj
rLtepOVkP+nYo99vtLeeGae1CTCi357bd16v58Xv4JOoISqS9XoVkmEGvGUiClGR
wE+xYw7+++1xMDIQyvwHu6Z87VVOKlChTpT5du+eP6vBbfxeg5WN/23mdW2JZT5d
E/XohJgL4OnqhJuG5miVQ8hOu/CvZZ0nYZMz75s5+tVsES76o1U/9QfjS+CQImMF
AV3d7UBmCUnqZ10t5Y9IHBa9AEnMLfK/yIo2uwVIwI89LzA3+L8Ql1WJ1ZA7ecXZ
xGUIMz87AVho2zm3Z4tpZIGKxFlVvL3tkZQMZwocgCc=
-----END CERTIFICATE-----
</code></pre>
","<p>Since you have the certificate, you can fill the CSR just getting the information contained in the certificate (subject, public key, ...)
But since you don't have the private key associated to this public key, you won't be able to sign the CSR.</p>
","318","<java><security><bouncycastle><pkcs#7><pkcs#10>","-1","1","1","2017-05-02 13:16:34","","0","","","","","2017-04-30 02:06:25",""
"23252709","Read PKCS#7 from ASN1 with PasswordRecipientInfo","<p>I am reading a PKCS#15 file (asn1). Eventually I end up having a pkcs#7 structure, which contains a PasswordRecipientInfo (PBKDF2).</p>

<p>I can read the asn1 structure into a Bouncy Castle EnvelopedData. I can read all encryption parameters by hand, and I know the password to decrypt the data.</p>

<p>But how can I convert the EnvelopedData to something like CmsEnvelopedData (which has more functionality). If I feed the asn1 data to CmsEnvelopedData it fails with malformed data etc.</p>

<p>I also use Rebex, but that seems not to support the PasswordRecipientInfo structure (although they do implement the PBKDF2 key generation).</p>

<p>I did do all the decryption by hand, but do not end up with useful data, so I probably do make a mistake with all the 3Des decryption.</p>

<p>This is the example ASN1 stream:</p>

<pre><code>    0:d=0  hl=4 l= 823 cons: SEQUENCE          
    4:d=1  hl=4 l= 815 cons: cont [ 2 ]        
    8:d=2  hl=2 l=   1 prim: INTEGER           :02
   11:d=2  hl=2 l= 105 cons: SET               
   13:d=3  hl=2 l= 103 cons: cont [ 3 ]        
   15:d=4  hl=2 l=   1 prim: INTEGER           :00
   18:d=4  hl=2 l=  27 cons: cont [ 0 ]        
   20:d=5  hl=2 l=   9 prim: OBJECT            :PBKDF2
   31:d=5  hl=2 l=  14 cons: SEQUENCE          
   33:d=6  hl=2 l=   8 prim: OCTET STRING      [HEX DUMP]:91923125EC5C328F
   43:d=6  hl=2 l=   2 prim: INTEGER           :07D0
   47:d=4  hl=2 l=  35 cons: SEQUENCE          
   49:d=5  hl=2 l=  11 prim: OBJECT            :1.2.840.113549.1.9.16.3.9
   62:d=5  hl=2 l=  20 cons: SEQUENCE          
   64:d=6  hl=2 l=   8 prim: OBJECT            :des-ede3-cbc
   74:d=6  hl=2 l=   8 prim: OCTET STRING      [HEX DUMP]:9F040621A5AF002B
   84:d=4  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:52237B22E48C5D579DBA6FD457DFC47C7C9F244306F3856CE98826C5657E9B60
  118:d=2  hl=4 l= 701 cons: SEQUENCE          
  122:d=3  hl=2 l=   9 prim: OBJECT            :pkcs7-data
  133:d=3  hl=2 l=  20 cons: SEQUENCE          
  135:d=4  hl=2 l=   8 prim: OBJECT            :des-ede3-cbc
  145:d=4  hl=2 l=   8 prim: OCTET STRING      [HEX DUMP]:4620AEA54621405F
  155:d=3  hl=4 l= 664 prim: cont [ 0 ]        
  823:d=1  hl=2 l=   2 prim: INTEGER           :0100
</code></pre>

<p>and some code:</p>

<pre><code> var ed = EnvelopedData.GetInstance(encodedkey);
</code></pre>
","<p>Seems some wrapper code is missing from the der-data above:</p>

<pre><code>            var bs = new MemoryStream();
            var constructeddata = new DerSequenceGenerator(bs);
            constructeddata.AddObject(new DerObjectIdentifier(""1.2.840.1.113549.1.7.3""));
            constructeddata.AddObject(new DerTaggedObject(true, 0, ed));
            //constructeddata.AddObject(ed.ToAsn1Object());
            constructeddata.Close();

            var derdata = bs.ToArray();


            var cms = new CmsEnvelopedData(derdata);
</code></pre>

<p>So what I do is adding a top layer to the data. ed is the EnvelopedData that I was able to import from the der-data.</p>
","314","<c#><bouncycastle><pkcs#7>","1","1","1","2014-04-24 11:59:29","23268282","0","","41956","","2014-04-23 18:45:41","2014-04-23 18:44:24",""
"24123082","OWA not verifying emails signed by OpenSSL","<p>I am trying to create an android app which can send sign and encrypted mails using OpenSSL. </p>

<p>So far I am able to send Signed Emails and verify them using both web browsers and my android apps. </p>

<p>Same is the case with Encryption and Decryption. </p>

<p>But now when I am trying to send signed+encrypted mails from my android app. The Exchange server is unable to verify/decrypt the mails send from my android app. </p>

<p>When I am trying to open open these mails using OWA I get this error: </p>

<pre><code>One or more errors occurred while the message was being loaded. Error: (0x800ccef6)
The digital signature of this message couldn't be validated because an error occurred while the message was being loaded.
</code></pre>

<p>Any pointers about what this error code means? </p>

<p><strong>UPDATE 1:-</strong> Adding encryption and signing code. </p>

<p><em>Sign Code:</em></p>

<pre><code>public static boolean Java_PKCS7Sign(File inputFile, File outputFile, PrivateKey privateKey, X509Certificate certificate, String signingAlgorithm) {
    try {
        String inputFilePath = inputFile.getAbsolutePath();
        String outputFilePath = outputFile.getAbsolutePath();

        byte arr[] = android.security.Credentials.convertToPem(certificate);
        InputStream certIs = new  ByteArrayInputStream(arr);
        OpenSSLX509Certificate openSSLcert = OpenSSLX509Certificate.fromX509PemInputStream(certIs);
        byte openSSLcertEncoded[] = openSSLcert.getEncoded();
        long signCertRef = NativeCrypto.d2i_X509(openSSLcertEncoded);

        OpenSSLKey oKey = OpenSSLKey.fromPrivateKey(privateKey);
        long evpKeyRef = oKey.getPkeyContext();

        //boolean res = PKCS7Sign(signCertRef, pkeyRef, certs, bioRef, flags, a, b)
        long arr1[] = new long[0];
        return PKCS7Sign(inputFilePath, signCertRef, evpKeyRef, arr1, outputFilePath);
    } catch (Exception e) {
        e.printStackTrace();
    }


    return false;
}
</code></pre>

<p>In the above code <code>PKCS7Sign</code> is a JNI call to OpenSSL. And the flags used are for signing are: <code>int flgs = PKCS7_STREAM | PKCS7_DETACHED | PKCS7_BINARY ;</code></p>

<p><em>Encrypt Code:</em></p>

<pre><code>public static boolean Java_PKCS7encrypt(File inputData, File output, X509Certificate[] recipientCertificates, String encryptionAlgorithm) {
    if(!inputData.exists() || !output.exists())
        return false;

    try {
        fis = new FileInputStream(inputData);
        OpenSSLBIOInputStream bis = new OpenSSLBIOInputStream(fis);
        long bioRef = NativeCrypto.create_BIO_InputStream(bis);

        int certsRefArrLength = recipientCertificates.length;
        long certsRefArr[] = new long[certsRefArrLength];
        for (int i = 0; i &lt; certsRefArrLength; i++) {
            byte arr[] = android.security.Credentials.convertToPem(recipientCertificates[i]);
            InputStream certIs = new  ByteArrayInputStream(arr);
            OpenSSLX509Certificate openSSLcert = OpenSSLX509Certificate.fromX509PemInputStream(certIs);
            byte openSSLcertEncoded[] = openSSLcert.getEncoded();
            certsRefArr[i] = NativeCrypto.d2i_X509(openSSLcertEncoded);
        }

        String outputFilePath = output.getAbsolutePath();

        return PKCS7encrypt(bioRef, certsRefArr, outputFilePath, encryptionAlgorithm);


    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (CertificateEncodingException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}
</code></pre>

<p>Same as in case of sign <code>PKCS7encrypt</code> is a JNI call to OpenSSL. And flags used are: </p>

<pre><code>int flags = PKCS7_STREAM | PKCS7_BINARY;
</code></pre>

<p>And cipher used for encryption is <code>cipher = EVP_rc2_40_cbc();</code></p>
","","311","<outlook><openssl><pkcs#7><outlook-web-app><email-verification>","1","","0","2014-06-10 05:50:15","","2","","1416742","","2014-06-10 05:50:15","2014-06-09 15:02:25",""
"19999947","blowfish encryption with iaik pkcs7 EnvelopedData","<p>I am migrating my module from bouncy castle to <a href=""http://javadoc.iaik.tugraz.at/iaik_jce/current/"" rel=""nofollow"">iaik</a> pkcs7. I need to use blowfish,twofish and idea encryption algorithms in conjunction with iaik.pkcs.pkcs7.EnvelopedDataStream of IAIK library. Idea encryption algorithm Id is present in AlgorithmID class of IAIK but cant be implemented directly(probably because of variable key length). Blowfish is present as separate cipher class but I could not figure out a way to use it along with enveloped data(which is important because I will be using public key encryption method). I can actually encrypt using blowfish,then wrap using enveloped data and some algorithm such as aes and send this but the receiver won't have the algorithm info in that case. Secret key can be passed along with recepientInfo.</p>

<p>If anyone can possible show me the way een basic I may be able to proceed.</p>

<p>Thanks in advance</p>

<p>Atraya</p>
","<p>Hi I came up with the solution </p>

<p>ByteArrayInputStream is = new ByteArrayInputStream(message);</p>

<pre><code>  AlgorithmID blowfish=new AlgorithmID(""1.3.6.1.4.1.3029.1.2"",""BLOWFISH_CBC"",""Blowfish/CBC/PKCS5Padding"");
  byte[] iv = new byte[8];
    random.nextBytes(iv);
  try{
        KeyGenerator keyGen = KeyGenerator.getInstance(""Blowfish"", ""IAIK"");
        secretKey = keyGen.generateKey();

        AlgorithmParameterSpec params = new IvParameterSpec(iv);

        keyGen.init(128);

        secretKey = keyGen.generateKey();
        iaik.pkcs.pkcs7.EncryptedContentInfoStream eci = new iaik.pkcs.pkcs7.EncryptedContentInfoStream(ObjectID.pkcs7_data, is);
        eci.setupCipher(blowfish, secretKey, params);
        return eci;
  }catch(Exception e){

  }
</code></pre>

<p>Tell me if this way is wrong or can be improved or there is another way of doing this.</p>

<p>thanks</p>
","300","<java><public-key-encryption><blowfish><pkcs#7><iaik-jce>","0","0","1","2013-11-19 06:52:03","","0","4","","","","2013-11-15 11:22:50",""
"55237425","Sign multiple location with same response xml signature in PKCS7 (CMS)","<p>PDF document needs to signed with national digital identity.<br>
National digital identity WebService provide facility to sign document, in my project I have integrated same. </p>

<p>Requesting Esign services give response in <code>PKCS7(CMS)</code> format.
I want to append same response in multiple locations, So i am creating multiple  empty signature container post i receive Response from service.</p>

<p>I referred this article : <a href=""https://stackoverflow.com/questions/46243127/sign-pdf-using-itextsharp-and-xml-signature"">Sign Pdf Using ITextSharp and XML Signature</a></p>

<p>But in given article we only one signing location is present but i have multiple signing locations.</p>

<p>I am using <code>itext</code> sharp Library.
Using <code>MakeSignature.SignDeferred</code> Method to append signature at multiple locations but it is showing PDF invalid.</p>

<p>Please find below response XML which i received from Webservice:</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;EsignResp errCode=""NA"" errMsg=""NA"" resCode=""259A52453BE95D3A1071193995E062E3EAD796AD"" status=""1"" ts=""2019-03-18T14:26:59"" txn=""UKC:eSign:2998:20190318142602814""&gt;
    &lt;UserX509Certificate&gt;--Usercerti in base64--&lt;/UserX509Certificate&gt;
    &lt;Signatures&gt;
        &lt;DocSignature error="""" id=""1"" sigHashAlgorithm=""SHA256""&gt;--Signature in base 64 in PKCS7(CMS)---&lt;/DocSignature&gt;
    &lt;/Signatures&gt;
    &lt;Signature xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
        &lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
            &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""&gt;&lt;/CanonicalizationMethod&gt;
            &lt;SignatureMethod Algorithm=""http://www.w3.org/2001/04/xmldsig-more#rsa-sha256""&gt;&lt;/SignatureMethod&gt;
            &lt;Reference URI=""""&gt;
                &lt;Transforms&gt;
                    &lt;Transform Algorithm=""http://www.w3.org/2000/09/xmldsig#enveloped-signature""&gt;&lt;/Transform&gt;
                &lt;/Transforms&gt;
                &lt;DigestMethod Algorithm=""http://www.w3.org/2001/04/xmlenc#sha256""&gt;&lt;/DigestMethod&gt;
                &lt;DigestValue&gt;MrOfovytOIp/8qlEkgamrcyhGTSGTN5aS1P+08Fbwfk=&lt;/DigestValue&gt;
            &lt;/Reference&gt;
        &lt;/SignedInfo&gt;
        &lt;SignatureValue&gt;BBexJyk47YaTdoDgXaFRCtJq1Gc3KsZNt48/I8X4TgNJ6gh2NI9Y5Y9Tc7bozrK/QRy1VYPOWYq5r/YdunjMQLmJJicyeqeqe2eD+TJ8oecpjCbmhPnDK2VgaJ2h00lIe/toKwAmV4PTBA1a5wkz77hj+HTkWXMkPEIsBUnBirVpHxe2bYaa7jcIIpWtJmqvcSurKTOeyFRa+AFWfwWHB/EzHJlDmgiMXzrNauxJ4HpphNaRU+bO5JdyzJs/8Zx4i6qwSEybkuprL3GdO9C7zMPiC98CTfO2UrbZWy1pSvwEqlVXQIfrkp+m2JRbFgT8EEIGfXUS+AJBPRwhY1Xsww==&lt;/SignatureValue&gt;
        &lt;KeyInfo&gt;
            &lt;KeyValue&gt;
                &lt;RSAKeyValue&gt;
                    &lt;Modulus&gt;0o9vohWZ3ztI9ea8D/zUEUBRq6c82BE7sFmr1hNMeuGSJQFf39ceesRtGUzlUYVWXcU23P8sVZ5419CHh7ApFzUXaLD72i/2d5FFI0n3iRlTQec9PEUHyrvOCVDpqBhbnrO/EHBqRluUQJTQUtMu5mhPNFV7IIJMTEAsUhCL9adZXXQK9NeK0foRr29Oq7VdEGfSeLzHIibpQmhNPh89oJXqu0cmbNSW4J4i2GmwHQpmsmHaSQcgh4mgVrykO64pAKXPreAPipDHQM1l/e5hilYlWfLHxhC5ObTCTcydQ218IVulFOFhdQt7xVV61TOmoTC2elhWbDqoLJBVU5mBfQ==&lt;/Modulus&gt;
                    &lt;Exponent&gt;AQAB&lt;/Exponent&gt;
                &lt;/RSAKeyValue&gt;
            &lt;/KeyValue&gt;
            &lt;X509Data&gt;
                &lt;X509SubjectName&gt;CN=DS NSDL E GOVERNANCE INFRASTRUCTURE LIMITED 3,ST=MAHARASHTRA,PostalCode=400013,O=NSDL E GOVERNANCE INFRASTRUCTURE LIMITED,C=IN&lt;/X509SubjectName&gt;
                &lt;X509Certificate&gt;--public certificate of provider--- &lt;/X509Certificate&gt;
            &lt;/X509Data&gt;
        &lt;/KeyInfo&gt;
    &lt;/Signature&gt;
&lt;/EsignResp&gt;
</code></pre>

<p><strong>EDIT:</strong> As per latest communication, Web Service provide response for whatever hash is being provided from my end. They do not validate it. Hash is any 64 character string. Kindly let me know what are the possible ways by which i can use this to append PKCS7 signature on a PDF document. </p>

<p><strong>Below Code for generating request :</strong></p>

<pre><code>if (System.IO.File.Exists(tempPdf))
System.IO.File.Delete(tempPdf);

using (PdfReader reader = new PdfReader(pdfReadServerPath))
{
    using (FileStream os = System.IO.File.OpenWrite(tempPdf))
    {
        PdfStamper stamper = PdfStamper.CreateSignature(reader, os, '\0',null,true);

        PdfSignatureAppearance appearance = stamper.SignatureAppearance;

        appearance.SetVisibleSignature(new Rectangle(15, 15, 100, 100), 1, ""sign1"");

        appearance.CertificationLevel = PdfSignatureAppearance.NOT_CERTIFIED;
         AllPagesSignatureContainer external = new AllPagesSignatureContainer(appearance);

        MakeSignature.SignExternalContainer(appearance, external, 8192);
        Stream data = appearance.GetRangeStream();

       Stream data = appearance.GetRangeStream();
        byte[] hash = ReadFully(data); //Convert stream to byte
        _signatureHash = hash;


    }
}
//create sha256 message digest
using (SHA256.Create())
{
    _signatureHash = SHA256.Create().ComputeHash(_signatureHash);
}
bool check = false;
string hexencodedDigest = null;
//create hex encoded sha256 message digest
hexencodedDigest = new BigInteger(1, _signatureHash).ToString(16);
hexencodedDigest = hexencodedDigest.ToUpper();
if (hexencodedDigest.Length == 64)
{
    **Send this hexencoded hash to webservice**
}
</code></pre>

<p><strong>Below code for appending signature:</strong> </p>

<pre><code>//DLL Call
eSign2_1_Request_Response req_resp = new eSign2_1_Request_Response();

//// Response XML Digest process
string resp_xml = Request.Form[""msg""].ToString();//signature response XML;
XmlDocument xmlDoc = new XmlDocument();
xmlDoc.LoadXml(resp_xml);
XmlElement EsignResp = xmlDoc.DocumentElement;
if (EsignResp.Attributes != null &amp;&amp; EsignResp.Attributes[""status""].Value != ""1"")
{
    req_resp.WriteTextFileLog(""errCode: "" + EsignResp.Attributes[""errCode""].Value + "" &amp; Error Message: "" + EsignResp.Attributes[""errMsg""].Value, ""log"", base_folder_path);
}
else
{
    req_resp.WriteTextFileLog(resp_xml, ""xml"", base_folder_path + ""\\"" + file_withoutExtn + ""_responseXML.txt"");
    //-------Continue to generate signed PDF by passing parameter to DLL

    XmlNodeList nodeList = xmlDoc.GetElementsByTagName(""Signatures"");

    string signature = nodeList[0].FirstChild.InnerText;

    string signedPdf = @""D:\POC Hosted\TryNSDL\TryNSDL\wwwroot\TempPath\signedPdf.pdf"";
    string tempPdf = @""D:\POC Hosted\TryNSDL\TryNSDL\wwwroot\TempPath\tempPdf.pdf"";
    using (PdfReader reader = new PdfReader(tempPdf))
    {

        using (FileStream os = System.IO.File.OpenWrite(signedPdf))
        {
            byte[] encodedSignature = Convert.FromBase64String(signature);

            IExternalSignatureContainer external = new MyExternalSignatureContainer(encodedSignature);

            MakeSignature.SignDeferred(reader, ""sign1"", os, external);
        }
    }
}
</code></pre>

<p>Code for Allsignature container:</p>

<pre><code>public class AllPagesSignatureContainer : IExternalSignatureContainer
{
    public AllPagesSignatureContainer(PdfSignatureAppearance appearance)
    {
        this.appearance = appearance;

    }

    public void ModifySigningDictionary(PdfDictionary signDic)
    {
        signDic.Put(PdfName.FILTER, PdfName.ADOBE_PPKMS);
        signDic.Put(PdfName.SUBFILTER, PdfName.ADBE_PKCS7_DETACHED);

        PdfStamper stamper = appearance.Stamper;
        PdfReader reader = stamper.Reader;
        PdfDictionary xobject1 = new PdfDictionary();
        PdfDictionary xobject2 = new PdfDictionary();
        xobject1.Put(PdfName.N, appearance.GetAppearance().IndirectReference);
        xobject2.Put(PdfName.AP, xobject1);

        PdfIndirectReference PRef = stamper.Writer.PdfIndirectReference;
        PdfLiteral PRefLiteral = new PdfLiteral((PRef.Number + reader.NumberOfPages) + "" 0 R"");

        for (int i = 2; i &lt; reader.NumberOfPages+1; i++)
        {
            var signatureField = PdfFormField.CreateSignature(stamper.Writer);

            signatureField.Put(PdfName.T, new PdfString(""ClientSignature_"" + i.ToString()));
            signatureField.Put(PdfName.V, PRefLiteral);
            signatureField.Put(PdfName.F, new PdfNumber(""132""));
            signatureField.SetWidget(new Rectangle(15, 15, 100, 100), null);
            signatureField.Put(PdfName.SUBTYPE, PdfName.WIDGET);

            signatureField.Put(PdfName.AP, xobject1);
            signatureField.SetPage();
            Console.WriteLine(signatureField);

            stamper.AddAnnotation(signatureField, i);
        }
    }

    public byte[] Sign(Stream data)
    {
       return new byte[0];
    }

    PdfSignatureAppearance appearance;

}
</code></pre>

<p><strong>I used append mode in create signature then signature doesn't come. Only empty signatures are visible in adobe reader : <a href=""https://www.sendspace.com/file/5d1z0t"" rel=""nofollow noreferrer"">https://www.sendspace.com/file/5d1z0t</a></strong></p>

<p><strong>If i try same without appendmode <code>PdfStamper stamper = PdfStamper.CreateSignature(reader, os, '\0');</code> and <code>PdfLiteral PRefLiteral = new PdfLiteral((PRef.Number + 1 + 2 * (reader.NumberOfPages - 1)) + "" 0 R"");</code>
then it works fine : <a href=""https://www.sendspace.com/file/agat9a"" rel=""nofollow noreferrer"">https://www.sendspace.com/file/agat9a</a>, but it can be used for single signer only. Nd if we again try to use same pdf to Resign then old signatures becomes invalid. (obviously since append mode is not used.)</strong></p>

<p>I guess For signing to work in append mode, Change is required in line of <code>PdfLiteral</code> - I have less idea about same how it actually works.</p>

<p>Signed file :<a href=""https://www.sendspace.com/file/5d1z0t"" rel=""nofollow noreferrer"">https://www.sendspace.com/file/5d1z0t</a>
Input file: <a href=""https://www.sendspace.com/file/wh2h2y"" rel=""nofollow noreferrer"">https://www.sendspace.com/file/wh2h2y</a></p>
","<p><em>A first quick look through your code revealed two major errors.</em></p>

<h3>Hashing twice</h3>

<p>You hash the document data twice (using different APIs for that... weird!):</p>

<pre><code>        Stream data = appearance.GetRangeStream();

        byte[] hash = DigestAlgorithms.Digest(data, ""SHA256"");

        [...]

        _signatureHash = hash;// signatureHash;
    }
}

[...]
using (SHA256.Create())
{
    _signatureHash = SHA256.Create().ComputeHash(_signatureHash);
}
</code></pre>

<p>This is wrong, this makes no sense.</p>

<h3>Injecting the wrong signature container</h3>

<p>You say</p>

<blockquote>
  <p>Requesting Esign services give response in PKCS7(CMS) format.</p>
</blockquote>

<p>But instead of using the CMS signature container from the result as such, you try to build an own CMS container, injecting the Esign response CMS container as if it was a mere signed hash:</p>

<pre><code>XmlNodeList UserX509Certificate = xmlDoc.GetElementsByTagName(""UserX509Certificate"");
byte[] rawdat = Convert.FromBase64String(UserX509Certificate[0].InnerText);
var chain = new List&lt;Org.BouncyCastle.X509.X509Certificate&gt;
{
    Org.BouncyCastle.Security.DotNetUtilities.FromX509Certificate(new X509Certificate2(rawdat))
};
var signaturee = new PdfPKCS7(null, chain, ""SHA256"", false);
_signature = signaturee;

_signature.SetExternalDigest(Convert.FromBase64String(signature), null, ""RSA"");

byte[] encodedSignature = _signature.GetEncodedPKCS7(_hash, null, null, null, CryptoStandard.CMS);
</code></pre>

<p>According to your comments in the XML</p>

<pre class=""lang-xml prettyprint-override""><code>    &lt;DocSignature error="""" id=""1"" sigHashAlgorithm=""SHA256""&gt;--Signature in base 64 in PKCS7(CMS)---&lt;/DocSignature&gt;
</code></pre>

<p>this <code>DocSignature</code> element contains the CMS signature container.</p>

<p>Thus, remove the code segment above and instead put the content of the <code>DocSignature</code> element (don't forget to base64 decode) into the <code>byte[] encodedSignature</code>. Now you can inject it into the prepared signature as before:</p>

<pre><code>IExternalSignatureContainer external = new MyExternalSignatureContainer(encodedSignature);

MakeSignature.SignDeferred(reader, ""sign1"", os, external);
</code></pre>

<hr>

<p><em>After you fixed the issues above, two more became apparent:</em></p>

<h3>Using the wrong file mode</h3>

<p>You open the stream to write to like this:</p>

<pre><code>using (FileStream os = System.IO.File.OpenWrite(signedPdf))
</code></pre>

<p><code>File.OpenWrite</code> is <a href=""https://docs.microsoft.com/dotnet/api/system.io.file.openwrite"" rel=""nofollow noreferrer"">documented on docs.microsoft.com</a> to be</p>

<blockquote>
  <p>equivalent to the <code>FileStream(String, FileMode, FileAccess, FileShare)</code> constructor overload with file mode set to <code>OpenOrCreate</code>, the access set to <code>Write</code>, and the share mode set to <code>None</code>.</p>
</blockquote>

<p>The file mode <code>OpenOrCreate</code> in turn is <a href=""https://docs.microsoft.com/dotnet/api/system.io.filemode#System_IO_FileMode_OpenOrCreate"" rel=""nofollow noreferrer"">documented</a> to specify</p>

<blockquote>
  <p>that the operating system should open a file if it exists; otherwise, a new file should be created.</p>
</blockquote>

<p>Thus, <em>if there already is a file at the given location, <strong>that file remains and you start writing into it.</em></strong></p>

<p>If the new file you create is longer than the old one, this is no problem, you eventually overwrite all the old file content and then the file grows to house the additional new content.</p>

<p>But if the new file you create is shorter than the old one, you have a problem: After the end of the new file there still is data from the old, longer file. Thus, your result is a hodgepodge of two files.</p>

<p>This happened in case of the example files you shared, your new content of ""signedPdf.pdf"" is only 175982 bytes long but there appears to have been some older file with that name which was 811986 bytes long. Thus, the ""signedPdf.pdf"" file you shared is 811986 bytes long, the first 175982 bytes containing the result of your operation, the rest data from some other file.</p>

<p>If you cut down your shared ""signedPdf.pdf"" file to its first 175982 bytes, the result looks much better!</p>

<p>To solve this issue you should use the file mode <code>Create</code> which is <a href=""https://docs.microsoft.com/dotnet/api/system.io.filemode#System_IO_FileMode_Create"" rel=""nofollow noreferrer"">documented</a> to be </p>

<blockquote>
  <p>equivalent to requesting that if the file does not exist, use <code>CreateNew</code>; otherwise, use <code>Truncate</code>.</p>
</blockquote>

<pre><code>using (FileStream os = new FileStream(signedPdf, FileMode.Create, FileAccess.Write, FileShare.None))
</code></pre>

<h3>An issue with your signing service - identity not yet valid</h3>

<p>As mentioned above, if you cut down your shared ""signedPdf.pdf"" file to its first 175982 bytes, the result looks much better! Unfortunately merely better, not yet good:</p>

<p><a href=""https://i.stack.imgur.com/jqC5x.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jqC5x.png"" alt=""Signature Panel""></a></p>

<p>The reason for your ""identity has expired or is not yet valid"" becomes clearer by looking at the details:</p>

<p><a href=""https://i.stack.imgur.com/udL9B.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/udL9B.png"" alt=""Signature Properties""></a></p>

<p>I.e. the signing time claimed by the PDF is 09:47:59 UTC+1.</p>

<p>But looking at the certificate:</p>

<p><a href=""https://i.stack.imgur.com/2HVyl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2HVyl.png"" alt=""Certificate Viewer""></a></p>

<p>I.e. your certificate is valid not before 09:48:40 UTC+1.</p>

<p>Thus, the claimed signing time is more than half a minute before your user certificate became valid! This obviously cannot be accepted by a validator...</p>

<p>Apparently your signing service creates a short-time certificate for you on demand, valid from just then for half an hour. And the time at which you started creating the PDF signature is <em>not</em> in that interval.</p>

<p>I doubt they will change the design of the signing service for your requirements. Thus, you'll have to cheat a bit and use a signing time slightly in the future.</p>

<p>By default the signing time is set to the current by the <code>PdfSignatureAppearance</code> constructor, i.e. when this line executes:</p>

<pre><code>PdfSignatureAppearance appearance = stamper.SignatureAppearance;
</code></pre>

<p>Fortunately you can change this claimed signing time if you immediately use</p>

<pre><code>appearance.SignDate = [some other date time];
</code></pre>

<p>The date time you should use here has to be shortly (I'd propose not more than 5 minutes) after the time you will call your signing service.</p>

<p><strong>This of course implies that <em>you cannot arbitrarily wait until executing that service call.</em> As soon as you assigned the claimed signing time above, <em>you are committed to have successfully called your signing service shortly before that claimed time!</em></strong></p>

<p>Furthermore, if that signing service turns out to react only slowly or only after some retries, your software should definitively check the certificate in the signature container you retrieve from it and compare its validity interval with your claimed signing time. If the claimed signing time is not in that interval, start signing again!</p>

<hr>

<p><em>Now it became apparent that the <code>AllPagesSignatureContainer</code> you used was designed for a very special use case and still had to be adapted to your use case.</em></p>

<h3>Adapting the <code>AllPagesSignatureContainer</code> for append mode</h3>

<p>The <code>AllPagesSignatureContainer</code> implementation essentially copied from <a href=""https://stackoverflow.com/a/47762053/1729265"">this answer</a> worked fine when not signing in append mode but when signing in append mode it failed.</p>

<p>This at first was plausible because that class has to predict the object number that will be used for the signature value. This prediction depends on the exact use case, and switching on append mode changes this use case considerably. Thus, my advice in a comment was</p>

<blockquote>
  <p>If you need append mode, try to replace the</p>

<pre><code>PdfLiteral PRefLiteral = ...
</code></pre>
  
  <p>line in the <code>AllPagesSignatureContainer</code> by</p>

<pre><code>PdfLiteral PRefLiteral = new PdfLiteral((PRef.Number + reader.NumberOfPages) + "" 0 R"");
</code></pre>
</blockquote>

<p>In my tests that worked but in your tests it still didn't. An analysis of your signed file turned up the cause: My test file was using cross reference tables while yours was using cross reference streams.</p>

<h3>Adapting the <code>AllPagesSignatureContainer</code> for append mode and object streams</h3>

<p>iText in append mode uses the compression features of the original file, i.e. in case of your file it creates an object stream as soon as storing an indirect object that allows storage in an object stream.</p>

<p>In case of your file iText reserved an object number for the object stream, and it did so between the time the <code>AllPagesSignatureContainer</code> predicted the signature value object number and the time the signature value actually was generated. Thus, in your file the actual signature value object number was higher than the predicted number by 1.</p>

<p>To solve this for PDFs with cross reference streams, therefore, one can simply replace the <code>PdfLiteral PRefLiteral = ...</code> line by </p>

<pre><code>PdfLiteral PRefLiteral = new PdfLiteral((PRef.Number + reader.NumberOfPages + 1) + "" 0 R"");
</code></pre>

<p>i.e. by adding 1 to the originally predicted value. Unfortunately now the prediction is wrong for PDFs with cross reference tables...</p>

<p>A better way to fix this is to force iText to reserve an object number for the object stream for cross reference stream PDFs before predicting the signature value object number and then use the original prediction code. One way to do this is by creating and writing an indirect object right before the prediction, e.g. like this:</p>

<pre><code>stamper.Writer.AddToBody(new PdfNull(), stamper.Writer.PdfIndirectReference, true);

PdfIndirectReference PRef = stamper.Writer.PdfIndirectReference;
PdfLiteral PRefLiteral = new PdfLiteral((PRef.Number + reader.NumberOfPages) + "" 0 R"");
</code></pre>

<p><em><a href=""https://stackoverflow.com/a/47762053/1729265"">The answer</a> the <code>AllPagesSignatureContainer</code> implementation essentially was copied from has been updated accordingly.</em></p>
","299","<c#><pdf><itext><signature><pkcs#7>","2","3","1","2019-03-25 14:53:21","55247695","23","0","9601341","","2019-03-25 11:00:30","2019-03-19 09:22:51",""
"47309060","How to Generate PKCS7 for Sha256 hash of any file or plain text in java and verification process?","<p><strong><em>Code for Pkcs7 generation</em></strong>  </p>

<pre><code>@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public static byte[] createDetachedSignature() throws NoSuchAlgorithmException, NoSuchProviderException, DSCException, InvalidKeyException, SignatureException, CertificateEncodingException, OperatorCreationException, CMSException, IOException{

    //byte[] contentToSign = generateHash(""Test"".getBytes(Charset.forName(""UTF-8""))).getBytes();
    //System.out.println(""Original Content :: ""+new String(contentToSign));

    DSCUtil.initKeyStore();
    DSCertificate dscCert = DSCUtil.findBySerialNumber(new BigInteger(""1396617567""));

    PrivateKey privKey = dscCert.getPrivateKey();
    Signature signature = Signature.getInstance(""SHA256WithRSA"");
    signature.initSign(privKey);
    signature.update(""Test"".getBytes(Charset.forName(""UTF-8"")));

    //X509Certificate cert = dscCert.getCertificate();
   // List certList = new ArrayList();
    CMSTypedData msg = new CMSProcessableByteArray(signature.sign());
    //certList.add(cert);

    Store certs = new JcaCertStore(Arrays.asList(dscCert.getCertChain()));
    CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
    ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA256withRSA"").build(privKey);
    gen.addSignerInfoGenerator(
            new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build())
                    .build(sha1Signer, dscCert.getCertificate()));
    gen.addCertificates(certs);
    CMSSignedData sigData = gen.generate(msg, true);

    //BASE64Encoder encoder = new BASE64Encoder();


    String signedContent = Base64.encodeBase64String((byte[]) sigData.getSignedContent().getContent());
    System.out.println(""Signed content: "" + signedContent + ""\n"");

    String envelopedData = Base64.encodeBase64String(sigData.getEncoded());
    System.out.println(""Enveloped data: "" + envelopedData);


    return envelopedData.getBytes();
}
</code></pre>

<p><strong><em>Code for verification</em></strong></p>

<pre><code>@SuppressWarnings({ ""deprecation"", ""rawtypes"" })
public static boolean verifyTextwithPKCS7(String input, byte[] pkcs7Resp) throws NoSuchAlgorithmException, NoSuchProviderException {
    boolean result = false;
    if (pkcs7Resp.length &lt;= 0) {
        return result;
    }
    //String hash = generateHash(input.getBytes(Charset.forName(""UTF-8"")));
    try {
        CMSSignedData cms = new CMSSignedData(new CMSProcessableByteArray(input.getBytes()),
                pkcs7Resp);
        System.out.println(new String((byte[]) cms.getSignedContent().getContent()));
        CertStore certStore = cms.getCertificatesAndCRLs(""Collection"", ""BC"");
        SignerInformationStore signers = cms.getSignerInfos();
        Collection c = signers.getSigners();
        Iterator it = c.iterator();
        while (it.hasNext()) {
            SignerInformation signer = (SignerInformation) it.next();
            Collection certCollection = certStore.getCertificates(signer.getSID());
            Iterator certIt = certCollection.iterator();
            X509Certificate cert = (X509Certificate) certIt.next();
            result = signer.verify(cert, ""BC"");
            System.out.println(new String(signer.getContentDigest()));
        }
    } catch (Exception e) {
        e.printStackTrace();
        result = false;
    }
    return result;
}
</code></pre>

<p>Please tell me either any problem in Generation of PKCS#7 or in verification process.</p>

<p>if my process is wrong then please suggest me the right mechanism with some code snippet. </p>
","","298","<java><sha256><pkcs#7><java-security><message-digest>","0","","0","2017-11-15 20:59:34","","3","","472495","","2017-11-15 20:59:34","2017-11-15 13:45:58",""
"51144473","""jarsigner -tsa ..."" leads to a jar that cannot be verified on java 6, while simply ""jarsigner ..."" is fine","<p>The company I work for distributes a part of its software as signed Java jar files. There is a requirement that the jar files must be ""verifiable"" on Java 6. There is a mechanism that reads the jar entries and fails when either a signature is wrong or absent for any entry. The code is (simplified):</p>

<pre><code>import java.io.*;
import java.security.cert.Certificate;
import java.util.Enumeration;
import java.util.jar.*;

public final class JarCheckSimple {

    public static void main(String[] args) throws IOException {
        check(new File(""SuperAwesome.jar""));
    }

    private static void check(File file) throws IOException {
        JarFile jar = new JarFile(file);
        Manifest manifest = jar.getManifest();
        if (manifest == null) {
            throw new SecurityException(""jar not signed "" + jar);
        }

        byte[] buffer = new byte[8096];
        Enumeration entries = jar.entries();
        while (entries.hasMoreElements()) {
            JarEntry e = (JarEntry) entries.nextElement();
            if (!e.isDirectory() &amp;&amp; !e.getName().startsWith(""META-INF"")) {
                InputStream is = jar.getInputStream(e);
                while (is.read(buffer, 0, buffer.length) != -1) { /* to be verified by VerifierStream */ }
                is.close();

                Certificate[] certs = e.getCertificates();
                if (certs == null || certs.length == 0) { /* Works on Java 8, fails on Java 6: (certs == null) is true there */
                    throw new SecurityException(""unsigned entry "" + e.getName());
                }
            }
        }
    }
}
</code></pre>

<p>Recently our Release Engineering department has tried to change the signing process to enable signature timestamp support (this thing: <a href=""https://docs.oracle.com/javase/7/docs/technotes/guides/security/time-of-signing.html"" rel=""nofollow noreferrer"">https://docs.oracle.com/javase/7/docs/technotes/guides/security/time-of-signing.html</a>), and since then the check above started to fail on Java 6 (only) -- my question ultimately will be why, but I have to give some details first. Release Engineering claim they use all the same certificates and all, the only change is they added ""-tsa <a href=""http://sha256timestamp.ws.symantec.com/sha256/timestamp"" rel=""nofollow noreferrer"">http://sha256timestamp.ws.symantec.com/sha256/timestamp</a>"" to the jarsigner command they have.</p>

<p>I set the <code>-Djava.security.debug=jar</code> parameter for the code above and got this difference in the output (for jar files signed with and without timestamp, checked on Java 6 and Java 8):</p>

<p>Java 6, no timestamp (CERTIFICATE.RSA is under 4 KB here):</p>

<pre><code>jar: beginEntry META-INF/MANIFEST.MF
jar: done with meta!
jar: nothing to verify!
jar: beginEntry META-INF/MANIFEST.MF
jar: beginEntry META-INF/CERTIFICATE.SF
jar: processEntry: processing block
jar: beginEntry META-INF/CERTIFICATE.RSA
jar: processEntry: processing block
jar: Signature Block Certificate: [
[
  Version: V3
  Subject: CN=SuperCompany Ltd, OU=IT, O=SuperCompany Ltd, L=Rwanda, C=CH
  Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11

  Key:  Sun RSA public key, 2048 bits
  modulus: ...
  public exponent: 65537
  Validity: [From: Tue May 29 02:00:00 CEST 2018,
               To: Sun Jun 28 01:59:59 CEST 2020]
  Issuer: CN=thawte SHA256 Code Signing CA, O=""thawte, Inc."", C=US
  SerialNumber: [    ...]

Certificate Extensions: 8
...
</code></pre>

<p>So it looks like the certificate is found and parsed.</p>

<p>Java 8, with timestamp (CERTIFICATE.RSA is over 7 KB here):</p>

<pre><code>jar: beginEntry META-INF/MANIFEST.MF
jar: done with meta!
jar: nothing to verify!
jar: beginEntry META-INF/MANIFEST.MF
jar: beginEntry META-INF/CERTIFICATE.SF
jar: processEntry: processing block
jar: beginEntry META-INF/CERTIFICATE.RSA
jar: processEntry: processing block
jar: Unsupported signer attribute: 1.2.840.113549.1.9.16.2.47
jar:
jar: Detected signature timestamp (#885515941755655847907684100465949331954643356622) generated on Tue Jun 26 14:11:42 CEST 2018
jar:
jar: Signature Block Certificate: [
[
  Version: V3
  Subject: CN=SuperCompany Ltd, OU=IT, O=SuperCompany Ltd, L=Rwanda, C=CH
  Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11

  Key:  Sun RSA public key, 2048 bits
  modulus: ...
  public exponent: 65537
  Validity: [From: Tue May 29 02:00:00 CEST 2018,
               To: Sun Jun 28 01:59:59 CEST 2020]
  Issuer: CN=thawte SHA256 Code Signing CA, O=""thawte, Inc."", C=US
  SerialNumber: [    ...]

Certificate Extensions: 8
...
</code></pre>

<p>Note the ""warning"" about ""Unsupported signer attribute: 1.2.840.113549.1.9.16.2.47""; but still, the certificate is parsed fine.</p>

<p>Now, the problem: Java 6, with timestamp (CERTIFICATE.RSA is over 7 KB here):</p>

<pre><code>jar: beginEntry META-INF/MANIFEST.MF
jar: beginEntry META-INF/CERTIFICATE.SF
jar: processEntry: processing block
jar: beginEntry META-INF/CERTIFICATE.RSA
jar: processEntry: processing block
jar: ignoring unsupported signer attribute: 1.2.840.113549.1.9.16.2.47
jar: processEntry caught: sun.security.pkcs.ParsingException: Unable to parse the encoded bytes
jar: done with meta!
jar: nothing to verify!
...
</code></pre>

<p>So, Java can't parse some block, therefore it treats the whole jar as unsigned, therefore our check (above) fails: the JarEntry::getCertificates() returns null.
For the sake of completeness: running ""jarsigner -verify -verbose -certs SuperAwesome.jar"" prints everything fine for the jarsigner from JDK 8, and prints for each jar entry that it was simply ""mentioned"" (not signed) for JDK 6.</p>

<p>Debugging with some OpenJDK source code attached, I found that this is why Java 6 fails (<code>sun.security.pkcs.PKCS9Attribute#PKCS9Attribute(sun.security.util.DerValue)</code>):</p>

<pre><code>    ...
    // get the oid
    ObjectIdentifier oid = val[0].getOID();
    index = indexOf(oid, PKCS9_OIDS, 1);
    if (index == -1) {
        if (debug != null) {
            debug.println(""ignoring unsupported signer attribute: "" + oid);
        }
        throw new ParsingException(""Unsupported PKCS9 attribute: "" + oid);
    }
    ...
</code></pre>

<p>While Java 8 passes fine:</p>

<pre><code>    ...
    // get the oid
    oid = val[0].getOID();
    byte[] content = val[1].toByteArray();
    DerValue[] elems = new DerInputStream(content).getSet(1);

    index = indexOf(oid, PKCS9_OIDS, 1);
    if (index == -1) {
        if (debug != null) {
            debug.println(""Unsupported signer attribute: "" + oid);
        }
        value = content;
        return;
    }
    ...
</code></pre>

<p>Also, all logic in <code>sun.security.pkcs.PKCS9Attribute</code> is ready for this.index == -1, unlike in the Java 6 version. I can even modify this class to be more like in JDK 8, and then the test passes; the problem however is that I don't have control over the user's JDK.</p>

<p>It looks like my problem could be solved if the certificate didn't have this ""1.2.840.113549.1.9.16.2.47"" oid present (the only info I could find on it is: <a href=""http://oid-info.com/get/1.2.840.113549.1.9.16.2.47"" rel=""nofollow noreferrer"">id-aa-signingCertificateV2</a>). I have to confess I know nothing about the whole process of signing (both in principle and how it's done by our Release Engineering -- it seems they obscure it on purpose), certificates etc.</p>

<p>Now, my questions are:</p>

<ol>
<li>Am I right that the most straightforward way to fix this would be to get rid of this attribute ""1.2.840.113549.1.9.16.2.47""?</li>
<li>Is it possible to say having the information I provided what introduces it into the resulting certificate that ends up in the jar file? (That CERTIFICATE.RSA)</li>
<li>If not, could you hint me what my next steps could be in trying to track down or fix the problem? I am stuck.</li>
</ol>

<p>I am on Windows 7, using Oracle JDK 6 update 45 and Oracle JDK 8 update 20.
Thank you in advance.</p>
","","289","<java><pkcs#7><java-security>","0","","0","2018-07-02 22:48:18","","2","","2369544","","2018-07-02 22:48:18","2018-07-02 22:34:17",""
"24570491","Crash in Firefox extension Using NSS","<p>I am new to Firefox extension development.</p>

<p>We got a firefox Extension that signs PDF (encapsulated signature) working for all versions of firefox prior to 22 (22 not included) Using NSS 3.12. After that Firefox version, there is a modification in the NSS used by it. 
This extension is a JS extension calling C++ fonctions using ctypes.</p>

<p>My goal is to make this extension work on firefox version superior to 22.</p>

<p>I got in my extension libs nspr4.dll, nss3.dll, nssutil3.dll, plc4.dll, plds4.dll generated with mozilla-build from NSS release.</p>

<p>the Code we got is pretty similar to what you can find here : <a href=""https://github.com/metajack/nss/blob/master/cmd/p7sign/p7sign.c"" rel=""nofollow"">https://github.com/metajack/nss/blob/master/cmd/p7sign/p7sign.c</a></p>

<p>the code works well ( it gets the certificates information sucessfully, creates the SEC_PKCS7ContentInfo with SEC_PKCS7CreateSignedData(...), set it's content with SEC_PKCS7SetContent(..), includes the certs chains)
until the call of SEC_PKCS7Encode.
when using this method, fireFox crashes.</p>

<p>I used WinDBG to get the stacktrace and here is what I got:</p>

<pre><code>*******************************************************************************
*                                                                             *
*                           Exception Analysis                                *
*                                                                             *
*******************************************************************************


FAULTING_IP: 
plds4!PL_HashTableLookupConst+c
721b1c7c 8b4f0c          mov     ecx,dword ptr [edi+0Ch]

EXCEPTION_RECORD:  ffffffffffffffff -- (.exr 0xffffffffffffffff)
.exr 0xffffffffffffffff
ExceptionAddress: 00000000721b1c7c (plds4!PL_HashTableLookupConst+0x000000000000000c)
   ExceptionCode: c0000005 (Access violation)
  ExceptionFlags: 00000000
NumberParameters: 2
   Parameter[0]: 0000000000000000
   Parameter[1]: 000000000000000c
Attempt to read from address 000000000000000c

CONTEXT:  0000000000000000 -- (.cxr 0x0;r)
.cxr 0x0;r
eax=063e7b90 ebx=00000000 ecx=dd4c128b edx=063e7c98 esi=063e7b90 edi=00000000
eip=721b1c7c esp=0067c1e8 ebp=063e7898 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210206
plds4!PL_HashTableLookupConst+0xc:
721b1c7c 8b4f0c          mov     ecx,dword ptr [edi+0Ch] ds:002b:0000000c=????????
.cxr

FAULTING_THREAD:  00000000000016cc

PROCESS_NAME:  firefox.exe

ERROR_CODE: (NTSTATUS) 0xc0000005 - L

EXCEPTION_CODE: (NTSTATUS) 0xc0000005 - L

EXCEPTION_PARAMETER1:  0000000000000000

EXCEPTION_PARAMETER2:  000000000000000c

READ_ADDRESS:  000000000000000c 

FOLLOWUP_IP: 
plds4!PL_HashTableLookupConst+c
721b1c7c 8b4f0c          mov     ecx,dword ptr [edi+0Ch]

APPLICATION_VERIFIER_FLAGS:  0

APP:  firefox.exe

ANALYSIS_VERSION: 6.3.9600.17029 (debuggers(dbg).140219-1702) amd64fre

BUGCHECK_STR:  APPLICATION_FAULT_NULL_CLASS_PTR_READ_ZEROED_STACK

PRIMARY_PROBLEM_CLASS:  NULL_CLASS_PTR_READ

DEFAULT_BUCKET_ID:  NULL_CLASS_PTR_READ

LAST_CONTROL_TRANSFER:  from 00000000716b9231 to 00000000721b1c7c

STACK_TEXT:  
WARNING: Stack unwind information not available. Following frames may be wrong.
0067c1f4 716b9231 00000000 063e7b90 063e7ca0 plds4!PL_HashTableLookupConst+0xc
00000000 00000000 00000000 00000000 00000000 nssutil3!SECOID_FindOIDTag_Util+0x11


STACK_COMMAND:  .cxr 0x0 ; kb

SYMBOL_STACK_INDEX:  0

SYMBOL_NAME:  plds4!PL_HashTableLookupConst+c

FOLLOWUP_NAME:  MachineOwner

MODULE_NAME: plds4

IMAGE_NAME:  plds4.dll

DEBUG_FLR_IMAGE_TIMESTAMP:  53a04c1e

FAILURE_BUCKET_ID:  NULL_CLASS_PTR_READ_c0000005_plds4.dll!PL_HashTableLookupConst

BUCKET_ID:  
APPLICATION_FAULT_NULL_CLASS_PTR_READ_ZEROED_STACK_plds4!PL_HashTableLookupConst+c

ANALYSIS_SOURCE:  UM

FAILURE_ID_HASH_STRING:                          um:null_class_ptr_read_c0000005_plds4.dll!pl_hashtablelookupconst

FAILURE_ID_HASH:  {2f7bb160-6820-dd99-35e3-03bb56e8aca4}

Followup: MachineOwner
---------
</code></pre>

<p>It means that when calling the SEC_PKCS7Encode, it calls a method in PLDS4.DLL that make Firefox crash.</p>

<p>I tried to call SEC_PKCS7Encode using an empty SEC_PKCS7ContentInfo (with SEC_PKCS7CreateData()) and it didn't crash. It crashes only when the SEC_PKCS7ContentInfo is filled.</p>

<p>After some reaserchs , I find this issue : <a href=""https://bugzilla.mozilla.org/show_bug.cgi?id=702307"" rel=""nofollow"">https://bugzilla.mozilla.org/show_bug.cgi?id=702307</a> 
I don't know if this issue is what makes my Firefox crash.</p>

<p>I tried to use different version of the NSS (3.12,  3.15, 3.16.2) the results are exactly the same.</p>

<p>Is there some way to avoid this problem ? is there a way to encode my SEC_PKCS7ContentInfo whithout using SEC_PKCS7Encode ?</p>

<p>thanks in advance.</p>

<p>EDIT 11/07/2014</p>

<p>As nmaier mentioned in is response, the probleme seems to be the utilisation of two different NSS (even if it is the same version of the nss because the one in mozilla has different dependencies for exemple).</p>

<p>The signature (and other processes) are done in a C++ project (the Dll used by my extension is generated from this project with visual studio 2013). But in order to compile and build the DLL, the project must have the NSS libs and includes (it is quite normal, I use NSS methods in my project).
The main question is how can I refer the MOZILLA FIREFOX NSS libs and include. I compiled a NSS of the same version of the Firefox's NSS, but the dependecies are different. 
I also tried to get the FireFox sources and compile it's NSS with mozilla build but I got errors. If I can get the Firefox's NSS libs, I could just load the Firefox's NSS dll in my extension.</p>

<p>How can I refers Mozilla firefox's NSS libs in my C++ project to build my custom DLL using the right libs ?</p>
","<p>I'd expect this to misbehave: Firefox already load nss and dependent libraries. Trying to load the ""same"" DLL again, but in a different version will cause the DLL loader to resolve dependent imports using the exports from the initially loaded DLL that comes with Firefox, not your copies of older versions of the same DLL. And this mix of new stuff and old stuff then breaks and crashes.</p>

<p>You should:</p>

<ul>
<li>Not build and ship DLLs in the first place...</li>
<li>but use the DLLs that Firefox already comes with. (e.g. see <a href=""http://hg.mozilla.org/mozilla-central/file/e268bb51e084/services/crypto/modules/WeaveCrypto.js#l123"" rel=""nofollow""><code>WeaveCrypto.js</code></a>)</li>
<li>Update your <code>ctypes</code> calls if the nss API it uses changed in the meantime.</li>
<li>Make sure your <code>ctypes</code> declarations are correct and still up-to-date.</li>
</ul>
","287","<firefox><dll><firefox-addon><pkcs#7><nss>","1","1","2","2014-07-21 07:53:58","24860122","1","","2655786","","2014-07-11 12:36:08","2014-07-04 09:01:27",""
"24570491","Crash in Firefox extension Using NSS","<p>I am new to Firefox extension development.</p>

<p>We got a firefox Extension that signs PDF (encapsulated signature) working for all versions of firefox prior to 22 (22 not included) Using NSS 3.12. After that Firefox version, there is a modification in the NSS used by it. 
This extension is a JS extension calling C++ fonctions using ctypes.</p>

<p>My goal is to make this extension work on firefox version superior to 22.</p>

<p>I got in my extension libs nspr4.dll, nss3.dll, nssutil3.dll, plc4.dll, plds4.dll generated with mozilla-build from NSS release.</p>

<p>the Code we got is pretty similar to what you can find here : <a href=""https://github.com/metajack/nss/blob/master/cmd/p7sign/p7sign.c"" rel=""nofollow"">https://github.com/metajack/nss/blob/master/cmd/p7sign/p7sign.c</a></p>

<p>the code works well ( it gets the certificates information sucessfully, creates the SEC_PKCS7ContentInfo with SEC_PKCS7CreateSignedData(...), set it's content with SEC_PKCS7SetContent(..), includes the certs chains)
until the call of SEC_PKCS7Encode.
when using this method, fireFox crashes.</p>

<p>I used WinDBG to get the stacktrace and here is what I got:</p>

<pre><code>*******************************************************************************
*                                                                             *
*                           Exception Analysis                                *
*                                                                             *
*******************************************************************************


FAULTING_IP: 
plds4!PL_HashTableLookupConst+c
721b1c7c 8b4f0c          mov     ecx,dword ptr [edi+0Ch]

EXCEPTION_RECORD:  ffffffffffffffff -- (.exr 0xffffffffffffffff)
.exr 0xffffffffffffffff
ExceptionAddress: 00000000721b1c7c (plds4!PL_HashTableLookupConst+0x000000000000000c)
   ExceptionCode: c0000005 (Access violation)
  ExceptionFlags: 00000000
NumberParameters: 2
   Parameter[0]: 0000000000000000
   Parameter[1]: 000000000000000c
Attempt to read from address 000000000000000c

CONTEXT:  0000000000000000 -- (.cxr 0x0;r)
.cxr 0x0;r
eax=063e7b90 ebx=00000000 ecx=dd4c128b edx=063e7c98 esi=063e7b90 edi=00000000
eip=721b1c7c esp=0067c1e8 ebp=063e7898 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210206
plds4!PL_HashTableLookupConst+0xc:
721b1c7c 8b4f0c          mov     ecx,dword ptr [edi+0Ch] ds:002b:0000000c=????????
.cxr

FAULTING_THREAD:  00000000000016cc

PROCESS_NAME:  firefox.exe

ERROR_CODE: (NTSTATUS) 0xc0000005 - L

EXCEPTION_CODE: (NTSTATUS) 0xc0000005 - L

EXCEPTION_PARAMETER1:  0000000000000000

EXCEPTION_PARAMETER2:  000000000000000c

READ_ADDRESS:  000000000000000c 

FOLLOWUP_IP: 
plds4!PL_HashTableLookupConst+c
721b1c7c 8b4f0c          mov     ecx,dword ptr [edi+0Ch]

APPLICATION_VERIFIER_FLAGS:  0

APP:  firefox.exe

ANALYSIS_VERSION: 6.3.9600.17029 (debuggers(dbg).140219-1702) amd64fre

BUGCHECK_STR:  APPLICATION_FAULT_NULL_CLASS_PTR_READ_ZEROED_STACK

PRIMARY_PROBLEM_CLASS:  NULL_CLASS_PTR_READ

DEFAULT_BUCKET_ID:  NULL_CLASS_PTR_READ

LAST_CONTROL_TRANSFER:  from 00000000716b9231 to 00000000721b1c7c

STACK_TEXT:  
WARNING: Stack unwind information not available. Following frames may be wrong.
0067c1f4 716b9231 00000000 063e7b90 063e7ca0 plds4!PL_HashTableLookupConst+0xc
00000000 00000000 00000000 00000000 00000000 nssutil3!SECOID_FindOIDTag_Util+0x11


STACK_COMMAND:  .cxr 0x0 ; kb

SYMBOL_STACK_INDEX:  0

SYMBOL_NAME:  plds4!PL_HashTableLookupConst+c

FOLLOWUP_NAME:  MachineOwner

MODULE_NAME: plds4

IMAGE_NAME:  plds4.dll

DEBUG_FLR_IMAGE_TIMESTAMP:  53a04c1e

FAILURE_BUCKET_ID:  NULL_CLASS_PTR_READ_c0000005_plds4.dll!PL_HashTableLookupConst

BUCKET_ID:  
APPLICATION_FAULT_NULL_CLASS_PTR_READ_ZEROED_STACK_plds4!PL_HashTableLookupConst+c

ANALYSIS_SOURCE:  UM

FAILURE_ID_HASH_STRING:                          um:null_class_ptr_read_c0000005_plds4.dll!pl_hashtablelookupconst

FAILURE_ID_HASH:  {2f7bb160-6820-dd99-35e3-03bb56e8aca4}

Followup: MachineOwner
---------
</code></pre>

<p>It means that when calling the SEC_PKCS7Encode, it calls a method in PLDS4.DLL that make Firefox crash.</p>

<p>I tried to call SEC_PKCS7Encode using an empty SEC_PKCS7ContentInfo (with SEC_PKCS7CreateData()) and it didn't crash. It crashes only when the SEC_PKCS7ContentInfo is filled.</p>

<p>After some reaserchs , I find this issue : <a href=""https://bugzilla.mozilla.org/show_bug.cgi?id=702307"" rel=""nofollow"">https://bugzilla.mozilla.org/show_bug.cgi?id=702307</a> 
I don't know if this issue is what makes my Firefox crash.</p>

<p>I tried to use different version of the NSS (3.12,  3.15, 3.16.2) the results are exactly the same.</p>

<p>Is there some way to avoid this problem ? is there a way to encode my SEC_PKCS7ContentInfo whithout using SEC_PKCS7Encode ?</p>

<p>thanks in advance.</p>

<p>EDIT 11/07/2014</p>

<p>As nmaier mentioned in is response, the probleme seems to be the utilisation of two different NSS (even if it is the same version of the nss because the one in mozilla has different dependencies for exemple).</p>

<p>The signature (and other processes) are done in a C++ project (the Dll used by my extension is generated from this project with visual studio 2013). But in order to compile and build the DLL, the project must have the NSS libs and includes (it is quite normal, I use NSS methods in my project).
The main question is how can I refer the MOZILLA FIREFOX NSS libs and include. I compiled a NSS of the same version of the Firefox's NSS, but the dependecies are different. 
I also tried to get the FireFox sources and compile it's NSS with mozilla build but I got errors. If I can get the Firefox's NSS libs, I could just load the Firefox's NSS dll in my extension.</p>

<p>How can I refers Mozilla firefox's NSS libs in my C++ project to build my custom DLL using the right libs ?</p>
","<p>I did It.</p>

<p>In order to specify firefox's NSS in my project, I had to build an entire Firefox with the mozilla-build tool, and then recover the Libs and include for inside the OBJ directory.</p>

<p>this will generate my project as DLL that refers the good version of the DLL.</p>

<p>(this is not the greatest solution I think, as there is a NSS changement of the NSS between Firefox  21 and  22, so my solution will only work for firefox between 22 and the next version of Firefox that include NSS changes.)</p>
","287","<firefox><dll><firefox-addon><pkcs#7><nss>","1","1","2","2014-07-21 07:53:58","24860122","1","","2655786","","2014-07-11 12:36:08","2014-07-04 09:01:27",""
"24079329","Clear Text Signing using OpenSSL in C Code","<p>I am trying to sign a email message using OpenSSL. I want to perform Clear Text Signing on the email message. </p>

<p>I know I can do this using command prompt with the command: </p>

<pre><code>openssl smime -sign -in hw.txt -text -out signed.msg -signer mycert.pem
</code></pre>

<p>But how do I do this using C Code? </p>

<p>This is what I am doing right now: </p>

<pre><code>int flgs = PKCS7_DETACHED | PKCS7_TEXT;
PKCS7 * p7 = PKCS7_sign(signCert, pKey, certs, bio, flgs);
if(p7 != NULL) {
    int res = PKCS7_final(p7, bio, flags);
    __android_log_print(ANDROID_LOG_DEBUG, ""OpenSSLJni"", ""\nFinal result is: %d"", res);
    FILE *outfile = fopen(""/storage/sdcard0/sign_output.txt"", ""w"");
    BIO* out = BIO_new_fp(outfile, BIO_NOCLOSE) ;// BIO_new_file(outfile, """");
    BIO_reset(bio);
    SMIME_write_PKCS7(out, p7, bio, flags);
    return true;
}
</code></pre>

<p>But I in the output file I am only getting the signature not both the body and signature.</p>

<p>Any pointers?  </p>
","<p>Finally did it. </p>

<p>It was just a missing flag. </p>

<pre><code>int flgs = PKCS7_STREAM | PKCS7_DETACHED | PKCS7_BINARY ;
</code></pre>

<p>Added this flag and it started working perfectly. </p>
","286","<c><openssl><sign><pkcs#7><smime>","0","0","1","2014-06-10 05:54:18","24133798","0","","","","","2014-06-06 10:10:14",""
"47508108","Why I can't use SHA1 before PKCS7.detached in iText7?","<p><a href=""https://i.stack.imgur.com/Gzyzf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Gzyzf.png"" alt=""enter image description here""></a></p>

<p>As the picture show , now I can realize the 1 ,and here is my signed success code , I used </p>

<pre><code>pdfSigner.signExternalContainer(iExternalSignatureContainer, estimatedSize);
</code></pre>

<p>not </p>

<pre><code> pdfSigner.signDetached();
</code></pre>

<p>:</p>

<pre><code>public class PdfSignatureContainerExt implements IExternalSignatureContainer {

private MySignUtil mySignUtil;
public PdfSignatureContainerExt(MySignUtil mySignUtil){
    this.mySignUtil= mySignUtil;
}

/**
 * 
 * @param data , the data to sign
 * @return a container with the signature and other objects, like CRL and OCSP. The container will generally be a PKCS7 one.
 * @throws GeneralSecurityException
 */
@Override
public byte[] sign(InputStream data) throws GeneralSecurityException {

    byte[] dataBytes = streamToBytes(data);
    return  mySignUtil.signP7DetachData(dataBytes);

}

@Override
public void modifySigningDictionary(PdfDictionary signDic) {
    signDic.put(PdfName.Filter, PdfName.Adobe_PPKLite);
    signDic.put(PdfName.SubFilter, PdfName.Adbe_pkcs7_detached);
}}
</code></pre>

<p>In order to realize the 2 , I altered the code which the output result is invalid:</p>

<pre><code>public class PdfSignatureContainerExt implements IExternalSignatureContainer {

private MySignUtil mySignUtil;
public PdfSignatureContainerExt(MySignUtil mySignUtil){
    this.mySignUtil= mySignUtil;
}


@Override
public byte[] sign(InputStream data) throws GeneralSecurityException {

        byte[] dataBytes = streamToBytes(data);
        //change here
        BouncyCastleProvider provider = new BouncyCastleProvider();
        Security.addProvider(provider);

        MessageDigest messageDigest = MessageDigest.getInstance(""SHA1"" , ""BC"");
        byte[] hash = messageDigest.digest(dataBytes);

        return  mySignUtil.signP7DetachData(hash);      
}

@Override
public void modifySigningDictionary(PdfDictionary signDic) {
    signDic.put(PdfName.Filter, PdfName.Adobe_PPKLite);
    //change here
    signDic.put(PdfName.SubFilter, PdfName.Adbe_pkcs7_sha1);
}}
</code></pre>

<p>and the output sign result is failed , here is my failed pdf.</p>

<p><a href=""https://www.dropbox.com/s/vndug51hlclpqi9/invalid.pdf?dl=0"" rel=""nofollow noreferrer"">invalid.pdf</a></p>
","<p>The method you use to create the <strong>adbe.pkcs7.detached</strong> CMS signature container</p>

<pre><code>return  mySignUtil.signP7DetachData(data);
</code></pre>

<p>(with an <code>InputStream data</code>) appears to create the container just like the method you use to create the <strong>adbe.pkcs7.sha1</strong> CMS container</p>

<pre><code>return  mySignUtil.signP7DetachData(hash);      
</code></pre>

<p>(with a <code>byte[] hash</code>), at least this is what your example file suggests.</p>

<p>This is wrong: As the PDF Reference 1.7 says:</p>

<blockquote>
  <ul>
  <li><strong>adbe.pkcs7.detached</strong>: No data is encapsulated in the PKCS#7 signed-data field.</li>
  <li><strong>adbe.pkcs7.sha1</strong>: The SHA1 digest of the byte range is encapsulated in the PKCS#7 signed-data field with ContentInfo of type Data.</li>
  </ul>
</blockquote>

<p><em>(section 8.7.2 ""Signature Interoperability"")</em></p>

<p>As you used the equivalent functionality for creating the CMS containers in both cases, you left the <em>PKCS#7 signed-data field</em> (by which the optional <code>eContent</code> octet string in the CMS <code>SignedData</code> field <code>EncapsulatedContentInfo</code> is meant) in your <strong>adbe.pkcs7.sha1</strong> container empty which is against the specification.</p>

<hr>

<p><strong>PS</strong>: Ordinarily I would have referred to the ISO 32000 standards but unfortunately the corresponding sections in both part 1 and part 2 have been changed in a way that makes the content somewhere between even more unclear and outright wrong. Unfortunately that did not cross my mind when one could make inputs for ISO 32000-2.</p>

<p><strong>PPS</strong>: Ceterum censeo <strong>adbe.pkcs7.sha1</strong> should not be used at all anymore. Our validation code explicitly does not implement validation of these signatures.</p>
","275","<itext><sha1><itext7><pkcs#7>","0","2","1","2017-11-29 06:54:03","47512638","1","2","5941014","","2017-11-29 06:54:03","2017-11-27 09:56:10",""
"42557585","Create PKCS7 for PDF signing","<p>I'm trying to sign a PDF with certificate. I prepare the PDF for signing, generate SHA256 hash value of the document, encrypt it with my private key and now I need to create PKCS7 certificate. When I create it like this:</p>

<pre><code>PKCS7 *pkcs7 = PKCS7_sign(certificate, privateKey, ca, fileBIO, PKCS7_DETACHED | PKCS7_BINARY);
PKCS7_final(pkcs7, fileBIO, PKCS7_DETACHED | PKCS7_BINARY);
</code></pre>

<p>the certificate works but it doesn't contain any hash value. How do I insert my custom SHA256 hash value?</p>
","","275","<objective-c><pdf><openssl><digital-signature><pkcs#7>","0","","0","2017-03-02 14:06:48","","4","","","","","2017-03-02 14:06:48",""
"49641515","How to use raw Pkcs#7 signature & user x.509 certificate to stamp it into a PDF file?","<p>I have a raw pkcs#7 signature response, user x.509 certificate &amp; input hash of document to be signed. I need to stamp this  PDF. What is the process to get this PDF signed using above inputs? </p>
","","270","<php><openssl><digital-signature><pkcs#7>","0","","0","2018-04-05 10:43:50","","13","","2072304","","2018-04-05 10:43:50","2018-04-04 01:49:19",""
"48780157","Decrypt apple-app-site-association in browser","<p>I'm building a tool to verify deep links set up with Apple's apple-app-site-association files. In some cases, these files are pkcs7-mime encrypted.</p>

<p>Is there any way currently to decrypt these files entirely on the client? I've researched WebCrypto and similar tools but I can't find a solution.</p>

<p>Essentially, I'd like to replicate the following openssl command in JS:</p>

<p><code>openssl smime -verify -inform DER -noverify -in apple-app-site-association.p7m</code></p>

<p>This should successfully output valid JSON, such as:</p>

<pre><code>{
""applinks"": {
    ""apps"": [],
    ""details"": [
        {
            ""appID"": ""4MU37S3E4Q.com.couchsurfing.CouchSurfing"",
            ""paths"": [
                        ""NOT /people/*/*"",
                        ""NOT /users/*/*"",
                        ""NOT /events/*/*"",
                        ""NOT /events/past"",
                        ""NOT /events/attending"",
                        ""NOT /events/organizing"",
                        ""NOT /events/featured"",
                        ""NOT /users/confirmation"",
                        ""/users/*"",
                        ""/people/*"",
                        ""/events/*"",
                        ""/get_verified"",
                        ""/messages/*"",
                        ""/hosting"",
                        ""/mobile-hangouts""
                     ]
        }
    ]
}
}
</code></pre>

<p>Any help is much appreciated!</p>
","<p>You can use <a href=""https://pkijs.org/"" rel=""nofollow noreferrer"">PKIjs</a>. This is a pure JavaScript library implementing the formats that are used in PKI applications (signing, encryption, certificate requests, OCSP and TSP requests/responses). It is built on WebCrypto (Web Cryptography API) and requires no plug-ins to work in modern browsers.</p>

<p>Here is an example of decoding CMS/PKCS#7 files:</p>

<ul>
<li><a href=""https://pkijs.org/examples/CMSSigned_complex_example.html"" rel=""nofollow noreferrer"">Demo</a></li>
<li><a href=""https://github.com/PeculiarVentures/PKI.js/tree/master/examples/CMSSignedComplexExample"" rel=""nofollow noreferrer"">Source</a></li>
</ul>
","268","<javascript><ios><openssl><deep-linking><pkcs#7>","0","2","1","2018-02-16 05:32:25","","0","","","","","2018-02-14 05:20:09",""
"47333142","PHP openssl_encrypt not always decryptable with C++","<p>I have a function which encrypts certain strings for transfer to my client application in C++. The function I use in PHP to generate the encrypted string:</p>

<pre><code>&lt;?php
    echo EncryptForTransfer(""This is a test""); //returns: l4/r5AUDTrPTlIfVyG0=DJKlty0VgWPSNsM2XbzkOZ79ivQA2eBWTd18FKVfgslM6UmP
    function EncryptForTransfer($EncryptMe) {
        $Key = random_string(32);
        $IV = random_string(16);
        return openssl_encrypt($EncryptMe, ""AES-256-CFB"", (string)$Key, false, $IV).$IV.$Key;
        }
    ?&gt;
</code></pre>

<p>However, when I try to decrypt this result in C++ with the functions shown underneath, it is not returning me the string correctly (missing last parts).</p>

<pre><code>int Decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key, unsigned char *iv, unsigned char *plaintext) {
    EVP_CIPHER_CTX *ctx;
    int len;
    int plaintext_len;
    if (!(ctx = EVP_CIPHER_CTX_new())) handleErrors();
    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cfb(), NULL, key, iv)) {
        handleErrors();
        }
    if (1 != EVP_DecryptUpdate(ctx, plaintext, &amp;len, ciphertext, ciphertext_len)) {
        handleErrors();
        }
    plaintext_len = len;
    if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &amp;len)) {
        handleErrors();
        }
    plaintext_len += len;
    EVP_CIPHER_CTX_free(ctx);
    return plaintext_len;
    }
string DecryptFromTransfer(string DecryptMe) {
    long long DecryptFromTransferLength = DecryptMe.length();
    string TransferKey = DecryptMe.substr(DecryptFromTransferLength - 32, 32);
    string TransferIV = DecryptMe.substr(DecryptFromTransferLength - 32 - 16, 16);
    string DecryptMeOriginal = DecryptMe.substr(0, DecryptFromTransferLength - 32 - 16);
    return DecryptThis(DecryptMeOriginal, TransferKey, TransferIV);
    }
cout &lt;&lt; DecryptFromTransfer(""l4/r5AUDTrPTlIfVyG0=DJKlty0VgWPSNsM2XbzkOZ79ivQA2eBWTd18FKVfgslM6UmP""); //returns: This is
</code></pre>

<p>Please note that for some strings the decryption in C++ works correctly. However, for other strings the output is as stated above, only partially decrypted and missing the last parts. Maybe it is some kind of padding issue since some strings are decrypted correctly? So, what is wrong with my code?</p>

<p><strong><em>The used string in the code above is just an example string to clarify the issue.</em></strong></p>
","","267","<php><c++><encryption><openssl><pkcs#7>","0","","0","2017-11-16 15:17:22","","17","","7114793","","2017-11-16 15:17:22","2017-11-16 15:13:13",""
"27567265","SignedData / DigestAlgorithm and SignedData / SignerInfo / DigestAlgorithm: same?","<p><a href=""https://tools.ietf.org/rfc/rfc6488.txt"" rel=""nofollow"">RFC 6488</a> specifies the following content of <code>Signed-Data</code> content type:</p>

<pre><code>  SignedData ::= SEQUENCE {
    version CMSVersion,
    digestAlgorithms DigestAlgorithmIdentifiers,
    encapContentInfo EncapsulatedContentInfo,
    certificates [0] IMPLICIT CertificateSet OPTIONAL,
    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
    signerInfos SignerInfos }
</code></pre>

<p>The text explains:</p>

<pre><code>The digestAlgorithms set contains the OIDs of the digest algorithm(s)
used in signing the encapsulated content.  This set MUST contain
exactly one digest algorithm OID [...]
</code></pre>

<p>Then, inside <code>SignerInfo</code>, there is another <code>DigestAlgorithmIdentifier</code>:</p>

<pre><code> SignerInfo ::= SEQUENCE {
    version CMSVersion,
    sid SignerIdentifier,
    digestAlgorithm DigestAlgorithmIdentifier,
    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
    signatureAlgorithm SignatureAlgorithmIdentifier,
    signature SignatureValue,
    unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
</code></pre>

<p>And the explanation is:</p>

<pre><code>The digestAlgorithm MUST consist of the OID of a digest algorithm
that conforms to the RPKI Algorithms and Key Size Profile
specification [RFC6485].
</code></pre>

<p>In a couple of PKCS#7 files I peeked in, these two elements had equal value.</p>

<p>Is this a duplication of the same attribute? If not, what is the meaning of either?</p>
","<blockquote>
  <p>Is this a duplication of the same attribute? If not, what is the meaning of either?</p>
</blockquote>

<p>In case of RPKI yes.</p>

<p>The reason is that this standard does not introduce a specialized new structure but merely a profile of an existing one:</p>

<blockquote>
  <blockquote>
    <p>The RPKI signed object is a profile of the CMS [RFC5652] signed-data object</p>
  </blockquote>
</blockquote>

<p>A CMS signed-data object in contrast to your RPKI one may contain multiple <strong>SignerInfo</strong> object in its <strong>signerInfos</strong> set, and each of them might make use of a different <strong>digestAlgorithm</strong>. Thus, in a CMS signed-data object the initial <strong>digestAlgorithms</strong> set may sensibly contain multiple entries.</p>

<p>Actually that field is even more liberally specified:</p>

<blockquote>
  <blockquote>
    <p>digestAlgorithms is a collection of message digest algorithm
          identifiers.  There MAY be any number of elements in the
          collection, including zero.  Each element identifies the message
          digest algorithm, along with any associated parameters, used by
          one or more signer.  The collection is intended to list the
          message digest algorithms employed by all of the signers, in any
          order, to facilitate one-pass signature verification.</p>
  </blockquote>
</blockquote>
","267","<digital-signature><pkcs#7>","0","1","1","2014-12-19 13:57:04","27567573","0","","","","","2014-12-19 13:36:42",""
"43325117","How do I use Bouncy Castle to read an App Store In App Purchase receipt? (PKCS7)","<p>I have a receipt in PKCS7 that I obtained from my iOS app.  Apple <a href=""https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateLocally.html#//apple_ref/doc/uid/TP40010573-CH1-SW6"" rel=""nofollow noreferrer"">says this is a PKCS7 structure</a>, and within that, is information regarding past recurring purchases. </p>

<p>I have the <a href=""https://pastebin.com/yk1Ujhjc"" rel=""nofollow noreferrer"">raw receipt here</a>, encoded in Base64.</p>

<p>I've sent this payload, with my secret key, to Apple <a href=""https://pastebin.com/YjkrBAYX"" rel=""nofollow noreferrer"">and got this response</a>.  Based on WWDC videos, and documentation, I believe I should be able to read this receipt directly, and without sending it to apple. </p>

<p>I'm guessing that PEMReader in BC is the correct starting point parse it, however I'm not sure how to actually use it.  I've scanned the BC source code for the strings ""PKCS"", and looked at unit tests, however all I ever see are casts from PEMReader into another format.</p>

<pre><code> using (var stream1 = new MemoryStream(receipt.Data))
 using (var stream2 = new StreamReader(stream1))
 {
       var pp = new PemReader(stream2);
       pp.ReadObject();
 }
</code></pre>

<p><strong>Question</strong></p>

<ul>
<li>How do I use Bouncy Castle to verify a raw receipt payload generated from Apple Store?</li>
</ul>

<p>Note to self: I intend to use this to inspect the actual binary to see if ApplicationUsername is included in the receipt, yet for some reason isn't returned in the JSON result when posting the server. (Bug on Apple's side?)</p>
","<p>I've made this using <strong>Java 7</strong> and <strong>BouncyCastle 1.56</strong>.</p>

<p>For the code below, consider that <code>pemString</code> is the PEM string you provided. But I had to make some modifications:</p>

<ul>
<li>format (break lines for every 64 characters) - I've made a small program to do that</li>
<li>include <strong>BEGIN</strong> and <strong>END</strong> headers</li>
</ul>

<p>So my PEM looks like:</p>

<pre><code>-----BEGIN PKCS7-----
MIIv5gYJKoZIhvcNAQcCoIIv1zCCL9MCAQExCzAJBgUrDgMCGgUAMIIfhwYJKoZI
hvcNAQcBoIIfeASCH3Qxgh9wMAoCAQgCAQEEAhYAMAoCARQCAQEEAgwAMAsCAQEC
AQEEAwIBADALAgELAgEBBAMCAQAwCwIBDwIBAQQDAgEAMAsCARACAQEEAwIBADAL
....
gdTu2uzkTyT+vcBlaLHK1ZpjKozsBds7ys6Q4EFp7OLxtJTj7saEDYXCNQtXBjwl
UfSGvQkXeIbsaqSPvOVIE83K3ki5i64gccA=
-----END PKCS7-----
</code></pre>

<p>For the code below, I followed the definition in Apple's doc:</p>

<pre><code>ReceiptAttribute ::= SEQUENCE {
    type    INTEGER,
    version INTEGER,
    value   OCTET STRING
}

Payload ::= SET OF ReceiptAttribute
</code></pre>

<p>Code:</p>

<pre><code>import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DLSequence;
import org.bouncycastle.asn1.DLSet;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;

String pemString = // PEM String as described above

PemReader reader = new PemReader(new StringReader(pemString));
PemObject pemObject = reader.readPemObject();
reader.close();

CMSSignedData s = new CMSSignedData(pemObject.getContent());
byte[] content = (byte[]) s.getSignedContent().getContent();

ASN1InputStream in = new ASN1InputStream(content);

// Payload: a SET of ReceiptAttribute
DLSet set = (DLSet) DLSet.fromByteArray(in.readObject().getEncoded());
int size = set.size();
for (int i = 0; i &lt; size; i++) {
    // ReceiptAttribute is a SEQUENCE
    DLSequence seq = (DLSequence) set.getObjectAt(i);

    // value is the third element of the sequence
    DEROctetString oct = (DEROctetString) seq.getObjectAt(2);
    ASN1Object obj = readObject(oct.getOctets()); // *** see comments below ***
}

in.close();

// readObject method
public ASN1Object readObject(byte[] b) throws IOException {
    ASN1InputStream in = null;
    try {
        in = new ASN1InputStream(b);
        return in.readObject();
    } catch (Exception e) {
        // if error occurs, just return the octet string
        return new DEROctetString(b);
    } finally {
        in.close();
    }
}
</code></pre>

<p>Variable <code>obj</code> will be the content of the <code>ReceiptAttribute</code>, and it can vary a lot - I've seen <code>DERIA5String</code>, <code>DERUTF8String</code>, <code>ASN1Integer</code> and many others. As I don't know all possible values of this field, I think it's up to you to check each value.</p>
","246","<ios><encryption><in-app-purchase><bouncycastle><pkcs#7>","0","3","1","2017-04-10 17:37:09","","3","2","328397","","2017-04-10 16:40:03","2017-04-10 13:53:01",""
"23552038","Is PKCS7 signing possible on Google App Engine?","<p>I need to create a PKCS7 signature for some data using my Python app running on Google App Engine (GAE).  More specifically, I am trying to create a PKCS7 signature of an Apple Passbook pass manifest; the Passbook pass requires the PKCS7 signature file to be present in order to be a complete and valid pass.</p>

<p>I have spent almost a week researching and trying to no avail.  </p>

<p>I can successfully create the signature using openssl command line on my local PC with:</p>

<pre><code>openssl smime -binary -sign -certfile WWDR.pem -signer certificate.pem -inkey key.pem -in manifest.json -out signature -outform DER 
</code></pre>

<p>I can also successfully create the signature using M2Crypto library on my local PC with:</p>

<pre><code>from M2Crypto import BIO, SMIME, X509

s = SMIME.SMIME()
s.load_key('identity.pem')         # my certificate and private key

x509 = X509.load_cert('WWDR.pem')  # Apple's intermediate certificate
sk = X509.X509_Stack()
sk.push(x509)
s.set_x509_stack(sk)

p7 = s.sign(bio_manifest, SMIME.PKCS7_DETACHED | SMIME.PKCS7_BINARY)
pkcs7_buffer = BIO.MemoryBuffer()
p7.write_der(pkcs7_buffer)

f = open('signature', 'w')
f.write(pkcs7_buffer.read())
f.close()
</code></pre>

<p>However, M2Crypto is a wrapper to OpenSSL which is not supported on GAE.</p>

<p>GAE supports the pycrypto library, but it doesn't seem this library has support for PKCS7 signing.</p>

<p>I've also looked at tlslite, which is a pure python implementation and therefore should be supported on GAE, but it also doesn't seem to have support for PKCS7 signing.</p>

<p>I'm looking for guidance from anyone that has been able to successfully create a PKCS7 signature on GAE.  If you could point me to a pure python library or any other solution, I'd really appreciate it.  </p>

<p>Otherwise, I feel like I've reached the boundary of what is possible with GAE and will be looking to move my app to another platform.  I'm a bit flabbergasted that it has been this difficult and that GAE doesn't support the openssl library given the importance of data security; it appears they aren't serious about providing a web app service that offers support for anything beyond the basics.  Unless (hopefully) I've missed the obvious.</p>

<p>Thanks for any help!</p>
","","238","<google-app-engine><passbook><pkcs#7>","4","","0","2014-05-08 20:38:02","","3","1","","","","2014-05-08 20:38:02",""
"53193110","Validate certificate chain in PKCS#7 format","<p>I've extracted PKCS#7 formatted in ASN1, and I'd like to verify it's certificate chain (meaning that each certificate was properly signed by the certificate above it from root to leaf).</p>

<p>In openssl, there's the following API : </p>

<pre><code>int PKCS7_verify(PKCS7 *p7, 
                 STACK_OF(X509) *certs, 
                 X509_STORE *store, 
                 BIO *indata, 
                 BIO *out, 
                 int flags);
</code></pre>

<p>However, I don't have a trusted certificate store. </p>

<p>I have a separate function that validate the integrity of the root certificate and that's enough for me. </p>

<p>Assuming that I already trust the root certificate, why do I need the store certificates structure in order to verify that the chain is properly signed ? </p>

<p>thanks  </p>
","<blockquote>
  <p>The question is why do I need the store in order to verify that the chain is properly signed ?</p>
</blockquote>

<p>You do not necessarily need a store parameter, you can set it to <code>NULL</code> as well and just verify the signature and not the entire chain of certificates. In that case, you should use the flag <code>PKCS7_NOVERIFY</code>, as explained in the <a href=""https://www.openssl.org/docs/man1.1.0/crypto/PKCS7_verify.html"" rel=""nofollow noreferrer"">manual for <code>PKCS7_verify()</code></a>. However, if you do want to verify the chain of certificates as well, you will somehow have to provide a mechanism to tell OpenSSL that you trust the root certificate and <code>X509_STORE</code> is a way to achieve that.</p>

<blockquote>
  <p>However, I don't have a trusted certficate store.</p>
</blockquote>

<p>From your question, it is not entirely clear what you situation is. But you do write that you have a separate function to ""validate the integrity of the root certificate"".</p>

<p>In that case, you can instantiate an <code>X509_STORE</code> object with <a href=""https://www.openssl.org/docs/man1.1.0/crypto/X509_STORE_new.html"" rel=""nofollow noreferrer""><code>X509_STORE_new()</code></a> and add your trusted certificate to it. There is an example in the OpenSSL source code tree of that in the <a href=""https://github.com/openssl/openssl/blob/OpenSSL_1_1_1/apps/apps.c#L1223"" rel=""nofollow noreferrer"">setup_verify()</a> function, which is for the case that the trusted certificate is available in a file. Or you could use <a href=""https://www.openssl.org/docs/manmaster/man3/X509_STORE_add_cert.html"" rel=""nofollow noreferrer"">X509_STORE_add_cert()</a> if that fits your purpose better. After you have added that trusted certificate, you can use the store as a parameter to your <code>PKCS7_verify()</code> invocation.</p>
","234","<openssl><x509><pkcs#7><asn1>","1","1","1","2018-11-10 01:39:08","53198995","1","","4333809","","2018-11-07 23:01:17","2018-11-07 15:57:15",""
"18899570","Input files required to programmatically generate a PKCS#12 certificate","<p>I need to create an application in C to generate a self signed PKCS#12 certificate. I have an application which so far creates a <strong>.csr</strong> and a <strong>.key</strong> file.</p>

<p>I also have a program which creates a PKCS#12 object from a supplied <strong>.key</strong> and <strong>.p7</strong> file. So given that I have a <strong>.csr</strong> and a <strong>.key</strong> file, I assume my next move would be to create a <strong>.p7</strong> file from the <strong>.key</strong> / <strong>.csr</strong> file?</p>

<p>I found a sample application <a href=""http://www.cs.odu.edu/~cs772/sourcecode/NSwO/EX10-8"" rel=""nofollow"">here</a> which signs or verifies certificates. At the end of the signing process, we have a PKCS7 object. I assume that is the object I need. </p>

<p>However, the sample application gives the following error when I run it with the key I have generated:</p>

<pre><code>$ ./sign_and_verify_util sign mykey.key.pem
Error reading signer private key in mykey.key.pem
</code></pre>

<p>I added the .pem onto the file because I thought that was the issue.</p>

<p>Any shove in the right direction would be a great help and I would really appreciate it!</p>

<p><strong>Edit</strong></p>

<p>I just converted mykey.key to mykey.key.pem correctly using:</p>

<pre><code>openssl rsa -inform DER -outform PEM -in mykey.key -out mykey.key.pem
</code></pre>

<p>Now the application I am trying to get the <strong>.p7</strong> file from says:</p>

<pre><code>Error reading signer certificate in (null)
</code></pre>
","","232","<c><openssl><pkcs#12><pkcs#7><csr>","1","","0","2013-09-19 16:12:34","","4","","985012","","2013-09-19 16:12:34","2013-09-19 15:58:08",""
"53761285","Bouncy Castle crafted PKCS7/CMS signature verification by OpenSSL","<p>We were using the following code snippet for signing and crafting the PKCS7 files.,</p>

<pre><code>public static String signAttached(X509Certificate obCert,PrivateKey obPvtKey,String signData, boolean attached){
    byte[] envelopedData = null;

    try{
        Security.addProvider(new BouncyCastleProvider());

        //Signed Attributes for TimeStamping
        final ASN1EncodableVector signedAttributes = new ASN1EncodableVector();
        final Attribute signingAttribute = new Attribute(CMSAttributes.signingTime, new DERSet(new DERUTCTime(new Date()))); 
        signedAttributes.add(signingAttribute);
        // Create the signing table
        final AttributeTable signedAttributesTable = new AttributeTable(signedAttributes);
        // Create the table table generator that will added to the Signer builder
        final DefaultSignedAttributeTableGenerator signedAttributeGenerator = new DefaultSignedAttributeTableGenerator(signedAttributesTable);


        //Build CMS
        X509Certificate cert = (X509Certificate) obCert;
        List certList = new ArrayList();
        CMSTypedData msg = new CMSProcessableByteArray(signData.getBytes(java.nio.charset.StandardCharsets.UTF_8));
        certList.add(cert);
        Store certs = new JcaCertStore(certList);
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""SunMSCAPI"").build(obPvtKey);
        gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()).build(sha1Signer, cert));
        gen.addCertificates(certs);

        //true means Attached; false means detached content 
        CMSSignedData sigData = gen.generate(msg, attached);     

        envelopedData = sigData.getEncoded();
    }catch(Exception e){
        e.printStackTrace();
    }
    return new String(Base64.encode(envelopedData));
}
</code></pre>

<p>The final Base64 encoded envelope persisted into the file. Later, When i tried to verify the signature by using the following command; </p>

<pre><code>$ openssl cms -verify -noverify -inform PEM -in new.p7s
Verification successful
madan prabhu nic tamilnadu state unit
</code></pre>

<p>For attached signature; it works fine. Same thing for the detached signature; it's not working.</p>

<pre><code>$openssl cms -verify -noverify -inform PEM -in newd.p7s -content newd.txt
madan prabhu nic tamilnadu state unit
Verification failure
140109147780928:error:2E09A09E:CMS routines:CMS_SignerInfo_verify_content:verification failure:crypto/cms/cms_sd.c:821:
140109147780928:error:2E09D06D:CMS routines:CMS_verify:content verify error:crypto/cms/cms_smime.c:393:
</code></pre>

<p>The content of the file newd.txt is exactly same data.</p>

<p>Kindly suggest me, how to resolve the Openssl verification successfully; since we are in development of cross platform supported solution. </p>

<p>Note: Verification of both signatures(attached and detached) works fine in BC java-code verification using JcaSimpleSignerInfoVerifierBuilder.</p>
","","225","<java><bouncycastle><pkcs#7>","0","","0","2018-12-13 13:05:45","","0","","3705788","","2018-12-13 13:05:45","2018-12-13 11:53:20",""
"43354660","How to decrypt PKCS#7 enveloped data with Azure Key Vault","<p>I have certificates with private keys installed in Azure Key Vault, and I need to decrypt mime-content of type '<code>application/pkcs7-mime; smime-type=enveloped-data</code>' (Cryptographic Message Syntax)</p>

<p>Can this be done with Azure Key Vault and C#/.NET?
Seems to me that Decrypt only works with raw data against the KeyVault client.
Is there some easy way to unwrap the mime content and decrypt bytes, manually?</p>
","","224","<c#><azure><encryption><pkcs#7><azure-keyvault>","0","","0","2017-04-11 19:29:41","","5","","","","","2017-04-11 19:29:41",""
"25768692","Calling SignedCMS.Decode takes too long","<p>Is there any reason that calling SignedCMS.Decode would take 15 seconds or more?  I have the following code:</p>

<pre><code>SignedCms signedCms = new SignedCms();
signedCms.Decode(postedData);
</code></pre>

<p>where postedData is a byte array of a signed CMS message.  Sometimes the function call returns instantly, but most of the time, it takes 10-15 seconds to return causing the message sender to timeout.  </p>

<p>This seems to happen whether or not the debugger is attached to the process.</p>
","<p>So I narrowed it down to an instantiation of Oid in one of the functions that the Decode function calls.  The source is available at <a href=""http://referencesource.microsoft.com/#System.Security"" rel=""nofollow"">Reference Source .NET Framework 4.5.1</a>.</p>

<p>I tested using:</p>

<pre><code>System.Security.Cryptography.Oid oid = new System.Security.Cryptography.Oid(""1.2.840.113549.1.7.1"");
</code></pre>

<p>I also found <a href=""http://social.msdn.microsoft.com/Forums/vstudio/en-US/0e6cd018-7574-4a58-97a0-a74f66a384e3/systemsecuritycryptographyoid-changed-behavior-in-net-40?forum=clr"" rel=""nofollow"">this link</a> with a similar problem. </p>

<p>Interestingly, disconnecting my wireless adapter, the Oid instantiation occurs immediately, which leads me to believe that it may be network/DNS related (I have not idea what the Oid instantiation is doing).  After reconnecting my adapter SignedCms.Decode is working as normal.  Another option I read is to remove  my computer from the domain and then rejoin.  Haven't tried it yet.</p>

<p>Maybe this will help anyone else that is have the same (or similar) problem.</p>
","222","<c#><.net><digital-signature><pkcs#7>","2","1","1","2014-09-10 21:34:11","","4","0","1256111","","2014-09-10 15:15:02","2014-09-10 14:55:33",""
"47975884","Not able to sign zip file using pkcs#7 and bouncyCastle in java","<p>I have a program to sign and verify text and zip files using pkcs#7 and bouncycastle. 
Am writing the following string into both text and zip files( which contains base64 encoded original data, SignedBytes and Certificate data) :</p>

<pre><code>String finalmsg=""&lt;?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\"" ?&gt;\n"" +
                     ""&lt;Envelope&gt;\n"" +""    &lt;OrgContent&gt;""+new String(Base64.encode(contentbytes))+""&lt;/OrgContent&gt;\n""+""    &lt;Signature&gt;""+new String(Base64.encode(signedBytes))+""&lt;/Signature&gt;\n""+""    &lt;Certificate&gt;""+
                    new String(Base64.encode(keyStore.getCertificate(""CertName"").getEncoded()))+""&lt;/Certificate&gt;\n""+""&lt;/Envelope&gt;"";
</code></pre>

<p>Am able to verify my text file perfectly after signing. Also am able to verify my zip file but am not able to extract the zip file ( am getting unexpected end of zip file error)</p>

<p>Below is the code am using to write my signed message into the files :</p>

<pre><code>if(file.getName().contains("".zip"")) {
byte[] b = finalmsg.getBytes(StandardCharsets.UTF_8);
try (BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(address+""SIGVERFILES/s2/""+name), 4096)) {
    out.write(b);
}
} else {
    FileWriter fw = new FileWriter(address+""SIGVERFILES/s2/""+name,true);
    BufferedWriter bw = new BufferedWriter(fw);
    bw.write(finalmsg);
    bw.close();
}
</code></pre>

<p>Also am able to verify and unzip successfully zip files signed by other parties. So my verification code is fine. I think somethings wrong with the way am writing the zip file.
Please dont mind the indentation and request you to help me try to find out what am doing wrong here? </p>

<p>Please let me know if anymore code snippets are required.</p>
","<p>You can't just write a XML string into a file, rename it to ""whatever.zip"", and expect the result to be a valid zip file. Zip is a binary file format with its own constraints, one of them being the magic number starting with ""PK"" at the beginning of the file.</p>

<p>Exchanging signed data also has its own constraints, and <a href=""http://www.pkiglobe.org/pkcs7.html"" rel=""nofollow noreferrer"">PKCS#7 SignedData</a> is also a normalized format.</p>

<p>To make your life easier, BouncyCastle provides helper classes to generate valid, properly wrapped signed data. Check out their documentation and examples <a href=""https://www.bouncycastle.org/docs/pkixdocs1.5on/org/bouncycastle/cms/CMSSignedData.html"" rel=""nofollow noreferrer"">here</a> and <a href=""https://www.bouncycastle.org/docs/pkixdocs1.4/org/bouncycastle/cms/CMSSignedDataGenerator.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>You will want to decide between generating an attached or detached signature : with an attached signature, the ASN.1 structure contains the signed message, so you can read validate the signature and read the payload from the same data block (example : RSA certificates). With a detached signature, it'll be up to you to transmit the data and its signature separately (but the recipiend will need both in order to verify the signature - example : signed files available for download on a public FTP server). Usually the question is answered simply by asking yourself if the recipient may want to use the payload without verifying its signature first, or not.</p>
","222","<java><zip><bouncycastle><zipfile><pkcs#7>","0","0","1","2017-12-26 09:24:24","","0","","","","","2017-12-26 08:30:39",""
"39367374","Difference between two PKCS7 signatures while Signing a PDF","<p>I am working on signing PDFs with digital mobile signatures (PKCS#7). Since I am not an expert on Openssl and Signatures types, I am facing some problems. Maybe I didn‚Äôt get the logic.</p>

<p>Im using Setasign PDF library to preparing PDF document, calculating byterange and SHA256. Since its paid and well known library, Im supposing there is no problem on these steps.</p>

<p>Then I am sending calculated hash to my mobile carrier‚Äôs service, the mobile user approving this signing process on his phone and The carrier‚Äôs web service returning PKCS#7 formatted signature. </p>

<p>On last step PDF Library placing this signature into prepared PDF. 
Everythings looks fine till here. But when I open signed PDf its says ‚ÄúDocument has been altered or corrupted since it was signed‚Äù</p>

<p>So I start to lookup reason of this problem and I noticed something that I don‚Äôt understand. </p>

<p>I know other companies also using same mobile carrier‚Äôs service to signing documents, and those PDFs totally fine (I think they are using iTextsharp library). Anyway I got the signature from one of those documents and save this sign as binary data into a file then run this command on this file </p>

<pre><code>openssl asn1parse -inform der -in signature.p7b
</code></pre>

<p>This command gave me this result:</p>

<pre><code>   0:d=0  hl=2 l=inf  cons: SEQUENCE
    2:d=1  hl=2 l=   9 prim: OBJECT            :pkcs7-signedData
   13:d=1  hl=2 l=inf  cons: cont [ 0 ]
   15:d=2  hl=2 l=inf  cons: SEQUENCE
   17:d=3  hl=2 l=   1 prim: INTEGER           :01
   20:d=3  hl=2 l=  13 cons: SET
   22:d=4  hl=2 l=  11 cons: SEQUENCE
   24:d=5  hl=2 l=   9 prim: OBJECT            :sha256
   35:d=3  hl=2 l=inf  cons: SEQUENCE
   37:d=4  hl=2 l=   9 prim: OBJECT            :pkcs7-data
   48:d=4  hl=2 l=   0 prim: EOC
   50:d=3  hl=4 l=1788 cons: cont [ 0 ]
   54:d=4  hl=4 l=1784 cons: SEQUENCE
   58:d=5  hl=4 l=1504 cons: SEQUENCE
   62:d=6  hl=2 l=   3 cons: cont [ 0 ]
   64:d=7  hl=2 l=   1 prim: INTEGER           :02
   67:d=6  hl=2 l=  17 prim: INTEGER           :B99634F7172927B1B51262580A11B4FE
   86:d=6  hl=2 l=  13 cons: SEQUENCE
   88:d=7  hl=2 l=   9 prim: OBJECT            :sha256WithRSAEncryption
   99:d=7  hl=2 l=   0 prim: NULL
  101:d=6  hl=2 l= 106 cons: SEQUENCE
  103:d=7  hl=2 l=  11 cons: SET
  105:d=8  hl=2 l=   9 cons: SEQUENCE
  107:d=9  hl=2 l=   3 prim: OBJECT            :countryName
  112:d=9  hl=2 l=   2 prim: PRINTABLESTRING   :TR
  116:d=7  hl=2 l=  40 cons: SET
  118:d=8  hl=2 l=  38 cons: SEQUENCE
  120:d=9  hl=2 l=   3 prim: OBJECT            :organizationName
  125:d=9  hl=2 l=  31 prim: UTF8STRING        :Elektronik A.S.
  158:d=7  hl=2 l=  49 cons: SET
  160:d=8  hl=2 l=  47 cons: SEQUENCE
  162:d=9  hl=2 l=   3 prim: OBJECT            :commonName
  167:d=9  hl=2 l=  40 prim: UTF8STRING        :Mobil S2
  209:d=6  hl=2 l=  30 cons: SEQUENCE
  211:d=7  hl=2 l=  13 prim: UTCTIME           :151125084946Z
  226:d=7  hl=2 l=  13 prim: UTCTIME           :161124084946Z
  241:d=6  hl=2 l=  87 cons: SEQUENCE
  243:d=7  hl=2 l=  11 cons: SET
  245:d=8  hl=2 l=   9 cons: SEQUENCE
  247:d=9  hl=2 l=   3 prim: OBJECT            :countryName
  252:d=9  hl=2 l=   2 prim: PRINTABLESTRING   :TR
  256:d=7  hl=2 l=  27 cons: SET
  258:d=8  hl=2 l=  25 cons: SEQUENCE
  260:d=9  hl=2 l=   3 prim: OBJECT            :organizationalUnitName
  265:d=9  hl=2 l=  18 prim: PRINTABLESTRING   :popCode - 33854
  285:d=7  hl=2 l=  20 cons: SET
  287:d=8  hl=2 l=  18 cons: SEQUENCE
  289:d=9  hl=2 l=   3 prim: OBJECT            :serialNumber
  294:d=9  hl=2 l=  11 prim: PRINTABLESTRING   :2594884
  307:d=7  hl=2 l=  21 cons: SET
  309:d=8  hl=2 l=  19 cons: SEQUENCE
  311:d=9  hl=2 l=   3 prim: OBJECT            :commonName
  316:d=9  hl=2 l=  12 prim: UTF8STRING        :JORJ MARDUK
  330:d=6  hl=4 l= 290 cons: SEQUENCE
  334:d=7  hl=2 l=  13 cons: SEQUENCE
  336:d=8  hl=2 l=   9 prim: OBJECT            :rsaEncryption
  347:d=8  hl=2 l=   0 prim: NULL
  349:d=7  hl=4 l= 271 prim: BIT STRING
  624:d=6  hl=4 l= 938 cons: cont [ 3 ]
  628:d=7  hl=4 l= 934 cons: SEQUENCE
  632:d=8  hl=3 l= 138 cons: SEQUENCE
  635:d=9  hl=2 l=   8 prim: OBJECT            :Authority Information Access
  645:d=9  hl=2 l= 126 prim: OCTET STRING      [HEX DUMP]:307C302E06082B060105050730018622687474703A2F2F6F637370322E652D677576656E2E636F6D2F6F6373702E78756461304A06082B06010505073002863E687474703A2F2F7777772E652D677576656E2E636F6D2F646F63756D656E74732F5475726B63656C6C4D6F62696C496D7A61416C744B6F6B53322E637274
  773:d=8  hl=2 l=  31 cons: SEQUENCE
  775:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Authority Key Identifier
  780:d=9  hl=2 l=  24 prim: OCTET STRING      [HEX DUMP]:3016801408B053A6CF4F46DB1D608B086DE5CD47E0606C0E
  806:d=8  hl=4 l= 370 cons: SEQUENCE
  810:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Certificate Policies
  815:d=9  hl=4 l= 361 prim: OCTET STRING      [HEX DUMP]:308201653081B106066086180300013081A6303606082B06010505070201162A687474703A2F2F7777772E652D677576656E2E636F6D2F646F63756D656E74732F4E455355452E706466306C06082B0601050507020230601A5E427520736572746966696B612C203530373020736179C4B16CC4B120456C656B74726F6E696B20C4B06D7A61204B616E756E756E612067C3B67265206E6974656C696B6C6920656C656B74726F6E696B20736572746966696B6164C4B1723081AE06096086180300010101033081A0303706082B06010505070201162B687474703A2F2F7777772E652D677576656E2E636F6D2F646F63756D656E74732F4D4B4E4553492E706466306506082B0601050507020230591A57427520736572746966696B612C204D4B4E455349206B617073616DC4B16E646120796179C4B16E6C616E6DC4B1C59F20626972206E6974656C696B6C6920656C656B74726F6E696B20736572746966696B6164C4B1722E
 1180:d=8  hl=2 l=  88 cons: SEQUENCE
 1182:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 CRL Distribution Points
 1187:d=9  hl=2 l=  81 prim: OCTET STRING      [HEX DUMP]:304F304DA04BA0498647687474703A2F2F73696C2E652D677576656E2E636F6D2F456C656B74726F6E696B42696C6769477576656E6C69676941534D4B4E45534953322F4C617465737443524C2E63726C
 1270:d=8  hl=2 l=  14 cons: SEQUENCE
 1272:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Key Usage
 1277:d=9  hl=2 l=   1 prim: BOOLEAN           :255
 1280:d=9  hl=2 l=   4 prim: OCTET STRING      [HEX DUMP]:030206C0
 1286:d=8  hl=3 l= 131 cons: SEQUENCE
 1289:d=9  hl=2 l=   8 prim: OBJECT            :qcStatements
 1299:d=9  hl=2 l= 119 prim: OCTET STRING      [HEX DUMP]:30753008060604008E4601013069060B608618013D0001A74E01010C5A427520736572746966696B612C203530373020736179696C6920456C656B74726F6E696B20496D7A61204B616E756E756E612067C3B67265206E6974656C696B6C6920656C656B74726F6E696B20736572746966696B61646972
 1420:d=8  hl=2 l=  79 cons: SEQUENCE
 1422:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Directory Attributes
 1427:d=9  hl=2 l=  72 prim: OCTET STRING      [HEX DUMP]:3046301D06082B060105050709013111180F30303138313233313232303030305A301006082B06010505070904310404025452301306082B060105050709023107040542C4B04741
 1501:d=8  hl=2 l=  32 cons: SEQUENCE
 1503:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Alternative Name
 1508:d=9  hl=2 l=  25 prim: OCTET STRING      [HEX DUMP]:301781156E6968616E2E6963696B40746B642E636F6D2E7472
 1535:d=8  hl=2 l=  29 cons: SEQUENCE
 1537:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Key Identifier
 1542:d=9  hl=2 l=  22 prim: OCTET STRING      [HEX DUMP]:04149E69B3ABDAC2AC1C74156FCEEE68FF75A704B432
 1566:d=5  hl=2 l=  13 cons: SEQUENCE
 1568:d=6  hl=2 l=   9 prim: OBJECT            :sha256WithRSAEncryption
 1579:d=6  hl=2 l=   0 prim: NULL
 1581:d=5  hl=4 l= 257 prim: BIT STRING
 1842:d=3  hl=4 l= 729 cons: SET
 1846:d=4  hl=4 l= 725 cons: SEQUENCE
 1850:d=5  hl=2 l=   1 prim: INTEGER           :01
 1853:d=5  hl=2 l= 127 cons: SEQUENCE
 1855:d=6  hl=2 l= 106 cons: SEQUENCE
 1857:d=7  hl=2 l=  11 cons: SET
 1859:d=8  hl=2 l=   9 cons: SEQUENCE
 1861:d=9  hl=2 l=   3 prim: OBJECT            :countryName
 1866:d=9  hl=2 l=   2 prim: PRINTABLESTRING   :TR
 1870:d=7  hl=2 l=  40 cons: SET
 1872:d=8  hl=2 l=  38 cons: SEQUENCE
 1874:d=9  hl=2 l=   3 prim: OBJECT            :organizationName
 1879:d=9  hl=2 l=  31 prim: UTF8STRING        :Elektronik A.S.
 1912:d=7  hl=2 l=  49 cons: SET
 1914:d=8  hl=2 l=  47 cons: SEQUENCE
 1916:d=9  hl=2 l=   3 prim: OBJECT            :commonName
 1921:d=9  hl=2 l=  40 prim: UTF8STRING        :Mobil S2
 1963:d=6  hl=2 l=  17 prim: INTEGER           :B99634F7172927B1B51262580A11B4FE
 1982:d=5  hl=2 l=  11 cons: SEQUENCE
 1984:d=6  hl=2 l=   9 prim: OBJECT            :sha256
 1995:d=5  hl=4 l= 301 cons: cont [ 0 ]
 1999:d=6  hl=2 l=  24 cons: SEQUENCE
 2001:d=7  hl=2 l=   9 prim: OBJECT            :contentType
 2012:d=7  hl=2 l=  11 cons: SET
 2014:d=8  hl=2 l=   9 prim: OBJECT            :pkcs7-data
 2025:d=6  hl=2 l=  28 cons: SEQUENCE
 2027:d=7  hl=2 l=   9 prim: OBJECT            :signingTime
 2038:d=7  hl=2 l=  15 cons: SET
 2040:d=8  hl=2 l=  13 prim: UTCTIME           :160815091237Z
 2055:d=6  hl=2 l=  47 cons: SEQUENCE
 2057:d=7  hl=2 l=   9 prim: OBJECT            :messageDigest
 2068:d=7  hl=2 l=  34 cons: SET
 2070:d=8  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:16D96A5B9033B7A73A3510CC429DDA315C6308AE7233A7F054118E764FF85885
 2104:d=6  hl=3 l= 193 cons: SEQUENCE
 2107:d=7  hl=2 l=  11 prim: OBJECT            :1.2.840.113549.1.9.16.2.47
 2120:d=7  hl=3 l= 177 cons: SET
 2123:d=8  hl=3 l= 174 cons: SEQUENCE
 2126:d=9  hl=3 l= 171 cons: SEQUENCE
 2129:d=10 hl=3 l= 168 cons: SEQUENCE
 2132:d=11 hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:7D3D2FEB1DD1F60316A7601C2AAE81F9EA9992948810AF5FC089825287BB1517
 2166:d=11 hl=3 l= 131 cons: SEQUENCE
 2169:d=12 hl=2 l= 110 cons: SEQUENCE
 2171:d=13 hl=2 l= 108 cons: cont [ 4 ]
 2173:d=14 hl=2 l= 106 cons: SEQUENCE
 2175:d=15 hl=2 l=  11 cons: SET
 2177:d=16 hl=2 l=   9 cons: SEQUENCE
 2179:d=17 hl=2 l=   3 prim: OBJECT            :countryName
 2184:d=17 hl=2 l=   2 prim: PRINTABLESTRING   :TR
 2188:d=15 hl=2 l=  40 cons: SET
 2190:d=16 hl=2 l=  38 cons: SEQUENCE
 2192:d=17 hl=2 l=   3 prim: OBJECT            :organizationName
 2197:d=17 hl=2 l=  31 prim: UTF8STRING        :Elektronik A.S.
 2230:d=15 hl=2 l=  49 cons: SET
 2232:d=16 hl=2 l=  47 cons: SEQUENCE
 2234:d=17 hl=2 l=   3 prim: OBJECT            :commonName
 2239:d=17 hl=2 l=  40 prim: UTF8STRING        :Mobil S2
 2281:d=12 hl=2 l=  17 prim: INTEGER           :B99634F7172927B1B51262580A11B4FE
 2300:d=5  hl=2 l=  13 cons: SEQUENCE
 2302:d=6  hl=2 l=   9 prim: OBJECT            :sha256WithRSAEncryption
 2313:d=6  hl=2 l=   0 prim: NULL
 2315:d=5  hl=4 l= 256 prim: OCTET STRING      [HEX DUMP]:388E968648889ECC29FC394A958365E0C0B14CC8861CF73198B0330002EE7B97DA06E7548EBB52286F5ADE5E40394444786E695FC6BB288CDCF71CFBBCA002C6C84E84608DAC057C8FE05C0465074D6BA4EAC941A069AB62ED1747656BBD8FCE412D20462B7068E07692169558853AAB10594D91A616AB28708C2ECF08C6EE48989D10B48B300E35223259BE6B4B3612BDC6BD40C3707B138E2DD645D7922693AC18566FFBEBE5E970B77321C11C19B029BB8F12471D7B613BF49E530641E0B1F3C02D92D1288AAB0D4AF691F302083D5FE0749CC4858F6A4AB33B0DABC8AAD97AF79C12DD6EE03FC5AF4083F9C453C4994D018468738FD60DF50074394D11E2
 2575:d=3  hl=2 l=   0 prim: ENUMERATED        :00
</code></pre>

<p>Then i saved the signature from same Mobile Carrier's returns me:</p>

<pre><code>    0:d=0  hl=4 l=2413 cons: SEQUENCE
    4:d=1  hl=2 l=   9 prim: OBJECT            :pkcs7-signedData
   15:d=1  hl=4 l=2398 cons: cont [ 0 ]
   19:d=2  hl=4 l=2394 cons: SEQUENCE
   23:d=3  hl=2 l=   1 prim: INTEGER           :01
   26:d=3  hl=2 l=  11 cons: SET
   28:d=4  hl=2 l=   9 cons: SEQUENCE
   30:d=5  hl=2 l=   5 prim: OBJECT            :sha1
   37:d=5  hl=2 l=   0 prim: NULL
   39:d=3  hl=2 l=  59 cons: SEQUENCE
   41:d=4  hl=2 l=   9 prim: OBJECT            :pkcs7-data
   52:d=4  hl=2 l=  46 cons: cont [ 0 ]
   54:d=5  hl=2 l=  44 prim: OCTET STRING      :hPUsrH5h12umBN5a6SktIkfKwI0dOBNids5LY84CWxU=
  100:d=3  hl=4 l=1793 cons: cont [ 0 ]
  104:d=4  hl=4 l=1789 cons: SEQUENCE
  108:d=5  hl=4 l=1509 cons: SEQUENCE
  112:d=6  hl=2 l=   3 cons: cont [ 0 ]
  114:d=7  hl=2 l=   1 prim: INTEGER           :02
  117:d=6  hl=2 l=  16 prim: INTEGER           :64022A0CF088F79AF0024C139729BA23
  135:d=6  hl=2 l=  13 cons: SEQUENCE
  137:d=7  hl=2 l=   9 prim: OBJECT            :sha256WithRSAEncryption
  148:d=7  hl=2 l=   0 prim: NULL
  150:d=6  hl=2 l= 106 cons: SEQUENCE
  152:d=7  hl=2 l=  11 cons: SET
  154:d=8  hl=2 l=   9 cons: SEQUENCE
  156:d=9  hl=2 l=   3 prim: OBJECT            :countryName
  161:d=9  hl=2 l=   2 prim: PRINTABLESTRING   :TR
  165:d=7  hl=2 l=  40 cons: SET
  167:d=8  hl=2 l=  38 cons: SEQUENCE
  169:d=9  hl=2 l=   3 prim: OBJECT            :organizationName
  174:d=9  hl=2 l=  31 prim: UTF8STRING        :Elektronik A.S.
  207:d=7  hl=2 l=  49 cons: SET
  209:d=8  hl=2 l=  47 cons: SEQUENCE
  211:d=9  hl=2 l=   3 prim: OBJECT            :commonName
  216:d=9  hl=2 l=  40 prim: UTF8STRING        :Mobil S2
  258:d=6  hl=2 l=  30 cons: SEQUENCE
  260:d=7  hl=2 l=  13 prim: UTCTIME           :151012133852Z
  275:d=7  hl=2 l=  13 prim: UTCTIME           :161011133852Z
  290:d=6  hl=2 l=  86 cons: SEQUENCE
  292:d=7  hl=2 l=  11 cons: SET
  294:d=8  hl=2 l=   9 cons: SEQUENCE
  296:d=9  hl=2 l=   3 prim: OBJECT            :countryName
  301:d=9  hl=2 l=   2 prim: PRINTABLESTRING   :TR
  305:d=7  hl=2 l=  27 cons: SET
  307:d=8  hl=2 l=  25 cons: SEQUENCE
  309:d=9  hl=2 l=   3 prim: OBJECT            :organizationalUnitName
  314:d=9  hl=2 l=  18 prim: PRINTABLESTRING   :popCode - 16557
  334:d=7  hl=2 l=  20 cons: SET
  336:d=8  hl=2 l=  18 cons: SEQUENCE
  338:d=9  hl=2 l=   3 prim: OBJECT            :serialNumber
  343:d=9  hl=2 l=  11 prim: PRINTABLESTRING   :52059220
  356:d=7  hl=2 l=  20 cons: SET
  358:d=8  hl=2 l=  18 cons: SEQUENCE
  360:d=9  hl=2 l=   3 prim: OBJECT            :commonName
  365:d=9  hl=2 l=  11 prim: UTF8STRING        :NATE MARDUK
  378:d=6  hl=4 l= 290 cons: SEQUENCE
  382:d=7  hl=2 l=  13 cons: SEQUENCE
  384:d=8  hl=2 l=   9 prim: OBJECT            :rsaEncryption
  395:d=8  hl=2 l=   0 prim: NULL
  397:d=7  hl=4 l= 271 prim: BIT STRING
  672:d=6  hl=4 l= 945 cons: cont [ 3 ]
  676:d=7  hl=4 l= 941 cons: SEQUENCE
  680:d=8  hl=3 l= 138 cons: SEQUENCE
  683:d=9  hl=2 l=   8 prim: OBJECT            :Authority Information Access
  693:d=9  hl=2 l= 126 prim: OCTET STRING      [HEX DUMP]:307C302E06082B060105050730018622687474703A2F2F6F637370322E6687474703A2F2F7777772E652D677576656E2E636F6D2F646F63756D656E74732F5475726B63656C6C4D6F62696C496D7A61416C744B6F6B53322
  821:d=8  hl=2 l=  31 cons: SEQUENCE
  823:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Authority Key Identifier
  828:d=9  hl=2 l=  24 prim: OCTET STRING      [HEX DUMP]:3016801408B053A6CF4F46DB1D608B086DE5CD47E0606C0E
  854:d=8  hl=4 l= 370 cons: SEQUENCE
  858:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Certificate Policies
  863:d=9  hl=4 l= 361 prim: OCTET STRING      [HEX DUMP]:308201653081B106066086180300013081A6303606082B06010505070202F4E455355452E706466306C06082B0601050507020230601A5E427520736572746966696B612C203530373020736179C4B16CC4B120456C656B76C6920656C656B74726F6E696B20736572746966696B6164C4B1723081AE06096086180300010101033081A0303706082B06010505070201162B64E4553492E706466306506082B0601050507020230591A57427520736572746966696B612C204D4B4E455349206B617073616DC4B16E6461207966E696B20736572746966696B6164C4B1722E
 1228:d=8  hl=2 l=  88 cons: SEQUENCE
 1230:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 CRL Distribution Points
 1235:d=9  hl=2 l=  81 prim: OCTET STRING      [HEX DUMP]:304F304DA04BA0498647687474703A2F2F73696C2E652D677576656E2E64953322F4C617465737443524C2E63726C
 1318:d=8  hl=2 l=  14 cons: SEQUENCE
 1320:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Key Usage
 1325:d=9  hl=2 l=   1 prim: BOOLEAN           :255
 1328:d=9  hl=2 l=   4 prim: OCTET STRING      [HEX DUMP]:030206C0
 1334:d=8  hl=3 l= 131 cons: SEQUENCE
 1337:d=9  hl=2 l=   8 prim: OBJECT            :qcStatements
 1347:d=9  hl=2 l= 119 prim: OCTET STRING      [HEX DUMP]:30753008060604008E4601013069060B608618013D0001A74E01010C5A46B20496D7A61204B616E756E756E612067C3B67265206E6974656C696B6C6920656C656B74726F6E696B20736572746966696B61646972
 1468:d=8  hl=2 l=  79 cons: SEQUENCE
 1470:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Directory Attributes
 1475:d=9  hl=2 l=  72 prim: OCTET STRING      [HEX DUMP]:3046301D06082B060105050709013111180F30303034313233313232303070405544F4B4154
 1549:d=8  hl=2 l=  39 cons: SEQUENCE
 1551:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Alternative Name
 1556:d=9  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:301E811C6D6572742E697A6369406B6579696E7465726E65742E636F6D2
 1590:d=8  hl=2 l=  29 cons: SEQUENCE
 1592:d=9  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Key Identifier
 1597:d=9  hl=2 l=  22 prim: OCTET STRING      [HEX DUMP]:0414E2096E3737DC612801B12C31E89903685EB6E423
 1621:d=5  hl=2 l=  13 cons: SEQUENCE
 1623:d=6  hl=2 l=   9 prim: OBJECT            :sha256WithRSAEncryption
 1634:d=6  hl=2 l=   0 prim: NULL
 1636:d=5  hl=4 l= 257 prim: BIT STRING
 1897:d=3  hl=4 l= 516 cons: SET
 1901:d=4  hl=4 l= 512 cons: SEQUENCE
 1905:d=5  hl=2 l=   1 prim: INTEGER           :01
 1908:d=5  hl=2 l= 126 cons: SEQUENCE
 1910:d=6  hl=2 l= 106 cons: SEQUENCE
 1912:d=7  hl=2 l=  11 cons: SET
 1914:d=8  hl=2 l=   9 cons: SEQUENCE
 1916:d=9  hl=2 l=   3 prim: OBJECT            :countryName
 1921:d=9  hl=2 l=   2 prim: PRINTABLESTRING   :TR
 1925:d=7  hl=2 l=  40 cons: SET
 1927:d=8  hl=2 l=  38 cons: SEQUENCE
 1929:d=9  hl=2 l=   3 prim: OBJECT            :organizationName
 1934:d=9  hl=2 l=  31 prim: UTF8STRING        :Elektronik A.S.
 1967:d=7  hl=2 l=  49 cons: SET
 1969:d=8  hl=2 l=  47 cons: SEQUENCE
 1971:d=9  hl=2 l=   3 prim: OBJECT            :commonName
 1976:d=9  hl=2 l=  40 prim: UTF8STRING        :Mobil S2
 2018:d=6  hl=2 l=  16 prim: INTEGER           :64022A0CF088F79AF0024C139729BA23
 2036:d=5  hl=2 l=   9 cons: SEQUENCE
 2038:d=6  hl=2 l=   5 prim: OBJECT            :sha1
 2045:d=6  hl=2 l=   0 prim: NULL
 2047:d=5  hl=2 l=  93 cons: cont [ 0 ]
 2049:d=6  hl=2 l=  24 cons: SEQUENCE
 2051:d=7  hl=2 l=   9 prim: OBJECT            :contentType
 2062:d=7  hl=2 l=  11 cons: SET
 2064:d=8  hl=2 l=   9 prim: OBJECT            :pkcs7-data
 2075:d=6  hl=2 l=  28 cons: SEQUENCE
 2077:d=7  hl=2 l=   9 prim: OBJECT            :signingTime
 2088:d=7  hl=2 l=  15 cons: SET
 2090:d=8  hl=2 l=  13 prim: UTCTIME           :160906195531Z
 2105:d=6  hl=2 l=  35 cons: SEQUENCE
 2107:d=7  hl=2 l=   9 prim: OBJECT            :messageDigest
 2118:d=7  hl=2 l=  22 cons: SET
 2120:d=8  hl=2 l=  20 prim: OCTET STRING      [HEX DUMP]:049FB27A9ED352096E59BF189BF35ADD1C88D4CF
 2142:d=5  hl=2 l=  13 cons: SEQUENCE
 2144:d=6  hl=2 l=   9 prim: OBJECT            :rsaEncryption
 2155:d=6  hl=2 l=   0 prim: NULL
 2157:d=5  hl=4 l= 256 prim: OCTET STRING      [HEX DUMP]:1EEBD18D0AE9BCD393FECB45AD18C30832ACDF83CDF703B6CF093C275BF0FB0D9B6697C9C3D4652ED1C48BC2816DF6A02620AAC9518A79367443F664A34C6EFD023649FFC18785342D7BCA311449BE2155B309008A1A68B296CD50EFE315A34A5C2E7303EA169201B150B94F8C20851F40B978121CDFF50D6D3C699483F3A7AAEA37D02DE20CEFEE88AC5947BD2B573C338A9145BB942FBF7
</code></pre>

<p>As you see they look very different. At this point, Am i missing some thing ? I mean, Shall I do something on second one to convert it looks like first signature ?
Like i said before, I am using same service with those guys but they had different signature type on their signed pdf's(And its also working).</p>
","","220","<digital-signature><signature><sign><digital-certificate><pkcs#7>","0","","0","2016-09-07 10:26:49","","2","","","","","2016-09-07 10:26:49",""
"49177595","OpenSSL: PKCS7, verification failure, checksum of payload in PEM?","<p>I have a verification-error in a SMIME-message and I try to check manually.</p>

<p>Is there an obvious relation between the ASN1 of the PEM and the digest of the payload?</p>

<p><strong>I try the following:</strong></p>

<ol>
<li><p>Make the PEM of a message (signature of the SMIME)</p>

<pre><code>openssl cms -sign -in x.txt -md sha1 -signer cer.cer -inkey key.key -outform PEM &gt; mypem
</code></pre></li>
<li><p>Make a SHA-checksum of the payload:</p>

<pre><code>sha1sum x.txt
</code></pre></li>
<li><p>Parse the PEM:</p>

<pre><code>openssl asn1parse -in mypem
</code></pre></li>
</ol>

<p>So will I find the SHA-checksum of sha1sum in the output of asn1parse??</p>
","<p>If you add <code>-inform pem</code> to the last openssl command you'll see more:</p>

<pre><code> openssl asn1parse -inform pem -in mypem
</code></pre>

<p>Look at the end of the output for the <code>OCTET STRING</code>. In my case I have 2K RSA key and that object is 512 bytes.</p>

<p>This hexdump is the crypto part of the PKCS#7 signature.</p>

<p>Convert this string to binary (I like <code>xxd</code> for this) and use openssl once more to get it decode (assuming you also have RSA key):</p>

<pre><code>$ echo ""07CD61E81878C803ACA4B41713845320D46577ED9B4F70FA04F18C31B27F08622B4D919C30147B99EF2135A402C5DC11639F0412648DA84183284A2E9F51EC05C3F354ECDC7A7F9BB540785ACC192BFAE2643C796FBD3CD8CD9ADB8591ABF042F9FC6F520250D50B0DC52E2207A1D7116878AC75EFE87031CC728822D01A0FCB75E528239CA9FD94EC4C6161696A33A35D5CA7E182FF486E8DF7CBA7944840F130612415ED3FCD42C4F92E2BF193CCC265A4B5D153362A51A3CA00F8EF0D7E4D3F7516299C74271E4AF6307AFA5FF2897297F7076E3D7A21A0BCA4B22A699D9D6F5C3AD044DC91145B34B3564EE9825DC9E9DE19A453296A8C1E520D292A7861"" | 
xxd -r -ps -c512 | openssl rsautl -encrypt -inkey key.key -raw -hexdump
Enter pass phrase for key.key:
0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 21 30   .............0!0
00e0 - 09 06 05 2b 0e 03 02 1a-05 00 04 14 d2 b9 cb a5   ...+............
00f0 - 53 a5 e2 da d9 da 75 c5-bc ad a5 1b f6 2a eb 13   S.....u......*..
</code></pre>

<p>You'll recognized the PCKS#1 v1.5 padding. </p>

<p>Extract the bytes at the end, decode them with the openssl asn1 parser and you'll finally get the hash you wanted:</p>

<pre><code>$ echo 3021300906052b0e03021a05000414d2b9cba553a5e2dad9da75a5bcada51bf62aeb13 | xxd -r -ps | openssl asn1parse -inform der
  0:d=0  hl=2 l=  33 cons: SEQUENCE
  2:d=1  hl=2 l=   9 cons: SEQUENCE
  4:d=2  hl=2 l=   5 prim: OBJECT            :sha1
 11:d=2  hl=2 l=   0 prim: NULL
 13:d=1  hl=2 l=  20 prim: OCTET STRING      [HEX DUMP]:D2B9CBA553A5E2DAD9DA75A5BCADA51BF62AEB13
</code></pre>
","208","<openssl><pkcs#7><smime>","0","1","1","2018-03-12 08:31:19","","0","","","","","2018-03-08 16:10:42",""
"56818371","What is the correct behavior of C_Decrypt in pkcs#11?","<p>I am using <code>C_Decrypt</code> with the <code>CKM_AES_CBC_PAD</code> mechanism. I know that my ciphertext which is 272 bytes long should actually decrypt to 256 bytes, which means a full block of padding was added.</p>

<p>I know that <a href=""http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html#_Toc416959738"" rel=""nofollow noreferrer"">according to the standard</a> when invoking <code>C_Decrypt</code> with a NULL output buffer the function may return an output length which is somewhat longer than the actual required length, in particular when padding is used this is understandable, as the function can't know how many padding bytes are in the final block without carrying out the actual decryption.</p>

<p>So the question is whether if I know that I should get exactly 256 bytes back, such as in the scenario I explained above, does it make sense that I am still getting a <code>CKR_BUFFER_TOO_SMALL</code> error as a result, despite passing a 256 bytes buffer? (To make it clear: I am indicating that this is the length of the output buffer in the appropriate output buffer length parameter, see the parameters of <a href=""http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html#_Toc416959745"" rel=""nofollow noreferrer"">C_Decrypt</a> to observe what  I mean)</p>

<p>I am encountering this behavior with a Safenet Luna device and am not sure what to make of it. Is it my code's fault for not querying for the length first by passing NULL in the output buffer, or is this a bug on the HSM/PKCS11 library side?</p>

<p>One more thing I should perhaps mention is that when I provide a 272 (256+16) bytes output buffer, the call succeeds and I am noticing that I am getting back my expected plaintext, <em>but also the padding block</em> which means 16 final bytes with the value 0x10. However, the output length is updated correctly to 256, <em>not</em> 272 - this also proves that I am not using CKM_AES_CBC instead of CKM_AES_CBC_PAD accidentally, which I suspected for a moment as well :)</p>
","<p>I have used <em>CKM.AES_CBC_PAD</em> padding mechanism with <em>C_Decrypt</em> in past. You have to make 2 calls to <em>C_Decrypt</em> <em>(1st ==> To get the size of the plain text, 2nd ==> Actual decryption)</em>. see the documentation <a href=""https://www.cryptsoft.com/pkcs11doc/v230/"" rel=""nofollow noreferrer"">here</a> which talks about determining the length of the buffer needed to hold the plain-text. </p>

<p>Below is the step-by-step code to show the behavior of decryption:</p>

<pre><code>//Defining the decryption mechanism
CK_MECHANISM mechanism = new CK_MECHANISM(CKM.AES_CBC_PAD);

//Initialize to zero -&gt; variable to hold size of plain text
LongRef lRefDec = new LongRef();

// Get ready to decrypt 
CryptokiEx.C_DecryptInit(session_1, mechanism, key_handleId_in_hsm);

// Get the size of the plain text -&gt; 1st call to decrypt
CryptokiEx.C_Decrypt(session_1, your_cipher, your_cipher.length, null, lRefDec);

// Allocate space to the buffer to store plain text.  
byte[] clearText = new byte[(int)lRefDec.value];

// Actual decryption -&gt; 2nd call to decrypt
CryptokiEx.C_Decrypt(session_1, eFileCipher, eFileCipher.length, eFileInClear,lRefDec);
</code></pre>

<p>Sometimes, decryption fails because your input encryption data was misleading (however, encryption is successful but corresponding decryption will fail) the decryption algorithm. So it is important not to send raw bytes directly to the encryption algorithm; rather encoding the input data with UTF-8/16 schema's preserves the data from getting misunderstood as network control bytes.  </p>
","206","<pkcs#11><pkcs#7><hsm><cbc-mode><cryptoki>","2","1","1","2019-07-10 15:41:38","","9","1","1833599","","2019-06-30 12:13:05","2019-06-29 14:35:36",""
"53313288","Why I am getting an error while opening digitally signed pdf document using PKCS7 and X509Certificate in C#?","<p>I am trying to sign a pdf file using <code>PKCS7</code> and <code>X509Certificate</code> but I get the following error when I open the signed pdf file in Adobe.</p>

<blockquote>
  <p><em>Document has been altered or corrupted since it was signed</em></p>
</blockquote>

<p>Docuement Hash </p>

<pre><code>66305799d97adc716694faa3aecb3b82136a76a57e0470fb289dcf727b83304b
</code></pre>

<h3>Following is my code:</h3>

<pre><code>public class Helper
{

    private static PdfPKCS7 _signature;
    private static PdfSignatureAppearance _apperance;
    private static byte[] _hash;
    private static byte[] _signatureHash;

    public static byte[] GetBytesToSign(string unsignedPdf, string tempPdf, string signatureFieldName, byte[] x509Signature)
    {
        if (System.IO.File.Exists(tempPdf))
            System.IO.File.Delete(tempPdf);

        var chain = new List&lt;Org.BouncyCastle.X509.X509Certificate&gt;
        {
            Org.BouncyCastle.Security.DotNetUtilities.FromX509Certificate(new X509Certificate2(x509Signature))
        };

        Org.BouncyCastle.X509.X509Certificate certificate = chain.ElementAt(0);

        using (PdfReader reader = new PdfReader(unsignedPdf))
        {
            using (FileStream os = System.IO.File.OpenWrite(tempPdf))
            {
                PdfStamper stamper = PdfStamper.CreateSignature(reader, os, '\0');

                PdfSignatureAppearance appearance = stamper.SignatureAppearance;

                appearance.SetVisibleSignature(new Rectangle(36, 748, 250, 400), 1, signatureFieldName);

                appearance.Certificate = chain[0];

                IExternalSignatureContainer external = new ExternalBlankSignatureContainer(PdfName.ADOBE_PPKLITE, PdfName.ADBE_PKCS7_DETACHED);

                MakeSignature.SignExternalContainer(appearance, external, 8192);

                Stream data = appearance.GetRangeStream();

                byte[] hash = DigestAlgorithms.Digest(data, ""SHA256"");

                var signature = new PdfPKCS7(null, chain, ""SHA256"", false);

                byte[] signatureHash = signature.getAuthenticatedAttributeBytes(hash, null, null, CryptoStandard.CMS);

                _signature = signature;
                _apperance = appearance;
                _hash = hash;
                _signatureHash = signatureHash;

                return signatureHash;
            }
        }
    }

    public static void EmbedSignature(string tempPdf, string signedPdf, string signatureFieldName, byte[] signedBytes)
    {
        using (PdfReader reader = new PdfReader(tempPdf))
        {
            using (FileStream os = File.OpenWrite(signedPdf))
            {
                _signature.SetExternalDigest(signedBytes, null, ""RSA"");

                byte[] encodedSignature = _signature.GetEncodedPKCS7(_hash, null, null, null, CryptoStandard.CMS);

                IExternalSignatureContainer external = new MyExternalSignatureContainer(encodedSignature);

                MakeSignature.SignDeferred(reader, signatureFieldName, os, external);
            }
        }
    }

    private class MyExternalSignatureContainer : IExternalSignatureContainer
    {
        private readonly byte[] signedBytes;

        public MyExternalSignatureContainer(byte[] signedBytes)
        {
            this.signedBytes = signedBytes;
        }

        public byte[] Sign(Stream data)
        {
            string strResp = File.ReadAllText(@""C:\Users\Digital\Content\KYC_responseXML.txt"");
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(strResp);
            string strDsc = xmlDoc.SelectSingleNode(""EsignResp/Signatures/DocSignature"").InnerText;
            return Convert.FromBase64String(strDsc);
        }

        public void ModifySigningDictionary(PdfDictionary signDic)
        {

        }
    }
}
</code></pre>

<h3>Webservice returned following XML signature:</h3>

<p>This XML file does not appear to have any style information associated with it. The document tree is shown below.</p>

<pre><code>&lt;EsignResp errCode=""NA"" errMsg=""NA"" resCode=""957C7BF1B9A9F1473E358F6F0D3FC200CB48A253"" status=""1"" ts=""2018-11-15T09:55:02"" txn=""UKC:eSign:5306:20181115095351206""&gt;
&lt;UserX509Certificate&gt;
MIIFtjCCBJ6gAwIBAgIEWxeBRzANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCSU4xMTAvBgNVBAoTKE5TREwgZS1Hb3Zlcm5hbmNlIEluZnJhc3RydWN0dXJlIExpbWl0ZWQxHTAbBgNVBAsTFENlcnRpZnlpbmcgQXV0aG9yaXR5MSIwIAYDVQQDExlOU0RMZUdvdklzc3VpbmdDQTIwMThUZXN0MB4XDTE4MTExNTA0MjUwMloXDTE4MTExNTA0NTUwMVowggFLMRAwDgYDVQQIEwdHdWphcmF0MQ8wDQYDVQQREwYzOTQ2NTAxTjBMBgNVBC4TRTE5OTJNMUI5NDhGNkIwQUM5MkY5MUIxMjBGOEQyMjBGMkJGMkMwRUVFQjBCMENGNkU3MDAxRkVDMjVBQkU3MEM1MDQ3QjENMAsGA1UEDBMEMDkzNzFSMFAGA1UELQNJADAxMDAwNTA5Wk9sWlVJWDJGMTlWcXJwUVN4YUZ0NjZkMW9ldmZpbllocHI2TXN4QXlYQXI3MCttRnJLQXBJOE5wT1BLMG1zNDEpMCcGA1UEQRMgY2IxNjYyNzgNDYzNDZiYjg4M2I1NGI2ZGM2MWJlNzcxETAPBgNVBAoTCFBlcnNvbmFsMQswCQYDVQQGEwJJTjEoMCYGA1UEAxMfQmFoZWxpbSBBYmR1bG1hbm5hbiBBYmR1bHNhdHRhcjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABHzwDifYLBhJfjKTgtaACz77Nm/EM3INgefVdsDkwMexp52vssDxu7jN/yCXCJWOThOHeWfTQozWP1t87J+EsOajggIwMIICLDALBgNVHQ8EBAMCBsAwgaUGA1UdIASBnTCBmjCBlwYHYIJkZAIEATCBizA/BggrBgEFBQcCARYzaHR0cHM6Ly8xMjEuMjQwLjkuOC9jcHMvTlNETGUtR292LUNBLUNQUy12ZXIxLjAucGRmMEgGCCsGAQUFBwICMDwMOkFhZGhhYXItZUtZQy1PVFAgQ2xhc3MgQ2VydGlmaWNhdGUgaXNzdWVkIGJ5IE5TREwgZS1Hb3YgQ0EwTgYIKwYBBQUHAQEEQjBAMD4GCCsGAQUFBzAChjJodHRwczovLzEyMS4yNDAuOS44L3JlcG9zaXRvcnkvTlNETGUtR292Q0EyMDE4LmNlcjCB5AYDVR0fBIHcMIHZMDWgM6Axhi9odHRwOi8vMTIxLjI0MC45LjgvY3JsL05TRExlR292VUFUSXNzdWluZ0NBLmNybDCBn6CBnKCBmaSBljCBkzELMAkGA1UEBhMCSU4xMTAvBgNVBAoTKE5TREwgZS1Hb3Zlcm5hbmNlIEluZnJhc3RydWN0dXJlIExpbWl0ZWQxHTAbBgNVBAsTFENlcnRpZnlpbmcgQXV0aG9yaXR5MSIwIAYDVQQDExlOU0RMZUdvdklzc3VpbmdDQTIwMThUZXN0MQ4wDAYDVQQDEwVDUkw2NjAfBgNVHSMEGDAWgBTSGuo/qezZNRnR1RvxYGbZw9QjFDAdBgNVHQ4EFgQUZYy9fj/1CqZ19ZWpZeOYFmHKSnwwDQYJKoZIhvcNAQELBQADggEBAHZblBpACyNn2gFHxZcx1ezyIU29HGacChWlzCdTiSGAZG492wVnEFljXGM4RhVP0mSA/SsCibORI4zHSyyf56DZoNTrHJrOxU+nxqOY1Ss1E0kjWVcyEAmlPYqY7I8pTiNibxGg59ibezjNV4uSULcClXq+e+rcnun2pBail9ReSkOQJiLL7pHHKAqdBP6sxvT0nhD/bxnzYc2aVrqwCOp1nErx8csBISxzTOvo0zPfrGaWWyDWShhkH2FKXyShZRdT9W98EBOP1fyx9Bg1XrlOdtLNR3Ex7ZnVhRaBPjkkNB37yP8Vx5OMZ8lzTOgdw0FKbV4A1rc0UdJvRz62e+w=
&lt;/UserX509Certificate&gt;
&lt;Signatures&gt;
&lt;DocSignature error="""" id=""1"" sigHashAlgorithm=""SHA256""&gt;
MIILXAYJKoZIhvcNAQcCoIILTTCCC0kCAQExDzANBglghkgBZQMEAgEFADALBgkqhkiG9w0BBwGgggnQMIIFtjCCBJ6gAwIBAgIEWxeBRzANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCSU4xMTAvBgNVBAoTKE5TREwgZS1Hb3Zlcm5hbmlIEluZnJhc3RydWN0dXJlIExpbWl0ZWQxHTAbBgNVBAsTFENlcnRpZnlpbmcgQXV0aG9yaXR5MSIwIAYDVQQDExlOU0RMZUdvdklzc3VpbmdDQTIwMThUZXN0MB4XDTE4MTExNTA0MjUwMloXDTE4MTExNTA0NTUwMVowggFLMRAwDgYDVQQIEwdHdWphcmF0MQ8wDQYDVQQREwYzOTQ2NTAxTjBMBgNVBC4TRTE5OTJNMUI5NDhGNkIwQUM5MkY5MUIxMjBGOEQyMjBGMkJGMkMwRUVFQjBCMENGNkU3MDAxRkVDMjVBQkU3MEM1MDQ3QjENMAsGA1UEDBMEMDkzNzFSMFAGA1UELQNJADAxMDAwNTA5Wk9sWlVJWDJGMTlWcXJwUVN4YUZ0NjZkMW9ldmZpbllocHI2TXN4QXlYQXI3MCttRnJLQXBJOE5wT1BLMG1zNDEpMCcGA1UEQRMgY2IxNjYyNzgyNDYzNDZiYjg4M2I1NGI2ZGM2MWJlNzcxETAPBgNVBAoTCFBlcnNvbmFsMQswCQYDVQQGEwJJTjEoMCYGA1UEAxMfQmFoZWxpbSBBYmR1bG1hbm5hbiBBYmR1bHNhdHRhcjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABHzwDifYLBhJfjKTgtaACz77Nm/EM3INgefVdsDkwMexp52vssDxu7jN/yCXCJWOThOHeWfTQozWP1t87J+EsOajggIwMIICLDALBgNVHQ8EBAMCBsAwgaUGA1UdIASBnTCBmjCBlwYHYIJkZAIEATCBizA/BggrBgEFBQcCARYzaHR0cHM6Ly8xMjEuMjQwLjkuOC9jcHMvTlNETGUtR292LUNBLUNQUy12ZXIxLjAucGRmMEgGCCsGAQUFBwICMDwMOkFhZGhhYXItZUtZQy1PVFAgQ2xhc3MgQ2VydGlmaWNhdGUgaXNzdWVkIGJ5IE5TREwgZS1Hb3YgQ0EwTgYIKwYBBQUHAQEEQjBAMD4GCCsGAQUFBzAChjJodHRwczovLzEyMS4yNDAuOS44L3JlcG9zaXRvcnkvTlNETGUtR292Q0EyMDE4LmNlcjCB5AYDVR0fBIHcMIHZMDWgM6Axhi9odHRwOi8vMTIxLjI0MC45LjgvY3JsL05TRExlR292VUFUSXNzdWluZ0NBLmNybDCBn6CBnKCBmaSBljCBkzELMAkGA1UEBhMCSU4xMTAvBgNVBAoTKE5TREwgZS1Hb3Zlcm5hbmNlIEluZnJhc3RydWN0dXJlIExpbWl0ZWQxHTAbBgNVBAsTFENlcnRpZnlpbmcgQXV0aG9yaXR5MSIwIAYDVQQDExlOU0RMZUdvdklzc3VpbmdDQTIwMThUZXN0MQ4wDAYDVQQDEwVDUkw2NjAfBgNVHSMEGDAWgBTSGuo/qezZNRnR1RvxYGbZw9QjFDAdBgNVHQ4EFgQUZYy9fj/1CqZ19ZWpZeOYFmHKSnwwDQYJKoZIhvcNAQELBQADggEBAHZblBpACyNn2gFHxZcx1ezyIU29HGacChWlzCdTiSGAZG492wVnEFljXGM4RhVP0mSA/SsCibORI4zHSyyf56DZoNTrHJrOxU+nxqOY1Ss1E0kjWVcyEAmlPYqY7I8pTiNibxGg59ibezjNV4uSULcClXq+e+rcnun2pBail9ReSkOQJiLL7pHHKAqdBP6sxvT0nhD/bxnzYc2aVrqwCOp1nErx8csBISxzTOvo0zPfrGaWWyDWShhkH2FKXyShZRdT9W98EBOP1fyx9Bg1XrlOdtLNR3Ex7ZnVhRaBPjkkNB37yP8Vx5OMZ8lzTOgdw0FKbV4A1rc0UdJvRz62e+wwggQSMIIC+qADAgECAgRalYv+MA0GCSqGSIb3DQEBCwUAMIGDMQswCQYDVQQGEwJJTjExMC8GA1UEChMoTlNETCBlLUdvdmVybmFuY2UgSW5mcmFzdHJ1Y3R1cmUgTGltaXRlZDEdMBsGA1UECxMUQ2VydGlmeWluZyBBdXRob3JpdHkxIjAgBgNVBAMTGU5TRExlR292SXNzdWluZ0NBMjAxOFRlc3QwHhcNMTgwMjI3MTYxOTAzWhcNMjMwMjI3MTY0OTAzWjCBgzELMAkGA1UEBhMCSU4xMTAvBgNVBAoTKE5TREwgZS1Hb3Zlcm5hbmNlIEluZnJhc3RydWN0dXJlIExpbWl0ZWQxHTAbBgNVBAsTFENlcnRpZnlpbmcgQXV0aG9yaXR5MSIwIAYDVQQDExlOU0RMZUdvdklzc3VpbmdDQTIwMThUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAl2NTpJJWbR3OPHY5r2ldRSwGKiEImn+uHf8fKLkkLwypERmkz6otgPExuC51ZneFLXtzReNRzrYoP2FkiNw2LkXbYK0tg9tZ0KdzsuGPtuYfvu6EG0bCO2XmRePrzyXBdEbWQw501rLkRGxxq4EsgWDJgxlClKvcxpH1f3IN940moQz3GktVMF4e3WF6GnkMSY9bcAKrfGQE6PoR52v+ObkG7sWg8hRGxAo5mVFaIumTq81wkK4v7ZGWZL3cjinZb82E7f9PTOtPZlHzfcMct2U6+4ldAwH+jp3YrBTeSw7/HQbPclR9pqW22bByw0nne/DQYHo6hHTUM6afiKwEewIDAQABo4GLMIGIMCsGA1UdEAQkMCKADzIwMTgwMjI3MTYxOTAzWoEPMjAyMzAyMjcxNjQ5MDNaMAsGA1UdDwQEAwIBBjAfBgNVHSMEGDAWgBTSGuo/qezZNRnR1RvxYGbZw9QjFDAdBgNVHQ4EFgQU0hrqP6ns2TUZ0dUb8WBm2cPUIxQwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAdeGegyhzT279eGyMriBYUN+bwtyKFFjotpeuUl0o8wYDDZHamddKj6bCW9reNrUCgOwronG6EU8P8WcLQHvbtcqsi8PZ5CqBK1S6xh09fvgqQwVFkMD2Y2fv7Nlr0P7+bjDSbfgu5XizxFe5WUY/P8bgVU1gLvRZEMo4Q6oV4eXPdWiE77wwcwAwMDD2EgpPY/HOjpNOiJzhefo0sjHMxQaQPRliclBpHM+EVmFX0NZ06nK2Ou9WkeEV9CGRlldZAgQxV5cAU9zjFIZFUwcbl7R7NF9NbdEXaHNlXFjhhITLQors47oTu+ukbNeyUl3d5/L+CDUZHNVDtDCKNjucyDGCAVAwggFMAgEBMIGMMIGDMQswCQYDVQQGEwJJTjExMC8GA1UEChMoTlNETCBlLUdvdmVybmFuY2UgSW5mcmFzdHJ1Y3R1cmUgTGltaXRlZDEdMBA1UECxMUQ2VydGlmeWluZyBBdXRob3JpdHkxIjAgBgNVBAMTGU5TRExlR292SXNzdWluZ0NBMjAxOFRlc3QCBFsXgUcwDQYJYIZIAWUDBAIBBQCgSzAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMC8GCSqGSIb3DQEJBDEiBCBmMFeZ2XrccWaU+qOuyzuCE2p2pX4EcPsonc9ye4MwSzAUBggqhkjOPQQDAgYIKoZIzj0DAQcERjBEAiA803FSntU+Ao7xqJ0bsF5EXG4T53UWnVeUn+UqjcQ1/wIgVZ/M9XH5xzew9+/dLnP9P574jszJPg7/IrtRVyFP4tc=
&lt;/DocSignature&gt;
&lt;/Signatures&gt;
&lt;Signature xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
&lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
&lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""/&gt;
&lt;SignatureMethod Algorithm=""http://www.w3.org/2001/04/xmldsig-more#rsa-sha256""/&gt;
&lt;Reference URI=""""&gt;
&lt;Transforms&gt;
&lt;Transform Algorithm=""http://www.w3.org/2000/09/xmldsig#enveloped-signature""/&gt;
&lt;/Transforms&gt;
&lt;DigestMethod Algorithm=""http://www.w3.org/2001/04/xmlenc#sha256""/&gt;
&lt;DigestValue&gt;zcFiuaTy/HajJpSKCS/DtAZ8b+TMTPfO+Na7dLP38i4=&lt;/DigestValue&gt;
&lt;/Reference&gt;
&lt;/SignedInfo&gt;
&lt;SignatureValue&gt;
qOJyQroX0Rr53prUuRSCAFKQZ77SOBXxM3x8iwk7GgrfOjdItK+/MMXes8K39Hy2jvzJuEtBai5nx4XiWrfHWThYcnkD/iuQb+Rs/NC9blJj5EdYSLlrZ6UAT2NYU70WKgbrteZiSgkk/PAyPTTwZzxtiExN5aPpalX0OkuHhrXnmvnssc4taaFNP3BfJ4JJphJiUgq02DLmCtvRI25Qg0H2kMpLZFiGNxCZTXck2hwDLpO8RVb9k6Fn8DZhWDWLEbEPNHb6CoAMsvTu7iSC9VMpq7c2scAeg2qVRFf63tmkAfbQZs7boWrmj96JwVj5P7K95UzH8ku+WehIm+8w==
&lt;/SignatureValue&gt;
&lt;KeyInfo&gt;
&lt;KeyValue&gt;
&lt;RSAKeyValue&gt;
&lt;Modulus&gt;
0o9vohWZ3ztI9ea8D/zUEUBRq6c82BE7sFmr1hNMeuGSJQFf39ceesRtGUzlUYVWXcU23P8sVZ5419CHh7ApFzUXaLD72i/2d5FFI0n3iRlTQec9PEUHyrvOCVDpqBhbnrO/EHBqRluUQJTQUtMu5mhPNFV7IIJMTEAsUhCL9adZXXQK9NeK0foRr29Oq7VdEGfSeLzHIibpQmhNPh89oJXqu0cmbNSW4J4i2GmwHQpmsmHaSQcgh4mgVrykO64pAKXPreAPipDHQM1l/e5hilYlWfLHxhC5ObTCTcydQ218IVulFOFhdQt7xVV61TOmoTC2elhWbDqoLJBVU5mBfQ==
&lt;/Modulus&gt;
&lt;Exponent&gt;AQAB&lt;/Exponent&gt;
&lt;/RSAKeyValue&gt;
&lt;/KeyValue&gt;
&lt;X509Data&gt;
&lt;X509SubjectName&gt;
ITC INFRASTRUCTURE LIMITED
&lt;/X509SubjectName&gt;
&lt;X509Certificate&gt;
MIIGIjCCBQqgAwIBAgIEANgp4jANBgkqhkiG9w0BAQsFADCBkzELMAkGA1UEBhMCSU4xKjAoBgNVBAoTIWVNdWRocmEgQ29uc3VtZXIgU2VydmljZXMgTGltaXRlZDEdMBsGA1UECxMUQ2VydGlmeWluZyBBdXRob3JpdHkxOTA3BgNVBAMTMGUtTXVkaHJhIFN1YiBDQSBDbGFzcyAyIGZvciBEb2N1bWVudCBTaWduZXIgMjAxNDAeFw0xNzA2MjMxMTUzMTVaFw0xOTA2MjMxMTUzMTVaMIIBEzELMAkGA1UEBhMCSU4xMTAvBgNVBAoTKE5TREwgRSBHT1ZFUk5BTkNFIElORlJBU1RSVUNUVVJFIExJTUlURUQxIzAhBgNVBAsTGlBBTiBUSU4gQU5EIFVJRCBPUEVSQVRJT05TMQ8wDQYDVQQREwY0MDAwMTMxFDASBgNVBAgTC01BSEFSQVNIVFJBMQ8wDQYDVQQJEwZNVU1CQUkxPDA6BgNVBDMTMzFTVCBGTE9PUiBUSU1FUyBUT1dFUiBLQU1BTEEgTUlMTFMgQ09NUE9VTkQgU0IgTUFSRzE2MDQGA1UEAxMtRFMgTlNETCBFIEdPVkVSTkFOQ0UgSU5GUkFTVFJVQ1RVUkUgTElNSVRFRCAzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0o9vohWZ3ztI9ea8D/zUEUBRq6c82BE7sFmr1hNMeuGSJQFf39ceesRtGUzlUYVWXcU23P8sVZ5419CHh7ApFzUXaLD72i/2d5FFI0n3iRlTQec9PEUHyvOCVDpqBhbnrO/EHBqRluUQJTQUtMu5mhPNFV7IIJMTEAsUhCL9adZXXQK9NeK0foRr29Oq7VdEGfSeLzHIibpQmhNPh89oJXqu0cmbNSW4J4i2GmwHQpmsmHaSQcgh4mgVrykO64pAKXPreAPipDHQM1l/e5hilYlWfLHxhC5ObTCTcydQ218IVulFOFhdQt7xVV61TOmoTC2elhWbDqoLJBVU5mBfQIDAQABo4IB+TCCAfUwEwYDVR0jBAwwCoAITaZEyKbiAAgwHQYDVR0OBBYEFGzNaT6D2SoleAtlGlS4gBsQvo3qMA4GA1UdDwEB/wQEAwIGwDAcBgNVHREEFTATgRFISVRFTk1ATlNETC5DTy5JTjCB0gYDVR0gBIHKMIHHMC0GBmCCZGQCAjAjMCEGCCsGAQUFBwICMBUaE0NsYXNzIDIgQ2VydGlmaWNhdGUwRAYGYIJkZAoBMDowOAYIKwYBBQUHAgIwLBoqT3JnYW5pc2F0aW9uYWwgRG9jdW1lbnQgU2lnbmVyIENlcnRpZmljYXRlMFAGB2CCZGQBCAIwRTBDBggrBgEFBQcCARY3aHR0cDovL3d3dy5lLW11ZGhyYS5jb20vcmVwb3NpdG9yeS9jcHMvZS1NdWRocmFfQ1BTLnBkZjB3BggrBgEFBQcBAQRrMGkwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmUtbXVkaHJhLmNvbTBBBggrBgEFBQcwAoY1aHR0cDovL3d3dy5lLW11ZGhyYS5jb20vcmVwb3NpdG9yeS9jYWNlcnRzL2RvY2NsMi5jcnQwQwYDVR0fBDwwOjA4oDagNIYyaHR0cDovL3d3dy5lLW11ZGhyYS5jb20vcmVwb3NpdG9yeS9jcmxzL2RvY2NsMi5jcmwwDQYJKoZIhvcNAQELBQADggEBALp9E7tM/HvtM+FEfaHdBn5MqL2WLf/GuuMH02ULbIDLQQNK+R4ivuFXLAqU5hbgtr9Yi1oRlfA5iTVDfxKLW6nGF3aSzNihgwhNP69/WM0TozxwYzCxMAVMGPGY+wUuLxWo67RybDCmQCaeG/RXM7FzfKtX8E99g9pBwjw23dc3kGIUqnWUqTEXjauYwz/7XDO2PWJw7F+PPeOrrxC2gA0F6jCT24bZjoF32eLCgXFcE5tIBMhM8WnUR3Pfex8mw5sctuUi8WFkgbLVrIBGuRDebMmr2/k2+D/O4tyTSbdl8YIV4MtHvMIUHnD0Z691Tjwj109A6h0AtuJAXvOm7FE=
&lt;/X509Certificate&gt;
&lt;/X509Data&gt;
&lt;/KeyInfo&gt;
&lt;/Signature&gt;
&lt;/EsignResp&gt;
</code></pre>
","","205","<c#><itext><digital-signature><x509certificate><pkcs#7>","2","","0","2018-11-15 09:41:11","","6","0","10655739","","2018-11-15 09:41:11","2018-11-15 05:57:36",""
"53408547","Using openssl to check if root certificate in PKCS#7 is revoked","<p>Here's <code>pkcs7_verify</code> signature taken from C/C++ library: </p>

<pre><code>int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
             BIO *indata, BIO *out, int flags);
</code></pre>

<p>It can be used with PKCS7 block (p7) and the section that it suppose to sign (in data). </p>

<p>I wonder how does this check detect if one of the certificate in the chain is revoked...</p>

<p>From what I know, revocation check can be made only if matching against another certificate outside the pkcs7 block, which is marked as revoked.</p>

<p>I checked the function arguments and found one that represent the list of store trusted certificates. </p>

<p>This arg should hold the certificate which is the issuer of the lower-most certificate in the pkcs7 chain. So my guess is that if this certificate is marked as revoked, we fail the check on <code>revocation</code> reason... </p>

<p>But what if another certificate higher in the chain is revoked ? how do I provide this piece of information to <code>pkcs7_verify</code> ?</p>

<p>Or perhaps there's another openssl method that decide if a certificate in the chain is revoked or not ?</p>

<p>UPDATE: </p>

<p>I've found an alternative way to check whether a certificate is revoked. In the example below we can see that <code>revoked_test.pem</code> is identified as revoked by matching against the list in <code>crl_chain.pem</code>. How can I do it programmatically ? </p>

<pre><code>openssl verify -crl_check -CAfile crl_chain.pem revoked-test.pem 
revoked-test.pem: OU = Domain Control Validated, OU = PositiveSSL, CN = xs4all.nl
error 23 at 0 depth lookup:certificate revoked
</code></pre>

<p>thanks </p>
","<p>Most of the rules of the certification path validation is set in the <code>X509_STORE</code> structure you are passing to the <code>PKCS7_verify</code> function.</p>

<p><s><a href=""http://itsjustsosimple.blogspot.com/2017/05/openssl-how-to-verifying-certificate.html"" rel=""nofollow noreferrer"">This example</a> show how to build a complete X509_STORE and explain how to activate the CRL validation in the X509_STORE.</s> (the example is good for setting up the crl validation but not for the certificate chain handling)</p>

<p>The core functions are:</p>

<ul>
<li><code>X509_STORE_set_flags</code></li>
<li><code>X509_STORE_add_crl</code> </li>
<li><code>X509_STORE_add_lookup</code></li>
</ul>

<p>You use the <code>X509_STORE_set_flags</code> to tell the certificate store to perform CRL validation. The flags you need are: <code>X509_V_FLAG_CRL_CHECK_ALL | X509_V_FLAG_CRL_CHECK</code>. You can find all flags <a href=""https://www.openssl.org/docs/man1.1.0/crypto/X509_VERIFY_PARAM_set_depth.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>You use the<code>X509_STORE_add_crl</code> to add CRLs for the validation. The CRL doesn't need to be from a root CA.</p>

<p>As an option to the<code>X509_STORE_add_crl</code>, you have the <code>X509_STORE_add_lookup</code>, to add a function to lookup for CRLs in any place (e.g.: file system, database, urls, etc.).</p>

<p>When performing the chain validation, OpenSSl will use the CRLs and lookup functions in the X509_STORE to validate all certificates in the chain. If any certificate in the chain is revoked, an error is returned.</p>

<p>It's important to add that <a href=""https://tools.ietf.org/html/rfc5280#section-6"" rel=""nofollow noreferrer"">the X.509 certification path validation</a> specification doesn't include the validation of trust anchors (usually root certificates). All certificates in the chain under the trust anchor have to be verified, but the trust anchor is trusted because the verifier set it as so (i.e.: the trust anchor validation is made out-of-bounds by the verifier).</p>
","200","<c++><c><openssl><x509certificate><pkcs#7>","1","1","1","2018-11-25 11:09:38","53453578","0","2","4333809","","2018-11-22 18:24:02","2018-11-21 09:07:57",""
"40382157","Create a correct PKCS7/CMS (ASN.1) from existing XML Signature in PHP","<p>I have an XML digital signature, (<code>xmlns=""http://www.w3.org/2000/09/xmldsig</code>) and I want to convert this into a PKCS7 signature. </p>

<p>I belive I have to use an ASN.1 encoder such as <a href=""https://github.com/FGrosse/PHPASN1"" rel=""nofollow noreferrer"">https://github.com/FGrosse/PHPASN1</a> but I cannot understand how to create a valid pkcs7/asn.1 signaure with it.</p>

<p>Is this possible?</p>
","<p>No. It's not posible.</p>

<p>When making a XML signature, the private key is signing a data codification (codified in XML).</p>

<p>You are able to put the information included in this XML signature into a PKCS7 signature (codified in ASN.1).
But then, the codification of these data would be different, so the signature wouldn't be valid.</p>
","197","<php><pki><asn.1><pkcs#7><xml-dsig>","-1","1","1","2016-11-18 11:03:54","40675463","1","","3329664","","2016-11-05 09:42:01","2016-11-02 14:15:08",""
"4466885","What version of the PKCS#1 spec is gcrypt implemented against?","<p>I am trying to determine which version of the PKCS#1 spec that gcrypt is implemented against.</p>

<p>Thank you</p>
","<p>The <a href=""http://www.gnupg.org/documentation/manuals/gcrypt/Cryptographic-Functions.html"" rel=""nofollow"">gcrypt manual</a> talks about ""type 1 padding"" (for signatures) and ""type 2 padding"" (for encryption). This means that it implements the ""old-style"" PKCS#1 signature and encryption methods, also called ""v1.5"" because they were the only ones specified in PKCS#1 v1.5. gcrypt does not appear (from what I see in the documentation) to implement the more recent OAEP (encryption) and PSS (signature) paddings.</p>

<p>Note, though, that the ""v1.5"" paddings are still specified in more recent versions of <a href=""http://www.rsa.com/rsalabs/node.asp?id=2125"" rel=""nofollow"">PKCS#1</a>, so it can be said that gcrypt is also implemented against PKCS#1 v2.1 -- but it does not implement <em>all</em> of it.</p>
","194","<c++><encryption><pkcs#7>","2","2","1","2010-12-17 13:06:59","4470702","0","","","","","2010-12-17 01:09:37",""
"53587927","How to get signed content from pkcs7 attached signature using Bouncy Castle","<p>using following code; when i tries to get access the signed from the PKCS7 attached  signature. </p>

<pre><code>  cms = new CMSSignedData(envelopedData); //PKCS7 envelope
  String signedData = new String((byte[])cms.getSignedContent().getContent());
</code></pre>

<p>I got the output like this. </p>

<pre><code>n¬∫‚Ñ¢(5√Ç≈°?¬∂√ÅN≈°c¬´n‚Äò¬∂Àú√ä√µ√ª√∏ÀÜ‚Äö&lt;√π√¶B0¬∏√∞¬ø√∏""ÀúZ√ä√ó`‚Äî√µW√∏≈æ8¬π¬®c¬º‚Äò√á{¬•√©√ó√Üx¬¢√¥√£√ï‚Ä∫|?‚Ç¨√ß≈æ√Ü3√î√ú√ß&amp;¬¶¬§X‚Äû√µ¬∑3c'G≈æ\¬≥√ñ/‚Ç¨√Å&lt;≈æ¬≤¬¨√ø¬µ∆í√â√¢w‚Ä¶¬´b‚Ä∫¬§?¬§¬≠1¬ÆkB‚Ä¢√¥?¬≥√Å¬≠2‚Ç¨¬¶?r`!¬¶√∑nt¬Ø*≈∏
</code></pre>

<p>Same thing works fine for detached signature. For attached signature, i used the following code.</p>

<pre><code>CMSSignedData sigData = gen.generate(msg, true); 
</code></pre>

<p>Even. I tried all the charsets for the signedData String.</p>
","<p>I found the problem and resolved it. It was due to the double signing process.</p>
","194","<java><digital-signature><bouncycastle><pkcs#7>","0","0","1","2018-12-13 10:33:59","","0","","","","","2018-12-03 05:25:51",""
"53849607","Verify signature of SMIME .p7m file","<p>I need to to validate the signature of one .p7m package(SMIME message) using c++ code. I understood this file contains both the signature and the certificate along with the original message content. Initially when I was trying with my c++ code , I was getting some errors. Now I am planning to do it using openssl command line before moving to c++ code for better understanding how to achieve this. To get the public certificate , I am using the following command :</p>

<pre><code>    openssl pkcs7 -in Signed.p7m -inform DER -print_certs &gt; certificate.pem
</code></pre>

<p>Now, I want to extract the signature value from that file to validate the signature. I want to see the value of the signature as well as the certificate, that's why I want to have those values separately in a file.</p>

<p>One of my friend tried to extract the certificate &amp; signature as well as the validation of the package using c# code and getting expected result , so the package is not corrupted.</p>

<p>I have tried multiple commands from internet. But none of those are working correctly. It will be helpful if you can provide one working openssl command.</p>

<p>Thanks you.</p>
","","191","<openssl><certificate><signature><pkcs#7><smime>","0","","0","2018-12-19 10:48:39","","0","","","","","2018-12-19 10:48:39",""
"52824352","PKCS7 validation error: ASN1 corrupted data","<p>I am developing a java class that signs text files in PKCS7 format. I discovered that it is possible to do this using Sun libraries instead of BouncyCastle, and I developed the following method:</p>

<pre><code>    public void AssinaPKCS7(String ArquivoAssinar) {

        String SrtResultPKCS7 = """";
        byte[] Conteudo;
        byte[] Hash;
        String DadosArq = """";
        String Linha = """";
        boolean AssinValid = false;

        try {
            FileInputStream Entrada = new FileInputStream(ArquivoAssinar);
            InputStreamReader Leitor = new InputStreamReader(Entrada, Charset);
            BufferedReader Buffer = new BufferedReader(Leitor);
            Linha = Buffer.readLine();

            while (Linha != null) {
                DadosArq = DadosArq + Linha;
                Linha = Buffer.readLine();
            }

            Buffer.close();

            Conteudo = DadosArq.getBytes(Charset);

            X500Name xName = X500Name.asX500Name(Certif.getSubjectX500Principal());
            BigInteger serial = Certif.getSerialNumber();
            AlgorithmId digestAlgorithmId = new AlgorithmId(AlgorithmId.SHA_oid);
            AlgorithmId signAlgorithmId = new AlgorithmId(AlgorithmId.RSAEncryption_oid);

            MessageDigest MessDig = MessageDigest.getInstance(""SHA1"");
            Hash = MessDig.digest(Conteudo);

            PKCS9Attribute Atributo1 = new PKCS9Attribute(PKCS9Attribute.CONTENT_TYPE_OID, ContentInfo.DATA_OID);
            PKCS9Attribute Atributo2 = new PKCS9Attribute(PKCS9Attribute.MESSAGE_DIGEST_OID, Hash); 
            PKCS9Attributes ConjuntoAtrib = new PKCS9Attributes(new PKCS9Attribute[] {Atributo1, Atributo2}); 

            Signature Sign = Signature.getInstance(AlgoritmoAssinatura);
            Sign.initSign(PrivPass);
            Sign.update(Conteudo);
            ResultadoAssinatura = Sign.sign();

            Signature Verif = Signature.getInstance(AlgoritmoAssinatura);
            Verif.initVerify(Certif);
            Verif.update(Conteudo);
            AssinValid = Verif.verify(ResultadoAssinatura);

            if (AssinValid) {
                try {
                    SignerInfo sInfo = new SignerInfo(xName, serial, digestAlgorithmId, ConjuntoAtrib, signAlgorithmId, ResultadoAssinatura, null);

                    ContentInfo cInfo = new ContentInfo(ContentInfo.DIGESTED_DATA_OID, new DerValue(DerValue.tag_OctetString, Conteudo));

                    PKCS7 p7 = new PKCS7(new AlgorithmId[] { digestAlgorithmId }, cInfo, new java.security.cert.X509Certificate[] { Certif }, new SignerInfo[] { sInfo });

                    ByteArrayOutputStream bOut = new DerOutputStream();
                    p7.encodeSignedData(bOut);
                    byte[] encoded = bOut.toByteArray();
                    SrtResultPKCS7 = Encoder.encode(encoded);

                    FileOutputStream Saida = new FileOutputStream(ArquivoAssinar);
                    OutputStreamWriter Escritor = new OutputStreamWriter(Saida, Charset);
                    BufferedWriter BuffWriter = new BufferedWriter(Escritor); 
                    //BuffWriter.write(SrtResultPKCS7);
                    BuffWriter.write(bOut.toString());
                    BuffWriter.close();
                }
                catch (Exception E) {
                    E.printStackTrace();        
                }
            }
            else {
                System.out.println(""Assinatura inv√°lida"");
            }
        }
        catch (Exception E) {
            E.printStackTrace();
        }

    }
</code></pre>

<p>When I tryed to validate the resulting file in online validator <a href=""https://www.receita.fazenda.gov.br/Aplicacoes/SSL/ATBHE/assinadoc/ValidadorAssinaturas.app/valida.aspx"" rel=""nofollow noreferrer"">https://www.receita.fazenda.gov.br/Aplicacoes/SSL/ATBHE/assinadoc/ValidadorAssinaturas.app/valida.aspx</a> I got this error message:</p>

<p><strong>ASN1 corrupted data</strong></p>

<p>I checked the signature, she is OK. I believe the error is in som data convertion while generating PKCS7 result.</p>

<p>Has anyone had this problem? And how can I validate the PCKS7 result in java code? </p>
","<p>I don't know how you checked the signature, other than the meaningless check in your code which repeats the mistake(s), but it was of the wrong data and since you didn't show us <code>AlgoritmoAssinatura</code> maybe the wrong method as well. You also have several other errors. Rather than detail all of them, here is an example that produces a valid result, with the changes commented:</p>

<pre><code>// use test data for example
KeyStore ks = KeyStore.getInstance(""JKS""); ks.load(new FileInputStream (args[0]), args[1].toCharArray());
PrivateKey PrivKey = (PrivateKey) ks.getKey (args[2], args[1].toCharArray());
X509Certificate Certif = (X509Certificate) ks.getCertificate(args[2]);
String Message = ""test"";
String ArquivoAssinar = args[3];
String Charset = ""ASCII""; // no idea, see below

String SrtResultPKCS7 = """";
byte[] Conteudo = Message.getBytes(Charset);
byte[] Hash;
//String DadosArq = """";
//String Linha = """";
//boolean AssinValid = false;

try {
    // the name in SignerInfo is the _Issuer_ name NOT the Subject
    X500Name xName = X500Name.asX500Name(Certif.getIssuerX500Principal());
    BigInteger serial = Certif.getSerialNumber();
    AlgorithmId digestAlgorithmId = new AlgorithmId(AlgorithmId.SHA_oid);
    AlgorithmId signAlgorithmId = new AlgorithmId(AlgorithmId.RSAEncryption_oid);

    MessageDigest MessDig = MessageDigest.getInstance(""SHA1"");
    Hash = MessDig.digest(Conteudo);

    PKCS9Attribute Atributo1 = new PKCS9Attribute(PKCS9Attribute.CONTENT_TYPE_OID, ContentInfo.DATA_OID);
    PKCS9Attribute Atributo2 = new PKCS9Attribute(PKCS9Attribute.MESSAGE_DIGEST_OID, Hash); 
    PKCS9Attributes ConjuntoAtrib = new PKCS9Attributes(new PKCS9Attribute[] {Atributo1, Atributo2}); 

    // when using signedattrs, signature is of the encoded attrs 
    // (without the context-implicit tag used when embedded in SignerInfo)
    Signature Sign = Signature.getInstance(""SHA1withRSA"");
    Sign.initSign(PrivKey);
    Sign.update(ConjuntoAtrib.getDerEncoding());
    byte[] ResultadoAssinatura = Sign.sign();

    SignerInfo sInfo = new SignerInfo(xName, serial, digestAlgorithmId, ConjuntoAtrib, signAlgorithmId, ResultadoAssinatura, null);
    // contenttype inside signed-data is data not digested-data  
    ContentInfo cInfo = new ContentInfo(ContentInfo.DATA_OID, new DerValue(DerValue.tag_OctetString, Conteudo));

    PKCS7 p7 = new PKCS7(new AlgorithmId[] { digestAlgorithmId }, cInfo, new java.security.cert.X509Certificate[] { Certif }, new SignerInfo[] { sInfo });

    ByteArrayOutputStream bOut = new DerOutputStream();
    p7.encodeSignedData(bOut);
    byte[] encoded = bOut.toByteArray();
    // Java doesn't define a class 'Encoder' so I assume this is base64
    SrtResultPKCS7 = DatatypeConverter.printBase64Binary(encoded); // gone in 11!

    FileOutputStream Saida = new FileOutputStream(ArquivoAssinar);
    OutputStreamWriter Escritor = new OutputStreamWriter(Saida, Charset);
    BufferedWriter BuffWriter = new BufferedWriter(Escritor);
    // this was correct for base64 (although the buffering is wasted)
    BuffWriter.write(SrtResultPKCS7);
    // this was nonsense -- it decodes the DER bytes as if they were characters,
    // which they aren't, and then OSW re-encodes them to probably wrong bytes
    //BuffWriter.write(bOut.toString());
    BuffWriter.close();
    // alternatively could write DER/binary with a Stream (NOT a Writer)
}
catch (Exception E) {
    E.printStackTrace();
}
</code></pre>

<p>It's not clear to me what output format you -- or the site you link -- want. 
Using binary/DER is fairly common, but can't be cut&amp;pasted and is harder to work with. Base64 of DER is rare but not unknown. If you or they want the standard PEM format, used by a lot of software, that is NOT merely base64 of DER; it is base64 of DER PLUS line breaks every 64 characters AND dash-BEGIN and dash-END lines added.</p>

<p>Also, SHA-1 has been broken for collision more than a year; see <a href=""https://shattered.io"" rel=""nofollow noreferrer"">https://shattered.io</a> and the numerous Qs on cryptography.SX and security.SX about this. Even before that it was prohibited for signatures by numerous authorities since 2014 or 2015, including NIST (for the US government) and CABforum (for public web certificates). I don't know anything about the data you are signing, but if it is in any way important or valuable, and you have the option to use a better hash in your signature(s), you should.</p>

<p>ADDED: also I asume you realize that <code>sun.*</code> classes are not documented, not guaranteed, and may stop working anytime Oracle feels like it.</p>
","190","<java><digital-signature><pkcs#7>","0","0","1","2018-10-17 05:55:12","","0","","","","","2018-10-15 20:31:25",""
"44271033","Node.js safari push notifications intermittent signature failure","<p>I am using the <a href=""https://www.npmjs.com/package/safari-push-notifications"" rel=""nofollow noreferrer"">safari-push-notifications v 0.3.0</a> module to create the push package required for Safari. Occasionally I get the error <code>Signature verification of push package failed</code> from Safari.</p>

<p>I noticed in the failed signatures there are some garbled/invalid characters. I tried taking these out and using the signature, but it still fails.</p>

<p>My cert, key, intermediate, and manifest are the same each time.</p>

<p>Most of the time the signature works just fine, but once in a while it fails.</p>

<p>Has anybody else experienced this and know a way to fix it?</p>
","<p>I had opened an issue in the github repo for this problem as well, and the owner pushed a fix. If you are experiencing this problem, just upgrade to version 0.3.1 or higher.</p>
","188","<node.js><signature><pkcs#7><safari-push-notifications>","3","0","1","2017-06-02 01:39:12","44319551","0","","6952289","","2017-05-31 14:34:50","2017-05-30 20:08:36",""
"24055416","How to export a *.p7b cert from *.pfx file","<p>MSDN said:
X509Certificate.Export
The contentType parameter accepts only the following values of the X509ContentType enumeration: Cert, SerializedCert, and Pkcs12. Passing any other value causes a CryptographicException to be thrown.
<a href=""http://msdn.microsoft.com/en-us/library/dxz81eb9%28v=vs.110%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/dxz81eb9(v=vs.110).aspx</a></p>

<p>Is there any other methods?</p>

<p>Thanks in advance!</p>
","<p>Recently, I understand what .p7b format is.</p>

<pre><code>static void ExportCert()
{
        X509Certificate2 x509 = new X509Certificate2(@""E:\SimonSelf.pfx"", ""password"", X509KeyStorageFlags.Exportable);

        X509Certificate2Collection x509List = new X509Certificate2Collection(x509);
        byte[] p7bBinary = x509List.Export(X509ContentType.Pkcs7);
        using (FileStream fs = new FileStream(@""E:\SimonSelf.p7b"", FileMode.Create))
        {
            fs.Write(p7bBinary, 0, p7bBinary.Length);
            fs.Close();
        }
}
</code></pre>
","186","<windows-phone-8><certificate><pkcs#7>","0","0","1","2014-06-06 08:02:21","","0","","2476700","","2014-06-06 01:09:24","2014-06-05 08:38:04",""
"18382270","How can I sign a text by certificate in SQL Server and provide PKCS#7 signature?","<p>In my app i need to implement digital signature of some text, extracted from DB data (customer bill, for example), to send a text by e-mail together with it's signature in PKCS#7 format. Both because of high load and data volumes, and a fact that an e-mail app is provided by external developers, it's highly desired to include a text signature in SQL Server resultset, which returns all the data (e-mail attachments) to e-mail app.</p>

<p>The problem is that SQL Server uses x509 v.3 certificate format. It is not a problem while importing certificate and a key - I can convert it to x509 v.3 using OpenSSL before import, it's a one-time deal. But is there a way to convert a SQL Server signature to PKCS#7 format inside SQL Server, or do I have to implement a signing process outside of it?</p>
","","185","<sql><sql-server><certificate><digital-signature><pkcs#7>","0","","0","2015-06-18 16:09:39","","2","","1816580","","2015-06-18 16:09:39","2013-08-22 13:45:43",""
"35124071","PKCS7 Padding in JavaCard","<p>I am trying to implement my own PKCS7 padding scheme in JavaCard environment in case a smart card does not support PKCS5 or 7 padding schemes.</p>

<p>I want the block size of the PKCS padding scheme to be flexible in the event that different block size of symmetric ciphers are used. The <code>length</code> indicates the message input length and the <code>blocksize</code> indicates the size of a cipher's block.</p>

<p>My algorithm would check two scenarios in the PKCS7 padding namely if all bytes are the same bytes (e.g. <code>0A, 0A, 0A .. 0A, 0A, 0A</code>) which means there is no padding involved and would return a value <code>0</code>.</p>

<p>The second scenario is the checking if there is padding (e.g. <code>0A, 0B, 0C, 05, 05, 05, 05, 05</code>).</p>

<p>I am able to check all the scenarios successfully but when it comes to copying the data to output the result, it doesn't seem to copy correctly.</p>

<p>It seems like the <code>arrayFillGenericNonAtomic()</code> data that was filled before the <code>arrayCopyRepackNonAtomic()</code> is called is still stuck in the output byte array and doing the <code>arrayCopyRepackNonAtomic()</code> is not copying the data properly.</p>

<p>The output byte array format I am using is for the first element in the array to carry the indicator (in byte representation) of the amount of data that has been processed for output (e.g. <code>output[outputOffset] = (byte) 0x10</code> means 16 data element afterwards that has been processed). Subsequent data elements in the output byte array after the first element contains the processed data.</p>

<p>An example of the problem is I am trying to PKCS7 decode <code>A0, B0, C0, D0, E0, 04, 04, 04, 04</code> and the outcome should be <code>05, A0, B0, C0, D0, E0</code> (where the 05 represents following 5 bytes are processed) but I am getting <code>05, 04, 04, 04, 04 ..</code> instead.</p>

<p>How do I fix the problem of the <code>arrayCopyRepackNonAtomic()</code> not working as expected ?</p>

<p>I am testing the code on an actual JavaCard 2.2.2 and JavaCard 3.0.4 compatible smart card that is in OP_READY mode.</p>

<pre><code>public static void process(byte[] input, short offset, short length,
        short blockSize, byte[] output, short outputOffset, short mode) {
    if (mode == MODE_DECODE) {
        // Data length must be &gt;= blocksize and have to have be a modulus of 0 size.
        if ((length &gt;= blockSize) &amp;&amp; ((length % blockSize) == 0)) {
            output[outputOffset] = (byte) length;
            ArrayLogic.arrayFillGenericNonAtomic(output, (short) (outputOffset + 1), (short) (length - 1), output, outputOffset);
            if (ArrayLogic.arrayCompareGeneric(input, offset, output, outputOffset, length) == 0x00) {
                // If all bytes are the same, return 0.
                output[outputOffset] = (byte) 0x00;
            } else {
                // Bytes are not all the same, check if the last segment of bytes are padded.
                if (ArrayLogic.arrayCompareGeneric(input, offset, output, outputOffset, (short) (input[(short) (offset + length - 1)] &amp; 0xFF)) == 0x00) {
                    // Padded bytes are found.
                    output[outputOffset] = (byte) (length - input[(short) (offset + length - 1)]);
                    // Unable to copy correctly to output
                    ArrayLogic.arrayCopyRepackNonAtomic(input, offset, (short) (output[outputOffset] &amp; 0xFF), output, (short) (outputOffset + 1)); 
                } else {
                    output[outputOffset] = (byte) length;
                    // Unable to copy correctly to output
                    ArrayLogic.arrayCopyRepackNonAtomic(input, offset, length, output, (short) (outputOffset + 1));
                }
            }
        }
    }
}
</code></pre>

<p>The question have been solved and the problems are wrong variable offsets and also handling of byte to short conversions that caused the problem.</p>

<p>Below is a working version that seems to does the padding after some testing for those interested in using it in the future.</p>

<pre><code>public static void process(byte[] input, short offset, short length,
        short blockSize, byte[] workBuff, short buffOffset, byte[] output,
        short outputOffset, short mode) {
    if (mode == MODE_DECODE) {
        // Data length must be &gt;= blocksize and have to have be a modulus of 0 size.
        if ((length &gt;= blockSize) &amp;&amp; ((length % blockSize) == 0)) {
            workBuff[buffOffset] = (byte) input[(short) (length + offset - 1)];
            ArrayLogic.arrayFillGenericNonAtomic(workBuff, buffOffset, length, workBuff, buffOffset);
            if (ArrayLogic.arrayCompareGeneric(input, offset, workBuff, buffOffset, length) == 0x00) {
                // If all bytes are the same, return 0.
                output[outputOffset] = (byte) 0x00;
            } else {
                output[outputOffset] = (byte) (offset + length - (workBuff[buffOffset] &amp; 0xFF));
                output[(short) (outputOffset + 1)] = workBuff[buffOffset];
                // Bytes are not all the same, check if the last segment of bytes are padded.
                if (ArrayLogic.arrayCompareGeneric(input, (short) (offset + length - (workBuff[buffOffset] &amp; 0xFF)), workBuff, buffOffset, (short) (workBuff[buffOffset] &amp; 0xFF)) == 0x00) {
                    // Padded bytes are found.
                    output[outputOffset] = (byte) (length - input[(short) (offset + length - 1)]);
                    ArrayLogic.arrayCopyRepackNonAtomic(input, offset, (short) output[outputOffset], output, (short) (outputOffset + 1));
                } else {
                    // Padded bytes are not found.
                    output[outputOffset] = (byte) length;
                    ArrayLogic.arrayCopyRepackNonAtomic(input, offset, length, output, (short) (outputOffset + 1));
                }
            }
        }
    }
}
</code></pre>
","<p>Hmm, I don't think thats the only mistake, but your branch is definitly wrong:</p>

<pre><code>// Bytes are not all the same, check if the last segment of bytes are padded.
if (ArrayLogic.arrayCompareGeneric(input, offset, output, outputOffset, (short) (input[(short) (offset + length - 1)] &amp; 0xFF)) == 0x00) {
</code></pre>

<p>You are comparing the right length, but the wrong offsets.</p>

<p>I'm not understanding what the else-case should do in your method. Should throw an error if the padding was wrong?</p>
","170","<padding><smartcard><javacard><pkcs#7>","0","1","1","2016-02-05 03:57:01","35127239","3","1","476467","","2016-02-05 03:57:01","2016-02-01 06:16:14",""
"40187733","Calculate message digest for TSA for CMS_sign prior to CMS_final","<p>I have code to create CMS signature. It worked well now I need to add trusted timestamping.</p>

<pre><code>BIO *data_output = BIO_new(BIO_s_mem());
const EVP_MD *sign_md = EVP_get_digestbyname(digest_name);

cms = CMS_sign(NULL, NULL, NULL, bio_in, flags);
BOOST_ASSERT(cms);

for (size_t i = 0; i &lt; m_signers.size(); i++) {
    int tflags = flags;

    SignerInfo si = m_signers[i];

    CMS_SignerInfo *signer_info = CMS_add1_signer(cms,
        si.m_x509, si.m_privateKey, sign_md, tflags);
    BOOST_ASSERT(signer_info != NULL);

    for (int c = 0; c &lt; sk_X509_num(si.m_ca); c++) {
        X509* cert = sk_X509_value(si.m_ca, c);
        BOOST_ASSERT(CMS_add0_cert(cms, cert) != 0);
    }
}

BOOST_ASSERT(CMS_final(cms, bio_in, NULL, flags) != 0);
BOOST_ASSERT(i2d_CMS_bio_stream(data_output, cms, bio_in, flags) != 0);
</code></pre>

<p>In order to talk to TSA, I need the digest value but there is no way to get the digest value until CMS_final is called. I could not locate the answer anywhere.</p>
","<p>id-aa-timeStampToken is an unsigned attribute. If your implementation has no hooks to modify the message afterwards you can do it in two passes. Do call final, get the hash and send it to the TSA. Then build a second identical CMS and add an unsigned id-aa-timeStampToken attibute (OID 1.2.840.113549.1.9.16.2.14). Paste the timestampToken in there and call final.</p>

<p>Be aware that using a timestamp usually requires a SIGNED attribute signing-time Pkcs9SigningTime (OID 1.2.840.113549.1.9.5) so save the time used on the first pass to get two identical CMS messages.</p>

<p>It is a bit cheap but it does the job. If you neeed to ask for a pin on a Smart card it will ask two times. </p>
","163","<security><openssl><signing><pki><pkcs#7>","2","0","1","2019-02-12 15:28:02","","1","2","608639","","2016-10-22 16:38:16","2016-10-22 02:27:03",""
"55827612","How to remove validity unknown icon from signature field using itextsharp C#?","<p>How to remove validity unknown icon(question mark) from signature field before calculating the hash of pdf. </p>

<p>Below code that I am using to create signature field.</p>

<pre><code>PdfStamper stamper = PdfStamper.CreateSignature(reader, os, '\0');
PdfSignatureAppearance appearance = stamper.SignatureAppearance;
appearance.SignDate = DateTime.Now.AddMinutes(15);
appearance.Reason = reasonForSign;
appearance.Contact = """";
appearance.Location = locationToShowOnSignatureStamp;
appearance.Acro6Layers = false;
appearance.Image = null;
appearance.SignatureRenderingMode = PdfSignatureAppearance.RenderingMode.DESCRIPTION;
appearance.CertificationLevel = PdfSignatureAppearance.NOT_CERTIFIED;
appearance.SetVisibleSignature(new iTextSharp.text.Rectangle(10, 10, 149, 69), reader.NumberOfPages, ""s1"");
</code></pre>

<p><a href=""https://i.stack.imgur.com/CiG9l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CiG9l.png"" alt=""""></a></p>
","<p>Your code explicitly requests that icon: you use</p>

<pre><code>appearance.Acro6Layers = false;
</code></pre>

<p>This instructs itext to create signature appearances as Adobe Acrobat up to version 5 did. This includes ""layers"" for signatures with positive, inconclusive, or negative validation results. If you use</p>

<pre><code>appearance.Acro6Layers = true;
</code></pre>

<p>instead (which is the default), itext creates signatures for which Adobe Acrobat won't show such on-page visualizations of the validation result anymore. </p>
","162","<c#><itext><digital-signature><acrobat><pkcs#7>","0","1","1","2019-04-24 11:08:24","55828557","0","","1729265","","2019-04-24 11:08:24","2019-04-24 10:13:08",""
"16672801","Error Initializing OpenSSL module in perl","<p>Hi I am a newbie to perl. How to create a pkcs7 signature in perl .Any Example code would be helpful. I tried to use OpenCA::OpenSSL. I got error initializing OpenCA::OpenSSL instance.
Thanks in Advance.......
  My code</p>

<pre><code>$openssl = OpenCA::OpenSSL-&gt;new(path=&gt;'/usr/bin/openssl');
my $crl=$openssl-&gt;issueCrl(
       CAKEY=&gt;'passbook/key.pem',
       CACERT=&gt;'passbook/certificate.pem',
       PASSWD=&gt;'somepass',
       OUTFILE=&gt;'passbook/signature',
       OUTFORM=&gt;'DER',
);
</code></pre>

<p>The error message i got was </p>

<pre><code>Use of uninitialized value $initial_skip in concatenation (.) or string at
/usr/local/share/perl/5.14.2/Parse/RecDescent.pm line 3054.""
</code></pre>
","","153","<perl><encryption><openssl><perl-module><pkcs#7>","1","","0","2013-05-21 15:19:34","","0","","2045980","","2013-05-21 15:19:34","2013-05-21 14:41:11",""
"47828731","CMS_verify fails if signature issuer differs from certificate issuer","<p>When trying to verify a signed data structure using</p>

<pre><code>openssl smime -verify -in EF_SOD.PEM -inform pem -noverify
</code></pre>

<p>I get this error:</p>

<pre><code>Verification failure
10280:error:2107C080:PKCS7 routines:PKCS7_get0_signers:signer certificate not found:pk7_smime.c:378:
</code></pre>

<p>It seems that the identity of the signature issuer is not literally the same as the identity of the embedded certificate issuer.</p>

<p>These are the two issuers:</p>

<pre><code>issuer: CN=CSCAEC_BE_3, OU=FEDERAL PUBLIC SERVICE FOREIGN AFFAIRS BELGIUM, O=KINGDOM OF BELGIUM, C=BE
issuer: C=BE, O=KINGDOM OF BELGIUM, OU=FEDERAL PUBLIC SERVICE FOREIGN AFFAIRS BELGIUM, CN=CSCAEC_BE_3
</code></pre>

<p>According to RFC 5280, the two names have have the exact same attributes in the exact same order.
Does this mean the data structure is corrupt?</p>

<p>Originally, I want to use <code>CMS_verify</code> in code to do the verification:</p>

<pre><code>nRet = CMS_verify(pCMS, certs, NULL, NULL, NULL, CMS_NO_SIGNER_CERT_VERIFY);
</code></pre>

<p>Is there a way to parametrise the function so that it will be successful?</p>

<p>Thank you!</p>
","","153","<security><openssl><pkcs#7>","0","","0","2017-12-15 15:25:19","","2","","608639","","2017-12-15 15:25:19","2017-12-15 08:49:22",""
"53205272","How to get algorithm field from signed PE PKCS#7 block","<p>I've got <code>PKCS#7</code> content extracted from PE file. </p>

<p>The first part before the certificate chain (goes from the beginning up to the <code>cert:</code> label), contains info about the file integrity.</p>

<p>In particular, the hash that matches the file hash and the algorithm that use to generate this hash (worth <code>FA0FE65F973A5709DC04EE18ABEF353EBEFEA669</code> and <code>sha1</code> correspondingly on the example listed below). </p>

<p>I'm using <code>openssl</code> and I'd like to extract the hash algorithm type from the <code>X509</code> format. I tried something like printing md_algs struct from debugger, and hopefully find the field <code>algorithm</code> worth <code>1.3.14.3.2.26</code> but that's what I saw.. </p>

<pre><code>p *(Pkcs7-&gt;d.sign-&gt;md_algs)
(stack_st_X509_ALGOR) $6 = {
  stack = {
     num = 1
     data = 0x00000001024457f0
     sorted = 0
     num_alloc = 4
     comp = 0x0000000000000000
  }
}
</code></pre>

<p>Where can I see the algorithm field ? </p>

<p>P.s. here's the relevant part of the pkcs7 struct : </p>

<pre><code>PKCS7: 
   type: pkcs7-signedData (1.2.840.113549.1.7.2)
   d.sign: 
     version: 1
     md_algs:
       algorithm: sha1 (1.3.14.3.2.26)
       parameter: NULL
     contents: 
       type: undefined (1.3.6.1.4.1.311.2.1.4)
     d.other: SEQUENCE:
        0:d=0  hl=2 l=  60 cons: SEQUENCE          
        2:d=1  hl=2 l=  23 cons:  SEQUENCE          
        4:d=2  hl=2 l=  10 prim:   OBJECT            :1.3.6.1.4.1.311.2.1.15
       16:d=2  hl=2 l=   9 cons:   SEQUENCE          
       18:d=3  hl=2 l=   1 prim:    BIT STRING        
       21:d=3  hl=2 l=   4 cons:    cont [ 0 ]        
       23:d=4  hl=2 l=   2 cons:     cont [ 2 ]        
       25:d=5  hl=2 l=   0 prim:      cont [ 0 ]        
       27:d=1  hl=2 l=  33 cons:  SEQUENCE          
       29:d=2  hl=2 l=   9 cons:   SEQUENCE          
       31:d=3  hl=2 l=   5 prim:    OBJECT            :sha1
       38:d=3  hl=2 l=   0 prim:    NULL              
       40:d=2  hl=2 l=  20 prim:   OCTET STRING      [HEX DUMP]:FA0FE65F973A5709DC04EE18ABEF353EBEFEA669
     cert:
      cert_info: 
      ...
</code></pre>

<p>thanks </p>
","<p>Defined in <a href=""https://github.com/openssl/openssl/blob/OpenSSL_1_1_1/include/openssl/pkcs7.h#L61"" rel=""nofollow noreferrer""><code>pkcs7.h</code></a>, the <code>md_algs</code> attribute that you are inspecting is a stack of <code>X509_ALGOR</code> instances:</p>

<pre><code>typedef struct pkcs7_signed_st {
    ASN1_INTEGER *version;      /* version 1 */
    STACK_OF(X509_ALGOR) *md_algs; /* md used */
    STACK_OF(X509) *cert;       /* [ 0 ] */
    STACK_OF(X509_CRL) *crl;    /* [ 1 ] */
    STACK_OF(PKCS7_SIGNER_INFO) *signer_info;
    struct pkcs7_st *contents;
} PKCS7_SIGNED;
</code></pre>

<p>It can be safely accessed via the <a href=""https://wiki.openssl.org/index.php/STACK_API"" rel=""nofollow noreferrer"">OpenSSL Stack API</a>, for example using the function <code>sk_X509_ALGOR_value()</code> to inspect its element(s).</p>

<p><code>X509_ALGOR</code> itself is defined in <a href=""https://github.com/openssl/openssl/blob/OpenSSL_1_1_1/include/openssl/x509.h#L59"" rel=""nofollow noreferrer""><code>x509.h</code></a>:</p>

<pre><code>struct X509_algor_st {
    ASN1_OBJECT *algorithm;
    ASN1_TYPE *parameter;
} /* X509_ALGOR */ ;
</code></pre>

<p>The information you are looking for is stored in the property <code>algorithm</code>, which you can inspect using, for example, <a href=""https://www.openssl.org/docs/man1.1.0/crypto/OBJ_obj2txt.html"" rel=""nofollow noreferrer""><code>OBJ_obj2txt()</code></a>.</p>

<p>Tying it together, to get a textual representation of the first algorithm in the stack, you could do something like this:</p>

<pre><code>char tbuf[20];
X509_ALGOR *algor = sk_X509_ALGOR_value(Pkcs7-&gt;d.sign-&gt;md_algs, 0);
int res = OBJ_obj2txt(tbuf, sizeof tbuf, algor-&gt;algorithm, 0);
</code></pre>

<p>After that, <code>tbuf</code> should contain a value like <code>""sha1""</code> and <code>res</code> contains the length of that string. For programmatic purposes, a function like <code>OBJ_obj2nid()</code> is probably more useful.</p>

<hr>

<p>The debugger did not give you this information because the <code>data</code> field in the <code>stack</code> element is not strongly typed. You would have to cast it yourself to indicate that it is an array of pointers to <code>X509_ALGOR</code> structs. The OpenSSL Stack API provides you a set of macros that do the casting for you and access the array that way. And then, the <code>ASN1_OBJECT</code> that you end up with is hard to inspect or interpret in the debugger since it is just a bunch of bytes representing an object id in <code>ASN.1</code> format.</p>
","152","<encryption><openssl><sha><pkcs#7><asn1>","1","3","1","2018-11-08 19:18:23","53212465","0","","","","","2018-11-08 09:56:13",""
"18182604","DES Algorithm Identifier","<p>Can somebody please give me an authoritative reference that <strong>1.3.14.3.2.7</strong> is the DES algorithm identifier used in S/MIME? I figured the number by sending a DES encrypted email and viewing the P7M file of the email.</p>
","<p>The <a href=""http://www.oid-info.com/cgi-bin/display?oid=1.3.14.3.2.7&amp;action=display"" rel=""nofollow"">OID repository has it here</a>. It parses it as:</p>

<p><strong>{ iso(1) identified-organization(3) oiw(14) secsig(3) algorithm(2) }</strong></p>

<p>and it oddly describes it as <em>""Voice encryption using DES (56 bit) in CBC mode and 512-bit DH-group""</em>.</p>

<p>For the record, <strong>oiw</strong> stands for the OSI Implementor's Working Group.</p>
","141","<des><pkcs#7><smime>","0","0","2","2013-08-15 04:49:10","18246504","0","","","","","2013-08-12 08:34:41",""
"18182604","DES Algorithm Identifier","<p>Can somebody please give me an authoritative reference that <strong>1.3.14.3.2.7</strong> is the DES algorithm identifier used in S/MIME? I figured the number by sending a DES encrypted email and viewing the P7M file of the email.</p>
","<p>This list of OIDs <a href=""http://www.imc.org/ietf-smime/other-smime-oids.asn"" rel=""nofollow"">OIDs Used with S/MIME</a> is maintained by the Internet Mail Consortium and it is referenced in RFC 2633 p. 7. It clearly mentions that the OID for the DES algorithm in CBC mode is <strong>1.3.14.3.2.7</strong>.</p>
","141","<des><pkcs#7><smime>","0","0","2","2013-08-15 04:49:10","18246504","0","","","","","2013-08-12 08:34:41",""
"47884939","How to create a CMS signature using a Luna SA (HSM)","<p>I am trying to create a CMS signature from a Luna SA (HSM) from C# in order to create an x-pkcs7 s/mime message.</p>

<p>What singing mechanism should I be using?</p>

<p>Regards</p>
","","135","<c#><signing><pkcs#7>","3","","0","2017-12-19 10:52:53","","0","","98579","","2017-12-19 10:52:53","2017-12-19 10:31:29",""
"47061020","Extract ICP-Brasil information from pkcs7 file","<p>Just Sharing my code:</p>

<p>Sorry for poor error treatment.</p>

<p>I have spend some time to get here. Its amazing that is easier to find certificate layout documentation in <em>Receita Federal do Brasil</em> then the ITI itself.
Older certificates have different layouts. I will invest a little time searching for more documentation.</p>

<p>If someone have the oficial documentation, please share too.</p>

<pre><code>         public static List&lt;Certificado&gt; ListarSignatariosArquivo(byte[] arquivo)
    {
        /* http://www.receita.fazenda.gov.br/acsrf/LeiautedeCertificadosdaSRF.pdf
         * 2.2.5. Subject Alternative Name
         *   Campos Obrigat√≥rios
         *      OID = 2.16.76.1.3.1 com o seguinte conte√∫do:
         *           Nas primeiras 8 (oito) posi√ß√µes, a data de nascimento da pessoa f√≠sica titular do certificado, no formato ddmmaaaa; 
         *           nas 11 (onze) posi√ß√µes subseq√ºentes, o n√∫mero de inscri√ß√£o no Cadastro de Pessoa F√≠sica (CPF) da pessoa f√≠sica titular do certificado;
         *           nas 11 (onze) posi√ß√µes subseq√ºentes, o n√∫mero de Identifica√ß√£o Social da pessoa f√≠sica titular do certificado - NIS (PIS, PASEP ou CI);
         *           nas 15 (quinze) posi√ß√µes subseq√ºentes, o n√∫mero do Registro Geral - RG da pessoa f√≠sica titular do certificado; 
         *           nas 6 (seis) posi√ß√µes subseq√ºentes, as siglas do √≥rg√£o expedidor do RG e respectiva UF.
         *
         *       OID = 2.16.76.1.3.5 com o seguinte conte√∫do:
         *           Nas primeiras 12 (onze) posi√ß√µes, o n√∫mero de inscri√ß√£o do T√≠tulo de Eleitor da pessoa f√≠sica titular do certificado;
         *           nas 3 (tr√™s) posi√ß√µes subseq√ºentes, o n√∫mero correspondente a Zona Eleitoral;
         *           nas 4 (quatro) posi√ß√µes seguintes, o n√∫mero correspondente a Se√ß√£o;
         *           nas 22 (vinte e duas) posi√ß√µes subseq√ºentes, o nome do munic√≠pio e a UF do T√≠tulo de Eleitor.
         *
         *       OID = 2.16.76.1.3.6 com o seguinte conte√∫do:
         *           Nas 12 (doze) posi√ß√µes, o n√∫mero do Cadastro Especifico do INSS (CEI) da pessoa f√≠sica titular do certificado.
         *
         *   Campos Opcionais
         *       OID = 2.16.76.1.4.x.y.z com o seguinte conte√∫do:
         *           Tamanho vari√°vel correspondente ao n√∫mero de habilita√ß√£o ou identifica√ß√£o profissional emitido por conselho de classe ou √≥rg√£o competente.
         *           A AC Raiz, por meio do documento ATRIBUI√á√ÉO DE OID DA ICP-BRASIL (DOC ICP-04-01) regulamentar√° a correspond√™ncia de cada conselho de classe
         *           ou √≥rg√£o competente ao conjunto de OID acima definido.
         *
         *       OID = 1.3.6.1.4.1.311.20.2.3 com o seguinte conte√∫do:
         *           Este campo Principal Name cont√©m a Identifica√ß√£o do endere√ßo de login do titular do certificado no diret√≥rio Active Direct (AD) Microsoft.
         *           O conjunto de informa√ß√µes definido em cada campo OtherName deve ser armazenado como uma cadeia de caracteres do tipo ASN.1 OCTET STRING,
         *           com exce√ß√£o do campo Principal Name cuja cadeia de caracteres √© do tipo UTF-8 String.
         *
         *   Os seguintes campos s√£o de preenchimento obrigat√≥rio:
         *   - Nome;
         *   - CPF;
         *   - Data de nascimento; e
         *   - Email. 
         */


        CmsSignedData signedData = null;
        List&lt;Certificado&gt; listaCpf = new List&lt;Certificado&gt;();
        try
        {
            signedData = new CmsSignedData(arquivo);
        }
        catch (CmsException)
        {
            return listaCpf;
        }
        catch (Exception e)
        {
            throw new IntegridadeArquivoException(""Arquivo corrompido."", e);
        }

        if (signedData != null)
        {
            IX509Store store = signedData.GetCertificates(""Collection/Certificate"");


            SignerInformationStore signers = signedData.GetSignerInfos();

            foreach (var it in signers.GetSigners())
            {
                SignerInformation signer = (SignerInformation)it;

                foreach (var certificado in store.GetMatches(signer.SignerID))
                {

                    X509Certificate x509cert = (X509Certificate)certificado;

                    IList tmp;
                    tmp = x509cert.SubjectDN.GetValueList(X509Name.CN);
                    string nome = tmp.Count &gt; 0 ? tmp[0].ToString() : """";
                    tmp = x509cert.IssuerDN.GetValueList(X509Name.CN);
                    string autoridadeCertificadora = tmp.Count &gt; 0 ? tmp[0].ToString() : """";
                    DateTime dtValidadeCertificado = x509cert.NotAfter;



                    Nullable&lt;DateTime&gt; dtNascimento = null;
                    string cpf = null;
                    string rg = null;
                    string orgaoExpedidorRg = null;

                    string pessoaFisicaOid = ""2.16.76.1.3.1"";
                    foreach (ArrayList a in x509cert.GetSubjectAlternativeNames())
                    {

                        string conteudo = a.ToArray()[1].ToString();
                        Match moid = Regex.Match(conteudo, @""\[[0-9\.]*"");
                        string oid = moid.Success ? moid.Value.Replace(""["", string.Empty) : """";
                        if (pessoaFisicaOid.Equals(oid))
                        {
                            Match mvalor = Regex.Match(conteudo, ""#[0-9a-fA-F]+"");
                            string valor = mvalor.Success ? mvalor.Value.Replace(""#"", string.Empty) : """";
                            //converter string hexadecimal em string decimal.
                            valor = FromHexToString(valor);

                            int i = 0;
                            dtNascimento = DateTime.ParseExact(valor.Substring(i, 8),""ddMMyyyy"", CultureInfo.InvariantCulture);
                            i += 8;
                            cpf = valor.Substring(i, 11);
                            i += 22;
                            rg = valor.Substring(i, 15);
                            i += 15;
                            orgaoExpedidorRg = valor.Substring(i, 6);
                        }
                    }


                    listaCpf.Add(new Certificado {
                        Nome = nome,
                        DtNascimento = dtNascimento,
                        AutoridadeCertificadora = autoridadeCertificadora,
                        DtValidadeCertificado = dtValidadeCertificado,
                        Cpf = cpf,
                        Rg = rg,
                        OrgaoExpedidorRg = orgaoExpedidorRg
                    });
                }
            }

        }
        return listaCpf;
    }
    public static string FromHexToString(string hex)
    {
        byte[] raw = new byte[hex.Length / 2];
        for (int i = 0; i &lt; raw.Length; i++)
        {
            raw[i] = Convert.ToByte(hex.Substring(i * 2, 2), 16);
        }
        return Encoding.ASCII.GetString(raw);
    }
</code></pre>
","","134","<c#><bouncycastle><pkcs#7>","0","","0","2017-11-01 18:01:27","","2","","","","","2017-11-01 18:01:27",""
"53851135","How to verify pkcs7 signature using public key","<p>I am very new to using certificates and signatures, I have got public key, form a certificate given to me by my client, they also gave me with a sample soap xml containing signature tab, which starts with ----begin pkcs7---- and ends with -----end pkcs7--- in between there is like encoded string signature. How should i verify  the signature using java? </p>
","","128","<certificate><digital-signature><bouncycastle><signature><pkcs#7>","0","","0","2018-12-19 12:18:32","","0","0","","","","2018-12-19 12:18:32",""
"39214891","Obtaining PKCS7 data length with OpenSSL","<p>I have some PKCS7 data which I can read like this with OpenSSL:</p>

<pre><code>$ openssl asn1parse -i -inform der -in data.dat
0:d=0  hl=4 l=16208 cons: SEQUENCE
4:d=1  hl=2 l=    9 prim:  OBJECT            :pkcs7-signedData
.. more ..
</code></pre>

<p>I can load it in code like so:</p>

<pre><code>// buf contains the raw data, len the length
BIO *bio = BIO_new_mem_buf(buf, len);

PKCS7 *pkcs7 = d2i_PKCS7_bio(bio, NULL);
if (!pkcs7) {
    // die
}
printf(""Success!"");
</code></pre>

<p>This works fine and I can successfully obtain signer information etc.  However I'd like to obtain the length value as parsed from the input data.  In my example this was 16208, seen in the second line of the ASN1 output.</p>

<p>I noticed there is a <code>length</code> attribute to the PKCS7 structure (see <code>include/openssl/pkcs7.h</code>) but <code>pkcs7-&gt;length</code> is always zero when I print it.</p>

<p>How can I obtain the length of the overall sequence which contains PKCS7 signed data?</p>
","","122","<c><openssl><pkcs#7>","1","","0","2016-08-29 20:44:20","","0","","","","","2016-08-29 20:44:20",""
"55682084","Creating PaDES signature","<p>I am trying to create a PaDES signature using the following workflow:</p>

<ul>
<li>PDF is prepared for signing and hash is calculated in the browser</li>
<li>hash is sent to the backend</li>
<li>detached CaDES signature is formed on the backend</li>
<li>detached CaDES is sent back to the browser where PaDES signature is assembled</li>
</ul>

<p>We have a working example of PDF signature that works like this:</p>

<ul>
<li>PDF is prepared and hash is calculated in the browser</li>
<li>hash is sent to the backend</li>
<li>detached PKCS7 signature is made on the backend (by using BouncyCastle lib)</li>
<li>detached PKCS7 is sent back to the browsere where PDF signature is assembled</li>
</ul>

<p>This is working fine.</p>

<p>However, now instead of BouncyCastle we are using <a href=""https://github.com/esig/dss"" rel=""nofollow noreferrer"">DSS</a> library on the backend because we are trying to create a PaDES signature. So, DSS lib is creating detached CaDES (which should be the same as detached PaDES) instead of PKCS7. However, when the signature is assembled in the browser the signature is invalid (even the certificate info isn't visible).</p>

<p>From my understanding CaDES is an extension to PKCS7 so this approach should work. </p>

<p>I'm first trying to understand if something's wrong with our approach and if not, I'll try to share the code we're using to make a detached CaDES signature to see if something's wrong there.</p>
","<p>I figured it out. It was that the size of detached CaDES signature is more than 2 times bigger then detached PKCS7 signature, so we weren't leaving enough space for the signature to fit in, so the signature was basically overwritting the PDF content. When I increased the space for the signature everything is working as it should</p>
","120","<pdf><digital-signature><pkcs#7><pades>","0","0","1","2019-04-15 03:37:34","55682291","0","","","","","2019-04-15 03:02:09",""
"54691889","Attach PKCS7 Signed data to pdf","<p>using this link <a href=""https://stackoverflow.com/questions/29210451/itext-generating-pdf-hash-without-certificate-chain#"">iText - Generating PDF hash without certificate chain</a>
I tried creating pdf with an empty signature appearance and also calculated hash using <code>PdfSignature.getRangeStream()</code>.I also managed to get this hash signed using bouncycastle.</p>

<p>This answer doesn't explains briefly how signing is performed, please explain if possible as when using this code I have attached signed data to pdf but the signatures are not getting validated properly. </p>

<p>Error is:
Document is altered or corrupted or altered since the signatures are applied.
At least one signature is invalid..</p>
","","118","<pdf><signed><pkcs#7>","0","","0","2019-02-14 14:45:36","","0","","506147","","2019-02-14 14:45:36","2019-02-14 13:45:13",""
"55879757","How to fix Openssl SMIME error :ASN1_get_object:header too long?","<p>I have a .p7s file, that is a PDF signed, which is now broken and i can't open it. When trying to convert it back to PDF i am having issues.</p>

<p>I have tried this repair tool <a href=""https://www.pdf-online.com/osa/repair.aspx"" rel=""nofollow noreferrer"">https://www.pdf-online.com/osa/repair.aspx</a> and it was able to give me a PDF, but it looks very bad and i can't read much from it.</p>

<p>I have also tried this command on my Mac:</p>

<pre><code>openssl smime -inform DER -verify -noverify -in ""file.p7s"" -out ""file.pdf""
</code></pre>

<p>But i am receiving this error:</p>

<pre><code>Error reading S/MIME message
140735895516104:error:0D07207B:asn1 encoding routines:ASN1_get_object:header too long:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22.50.2/libressl/crypto/asn1/asn1_lib.c:152:
</code></pre>

<p>Does anybody have an idea of how to properly convert the .p7s back to a .pdf properly or fix the .p7s file so my command above works?</p>
","","115","<pdf><openssl><pkcs#7><smime>","0","","0","2019-04-27 10:48:30","","3","","","","","2019-04-27 10:48:30",""
"46989608","Building a pkcs7 signature in php aleady knowing the signature","<p>My goal is to sign pdf and e-mails on my server, using an USB token on the client side.</p>

<p>So I would like to build a PKCS7 signature in PHP, but the signature will be obtained from the USB token, that's why I can't use openssl pkcs7 implementation.</p>

<p>I have seen something that could be a solution, using Bouncy Castle : <a href=""https://stackoverflow.com/questions/39378249/create-pkcs7-with-presigned-data-using-bouncy-castle"">create PKCS7 with presigned data using bouncy castle</a>, but I'd like not to use an external implementation.</p>

<p>I have searched for a library that could build the pkcs7 from certificate chain and the signature but I haven't found anything.</p>
","","114","<php><digital-signature><pkcs#7>","1","","0","2017-10-28 12:14:04","","0","","","","","2017-10-28 12:14:04",""
"54362589","Create/Convert to CMS/pkcs7 Certificate from Certificate collection and save it as p7b","<p>I'm trying to convert/Create a PKCS7 ""p7b"" Certificate from signed certificate pem + chain using BouncyCastle or .net Cryptography class</p>

<p>I tried to use only BC without success, so I use BC only to read pem certs and then transform it to an X509Certificate2 object. What I'm looking for at the end is a pem string at the end starting with ""-----BEGIN PKCS7-----"" to save it as p7b file
what have I done..</p>

<pre><code>public void DownloadP7bFile(string certId)
    {
        var records = (DataView)myCertDataSource.Select(DataSourceSelectArguments.Empty);
        var selected = Guid.Parse(certId);

        foreach (DataRow row in records.Table.Rows)
        {
            if (!Guid.Parse(row.Field&lt;Guid&gt;(""cert_id"").ToString()).Equals(selected)) continue;

            var filename = row.Field&lt;string&gt;(""cert_fqdn_main"");
            var certContent2 = row.Field&lt;string&gt;(""certHash_certificate"");
            var certissuer = row.Field&lt;string&gt;(""certHash_issuer"");

            DataTable chaincerts = GetChainCertsFromDB(certissuer);

            //### get pem string from DB to BC cert objects
            Org.BouncyCastle.X509.X509Certificate serverCert = CreateCertObjFromPem(certContent2);
            Org.BouncyCastle.X509.X509Certificate interCert = CreateCertObjFromPem(chaincerts.Rows[0].Field&lt;string&gt;(""cacert_pemhash""));
            Org.BouncyCastle.X509.X509Certificate rootCert = CreateCertObjFromPem(chaincerts.Rows[1].Field&lt;string&gt;(""cacert_pemhash""));

            //### transform to X509Certificate2 object
            System.Security.Cryptography.X509Certificates.X509Certificate2 serverCert2 = new System.Security.Cryptography.X509Certificates.X509Certificate2();
            System.Security.Cryptography.X509Certificates.X509Certificate2 interCert2 = new System.Security.Cryptography.X509Certificates.X509Certificate2();
            System.Security.Cryptography.X509Certificates.X509Certificate2 rootCert2 = new System.Security.Cryptography.X509Certificates.X509Certificate2();
            serverCert2.Import(serverCert.GetEncoded());
            interCert2.Import(interCert.GetEncoded());
            rootCert2.Import(rootCert.GetEncoded());

            //### collect all needed certificates
            var collection = new System.Security.Cryptography.X509Certificates.X509Certificate2Collection();
            collection.Add(rootCert2);
            collection.Add(interCert2);
            collection.Add(serverCert2);

            var pkcs7ContentBytes = collection.Export(System.Security.Cryptography.X509Certificates.X509ContentType.Pkcs7);

            //### Test if pkcs7 can be read ###
            System.Security.Cryptography.Pkcs.SignedCms sigcms = new System.Security.Cryptography.Pkcs.SignedCms();
            sigcms.Decode(pkcs7ContentBytes);
            if (sigcms.Certificates.Count &gt; 0)
            {
                Console.WriteLine(""Aussteller: {0}"", sigcms.Certificates[0].IssuerName.Name);
                Console.WriteLine(""G√ºltig bis {0}"", sigcms.Certificates[0].NotAfter);
            }
            var sigvar2 = sigcms.Encode();

            var pkcs7Content = Convert.ToBase64String(pkcs7ContentBytes); //das gute
            var certEncodedBytes = Convert.FromBase64String(pkcs7Content);
            var certContent = Encoding.UTF8.GetString(certEncodedBytes);

            var certContent7 = UTF8Encoding.UTF8.GetString(certEncodedBytes);
            var CertContent8 = Convert.ToBase64String(sigvar2);
            var CertContent8Bytes = Convert.FromBase64String(CertContent8);
            var certfromsig = sigcms.Certificates.Export(System.Security.Cryptography.X509Certificates.X509ContentType.Pkcs7);

            //var pkcs7cert = new System.Security.Cryptography.X509Certificates.X509Certificate2(certEncodedBytes);
            //var pkcs7cert2 = new System.Security.Cryptography.X509Certificates.X509Certificate2(sigvar2);
            //System.Security.Cryptography.Pkcs.EnvelopedCms pkcs7Envelop = new System.Security.Cryptography.Pkcs.EnvelopedCms();

            //File.WriteAllBytes(@"""")

            //string utfString = Encoding.UTF8.GetString(pkcs7ContentBytes, 0, pkcs7ContentBytes.Length);
            var memoryStream = new MemoryStream(certEncodedBytes);
            //var cryptostream = new System.Security.Cryptography.CryptoStream(memoryStream);
            //memoryStream.Write(pkcs7ContentBytes, 0, pkcs7ContentBytes.Length);
            var test31 = memoryStream.ToArray();
            var test32 = memoryStream.Read(certEncodedBytes, 0, certEncodedBytes.Length);

            memoryStream.Flush();
            memoryStream.Close();


            //var test30 = DecoderConverter.ConvertX509ToPkcs7(rootCert, interCert, serverCert);

            PerformFileDownload(filename, ""p7b"", pkcs7Content);

            break;
        }
    }
</code></pre>
","","112","<certificate><bouncycastle><x509certificate2><pkcs#7><p7b>","0","","0","2019-01-25 09:43:43","","5","","","","","2019-01-25 09:43:43",""
"57370663","How to extract PKCS#1 signature from PKCS#7","<p>I know that <code>PKCS#7 = Certificate + Optional raw data + Signature in PKCS#1 format</code> I need to extract PKCS#1 from a PKCS#7 signature how can I do this in C#. Can I use the bouncy castle to do this, Here is my implementation 
ie. to convert PKCS#7 to ASN.1 and to take the last sequence as it is PKCS#1</p>

<pre><code>Asn1InputStream asn1 = new Asn1InputStream(pkcs7Stream);
Asn1Sequence sequence = (Asn1Sequence)asn1.ReadObject().ToAsn1Object();
var sequenceString = sequence.ToString();
var lastCommaIndex = sequenceString.LastIndexOf("","");
var pkcs1HexStr = sequenceString.Substring(lastCommaIndex + 3).Replace(""]"", string.Empty);
</code></pre>

<p>Is there any other eligant way to obtain PKCS#1</p>
","<p>The SignedCms class can do this for you, .NET Core 2.1+ or .NET Framework 4.7.2+:</p>

<pre><code>SignedCms cms = new SignedCms();
cms.Decode(message);
return cms.SignerInfos[0].GetSignature();
</code></pre>

<p>Assuming you want the signature from the first signer, of course. (The GetSignature method is what requires net472+)</p>

<p>Other signers or countersigners would also be available, just through different aspects of the object model.</p>
","110","<c#><bouncycastle><pkcs#7><pkcs#1>","2","1","2","2019-08-08 09:31:13","57383548","3","","2487737","","2019-08-06 07:51:31","2019-08-06 07:07:30",""
"57370663","How to extract PKCS#1 signature from PKCS#7","<p>I know that <code>PKCS#7 = Certificate + Optional raw data + Signature in PKCS#1 format</code> I need to extract PKCS#1 from a PKCS#7 signature how can I do this in C#. Can I use the bouncy castle to do this, Here is my implementation 
ie. to convert PKCS#7 to ASN.1 and to take the last sequence as it is PKCS#1</p>

<pre><code>Asn1InputStream asn1 = new Asn1InputStream(pkcs7Stream);
Asn1Sequence sequence = (Asn1Sequence)asn1.ReadObject().ToAsn1Object();
var sequenceString = sequence.ToString();
var lastCommaIndex = sequenceString.LastIndexOf("","");
var pkcs1HexStr = sequenceString.Substring(lastCommaIndex + 3).Replace(""]"", string.Empty);
</code></pre>

<p>Is there any other eligant way to obtain PKCS#1</p>
","<p>Thanks, @bartonis for the help and guidance</p>

<p>Here is implementation using bouncy castle</p>

<pre><code>public static byte[] GetRaw(byte[] input)
{
    SignerInfo signerInfo = GetSignerInfo(input);
    return signerInfo?.EncryptedDigest?.GetOctets();
}
private static SignerInfo GetSignerInfo(byte[] input)
{
    Asn1InputStream cmsInputStream = new Asn1InputStream(input);
    Asn1Object asn1Object = cmsInputStream.ReadObject();

    Asn1Sequence asn1Sequence = Asn1Sequence.GetInstance(asn1Object);
    SignedData signedData = GetSignedData(asn1Sequence);
    SignerInfo signerInfo = GetSignerInfo(signedData);
    if (signerInfo?.UnauthenticatedAttributes != null)
    {
        signedData = GetSignerInfo(signerInfo);
        signerInfo = GetSignerInfo(signedData);
    }
    return signerInfo;
}
private static SignerInfo GetSignerInfo(SignedData signedData)
{
    Asn1Encodable[] Asn1Encodables = signedData?.SignerInfos?.ToArray();
    if (Asn1Encodables != null)
    {
        if (Asn1Encodables.Length &gt; 0)
        {
            SignerInfo signerInfo = SignerInfo.GetInstance(Asn1Encodables[0]);
            return signerInfo;
        }
    }
    return null;
}
private static SignedData GetSignedData(Asn1Sequence sequence)
{
    var rootContent = ContentInfo.GetInstance(sequence);
    var signedData = SignedData.GetInstance(rootContent.Content);
    return signedData;
}
private static SignedData GetSignerInfo(SignerInfo signerInfo)
{
    Asn1Encodable[] asn1Encodables = signerInfo.UnauthenticatedAttributes.ToArray();
    foreach (var asn1Encodable in asn1Encodables)
    {
        Asn1Sequence sequence = Asn1Sequence.GetInstance(asn1Encodable);
        DerObjectIdentifier OID = (DerObjectIdentifier)sequence[0];
        if (OID.Id == ""1.2.840.113549.1.9.16.2.14"")
        {
            Asn1Sequence newSequence =Asn1Sequence.GetInstance(Asn1Set.GetInstance(sequence[1])[0]);
            SignedData signedData = GetSignedData(newSequence);
            return signedData;
        }
    }
    return null;
}
</code></pre>
","110","<c#><bouncycastle><pkcs#7><pkcs#1>","2","0","2","2019-08-08 09:31:13","57383548","3","","2487737","","2019-08-06 07:51:31","2019-08-06 07:07:30",""
"48474642","how to convert this java pkcs7gen data signing method to javascript?","<p>I am confused with how to convert this java code to javascript this is for signing data. i am confused with what this bouncycastle and i havent found any replacement for this code in javascript nodejs.</p>

<p>It is working fine in java but this process of creating this is to sign my data and the pass it to 3rd party API but my system is in javascript but they have this method of signing the data which i am not able to find the replacement.</p>

<pre><code>package pkcs7gen;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Security;
import java.security.cert.CertStore;
import java.security.cert.Certificate;
import java.security.cert.CollectionCertStoreParameters;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Enumeration;

import org.bouncycastle.cms.CMSProcessableByteArray;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import org.bouncycastle.cms.CMSTypedData;
import org.bouncycastle.util.encoders.Base64;
import org.springframework.stereotype.Service;

@Service
public class Pkcs7gen {


    final String SIGNATUREALGO = ""SHA1withRSA"";

    byte[] signPkcs7(final byte[] content, final CMSSignedDataGenerator generator) throws Exception {

        CMSTypedData cmsdata = new CMSProcessableByteArray(content);
        CMSSignedData signeddata = generator.generate(cmsdata, true);
        return signeddata.getEncoded();
    }

    public static void main(String[] args) {
        try {
            String data = getSignature(args[0]);
            System.out.println(data);
        }
        catch (Exception exc) {
            // TODO: handle exception
        }
    }

    public static String getSignature (String content) throws Exception{

        KeyStore keystore = KeyStore.getInstance(""jks"");
        InputStream input = new FileInputStream(""./keystore.jks"");
        try {
            char[] password= ""password"".toCharArray();
            keystore.load(input, password);
        } catch (IOException e) {
        } finally {


        Enumeration e = keystore.aliases();
        String alias = """";

        if(e!=null)
        {
            while (e.hasMoreElements())
            {
                String  n = (String)e.nextElement();
                if (keystore.isKeyEntry(n))
                {
                    alias = n;
                }
            }
        }
        PrivateKey privateKey=(PrivateKey) keystore.getKey(alias, ""password"".toCharArray());

        X509Certificate myPubCert=(X509Certificate) keystore.getCertificate(alias);
        byte[] dataToSign=content.getBytes();
        CMSSignedDataGenerator sgen = new CMSSignedDataGenerator();
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider ());
        sgen.addSigner(privateKey, myPubCert,CMSSignedDataGenerator.DIGEST_SHA1);
        Certificate[] certChain =keystore.getCertificateChain(alias);
        ArrayList certList = new ArrayList();
        CertStore certs = null;
        for (int i=0; i &lt; certChain.length; i++)
            certList.add(certChain[i]);
        sgen.addCertificatesAndCRLs(CertStore.getInstance(""Collection"", new CollectionCertStoreParameters(certList), ""BC""));
        CMSSignedData csd = sgen.generate(new CMSProcessableByteArray(dataToSign),true, ""BC"");
        byte[] signedData = csd.getEncoded();
        byte[] signedData64 = Base64.encode(signedData);
        return new String(signedData64);
    }

}
}
</code></pre>
","","105","<rsa><sha1><private-key><sign><pkcs#7>","0","","0","2018-01-27 10:03:26","","3","","","","","2018-01-27 10:03:26",""
"51671217","Why ComputeSignature in .Net Framework and .Net Core do different result","<p>I have problem.</p>

<pre><code>        var contentInfo = new ContentInfo(message);
        var signedCms = new SignedCms(contentInfo);
        var cmsSigner = new CmsSigner(certificate);

        signedCms.ComputeSignature(cmsSigner);
        data = signedCms.Encode();
</code></pre>

<p>This code in .Net Framework 4.7 and in .Net Core 2.1 do different result...</p>

<p>My message length is 73 bytes</p>

<p>result in .Net Framework - 1520 bytes</p>

<p>result in .Net Core - 1523 bytes</p>

<p>Why?</p>
","<p>On .NET Framework, if your .exe is targeting 4.7 or older then <code>new CmsSigner(cert)</code> indicates that the signer should use SHA-1 as their digest, at 4.7.1 and higher the default algorithms changed to SHA-2-256.</p>

<p>On .NET Core 2.1 the default is already SHA-2-256.</p>

<p>You can change either of them to whatever digest algorithm you like by setting the <code>DigestAlgorithm</code> property of <code>CmsSigner</code>.  e.g. <code>cmsSigner.DigestAlgorithm = new Oid(""2.16.840.1.101.3.4.2.1"");</code> now makes both of them use SHA-2-256.</p>

<p>Additionally, .NET Framework is encoding the RSA signature algorithm identifier as <code>{ id-rsaEncryption, NULL }</code> and .NET Core is encoding it as <code>{ id-rsaEncryption }</code> (omitting the optional second value).  This part doesn't change the semantic interpretation of the content, but means that when using the same digest algorithm on both, they still won't come out to the same length.</p>

<hr>

<p>The DER encoding of the SHA-2-256 algorithm identifier is two bytes longer than the DER encoding of the SHA-1 identifier (assuming that the parameters value for SHA-2-256 is omitted, and for SHA-1 it is NULL).  This gets written down twice (+4 to core), then the difference in how the RSA signature algorithm identifier is represented makes the .NET Core version 2 bytes smaller (net: +2 to core)</p>

<p>The reason that you see a <em>three</em> byte difference, instead of two, is that some portion of your document structure ends up passing one of the thresholds where the length prefix (which is variable length) needs to gain an extra byte to hold the value.  Those points are the standard ""byte boundaries"" (255 -> 256, 65535 -> 65536, etc) in addition to 127 -> 128. Your SignerInfo block is likely 254 or 255 bytes on your .NET Framework document, and crosses over to 256 or 257 due to the longer identifier value for SHA-2-256.</p>
","105","<.net><.net-core><pkcs#7>","2","4","2","2018-08-07 09:29:16","","0","1","6535399","","2018-08-03 15:36:41","2018-08-03 11:04:32",""
"51671217","Why ComputeSignature in .Net Framework and .Net Core do different result","<p>I have problem.</p>

<pre><code>        var contentInfo = new ContentInfo(message);
        var signedCms = new SignedCms(contentInfo);
        var cmsSigner = new CmsSigner(certificate);

        signedCms.ComputeSignature(cmsSigner);
        data = signedCms.Encode();
</code></pre>

<p>This code in .Net Framework 4.7 and in .Net Core 2.1 do different result...</p>

<p>My message length is 73 bytes</p>

<p>result in .Net Framework - 1520 bytes</p>

<p>result in .Net Core - 1523 bytes</p>

<p>Why?</p>
","<p>I resolve my problem using BouncyCastle.NetCore in method ""ComputeSignature"" (work in Debian 9 with .Net Core 2.0).
Result length is 2537 bytes, but external application working good with this signature.</p>

<pre><code>    public static byte[] ComputeSignature(byte[] message, string PrivateKeyPath, string password, string CertPath)
    {
        try
        {
            // Load end certificate and signing key
            var signerCert = ReadCertFromFile(PrivateKeyPath, password, out AsymmetricKeyParameter key);

            // Read CA cert
            var caCert = ReadCertFromFile(CertPath);
            var certChain = new X509Certificate[] { caCert };

            var result = SignWithSystem(
              message,
              key,
              signerCert,
              certChain);
            return result;
        }
        catch (Exception ex)
        {
            Console.WriteLine(""Failed : "" + ex.ToString());
            return null;
        }
    }

    protected static byte[] SignWithSystem(byte[] data, AsymmetricKeyParameter key, X509Certificate cert, X509Certificate[] chain)
    {
        var generator = new CmsSignedDataGenerator();
        // Add signing key
        generator.AddSigner(
          key,
          cert,
          ""2.16.840.1.101.3.4.2.1""); // SHA256 digest ID
        var storeCerts = new List&lt;X509Certificate&gt;
        {
            cert // NOTE: Adding end certificate too
        };
        storeCerts.AddRange(chain); // I'm assuming the chain collection doesn't contain the end certificate already
                                    // Construct a store from the collection of certificates and add to generator
        var storeParams = new X509CollectionStoreParameters(storeCerts);
        var certStore = X509StoreFactory.Create(""CERTIFICATE/COLLECTION"", storeParams);
        generator.AddCertificates(certStore);

        // Generate the signature
        var signedData = generator.Generate(
          new CmsProcessableByteArray(data),
          false); // encapsulate = false for detached signature
        return signedData.GetEncoded();
    }

    public static X509Certificate ReadCertFromFile(string strCertificatePath)
    {
        // Create file stream object to read certificate
        using (var keyStream = new FileStream(strCertificatePath, FileMode.Open, FileAccess.Read))
        {
            var parser = new X509CertificateParser();
            return parser.ReadCertificate(keyStream);
        }
    }

    // This reads a certificate from a file.
    // Thanks to: http://blog.softwarecodehelp.com/2009/06/23/CodeForRetrievePublicKeyFromCertificateAndEncryptUsingCertificatePublicKeyForBothJavaC.aspx
    public static X509Certificate ReadCertFromFile(string strCertificatePath, string strCertificatePassword, out AsymmetricKeyParameter key)
    {
        key = null;
        // Create file stream object to read certificate
        using (var keyStream = new FileStream(strCertificatePath, FileMode.Open, FileAccess.Read))
        {
            // Read certificate using BouncyCastle component
            var inputKeyStore = new Pkcs12Store();
            inputKeyStore.Load(keyStream, strCertificatePassword.ToCharArray());

            var keyAlias = inputKeyStore.Aliases.Cast&lt;string&gt;().FirstOrDefault(n =&gt; inputKeyStore.IsKeyEntry(n));

            // Read Key from Aliases  
            if (keyAlias == null)
                throw new NotImplementedException(""Alias"");
            key = inputKeyStore.GetKey(keyAlias).Key;
            //Read certificate into 509 format
            return (X509Certificate)inputKeyStore.GetCertificate(keyAlias).Certificate;
        }
    }
</code></pre>
","105","<.net><.net-core><pkcs#7>","2","0","2","2018-08-07 09:29:16","","0","1","6535399","","2018-08-03 15:36:41","2018-08-03 11:04:32",""
"27900089","Verification of pdf integrity fail","<p>I'm trying to verify via bash commands the integrity of a pdf file.</p>

<p>Using dd I extracted the signedContent and the pkcs7 detached object of the pdf.</p>

<p>Then I decoded the pkcs via</p>

<pre><code>xxd -r -p pkcs7_extracted &gt; pkcs7_extracted.bin

openssl asn1parse -inform DER &lt;pkcs7_extracted.bin &gt;pkcs7_extracted_decoded
</code></pre>

<p>from the decoded pkcs7 I got some useful information as</p>

<pre><code> 0:d=0  hl=4 l=5498 cons: SEQUENCE         
 4:d=1  hl=2 l=   9 prim: OBJECT            :pkcs7-signedData
 15:d=1  hl=4 l=5483 cons: cont [ 0 ]        
 19:d=2  hl=4 l=5479 cons: SEQUENCE          
 23:d=3  hl=2 l=   1 prim: INTEGER           :01
 26:d=3  hl=2 l=  15 cons: SET               
 28:d=4  hl=2 l=  13 cons: SEQUENCE          
 30:d=5  hl=2 l=   9 prim: OBJECT            :sha256
 41:d=5  hl=2 l=   0 prim: NULL              
 43:d=3  hl=2 l=  11 cons: SEQUENCE          
 ...
 5154:d=7  hl=2 l=   9 prim: OBJECT            :contentType
 5165:d=7  hl=2 l=  11 cons: SET               
 5167:d=8  hl=2 l=   9 prim: OBJECT            :pkcs7-data
 5178:d=6  hl=2 l=  47 cons: SEQUENCE          
 5180:d=7  hl=2 l=   9 prim: OBJECT            :messageDigest
 5191:d=7  hl=2 l=  34 cons: SET               
 5193:d=8  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:18B399D208A08815DDF23C93B1B63B13757A6AA24B1932569D7A69D0DB3A34C2
 5227:d=5  hl=2 l=  13 cons: SEQUENCE          
 5229:d=6  hl=2 l=   9 prim: OBJECT            :sha256WithRSAEncryption
 5240:d=6  hl=2 l=   0 prim: NULL              
 5242:d=5  hl=4 l= 256 prim: OCTET STRING      [HEX DUMP]:8F4B21914173EC57E6B0533BB5E04FB7054F23AC299C1BDBF589ED164A3EABB611727BE9117AAC3161D9C18DCA08BD113DD3AA90E5922009FA12BA59E7F6587E81CD79BDED09F862C2C76F35D950926F1A31A3DCCE999A52DCE0C7F67D081E81A44397E8AF96A1051B8E51F2E2271221B06D05C9895E1846B1DBE02B558F5B9EF97C7EB0FF9A7C71A9764D5E205900818F07E82027D79D3F9A5AA72B3A0CF131F1B890D0BCBF3C4DD8A0229FABE15F6C2CA0CE079EB925B3998A1A6190596A88D8F07C1C12B8750636E69108E30E643A653B285A400080C9C5590C112451F6D69BAFC2686D6F1107B37A5DB36B9F797C49E61D4B44E62E17DD541778DE763AC5
 5502:d=0  hl=2 l=   0 prim: EOC              
</code></pre>

<p>in particular I notice that the messageDigest field is equal to the calculated digest of the signedContent obtained using the ByteRange.</p>

<p>I've so extracted the encrypted hash, decrypted it with my publickey and decoded again with asn1 command.</p>

<pre><code>dd if=pkcs7_extracted.bin of=extracted.sign.bin bs=1 skip=$[ 5242 + 4 ] count=256

#decrypt

openssl rsautl -verify -pubin -inkey publickey.pem &lt; extracted.sign.bin &gt; verified.bin

#decode of result
openssl asn1parse -inform der -in verified.bin
</code></pre>

<p>the result is this object</p>

<pre><code>0:d=0  hl=2 l=  49 cons: SEQUENCE          
2:d=1  hl=2 l=  13 cons: SEQUENCE          
4:d=2  hl=2 l=   9 prim: OBJECT            :sha256
15:d=2  hl=2 l=   0 prim: NULL              
17:d=1  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:EBAA31519CD0CCA793FEC34AA6BDD8DFA5E4D5F63BA4711F6C8ECE5D20FEF393
</code></pre>

<p>I'm pretty sure decryption worked since the object is correctly decoded and as I expected contains a sha256 object but as you can see the digest value is <strong>different</strong>...</p>

<p>Am I looking in the wrong place? I've no more idea how to verify the integrity.</p>

<p>In addition Acrobat of course validate the integrity of the document for this signature.</p>

<p>thanks in advance!</p>
","<p>Please be aware that in a <code>SignedData</code> object there are multiple hash values to consider which generally are not equal.</p>

<p>Have a look at the definition of the Cryptographic Message Syntax (CMS) objects in <a href=""https://tools.ietf.org/html/rfc3852"" rel=""nofollow noreferrer"">RFC 3852</a>.</p>

<p>(<a href=""https://tools.ietf.org/html/rfc3852"" rel=""nofollow noreferrer"">RFC 3852</a> is the RFC referenced from the current PDF specification ISO 32000-1; thus, even though it is <em>obsoleted by</em> <a href=""https://tools.ietf.org/html/rfc5652"" rel=""nofollow noreferrer"">RFC 5652</a>, changes in the newer RFC might not apply in this context.)</p>

<pre><code>  SignedData ::= SEQUENCE {
    version CMSVersion,
    digestAlgorithms DigestAlgorithmIdentifiers,
    encapContentInfo EncapsulatedContentInfo,
    certificates [0] IMPLICIT CertificateSet OPTIONAL,
    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
    signerInfos SignerInfos }

...

  SignerInfo ::= SEQUENCE {
    version CMSVersion,
    sid SignerIdentifier,
    digestAlgorithm DigestAlgorithmIdentifier,
    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
    signatureAlgorithm SignatureAlgorithmIdentifier,
    signature SignatureValue,
    unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }

...

  SignedAttributes ::= SET SIZE (1..MAX) OF Attribute

...

  signedAttrs is a collection of attributes that are signed.  The
  field is optional, but it MUST be present if the content type of
  the EncapsulatedContentInfo value being signed is not id-data.
  SignedAttributes MUST be DER encoded, even if the rest of the
  structure is BER encoded.  Useful attribute types, such as signing
  time, are defined in Section 11.  If the field is present, it MUST
  contain, at a minimum, the following two attributes:

     A content-type attribute having as its value the content type
     of the EncapsulatedContentInfo value being signed.  Section
     11.1 defines the content-type attribute.  However, the
     content-type attribute MUST NOT be used as part of a
     countersignature unsigned attribute as defined in section 11.4.

     A message-digest attribute, having as its value the message
     digest of the content.  Section 11.2 defines the message-digest
     attribute.

...

  The result of the message digest calculation process depends on
  whether the signedAttrs field is present.  When the field is absent,
  the result is just the message digest of the content as described
  above.  When the field is present, however, the result is the message
  digest of the complete DER encoding of the SignedAttrs value
  contained in the signedAttrs field.  Since the SignedAttrs value,
  when present, must contain the content-type and the message-digest
  attributes, those values are indirectly included in the result.
</code></pre>

<p>Thus, your observation</p>

<blockquote>
  <p>that the messageDigest field is equal to the calculated digest of the signedContent obtained using the ByteRange.</p>
</blockquote>

<pre><code> 5178:d=6  hl=2 l=  47 cons: SEQUENCE          
 5180:d=7  hl=2 l=   9 prim: OBJECT            :messageDigest
 5191:d=7  hl=2 l=  34 cons: SET               
 5193:d=8  hl=2 l=  32 prim: OCTET STRING      [HEX DUMP]:18B399D208A08815DDF23C93B1B63B13757A6AA24B1932569D7A69D0DB3A34C2
</code></pre>

<p>indicates that the correct data is signed because the <em>message-digest attribute</em> shall have <em>as its value the message digest of the content</em>.</p>

<p>But as you can also read here, the data signed by the actual inner <em>signature</em> bytes (which you decrypted) is <em>not this message digest of the content</em> but instead the <em>collection of attributes signedAttrs</em>!</p>

<p><strong>Thus, you must not verify those <em>signature</em> bytes against the <em>content</em> hash but against the <em>signed attributes</em> hash as described in the RFC.</strong></p>

<p>PS: The OP meanwhile found <a href=""https://stackoverflow.com/a/24581628/1729265"">this other answer</a> on the topic of CMS signed data verification which additionally illustrates how one can more graphically identify which attributes are signed and which are not.</p>

<p>PPS: The OP verifies by <em>decrypting</em> the signature bytes, extracting the contained hash, and comparing it with the actual one. This is ok for signatures based on RSA. Signatures based on DSA or ECDSA cannot be decrypted, though, so the hash value cannot be extracted. Special verification routines must be used for their verification.</p>

<p>PPPS: There are different styles of integrated PDF signatures. While the style (PKCS7/CAdES detached) used here is the most common and recommended one, in a generic solution one has to check beforehand and verify accordingly.</p>
","101","<security><pdf><pkcs#7>","0","0","1","2015-01-15 11:42:10","27900993","1","","","","","2015-01-12 10:40:27",""
"44320838","convert c# TripleDes PKCS7 code to php code","<p>I have this code in C#</p>

<pre><code>var dataBytes = Encoding.UTF8.GetBytes('clear text');

var symmetric = SymmetricAlgorithm.Create(""TripleDes"");
symmetric.Mode = CipherMode.ECB;
symmetric.Padding = PaddingMode.PKCS7;

var encryptor = symmetric.CreateEncryptor(Convert.FromBase64String('myKey'), new byte[8]);

var signedData = Convert.ToBase64String(encryptor.TransformFinalBlock(dataBytes, 0, dataBytes.Length));
</code></pre>

<p>now i need convert c# code to php code.
regard</p>
","<p>I use this function and worked for me </p>

<pre><code>function encryptData($plainText,$key)
{

    $byte = mb_convert_encoding($key, 'ASCII');

    $desKey = base64_decode($key);
    $data = mb_convert_encoding($plainText, 'ASCII');

    // add PKCS#7 padding
    $blocksize = mcrypt_get_block_size('tripledes', 'ecb');
    $paddingSize = $blocksize - (strlen($data) % $blocksize);
    $data .= str_repeat(chr($paddingSize), $paddingSize);

    // encrypt password
    $encData = mcrypt_encrypt('tripledes', $desKey, $data, 'ecb');

    return base64_encode($encData);
}
</code></pre>
","92","<c#><php><pkcs#7><tripledes>","0","-1","1","2017-06-02 14:40:49","44331582","1","","","","","2017-06-02 04:31:10",""
"35272701","verify x509 certificate validity at some point of time","<p>Actually what I am trying to do is to verify signature of the file. It consists of several items:</p>

<ol>
<li>Verify that file hash is the same as in signature (non-modification)</li>
<li>Verify that certificate chain is valid (it is done using OCSP and
cached CRLs) </li>
<li>Verify that certificate was valid at given time. Now
this is the problem. I can't get this information using both <code>OCSP</code>
or <code>CRL</code>.</li>
</ol>

<p>Can you point me to direction how can this be checked?</p>
","","91","<php><openssl><pkcs#7>","2","","0","2016-02-08 16:44:16","","0","","206","","2016-02-08 16:44:16","2016-02-08 15:02:04",""
"30712799","PKCS7_verify fails to return me original signed binary","<p>I have an application signed twice using openssl smime. like shown below in a script:</p>

<pre><code>SRC_FILE=""my-app""

echo ""signature XYZ...""

openssl smime -sign \
  -in ${SRC_FILE} -binary \
  -out ${SRC_FILE}.sig1 -nodetach \
  -signer ${SIGN_CERT} -inkey ${SIGN_KEY}

echo ""NB signature...""

openssl smime -sign \
  -in ${SRC_FILE}.sig1 -binary \
  -out ${SRC_FILE}.sig2 -nodetach \
  -signer ${NB_SIGN_CERT} -inkey ${NB_SIGN_KEY}
</code></pre>

<p>I am trying to verify the signed application using :</p>

<pre><code>openssl smime -verify -in ${SRC_FILE}.sig2 -CAfile ./Root_CA.crt -out ${SRC_FILE}.out
</code></pre>

<p>As an output of verify I am getting equivalent to ${SRC_FILE}.sig1 but my intention is to get original my-app. </p>

<p>If I am running verify command twice then eventually I am able to  receive my-app.</p>

<p>I wanted to ask is there any <strong>flag which internally call recursively</strong> to produce original signed file.</p>
","","88","<security><openssl><pkcs#7><smime>","0","","0","2015-06-15 12:03:53","","2","","1859501","","2015-06-15 12:03:53","2015-06-08 15:08:36",""
"40733114","Write CMS encoded PEM with Bouncycastle","<p>I have used the following source code and successfully generated a PKCS7 encoded PEM but i need to generate a CMS encoded based on RFC7468 <a href=""https://tools.ietf.org/html/rfc7468#page-11"" rel=""nofollow noreferrer"">https://tools.ietf.org/html/rfc7468#page-11</a>. Based on the RFC, CMS encoded PEM is recommended. Please help if you know the answer, thanks in advance. </p>

<pre><code>    ContentSigner sha256Signer = new     JcaContentSignerBuilder(""SHA256WITHECDSA"").setProvider(new org.spongycastle.jce.provider.BouncyCastleProvider()).build(key);

    CMSTypedData     msg = new CMSProcessableByteArray(data.getBytes(charset));
    CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
    gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(
            new JcaDigestCalculatorProviderBuilder().build()).build(
            sha256Signer, new X509CertificateHolder(x509Cert)));

    gen.addCertificates(certStore);
    CMSSignedData signedData = gen.generate(msg, true);
    // Generate PKCS7 PEM
    ContentInfo ci = signedData.toASN1Structure();

    StringWriter signedCertificatePEMDataStringWriter = new StringWriter();
    JcaPEMWriter pemWrt = new JcaPEMWriter(signedCertificatePEMDataStringWriter);
    pemWrt.writeObject(ci);
    pemWrt.flush();
    pemWrt.close();
</code></pre>
","","87","<content-management-system><bouncycastle><pem><pkcs#7>","1","","0","2016-11-22 03:02:14","","0","1","","","","2016-11-22 03:02:14",""
"56497793","Create PKCS#7 CMS Detached signature compatible with OpenSSL SMIME command","<p>I'm trying to create a detached signature of XML file in order to send message to the government organization. The application on the government's side wants PKCS#7 detached signature without certs and data(?). In documentation they use openssl as an example. From string ""this is string"" (without quotes) the openssl command:</p>

<blockquote>
  <p>openssl smime -sign -outform pem -signer C:\Temp\cert_test_np.pem -in
  C:\Temp\test.xml -out C:\Temp\Podpis2.xml -nocerts</p>
</blockquote>

<p>generates this signature string</p>

<blockquote>
  <p>-----BEGIN PKCS7----- MIIC0QYJKoZIhvcNAQcCoIICwjCCAr4CAQExDzANBglghkgBZQMEAgEFADALBgkq
  hkiG9w0BBwExggKZMIIClQIBATCBhjB/MQswCQYDVQQGEwJDWjEoMCYGA1UEAwwf
  SS5DQSBUZXN0IFB1YmxpYyBDQS9SU0EgMTEvMjAxNTEtMCsGA1UECgwkUHJ2bsOt
  IGNlcnRpZmlrYcSNbsOtIGF1dG9yaXRhLCBhLnMuMRcwFQYDVQQFEw5OVFJDWi0y
  NjQzOTM5NQIDAU1jMA0GCWCGSAFlAwQCAQUAoIHkMBgGCSqGSIb3DQEJAzELBgkq
  hkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTE5MDYwNzE1MjcyMFowLwYJKoZIhvcN
  AQkEMSIEIDY+iM9Vpap9krHOHyxKSyBHRZM20eaMwQFR7OpqrryFMHkGCSqGSIb3
  DQEJDzFsMGowCwYJYIZIAWUDBAEqMAsGCWCGSAFlAwQBFjALBglghkgBZQMEAQIw
  CgYIKoZIhvcNAwcwDgYIKoZIhvcNAwICAgCAMA0GCCqGSIb3DQMCAgFAMAcGBSsO
  AwIHMA0GCCqGSIb3DQMCAgEoMA0GCSqGSIb3DQEBAQUABIIBAIeN8SPBeNfDmip0
  NrpCoJ7c7YuuDW36OE9TN30D/ijRWcNMdgsObyNTFSrY0/51Gy655kejppfhwicv
  l/AdEXZcmM8JoWR9vHeRcklWmHLn1XYnKhDDWSQMZ0Kp62TTBTBsA6dLjizOhWx0
  u4Rj/lVv5/PmGsrQ4JmNreCaoSBAdqYOFCy2ZrvWNfhvpKPE+SDlAVMayfY0nqwM
  ds5pSb5o+YAWgsbfSQQU7uJp2K8XU4B1YAvGsg+aoGOxf/uiWNoppluQ9hpFAMzx
  tqndj8d1E2MUGkc6rISrMv+eoNheU+RM9ovDHQh9IVUDrdq8IalnjYVFsj+/0Wcz
  1O14IY0=
  -----END PKCS7-----</p>
</blockquote>

<p>I've written a following code in C#</p>

<pre><code> public static string GetSignatureString(string stringToSign, X509Certificate2 certificateToUse)
        {
            byte[] array = Encoding.ASCII.GetBytes(stringToSign);
            ContentInfo content = new ContentInfo(array);
            certificate = certificateToUse;
            SignedCms signedCMS = new SignedCms(content, true);

            CmsSigner signer = new CmsSigner(certificate);
            signer.IncludeOption = X509IncludeOption.None;
            signer.DigestAlgorithm =new Oid(""2.16.840.1.101.3.4.2.1"");
            signer.SignedAttributes.Add(new Pkcs9SigningTime());

            signedCMS.ComputeSignature(signer, true);
            byte[] signed = signedCMS.Encode();

            string sToWrite = Convert.ToBase64String(signed,Base64FormattingOptions.InsertLineBreaks);
            return ""-----BEGIN PKCS7-----\r\n"" + sToWrite + ""\r\n-----END PKCS7-----\r\n"";
        }
</code></pre>

<p>which returns following PKCS#7 string</p>

<blockquote>
  <p>-----BEGIN PKCS7----- MIICVQYJKoZIhvcNAQcCoIICRjCCAkICAQExDzANBglghkgBZQMEAgEFADALBgkqhkiG9w0BBwEx
  ggIdMIICGQIBATCBhjB/MQswCQYDVQQGEwJDWjEoMCYGA1UEAwwfSS5DQSBUZXN0IFB1YmxpYyBD
  QS9SU0EgMTEvMjAxNTEtMCsGA1UECgwkUHJ2bsOtIGNlcnRpZmlrYcSNbsOtIGF1dG9yaXRhLCBh
  LnMuMRcwFQYDVQQFEw5OVFJDWi0yNjQzOTM5NQIDAU1jMA0GCWCGSAFlAwQCAQUAoGkwGAYJKoZI
  hvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTkwNjA3MTUzMjU0WjAvBgkqhkiG
  9w0BCQQxIgQg3Obi7c6uoQfynW4GHXd9NRkmncvsYE1jAPUrepXO8PEwDQYJKoZIhvcNAQEBBQAE
  ggEAebxo2B+ka/xHWBWniTHSMkH8wNtRN6gWpqyI/Qq8/ZCchcT5PiUGnUFsDWXTJVaYuFG8NLOh
  uRNc6pFJduPyDRCtGJxNE8o2G5mAqAvARhuY6I4DvL88+a2Zvt1UgMyESzQqGOUT4EVCK8h+hkIy
  jlBpMESiJkMO6A+gLB0hfqjS5L4oIhtqr4SLhSSmyP8h/slBABYzRB6LZipFXy5252zPcgxxb8ZE
  hutzCD1K8o/qMcyXdnZT3Tm5pqKx39P3i3dLOnsus4zIDXzb2oKJwq6HfWapVngJO/bqozmhQnJj
  T1uM4W/KE+sx7z/uSBOKO1DWqG48OHO4PFCRdLwAng==
  -----END PKCS7-----</p>
</blockquote>

<p>Both signs are valid if you insert them into online pkcs7 decoder (<a href=""https://redkestrel.co.uk/products/decoder/"" rel=""nofollow noreferrer"">https://redkestrel.co.uk/products/decoder/</a> for example) but they have diferent message digest octet inside auth_attributes which is the part that government uses to check if the message is valid.</p>

<p>I know that they use/bend over <em>openssl smime</em> function which should be for email and for CMS they should use newer <em>openssl cms</em> function, but CMS should be compatible with smime which is older.</p>

<p>What I'm doing wrong in my function that the digest of the same string is different?</p>

<p>I'm using SHA256 algorithm (they too), no certs. inside PKCS#7 (they too), adding time to auth. attribute (they too).</p>

<p>Only two things are different.
1) They have generated some SMIME related information inside auth. attribute but it should be out of the game since we need the same message digest.</p>

<p>2) I'm getting certificate directly from cert. store inside windows for C# APP. OpenSSL is using .pem exported from the store. But they should be equal.</p>

<p>Is there any way how can I reproduce the same algorithm (get the same digest) used by OpenSSL smime function without linking of C++ libraries?</p>

<p>Thanks</p>
","","86","<c#><openssl><pkcs#7><message-digest>","0","","0","2019-06-07 16:01:00","","0","","","","","2019-06-07 16:01:00",""
"52216887","Verify pkcs7 Signature received from AS2 trading partner","<p>I am receiving an AS2 message from my trading partner. I have successfully decrypted it and it has following content:</p>

<pre><code>Content-Type: multipart/signed; boundary=""----1E2FB76A361B53C9D12B3971C32BC0D8""; protocol=""application/pkcs7-signature""; micalg=""sha-256""

------1E2FB76A361B53C9D12B3971C32BC0D8
Content-Transfer-Encoding: binary
Content-Disposition: attachment; filename=""edi.dat""
Content-Type: application/octet-stream; charset=""ascii""; name=""edi.dat""

ISA*00*          *00*          *ZZ*SPSAS2         *ZZ*SPSAS2         *140919*1159*|*00501*100000001*0*P*&gt;
GS*PO*AS2S3REC*AS2S3SEND*20140919*1159*123*X*005010
ST*850*1234
BEG*00*SA*SPSAS2TEST**20121017
REF*IA*TEST
PER*OC*Someone*TE*2844994944
DTM*001*20121025
N1*ST*SomeoneElse
N3*My address is private
N4*ST THOMAS*VI*00801
PO1*54812*1*EA***SK*123546*VP*123546*UP*123456987111
CTT*1
SE*11*1234
GE*1*123
IEA*1*100000001

------1E2FB76A361B53C9D12B3971C32BC0D8
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=""smime.p7s""
Content-Type: application/pkcs7-signature; name=""smime.p7s""

MIIL5gYJKoZIhvcNAQcCoIIL1zCCC9MCAQExDzANBglghkgBZQMEAgEFADALBgkq
hkiG9w0BBwGgggg3MIIIMzCCBxugAwIBAgIQCq+jbObLeCwtsdF61BAtBzANBgkq
hkiG9w0BAQsFADBNMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5j
MScwJQYDVQQDEx5EaWdpQ2VydCBTSEEyIFNlY3VyZSBTZXJ2ZXIgQ0EwHhcNMTgw
MjA5MDAwMDAwWhcNMjEwMjE3MTIwMDAwWjCBgjELMAkGA1UEBhMCVVMxEjAQBgNV
BAgTCU1pbm5lc290YTEUMBIGA1UEBxMLTWlubmVhcG9saXMxGzAZBgNVBAoTElNQ
UyBDb21tZXJjZSwgSW5jLjELMAkGA1UECxMCSVQxHzAdBgNVBAMTFnNwc2FzMi5j
b21tZXJjZXZhbi5jb20wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCw
1fJZ14+32k+Qutklk2+YYxaPMe2ASv41lfR5945H6M2SmdgFqqF2LPNZqWofcBPQ
HbMWctbBHOW1shOS2XvBRUFT5tuyQKcG4iYz7FEHFGpu4oGyC0eUYSuBBtTQMmRi
zk8bMwwNhRUUyzxa/y3OePK0lEDdaQsSKi8WHLkfkVZBo7Lk9CPyR4WZ8q8uo/qW
tNMDbk1Fn2CtXqYrXFTmLJ81ScXGTp5zoIUhrkGcUzumK+25EBT9p+2XcVMCUj9S
LY1DWyTnWx2mgT0ekeHM0pXV2MPDuUG99SiQB4Q0CH0I3J4ZafP2rCzBVkvNlTFJ
ZojaQyfcP9W73ZiYSgUmQ3mCa/BjACTO8wztu9DBelUNVjSxCYysGUdKNyl6hAAI
OAPe8z0mmDCVA7S4rnTYkliW+2JQdOTaKc0GOiaHQjrd+Gta1aAJHRR1pxjSX2FC
apS3DkiJl4i5vdyPZM53QhS51XCxGHtCCcJ574MIPkthI4SLwKJkk6rSgvb7B0ai
7jbDmvp1FjY0SgKoHyN+QNH1J4rMeK7IUp2N0R+YrJa6kEaocIptSoPToDGKWk+o
qAx65r3T2n21jEfiCzN6JyqxNfE1T35Pekpvu4ioUEfW1ICf6AOQ5oQHWLr/Fhk2
sVzptYw5Lmtkb/sPGP1R/hBy88HAlTAh+QFrRJHHWwIDAQABo4ID1zCCA9MwHwYD
VR0jBBgwFoAUD4BhHIIxYdUvKOeNRji0LOHG2eIwHQYDVR0OBBYEFJs5x7uPOhBe
2Mp1aThYg8urrQ4FMCEGA1UdEQQaMBiCFnNwc2FzMi5jb21tZXJjZXZhbi5jb20w
DgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjBr
BgNVHR8EZDBiMC+gLaArhilodHRwOi8vY3JsMy5kaWdpY2VydC5jb20vc3NjYS1z
aGEyLWc2LmNybDAvoC2gK4YpaHR0cDovL2NybDQuZGlnaWNlcnQuY29tL3NzY2Et
c2hhMi1nNi5jcmwwTAYDVR0gBEUwQzA3BglghkgBhv1sAQEwKjAoBggrBgEFBQcC
ARYcaHR0cHM6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzAIBgZngQwBAgIwfAYIKwYB
BQUHAQEEcDBuMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5jb20w
RgYIKwYBBQUHMAKGOmh0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2Vy
dFNIQTJTZWN1cmVTZXJ2ZXJDQS5jcnQwDAYDVR0TAQH/BAIwADCCAfYGCisGAQQB
1nkCBAIEggHmBIIB4gHgAHYApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN
3BAAAAFhezY//QAABAMARzBFAiEA/peliWFFZt3DPuaO1JekVr9XQhfW/SeCVONq
Rmju3zECIDByDCYP5dzgszieTnkpP3w5dsOfiVmJ+RRmuNORjb0rAHYAh3W/51l8
+IxDmV+9827/Vo1HVjb/SrVgwbTq/16ggw8AAAFhezZA2gAABAMARzBFAiEAmlnD
uPy34+XDxNZU8r0dD4fI+hFJwxQQkatA9zkIzegCIFxT3jLCCf9pVoEIeWYBOv3C
BjVqsn0jDqXLYSVOJTQVAHYAu9nfvB+KcbWTlCOXqpJ7RzhXlQqrUugakJZkNo4e
0YUAAAFhezZAzAAABAMARzBFAiEAwAWMiOFLxRBqVjLc/cktB7SjMujisPPx5WQA
Bat22NoCIAtVJcU2yoj6c66x8o/YI2lfSdZqF46K51WGb6/J79UdAHYAb1N2rDHw
MRnYmQCkURX/dxUcEdkCwQApBo2yCJo32RMAAAFhezZDCwAABAMARzBFAiAqzLuy
gkPgUSELvuB2xF9bFxPOj2YjBoiggQbUGfCMqgIhAL3VnGsi6xXUBswPEMn0M3P5
Cgnz6UGp2M4ItBE69YQnMA0GCSqGSIb3DQEBCwUAA4IBAQBbxA1NvqhkXddENUT5
qHY1pF91metZG38DwUS7c0xgS/LoY/WZZJ2cv0rEMoGCzRwwYijiiTc1MY6muiGE
hpdNja9Tu3bYJ9Z1bkiJJVKknqcqs64ibIbD762a7L/J0O9DzFKHeUwXAhpzT+rh
Z2eIPSR9BpUbiBpok73F/TvW2beJb2ncEiQJujK+UKlB9XeSsghrMOBiGnNJFB5t
Y155GAQb6oGiwRkkhWiJYZOq6riU5dmUbyqAqaxHij6hZOUzDL/fM5oeOpusedR0
4+eYgTe7LBq2teDNjchSceapKRXbbtz4UNDp0Ce3ZQyU4T4ndAsF9QiQnq7478SO
2ZgpMYIDczCCA28CAQEwYTBNMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNl
cnQgSW5jMScwJQYDVQQDEx5EaWdpQ2VydCBTSEEyIFNlY3VyZSBTZXJ2ZXIgQ0EC
EAqvo2zmy3gsLbHRetQQLQcwDQYJYIZIAWUDBAIBBQCggeQwGAYJKoZIhvcNAQkD
MQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTgwODMwMTkxMjQ3WjAvBgkq
hkiG9w0BCQQxIgQgh0UxRgyVkgQvRpk0/2ZBwHWFEqKH5Hu6qgpvjX9ETjUweQYJ
KoZIhvcNAQkPMWwwajALBglghkgBZQMEASowCwYJYIZIAWUDBAEWMAsGCWCGSAFl
AwQBAjAKBggqhkiG9w0DBzAOBggqhkiG9w0DAgICAIAwDQYIKoZIhvcNAwICAUAw
BwYFKw4DAgcwDQYIKoZIhvcNAwICASgwDQYJKoZIhvcNAQEBBQAEggIAEb1tlBKO
lSv69TDq4Jlhmtqt2szWKZazOhTMDUo68j3rJ6xJS9so7NKrQv+aeo8DdAblU/G/
OD2U6XS5iDdYg94aIyNEjuCZOfvibV8U1PA6WP+8VTo3vEDP0JoAt/NgWJKiKESS
iQ/8waAcLqxECW1Pa11KxdvO6xhJKpNI/xpl/t0007mYrZDseuLZNcyQjOOrP0Kj
E/21geSIyTTN842R0Zg6qTn6XlkPUq/bSa9MnlCUDNGxFn25Uqv+3nYlJhEiGyHa
GQef4vZL1faz7ljxnx/MJKiWAbq07F7tYEHGyVTkO3MGF/wBe8vDlYs3U1T4v+2g
hjEWiOyREYTt9a4XJ1QcscjbGCRl28BajmxBBHibkSM2o5ztLxPUoiEKjY3XQc6J
oHX3Gmj63qMQPQz58AVoalGtwxOxlJiFc0Y13NIydbxMRuxep0XHVNE5XFQGE1K/
2r5iV4pS1f+EarDxfjzkrUwZFYJLdO27DqIL//6m6uTiIgZBXnzqulWlLxX17MCD
2yUOTRPGqo9eRhnrtbeh3PYGXG0zhGSdmzoTQr2mf2k7EDB/48BGvUWeHGsc7sQT
LUrlnLKqiG1uRB4sWTWMtxsKtH8kGP824ihszLh+13IXlMztCEg+kh472KQENguC
Yxt8DzcvxMi0rIsbsC/Thq3nxpFCGDV7m3Q=

------1E2FB76A361B53C9D12B3971C32BC0D8--
</code></pre>

<p>It has the signature in ""Base64"" format and ""pkcs7-signature"". I am not able to match signature. I am considering following part as main data:</p>

<pre><code>ISA*00*          *00*          *ZZ*SPSAS2         *ZZ*SPSAS2         *140919*1159*|*00501*100000001*0*P*&gt;
GS*PO*AS2S3REC*AS2S3SEND*20140919*1159*123*X*005010
ST*850*1234
BEG*00*SA*SPSAS2TEST**20121017
REF*IA*TEST
PER*OC*Someone*TE*2844994944
DTM*001*20121025
N1*ST*SomeoneElse
N3*My address is private
N4*ST THOMAS*VI*00801
PO1*54812*1*EA***SK*123546*VP*123546*UP*123456987111
CTT*1
SE*11*1234
GE*1*123
IEA*1*100000001
</code></pre>

<p>and base64 string as sign. and sung following function to match sign:</p>

<pre><code>static bool Verify(string text, byte[] signature, string certPath)
        {
            X509Certificate2 cert = new X509Certificate2(certPath);
            RSACryptoServiceProvider csp = (RSACryptoServiceProvider)cert.PublicKey.Key;
            SHA1Managed sha1 = new SHA1Managed();
            UnicodeEncoding encoding = new UnicodeEncoding();
            byte[] data = encoding.GetBytes(text);
            byte[] hash = sha1.ComputeHash(data);
            // Verify the signature with the hash
            return csp.VerifyHash(hash, CryptoConfig.MapNameToOID(""SHA1""), signature);
        }
</code></pre>

<p>But this function is not matching the signature.
Please help me with this problem.</p>

<p>Thank you...</p>
","<p>I can't, personally, get the data to validate.  (I'm assuming that either there are trailing spaces that aren't copying correctly or that the payload has been altered (e.g. ""My address is private""))</p>

<p>The flow that I expect is happening:</p>

<ul>
<li>The pkcs7 content is a CMS SignedData with detached content.</li>
<li>The signed content was specified in the first stream</li>
</ul>

<p>So you need to do something like:</p>

<pre><code>byte[] dataBytes = ReadFirstSegment();
byte[] signatureBytes = ReadSecondSegment();

SignedCms cms = new SignedCms(new ContentInfo(dataBytes), detached: true);
cms.Decode(signatureBytes);
// This next line throws a CryptographicException if the signature can't be verified
cms.CheckSignature(true);

SignerInfoCollection signers = cms.SignerInfos;

if (signers.Count != 1)
{
    // probably fail
}

if (!IsExpectedCertificate(signers[0].Certificate))
{
    // fail
}

// success
</code></pre>
","85","<c#><digital-signature><x509certificate><pkcs#7>","0","0","1","2018-09-18 14:42:24","","0","","","","","2018-09-07 06:54:03",""
"55547844","Bundle.main.url(forResource: ""AppleIncRootCertificate"", withExtension: ""cer"") == nil","<p>In order to set up Receipt-Validation in a <code>Swift</code> iOS app (using <code>In-App-Purchase</code>), I am following this tutorial: <a href=""https://www.raywenderlich.com/9257-in-app-purchases-receipt-validation-tutorial"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/9257-in-app-purchases-receipt-validation-tutorial</a> and reading here: <em>Validating Apple Signed the Receipt</em>.</p>

<p>Here is a problem I have at this point.</p>

<p>In the code I have this:</p>

<pre><code>Bundle.main.url(forResource: ""AppleIncRootCertificate"", withExtension: ""cer"")
</code></pre>

<p>And when I check its value, it is nil. Since it is supposed to be used to extract further information, it shoud obviously not be nil. The question is: <strong>what could be wrong in the code or in some setting to make this nil?</strong></p>

<p>This is my first time to implement Receipt-Validation, so it may well be that I am missing something basic.</p>
","","85","<ios><swift><openssl><pkcs#7><receipt-validation>","0","","0","2019-04-06 09:48:37","","4","","","","","2019-04-06 09:48:37",""
"52376546","How to encrypt with Twofish using ECB cipher mode and PKCS7 block padding mode?","<p>I want to access an API with PHP. The specifications are:</p>

<ul>
<li>Twofish algorithm</li>
<li>ECB cipher mode</li>
<li>PKCS7 block padding mode</li>
</ul>

<p>I have tried a lot of different PHP functions and libraries, but none seems to work.</p>

<p>Here is my code:</p>

<pre><code>function encrypt($data, $key)
{
  // Pad for PKCS7
  $blockSize = mcrypt_get_block_size(MCRYPT_TWOFISH, MCRYPT_MODE_ECB);
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $encryptedData = mcrypt_encrypt( MCRYPT_TWOFISH, $key, $data, MCRYPT_MODE_ECB);

  return $encryptedData;
}
</code></pre>

<p><strong>Do you see a problem with this code?</strong></p>
","<p><code>mcrypt_encrypt</code> does not support PKCS7 padding.  It has also been deprecated for a significant period of time.</p>

<p>If the API you want to talk to is using Twofish and ECB mode then you probably don't want to use that API at all - if they're happy to whack an incredibly insecure encryption scheme together for the front-facing API then the rest of their codebase is probably pretty shammy too.</p>
","84","<php><encryption><pkcs#7><ecb><twofish>","0","0","1","2018-09-17 23:58:42","","2","","","","","2018-09-17 22:37:30",""
"52017825","Reading PKCS7 and .p12 file certificate information(subjectDN,vaildstartfrom,ValildTo..) through java","<p>I am trying to implement Digital certificate validity utility using java. I can able to read the certification information(subjectDN, Issure info, validitity..etc) if the certificate in .cert,.cer but can't able to read certificate information from .p7b and .p12 certificate format. I have used the BouncyCastle security provider to read .p7b and .p12 certificate content but not able to get with that security provider might be i was missing on this. I am referring online resources  to get some idea on this but not get guideline for this.Could you please someone give suggestion on this.</p>
","<p>I suggest if you're looking for validity of the certificate from p12, it can be done as below :</p>

<pre><code>try {
        Security.addProvider(new BouncyCastleProvider());
        KeyStore keyStore = KeyStore.getInstance(""pkcs12"");
        InputStream input = new FileInputStream(""pathToYourP12"");
        keyStore.load(input, ""password"");
        certFromKeyStore = (X509Certificate)keyStore.getCertificate(""keyStoreAllias"");
        certFromKeyStore.checkValidity();
}
catch(Exception e)
{
// catch exception like if no valid p12 existing at the location, invalid password, or any other exception should get catch properly.
}
</code></pre>
","81","<certificate><pkcs#7><java-security>","0","0","1","2018-09-01 14:04:48","52099684","0","","5794000","","2018-08-26 12:48:29","2018-08-25 13:35:02",""
"50698179","Generate signed PKCS#7 without access to the PK","<p>I have a smart card which stores my private key and performs limited cryptographic operations, and I need to generate a PKCS#7 signed file. The library that came with the smart card doesn't support PKCS#7, but I can use it to generate signatures.</p>

<p>Is there any way I can use a mature, open source library, such as openssl, in order to build the PKCS#7 content, given the clear text payload, the certificate, and the <em>signature</em> (<strong>not</strong> the private key)?</p>

<p>I know I can call various functions in openssl to perform all operations at once (including signing), but that requires access to the private key, which my code can't extract.</p>
","<p>You can do it by creating an OpenSSL engine that will communicate with the card when private key operation is required. </p>
","81","<openssl><smartcard><sign><pkcs#7>","0","-1","1","2018-06-06 11:42:53","","0","1","","","","2018-06-05 10:46:08",""
"51434245","Can't get encrypted key out of pkcs7 envelope with PyAsn1 Python","<p>I am trying to extract a RSA-encrypted AES key from a PKCS7 envelope and am getting an error that says the encrypted key is a schema, not a value. Why is this when in the envelope there is a line that says encryptedKey=....</p>

<pre><code>content, rest = decode(env_der, asn1Spec=rfc2315.ContentInfo())
assert content['contentType'] == rfc2315.envelopedData

myenvelop, rest = decode(content['content'], asn1Spec=rfc2315.EnvelopedData())
print(myenvelop)
print(myenvelop['recipientInfos'][1]['encryptedKey'])
</code></pre>

<p>the result of this code is:</p>

<pre><code>    EnvelopedData:
 version=0
 recipientInfos=RecipientInfos:
  RecipientInfo:
   version=0
   issuerAndSerialNumber=IssuerAndSerialNumber:
    issuer=Name:
     =RDNSequence:
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.6
        value=0x13025553
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.10
        value=0x130f552e532e20476f7665726e6d656e74
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.11
        value=0x131c556e697465642053746174657320506f7374616c2053657276696365
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.3
        value=0x131255535053496e7465726e616c537562324341


    serialNumber=488380148491395325238848

   keyEncryptionAlgorithm=KeyEncryptionAlgorithmIdentifier:
    algorithm=1.2.840.113549.1.1.1
    parameters=0x0500

   encryptedKey=0x1b396af2d3a1eca95621262c85fd11835616fc5e1d342c752a2082dd559a23c8f11c21d68b8d5317c721c1d7eba7a1c5bef8ee15d428da74c513a61437d6ba7e6ba4286540ec6c068091b5a611ea36c0aaf44b3055fddbdfe40f5472aa0c1daaa69b67ff5bac3e9de17f5c12f7bd4c86ad4d505341308048c82f29cf71c3bcb9108039ccbf7ebc5f9784570f360a1ec3c529dfc94950d290aa95d80e849688b3cc509851173cedf12e963dcd1d083b87ab3a41b7a0db5f79ca4a52b28b3758fec1f20a627d181e95547d56f0b51fcf2a211371df8d62b5e62473ece192649493d89a72693ffe94c2dbfb7e5ba1fa1c04b623b5094600786b931e6cd1a6f406d1

 encryptedContentInfo=EncryptedContentInfo:
  contentType=1.2.840.113549.1.7.1
  contentEncryptionAlgorithm=ContentEncryptionAlgorithmIdentifier:
   algorithm=2.16.840.1.101.3.4.1.42
   parameters=0x041016b5378e3bfde72671a7a207a4038840



Traceback (most recent call last):
  File ""C:/Users/VoxaiLap10/Desktop/pythonbible/cryptotestpemmp3_b_md5_7-19-18b.py"", line 81, in &lt;module&gt;
    unEnvelop(filename, pemFile, outfilename)
  File ""C:/Users/VoxaiLap10/Desktop/pythonbible/cryptotestpemmp3_b_md5_7-19-18b.py"", line 41, in unEnvelop
    print(myenvelop['recipientInfos'][1]['encryptedKey'])
  File ""C:\Program Files (x86)\Python36-32\lib\site-packages\pyasn1\type\univ.py"", line 882, in __str__
    return self._value.decode(self.encoding)
  File ""C:\Program Files (x86)\Python36-32\lib\site-packages\pyasn1\type\base.py"", line 221, in __getattr__
    raise error.PyAsn1Error('Attempted ""%s"" operation on ASN.1 schema object' % attr)
pyasn1.error.PyAsn1Error: Attempted ""decode"" operation on ASN.1 schema object
</code></pre>
","<p>Suspicious part is that <code>[1]</code> subscription, should it be <code>[0]</code> instead? I assume you are trying to address the first element of the <code>RecipientInfos</code> sequence which is zero-based.</p>

<p>The error message itself means that the object you are trying to work with is not initialized e.g. is not filled with any concrete value. That's why it can only be used as a ""schema"" e.g. for type information.</p>

<p>When you subscribe <code>RecipientInfos</code> by a non-existing index, the new <code>RecipientInfo</code> element is created which obviously is not populated with any concrete values (apart from the defaults). In that sense it remains a schema, not schema instance.</p>
","76","<python><python-3.x><pkcs#7><pyasn1>","0","1","1","2018-07-20 06:37:18","51436458","0","","","","","2018-07-20 02:29:31",""
"53632723","How can I sign a document using PKCS7, CAdES, S/MIME (e-cpf / e-cnpj) to create a P7S file using javascript on the browser?","<p>I was able to read a p12 certificate file and, using the password, I was able to extract:</p>

<ul>
<li><code>key</code> and <code>cert</code> using <strong>forge</strong> methods: <code>forge.pkcs12.pkcs12FromAsn1</code> and <code>getBags({friendlyName: this.selectedFriendlyName}).friendlyName</code></li>
<li><code>privatePem</code> using <code>forge.pki.privateKeyToPem</code></li>
</ul>

<p>I found some solutions to sign a message or document using PKCS7, CAdES and S/MIME, but none of them produced a P7S file and the result is different than a proper P7S content (byte array), and that is what I understood is the correct file format to be used in E-CPF/E-CNPJ signed documents.</p>

<p>I would like to archive this using javascript on the browser, but any help or direction will be appreciated, thank you in advance :)</p>
","<p>Looks like you are brazilian... Check if this PHP answer helps.</p>

<p><a href=""https://pt.stackoverflow.com/a/124876/6573"">https://pt.stackoverflow.com/a/124876/6573</a></p>
","76","<javascript><x509><pki><pkcs#7><electronic-signature>","0","1","1","2018-12-05 13:08:46","","1","","858257","","2018-12-05 13:05:42","2018-12-05 12:48:21",""
"47578329","use subprocess in Python to use OpenSSL to print a PKCS7 certifcate to a file","<p>There is plenty of code for OpenSSL/UNIX for Encrypting/Decrypting cert files.
I would like to know if there is some code I can put into Python 3.5 that will print and create an output file of that information. Here is the OpenSSL command that works wonderfully:</p>

<pre><code>OpenSSL&gt; pkcs7 -inform DER -n CERT.RSA -out CERT.TXT -noout -print_certs -text
</code></pre>

<p>This converts the file so that I can easily read it. Try this for yourself in OpenSSL. I am not an expert in Python and I am trying to learn how to use my skills in Python for automation. Thank you for any input.</p>
","<p>Thank you to the ones that read my question. I figured it out. I hope that this helps someone.<br>
PYTHON CODE:</p>

<pre><code>subprocess.Popen(['openssl.exe', 'pkcs7', 'DER', '-in', InputFile, '-out', OutputFile,
    'print_certs', '-text'], stdout=None, stderr=None, shell=True)
</code></pre>
","72","<python><pkcs#7>","0","0","1","2017-12-04 14:01:29","","0","","1848654","","2017-11-30 18:23:05","2017-11-30 16:39:22",""
"36167932","How does Paypal structure button data before encryption?","<p>Currently I've done alot searching on how data should be structured before PKCS7 encryption for proper use within the Paypal buy-now button. So far, the best data I've found so far pertaining to data structure is an Paypal example code which demonstrates how a encrypted button appears on your website (this can be found here:<a href=""https://www.paypal.com/cgi-bin/webscr?cmd=p/xcl/rec/ewp-techview-outside"" rel=""nofollow"">https://www.paypal.com/cgi-bin/webscr?cmd=p/xcl/rec/ewp-techview-outside</a>) </p>

<p>At first glance, my results seem to be exactly as demonstrated within the Paypal eaxmple link, except that when i proceed to click the button i get a Paypal error saying ""We were unable to decrypt the certificate id"". Therefore I think that the problem is either how the data is structured or the actual encryption itself (I've also done alot of debugging and have made sure that all certificates and keys are being successfully registered ). The code below demonstrates the button that my php code creates.</p>

<pre><code>&lt;form action=""https://www.sandbox.paypal.com/cgi-bin/webscr"" method=""post""&gt;
  &lt;input type=""hidden"" name=""cmd"" value=""_s-xclick""&gt;
  &lt;input type=""image"" src=""https://www.sandbox.paypal.com/en_US/i/btn/x-click-but23.gif"" border=""0"" name=""submit"" alt=""Make payments with PayPal - it\'s fast, free and secure!""&gt;
  &lt;input type=""hidden"" name=""encrypted"" value=""-----BEGIN PKCS7-----MIIH6QYJKM585oH7A[to much data to show]9QRQIpFZzRK6cJu6QQO+q/xfiw==-----END PKCS7-----""&gt;
&lt;/form&gt;
</code></pre>

<p>This is my data before encryption:</p>

<pre><code>cert_id=9CE6NSORUBVMC cmd=_xclick business=sales@mycompany.com item_name=Cat Litter #40 amount=12.95 no_shipping=1 return=http://test183653.comli.com/MainPage.php cancel_return=http://test183653.comli.com/MainPage.php no_note=1 currency_code=USD bn=PP-BuyNowBF
</code></pre>

<p>I'm currently using the format above as a result of piecing bits and pieces of info on the internet but it doesn't seem to work (also doesn't work when i remove all the spaces in the string). Thus, </p>

<p><strong>MAIN QUESTION:</strong> Can anyone tell me or point me in the right direction to learn the proper format of the data before encryption?</p>

<p>For Anyone interested to check if it is the code that creates the errors through improper encryption, the function which encrypts data can be found below:</p>

<pre><code>function encryptButton($parameters) {

    if (($this-&gt;certificateID == '') ||
    !IsSet($this-&gt;certificate) ||
    !IsSet($this-&gt;paypalCertificate)) {
      return FALSE;
    }

    $clearText = '';
    $encryptedText = '';

    $clearText = 'cert_id='.$this-&gt;certificateID;

    foreach (array_keys($parameters) as $key) {

      $clearText .= ""\n{$key}={$parameters[$key]}"";
    }

    $clearFile = tempnam($this-&gt;tempFileDirectory, 'cle');
    $signedFile = preg_replace('/cle/', 'signed', $clearFile);
    $encryptedFile = preg_replace('/cle/', 'encrypted', $clearFile);

    $out = fopen($clearFile, 'wb');
    fwrite($out, $clearText); 
    fclose($out);

    //openssl_pkcs7_sign occurs here
    if (!openssl_pkcs7_sign($clearFile, $signedFile, $this-&gt;certificate, $this-&gt;privateKey, array(), PKCS7_BINARY)) {
      return FALSE;
    }

    $signedData = explode(""\n\n"", file_get_contents($signedFile));

    $out = fopen($signedFile, 'wb');
    fwrite($out, base64_decode($signedData[1]));
    fclose($out);

    //openssl_pkcs7_encrypt occurs here
    if (!openssl_pkcs7_encrypt($signedFile, $encryptedFile, $this-&gt;paypalCertificate, array(), PKCS7_BINARY)) {
      return FALSE;
    }

    $encryptedData = explode(""\n\n"", file_get_contents($encryptedFile));

    $encryptedText = $encryptedData[1];

    @unlink($clearFile);
    @unlink($signedFile);
    @unlink($encryptedFile);

    return $encryptedText;

  }


  function getEncryptedString($params) {
  return ""-----BEGIN PKCS7-----"".str_replace(""\n"", """", $this-&gt;encryptButton($params)).""-----END PKCS7-----""; }
</code></pre>

<p>}</p>
","","72","<php><encryption><paypal><ssl-certificate><pkcs#7>","1","","0","2016-03-23 00:54:09","","7","1","","","","2016-03-23 00:54:09",""
"57892036","Decrypt a Java AES encoded String in Dart","<p>I need to decrypt an AES (PKCS#7) encoded string in my Flutter mobile application.</p>

<p>The string is got from a QR Code, which has been generated from a Java application and contains the AES encoded String.</p>

<p>The Java encoding :</p>

<pre class=""lang-java prettyprint-override""><code>import java.security.Security;
import java.nio.charset.StandardCharsets;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class MyClass {

     public static void main(String[] args) throws Exception {
         String toEncode = ""firstname.lastname@mycompany.com;12"";
         String encoded = pleaseEncodeMe(toEncode);
         System.out.println(encoded);
     }

     private static String pleaseEncodeMe(String plainText) throws Exception {
         Security.addProvider(new BouncyCastleProvider());
         final String encryptionAlgorithm = ""AES/CBC/PKCS7PADDING"";
         final String encryptionKey = ""WHatAnAWEsoMeKey"";
         final SecretKeySpec keySpecification = new SecretKeySpec(encryptionKey.getBytes(StandardCharsets.UTF_8), encryptionAlgorithm);
         final Cipher cipher = Cipher.getInstance(encryptionAlgorithm, ""BC"");
         cipher.init(Cipher.ENCRYPT_MODE, keySpecification);
         final byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());
         return Base64.encodeBase64URLSafeString(encryptedBytes);
    }

}
</code></pre>

<p>Output : <code>AIRTEuNmSuQtYuysv93w3w83kJJ6sg7kaU7XzA8xrAjOp-lKYPp1brtDAPbhSJmT</code></p>

<p>The Dart decoding :</p>

<pre class=""lang-dart prettyprint-override""><code>void main() {
    print(decodeMeOrDie(""AIRTEuNmSuQtYuysv93w3w83kJJ6sg7kaU7XzA8xrAjOp-lKYPp1brtDAPbhSJmT""));
}

String decodeMeOrDie(String encryptedString) {
    final key = Key.fromUtf8(""WHatAnAWEsoMeKey"");
    final iv = IV.fromLength(16);
    final encrypter = Encrypter(AES(key, mode: AESMode.cbc, padding: ""PKCS7""));
    return encrypter.decrypt64(encryptedString, iv: iv);
}
</code></pre>

<p>Output : <code>YÔøΩÔøΩ=XÔøΩR»ëÔøΩ""Qme@mycompany.com;12</code></p>

<p>You can see that only a part of the string is decoded.</p>
","<ul>
<li><p>Two things must be taken into account:</p>

<p>1) For decryption, the IV used for encryption is required. </p>

<p>2) For security reasons, a new IV must be randomly generated for each encryption so that no IV is used more than once with the same key, <a href=""https://stackoverflow.com/questions/9049789/aes-encryption-key-versus-iv"">here</a>. </p>

<p>Therfore, the IV must be passed from the encryption-side to the decryption-side. This doesn't happen automatically, but has to be implemented.</p></li>
<li><p>One possibility is to concatenate the byte-arrays of IV and ciphertext. Usually the IV is placed before the ciphertext and the result is Base64-encoded (if required), e.g. in Java: </p>

<pre><code>// Concatenate IV and ciphertext
byte[] iv = ...
byte[] ciphertext = ...
byte[] ivAndCiphertext = new byte[iv.length + ciphertext.length];
System.arraycopy(iv, 0, ivAndCiphertext, 0, iv.length);
System.arraycopy(ciphertext, 0, ivAndCiphertext, iv.length, ciphertext.length);
// If required: Base64-encoding
</code></pre>

<p>This data is transmitted to the decryption-side, which separates both parts after Base64-decoding. In the case of AES-CBC, the IV is 16 bytes long, so the first 16 bytes represent the IV and the rest the ciphertext. The IV doesn't need to be encrypted because it isn't secret. </p>

<p>Specifically for your case this means that you have to concatenate IV and ciphertext on the Java-side and to Base64-encode the result. On the Dart-side you have to Base64-decode first and then both parts, IV and ciphertext, can be separated and used for the following decryption.</p></li>
<li><p>There are two ways to generate the IV before encryption: Implicit generation by the <a href=""https://docs.oracle.com/en/java/javase/12/docs/api/java.base/javax/crypto/Cipher.html"" rel=""nofollow noreferrer""><code>Cipher</code></a>-instance as in your example or explicit generation e.g. via <a href=""https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/security/SecureRandom.html"" rel=""nofollow noreferrer"">SecureRandom</a>. Both alternatives are discussed <a href=""https://stackoverflow.com/a/29267873/9014097"">here</a>. If the IV is generated implicitly (via the <code>Cipher</code>-instance), then this IV must be determined via the <code>Cipher</code>-instance, since it is later required for decryption:</p>

<pre><code>// Determine IV from cipher for later decryption
byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
</code></pre>

<p>If the IV is determined explicitly (e.g. using <code>SecureRandom</code>), it must be passed to the <code>Cipher</code>-instance so that it will be used in the running encryption. This is done using an <a href=""https://docs.oracle.com/en/java/javase/12/docs/api/java.base/javax/crypto/spec/IvParameterSpec.html"" rel=""nofollow noreferrer""><code>IvParameterSpec</code></a>.</p>

<pre><code>// Assign IV to cipher so that it is used for current encryption
byte[] iv = ...
IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
cipher.init(Cipher.ENCRYPT_MODE, secretkeySpec, ivParameterSpec);
</code></pre></li>
<li><p>A hard-coded key is in general not good practice (except for testing purposes perhaps). However, the topic of key generation/management is outside the scope of this answer. There are already a lot of questions and answers on this subject. If your question is not covered by these answers, please post a new question. A hard-coded IV doesn't occur within the above architecture and should only be used for testing purposes.  </p></li>
</ul>

<hr>
","68","<java><encryption><dart><aes><pkcs#7>","1","2","1","2019-09-12 17:29:46","57911838","4","","","","","2019-09-11 15:06:00",""
"51631352","Encryption AES 128","<p>I've been asked at work to implement a request for a simple web service with the following instructions:</p>

<p><strong>AES encryption:<br>
Type: ECB<br>
Size: 128bits<br>
Padding Mode: PKCS7<br>
key: 9b6018215942b2e1da3797d3394779bf</strong></p>

<p>In the docs (just a given example) they say that for the string:</p>

<blockquote>
  <p>2874838-49</p>
</blockquote>

<p>The encryption process must generate:</p>

<blockquote>
  <p>BEE361962A1802A7BA2AD328DAE8B291</p>
</blockquote>

<p>I've been searching a lot for something like this, but none of the solutions (like <a href=""https://stackoverflow.com/questions/7314901/how-to-add-remove-pkcs7-padding-from-an-aes-encrypted-string"">here</a>, <a href=""https://gist.github.com/Halama/5956871"" rel=""nofollow noreferrer"">here</a> <a href=""https://gist.github.com/RiANOl/1077723/fb7add28bdb7d9829a134ed45edc049453891797"" rel=""nofollow noreferrer"">here</a>, etc...) given helped me achieving the example result given.</p>

<p>This was the last thing I tried now:</p>

<pre><code>function aes128Encrypt($data, $key) {
  $padding = 32 - (strlen($data) % 32);
  $data .= str_repeat(chr($padding), $padding);
  return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_ECB));
}
$data = ""2874838-49"";
$key = ""9b6018215942b2e1da3797d3394779bf"";    
echo aes128Encrypt($data, $key); // UdP7dXSTp6b5I986PLL8Gs3qH3rMj0SpQ0te4pP7M44=
</code></pre>
","<p>The encoding algorithm returns a stream of bytes back to you of encoded data.</p>

<p>The sample you have doens't provide a base64 encoded variant of the data but a hexadecimal representation.</p>

<p>In your case, just swap out the <a href=""http://php.net/manual/en/function.base64-encode.php"" rel=""nofollow noreferrer"">base64_encode</a> for <a href=""http://php.net/manual/en/function.bin2hex.php"" rel=""nofollow noreferrer"">bin2hex</a> and the answer should match up.</p>

<pre><code>function aes128Encrypt($data, $key) {
  $padding = 32 - (strlen($data) % 32);
  $data .= str_repeat(chr($padding), $padding);
  return bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_ECB));
}
$data = ""2874838-49"";
$key = ""keyshouldbeplacedhere"";    
echo aes128Encrypt($data, $key);
</code></pre>
","67","<php><encryption><aes><pkcs#7><ecb>","1","1","1","2018-08-01 13:23:04","51633883","8","","7801160","","2018-08-01 13:23:04","2018-08-01 10:45:36",""
"39651411","SMIME with BIO, char * and binary data","<p><strong>The problem</strong></p>

<p>1- I'd like to create a MIME message. Something like this:</p>

<pre><code>MIME-Version: 1.0
Content-Type: multipart/mixed;
        boundary=""---12345""

This is a multipart message in MIME format.

---12345
Content-Type: text/plain

This is the plain text

---12345
Content-Type: application/pdf

&gt;&gt; PDF binary code here &lt;&lt;

---12345
</code></pre>

<p>2- Then i need to pass it to the OpenSSL functions in the form of <code>BIO * data</code>.</p>

<pre><code>PKCS7 *PKCS7_sign(..., ..., ..., BIO *data, ...);
</code></pre>

<p><strong>The first approach</strong></p>

<p>Load the plain text and attachment data from the filesystem and assign it to <code>char * data</code>, manipulate the data to add the respective MIME headers, finally assign it to <code>BIO * memoryBIO</code> with <code>BIO_puts(memoryBIO, data);</code>.</p>

<p>But this approach doesnt work because the binary data contains ""\0""(NULL) which wont go well with <code>char</code> type.</p>

<p><strong>The second approach</strong></p>

<p>Assign plain text and attachment to a <code>BIO</code> <em>each</em> and then ""concatenate"" them. But couldn't find a way to do this.</p>

<p><strong>Conclusion</strong></p>

<p>I'd like to know if there is a way to accomplish such feat.
I'd also like to avoid using intermediary files and build everything in-memory.</p>
","<p>After following jww's suggestion, what i ended up using is <code>BIO_write();</code>.</p>

<pre><code>BIO * inBIO = NULL;
std::vector&lt;unsigned char&gt; data = GetData();
inBIO = BIO_new(BIO_s_mem());
BIO_write(inBIO, data.data(), data.size());
</code></pre>

<p>Again thanks to jww for this answer and for all the other answers regarding OpenSSL in SO, you've helped me a great deal.</p>
","66","<c><openssl><pkcs#7><smime>","0","0","1","2016-10-09 00:21:51","39938751","5","","608639","","2016-09-23 04:20:43","2016-09-23 01:58:24",""
"50227261","Extract PKCS7 Container memory leak during receipt validation","<p>XCode detected memory leaks in one of my function:
<a href=""https://i.stack.imgur.com/8mIzn.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8mIzn.jpg"" alt=""enter image description here""></a></p>

<p>The func is responsible for extracting PKCS7 container. Here the code of the func:</p>

<pre><code>func extractPKCS7Container() throws -&gt; UnsafeMutablePointer&lt;PKCS7&gt; {
    guard let receiptURL = Bundle.main.appStoreReceiptURL,
        let certificateURL = Bundle.main.url(forResource: ""AppleIncRootCertificate"", withExtension: ""cer""),
        let receiptData = NSData(contentsOf: receiptURL),
        let certificateData = NSData(contentsOf: certificateURL) else {
            throw ReceiptError.couldNotFindReceipt
    }
    let bio = BIOWrapper(data: receiptData)
    let p7 = d2i_PKCS7_bio(bio.bio, nil)
    guard p7 != nil else {
        throw ReceiptError.emptyReceiptContents
    }
    OpenSSL_add_all_digests()

    let x509Store = X509StoreWrapper()
    let certificate = X509Wrapper(data: certificateData)
    x509Store.addCert(x509: certificate)
    let payload = BIOWrapper()
    guard PKCS7_verify(p7, nil, x509Store.store, nil, payload.bio, 0) == 1 else {
        throw ReceiptError.receiptNotSigned
    }
    return p7!
}
</code></pre>

<p>I also have supplementary classes:</p>

<pre><code>class BIOWrapper {
    let bio = BIO_new(BIO_s_mem())
    init(data:NSData) {
        BIO_write(bio, data.bytes, Int32(data.length))
    }
    init() {}
    deinit {
        BIO_free(bio)
    }
}

class X509StoreWrapper {
    let store = X509_STORE_new()
    deinit {
        X509_STORE_free(store)
    }
    func addCert(x509:X509Wrapper) {
        X509_STORE_add_cert(store, x509.x509)
    }
}

class X509Wrapper {
    let x509 : UnsafeMutablePointer&lt;X509&gt;!
    init(data:NSData){
        let certBIO = BIOWrapper(data: data)
        x509 = d2i_X509_bio(certBIO.bio, nil)
    }
    deinit {
        X509_free(x509)
    }
}
</code></pre>

<p>All wrappers has init and deinit section. Other functions is from the build-in Crypto module... Frankly, I have no idea there the leak can be here. Could anyone help me?</p>
","<p>You are allocating a <code>PKCS7</code> object but it seems you are never calling <code>PKCS7_free</code>. For example, you would need to call it right before <code>throw ReceiptError.receiptNotSigned</code>.</p>

<p>Notice in the stack trace on the right there are stack frames missing. You can view them by clicking on the icon the looks like a square with a line above and below that. That way you know exactly which function call is responsible for the allocation (and thus likely what it is that leaked).</p>
","61","<swift><pkcs#7><receipt-validation>","0","0","1","2018-05-08 06:49:37","50227520","0","","","","","2018-05-08 06:29:05",""
"38857956","Why is my original purchase version always displayed as 1.0?","<p>I am attempting to extract the user's receipt to ascertain what their original purchase version was by using the following code:</p>

<pre><code>if attr_type == 19 {
                // Bundle version
                var str_ptr = ptr
                var str_type: Int32 = 0
                var str_length = 0
                var str_xclass: Int32 = 0
                ASN1_get_object(&amp;str_ptr, &amp;str_length, &amp;str_type, &amp;str_xclass, seq_end - str_ptr)

                if str_type == V_ASN1_UTF8STRING {
                    originalPurchaseVersion = NSString(bytes: str_ptr, length: str_length, encoding: NSUTF8StringEncoding)

                securityInfo.originalPurchaseDate = originalPurchaseVersion as! String                        
                }
</code></pre>

<p>However, I set up a testflight beta programme and the user that is testing has previously purchased version 1.32, however, the returned value is always version 1.0. </p>
","","61","<ios><swift><pkcs#7><receipt-validation>","1","","0","2016-08-09 22:04:49","","3","","608639","","2016-08-09 22:04:49","2016-08-09 18:28:28",""
"26930911","Where to put information about padding length?","<p>I'm working on AES encryptor and decryptor. I've decided to use PKCS#7. And now, I've no idea where to put information about padding length. I've read that I can read last byte (==n) and check if it's lower than 16. If it's true i can check n bytes if they are equal n. But here is a thing. What if the last block to encrypt has 16 bytes and looks like this for exmaple:</p>

<pre><code>{0x01, 0xfa,..., 0xf1, 0x02, 0x02}
</code></pre>

<p>After decryption, decryptor will read it and decide that two last bytes are padded (in fact they are not).</p>

<p>Should I add byte at the begining of a file with length, and decryptor will read it and start decrypting from second byte?</p>
","<p>The best practice is to add 32bit prefix with the actual length before encrypted data.</p>
","60","<encryption><aes><pkcs#7>","1","-1","2","2014-11-14 13:43:52","26931284","2","","","","","2014-11-14 13:18:05",""
"26930911","Where to put information about padding length?","<p>I'm working on AES encryptor and decryptor. I've decided to use PKCS#7. And now, I've no idea where to put information about padding length. I've read that I can read last byte (==n) and check if it's lower than 16. If it's true i can check n bytes if they are equal n. But here is a thing. What if the last block to encrypt has 16 bytes and looks like this for exmaple:</p>

<pre><code>{0x01, 0xfa,..., 0xf1, 0x02, 0x02}
</code></pre>

<p>After decryption, decryptor will read it and decide that two last bytes are padded (in fact they are not).</p>

<p>Should I add byte at the begining of a file with length, and decryptor will read it and start decrypting from second byte?</p>
","<p>PKCS#7 padding is deterministic. That means that unpadding should always be able to find out the padding length itself. So you first decrypt, then take the last byte (as number) and that is the padding length. <strong>For this to work, PKCS#7 padding is <em>always</em> applied. So the amount of padding, and thus the value of the bytes, is 1 to the blocksize, which is 16 bytes for AES.</strong> . If the plaintext is already dividable by 16, a full block of padding - with bytes valued 16 / 0x10 is applied. </p>

<p>In short, the calculation is:</p>

<pre><code>p = n - l % n
</code></pre>

<p>where <code>p</code> is the pad size &amp; value, <code>n</code> is the block size and <code>l</code> is the size of the plaintext.</p>
","60","<encryption><aes><pkcs#7>","1","3","2","2014-11-14 13:43:52","26931284","2","","","","","2014-11-14 13:18:05",""
"57263676","How to use PHP PKCS7 encrypt decrypt in JAVA","<p>I'm using JAVA for the 2c2p(<a href=""https://developer.2c2p.com/docs/status-inquiry"" rel=""nofollow noreferrer"">https://developer.2c2p.com/docs/status-inquiry</a>) API, but they're using PHP, and I don't know how to implement the openssl_pkcs7_encrypt method of PHP in JAVA</p>

<p>I searched for the implementation of node.js(<a href=""https://stackoverflow.com/questions/14037917/pkcs7-encrypt-decrypt-in-node-js"">PKCS7 encrypt decrypt in Node.js</a>), but I couldn't find the Java implementation</p>

<p>This is a PHP code example provided by 2c2p</p>

<pre><code>function encrypt($text,$publickey)
{
    //write text to file
    if(!file_exists( dirname(__FILE__).""/tmp/""))
    {
        mkdir( dirname(__FILE__).""/tmp/"");
    }
    $filename = dirname(__FILE__).""/tmp/"".time()."".txt"";
    $this-&gt;text_to_file($text,$filename);
    $filename_enc = dirname(__FILE__).""/tmp/"".time()."".enc"";

    $key = file_get_contents($publickey);
    if (openssl_pkcs7_encrypt($filename, $filename_enc, $key,
    array())) {
        // message encrypted - send it!
        unlink($filename);
        if (!$handle = fopen($filename_enc, 'r')) {
                 echo ""Cannot open file ($filename_enc)"";
                 exit;
            }

            $contents = fread($handle, filesize($filename_enc));
            fclose($handle);
            $contents = str_replace(""MIME-Version: 1.0
            Content-Disposition: attachment; filename=\""smime.p7m\""
            Content-Type: application/pkcs7-mime; smime-type=enveloped-                             data; name=\""smime.p7m\""
            Content-Transfer-Encoding: base64
            "","""",$contents);
            $contents = str_replace(""\n"","""",$contents);
            unlink($filename_enc);
            return $contents;
    }
}
</code></pre>
","","55","<java><php><pkcs#7>","1","","0","2019-07-30 02:45:33","","1","","","","","2019-07-30 02:45:33",""
"57567688","How to compose a PKCS#7 signature file correctly?","<p>I'm trying to use the Botan library to generate a detached signature file. The resulting signature file is not validated by OpenSSL (no other checks). Prompt in what there can be an error of formation of the signature file. </p>

<p>A couple of keys for signing and the certificate is stored in the HSM, it was not difficult to get them. For tests I use RSA keys and SoftHSM, later another key format and physical HSM will be used. PKCS#11 is used to communicate with HSM.</p>

<p>For create PKCS#7:</p>

<pre class=""lang-cpp prettyprint-override""><code>static const Botan::BigInt CMSVersion(1ull);

std::vector&lt;uint8_t&gt; createAttributes(std::vector&lt;uint8_t&gt; &amp;digestData)
{
  std::chrono::time_point&lt;std::chrono::system_clock&gt; time = std::chrono::system_clock::now();
  Botan::OID dataOID(""1.2.840.113549.1.7.1"");
  Botan::Attribute contentType(Botan::OIDS::str2oid(""PKCS9.ContentType""),
                               dataOID.BER_encode());
  Botan::X509_Time timeASN1(time);
  std::vector&lt;uint8_t&gt; attributesData;
  Botan::DER_Encoder attrib(attributesData);
  attrib.start_cons(Botan::ASN1_Tag(0),
                    Botan::ASN1_Tag(Botan::ASN1_Tag::CONTEXT_SPECIFIC));
  attrib.encode(contentType)
      .start_cons(Botan::ASN1_Tag::SEQUENCE)
        .encode(Botan::OID(""1.2.840.113549.1.9.5""))
        .start_cons(Botan::ASN1_Tag::SET).encode(timeASN1).end_cons()
      .end_cons()
      .start_cons(Botan::ASN1_Tag::SEQUENCE)
        .encode(Botan::OIDS::str2oid(""PKCS9.MessageDigest""))
        .start_cons(Botan::ASN1_Tag::SET)
          .encode(digestData, Botan::ASN1_Tag::OCTET_STRING,
                  Botan::ASN1_Tag::OCTET_STRING, Botan::ASN1_Tag::UNIVERSAL)
        .end_cons()
      .end_cons();
  attrib.end_cons();
  return attributesData;
}
std::vector&lt;uint8_t&gt; createCMS(const Botan::AlgorithmIdentifier &amp;digestAlg,
                               Botan::X509_Certificate &amp;cert,
                               const Botan::AlgorithmIdentifier &amp;keyAlg,
                               std::vector&lt;uint8_t&gt; &amp;sigData,
                               std::vector&lt;uint8_t&gt; &amp;signedAttributes)
{
  Botan::secure_vector&lt;uint8_t&gt; msgData;
  Botan::DER_Encoder encoder(msgData);
  encoder.start_cons(Botan::ASN1_Tag::SEQUENCE).encode(CMSVersion)
          .start_cons(Botan::ASN1_Tag::SET).start_cons(Botan::ASN1_Tag::SEQUENCE)
            .encode(digestAlg.get_oid()).end_cons().end_cons();
  Botan::OID dataOID(""1.2.840.113549.1.7.1"");
      encoder.start_cons(Botan::ASN1_Tag::SEQUENCE).encode(dataOID).end_cons();
  encoder.start_cons(Botan::ASN1_Tag::UNIVERSAL, Botan::ASN1_Tag::PRIVATE)
          .encode(cert).end_cons();
  encoder.start_cons(Botan::ASN1_Tag::SET);
  Botan::secure_vector&lt;uint8_t&gt; signerInfoData;
  Botan::DER_Encoder signerInfo(signerInfoData);
  signerInfo.start_cons(Botan::ASN1_Tag::SEQUENCE);
  signerInfo.encode(CMSVersion);
  signerInfo.start_cons(Botan::ASN1_Tag::SEQUENCE)
         .encode(cert.issuer_dn())
         .encode(Botan::BigInt(cert.serial_number())).end_cons();
  signerInfo.start_cons(Botan::ASN1_Tag::SEQUENCE).encode(digestAlg.get_oid())
          .end_cons();
  signerInfo.raw_bytes(signedAttributes);
  signerInfo.encode(keyAlg)
          .encode(sigData, Botan::ASN1_Tag::OCTET_STRING,
                  Botan::ASN1_Tag::OCTET_STRING, Botan::ASN1_Tag::UNIVERSAL);        
  signerInfo.end_cons();
  encoder.raw_bytes(signerInfoData).end_cons().end_cons();
  std::vector&lt;uint8_t&gt; resulData;
  Botan::DER_Encoder result(resulData);
  result.start_cons(Botan::ASN1_Tag::SEQUENCE)
          .encode(Botan::OID(""1.2.840.113549.1.7.2""))
          .start_cons(Botan::ASN1_Tag::UNIVERSAL, Botan::ASN1_Tag::PRIVATE)
          .raw_bytes(msgData).end_cons().end_cons();
  return resulData;
}
</code></pre>

<p>To calculate the hash and signature using PKCS#11, as follows:</p>

<pre class=""lang-cpp prettyprint-override""><code> QFile input(m_content-&gt;text()), output(m_sigFile-&gt;text());
  if(!input.open(QFile::ReadOnly))
  {
    QMessageBox::critical(this, tr(""Error""),
                          tr(""Content file '%1' not open.\n""
                             ""Error message: %2"").arg(m_content-&gt;text())
                          .arg(input.errorString()));
    return;
  }
  Botan::PKCS11::PKCS11_X509_Certificate *cert = nullptr;
  Botan::Private_Key *key = nullptr;
  // –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–∞ –∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ –∏–∑ —Ç–æ–∫–µ–Ω–∞
  while(!input.atEnd())
    {
      static const qint64 maxLen = 1024;
      QByteArray data = input.read(maxLen);
      (*module)-&gt;C_DigestUpdate(session-&gt;handle(),
                                reinterpret_cast&lt;uchar*&gt;(data.data()),
                                data.size(), &amp;rv);
      if(rv != Botan::PKCS11::ReturnValue::OK)
      {
        QMessageBox::critical(this, tr(""Error""),
                              tr(""Digest not run.\nError code: 0x%3"")
                              .arg(static_cast&lt;int&gt;(rv), 0, 16));
        delete key;
        delete cert;
        delete session;
        delete slot;
        delete module;
        return;
      }
    }
    digest.resize(102400);
    ulong digestLen;
    (*module)-&gt;C_DigestFinal(session-&gt;handle(), digest.data(), &amp;digestLen, &amp;rv);
    if(rv != Botan::PKCS11::ReturnValue::OK)
    {
      QMessageBox::critical(this, tr(""Error""),
                            tr(""Digest not start.\nError code: 0x%3"")
                            .arg(static_cast&lt;int&gt;(rv), 0, 16));
      delete key;
      delete cert;
      delete session;
      delete slot;
      delete module;
      return;
    }
    digest.resize(digestLen);
    {
      Botan::PKCS11::PKCS11_RNG rng(*session);
      std::unique_ptr&lt;Botan::PK_Ops::Signature&gt; signer =
          key-&gt;create_signature_op(rng,
                                   ""EMSA3(SHA-256)"",
                                   """");
      signer-&gt;update(digest.data(), digest.size());
      std::vector&lt;uint8_t&gt; attr = createAttributes(digest);
      auto signData = signer-&gt;sign(rng);
      for(uint8_t i : signData)
        signature.push_back(i);
      Botan::AlgorithmIdentifier digAlg(""SHA-256"", {});
      auto fileData = createCMS(digAlg, *cert, key-&gt;algorithm_identifier(),
                                signature, attr);
      output.write(reinterpret_cast&lt;const char*&gt;(fileData.data()),
                   fileData.size());
      output.close();
    }
</code></pre>

<p>When checking the received signature file, OpenSSL says </p>

<pre><code>Verification failure
140365848428992:error:04091068:rsa routines:int_rsa_verify:bad signature:../crypto/rsa/rsa_sign.c:220:
140365848428992:error:2E09A09E:CMS routines:CMS_SignerInfo_verify_content:verification failure:../crypto/cms/cms_sd.c:842:
140365848428992:error:2E09D06D:CMS routines:CMS_verify:content verify error:../crypto/cms/cms_smime.c:393:
</code></pre>
","","53","<c++><pkcs#7><botan>","1","","0","2019-08-21 06:32:28","","0","","608639","","2019-08-21 06:32:28","2019-08-20 06:20:09",""
"57051363","Read xml PKCS7 response and embed to pdf C#","<p>Have xml response which have random string in PKCS7 format. I need to embed that PKCS7 string to pdf.</p>

<pre><code>What is the step to do the same in asp.net c#
</code></pre>

<p>Find Input xml file <a href=""https://pastebin.com/aRkc9veq"" rel=""nofollow noreferrer"">Input XML</a></p>

<p><strong>Output</strong>
Digital signed pdf</p>

<p>Have tried below mentioned code</p>

<pre><code>string str = ""which contains pkcs7 string"";
    string file = @""D:\Sourcefile.pdf"";
    string targetDir = @""D:\"";
    string fileName = ""targetFile.pdf"";
    PdfReader reader = new PdfReader(file);
    using (FileStream fout = new FileStream(targetDir + fileName, FileMode.Create))
    {
            PdfStamper stp = PdfStamper.CreateSignature(reader, fout, '\0', null, true);
            PdfSignatureAppearance pdfSignatureAppearance = stp.SignatureAppearance;
            byte[] sigbytes = Convert.FromBase64String(str);
            int contentEstimated = 8192 * 2;
            byte[] paddedSig = new byte[contentEstimated];
            Array.Copy(sigbytes, 0, paddedSig, 0, sigbytes.Length);
            PdfDictionary dic2 = new PdfDictionary();
            dic2.Put(PdfName.CONTENTS, new PdfString(paddedSig).SetHexWriting(true));
            Dictionary&lt;PdfName, int&gt; exc = new Dictionary&lt;PdfName, int&gt;();
            exc[PdfName.CONTENTS] = contentEstimated * 2 + 2;
            pdfSignatureAppearance.PreClose(exc);
            pdfSignatureAppearance.Close(dic2);
        }
</code></pre>

<p>But getting error as ""Unknown filter: {1}""</p>
","","51","<c#><asp.net><digital-signature><pkcs#7>","0","","0","2019-07-22 12:16:54","","2","2","1520781","","2019-07-22 12:16:54","2019-07-16 06:38:25",""
"56016755","In C# Why signature visualization not showing signer name in pdf when signed by Itextsharp library?","<p>Here is the code that create signature appearance before signing document.</p>

<pre><code>PdfStamper stamper = PdfStamper.CreateSignature(reader, os, '\0');
// Creating the appearance
PdfSignatureAppearance appearance = stamper.SignatureAppearance;
appearance.Reason = ""Lorem apsum"";
appearance.Contact = """";
appearance.Location = """";
appearance.SignatureRenderingMode = PdfSignatureAppearance.RenderingMode.DESCRIPTION;
appearance.CertificationLevel = PdfSignatureAppearance.NOT_CERTIFIED;
appearance.SetVisibleSignature(new iTextSharp.text.Rectangle(10, 10, 149, 69), reader.NumberOfPages, ""Page1_Loc_5"");
//Creating the appearance
</code></pre>

<p>Here Contact property is empty that I want to fill with Name of the signer</p>

<p>I am getting name of the signer from userX509Certificate.</p>

<pre><code>string responseXML = System.IO.File.ReadAllText(Server.MapPath(""~/ResponseSignatureXML.txt""));
XmlDocument xmlDoc = new XmlDocument();
xmlDoc.LoadXml(responseXML);
XmlElement EsignResp = xmlDoc.DocumentElement;
XmlNodeList nodeList = xmlDoc.GetElementsByTagName(""UserX509Certificate"");
Byte[] Certificate = Encoding.UTF8.GetBytes(nodeList[0].FirstChild.InnerText);

X509Certificate cert = new X509Certificate(Certificate);
string CertificateIssuedTo = cert.GetName();
</code></pre>

<p>@Note: this signer name is not available while preparing the signature appearance.  </p>

<p>After preparing file with appearance. calculate the hash of that file(i.e src file) and call external service, in response I am getting xmlsiganture, which I used to place the signature on my document.  </p>

<p>How do I append/change signature visualization in my src file before placing signature?  </p>

<p>code that place the signature on document.(signature response with pkcs7 signature)</p>

<pre><code>XmlNodeList nodeList = xmlDoc.GetElementsByTagName(""Signatures"");
string signature = nodeList[0].FirstChild.InnerText;
using (PdfReader reader = new PdfReader(src))
{
    using (FileStream os = new FileStream(dest, FileMode.Create))
    {
        byte[] encodedSignature = Convert.FromBase64String(signature);
        IExternalSignatureContainer external = new MyExternalSignatureContainer(encodedSignature);
        MakeSignature.SignDeferred(reader, ""Page1_Loc_5"", os, external);
    }
}
</code></pre>

<p>Here Digitally signed by is showing blank instead of signer name.</p>

<p><a href=""https://i.stack.imgur.com/3w5v2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3w5v2.png"" alt=""enter image description here""></a></p>

<p>Here is screenshot from documentation which I am referring for <a href=""https://itextpdf.com/de/resources/books/digital-signatures-pdf/intro"" rel=""nofollow noreferrer"">digital signature</a>. <a href=""https://git.itextsupport.com/projects/I5NS/repos/tutorial/browse/signatures/chapter2/C2_01_SignHelloWorld/C2_01_SignHelloWorld.cs"" rel=""nofollow noreferrer"">C# Code</a>   How it is showing <em>Digitaly signed by Bruno Spiceman</em> as signer name
<a href=""https://i.stack.imgur.com/S2t68.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/S2t68.png"" alt=""enter image description here""></a></p>
","","50","<c#><itext><digital-signature><x509certificate><pkcs#7>","1","","0","2019-05-07 09:30:57","","6","1","5326667","","2019-05-07 09:30:57","2019-05-07 06:31:15","2019-05-07 15:38:31"
"38175804","How clean a X509 certified file","<p>I made a routine to sign some proprietary binary files with PKCS#7 X509 certificates. The routine is functioning like a charm:</p>

<pre><code>    public static byte[] SignFile(X509Certificate2Collection certs, byte[] data, bool Tipo_A3 = false)
    {
        try
        {
            ContentInfo content = new ContentInfo(data);
            SignedCms signedCms = new SignedCms(content, false);
            if (VerifySign(data))
            {
                signedCms.Decode(data);
            }
            foreach (X509Certificate2 cert in certs)
            {

                CmsSigner signer = new CmsSigner( cert);
                signer.IncludeOption = X509IncludeOption.WholeChain;
                signer.SignerIdentifierType = SubjectIdentifierType.IssuerAndSerialNumber;

                signer.SignedAttributes.Add(new Pkcs9SigningTime(System.DateTime.Now));

                if (Type_A3 == true)
                {
                    signedCms.ComputeSignature(signer, false);
                }
                else
                {
                    signedCms.ComputeSignature(signer);
                }

            }
            return signedCms.Encode();
        }
        catch (Exception ex)
        {
            MessageBox.Show(""Error: "" + ex.Message);
            return null;
        }

    }
</code></pre>

<p>My problem is related to RECOVER the original info. An 1Kb file will be transformed in a ~8Kb file, since the signature in within this file.</p>

<p>I need to read the data <em>without the signature/certificate</em> within the file, I mean, I need to recover the original data before its signing - and I don't know how to do it.</p>

<p>I saw that the signed file has bytes BEFORE and AFTER its original contents (I made a test using a tiny TXT file with ""abcd""), but I'm affraid to consider ever the same data length before and after the original data to extract it.</p>

<p>I know I get the original content using this function, where DATA is the signed file:</p>

<pre><code> using System;
 using System.Collections.Generic;
 using System.Security.Cryptography.X509Certificates;
 using System.Security.Cryptography.Pkcs;
 using System.IO;
 using System.Windows.Forms;

     public static Int VerifyContentInfo(byte[] data)
        {
           try
           {
            SignedCms signed = new SignedCms();
            signed.Decode(data);
            signed.CheckSignature(true);

            return signed.ContentInfo.Content.Length

           }
             catch
           {
             return null;
           }

        }
</code></pre>

<p><strong>The problem: even knowing the length of the original data within the signed file, how securely locate and extract it using a .NET function?</strong> </p>

<p>Thanks for any help!</p>
","<p><code>signed.ContentInfo.Content</code> (whose value you took the length of) is the original content.</p>
","48","<c#><.net><x509certificate><pkcs#7>","0","1","1","2016-07-12 14:49:42","38332223","4","","","","","2016-07-04 01:24:05",""
"57477845","128 bit AES decryption PKCS7 padding problems","<p>I'm trying to convert this c# function to a python script, but am running into trouble. I seem to be getting the same byte values as my c# function for my converted values but when i try and remove padding on my decoded 64 byte string, I get told ""ValueError: Input is not padded or padding is corrupt"". Looking for any help</p>

<pre><code>private static string TestDecrypt(string input)
    {
        string result = """";
        //The decryption needs to only handle one layer of Base64 encoding.
        var base64EncodedBytes = System.Convert.FromBase64String(input);
        ///string decoded = System.Text.Encoding.UTF8.GetString(base64EncodedBytes);
        using (MemoryStream ms = new MemoryStream())
        {

            using (RijndaelManaged AES = new RijndaelManaged())
            {
                AES.KeySize = 128;
                AES.BlockSize = 128;

                var testIdBytes = ConvertLongToByteArr(testId);

                var bigArray = new byte[16];
                testIdBytes.CopyTo(bigArray, 8);

                byte[] IVbytes = Encoding.ASCII.GetBytes(salt).Reverse().ToArray();

                AES.Mode = CipherMode.CBC;
                AES.Padding = PaddingMode.PKCS7;

                AES.IV = IVbytes;
                AES.Key = bigArray;

                using (var cs = new CryptoStream(ms, AES.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(base64EncodedBytes, 0, base64EncodedBytes.Length);
                    cs.Close();
                }
                var resultBytes = ms.ToArray();
                Console.WriteLine(""After decryption : "" + string.Concat(resultBytes.Select(b =&gt; b.ToString(""X2"")).ToArray()));
                result = Convert.ToBase64String(resultBytes);

                testClass tc = new testClass(resultBytes);

            }
        }
        return result;
    }
</code></pre>

<p>Python Code</p>

<pre><code> def Decrypt(self):
    #encrypted base 64 string decoded
    b64decoded = base64.b64decode(""2YK4Eev6GE7Tu+bpKX3V9iFrMavPMYQPZxNoHQBUiFgZKId2WEndvyOzvpIly4n2pVKUK6XqYX26pJzyHvT1bw=="")

    IVBytes = self.ConvertStringToBytes(self.Salt)[::-1]
    key = '\x00' * 8 + self.ConvertLongToBytes(self.EventId) + ('\x00' * 4)
    encoder = PKCS7Encoder()
    iv =  self.Salt[::-1].encode('ascii')

    encryptor = AES.new(key, AES.MODE_CBC, iv)

    encoder = PKCS7Encoder()
    depadded = encoder.decode(""b64decoded "")
    decrypted= encryptor.decrypt(depadded)
</code></pre>

<p>the PKCS7 library Im using</p>

<pre><code>import binascii
import StringIO

class PKCS7Encoder(object):
     '''
     RFC 2315: PKCS#7 page 21
     Some content-encryption algorithms assume the
     input length is a multiple of k octets, where k &gt; 1, and
     let the application define a method for handling inputs
     whose lengths are not a multiple of k octets. For such
     algorithms, the method shall be to pad the input at the
     trailing end with k - (l mod k) octets all having value k -
     (l mod k), where l is the length of the input. In other
     words, the input is padded at the trailing end with one of
     the following strings:

              01 -- if l mod k = k-1
             02 02 -- if l mod k = k-2
                         .
                         .
                         .
           k k ... k k -- if l mod k = 0

     The padding can be removed unambiguously since all input is
     padded and no padding string is a suffix of another. This
     padding method is well-defined if and only if k &lt; 256;
     methods for larger k are an open issue for further study.
     '''
     def __init__(self, k=16):
         self.k = k

     ## @param text The padded text for which the padding is to be removed.
     # @exception ValueError Raised when the input padding is missing or corrupt.
     def decode(self, text):
         '''
         Remove the PKCS#7 padding from a text string
         '''
         nl = len(text)
         val = int(binascii.hexlify(text[-1]), 16)
         if val &gt; self.k:
             raise ValueError('Input is not padded or padding is corrupt')

         l = nl - val
         return text[:l]

     ## @param text The text to encode.
     def encode(self, text):
         '''
         Pad an input string according to PKCS#7
         '''
         l = len(text)
         output = StringIO.StringIO()
         val = self.k - (l % self.k)
         for _ in xrange(val):
             output.write('%02x' % val)
         return text + binascii.unhexlify(output.getvalue())
</code></pre>
","","46","<c#><python><python-2.7><aes><pkcs#7>","1","","0","2019-08-13 12:35:06","","1","","","","","2019-08-13 12:35:06",""
"38668481","How remove a single X509 signature?","<p>I'm trying to remove just the last signature of a file signed by <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.pkcs.signedcms(v=vs.110).aspx"" rel=""nofollow"">SignedCMS</a>.</p>

<p>The function is called <a href=""https://msdn.microsoft.com/en-us/library/ysxt16y4(v=vs.110).aspx"" rel=""nofollow"">RemoveSignature</a> and it requires an index, which reflects the signature I need to discard from the signed data.</p>

<p>I didn't find any help in Google about how to utilize it.</p>

<p>I made the following code, where <em>data</em> is the signed file in a byte array, which contains <strong>three X509 signatures</strong>:</p>

<pre><code>        Dim Contents As New ContentInfo(data)
        Dim signed As New SignedCms(Contents)
        signed.Decode(data)
        signed.RemoveSignature(0)
        dim ResultCode as byte() = signed.ContentInfo.Content
</code></pre>

<p>The code functions normally (no errors at all) but <strong>always removes all</strong> signatures within the file! Even if I change the index from 0 to 1 or 2, the result is always the file data  <strong>clean of all its signatures</strong>!</p>

<p>Does anyone knows how to remove just the signature pointed by the index of that function (RemoveSignature)?</p>

<p>Thanks for any help!</p>
","","44","<c#><.net><pkcs#7>","1","","0","2016-07-29 22:41:50","","0","","","","","2016-07-29 22:41:50",""
"56611921","Remove first part of xml file, cannot be serialized","<p>I have an xml file it start like: </p>

<pre><code>'''some non ascii character'''
&lt;b:FatturaElettronica xmlns:b=""#""&gt;
  &lt;FatturaElettronicaHeader&gt;
    &lt;DatiTrasmissione&gt;
      &lt;IdTrasmittente&gt;
        &lt;IdPaese&gt;IT&lt;/IdPaese&gt;
</code></pre>

<p>i need to remove all until </p>

<pre><code>&lt;FatturaElettronicaHeader&gt;
</code></pre>

<p>now the code is:</p>

<pre><code>import xml.etree.ElementTree as ET
import xml.etree.ElementTree as ETree
from lxml import etree

parser = etree.XMLParser(encoding='utf-8', recover=True, remove_comments=True, resolve_entities=False)
tree = ETree.parse('test.xml', parser)

root = tree.getroot()

print etree.tostring(root)
</code></pre>

<p>and give me:</p>

<pre><code>Traceback (most recent call last):
  File ""xml2.py"", line 14, in &lt;module&gt;
    print etree.tostring(root)
  File ""src/lxml/etree.pyx"", line 3350, in lxml.etree.tostring
TypeError: Type 'NoneType' cannot be serialized.
</code></pre>

<p>whitout the first part of xml file it work.</p>

<p>TY</p>
","<p>you could use the <strong>find()</strong> function to search for the first bracket.</p>

<pre><code>import xml.etree.ElementTree as ET

with open ('...XMLFILE.xml', 'r') as file:
    filestring = file.read()

XML_start = filestring.find('&lt;')
print(XML_start) #gives 31

tree = ET.fromstring(filestring[XML_start:])

for i in tree.iter():
    print(i.tag) #gives {#}FatturaElettronica, FatturaElettronicaHeader, ... 
</code></pre>

<p>but also your xml-file has to be correct:</p>

<pre><code>'''some non ascii character'''
&lt;b:FatturaElettronica xmlns:b=""#""&gt;
  &lt;FatturaElettronicaHeader&gt;
    &lt;DatiTrasmissione&gt;
      &lt;IdTrasmittente&gt;
        &lt;IdPaese&gt;IT&lt;/IdPaese&gt;
        &lt;/IdTrasmittente&gt;
    &lt;/DatiTrasmissione&gt;
&lt;/FatturaElettronicaHeader&gt;
&lt;/b:FatturaElettronica&gt;
</code></pre>
","43","<python><django><xml><parsing><pkcs#7>","0","0","1","2019-06-17 07:53:54","","6","","2226988","","2019-06-16 13:43:31","2019-06-15 15:54:50",""
"54626550","What does SignedCms.decode() do in c#","<p>I want to implement SignedCms.decode() function in c++ but I don't know what does it do like code? all I know is that SignedCms.encode() generate BER encoded bytes and I am not even sure about that.
Any help is greatly appreciated.
Thanks in advance. </p>
","<p>I wouldn't recommend that you implement your own SignedCms.decode since that would involve implementing an ASN.1 reader which is a complex task.</p>

<p>If you are on Windows OS, i would recommend taking a look at this: <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode"" rel=""nofollow noreferrer"">CryptMsgOpenToDecode function</a></p>
","41","<c#><c++><openssl><pkcs#7>","0","0","1","2019-02-11 08:39:44","54626643","3","","","","","2019-02-11 08:32:49",""
"58428955","Encrypted in java (Android) failing in python AES decryption","<p>I am trying to decrypt a java AES encrypted code into python script but it's failing to decrypt completely, means some of initial data does not decrypted but rest of data decrypted fine. Below is python code - </p>

<pre><code>decryptor = Cipher(
            algorithms.AES(self._encryption_key),
            modes.CBC(initialization_vector),
            self._backend
        ).decryptor()
        plaintext_padded = decryptor.update(ciphertext)
        try:
            plaintext_padded += decryptor.finalize()
        except ValueError:
            raise InvalidToken
        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()

        unpadded = unpadder.update(plaintext_padded)
        try:
            unpadded += unpadder.finalize()
        except ValueError:
            raise InvalidToken
</code></pre>

<p>And below is my java code that can ecnrypt and decrypt successfully it's own generated cipher to plain and vice versa. </p>

<pre><code>aesCipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
.
.
static SecretKey generateSecretKey() {

        SecretKeyFactory pbeKeyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1And8bit"");
        SecretKey secretKey;
        try {
            SecureRandom rand = new SecureRandom();
            byte[] salt = new byte[32];
            rand.nextBytes(salt);
            // WORK-AROUND change rand.nextInt(2048) to rand.nextInt(2047) + 1 to genterate 1-2048;
            int iterationCount = rand.nextInt(2047) + 1;
            KeySpec pbeKeySpec = new PBEKeySpec(new String(rand.generateSeed(24)).toCharArray(), salt, iterationCount, 256);
            SecretKey pbeKey = pbeKeyFactory.generateSecret(pbeKeySpec);
            secretKey = new SecretKeySpec(pbeKey.getEncoded(), ""AES"");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return secretKey;
    }

    static SymmetricEncryptionEntry symmetricEncrypt(SecretKey key, String data) {

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
        SymmetricEncryptionEntry entry;
        try {
            byte[] iv = generateIv(cipher.getBlockSize());
            IvParameterSpec ivParams = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);
            byte[] cipherText = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
            entry = new SymmetricEncryptionEntry(cipherText , iv);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return entry;
    }

    private static byte[] generateIv(int length) {
        byte[] b = new byte[length];
        new SecureRandom().nextBytes(b);

        return b;
    }
</code></pre>

<p>Below is the real plain text and decrypted plain text - </p>

<p><strong>expected by python decryption</strong> </p>

<pre><code>b'{""auth_key"":""eyJhbGciOiJSUzI1NiIsImtpZCI6ImZhMWQ3NzBlZWY5ZWFhNjU0MzY1ZGE5MDhjNDIzY2NkNzY4ODkxMDUiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vY2hhdHEtc3RhZ2luZyIsImF1ZCI6ImNoYXRxLXN0YWdpbmciLCJhdXRoX3RpbWUiOjE1NzExMjM5NDcsInVzZXJfaWQiOiJyQ3N0aTBoMEczVUZmVWk2Q1oxYjNJOEJmOVIyIiwic3ViIjoickNzdGkwaDBHM1VGZlVpNkNaMWIzSThCZjlSMiIsImlhdCI6MTU3MTIwMjY4OSwiZXhwIjoxNTcxMjA2Mjg5LCJwaG9uZV9udW1iZXIiOiIrODQxMjM0NTY3ODIiLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7InBob25lIjpbIis4NDEyMzQ1Njc4MiJdfSwic2lnbl9pbl9wcm92aWRlciI6InBob25lIn19.0OCskQkPKq5yxku02PuBgoZMFHgMfZBVPptQaVExrWYRDrEM3uUwDrDXAWiqA6L9i54fg_7dfWBwnPvQ71g4Lzsft60_JycS0-C_kSlCBxVSlX5J8WDTwNGm6p5-QDxN2bU9fwglzmggMst-4A3tLlPLQRnttuishFKhgr40ABHX8tksNfbs626YhTiwY6vD6_Gn0k7X7jh1HsHAUUcnPZq2tCXRFUKNDmF_4lC6vc7-Cs5zHpIlKtaAXoQBRe9HYsEvYfK2tOey8T_3mDC_Eh36fcve6HCOQBt9EtFPRIUcKZgFDWPoG70t-ABk66Lr2BjejbOsBBnA9R7492t6Sg"",""correlation_id"":""1fb572ff331346b7"",""user_id"":""rCsti0h0G3UFfUi6CZ1b3I8Bf9R2""}'
</code></pre>

<p><strong>Received by python decryption</strong></p>

<pre><code>b'\xae\xfa\x9c\xb3\x8c+\x17\xfeI\xc9\xb8\x0b\x0e@\xac\rhbGciOiJSUzI1NiIsImtpZCI6ImZhMWQ3NzBlZWY5ZWFhNjU0MzY1ZGE5MDhjNDIzY2NkNzY4ODkxMDUiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vY2hhdHEtc3RhZ2luZyIsImF1ZCI6ImNoYXRxLXN0YWdpbmciLCJhdXRoX3RpbWUiOjE1NzExMjM5NDcsInVzZXJfaWQiOiJyQ3N0aTBoMEczVUZmVWk2Q1oxYjNJOEJmOVIyIiwic3ViIjoickNzdGkwaDBHM1VGZlVpNkNaMWIzSThCZjlSMiIsImlhdCI6MTU3MTIwMjY4OSwiZXhwIjoxNTcxMjA2Mjg5LCJwaG9uZV9udW1iZXIiOiIrODQxMjM0NTY3ODIiLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7InBob25lIjpbIis4NDEyMzQ1Njc4MiJdfSwic2lnbl9pbl9wcm92aWRlciI6InBob25lIn19.0OCskQkPKq5yxku02PuBgoZMFHgMfZBVPptQaVExrWYRDrEM3uUwDrDXAWiqA6L9i54fg_7dfWBwnPvQ71g4Lzsft60_JycS0-C_kSlCBxVSlX5J8WDTwNGm6p5-QDxN2bU9fwglzmggMst-4A3tLlPLQRnttuishFKhgr40ABHX8tksNfbs626YhTiwY6vD6_Gn0k7X7jh1HsHAUUcnPZq2tCXRFUKNDmF_4lC6vc7-Cs5zHpIlKtaAXoQBRe9HYsEvYfK2tOey8T_3mDC_Eh36fcve6HCOQBt9EtFPRIUcKZgFDWPoG70t-ABk66Lr2BjejbOsBBnA9R7492t6Sg"",""correlation_id"":""1fb572ff331346b7"",""user_id"":""rCsti0h0G3UFfUi6CZ1b3I8Bf9R2""}'
</code></pre>

<p><strong>Basically, the beginning is messed up:</strong></p>

<pre><code>{""auth_key"":""eyJ != \xae\xfa\x9c\xb3\x8c+\x17\xfeI\xc9\xb8\x0b\x0e@\xac\r
</code></pre>

<p>Let me know in comment if I missed anything in question :-)</p>
","","40","<java><python><encryption><aes><pkcs#7>","0","","0","2019-10-18 05:32:33","","6","","3448003","","2019-10-18 05:32:33","2019-10-17 09:11:47",""
"57707117","how to encrypt zip file with p7b certificate and sign it with p12","<p>I have a p7b file which includes the public key the goal is to encrypted a zip file with this public key and change the file to .zip.encrypted and then use a .p12 file to sign the content</p>

<p><strong>Questions</strong> </p>

<p>Right now I'm trying to figure out how this works. Is this just pkcs#7 encryption or do I call it CMS Evelope? Since in the p7b file i only have a public rsa key how would I be able to encrypt a whole zip file with it? As far as I know you can only encrypt small bytes with RSA encryption. Is there somekind of bytestream that I can use to encrypt every single byte of a zip file by it self? Or do I generate somehow a AES key out of the public RSA key from the p7b file? Do I need to add the p7b certificate to my windows account to get access to the data inside? </p>

<p><strong>What I've tried</strong></p>

<p>I tried the .net recources and couldn't figure out how to get what I want, then I googled a lot found many examples how people encrypt a short string and tried to adapt but it was never working for me.</p>

<p>Now I'm using Bouncy Castle for c# and I think I was able to read the public key from my p7b file when I try to encrypt a normal short string, it seems to work. But when I use my zip file then I get an exception that my byte array is too big. The zip file I use for this test is only 3KB, the real files later will be up to ~200MB</p>

<p>So I guess the Way im using the p7b file aswell as bouncy castle for my problem is wrong.</p>

<p><strong>My Code</strong></p>

<pre><code> var p7bFilePath = @""key\Test.p7b"";
 var text = @""zipfile"";
 var bytesToEncrypt = File.ReadAllBytes(@""zip\test.zip"");
 var certi = ReadCertificate(p7bFilePath);
 var encodedPublicKey = certi.GetPublicKey();
 var encryptEngine = new Pkcs1Encoding(new RsaEngine());
 encryptEngine.Init(true, encodedPublicKey);
 var encrypted = Convert.ToBase64String(encryptEngine.ProcessBlock(bytesToEncrypt, 0, bytesToEncrypt.Length));

 Console.WriteLine(encrypted);
</code></pre>
","<p>Okay since I asked this question before just deleted it and reworte it a little with the hope somebody might help me I think I came to the solution with the help of a collegue:</p>

<pre><code>using Org.BouncyCastle.Asn1;
using Org.BouncyCastle.Cms;
using Org.BouncyCastle.Pkcs;
using Org.BouncyCastle.X509;
using System.IO;

namespace pkchwencrypting
{
    class Program
    {
        static void Main(string[] args)
        {
            var certificateData = File.ReadAllBytes(""YOUR_p7b_FILE"");
            var cert = new X509CertificateParser().ReadCertificate(certificateData);
//I just wanted to know if I can see the publicKey somehow            
//var publicKey = cert.GetPublicKey();

            var store = new Pkcs12Store(File.OpenRead(""YOUR_p12_File""), ""test"".ToCharArray());
            var privateKey = store.GetKey(""THE_NAME_OF_KEY_YOU_WANT_TO_GET"").Key;

            var signedDataGen = new CmsSignedDataGenerator();
            signedDataGen.AddSigner(privateKey, cert, CmsSignedDataGenerator.EncryptionRsa, CmsSignedDataGenerator.DigestSha512);

            var zipContent = new CmsProcessableFile(new FileInfo(""YOUR_DATA_FILE""));
//For me a zip
            var signedData = signedDataGen.Generate(zipContent, true);

            var envDataGen = new CmsEnvelopedDataGenerator();
            envDataGen.AddKeyTransRecipient(cert);

            var sData = new CmsProcessableByteArray(signedData.GetEncoded());
            var enveloped = envDataGen.Generate(sData, CmsEnvelopedDataGenerator.DesEde3Cbc);

            var dos = new DerOutputStream(File.OpenWrite(""YOUR_DATA_FILE.zip.encrypted.sig)""));
            var bytesToWrite = enveloped.GetEncoded();
            dos.Write(bytesToWrite, 0, bytesToWrite.Length);
            dos.Flush();
            dos.Close();


        }

    }
}
</code></pre>

<p>This might help somebody, maybe somebody can have a look at it, if this actually makes sense but it seems to do what it supposed to do. </p>
","38","<c#><bouncycastle><pkcs#7><pkcs#12>","0","0","1","2019-08-30 10:41:05","57725227","0","","9289362","","2019-08-30 10:34:08","2019-08-29 09:27:59",""
"53699035","iOS PKCS#7 how to decrypt P7M file ? have .pfx file now","<p>as the title said.
I have the .pfx file and .p7m file ,how can I decrypt the it ? 
in github , I searched the code </p>

<p><a href=""https://github.com/zkrige/iOS-pkcs7-decrypt"" rel=""nofollow noreferrer"">https://github.com/zkrige/iOS-pkcs7-decrypt</a></p>

<p>but can't do it.</p>

<p>platform : iOS</p>
","","37","<ios><encryption><pkcs#7>","0","","0","2018-12-10 03:15:35","","2","","","","","2018-12-10 03:15:35",""
"41033840","How to use openssl to add the CA to the trusted chain within the PFX","<p><em>First of all, I'd like to make it clear this is my very first time dealing with certificates/keys/pfx/etc.. so please correct me if I'm wrong :)</em></p>

<p>I'm having troubles add the CA of the server im connecting to, to my trusted chain using <code>openssl</code> in a PFX.</p>

<p>After creating the PFX I successfully added it to my computer using <code>mmc.exe</code> but found out its not gonna be useful as soon as i'll get the application running on a linux server.</p>

<p>I've been searching all over the net to find the correct command but couldnt find any.</p>

<p>A friend assumed I'll have to first export the certificate out of the existing pfx, then add the CA to its' trusted chain and generate a new pfx with it.</p>

<p>Unfortunately, couldn't find how to add to a certificate's trusted chain either.</p>

<p>Any help would be much appreciated! hope the question is clear enough, let me know if i could add anything to help you help me!</p>
","","36","<windows><ssl><certificate><pfx><pkcs#7>","0","","0","2016-12-08 09:28:43","","2","","608639","","2016-12-08 09:28:43","2016-12-08 07:16:24",""
"53536775","OpenSSL library sign data using PKCS7","<p>I want to sign a PDF document using OpenSSL library. I already know how to put signed data properly to the pdf. So I have instances of <code>X509</code> and <code>EVP_PKEY</code>, content in <code>unsigned char</code> and I want to get DER-encoded ASN1 data by signing the pdf content to put it into the pdf body. It seems like I need to use <code>PKCS7</code>, but I couldn't understand how exactly.</p>

<p>Would be grateful for some code examples or explanation. Maybe this approach is not correct at all.</p>
","","32","<c><openssl><signing><pkcs#7>","0","","0","2018-11-29 10:23:43","","1","","","","","2018-11-29 10:23:43",""
"57135584","Kleopatra: Decryption failed: invalid data","<p>For encrypting files I use PKCS # 7 and the Javascript bundle forge.pki.</p>

<pre><code>var forge = require('node-forge');

var contentBuffer = forge.util.createBuffer( forge.util.decode64( ""fasdasd asdasdasda"" ));

var cert = forge.pki.certificateFromPem(certPem);

var p7 = forge.pkcs7.createEnvelopedData();
p7.addRecipient(cert);
p7.content = contentBuffer;
console.log(""Encrypt..."");
p7.encrypt();

var asn1Cert = p7.toAsn1();

var derBuffer = forge.asn1.toDer(asn1Cert);

var p7mContent = derBuffer.toHex();

console.log(p7mContent);
</code></pre>

<p>I copy the hex value into my Java class as a string constant. Java saves then converts this into a .p7m file and stores it locally for me.</p>

<pre><code>public void writeDocumentContent(String filename) throws Exception {

        byte[] encryptedMessage = getP7MBytes(hex);

        InputStream inputStream = new ByteArrayInputStream(encryptedMessage);

        handleTransfer(inputStream, TransferKanal.HTML5);

    }

    private static byte[] getP7MBytes(String p7m) {
        int len = p7m.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i &lt; len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(p7m.charAt(i), 16) &lt;&lt; 4) + Character.digit(p7m.charAt(i + 1), 16));
        }
        return data;
    }

    private void handleTransfer(InputStream inputStream, TransferKanal kanal) throws Exception {
        String path = ""C:TEMP/padline"";
        createDirectory(path);
        String filename = ""example."" + kanal.getFileExtension();
        File targetFile = new File(path, filename);
        provideTransferData(inputStream, targetFile);
    }

    private void provideTransferData(InputStream inputStream, File targetFile) throws Exception {
        try (InputStream bInputStream = new BufferedInputStream(inputStream, 20 * 8192)) {
            provide(bInputStream, targetFile);
        } catch (IOException e) {
            throw new Exception(""error while reading/writing transfer data"", e);
        }
    }

    private boolean createDirectory(String directory) {
        File file = new File(directory);
        if (!file.exists()) {
            file.mkdirs();
            return true;
        }
        return false;
    }

    private void provide(InputStream is, File finalFile) throws Exception {
        try {

            File destFile   = new File(finalFile.getAbsolutePath());

            FileOutputStream buffer = null;
            try {
                buffer = new FileOutputStream(destFile);

                int nRead;
                byte[] buf = new byte[2 * 16384];

                while ((nRead = is.read(buf, 0, buf.length)) != -1) {
                    buffer.write(buf, 0, nRead);
                }

            } catch (Exception e) {
                throw new Exception(""provision location corrupted"", e);
            } finally {
                if (buffer != null) {
                    buffer.close();
                }
            }

        } catch (IOException e) {
            throw new Exception(""error copying file"", e);
        }
    }
</code></pre>

<p>Before, I create a bundle of the certificate and the private key via openSSL with following command:</p>

<pre><code>openssl pkcs12 -export -inkey private.key -in public.cert -out certificate.pfx
</code></pre>

<p>and imported it into Kleopatra as a .pfx file. Then I have the generated (encrypted) p7m file to decrypt in Cleopatra and pushed the following error message:</p>

<p>Decryption failed: invalid data</p>
","","31","<javascript><java><pkcs#7><forge>","2","","0","2019-07-21 18:44:50","","0","","8670262","","2019-07-21 18:44:50","2019-07-21 17:44:33",""
"55508441","war file deployment on tomcat 8.5","<p>I am using jenkins on centos 7 and building java spring build, here result and build is showing success but I am getting error :</p>

<blockquote>
  <p>org.codehaus.cargo.container.tomcat.internal.TomcatManagerException:
  The Tomcat Manager responded ""FAIL - Deployed application at context
  path [/erp] but context failed to start</p>
</blockquote>

<p>And at last:</p>

<blockquote>
  <p>Build step 'Deploy war/ear to a container' marked build as failure
  Finished: FAILURE</p>
</blockquote>

<p>I have tried war project working when i deploy directly on tomcat 8.5</p>
","","28","<pkcs#7>","0","","0","2019-04-04 08:29:10","","3","","11147851","","2019-04-04 08:29:10","2019-04-04 05:24:57",""
"55384753","AES between C# and PHP (or Javascript/ or Python)","<p>Client use C# to Encrypt String</p>

<p>And My application need to generate the same Encrypt String to match his Encrypt String</p>

<p>But I only can PHP/Javascript/Python</p>

<p>How can I write PHP or Javascript or Python code to generate the same Encrypt String</p>

<p>For example. Client use ""TAIEX"" will turn to ""JrmEfbwGlF7w67KemS2zWw==""</p>

<p>Some Info: AES, CBC, Rijndael, PKCS7, KeySize = 256, BlockSize = 128</p>

<p>Following C# code was provided from Client</p>

<pre><code>internal string GetAESEncryptString(string inputString)
{
    string password = @""076FD250140F11E2892E0800200C9A66"";
    string saltString = @""5738C760140F11E2"";
    byte[] binputString = Encoding.UTF8.GetBytes(inputString);
    byte[] saltBytes = Encoding.UTF8.GetBytes(saltString);
    string encryptedData = null;

    try
    {
        RijndaelManaged aes = new RijndaelManaged();
        Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, saltBytes, 100);
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;
        aes.KeySize = 256;
        aes.Key = key.GetBytes(32);
        aes.BlockSize = 128;
        aes.GenerateIV();
        aes.IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        //aes.IV = key.GetBytes(16);

        ICryptoTransform encryptor = aes.CreateEncryptor();
        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
        cryptoStream.Write(binputString, 0, binputString.Length);
        cryptoStream.FlushFinalBlock();
        cryptoStream.Close();

        byte[] encryptBytes = memoryStream.ToArray();
        encryptedData = Convert.ToBase64String(encryptBytes);
    }
    catch (Exception ex)
    {
        throw ex;
    }
    return encryptedData;
}
</code></pre>

<p>Thank you for taking the time. I thank you from the bottom of my heart.</p>
","","27","<python-2.7><aes><pkcs#7><cbc-mode>","0","","0","2019-03-27 19:05:04","","1","","","","","2019-03-27 19:05:04",""
"57326772","How can I use EnvelopedCms class to decrypt data, searching for certificates in multiple certificate stores?","<p>I'm converting the existing C# code which was written with interop and native calls to 100% managed code. The code is the API library which lets the caller to decrypt <code>S/MIME</code> messages by passing the encrypted data and the array of certificate stores where to search for the certificates.</p>

<p>With Win32 API (used by the current implementation of the API library I'm working on), <code>CryptDecryptMessage</code> accepts <code>CRYPT_DECRYPT_MESSAGE_PARA</code> structure which lets me specify the array of certificate stores to search (<code>rghCertStore</code> field). I can't find out how I can reproduce the same with <code>EnvelopedCms</code> class.</p>

<p><code>EnvelopedCms.Decrypt</code> method overloads let me specify the collection of certificates to search but I need the ability to specify the collection of certificate stores. Is it possible?</p>
","","25","<c#><pkcs#7><smime>","1","","0","2019-08-02 13:30:51","","5","","695182","","2019-08-02 13:30:51","2019-08-02 12:45:23",""
"55256138","PHP OpenSSL Verify P7 no detach","<p>I'm trying to translate the following openssl command to an openssl php function. The openssl cmd command executes and verifies successfully but my tries working with php functions fail (<code>openssl_pkcs7_verify</code>):</p>

<pre><code>openssl smime -verify -in encrypted.p7 -inform pem -noverify &gt; decrypted.txt
</code></pre>

<p>The encrypted.p7 file is signed with openssl -nodetach option and its content is:</p>

<pre><code>-----BEGIN PKCS7-----
MIIEFgYJKoZIhvcNAQcCoIIEBzCCBAMCAQExCzAJBgUrDgMCGgUAMD4GCSqGSIb3
DQEHAaAxBC9UaGlzIG1lc3NhZ2UgY291bGQgb25seSBoYXZlIGJlZW4gc2VudCBi
eSBtZS4NCqCCAgQwggIAMIIBaaADAgECAgkA0oEkvc7szMwwDQYJKoZIhvcNAQEF
BQAwGTEXMBUGA1UEAwwOUEtDUyM3IGV4YW1wbGUwHhcNMTMwNDEyMjAzMzE4WhcN
MTMwNTEyMjAzMzE4WjAZMRcwFQYDVQQDDA5QS0NTIzcgZXhhbXBsZTCBnzANBgkq
hkiG9w0BAQEFAAOBjQAwgYkCgYEAnvFUnLFlzYScwPXCTBdp+e3pBAV/wFc10gq2
bKCcHg6WgWrnW39HJxaYdn6Edzt8ipdTvX2Kl6iQXtjAIs8oI7YBdqxZMknddM1M
mvbe0HVYPoF0lIWiLLIySYeV6GC2X0eYyWE1FLs1qJsRSrHA8iHlDH4gngGMu71d
WCEbXg8CAwEAAaNQME4wHQYDVR0OBBYEFLLtIWViOo4+XrllLngVkMMU78W2MB8G
A1UdIwQYMBaAFLLtIWViOo4+XrllLngVkMMU78W2MAwGA1UdEwQFMAMBAf8wDQYJ
KoZIhvcNAQEFBQADgYEAG1PiV0P2iZhh88juujpr/BrlMm64BlX1hrsLyyNR6e85
iBC4kFJNndkFiCFz31EAJkzoMIUdgn07cENk2KAjf3BIrgBaeY6mp94s6lpRcfK7
lEsfbyADOQqszCuzadMHZd44XReMaf43Kw/WYwVmsHpBDpzgAwH1sxtSKcHnFmox
ggGnMIIBowIBATAmMBkxFzAVBgNVBAMMDlBLQ1MjNyBleGFtcGxlAgkA0oEkvc7s
zMwwCQYFKw4DAhoFAKCB2DAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqG
SIb3DQEJBTEPFw0xMzA0MTIyMTExMTVaMCMGCSqGSIb3DQEJBDEWBBS0KhYhWkxR
nvCUyavULWwbRXaF1jB5BgkqhkiG9w0BCQ8xbDBqMAsGCWCGSAFlAwQBKjALBglg
hkgBZQMEARYwCwYJYIZIAWUDBAECMAoGCCqGSIb3DQMHMA4GCCqGSIb3DQMCAgIA
gDANBggqhkiG9w0DAgIBQDAHBgUrDgMCBzANBggqhkiG9w0DAgIBKDANBgkqhkiG
9w0BAQEFAASBgHq2NEUYm1csunOIOlekNBPW12EWMU3lTK+phxPtKZl+y2233NLN
TWaLUaRF7ePjapr71IYlrLfse9Kv8xl8o2QU+XMhj1p2I6Ng0lt3VfwjgJ5isidk
GM/suaYFITr4PxGlhZKEtoYQh4BOr0r0+iy6aFJGKAhn4slB6qdhn025
-----END PKCS7-----
</code></pre>

<p>Reference: <a href=""http://qistoph.blogspot.com/2013/04/pkcs7-and-openssl.html"" rel=""nofollow noreferrer"">http://qistoph.blogspot.com/2013/04/pkcs7-and-openssl.html</a></p>
","","23","<php><openssl><verify><pkcs#7><smime>","0","","0","2019-03-20 08:52:37","","0","","3865565","","2019-03-20 08:52:37","2019-03-20 08:10:35",""
"34443523","PyCrypto AES decryption weirdness - python 2.7","<p>I'm encrypting files with AES using PyCrypto, but when I decrypt them they have garbage characters at the head of the file. Here's a stripped down example that encrypts a text file of Moby Dick and then attempts to decrypt it:</p>

<pre><code>from Crypto.Cipher import AES
from os import urandom

key = urandom(32)
iv = urandom(16)
aes = AES.new(key, AES.MODE_CBC, iv)

def encrypt_data(chunk):
    padding = AES.block_size
    if len(chunk):
        padding = AES.block_size - (len(chunk) % AES.block_size)
    return aes.encrypt(chunk + chr(padding)*padding)

with open('melville-moby-106.txt', 'r') as infile:
    with open('/tmp/test.tmp', 'w') as outfile:
        chunk = infile.read()
        while chunk:
            outfile.write(encrypt_data(chunk))
            chunk = infile.read()


with open('/tmp/test.tmp', 'r') as infile:
    with open('melville-moby-106.txt.new', 'w') as outfile:
        chunk = infile.read()
        while chunk:
            data = aes.decrypt(chunk)
            data = data[0:-ord(data[-1])]
            outfile.write(data)
            chunk = infile.read()
</code></pre>

<p>After I've run the script, I have these files:</p>

<pre><code>-rw-rw-r--  1 brian  brian  1223687 Dec 23 15:11 melville-moby-106.txt
-rw-rw-r--  1 brian  brian  1223687 Dec 23 15:40 melville-moby-106.txt.new
-rw-rw-r--  1 brian  brian  1223696 Dec 23 15:40 test.tmp
</code></pre>

<p>The size looks right, but the checksums don't match:</p>

<pre><code>96e829710ef8966d6eaef34b439cae6b  melville-moby-106.txt
94b94e495d449dad919083029a66b675  melville-moby-106.txt.new
</code></pre>

<p>If I look at the files, here's what I see:</p>

<pre><code>$ head -n 1 melville-moby-106.txt
c                                      1851

$ head -n 1 melville-moby-106.txt.new 
ZÔøΩx#8iÔøΩÔøΩÔøΩ[ÔøΩÔøΩ`jÔøΩ6                       1851
</code></pre>

<p>The rest of the file's contents look OK.</p>

<p>Can someone tell me what I'm doing wrong?</p>

<p>Thanks</p>
","","22","<python><python-2.7><encryption><aes><pkcs#7>","2","","0","2015-12-23 20:51:02","","1","","","","","2015-12-23 20:51:02","2015-12-23 21:00:53"
"58502228","Detached Digital signature verification fails with exception no such algorithm: SHA256WITHECDSA for provider SUN","<p>I am signing some content in detached mode with external signature API, the external API takes content hash (SHA256)and returns signed bytes in PKCS#7 (Base64 encoded) and signers X509 certificate. Now I want to validate the signature, I am using following code for that.</p>

<p>Pom.xml</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;project xmlns=""http://maven.apache.org/POM/4.0.0""
         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd""&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;nic.oad&lt;/groupId&gt;
    &lt;artifactId&gt;verifysig&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;8&lt;/source&gt;
                    &lt;target&gt;8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    &lt;dependencies&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.bouncycastle/bcpkix-jdk15on --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
            &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
            &lt;version&gt;1.63&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
            &lt;artifactId&gt;bcpkix-jdk15on&lt;/artifactId&gt;
            &lt;version&gt;1.63&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>

<p>VerifyDetachedSignature.java</p>

<pre><code>

import org.bouncycastle.cms.*;
import org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.OperatorCreationException;

import java.io.ByteArrayInputStream;
import java.security.Security;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Base64;

public class VerifyDetachedSignature {
    public static void main (String ... args){
        String origContentBeforeSign = ""hello dear"";

        //Input for external API
        String sha256OfOrigContent = ""b17c48764e2ffbfecaa252c449b38185a6ef1f47f179f60d5776d2660f568298"";
        //Response form external API
        String userX509Cert = ""MIIF3zCCBMegAwIBAgIUAI3+onmDwTHVrLb0ZQjf6ieazc0wDQYJKoZIhvcNAQELBQAwgcExCzAJBgNVBAYTAklOMQ4wDAYDVQQKEwVDLURBQzEgMB4GA1UECxMXQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxDzANBgNVBBETBjQxMTAwNzEUMBIGA1UECBMLTWFoYXJhc2h0cmExJTAjBgNVBAkTHFB1bmUgVW5pdmVyc2l0eSBDYW1wdXMsIFB1bmUxGjAYBgNVBDMTETFzdCBmbG9vciwgS2hvc2xhMRYwFAYDVQQDEw1DLURBQyBDQSAyMDE0MB4XDTE5MTAyMTExMTcwMVoXDTE5MTAyMTExNDcwMVowggE/MQ4wDAYDVQQGEwVJbmRpYTEOMAwGA1UECBMFRGVsaGkxETAPBgNVBAoTCFBlcnNvbmFsMRowGAYDVQQDExFEZXZpIFNpbmdoIFBpbHdhbDEPMA0GA1UEERMGMTEwMDc2MVMwUQYDVQQtA0oAMDEwMDA1NTlWL3YyXCtZeHpaYnh0M2lTVm9GMXNjZGE3R3QxelF6RlVXTjFhd0NyWk55YjlxODE3Zzlwd1NlUEVpUy9DVVFmWTEpMCcGA1UEQRMgMTg2M2FiYmZhOWJhNDk0NGI3Yjg5ZWI1YjQ4MWYyYmMxDTALBgNVBAwTBDEwMzExTjBMBgNVBC4TRTE5ODNNNDdkOTNhZDAwYzM0N2QwZjljM2ViMzFjNGQxODQyOGEzMDU3NzU1NzEwNWIyMWNiMmQ0Yjc3NDA5MzYxZDI5ZDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOTOniWF/vD11jHGEwRL1FEBi4yClLQGea4zbSDuxQyb8gL33XoHBVA1uK1PVnQq65loSYhUq+XwRzizMtwki0qjggIXMIICEzAJBgNVHRMEAjAAMB0GA1UdDgQWBBRDbqI8q4d+l+E9/zCocyhcaDTqZDATBgNVHSMEDDAKgAhBQ3LI5DRx/DAOBgNVHQ8BAf8EBAMCBsAwOQYDVR0fBDIwMDAuoCygKoYoaHR0cHM6Ly9lc2lnbi5jZGFjLmluL2NhL2VzaWduQ0EyMDE5LmNybDCCAT8GA1UdIASCATYwggEyMIIBAQYHYIJkZAEJAjCB9TAwBggrBgEFBQcCARYkaHR0cHM6Ly9lc2lnbi5jZGFjLmluL2NhL0NQUy9DUFMucGRmMIHABggrBgEFBQcCAjCBszA+FjpDZW50cmUgZm9yIERldmVsb3BtZW50IG9mIEFkdmFuY2VkIENvbXB1dGluZyAoQy1EQUMpLCBQdW5lMAAacVRoaXMgQ1BTIGlzIG93bmVkIGJ5IEMtREFDIGFuZCB1c2VycyBhcmUgcmVxdWVzdGVkIHRvIHJlYWQgQ1BTIGJlZm9yZSB1c2luZyB0aGUgQy1EQUMgQ0EncyBjZXJ0aWZpY2F0aW9uIHNlcnZpY2VzMCsGB2CCZGQCBAEwIDAeBggrBgEFBQcCAjASGhBBYWRoYWFyIGVLWUMtT1RQMEQGCCsGAQUFBwEBBDgwNjA0BggrBgEFBQcwAoYoaHR0cHM6Ly9lc2lnbi5jZGFjLmluL2NhL0NEQUMtQ0EyMDE0LmRlcjANBgkqhkiG9w0BAQsFAAOCAQEAWfgVBA2kn31HZCWX8Jhikcd9vjaKhPIecN7hlrTx7BNzTFCksmuck17Lr6DowBkPuT7kYCAPVPKrUwkQ7w1VjGwTS9hTsb+aQYePO9JqoVQ9IpCS5Mz4m7ftPnd04PAwWwwpl62p1cuRPBgd1kGRuMBQPmGYIqEvddAZtcylXLmE3HaWngqE4bYm9dV3pevv3hzZPazz0fLVCLdxEAIg4bAcfaGbyhXj4JmX4AHk5HoNTY081mqP8GA98CyGIBmzVKmyMydRa3rCRGeHmTDRIc3VIA2GAsW/+A+Z6h3BNoXSwT2AA4SqaKVAkpHWmoYlbb0Ju0qTBzQst/Zs9xF/BQ=="";
        String signedContentPKCS7 =""MIIPIwYJKoZIhvcNAQcCoIIPFDCCDxACAQExDzANBglghkgBZQMEAgEFADALBgkqhkiG9w0BBwGggg0yMIIDIzCCAgugAwIBAgICJ60wDQYJKoZIhvcNAQELBQAwOjELMAkGA1UEBhMCSU4xEjAQBgNVBAoTCUluZGlhIFBLSTEXMBUGA1UEAxMOQ0NBIEluZGlhIDIwMTQwHhcNMTQwMzA1MTAxMDQ5WhcNMjQwMzA1MTAxMDQ5WjA6MQswCQYDVQQGEwJJTjESMBAGA1UEChMJSW5kaWEgUEtJMRcwFQYDVQQDEw5DQ0EgSW5kaWEgMjAxNDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN7IUL2K/yINrn+sglna9CkJ1AVrbJYBvsylsCF3vhStQC9kb7t4FwX7s+6AAMSakL5GUDJxVVNhMqf/2paerAzFACVNR1AiMLsG7ima4pCDhFn7t9052BQRbLBCPg4wekx6j+QULQFeW9ViLV7hjkEhKffeuoc3YaDmkkPSmA2mz6QKbUWYUu4PqQPRCrkiDH0ikdqR9eyYhWyuI7Gm/pc0atYnp1sru3rtLCaLS0ST/N/ELDEUUY2wgxglgoqEEdMhSSBL1CzaA8Ck9PErpnqC7VL+sbSyAKeJ9n56FttQzkwYjdOHMrgJRZaPb2i5VoVo1ZFkQF3ZKfiJ25VH5+8CAwEAAaMzMDEwDwYDVR0TAQH/BAUwAwEB/zARBgNVHQ4ECgQIQrjFz22zV+EwCwYDVR0PBAQDAgEGMA0GCSqGSIb3DQEBCwUAA4IBAQAdAUjv0myKyt8GC1niIZplrlksOWIR6yXLg4BhFj4ziULxsGK4Jj0sIJGCkNJeHl+Ng9UlU5EI+r89DRdrGBTF/I+g3RHcViPtOne9xEgWRMRYtWD7QZe5FvoSSGkW9aV6D4iGLPBQML6FDUkQzW9CYDCFgGC2+awRMx61dQVXiFv3Nbkqa1Pejcel8NMAmxjfm5nZMd3Ft13hy3fNF6UzsOnBtMbyZWhS8Koj2KFfSUGX+M/DS1TG2ZujwKKXCuKq7+67m0WF6zohoHJbqjkmKX34zkuFnoXaXco9NkOi0RBvLCiqR2lKfzLM7B69bje+z0EqnRNo5+s8PWSdy+xtMIIEJDCCAwygAwIBAgICJ8AwDQYJKoZIhvcNAQELBQAwOjELMAkGA1UEBhMCSU4xEjAQBgNVBAoTCUluZGlhIFBLSTEXMBUGA1UEAxMOQ0NBIEluZGlhIDIwMTQwHhcNMTYwNzI4MDkyNTE4WhcNMjQwMzA1MDYzMDAwWjCBwTELMAkGA1UEBhMCSU4xDjAMBgNVBAoTBUMtREFDMSAwHgYDVQQLExdDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEPMA0GA1UEERMGNDExMDA3MRQwEgYDVQQIEwtNYWhhcmFzaHRyYTElMCMGA1UECRMcUHVuZSBVbml2ZXJzaXR5IENhbXB1cywgUHVuZTEaMBgGA1UEMxMRMXN0IGZsb29yLCBLaG9zbGExFjAUBgNVBAMTDUMtREFDIENBIDIwMTQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCYxLdnqHi9Kq57pJuv0ijLCcsbFWirh3vKvoWmxX+i5WacwDZqbF6Oia5aHEgLL0YPeJ+FBNoEAYrDvIGc+UmkAKvM/6+KN+/lhDf6TBDMNntCsZ45GrkLcsUXHu9MLEqcAUOku8T6aD/JexF2E5Sg//exL9xvUwwa4TgQm8N1rZBPm5cOPkn3YRerfzHKjoxDwxIN3iVS5BjjbJrwGbcOb+yqZo7xKNdHlDKljEYNFpkYWD7rhDrOlPq3IIOi74b1WpoT67//fkHu1qYFuUHU5mwkqRZ6gGlH6rYYx9LoLN2Gch8f7IcujvxJLaX5Q57pKiWBFa4FFhIZrupJ66NRAgMBAAGjgaswgagwEgYDVR0TAQH/BAgwBgEB/wIBADARBgNVHQ4ECgQIQUNyyOQ0cfwwEgYDVR0gBAswCTAHBgVggmRkAjATBgNVHSMEDDAKgAhCuMXPbbNX4TAOBgNVHQ8BAf8EBAMCAQYwRgYDVR0fBD8wPTA7oDmgN4Y1aHR0cDovL2NjYS5nb3YuaW4vcncvcmVzb3VyY2VzL0NDQUluZGlhMjAxNExhdGVzdC5jcmwwDQYJKoZIhvcNAQELBQADggEBAL+ELhdhs5EJmH4G8Allsf+JXnI1Wo/xgDBj0XvvhFD+4L0ZlKwm3Z7c21x4xw/AIUdhJ3YTXhih9HiJxAzS7trWmBRyEv3ebG5nQpID+uCAYjgd+SAStUK58Dm6ztiS06RtE5X780tdIEMDCFQDIcRpwqhGGGoapE7V7r0eXUoSEd+Ba0OxxmBqz5ebKR+XEM9//UHMvkObow/ZFR8IRZzFbWbUIVRbYtvO8ZCUMFlGwijGzpbDZPKxiYurY6TK1vVoJ54Cr0amkImQtaJNMLjOXCBS0K2jxguiT2jHoQ8L+mt5aNETT9HHkeZJorM+V6kqSy6zXMhhzIaO7DsFAbkwggXfMIIEx6ADAgECAhQAjf6ieYPBMdWstvRlCN/qJ5rNzTANBgkqhkiG9w0BAQsFADCBwTELMAkGA1UEBhMCSU4xDjAMBgNVBAoTBUMtREFDMSAwHgYDVQQLExdDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEPMA0GA1UEERMGNDExMDA3MRQwEgYDVQQIEwtNYWhhcmFzaHRyYTElMCMGA1UECRMcUHVuZSBVbml2ZXJzaXR5IENhbXB1cywgUHVuZTEaMBgGA1UEMxMRMXN0IGZsb29yLCBLaG9zbGExFjAUBgNVBAMTDUMtREFDIENBIDIwMTQwHhcNMTkxMDIxMTExNzAxWhcNMTkxMDIxMTE0NzAxWjCCAT8xDjAMBgNVBAYTBUluZGlhMQ4wDAYDVQQIEwVEZWxoaTERMA8GA1UEChMIUGVyc29uYWwxGjAYBgNVBAMTEURldmkgU2luZ2ggUGlsd2FsMQ8wDQYDVQQREwYxMTAwNzYxUzBRBgNVBC0DSgAwMTAwMDU1OVYvdjJcK1l4elpieHQzaVNWb0Yxc2NkYTdHdDF6UXpGVVdOMWF3Q3JaTnliOXE4MTdnOXB3U2VQRWlTL0NVUWZZMSkwJwYDVQRBEyAxODYzYWJiZmE5YmE0OTQ0YjdiODllYjViNDgxZjJiYzENMAsGA1UEDBMEMTAzMTFOMEwGA1UELhNFMTk4M000N2Q5M2FkMDBjMzQ3ZDBmOWMzZWIzMWM0ZDE4NDI4YTMwNTc3NTU3MTA1YjIxY2IyZDRiNzc0MDkzNjFkMjlkMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5M6eJYX+8PXWMcYTBEvUUQGLjIKUtAZ5rjNtIO7FDJvyAvfdegcFUDW4rU9WdCrrmWhJiFSr5fBHOLMy3CSLSqOCAhcwggITMAkGA1UdEwQCMAAwHQYDVR0OBBYEFENuojyrh36X4T3/MKhzKFxoNOpkMBMGA1UdIwQMMAqACEFDcsjkNHH8MA4GA1UdDwEB/wQEAwIGwDA5BgNVHR8EMjAwMC6gLKAqhihodHRwczovL2VzaWduLmNkYWMuaW4vY2EvZXNpZ25DQTIwMTkuY3JsMIIBPwYDVR0gBIIBNjCCATIwggEBBgdggmRkAQkCMIH1MDAGCCsGAQUFBwIBFiRodHRwczovL2VzaWduLmNkYWMuaW4vY2EvQ1BTL0NQUy5wZGYwgcAGCCsGAQUFBwICMIGzMD4WOkNlbnRyZSBmb3IgRGV2ZWxvcG1lbnQgb2YgQWR2YW5jZWQgQ29tcHV0aW5nIChDLURBQyksIFB1bmUwABpxVGhpcyBDUFMgaXMgb3duZWQgYnkgQy1EQUMgYW5kIHVzZXJzIGFyZSByZXF1ZXN0ZWQgdG8gcmVhZCBDUFMgYmVmb3JlIHVzaW5nIHRoZSBDLURBQyBDQSdzIGNlcnRpZmljYXRpb24gc2VydmljZXMwKwYHYIJkZAIEATAgMB4GCCsGAQUFBwICMBIaEEFhZGhhYXIgZUtZQy1PVFAwRAYIKwYBBQUHAQEEODA2MDQGCCsGAQUFBzAChihodHRwczovL2VzaWduLmNkYWMuaW4vY2EvQ0RBQy1DQTIwMTQuZGVyMA0GCSqGSIb3DQEBCwUAA4IBAQBZ+BUEDaSffUdkJZfwmGKRx32+NoqE8h5w3uGWtPHsE3NMUKSya5yTXsuvoOjAGQ+5PuRgIA9U8qtTCRDvDVWMbBNL2FOxv5pBh4870mqhVD0ikJLkzPibt+0+d3Tg8DBbDCmXranVy5E8GB3WQZG4wFA+YZgioS910Bm1zKVcuYTcdpaeCoThtib11Xel6+/eHNk9rPPR8tUIt3EQAiDhsBx9oZvKFePgmZfgAeTkeg1NjTzWao/wYD3wLIYgGbNUqbIzJ1FresJEZ4eZMNEhzdUgDYYCxb/4D5nqHcE2hdLBPYADhKpopUCSkdaahiVtvQm7SpMHNCy39mz3EX8FMYIBtTCCAbECAQEwgdowgcExCzAJBgNVBAYTAklOMQ4wDAYDVQQKEwVDLURBQzEgMB4GA1UECxMXQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxDzANBgNVBBETBjQxMTAwNzEUMBIGA1UECBMLTWFoYXJhc2h0cmExJTAjBgNVBAkTHFB1bmUgVW5pdmVyc2l0eSBDYW1wdXMsIFB1bmUxGjAYBgNVBDMTETFzdCBmbG9vciwgS2hvc2xhMRYwFAYDVQQDEw1DLURBQyBDQSAyMDE0AhQAjf6ieYPBMdWstvRlCN/qJ5rNzTANBglghkgBZQMEAgEFAKBpMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTE5MTAyMTExMTcwMVowLwYJKoZIhvcNAQkEMSIEILF8SHZOL/v+yqJSxEmzgYWm7x9H8Xn2DVd20mYPVoKYMAwGCCqGSM49BAMCBQAERzBFAiEA5yYdKoT8jppsvsajBDDwCIUMHjB7ZE1Fz4Lzdu+/r5YCIBYfT2JWSiVfn51pyC/iAwdC+x6zvYOk1fPMcrGj79fU"";

        try {
            byte[] signedByte = Base64.getDecoder().decode(signedContentPKCS7);
            byte base64EncodedCert[] = Base64.getDecoder().decode(userX509Cert);
            ByteArrayInputStream inputStream  =  new ByteArrayInputStream(base64EncodedCert);

            Security.addProvider(new BouncyCastleProvider());

            CMSSignedData s = new CMSSignedData(new CMSProcessableByteArray(sha256OfOrigContent.getBytes()), signedByte);
            SignerInformationStore signers = s.getSignerInfos();
            SignerInformation signerInfo = (SignerInformation)signers.getSigners().iterator().next();

            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            X509Certificate cert = (X509Certificate)cf.generateCertificates(inputStream).iterator().next();
            System.out.println(cert.getSigAlgName());
            JcaSimpleSignerInfoVerifierBuilder obj = new JcaSimpleSignerInfoVerifierBuilder();
            obj.setProvider(""SUN"");
            boolean result = signerInfo.verify(obj.build(cert.getPublicKey()));
            System.out.println(""Verified: ""+result);
        } catch (CertificateException | CMSException
                | OperatorCreationException
                e) {
            e.printStackTrace();
        }



    }
}
</code></pre>

<p>I am getting following exception while executing the code.</p>

<pre><code>org.bouncycastle.cms.CMSException: can't create content verifier: exception on setup: java.security.NoSuchAlgorithmException: no such algorithm: SHA256WITHECDSA for provider SUN
    at org.bouncycastle.cms.SignerInformation.doVerify(Unknown Source)
    at org.bouncycastle.cms.SignerInformation.verify(Unknown Source)
    at VerifyDetachedSignature.main(VerifyDetachedSignature.java:41)
Caused by: org.bouncycastle.operator.OperatorCreationException: exception on setup: java.security.NoSuchAlgorithmException: no such algorithm: SHA256WITHECDSA for provider SUN
    at org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder.createSignature(Unknown Source)
    at org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder.access$200(Unknown Source)
    at org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$2.get(Unknown Source)
    at org.bouncycastle.cms.SignerInformationVerifier.getContentVerifier(Unknown Source)
    ... 3 more
Caused by: java.security.NoSuchAlgorithmException: no such algorithm: SHA256WITHECDSA for provider SUN
    at sun.security.jca.GetInstance.getService(GetInstance.java:87)
    at sun.security.jca.GetInstance.getInstance(GetInstance.java:206)
    at java.security.Signature.getInstance(Signature.java:361)
    at org.bouncycastle.jcajce.util.NamedJcaJceHelper.createSignature(Unknown Source)
    at org.bouncycastle.operator.jcajce.OperatorHelper.createSignature(Unknown Source)
    ... 7 more
Disconnected from the target VM, address: '127.0.0.1:63442', transport: 'socket'

Process finished with exit code 0
</code></pre>

<p>I am using Java version 1.8.0_221
<em>I also tried to use Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files for JDK/JRE</em> as mentioned <a href=""https://stackoverflow.com/questions/10721831/ecdsa-with-sha256-in-bouncy-castle-throws-no-such-algorithm-exception"">here</a></p>

<p>Can anybody please guide me, what am I missing or doing wrong ?</p>
","","21","<java><digital-signature><bouncycastle><pkcs#7>","0","","0","2019-10-22 10:28:44","","3","","","","","2019-10-22 10:28:44",""
"58362657","Code halts execution without any Exception","<p>I have a JAR which has a class which is supposed to sign a PDF file and also create a detached PKCS7 signature. The problem, however, is that I use 2 different crypto providers: JCP (a Russian provider for creating an attached PDF signature) and BC for creating a detached one, respectively. </p>

<p>The code as follows:</p>

<pre><code>public void signPdf(InputStream is, String folder, String fileNameWoExtension) throws Exception
    {
        // private key and certificate
        PrivateKey key = keyStore.getPrivateKey();
        Certificate[] chain = new Certificate[1];
        chain[0] = keyStore.getCertificate();

        X509Certificate cert = (X509Certificate)chain[0];
        Date notBefore = cert.getNotBefore();
        Date notAfter = cert.getNotAfter();
        String serial = cert.getSerialNumber().toString(16).toUpperCase();
        String subject = PdfPKCS7.getSubjectFields(cert).getField(""CN"");
        String number = fileNameWoExtension.replace(""appeal_"", """");
        // reader and stamper
        PdfReader reader = new PdfReader(is);
        FileOutputStream fout = new FileOutputStream(folder + File.separator + fileNameWoExtension + "".pdf"");
        PdfStamper stp = PdfStamper.createSignature(reader, fout, '\0');

        StampsCreator.createEdsStamp(folder, serial, subject, notBefore, notAfter);
        StampsCreator.createRegisterStamp(folder, new Date(), number);

        PdfContentByte pcb = stp.getOverContent(1);
        Image imageEds = Image.getInstance(folder + File.separator + StampsCreator.EDS_STAMP);
        imageEds.scaleAbsolute(200, 87);
        imageEds.setAbsolutePosition(75, 80);
        imageEds.setAnnotation(new Annotation(0, 0, 0, 0, 3));
        pcb.addImage(imageEds);

        Image imageReg = Image.getInstance(folder + File.separator + StampsCreator.REGNUMBER_STAMP);
        imageReg.scaleAbsolute(207, 20);
        int height = (int) Math.floor(reader.getPageSize(1).getHeight());
        imageReg.setAbsolutePosition(70, height - 130);
        imageReg.setAnnotation(new Annotation(0, 0, 0, 0, 3));
        pcb.addImage(imageReg);

        PdfSignatureAppearance sap = stp.getSignatureAppearance();
        sap.setSignDate(new GregorianCalendar());
        sap.setCrypto(null, chain, null, null);
        sap.setAcro6Layers(true);
        sap.setRenderingMode(PdfSignatureAppearance.RenderingMode.DESCRIPTION);
        PdfSignature dic;
        dic = new PdfSignature(PdfName.ADOBE_CryptoProPDF, PdfName.ADBE_PKCS7_DETACHED);
        dic.setDate(new PdfDate(sap.getSignDate()));

        dic.setName(subject);
        dic.setReason(""Signed with CryptoPro"");
        sap.setCryptoDictionary(dic);
        int csize = 4000;
        HashMap&lt;PdfName,Integer&gt; exc = new HashMap&lt;PdfName,Integer&gt;();
        exc.put(PdfName.CONTENTS, new Integer(csize * 2 + 2));
        sap.preClose(exc);
        System.out.println(""preclosed "" + key.getClass().getName() + "" "" + key.getAlgorithm());
        System.out.println(""1"");
        X509Certificate signerCert = (X509Certificate)chain[0];
        System.out.println(""2"");
        List certList = new ArrayList();
        System.out.println(""3"");
        certList.add(signerCert);
        System.out.println(""4"");
        Store certs = new JcaCertStore(certList);
        System.out.println(""5"");
        // signature
        CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
        System.out.println(""6"");
        ContentSigner signer = new JcaContentSignerBuilder(AlgorithmUtils.getDigestMessageAndAlgorithmsForJcaContentSignerBuilder(signerCert)).setProvider(""BC"").build(key);


        System.out.println(""7"");
        generator.addSignerInfoGenerator(
                new JcaSignerInfoGeneratorBuilder(
                        new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build())
                        .build(signer, signerCert));
        System.out.println(""8"");
        generator.addCertificates(certs);
        System.out.println(""9"");

        //generator.addCertificates(new JcaCertStore(Arrays.asList(chain)));
        //generator.addSigner(key, (X509Certificate)chain[0], JCP.GOST_EL_DH_OID, JCP.GOST_DIGEST_OID);

        /*ArrayList&lt;Certificate&gt; list = new ArrayList&lt;Certificate&gt;();
        for (int i = 0; i &lt; chain.length; i++) {
            list.add(chain[i]);
        }*/
        /*CertStore chainStore
            = CertStore.getInstance(""Collection"", new CollectionCertStoreParameters(list), ""BC"");
        generator.addCertificatesAndCRLs(chainStore);*/

        CMSSignedData signedData;
        System.out.println(""9"");
        signedData = generator.generate(new CMSProcessableByteArray(IOUtils.toByteArray(sap.getRangeStream())), false);
        System.out.println(""10"");

        //CMSProcessable content = new CMSProcessableRange(sap);
        //signedData = generator.generate(content, false, JCP.PROVIDER_NAME);
        byte[] pk = signedData.getEncoded();
        System.out.println(""p7s data ready."");
        byte[] outc = new byte[csize];
        PdfDictionary dic2 = new PdfDictionary();
        System.arraycopy(pk, 0, outc, 0, pk.length);
        dic2.put(PdfName.CONTENTS, new PdfString(outc).setHexWriting(true));
        System.out.println(""signed ready."");
        sap.close(dic2);
        FileOutputStream fos = new FileOutputStream(folder + File.separator + fileNameWoExtension + "".p7s"");
        fos.write(pk);
        fos.close();
    }
</code></pre>

<p>Here's the method for defining the algorithm inside the cert used for creating a signature:</p>

<pre><code>public static String getDigestMessageAndAlgorithmsForJcaContentSignerBuilder(X509Certificate cert)
    {
        switch (cert.getPublicKey().getAlgorithm()) 
        {
            case ""GOST3410_2012_256"": 
                return JCA_CONTENT_GOST_2012_256; //GOST3411-2012-256WITHECGOST3410-2012-256
            case ""GOST3410_2012_512"": 
                return JCA_CONTENT_GOST_2012_512; //GOST3411-2012-512WITHECGOST3410-2012-512
            case ""GOST3410EL"": 
                return JCA_CONTENT_GOST3410EL; //GOST3411withECGOST3410

            default: 
                throw new IllegalArgumentException(""Algorithm inside the certificate "" + cert.getPublicKey().getAlgorithm() + "" is not supported."");
        }
    }
</code></pre>

<p>The code seems to halt at the following line:</p>

<pre><code>ContentSigner signer = new JcaContentSignerBuilder(AlgorithmUtils.getDigestMessageAndAlgorithmsForJcaContentSignerBuilder(signerCert)).setProvider(""BC"").build(key);
</code></pre>

<p>I figured it out because when I try to execute it I get the following output:</p>

<pre><code>preclosed ru.CryptoPro.JCP.Key.GostExchPrivateKey GOST3410DH_2012_256
1
2
3
4
5
6
</code></pre>

<p>Why is that? Is it related to using different crypto providers? I mean because <code>PrivateKey</code> is of type <code>ru.CryptoPro.JCP.Key.GostExchPrivateKey</code> whilst BC requires a different type?</p>

<p>Thanks in advance.</p>
","","19","<java><digital-signature><bouncycastle><pkcs#7>","0","","0","2019-10-13 10:23:13","","0","","","","","2019-10-13 10:23:13",""
"56676694","Cades Digital sign with smartcard","<p>I'm try to develop a software for Digital signing xml files and output a .p7m file format. The problem is that I have to use a smartcard to do that. Could you please, show me some resources to learn how to achieve that?</p>
","","18","<python><windows><digital-signature><smartcard><pkcs#7>","0","","0","2019-06-20 02:58:01","","2","","6332958","","2019-06-20 02:58:01","2019-06-19 22:30:03",""
"56668275","Command-line openssl cms : is there any way to combine CMS with the digest algorithm ecdsa-with-SHA1?","<p>I wish to have a CMS signed document but that uses the digest ""ecdsa-with-SHA1"". Is that possible with openssl </p>

<pre><code>openssl cms -sign -noattr -nocerts -nosmimecap -md sha256 -in MYFILE.txt binary -out MYFILE.cms.sha256 -outform DER -stream -signer server.pem -inkey private-key.pem
</code></pre>

<p>But I wish to use a message digest ""ecdsa-with-SHA1"" rather than sha256 as in</p>

<pre><code>openssl dgst -ecdsa-with-SHA1 -sign private-key.pem -out MYFILE.ecdsa.dgst MYFILE.txt



OpenSSL&gt; version
OpenSSL 1.1.1c  28 May 2019
</code></pre>

<p>Is there any way with openssl to combine CMS with ecdsa-with-SHA1 ?</p>
","","18","<openssl><digital-signature><pkcs#7>","0","","0","2019-06-19 13:00:42","","1","","","","","2019-06-19 13:00:42",""
"58769162","Signed PDF verification in Origami with an Adobe PKCS#7 certificate","<p>I'm trying to verify the digital signature of a PDF. Here's what I've got:</p>

<p>A PDF that I've signed using Adobe Acrobat (tried both Pro 10 and Reader DC)</p>

<p>The key was generated in Acrobat Pro, I have access to the .p12, or exporting as FDF, PKCS#7 or just ""Certificate File"". Have also tried loading this ""Certificate File"" via Apple's ""Keychain Access"" and exporting that as a .pem from there, which had the same result (according to ruby's openssl - steps below) as me doing:</p>

<pre><code>openssl pkcs7 -print_certs -inform der -in pkcs7file.p7c -out certificate.cer
</code></pre>

<p>With the Origami gem, I've tried loading the certificate and attempting verification:</p>

<pre><code>cert = OpenSSL::X509::Certificate.new(File.read('/path/to/pem/or/cer.cer'))
Origami::PDF.read(File.open('/path/to/file.pdf', 'r')).verify(trusted_certs: [cert])
</code></pre>

<p>(just noticed that The .pem and .cer are identical, except that the .cer file includes ""subject="" and ""issue="" lines before the certificate)</p>

<p>Origami's output confirms the document has been signed, but the <code>verify(..)</code> method returns false.</p>

<p>Note that working through the code from <a href=""https://stackoverflow.com/questions/51984805/origami-openssl-error-while-validating-digital-signature-of-a-pdf-in-rails/54526938#54526938"">this excellent answer</a> works fine, but it only seems to work if you generate the X.509 keypair using openssl (e.g. the ruby-land bindings as per that code). Unfortunately I'm required to use the pre-existing Adobe-blessed signatures from the user's machines.</p>

<p>That said, aside from this I have very few restraints; I can ask the users to export their certificate in any other way that is useful to us (I can even run some simple code on their machines if necessary), though I mustn't transmit the private key in the procedure. I don't have to use Origami for the verification, but it does have to be a command accessible from ruby on an ubuntu server. The users are all running on Macs with reasonably up-to-date software.</p>
","<p>It's possible the ciphers are different. It could be that the Adobe cipher is not the same one that the openssl is using and would then fail the verification check. Take a look at this. <a href=""https://stackoverflow.com/questions/7402230/what-is-default-cipher-for-pem-format-in-openssl"">Details on ciphers</a> </p>

<p>This might be useful too <a href=""https://gist.github.com/webtobesocial/5313b0d7abc25e06c2d78f8b767d4bc3"" rel=""nofollow noreferrer"">openssl commands</a></p>
","18","<ruby><pdf><adobe><pkcs#7><origami>","0","0","1","2019-11-10 01:20:43","","0","","","","","2019-11-08 15:10:18",""
"58027881","Question about converting this code, to verify signature and decrypt soap response, from .NET to node","<p>I'm migrating an api that consumes third-party soap services, from .NET to Node.JS.
I was able to successfully obtain the answer I was expecting from one service.
But I have doubts about how I am treating the answer.
First of all clarify that I am a bit newbie in terms of encryption and soap web services.</p>

<p>This is the code in .NET that i want to migrate:</p>

<pre><code>using System.Security.Cryptography.Pkcs;

        public string DecodeMessage(string message)
        {
            message = message.Split('-')[10].Substring(1, message.Split('-')[10].Length - 2);
            SignedCms = new SignedCms();
            SignedCms.Decode(Convert.FromBase64String(message));
            return Encoding.ASCII.GetString(SignedCms.ContentInfo.Content);
        }
</code></pre>

<p>And this is what i'm actually doing in Node:</p>

<pre><code>import * as forge from 'node-forge';

 public decodeMessage(message: string) {
        let p7 = forge.pkcs7.messageFromPem(message);
        return p7.rawCapture.content.value[0].value;
    }
</code></pre>

<p>This code actually works, I'm able to recover the data from the response.
But is it correctly migrated?
Am I missing something? Like verify the signing?</p>
","","16","<c#><node.js><soap><sign><pkcs#7>","0","","0","2019-09-20 11:53:31","","0","","","","","2019-09-20 11:53:31",""
"53278126","How to add paragraph label using swing, following is my code","<p>How to add timestamp, while generating digital signature for the file using BouncyCastle?
How to add timestamp, while generating digital signature for the file using BouncyCastle?</p>

<pre><code>public String generateSignature(String filePath, PrivateKey privateKey, String alias) throws Exception {
        KeyStore ks = KeyStore.getInstance(""WINDOWS-MY"", ""SunMSCAPI"");
        String pin = """";
        ks.load(null, pin.toCharArray());
        Security.addProvider(new BouncyCastleProvider());
        byte[] fileContent = Files.readAllBytes(new File(filePath).toPath());
        Signature signature = Signature.getInstance(""SHA1withRSA"");
        signature.initSign(privateKey);
        signature.update(fileContent);

        // Build CMS
        X509Certificate certFromKeystore = (X509Certificate) ks.getCertificate(alias);
        List certList = new ArrayList();
        CMSTypedData data = new CMSProcessableByteArray(fileContent);
        certList.add(certFromKeystore);
        Store certs = new JcaCertStore(certList);
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();  //generate PKCS7 siganture messgae
        ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""SunMSCAPI"")
                .build(privateKey);
        gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build())
                        .build(sha1Signer, certFromKeystore));
        gen.addCertificates(certs);
        CMSSignedData signedData = gen.generate(data, false);
        BASE64Encoder encoder = new BASE64Encoder();
        String signedContent = encoder.encode((byte[]) signedData.getSignedContent().getContent());
        System.out.println(""Signed content==="" + ""\n"" + signedContent + ""==="" + signedContent.length() + ""\n"");
        String envelopedData = encoder.encode(signedData.getEncoded());
        System.out.println(""Enveloped data==="" + ""\n"" + envelopedData + ""==="" + envelopedData.length());

        return envelopedData;
    }
</code></pre>
","","13","<java><digital-signature><bouncycastle><x509certificate><pkcs#7>","0","","0","2018-11-13 09:47:03","","0","","","","","2018-11-13 09:47:03",""
"56861061","How to get a certain sequence of self-signature on python3?","<p>I need to get the python3 from the key signature raw data from the second sequence. I can not say how it is exactly called. This is part of the public key that is signed by the APK package. Android type <a href=""https://developer.android.com/reference/android/content/pm/Signature.html"" rel=""nofollow noreferrer"">Signature</a></p>

<p>In C #, I just write.</p>

<pre><code>var certfile = System.IO.Path.GetFullPath (file);
var Cert = X509Certificate.CreateFromCertFile (certfile);
System.IO.File.WriteAllBytes (v + ""RSA_PUBLIC_DATE.RSA"", Cert.GetRawCertData ());
</code></pre>

<p>Can't do the same thing on python3. I tried different libraries. Many people know this type of key. But do not work with primitives.</p>

<p><a href=""https://lapo.it/asn1js/#MIIFsQYJKoZIhvcNAQcCoIIFojCCBZ4CAQExCzAJBgUrDgMCGgUAMAsGCSqGSIb3DQEHAaCCA64wggOqMIICkgIJAOxe7dPW2gT3MA0GCSqGSIb3DQEBBQUAMIGVMQswCQYDVQQGEwJSVTETMBEGA1UECBMKUGV0ZXJzYnVyZzEYMBYGA1UEBxMPU2FpbnRQZXRlcnNidXJnMRMwEQYDVQQKEwpVbml2ZXJzaXR5MREwDwYDVQQLEwhNaWxreVdheTENMAsGA1UEAxMEQWxleDEgMB4GCSqGSIb3DQEJARYRbHVjZW11c0BnbWFpbC5jb20wIBcNMTYxMDA5MDIwMTM1WhgPMjA2MzA1MjQwNDQzNDNaMIGVMQswCQYDVQQGEwJSVTETMBEGA1UECBMKUGV0ZXJzYnVyZzEYMBYGA1UEBxMPU2FpbnRQZXRlcnNidXJnMRMwEQYDVQQKEwpVbml2ZXJzaXR5MREwDwYDVQQLEwhNaWxreVdheTENMAsGA1UEAxMEQWxleDEgMB4GCSqGSIb3DQEJARYRbHVjZW11c0BnbWFpbC5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCxYK86E1KJUmocME-r3I1uk6qV27_B6N07xxyW2n7HPjoakaeL1SddMIDVqxW0S2ZvKNhhjccJ3uZfW7brizA8YHdCWiBCSi9zZ1fH6nm5PI3ss1_HxyLO_VE4-c92Q_bHiS99mLL2QKwD8maBbfXj2iUaScwE2kW-gPWlr9WdwyfhF1aB3FlzQdypXUO5RYHoV_7U1mtNsTb0xsteL6Wd6XBqPqZ9HApfa0_KgEXhLti7vYfvAzY7sSSw-fkQSPYAF_aVUopxXTOfgBfTC_kQZTXYxV3RK5yahnnnWVLWcCYYH9RYUg9LYHrjMcoj2vqZSA6JsUQzJ2MO2L5YAh8vAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAHezD7MWvq59v0KfAxtLg6MnPGQ1X8aaMjG71aVLB6BR4VO_bmclspB97V-ztHwkP_Nj9T4F9fVaimfxEkv6hy_eakw2rzuRuElw4iYs5lKFhH5q-84TtWRB612HEX74MguwGWG6aD1T7tB9VFwPLTIdWIenIfXd9Kk3iLKVDn6lRXTM66YHTEGH976aHAqYnNdeo9hfgfPQe2zAe3UTNNArV-NRLsMZ--i1GYxspuZ4f2zi7N23fuqTiNeQWIhwo0QE_b-dpjnRj2w9HXHz1v0uRkU7fOg7mP26iJ3hcxbb_4NlOS-nqnNgjRQsLS6JY7nlIQ8jJUYivzgVcrmV3lsxggHLMIIBxwIBATCBozCBlTELMAkGA1UEBhMCUlUxEzARBgNVBAgTClBldGVyc2J1cmcxGDAWBgNVBAcTD1NhaW50UGV0ZXJzYnVyZzETMBEGA1UEChMKVW5pdmVyc2l0eTERMA8GA1UECxMITWlsa3lXYXkxDTALBgNVBAMTBEFsZXgxIDAeBgkqhkiG9w0BCQEWEWx1Y2VtdXNAZ21haWwuY29tAgkA7F7t09baBPcwCQYFKw4DAhoFADANBgkqhkiG9w0BAQEFAASCAQBtXrewl2XTpYHxuQ9YH1mvAJRGHv_KgsG3Fuy9sdVYuobeWGCor-NYlzN_g7MQHaUl8yl7hoWYHSWe3HXWeNy4zn35FxP_QAkFRIw5UMGI0tjUa0W3eXYNhHVOHsbG0OXUakbbHJxhHYdDMk9ugkgKt2ce6gcR3mSOuZiSsCac5qR9Y4_eosxOQPEr-rKQQMQMJVRWN6ylAc4L9eyMZnOUyaUq2YJX1O2Bd_V9_f5UtBW5g2VBmHy6y9TS619DndrMMnMmSE6Odpp-80y7lrqCFABZklYHI0bBnZqCRcnirqNI0ENO_sfrZe7iWDD7WvbM-_BXBCxc_FHAAJaKebr0"" rel=""nofollow noreferrer"">link original saignatures</a></p>

<p><a href=""https://lapo.it/asn1js/#MIIDqjCCApICCQDsXu3T1toE9zANBgkqhkiG9w0BAQUFADCBlTELMAkGA1UEBhMCUlUxEzARBgNVBAgTClBldGVyc2J1cmcxGDAWBgNVBAcTD1NhaW50UGV0ZXJzYnVyZzETMBEGA1UEChMKVW5pdmVyc2l0eTERMA8GA1UECxMITWlsa3lXYXkxDTALBgNVBAMTBEFsZXgxIDAeBgkqhkiG9w0BCQEWEWx1Y2VtdXNAZ21haWwuY29tMCAXDTE2MTAwOTAyMDEzNVoYDzIwNjMwNTI0MDQ0MzQzWjCBlTELMAkGA1UEBhMCUlUxEzARBgNVBAgTClBldGVyc2J1cmcxGDAWBgNVBAcTD1NhaW50UGV0ZXJzYnVyZzETMBEGA1UEChMKVW5pdmVyc2l0eTERMA8GA1UECxMITWlsa3lXYXkxDTALBgNVBAMTBEFsZXgxIDAeBgkqhkiG9w0BCQEWEWx1Y2VtdXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsWCvOhNSiVJqHDBPq9yNbpOqldu_wejdO8ccltp-xz46GpGni9UnXTCA1asVtEtmbyjYYY3HCd7mX1u264swPGB3QlogQkovc2dXx-p5uTyN7LNfx8cizv1ROPnPdkP2x4kvfZiy9kCsA_JmgW3149olGknMBNpFvoD1pa_VncMn4RdWgdxZc0HcqV1DuUWB6Ff-1NZrTbE29MbLXi-lnelwaj6mfRwKX2tPyoBF4S7Yu72H7wM2O7EksPn5EEj2ABf2lVKKcV0zn4AX0wv5EGU12MVd0SucmoZ551lS1nAmGB_UWFIPS2B64zHKI9r6mUgOibFEMydjDti-WAIfLwIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQB3sw-zFr6ufb9CnwMbS4OjJzxkNV_GmjIxu9WlSwegUeFTv25nJbKQfe1fs7R8JD_zY_U-BfX1Wopn8RJL-ocv3mpMNq87kbhJcOImLOZShYR-avvOE7VkQetdhxF--DILsBlhumg9U-7QfVRcDy0yHViHpyH13fSpN4iylQ5-pUV0zOumB0xBh_e-mhwKmJzXXqPYX4Hz0HtswHt1EzTQK1fjUS7DGfvotRmMbKbmeH9s4uzdt37qk4jXkFiIcKNEBP2_naY50Y9sPR1x89b9LkZFO3zoO5j9uoid4XMW2_-DZTkvp6pzYI0ULC0uiWO55SEPIyVGIr84FXK5ld5b"" rel=""nofollow noreferrer"">link sequnce im want get</a></p>
","","12","<android><python-3.x><rsa><pkcs#7><asn1>","0","","0","2019-07-02 23:12:49","","2","","","","","2019-07-02 23:12:49",""
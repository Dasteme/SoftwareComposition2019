post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"944833","Specified initialization vector (IV) does not match the block size for this algorithm","<p>I am working on a base encryption method. I am using RijndaelManaged. I got this code from somewhere a long time ago, but can't remember where.</p>

<p>I had my code working before, but something changed and I cannot quite figure it out.</p>

<p>When I run my code, I get the following error;</p>

<blockquote>
  <p>Specified initialization vector (IV)
  does not match the block size for this
  algorithm.</p>
</blockquote>

<p>Here is my code:</p>

<pre><code>string textToEncrypt = ""TEST STRING"";

int keySize = 256;
string hashAlgorithm = ""SHA1"";
string passPhrase = ""AH!PSB0%FGHR$"";
string saltValue = ""LRT%YUR#VBNL@1"";
string initVector = ""HR$2pIjHR$2pIj"";

byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

byte[] plainTextBytes = Encoding.UTF8.GetBytes(textToEncrypt);

var password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashAlgorithm, 2);

byte[] keyBytes = password.GetBytes(keySize / 8);

RijndaelManaged symmetricKey = new RijndaelManaged();

symmetricKey.Mode = CipherMode.CBC;

ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes,initVectorBytes);

MemoryStream memoryStream = new MemoryStream();

var cryptoStream = new CryptoStream(memoryStream,encryptor,CryptoStreamMode.Write);
cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

cryptoStream.FlushFinalBlock();

byte[] cipherTextBytes = memoryStream.ToArray();

memoryStream.Close();
cryptoStream.Close();

string cipherText = Convert.ToBase64String(cipherTextBytes);
</code></pre>

<p>Any help will be appreciated.</p>
","<p>The problem is your initialization vector size needs to be 16 bytes.</p>

<p>Your initial vector size is 14 bytes.</p>

<p>You will need to increase the size of your initial vector by 2 bytes and your code will work.</p>

<p>Example:</p>

<pre><code>string initVector = ""HR$2pIjHR$2pIj12"";
</code></pre>

<p>You will then get the output with your current code and the example IV (initialization vector) size provided:</p>

<p>hAC8hMf3N5Zb/DZhFKi6Sg==</p>

<p>This article provides a good explanation on what the initialization vector is.</p>

<p><a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Initialization_vector</a></p>
","51310","<c#><encryption><rijndaelmanaged><rijndael>","27","59","2","2019-08-11 12:55:14","944845","1","6","107625","","2018-10-06 18:29:06","2009-06-03 13:44:14",""
"944833","Specified initialization vector (IV) does not match the block size for this algorithm","<p>I am working on a base encryption method. I am using RijndaelManaged. I got this code from somewhere a long time ago, but can't remember where.</p>

<p>I had my code working before, but something changed and I cannot quite figure it out.</p>

<p>When I run my code, I get the following error;</p>

<blockquote>
  <p>Specified initialization vector (IV)
  does not match the block size for this
  algorithm.</p>
</blockquote>

<p>Here is my code:</p>

<pre><code>string textToEncrypt = ""TEST STRING"";

int keySize = 256;
string hashAlgorithm = ""SHA1"";
string passPhrase = ""AH!PSB0%FGHR$"";
string saltValue = ""LRT%YUR#VBNL@1"";
string initVector = ""HR$2pIjHR$2pIj"";

byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

byte[] plainTextBytes = Encoding.UTF8.GetBytes(textToEncrypt);

var password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashAlgorithm, 2);

byte[] keyBytes = password.GetBytes(keySize / 8);

RijndaelManaged symmetricKey = new RijndaelManaged();

symmetricKey.Mode = CipherMode.CBC;

ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes,initVectorBytes);

MemoryStream memoryStream = new MemoryStream();

var cryptoStream = new CryptoStream(memoryStream,encryptor,CryptoStreamMode.Write);
cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

cryptoStream.FlushFinalBlock();

byte[] cipherTextBytes = memoryStream.ToArray();

memoryStream.Close();
cryptoStream.Close();

string cipherText = Convert.ToBase64String(cipherTextBytes);
</code></pre>

<p>Any help will be appreciated.</p>
","<p>You should be able to check how many bytes the IV needs to be using:</p>

<pre><code>algorithm.BlockSize / 8
</code></pre>

<p>BlockSize is in bits, so 128 bits / 8 gives 16 bytes of ASCII, and you may also find <code>Rfc2898DeriveBytes</code> a useful class for producing keys.</p>

<pre><code>algorithm.IV = rfc2898DeriveBytesForIV.GetBytes(algorithm.BlockSize / 8);
</code></pre>

<p>Hope it helps.</p>
","51310","<c#><encryption><rijndaelmanaged><rijndael>","27","12","2","2019-08-11 12:55:14","944845","1","6","107625","","2018-10-06 18:29:06","2009-06-03 13:44:14",""
"3431950","Rijndael 256 Encrypt/decrypt between c# and php?","<p><strong>UPDATED</strong></p>

<p>I have made the changes to the C# code so it uses a block size of 256. but now the hello world looks like this <a href=""http://pastebin.com/5sXhMV11"" rel=""noreferrer"">http://pastebin.com/5sXhMV11</a> and I cant figure out what I should use with rtrim() to get ride of the mess at the end.</p>

<p>Also when you say the IV should be random, by this do you mean don't use the same IV more then once or is the way I have coded it wrong?</p>

<p>Thanks again!</p>

<p>Hi,</p>

<p>I'm trying to decrypt a string with PHP that was encrypted in C#. I can't seem to get PHP to decrypt it using mcrypt and could do with some help please. I get the following error with php so I am guessing I'm not setting the IV correctly.</p>

<p><strong>Error: The IV parameter must be as long as the blocksize</strong></p>

<p>Both functions use the same cipher, key, IV and set to CBC mode:</p>

<p>encrypted text from c# = UmzUCnAzThH0nMkIuMisqg==<br>
key 32 long = qwertyuiopasdfghjklzxcvbnmqwerty <br>
iv 16 long = 1234567890123456<br></p>

<p>C#</p>

<pre><code>    public static string EncryptString(string message, string KeyString, string IVString)
    {
        byte[] Key = ASCIIEncoding.UTF8.GetBytes(KeyString);
        byte[] IV = ASCIIEncoding.UTF8.GetBytes(IVString);

        string encrypted = null;
        RijndaelManaged rj = new RijndaelManaged();
        rj.Key = Key;
        rj.IV = IV;
        rj.Mode = CipherMode.CBC;

        try
        {
            MemoryStream ms = new MemoryStream();

            using (CryptoStream cs = new CryptoStream(ms, rj.CreateEncryptor(Key, IV), CryptoStreamMode.Write))
            {
                using (StreamWriter sw = new StreamWriter(cs))
                {
                    sw.Write(message);
                    sw.Close();
                }
                cs.Close();
            }
            byte[] encoded = ms.ToArray();
            encrypted = Convert.ToBase64String(encoded);

            ms.Close();
        }
        catch (CryptographicException e)
        {
            Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message);
            return null;
        }
        catch (UnauthorizedAccessException e)
        {
            Console.WriteLine(""A file error occurred: {0}"", e.Message);
            return null;
        }
        catch (Exception e)
        {
            Console.WriteLine(""An error occurred: {0}"", e.Message);
        }
        finally
        {
            rj.Clear();
        }

        return encrypted;
    }
</code></pre>

<p>PHP</p>

<pre><code>var $mcrypt_cipher = MCRYPT_RIJNDAEL_256;
var $mcrypt_mode = MCRYPT_MODE_CBC;

function decrypt($key, $iv, $encrypted)
{
    $encrypted = base64_decode($encrypted);

    $decrypted = rtrim(mcrypt_decrypt($this-&gt;mcrypt_cipher, $key, $encrypted, $this-&gt;mcrypt_mode, $iv), ""\0"");;
    return $decrypted;
}
</code></pre>

<p>Thanks</p>
","<p>If you want to use Rijndael256 in your C# application you have to set the BlockSize to 256.</p>

<pre><code>RijndaelManaged rj = new RijndaelManaged();
rj.BlockSize = 256;
</code></pre>

<p>And then your iv has to be 256 bits long as well.<br>
see <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.blocksize.aspx"" rel=""noreferrer"">SymmetricAlgorithm.BlockSize Property</a></p>

<hr>

<p>Or the other way round: Currently your C# application uses Rijndael128 and so must your php script. </p>

<pre><code>&lt;?php
class Foo {
  protected $mcrypt_cipher = MCRYPT_RIJNDAEL_128;
  protected $mcrypt_mode = MCRYPT_MODE_CBC;

  public function decrypt($key, $iv, $encrypted)
  {
    $iv_utf = mb_convert_encoding($iv, 'UTF-8');
    return mcrypt_decrypt($this-&gt;mcrypt_cipher, $key, base64_decode($encrypted), $this-&gt;mcrypt_mode, $iv_utf);
  }
}



$encrypted = ""UmzUCnAzThH0nMkIuMisqg=="";
$key = ""qwertyuiopasdfghjklzxcvbnmqwerty"";
$iv = ""1234567890123456"";

$foo = new Foo;
echo $foo-&gt;decrypt($key, $iv, $encrypted);
</code></pre>

<p>prints <code>hello world</code></p>
","29123","<c#><php><encryption><mcrypt><rijndael>","9","9","2","2011-09-09 10:15:37","3432024","2","4","388217","","2010-08-07 21:40:48","2010-08-07 20:34:55",""
"3431950","Rijndael 256 Encrypt/decrypt between c# and php?","<p><strong>UPDATED</strong></p>

<p>I have made the changes to the C# code so it uses a block size of 256. but now the hello world looks like this <a href=""http://pastebin.com/5sXhMV11"" rel=""noreferrer"">http://pastebin.com/5sXhMV11</a> and I cant figure out what I should use with rtrim() to get ride of the mess at the end.</p>

<p>Also when you say the IV should be random, by this do you mean don't use the same IV more then once or is the way I have coded it wrong?</p>

<p>Thanks again!</p>

<p>Hi,</p>

<p>I'm trying to decrypt a string with PHP that was encrypted in C#. I can't seem to get PHP to decrypt it using mcrypt and could do with some help please. I get the following error with php so I am guessing I'm not setting the IV correctly.</p>

<p><strong>Error: The IV parameter must be as long as the blocksize</strong></p>

<p>Both functions use the same cipher, key, IV and set to CBC mode:</p>

<p>encrypted text from c# = UmzUCnAzThH0nMkIuMisqg==<br>
key 32 long = qwertyuiopasdfghjklzxcvbnmqwerty <br>
iv 16 long = 1234567890123456<br></p>

<p>C#</p>

<pre><code>    public static string EncryptString(string message, string KeyString, string IVString)
    {
        byte[] Key = ASCIIEncoding.UTF8.GetBytes(KeyString);
        byte[] IV = ASCIIEncoding.UTF8.GetBytes(IVString);

        string encrypted = null;
        RijndaelManaged rj = new RijndaelManaged();
        rj.Key = Key;
        rj.IV = IV;
        rj.Mode = CipherMode.CBC;

        try
        {
            MemoryStream ms = new MemoryStream();

            using (CryptoStream cs = new CryptoStream(ms, rj.CreateEncryptor(Key, IV), CryptoStreamMode.Write))
            {
                using (StreamWriter sw = new StreamWriter(cs))
                {
                    sw.Write(message);
                    sw.Close();
                }
                cs.Close();
            }
            byte[] encoded = ms.ToArray();
            encrypted = Convert.ToBase64String(encoded);

            ms.Close();
        }
        catch (CryptographicException e)
        {
            Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message);
            return null;
        }
        catch (UnauthorizedAccessException e)
        {
            Console.WriteLine(""A file error occurred: {0}"", e.Message);
            return null;
        }
        catch (Exception e)
        {
            Console.WriteLine(""An error occurred: {0}"", e.Message);
        }
        finally
        {
            rj.Clear();
        }

        return encrypted;
    }
</code></pre>

<p>PHP</p>

<pre><code>var $mcrypt_cipher = MCRYPT_RIJNDAEL_256;
var $mcrypt_mode = MCRYPT_MODE_CBC;

function decrypt($key, $iv, $encrypted)
{
    $encrypted = base64_decode($encrypted);

    $decrypted = rtrim(mcrypt_decrypt($this-&gt;mcrypt_cipher, $key, $encrypted, $this-&gt;mcrypt_mode, $iv), ""\0"");;
    return $decrypted;
}
</code></pre>

<p>Thanks</p>
","<p>Encrypt using PHP;</p>

<pre><code>/Generate public key for encrytion
$path = ""keys/"";

    $crt = openssl_x509_read(file_get_contents($path.""cert.crt""));
    $publickey = openssl_get_publickey($crt);

    //Encrypt using public key
    openssl_public_encrypt($source, $crypted, $publickey);

    //openssl_private_encrypt($source, $crypted, $privkey);
    echo base64_encode($crypted);
</code></pre>

<p>Decrypt using C#</p>

<pre><code>    X509Certificate2 x509cert = new X509Certificate2(pKeyFilename);
    RSACryptoServiceProvider.UseMachineKeyStore = false;
    RSACryptoServiceProvider crypt = (RSACryptoServiceProvider)x509cert.PrivateKey;                

    byte[] decrypted = crypt.Decrypt(Convert.FromBase64String(data), false);
    return ASCIIEncoding.UTF8.GetString(decrypted);
</code></pre>

<p>where pKeyFilename is a Personal Information Exchange File created with the certificate file cert.crt. This examples uses a AES-256 encryption.</p>
","29123","<c#><php><encryption><mcrypt><rijndael>","9","-1","2","2011-09-09 10:15:37","3432024","2","4","388217","","2010-08-07 21:40:48","2010-08-07 20:34:55",""
"270510","How to encrypt in VBScript using AES?","<p>I am looking to encrypt some data using <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">Rijndael/AES</a> in <a href=""http://en.wikipedia.org/wiki/VBScript"" rel=""noreferrer"">VBScript</a> using a specific key and <a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""noreferrer"">IV</a> value. Are there any good function libraries or COM components that would be good to use?</p>

<p>I looked at <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">CAPICOM</a>; it allows a passphrase only, and won't allow setting specific key and IV values.</p>
","<p>Somebody wrote a short tutorial on using AES is VBScript:
<a href=""http://www.example-code.com/vbscript/AesIv.asp"" rel=""nofollow noreferrer"">http://www.example-code.com/vbscript/AesIv.asp</a></p>

<p>The module mentioned in that tutorial can be found at:
<a href=""http://www.chilkatsoft.com/refdoc/xChilkatCrypt2Ref.html"" rel=""nofollow noreferrer"">http://www.chilkatsoft.com/refdoc/xChilkatCrypt2Ref.html</a></p>
","23695","<asp-classic><vbscript><aes><rijndael><rfc2898>","11","1","6","2018-01-26 12:16:49","","1","5","63550","ALassek","2010-03-22 19:19:06","2008-11-06 22:05:56",""
"270510","How to encrypt in VBScript using AES?","<p>I am looking to encrypt some data using <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">Rijndael/AES</a> in <a href=""http://en.wikipedia.org/wiki/VBScript"" rel=""noreferrer"">VBScript</a> using a specific key and <a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""noreferrer"">IV</a> value. Are there any good function libraries or COM components that would be good to use?</p>

<p>I looked at <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">CAPICOM</a>; it allows a passphrase only, and won't allow setting specific key and IV values.</p>
","<p>One option would be to create a simple wrapper class in .NET for the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""nofollow noreferrer"">RijndaelManaged class</a> from the .NET framework and expose it via <a href=""http://msdn.microsoft.com/en-us/library/zsfww439.aspx"" rel=""nofollow noreferrer"" title=""Exposing .NET Framework Components to COM"">COM Interop</a> so you can call it from VBScript.</p>
","23695","<asp-classic><vbscript><aes><rijndael><rfc2898>","11","-1","6","2018-01-26 12:16:49","","1","5","63550","ALassek","2010-03-22 19:19:06","2008-11-06 22:05:56",""
"270510","How to encrypt in VBScript using AES?","<p>I am looking to encrypt some data using <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">Rijndael/AES</a> in <a href=""http://en.wikipedia.org/wiki/VBScript"" rel=""noreferrer"">VBScript</a> using a specific key and <a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""noreferrer"">IV</a> value. Are there any good function libraries or COM components that would be good to use?</p>

<p>I looked at <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">CAPICOM</a>; it allows a passphrase only, and won't allow setting specific key and IV values.</p>
","<p>One response suggested wrapping the <code>RijndaelManaged</code> class in COM. You could also wrap some other AES implementation in COM.  I just tried <a href=""http://code.google.com/p/slowaes"" rel=""nofollow noreferrer"">SlowAES</a>, which is a JavaScript implementation of AES. Wrapping it in COM via a Windows Script Component makes it callable from VBScript.  I would recommend this only if you cannot use the .NET approach; I would guess the AES for .NET will be faster than the AES implemented in JavaScript. </p>

<p>In my tests of the COM-wrapped-SlowAEs, I used CBC mode, and the encryption was completely compatible with the RijndaelManaged class in .NET. </p>

<p>Here's the WSC; I left out the 3 .js files provided by SlowAES.  You need to insert them unchanged where I marked the file. </p>

<pre><code>&lt;?xml version=""1.0""?&gt;

&lt;!--

//
// Ionic.COM.SlowAES.wsc
//
// This is a Windows Script Component that exposes the SlowAES
// encryption engine via COM. This AES can be used from any 
// COM-capable environment, including Javascript or VBScript. 
//
//
// This code is licensed under the Microsoft Public License. See the
// accompanying License.txt file for details.
//
// Copyright 2009 Dino Chiesa
//

--&gt;

&lt;package&gt;

&lt;component id=""Ionic.Com.SlowAES""&gt;

  &lt;comment&gt;
SlowAES is a Javascript implementation of AES.  
     See http://code.google.com/p/slowaes.  
This is a COM package for SlowAES.
  &lt;/comment&gt;

&lt;?component error=""true"" debug=""true""?&gt;

&lt;registration
  description=""WSC Component for SlowAES""
  progid=""Ionic.Com.SlowAES""
  version=""1.00""
  classid=""{ba78383f-1bcc-4df6-9fb9-61cd639ebc94}""
  remotable=""False""&gt;

  &lt;!-- boilerplate registration/unregistration logic --&gt;
  &lt;script language=""VBScript""&gt;
  &lt;![CDATA[

strComponent = ""Ionic SlowAES""

Function Register
  MsgBox strComponent &amp; "" - registered.""
End Function

Function Unregister
  MsgBox strComponent &amp; "" - unregistered.""
End Function

  ]]&gt;
  &lt;/script&gt;
&lt;/registration&gt;

&lt;public&gt;
  &lt;method name=""EncryptString""&gt;
&lt;parameter name=""plainText""/&gt;
  &lt;/method&gt;

  &lt;method name=""DecryptBytes""&gt;
&lt;parameter name=""cipherText""/&gt;
  &lt;/method&gt;

  &lt;method name=""DecryptBytesToString""&gt;
&lt;parameter name=""cipherText""/&gt;
  &lt;/method&gt;

  &lt;method name=""DecryptHexString""&gt;
&lt;parameter name=""hexStringCipherText""/&gt;
  &lt;/method&gt;

  &lt;method name=""DecryptCommaDelimitedStringToString""&gt;
&lt;parameter name=""cipherText""/&gt;
  &lt;/method&gt;

  &lt;property name=""Key""&gt;
  &lt;put/&gt;
  &lt;/property&gt;

  &lt;property name=""Mode""&gt;
  &lt;put/&gt;
  &lt;get/&gt;
  &lt;/property&gt;

  &lt;property name=""IV""&gt;
  &lt;put/&gt;
  &lt;get/&gt;
  &lt;/property&gt;

  &lt;property name=""KeySize""&gt;
  &lt;put/&gt;
  &lt;get/&gt;
  &lt;/property&gt;
&lt;/public&gt;

&lt;script language=""JavaScript""&gt;
&lt;![CDATA[

// ...insert slowAES code here... //

// defaults
var _keysize = slowAES.aes.SIZE_128;
var _mode = slowAES.modeOfOperation.CBC;
var _iv = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
var _key;

/* 
* byteArrayToHexString
* convert a byte array to hex string.
*/
function byteArrayToHexString(a)
{
try { hexcase } catch(e) { hexcase=0; }
var hex_tab = hexcase ? ""0123456789ABCDEF"" : ""0123456789abcdef"";
var r= """";
for (var i = 0; i &lt; a.length; i++)
{
    var b  = hex_tab.charAt((a[i] &gt;&gt; 4) &amp; 0x0F) + 
    hex_tab.charAt(a[i] &amp; 0x0F);
    r+= b;
}
return r;
}

/* 
* hexStringToByteArray
* convert a string of hex byts to a byte array
*/
function hexStringToByteArray(s)
{
var r= Array(s.length/2);
for (var i = 0; i &lt; s.length; i+=2)
{
    r[i/2] = parseInt(s.substr(i,2),16);
}
return r;
}

function EncryptString(plainText)
{
 var bytesToEncrypt = cryptoHelpers.convertStringToByteArray(plainText);
 var result = slowAES.encrypt(bytesToEncrypt, 
     _mode,
     _key,
     _keysize,
     _iv);
return result['cipher'];
}

function DecryptBytesToString(cipherText)
{
var d = DecryptBytes(cipherText);
var s = cryptoHelpers.convertByteArrayToString(d);
s[cipherText.length]= 0;
return s;
}

function DecryptHexString(hexStringCipherText)
{
var cipherText = hexStringToByteArray(hexStringCipherText);
return DecryptBytesToString(cipherText);
}

function DecryptCommaDelimitedStringToString(cipherText)
{
var c = [];
var atoms = cipherText.split("","");
for (i=0; i &lt; atoms.length; i++)
{
    c.push(parseInt(atoms[i], 10));
}
var d = DecryptBytes(c);
return cryptoHelpers.convertByteArrayToString(d);
}

function DecryptBytes(cipherText)
{
if (cipherText == undefined) return null;

var originalSize = cipherText.length;

var result = slowAES.decrypt(cipherText, 
    originalSize,
    _mode,
    _key,
    _keysize,
    _iv);

return result;
}

function put_Key(keyString)
{
  _key = hexStringToByteArray(keyString);
}

function put_KeySize(size)
{
if (size == 128) _keysize = slowAES.aes.keySize.SIZE_128;
else if (size == 192) _keysize = slowAES.aes.keySize.SIZE_192;
else if (size == 256) _keysize = slowAES.aes.keySize.SIZE_256;
else
    throw ""Unsupported key size.  Must be one of { 128, 192, 256 }."";
}

function get_KeySize()
{
if (_keysize == slowAES.aes.keySize.SIZE_128) return 128;
else if (_keysize == slowAES.aes.keySize.SIZE_192) return 192;
else if (_keysize == slowAES.aes.keySize.SIZE_256) return 256;
else return -1;
}

function put_IV(ivString)
{
    _iv = hexStringToByteArray(ivString);
}

function get_IV()
{
return byteArrayToHexString(_iv);
}

function put_Mode(mode)
{
if (mode == ""CBC"") _mode= slowAES.modeOfOperation.CBC;
else if (mode == ""OFB"") _mode= slowAES.modeOfOperation.OFB;
else if (mode == ""CFB"") _mode= slowAES.modeOfOperation.CFB;
else throw ""Unsupported mode.  Must be one of {CBC, OFB, CFB}"";
}

function get_Mode()
{
if (_mode == slowAES.modeOfOperation.CBC) return ""CBC"";
if (_mode == slowAES.modeOfOperation.OFB) return ""OFB"";
if (_mode == slowAES.modeOfOperation.CFB) return ""CFB"";
return ""???"";
}

]]&gt;

&lt;/script&gt;

&lt;/component&gt;

&lt;/package&gt;
</code></pre>

<p>Save that to a file called SlowAES.wsc.  Register it with ""regsvr32 SlowAES.wsc.""
Here's some VBScript code that uses the component.</p>

<pre><code>' '
' byteArrayToHexString'
' convert a byte array to hex string.'
' '
Function byteArrayToHexString(a)
Dim r,b,i
r = """"
For i = 0 To UBound(a)
    b = Hex( (a(i) And &amp;HF0) / 16) &amp; Hex(a(i) And &amp;HF)
    r= r &amp; b
Next
byteArrayToHexString= r
End Function

' '
' hexStringToByteArray'
' convert a string of hex byts to a byte array'
' '
Function hexStringToByteArray(s)
Dim r()
ReDim r(Len(s)/2-1)
Dim x
For i = 0 To  Len(s)-2 Step 2
    x= ""&amp;H"" &amp; Mid(s,i+1,2)
    r(i/2) = CInt(x)
Next
hexStringToByteArray= r
End Function

Function DemoEncryption()
WScript.echo ""Testing Ionic.Com.SlowAES...""

WScript.echo ""key:              "" &amp; byteArrayToHexString(key)
WScript.echo ""iv:               "" &amp; byteArrayToHexString(iv)
WScript.echo ""key length:       "" &amp; keyLengthInBytes &amp; "" bytes""
WScript.echo ""key length:       "" &amp; (keyLengthInBytes*8) &amp; "" bits""
WScript.echo ""plaintext:        "" &amp; plaintext
WScript.echo ""plaintext.length: "" &amp; Len(plaintext)

WScript.echo ""instantiate Ionic.Com.SlowAES""
Dim aes
set aes = CreateObject(""Ionic.Com.SlowAES"")

WScript.echo ""keysize""
aes.KeySize = keyLengthInBytes * 8

WScript.echo ""key""
aes.Key = byteArrayToHexString(key)

WScript.echo ""iv ""
aes.IV= byteArrayToHexString(iv)

WScript.echo ""mode ""
aes.Mode = ""CBC""

WScript.echo ""encrypting... ""
Dim result
result= aes.EncryptString(plaintext)

' result is a comma-separated string '
' if we Eval() on it we convert it to an array '
Dim expr
expr = ""Array("" &amp; result &amp; "")"" 

result= Eval( expr )

WScript.echo ""Cryptotext/Eval: "" &amp; byteArrayToHexString(result)
WScript.echo ""Cryptotext.length: "" &amp; UBound(result)+1

WScript.echo ""decrypting... ""
Dim decrypted
'The javascript way to do this is to pass the byte array.'
' Like so:'
'    var decrypted = aes.DecryptBytesToString(result);'
' '
'This does not work from VBScript. So, convert to a hexstring,'
'pass the hex string, and then convert back, in the COM component.'
decrypted= aes.DecryptHexString(byteArrayToHexString(result))

WScript.echo ""decrypted: "" &amp; decrypted
End Function

dim plaintext, iv, key, keyLengthInBytes

plaintext= ""Hello. This is a test. of the emergency broadcasting system.""
' iv must be a hexstring representation of an array of bytes, length=16'
iv =  hexStringToByteArray(""feedbeeffeedbeefbaadf00dbaadf00d"")
' key must be a hexstring representation of an array of bytes, length=16 or 32'
key = hexStringToByteArray(""cafebabe0099887766554433221100AA"")
keyLengthInBytes= UBound(key)+1

If Err.Number &lt;&gt; 0 Then Err.Clear

Call DemoEncryption

If (Err.Number &lt;&gt; 0) Then WScript.echo(""Error: "" &amp; Err.Description)
</code></pre>

<p>If you also want a password-based key derivation capability, then you can grab <a href=""http://anandam.name/pbkdf2/"" rel=""nofollow noreferrer"">the very succint JavaScript code for PBKDF2 here</a>, and <a href=""http://cheeso.members.winisp.net/srcview.aspx?dir=AES-example&amp;file=Ionic.Com.PBKDF2.wsc"" rel=""nofollow noreferrer"">create another WSC for that</a>, without too much trouble.</p>

<hr>

<p><strong>EDIT</strong>:  I did what I described - grabbed the source for PBKDF2 and integrated it into the code for SlowAES.  I also produced a second, independent implementation in C# that uses the built-in .NET class libraries to do the RFC 2898-key derivation and AES encryption.  </p>

<p>The result is 3 test applications, one in C#, one in JavaScript and another in VBScript.  <a href=""http://cheeso.members.winisp.net/srcview.aspx?dir=AES-example"" rel=""nofollow noreferrer"">The source is available</a>. They all take the same set of arguments.  They each use a <a href=""http://tools.ietf.org/html/rfc2898"" rel=""nofollow noreferrer"">RFC 2898</a>-compliant key derivation function.  You can specify the password, <a href=""http://en.wikipedia.org/wiki/Salt_%28cryptography%29"" rel=""nofollow noreferrer"">salt</a>, <a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""nofollow noreferrer"">IV</a>, and plaintext, as well as the number of RFC 2898 iterations to use in the <a href=""http://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow noreferrer"">PBKDF2</a>.  You can easily verify that the ciphertext is the same for each of these test programs. Maybe this example will be useful for someone. </p>
","23695","<asp-classic><vbscript><aes><rijndael><rfc2898>","11","3","6","2018-01-26 12:16:49","","1","5","63550","ALassek","2010-03-22 19:19:06","2008-11-06 22:05:56",""
"270510","How to encrypt in VBScript using AES?","<p>I am looking to encrypt some data using <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">Rijndael/AES</a> in <a href=""http://en.wikipedia.org/wiki/VBScript"" rel=""noreferrer"">VBScript</a> using a specific key and <a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""noreferrer"">IV</a> value. Are there any good function libraries or COM components that would be good to use?</p>

<p>I looked at <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">CAPICOM</a>; it allows a passphrase only, and won't allow setting specific key and IV values.</p>
","<p>I know this question is old and OP disappeared, but it is worth noting for future vb6 users that VbCorLib now supports cryptography, including the dreaded Rijndael.</p>

<p>Link: <a href=""http://vbcorlib.blogspot.com/"" rel=""nofollow"">http://vbcorlib.blogspot.com/</a></p>
","23695","<asp-classic><vbscript><aes><rijndael><rfc2898>","11","1","6","2018-01-26 12:16:49","","1","5","63550","ALassek","2010-03-22 19:19:06","2008-11-06 22:05:56",""
"270510","How to encrypt in VBScript using AES?","<p>I am looking to encrypt some data using <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">Rijndael/AES</a> in <a href=""http://en.wikipedia.org/wiki/VBScript"" rel=""noreferrer"">VBScript</a> using a specific key and <a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""noreferrer"">IV</a> value. Are there any good function libraries or COM components that would be good to use?</p>

<p>I looked at <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">CAPICOM</a>; it allows a passphrase only, and won't allow setting specific key and IV values.</p>
","<p>Old question- that really never gets old! One way is to declare encryption classes within vbscript, without needing external added COM objects or wrapper. The following example takes a string, encrypts and decrypts using Rijndael managed class:</p>

<pre><code>'-----------------------------------------------------
Dim obj,arr,i,r,str,enc,asc
dim bytes,bytesd,s,sc,sd
set obj=WScript.CreateObject(""System.Security.Cryptography.RijndaelManaged"")
Set asc = CreateObject(""System.Text.UTF8Encoding"")
s=""This is a private message""
bytes=asc.GetBytes_4(s)
obj.GenerateKey()
obj.GenerateIV()
set enc=obj.CreateEncryptor()
set dec=obj.CreateDecryptor()

bytec=enc.TransformFinalBlock((bytes),0,lenb(bytes))
sc=asc.GetString((bytec))
msgbox sc

byted=dec.TransformFinalBlock((bytec),0,lenb(bytec))
sd=asc.GetString((byted))
msgbox sd
'-----------------------------------------------------
</code></pre>

<p>Best,</p>
","23695","<asp-classic><vbscript><aes><rijndael><rfc2898>","11","6","6","2018-01-26 12:16:49","","1","5","63550","ALassek","2010-03-22 19:19:06","2008-11-06 22:05:56",""
"270510","How to encrypt in VBScript using AES?","<p>I am looking to encrypt some data using <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">Rijndael/AES</a> in <a href=""http://en.wikipedia.org/wiki/VBScript"" rel=""noreferrer"">VBScript</a> using a specific key and <a href=""http://en.wikipedia.org/wiki/Initialization_vector"" rel=""noreferrer"">IV</a> value. Are there any good function libraries or COM components that would be good to use?</p>

<p>I looked at <a href=""http://en.wikipedia.org/wiki/CAPICOM"" rel=""noreferrer"">CAPICOM</a>; it allows a passphrase only, and won't allow setting specific key and IV values.</p>
","<p>Here's my solution. It saves the the encryption key and initialization vector to a file so they can be reused. </p>

<pre><code>Dim objAes, objAesEncryptor, objAesDecryptor, objUtf8Encoder
Dim objStream, objFileSystem
Dim strMyTextInUtf8, strMyEncyptedInUtf8, strMyText, strEncryptedInAnsi, strDecryptedInAnsi
Dim strMyAesKeyFilename,strMyAesIvFilename
Const adTypeBinary = 1
Const adSaveCreateOverWrite = 2
Const adSaveCreateNotExist = 1

' https://stackoverflow.com/questions/270510/how-to-encrypt-in-vbscript-using-aes#28129895

Set objAes=WScript.CreateObject(""System.Security.Cryptography.RijndaelManaged"")
Set objUtf8Encoder = CreateObject(""System.Text.UTF8Encoding"")
strMyText = ""This is a private message""
strMyTextInUtf8=objUtf8Encoder.GetBytes_4(strMyText)

strMyAesKeyFilename = ""c:\Temp\objAes.Key"" 'objAes.Key
strMyAesIvFilename  = ""c:\Temp\objAes.IV"" 'objAes.IV
Set objFileSystem = CreateObject(""Scripting.FileSystemObject"")
set objStream = createobject(""Adodb.Stream"")
objStream.Type = adTypeBinary
objStream.open
If (objFileSystem.FileExists(strMyAesKeyFilename) And objFileSystem.FileExists(strMyAesKeyFilename)) Then   
   objStream.LoadFromFile strMyAesKeyFilename
   objAes.Key = objStream.Read
   objStream.Close
   objStream.Open
   objStream.LoadFromFile strMyAesIvFilename
   objAes.IV = objStream.Read
Else
   objAes.GenerateKey()
   objAes.GenerateIV()
   objStream.write objAes.Key
   objStream.savetofile strMyAesKeyFilename, adSaveCreateOverWrite
   objStream.Close
   objStream.open
   objStream.write objAes.IV
   objStream.savetofile strMyAesIvFilename, adSaveCreateOverWrite
   objStream.Close
End IF

Set objAesEncryptor = objAes.CreateEncryptor()
Set objAesDecryptor = objAes.CreateDecryptor()

strMyEncyptedInUtf8 = objAesEncryptor.TransformFinalBlock((strMyTextInUtf8),0,lenb(strMyTextInUtf8))
strEncryptedInAnsi = objUtf8Encoder.GetString((strMyEncyptedInUtf8))
WScript.Echo ""Encrypted In Ansi: "" &amp; strEncryptedInAnsi

strMyDecyptedInUtf8 = objAesDecryptor.TransformFinalBlock((strMyEncyptedInUtf8),0,lenb(strMyEncyptedInUtf8))
strDecryptedInAnsi = objUtf8Encoder.GetString((strMyDecyptedInUtf8))
WScript.Echo ""Decrypted In Ansi: "" &amp; strDecryptedInAnsi
</code></pre>

<p>Running the script looks like this:</p>

<pre><code>c:\Temp&gt;cscript //nologo TestAesCipher2.vbs
Encrypted In Ansi:  M!???↔???I?!?Q?%&amp;↑?M?n?(?\??o?
Decrypted In Ansi: This is a private message

c:\Temp&gt;cscript //nologo TestAesCipher2.vbs
Encrypted In Ansi:  M!???↔???I?!?Q?%&amp;↑?M?n?(?\??o?
Decrypted In Ansi: This is a private message
</code></pre>
","23695","<asp-classic><vbscript><aes><rijndael><rfc2898>","11","-1","6","2018-01-26 12:16:49","","1","5","63550","ALassek","2010-03-22 19:19:06","2008-11-06 22:05:56",""
"19441640","How can I encrypt and decrypt using AES 128 without an IV?","<p>I'm currently needing a way to encrypt a string and decrypt a byte array using AES-128 symmetrical encryption, in C#. I can't find a way how to do this, but maybe I've missed something.</p>
","<p>Import namespaces</p>

<pre><code>using System;
using System.IO;
using System.Text;
using System.Security.Cryptography;

     static void Main(string[] args)
        {
            string value = ""@arifansari300&lt;3&gt;"";

            string encryptedValue= EncryptDecrypt.Encrypt(value);

            string decryptedValue = EncryptDecrypt.Decrypt(encryptedValue);
        }

    public static string Encrypt(string clearText)
    {
        string EncryptionKey = ""MAKV2SPBNI99212"";
        byte[] clearBytes = Encoding.Unicode.GetBytes(clearText);
        using (Aes encryptor = Aes.Create())
        {
            Rfc2898DeriveBytes pdb = new 
                Rfc2898DeriveBytes(EncryptionKey, new byte[] 
                { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
            encryptor.Key = pdb.GetBytes(32);
            encryptor.IV = pdb.GetBytes(16);
            using (MemoryStream ms = new MemoryStream())
            {
                using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(clearBytes, 0, clearBytes.Length);
                    cs.Close();
                }
                clearText = Convert.ToBase64String(ms.ToArray());
            }
        }
        return clearText;
    }

    public static string Decrypt(string cipherText)
    {
        string EncryptionKey = ""MAKV2SPBNI99212"";
        byte[] cipherBytes = Convert.FromBase64String(cipherText);
        using (Aes encryptor = Aes.Create())
        {
            Rfc2898DeriveBytes pdb = new 
                Rfc2898DeriveBytes(EncryptionKey, new byte[] 
                { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
            encryptor.Key = pdb.GetBytes(32);
            encryptor.IV = pdb.GetBytes(16);
            using (MemoryStream ms = new MemoryStream())
            {
                using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(cipherBytes, 0, cipherBytes.Length);
                    cs.Close();
                }
                cipherText = Encoding.Unicode.GetString(ms.ToArray());
            }
        }
        return cipherText;
    }
</code></pre>
","21560","<c#><encryption><aes><rijndael>","5","11","1","2013-10-19 00:10:38","19441805","3","5","","","","2013-10-18 04:32:16",""
"939040","When will C# AES algorithm be FIPS compliant?","<p>Right now the only way I can get the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""noreferrer"">RijndaelManaged</a> algorithm to work on a computer with the Local Security Setting for FIPS turned on, is to <a href=""http://blog.aggregatedintelligence.com/2007/10/fips-validated-cryptographic-algorithms.html"" rel=""noreferrer"">disable it</a>.  It is a government computer, so I'm not sure how that will fly.  I've seen posts on the <a href=""http://blogs.msdn.com/shawnfa/archive/2006/10/09/The-Differences-Between-Rijndael-and-AES.aspx"" rel=""noreferrer"">msdn blog sites</a> that say they are working on an AES FIPS compliant version, but I cant seem to find out anything more.  Does anyone know when this might happen?</p>
","<p>I never realized this before this question, but you're right. The constructor has this:</p>

<pre><code>public RijndaelManaged()
{
    if (Utils.FipsAlgorithmPolicy == 1)
    {
        throw new InvalidOperationException(Environment.GetResourceString(""Cryptography_NonCompliantFIPSAlgorithm""));
    }
}
</code></pre>

<p><a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.aesmanaged.aspx"" rel=""noreferrer"">System.Security.Cryptography.AesManaged</a> has something similar:</p>

<pre><code>public AesManaged()
{
    if (CoreCryptoConfig.EnforceFipsAlgorithms)
    {
        throw new InvalidOperationException(SR.GetString(""Cryptography_NonCompliantFIPSAlgorithm""));
    }
    this.m_rijndael = new RijndaelManaged();
    this.m_rijndael.BlockSize = this.BlockSize;
    this.m_rijndael.KeySize = this.KeySize;
}
</code></pre>

<p>Have you tried <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.aescryptoserviceprovider.aspx"" rel=""noreferrer"">System.Security.Cryptography.AesCryptoServiceProvider</a>? It should work since it's using the <a href=""http://en.wikipedia.org/wiki/Cryptographic_API"" rel=""noreferrer"">CAPI</a> based FIPS AES implementation built into Windows.</p>

<p><a href=""http://social.msdn.microsoft.com/Forums/en-US/netfxbcl/thread/e0b4493f-6e20-4b75-a118-6b6e5d26a2a6"" rel=""noreferrer"">This question</a> on Microsoft's .NET Base Class Library forum discusses which algorithms are FIPS compliant and has good links.</p>

<p>It appears that Microsoft is making <a href=""http://support.microsoft.com/kb/811833"" rel=""noreferrer"">a consistent effort to obey the setting</a> of HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\FIPSAlgorithmPolicy on pre-Vista machines and use of the <a href=""http://msdn.microsoft.com/en-us/library/aa375460(VS.85).aspx"" rel=""noreferrer"">BCryptGetFipsAlgorithmMode</a> API for post-Vista.</p>

<p>I assume there is non-trivial effort involved in certifying an implementation as FIPS compliant, that is why Microsoft probably doesn't want to repeat the process and only offers the AesCryptoServiceProvider for customers that absolutely need this requirement.</p>

<p><a href=""http://blogs.msdn.com/shawnfa/archive/2005/05/16/417975.aspx"" rel=""noreferrer"">This MSDN blog post</a> has a comment that makes it clearer:</p>

<blockquote>
  <p>The easy way to figure out if an
  algorithm is compliant or not is to
  look at the suffix.  None of the
  *Managed types are FIPS certified.  The *CryptoServiceProvider and *Cng
  types however, may well be FIPS
  certified.  If they implement an
  algorithm that FIPS allows, and are
  using the default Microsoft providers,
  then they will be.</p>
  
  <p>For instance, SHA256Managed is not
  (because it is *Managed). 
  SHA256CryptoServiceProvider and
  SHA256Cng are.<br>
  MD5CryptoServiceProvider is not
  (because MD5 is not a FIPS algorithm).</p>
</blockquote>
","11054","<c#><security><rijndaelmanaged><rijndael><fips>","17","16","4","2018-04-12 01:41:09","","4","9","95573","","2009-06-03 21:45:22","2009-06-02 11:37:06",""
"939040","When will C# AES algorithm be FIPS compliant?","<p>Right now the only way I can get the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""noreferrer"">RijndaelManaged</a> algorithm to work on a computer with the Local Security Setting for FIPS turned on, is to <a href=""http://blog.aggregatedintelligence.com/2007/10/fips-validated-cryptographic-algorithms.html"" rel=""noreferrer"">disable it</a>.  It is a government computer, so I'm not sure how that will fly.  I've seen posts on the <a href=""http://blogs.msdn.com/shawnfa/archive/2006/10/09/The-Differences-Between-Rijndael-and-AES.aspx"" rel=""noreferrer"">msdn blog sites</a> that say they are working on an AES FIPS compliant version, but I cant seem to find out anything more.  Does anyone know when this might happen?</p>
","<p>The unmanaged AesCryptoServiceProvider is certified if the OS itself is certified as it calls the OS. And it will be a darned site quicker as well, at the cost of cross platform compatibility.</p>
","11054","<c#><security><rijndaelmanaged><rijndael><fips>","17","1","4","2018-04-12 01:41:09","","4","9","95573","","2009-06-03 21:45:22","2009-06-02 11:37:06",""
"939040","When will C# AES algorithm be FIPS compliant?","<p>Right now the only way I can get the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""noreferrer"">RijndaelManaged</a> algorithm to work on a computer with the Local Security Setting for FIPS turned on, is to <a href=""http://blog.aggregatedintelligence.com/2007/10/fips-validated-cryptographic-algorithms.html"" rel=""noreferrer"">disable it</a>.  It is a government computer, so I'm not sure how that will fly.  I've seen posts on the <a href=""http://blogs.msdn.com/shawnfa/archive/2006/10/09/The-Differences-Between-Rijndael-and-AES.aspx"" rel=""noreferrer"">msdn blog sites</a> that say they are working on an AES FIPS compliant version, but I cant seem to find out anything more.  Does anyone know when this might happen?</p>
","<p>My site had to get a waver for FIPS compliance in .net.</p>
","11054","<c#><security><rijndaelmanaged><rijndael><fips>","17","1","4","2018-04-12 01:41:09","","4","9","95573","","2009-06-03 21:45:22","2009-06-02 11:37:06",""
"939040","When will C# AES algorithm be FIPS compliant?","<p>Right now the only way I can get the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""noreferrer"">RijndaelManaged</a> algorithm to work on a computer with the Local Security Setting for FIPS turned on, is to <a href=""http://blog.aggregatedintelligence.com/2007/10/fips-validated-cryptographic-algorithms.html"" rel=""noreferrer"">disable it</a>.  It is a government computer, so I'm not sure how that will fly.  I've seen posts on the <a href=""http://blogs.msdn.com/shawnfa/archive/2006/10/09/The-Differences-Between-Rijndael-and-AES.aspx"" rel=""noreferrer"">msdn blog sites</a> that say they are working on an AES FIPS compliant version, but I cant seem to find out anything more.  Does anyone know when this might happen?</p>
","<p>This problem is much more complex than most of those responding understand. Here is the true reason why most of people's answers just won't work (I just spent a nearly 48-hour marathon session trying to understand and fix this problem):</p>

<ol>
<li>C# Under Windows has basically 3 encryption providers that ""support"" AES: RijndaelManaged, AesManaged, AesCryptoServiceProvider.</li>
<li>RijndaelManaged implements the full Rijnadael Algorithm (All Options) and so it is a super-set of AES capabilities; however, it is not certified FIPS compliant (because it is capable of doing things not in the FIPS-approved AES specification, like having block size other than 128 bits)</li>
<li>AesManaged is nothing more than a decorator/wrapper over RijndaelManaged that restrict it to a block-size of 128 bits, but, because RijndaelManaged is not FIPS approved, neither is AesManaged</li>
<li>AesCryptoServiceProvider is a C# wrapper over the C-library on Windows for AES that IS FIPS approved; however, in CFB Mode, it only supports 8|16|24|32|40|48|56|64 bits for the FeedbackSize (I can find no documentation that says that FIPS is restricted thusly, so, it's questionable how AesCryptoServiceProvider passsed the FIPS certification - probably somebody played midnight golf with someone else to have it pushed through the certification)</li>
<li>If FIPS mode is turned on on Windows, then RijndaelManaged (and thereby AesManaged) will throw and exception saying they are not FIPS compliant when you attempt to instantiate them.</li>
<li>Some things require AES-128 with CFB of 128-bits FeedbackSize (e.g. SNMPv3 AES according the the RFC).</li>
</ol>

<p>So, if you are in an environment where the following is true:</p>

<ol>
<li>You need AES-128 with CFB-128 (SNMPv3 for example)</li>
<li>You need to do the Crypto from C# without using Non-Microsoft Libs</li>
<li>You need to have FIPS mode turned on on the OS (Gov't requirements for example)</li>
</ol>

<p>Then, your ONLY option (or at least the only I could find after extensive searching and much wailing and gnashing of teeth) is to use RijndaelManaged AND use the ""<code>&lt;configuration&gt; &lt;runtime&gt; &lt;enforceFIPSPolicy enabled=""false""/&gt; &lt;runtime&gt; &lt;/configuration&gt;</code>"" in the Application.exe.config to turn-off FIPS forced compliance for that particular application.</p>

<p>What a nightmare! I hope this answer helps the next unfortunate soul to run into this problem.</p>

<p>Keywords: Cisco IOS SNMPv3 FIPS AES 128 CFB 128 AesCryptoServiceProvider Rijndael</p>
","11054","<c#><security><rijndaelmanaged><rijndael><fips>","17","1","4","2018-04-12 01:41:09","","4","9","95573","","2009-06-03 21:45:22","2009-06-02 11:37:06",""
"3306020","Rijndael decryption in C#","<p>I need to decrypt a string using Rijndael and those values:</p>

<p>key size - 192</p>

<p>block size - 128</p>

<p>key - cmdAj45F37I5ud2134FDg2fF</p>

<p>When I'm using the code below I get an error : string size illigle, can anyone help me?</p>

<pre><code>public static string DecryptRijndael(string value, string encryptionKey)
    {

            var key = Encoding.UTF8.GetBytes(encryptionKey); //must be 16 chars 
            var rijndael = new RijndaelManaged
            {
                BlockSize = 128,
                IV = key,
                KeySize = 192,
                Key = key
            };

            var buffer = Convert.FromBase64String(value);
            var transform = rijndael.CreateDecryptor();
            string decrypted;
            using (var ms = new MemoryStream())
            {
                using (var cs = new CryptoStream(ms, transform, CryptoStreamMode.Write))
                {
                    cs.Write(buffer, 0, buffer.Length);
                    cs.FlushFinalBlock();
                    decrypted = Encoding.UTF8.GetString(ms.ToArray());
                    cs.Close();
                }
                ms.Close();
            }

            return decrypted;

    }
</code></pre>
","<p>Can you see the comment in your code that says the key <em>""must be 16 chars""</em>? Your key looks more like 24 characters to me!</p>

<p>In this case you're re-using the key as the IV -- not recommended best practice anyway -- but the size of the IV must match the block size, which is set to 128 bits/16 bytes.</p>

<p>Having said that, the problem I just described should give you the error <em>""Specified initialization vector (IV) does not match the block size for this algorithm""</em>, not <em>""string size illigle""</em>, so this might be a red herring.</p>
","10764","<c#><rijndael>","2","2","3","2015-07-30 12:16:48","","2","1","1028323","","2012-03-09 09:19:11","2010-07-22 05:31:14",""
"3306020","Rijndael decryption in C#","<p>I need to decrypt a string using Rijndael and those values:</p>

<p>key size - 192</p>

<p>block size - 128</p>

<p>key - cmdAj45F37I5ud2134FDg2fF</p>

<p>When I'm using the code below I get an error : string size illigle, can anyone help me?</p>

<pre><code>public static string DecryptRijndael(string value, string encryptionKey)
    {

            var key = Encoding.UTF8.GetBytes(encryptionKey); //must be 16 chars 
            var rijndael = new RijndaelManaged
            {
                BlockSize = 128,
                IV = key,
                KeySize = 192,
                Key = key
            };

            var buffer = Convert.FromBase64String(value);
            var transform = rijndael.CreateDecryptor();
            string decrypted;
            using (var ms = new MemoryStream())
            {
                using (var cs = new CryptoStream(ms, transform, CryptoStreamMode.Write))
                {
                    cs.Write(buffer, 0, buffer.Length);
                    cs.FlushFinalBlock();
                    decrypted = Encoding.UTF8.GetString(ms.ToArray());
                    cs.Close();
                }
                ms.Close();
            }

            return decrypted;

    }
</code></pre>
","<p>One (big) problem is in using  <code>UTF8.GetBytes()</code> to get the byte[] from string. It is hard to control the number of bytes and it is not very safe.</p>

<p>Use <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.getbytes.aspx"" rel=""nofollow noreferrer""><code>Rfc2898DeriveBytes.GetBytes()</code></a> instead. And then you can specify the desired length.</p>

<p>But of course you have to do that while encrypting as well.<br>
And I agrre with Luke's remarks about the IV</p>
","10764","<c#><rijndael>","2","3","3","2015-07-30 12:16:48","","2","1","1028323","","2012-03-09 09:19:11","2010-07-22 05:31:14",""
"3306020","Rijndael decryption in C#","<p>I need to decrypt a string using Rijndael and those values:</p>

<p>key size - 192</p>

<p>block size - 128</p>

<p>key - cmdAj45F37I5ud2134FDg2fF</p>

<p>When I'm using the code below I get an error : string size illigle, can anyone help me?</p>

<pre><code>public static string DecryptRijndael(string value, string encryptionKey)
    {

            var key = Encoding.UTF8.GetBytes(encryptionKey); //must be 16 chars 
            var rijndael = new RijndaelManaged
            {
                BlockSize = 128,
                IV = key,
                KeySize = 192,
                Key = key
            };

            var buffer = Convert.FromBase64String(value);
            var transform = rijndael.CreateDecryptor();
            string decrypted;
            using (var ms = new MemoryStream())
            {
                using (var cs = new CryptoStream(ms, transform, CryptoStreamMode.Write))
                {
                    cs.Write(buffer, 0, buffer.Length);
                    cs.FlushFinalBlock();
                    decrypted = Encoding.UTF8.GetString(ms.ToArray());
                    cs.Close();
                }
                ms.Close();
            }

            return decrypted;

    }
</code></pre>
","<p>Error is because of the input being 64 bit encoded. </p>

<p>IV and key is not the same. IV is for salting. Anyway the error you are getting is because the input is 64bit encoded. so do this and the error will go.</p>

<p>var decodedEncryptionKey= Base64Decode(encryptionKey);</p>

<p>var key = Encoding.UTF8.GetBytes(decodedEncryptionKey);</p>

<p>here is the full code: </p>

<pre><code> private string decyptInit(string toBeDecrypted, string key, string initVector)
    {
        var keyByte = Encoding.Default.GetBytes(key);
        var decodedIV = Base64Decode(initVector);
        var iv = Encoding.Default.GetBytes(decodedIV);

        var rijndael = new RijndaelManaged
        {
            BlockSize = 128,
            IV = iv,
            KeySize = 192,
            Key = keyByte
        };

        var buffer = Convert.FromBase64String(toBeDecrypted);
        var transform = rijndael.CreateDecryptor();
        string decrypted;
        using (var ms = new MemoryStream())
        {
            using (var cs = new CryptoStream(ms, transform, CryptoStreamMode.Write))
            {
                cs.Write(buffer, 0, buffer.Length);
                cs.FlushFinalBlock();
                decrypted = Encoding.UTF8.GetString(ms.ToArray());
                cs.Close();
            }
            ms.Close();
        }

        return decrypted;
    } public static string Base64Decode(string base64EncodedData)
    {
        var base64EncodedBytes = System.Convert.FromBase64String(base64EncodedData);
        return System.Text.Encoding.UTF8.GetString(base64EncodedBytes);
    }
</code></pre>
","10764","<c#><rijndael>","2","1","3","2015-07-30 12:16:48","","2","1","1028323","","2012-03-09 09:19:11","2010-07-22 05:31:14",""
"16237475","A first chance exception of type 'System.ArgumentNullException' occurred in mscorlib.dll","<p>I a building a program that can ecnrypt and decrypt files using rijndael algorithm. But if i debug i get the following error: </p>

<blockquote>
  <p>A first chance exception of type 'System.ArgumentNullException' occurred in mscorlib.dll</p>
</blockquote>

<p>this is my code:</p>

<pre><code>    Imports crypter.crypter
Public Class Form1

  Private Sub btnEncrypt_Click(sender As System.Object, e As System.EventArgs) Handles btnEncrypt.Click
    Dim objCrypter As New crypter.crypter
    Dim strPass As String = txtPass.Text
    Dim bytkey As Byte()
    Dim bytIV As Byte()

    bytkey = objCrypter.CreateKey(strPass)
    bytIV = objCrypter.CreateIV(strPass)

    objCrypter.EncryptOrDecryptFile(txtSource.Text, txtDestination.Text, bytkey, bytIV, CryptoAction.ActionEncrypt)


  End Sub


  Private Sub btnDecrypt_Click(sender As Object, e As System.EventArgs) Handles btnDecrypt.Click
    Dim objCrypter As New crypter.crypter
    Dim strPass As String = txtPass.Text
    Dim bytkey As Byte()
    Dim bytIV As Byte()

    bytkey = objCrypter.CreateKey(strPass)
    bytIV = objCrypter.CreateIV(strPass)

    objCrypter.EncryptOrDecryptFile(txtSource.Text, txtDestination.Text, bytkey, bytIV, crypter.crypter.CryptoAction.ActionDecrypt)

  End Sub
End Class
</code></pre>

<p>and this is my code from my class crypter </p>

<pre><code>Imports System
Imports System.IO
Imports System.Security
Imports System.Security.Cryptography

Public Class crypter
#Region ""1. Global Variables ""

    '*************************
    '** Global Variables
    '*************************

    Dim strFileToEncrypt As String
    Dim strFileToDecrypt As String
    Dim strOutputEncrypt As String
    Dim strOutputDecrypt As String
    Dim fsInput As System.IO.FileStream
    Dim fsOutput As System.IO.FileStream

#End Region


#Region ""2. Create A Key ""

    '*************************
    '** Create A Key
    '*************************

    Private Function CreateKey(ByVal strPassword As String) As Byte()
        'Convert strPassword to an array and store in chrData.
        Dim chrData() As Char = strPassword.ToCharArray
        'Use intLength to get strPassword size.
        Dim intLength As Integer = chrData.GetUpperBound(0)
        'Declare bytDataToHash and make it the same size as chrData.
        Dim bytDataToHash(intLength) As Byte

        'Use For Next to convert and store chrData into bytDataToHash.
        For i As Integer = 0 To chrData.GetUpperBound(0)
            bytDataToHash(i) = CByte(Asc(chrData(i)))
        Next

        'Declare what hash to use.
        Dim SHA512 As New System.Security.Cryptography.SHA512Managed
        'Declare bytResult, Hash bytDataToHash and store it in bytResult.
        Dim bytResult As Byte() = SHA512.ComputeHash(bytDataToHash)
        'Declare bytKey(31).  It will hold 256 bits.
        Dim bytKey(31) As Byte

        'Use For Next to put a specific size (256 bits) of 
        'bytResult into bytKey. The 0 To 31 will put the first 256 bits
        'of 512 bits into bytKey.
        For i As Integer = 0 To 31
            bytKey(i) = bytResult(i)
        Next

        Return bytKey 'Return the key.
    End Function

#End Region


#Region ""3. Create An IV ""

    '*************************
    '** Create An IV
    '*************************

    Private Function CreateIV(ByVal strPassword As String) As Byte()
        'Convert strPassword to an array and store in chrData.
        Dim chrData() As Char = strPassword.ToCharArray
        'Use intLength to get strPassword size.
        Dim intLength As Integer = chrData.GetUpperBound(0)
        'Declare bytDataToHash and make it the same size as chrData.
        Dim bytDataToHash(intLength) As Byte

        'Use For Next to convert and store chrData into bytDataToHash.
        For i As Integer = 0 To chrData.GetUpperBound(0)
            bytDataToHash(i) = CByte(Asc(chrData(i)))
        Next

        'Declare what hash to use.
        Dim SHA512 As New System.Security.Cryptography.SHA512Managed
        'Declare bytResult, Hash bytDataToHash and store it in bytResult.
        Dim bytResult As Byte() = SHA512.ComputeHash(bytDataToHash)
        'Declare bytIV(15).  It will hold 128 bits.
        Dim bytIV(15) As Byte

        'Use For Next to put a specific size (128 bits) of 
        'bytResult into bytIV. The 0 To 30 for bytKey used the first 256 bits.
        'of the hashed password. The 32 To 47 will put the next 128 bits into bytIV.
        For i As Integer = 32 To 47
            bytIV(i - 32) = bytResult(i)
        Next

        Return bytIV 'return the IV
    End Function

#End Region


#Region ""4. Encrypt / Decrypt File ""

    '****************************
    '** Encrypt/Decrypt File
    '****************************

    Private Enum CryptoAction
        'Define the enumeration for CryptoAction.
        ActionEncrypt = 1
        ActionDecrypt = 2
    End Enum

    Private Sub EncryptOrDecryptFile(ByVal strInputFile As String, _
                                     ByVal strOutputFile As String, _
                                     ByVal bytKey() As Byte, _
                                     ByVal bytIV() As Byte, _
                                     ByVal Direction As CryptoAction)
        Try 'In case of errors.

            'Setup file streams to handle input and output.
            fsInput = New System.IO.FileStream(strInputFile, FileMode.Open, _
                                               FileAccess.Read)
            fsOutput = New System.IO.FileStream(strOutputFile, FileMode.OpenOrCreate, _
                                                FileAccess.Write)
            fsOutput.SetLength(0) 'make sure fsOutput is empty

            'Declare variables for encrypt/decrypt process.
            Dim bytBuffer(4096) As Byte 'holds a block of bytes for processing
            Dim lngBytesProcessed As Long = 0 'running count of bytes processed
            Dim lngFileLength As Long = fsInput.Length 'the input file's length
            Dim intBytesInCurrentBlock As Integer 'current bytes being processed
      Dim csCryptoStream As CryptoStream
            'Declare your CryptoServiceProvider.
            Dim cspRijndael As New System.Security.Cryptography.RijndaelManaged


            'Determine if ecryption or decryption and setup CryptoStream.
            Select Case Direction
                Case CryptoAction.ActionEncrypt
                    csCryptoStream = New CryptoStream(fsOutput, _
                    cspRijndael.CreateEncryptor(bytKey, bytIV), _
                    CryptoStreamMode.Write)

                Case CryptoAction.ActionDecrypt
                    csCryptoStream = New CryptoStream(fsOutput, _
                    cspRijndael.CreateDecryptor(bytKey, bytIV), _
                    CryptoStreamMode.Write)
            End Select

            'Use While to loop until all of the file is processed.
            While lngBytesProcessed &lt; lngFileLength
                'Read file with the input filestream.
                intBytesInCurrentBlock = fsInput.Read(bytBuffer, 0, 4096)
                'Write output file with the cryptostream.
                csCryptoStream.Write(bytBuffer, 0, intBytesInCurrentBlock)
                'Update lngBytesProcessed
                lngBytesProcessed = lngBytesProcessed + CLng(intBytesInCurrentBlock)
            End While

            'Close FileStreams and CryptoStream.
            csCryptoStream.Close()
            fsInput.Close()
            fsOutput.Close()

            'If encrypting then delete the original unencrypted file.
            If Direction = CryptoAction.ActionEncrypt Then
                Dim fileOriginal As New FileInfo(strFileToEncrypt)
                fileOriginal.Delete()
            End If

            'If decrypting then delete the encrypted file.
            If Direction = CryptoAction.ActionDecrypt Then
                Dim fileEncrypted As New FileInfo(strFileToDecrypt)
                fileEncrypted.Delete()
            End If

        Catch
            fsInput.Close()
            fsOutput.Close()

            If Direction = CryptoAction.ActionDecrypt Then
                Dim fileDelete As New FileInfo(strOutputFile)
                fileDelete.Delete()

            Else
                Dim fileDelete As New FileInfo(strOutputFile)
                fileDelete.Delete()


            End If

        End Try
    End Sub

#End Region

End Class
</code></pre>

<p>Does anybody have an idea about what might be my mistake?</p>

<p>Thanks in advance,</p>
","<p>While I do not know the particular problem, the way I find the causes of first chance exceptions is to go to the Visual Studio Debug menu-> choose the Exceptions entry, check both boxes for Common Language Runtime Exceptions.</p>

<p>Now when you debug, the IDE will break for all exceptions even if they are caught. </p>

<p>Rerun your code and you should see the line that calls into mscorlib and causes the null exception.</p>

<p>Good luck!</p>
","10395","<vb.net><encryption><rijndael>","1","14","1","2013-04-29 20:36:54","16237631","1","","","","","2013-04-26 13:18:29",""
"1278974","PHP Encryption & VB.net Decryption","<p>I'm trying to do a simple task.  Encypt a value in PHP and Decrypt it in my VB.net app.
I figure I'd use tripleDES or Rijdael 128 or 256</p>

<p>I though this should be simple.  Can anyone point me in the right direction?</p>

<p>Thank you</p>
","<p>For PHP you should look at the <a href=""http://ca.php.net/manual/en/book.mcrypt.php"" rel=""nofollow noreferrer"">mcrypt extension</a>, which should support all of the ciphers you specified</p>
","10382","<php><vb.net><encryption><rijndael>","5","0","4","2019-02-19 13:35:58","1279141","1","5","","","","2009-08-14 16:59:10",""
"1278974","PHP Encryption & VB.net Decryption","<p>I'm trying to do a simple task.  Encypt a value in PHP and Decrypt it in my VB.net app.
I figure I'd use tripleDES or Rijdael 128 or 256</p>

<p>I though this should be simple.  Can anyone point me in the right direction?</p>

<p>Thank you</p>
","<p>Disclaimer: I've never actually used the Crytography classes in .NET.</p>

<p>To do Rijndael decryption in .NET, you're probably looking for the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""nofollow noreferrer"">System.Security.Cryptography.RijndaelManaged</a> class.</p>

<p>That page also has some examples of how to use it, although you may also need an instance of <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspx"" rel=""nofollow noreferrer"">RSACryptoServiceProvider</a>... I'm not sure.</p>
","10382","<php><vb.net><encryption><rijndael>","5","0","4","2019-02-19 13:35:58","1279141","1","5","","","","2009-08-14 16:59:10",""
"1278974","PHP Encryption & VB.net Decryption","<p>I'm trying to do a simple task.  Encypt a value in PHP and Decrypt it in my VB.net app.
I figure I'd use tripleDES or Rijdael 128 or 256</p>

<p>I though this should be simple.  Can anyone point me in the right direction?</p>

<p>Thank you</p>
","<p>We have some ciphers working between C# on .NET and PHP. I am not familiar with VB.net. I assume it uses the same crypto library <code>System.Security.Cryptography</code>. </p>

<p>On PHP side, we switched from mcrypt to OpenSSL because some modes and paddings are not supported by mcrypt.</p>

<p>As long as you use same algorithm (DES, AES etc), same mode (CBC, ECB etc), same padding (PKCS1, PKCS5), the cipher should work on both platforms.</p>

<p>Example of encryption using AES-128 on PHP side using mcrypt,</p>

<pre><code>    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
    $blockSize = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128);
    $data = $this-&gt;paddingAlgorithm-&gt;padData($data, $blockSize);
    return $iv . mcrypt_encrypt($this-&gt;MCRYPT_DES, $keyBytes, $data, MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>Please note that we use PKCS7 padding but mcrypt doesn't support it so we have to write the padding algorithm. We also prepend the IV (Initial Vector) to the cipher text. You might store it somewhere else but you need that to decrypt.</p>

<p>Here is the corresponding C# code to setup the cipher to decrypt,</p>

<pre><code>    // create the underlying symmetric algorithm with the given name
    algorithm = (SymmetricAlgorithm)CryptoConfig.CreateFromName(""RIJNDAEL"");
    // set cipher mode
    algorithm.Mode = CipherMode.CBC;
    // set padding mode
    algorithm.Padding = PaddingMode.PKCS7;
</code></pre>
","10382","<php><vb.net><encryption><rijndael>","5","6","4","2019-02-19 13:35:58","1279141","1","5","","","","2009-08-14 16:59:10",""
"1278974","PHP Encryption & VB.net Decryption","<p>I'm trying to do a simple task.  Encypt a value in PHP and Decrypt it in my VB.net app.
I figure I'd use tripleDES or Rijdael 128 or 256</p>

<p>I though this should be simple.  Can anyone point me in the right direction?</p>

<p>Thank you</p>
","<p>I also looked long and hard for solutions to this problem.  Here is a complete set of code for both php and vb.net that will do what you are looking for.  Should be pretty easy to translate to C# as well.</p>

<pre><code>########################################
# BEGIN PHP CODE
########################################


&lt;?php

ini_set('display_errors', 1);
error_reporting(E_ALL);

// I blantantly stole, tweaked and happily used this code from: 
// Lord of Ports http://www.experts-exchange.com/M_1736399.html


$ky = 'lkirwf897+22#bbtrm8814z5qq=498j5'; // 32 * 8 = 256 bit key
$iv = '741952hheeyy66#cs!9hjv887mxx7@8y'; // 32 * 8 = 256 bit iv

$text = ""Here is my data to encrypt!!!"";

$from_vb = ""QBlgcQ2+v3wd8RLjhtu07ZBd8aQWjPMfTc/73TPzlyA="";   // enter value from vb.net app here to test

$etext = encryptRJ256($ky, $iv, $text);
$dtext = decryptRJ256($ky, $iv, $etext);
$vtext = decryptRJ256($ky, $iv, $from_vb);

echo ""&lt;HR&gt;orignal string: $text"";
echo ""&lt;HR&gt;encrypted in php: $etext"";
echo ""&lt;HR&gt;decrypted in php: $dtext"";
echo ""&lt;HR&gt;encrypted in vb: $from_vb"";
echo ""&lt;HR&gt;from vb decrypted in php: $vtext""; 
echo ""&lt;HR&gt;If you like it say thanks! richard dot varno at gmail dot com"";


exit;



function decryptRJ256($key,$iv,$string_to_decrypt)
{

    $string_to_decrypt = base64_decode($string_to_decrypt);

    $rtn = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $string_to_decrypt, MCRYPT_MODE_CBC, $iv);

    $rtn = rtrim($rtn, ""\0\4"");

    return($rtn);

}


function encryptRJ256($key,$iv,$string_to_encrypt)
{

    $rtn = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $string_to_encrypt, MCRYPT_MODE_CBC, $iv);

    $rtn = base64_encode($rtn);

    return($rtn);

}    

?&gt;

########################################
# END PHP CODE
########################################



########################################
# BEGIN VB.NET CODE (console app)
########################################

Imports System
Imports System.Text
Imports System.Security.Cryptography
Imports System.IO

Module Module1

    ' I blantantly stole, tweaked and happily used this code from: 
    ' Lord of Ports http://www.experts-exchange.com/M_1736399.html

    Sub Main()

        'Shared 256 bit Key and IV here
        Dim sKy As String = ""lkirwf897+22#bbtrm8814z5qq=498j5""  '32 chr shared ascii string (32 * 8 = 256 bit)
        Dim sIV As String = ""741952hheeyy66#cs!9hjv887mxx7@8y""  '32 chr shared ascii string (32 * 8 = 256 bit)

        Dim sTextVal As String = ""Here is my data to encrypt!!!""

        Dim eText As String
        Dim dText As String

        eText = EncryptRJ256(sKy, sIV, sTextVal)
        dText = DecryptRJ256(sKy, sIV, eText)

        Console.WriteLine(""key: "" &amp; sKy)
        Console.WriteLine()
        Console.WriteLine("" iv: "" &amp; sIV)
        Console.WriteLine(""txt: "" &amp; sTextVal)
        Console.WriteLine(""encrypted: "" &amp; eText)
        Console.WriteLine(""decrypted: "" &amp; dText)
        Console.WriteLine(""If you like it say thanks! richard dot varno at gmail dot com"")
        Console.WriteLine(""press any key to exit"")
        Console.ReadKey(True)

    End Sub

    Public Function DecryptRJ256(ByVal prm_key As String, ByVal prm_iv As String, ByVal prm_text_to_decrypt As String)

        Dim sEncryptedString As String = prm_text_to_decrypt

        Dim myRijndael As New RijndaelManaged
        myRijndael.Padding = PaddingMode.Zeros
        myRijndael.Mode = CipherMode.CBC
        myRijndael.KeySize = 256
        myRijndael.BlockSize = 256

        Dim key() As Byte
        Dim IV() As Byte

        key = System.Text.Encoding.ASCII.GetBytes(prm_key)
        IV = System.Text.Encoding.ASCII.GetBytes(prm_iv)

        Dim decryptor As ICryptoTransform = myRijndael.CreateDecryptor(key, IV)

        Dim sEncrypted As Byte() = Convert.FromBase64String(sEncryptedString)

        Dim fromEncrypt() As Byte = New Byte(sEncrypted.Length) {}

        Dim msDecrypt As New MemoryStream(sEncrypted)
        Dim csDecrypt As New CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read)

        csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length)

        Return (System.Text.Encoding.ASCII.GetString(fromEncrypt))

    End Function


    Public Function EncryptRJ256(ByVal prm_key As String, ByVal prm_iv As String, ByVal prm_text_to_encrypt As String)

        Dim sToEncrypt As String = prm_text_to_encrypt

        Dim myRijndael As New RijndaelManaged
        myRijndael.Padding = PaddingMode.Zeros
        myRijndael.Mode = CipherMode.CBC
        myRijndael.KeySize = 256
        myRijndael.BlockSize = 256

        Dim encrypted() As Byte
        Dim toEncrypt() As Byte
        Dim key() As Byte
        Dim IV() As Byte

        key = System.Text.Encoding.ASCII.GetBytes(prm_key)
        IV = System.Text.Encoding.ASCII.GetBytes(prm_iv)

        Dim encryptor As ICryptoTransform = myRijndael.CreateEncryptor(key, IV)

        Dim msEncrypt As New MemoryStream()
        Dim csEncrypt As New CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)

        toEncrypt = System.Text.Encoding.ASCII.GetBytes(sToEncrypt)

        csEncrypt.Write(toEncrypt, 0, toEncrypt.Length)
        csEncrypt.FlushFinalBlock()

        encrypted = msEncrypt.ToArray()

        Return (Convert.ToBase64String(encrypted))

    End Function

End Module

########################################
# END VB.NET CODE
########################################
</code></pre>
","10382","<php><vb.net><encryption><rijndael>","5","9","4","2019-02-19 13:35:58","1279141","1","5","","","","2009-08-14 16:59:10",""
"36826445","Rijndael key size in C#","<p>I'm currently developing a little tool in C# that allows me to quickly crypt my files. So I used <a href=""http://www.codeproject.com/Articles/26085/File-Encryption-and-Decryption-in-C"" rel=""nofollow noreferrer"">this script</a> which looks to be perfect for me. But I still have a problem : the key is too short (8 character max). I read in RijndaelManaged() documentation that maximum size for the key is 256 bits, so I should be able to use a 64 character key... (like sha256 hash)</p>

<p>But every time I try to increase the key size, I get a nice ""Encryption failed !"", even for 9 characters. I've been looking for a solution on google for a while, but nothing useful.</p>

<p>The best thing I found <a href=""https://stackoverflow.com/questions/6460793/using-rijndael-to-encrypt-decrypt-files"">is this</a>. So I tried to change the padding like:</p>

<pre><code>RMCrypto.Padding = PaddingMode.ISO10126;

// or
RMCrypto.Padding = PaddingMode.ANSIX923;
</code></pre>

<p>But it did not change anything...</p>
","<p>Padding is for padding the plaintext to the size of the block-length, it has nothing to do with the keysize. </p>

<p>In Rijndael, you are only allowed to use keys of length 128, 160, 192, 224 or 256 bit. (AES-128 --> 128 bit key, AES-256 --> 256 bit key. Block length is still 128 in both). </p>

<p>You cannot trivially change the keylength of a cipher. Usually you'd use key-derivation functions anyways (which in term use hash functions) to get a 128-bit (or whatever size you need) key out of a password-string.</p>

<p>In short, you're misunderstanding padding and the key-lengths of the cipher you're trying to use. If you want arbitrary-length password-strings, use key derivation function. The code in the first link you posted uses e.g. the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes(v=vs.110).aspx"" rel=""nofollow""><code>Rfc2898DeriveBytes</code></a> class. </p>

<p>To set the key length, FIRST change the property <code>.KeySize</code>, THEN set the key.</p>

<pre><code>RijndaelManaged rijndaelCSP = new RijndaelManaged();
rijndaelCSP.KeySize = 256;
//derive key from password and set as .Key.
</code></pre>

<p><a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.keysize%28v=vs.110%29.aspx"" rel=""nofollow"">MSDN documentation</a></p>
","9020","<c#><encryption><rijndael><symmetric-key>","4","1","2","2016-04-24 18:36:01","","4","","-1","","2017-05-23 11:59:38","2016-04-24 17:19:48",""
"36826445","Rijndael key size in C#","<p>I'm currently developing a little tool in C# that allows me to quickly crypt my files. So I used <a href=""http://www.codeproject.com/Articles/26085/File-Encryption-and-Decryption-in-C"" rel=""nofollow noreferrer"">this script</a> which looks to be perfect for me. But I still have a problem : the key is too short (8 character max). I read in RijndaelManaged() documentation that maximum size for the key is 256 bits, so I should be able to use a 64 character key... (like sha256 hash)</p>

<p>But every time I try to increase the key size, I get a nice ""Encryption failed !"", even for 9 characters. I've been looking for a solution on google for a while, but nothing useful.</p>

<p>The best thing I found <a href=""https://stackoverflow.com/questions/6460793/using-rijndael-to-encrypt-decrypt-files"">is this</a>. So I tried to change the padding like:</p>

<pre><code>RMCrypto.Padding = PaddingMode.ISO10126;

// or
RMCrypto.Padding = PaddingMode.ANSIX923;
</code></pre>

<p>But it did not change anything...</p>
","<p>Rjindael's key size is <em>not</em> free to choose. It must be 128-bit, 192-bit, or 256-bit. It cannot be, say, 9 bytes or 18 bytes or 36 bytes. It must strictly be 16 bytes, 24 bytes, or 32 bytes. </p>

<p>Besides, you should first specify your key size suitably <em>before</em> you could use the class correctly. Though both 128-bit and 192-bit key size are allowed, you cannot, for instance, specify the key size to be 128-bit but using 192-bit key. The key size you specify must match the key size you use.</p>

<p>This is an example how you do it:</p>

<p>You could specify your key size (not to be confused with <code>BlockSize</code>) in the <code>RjindaelManaged.KeySize</code> property:</p>

<pre><code>RMCrypto.KeySize = 256;
</code></pre>

<p>And then the key size in byte[] should match with the size of the key above:</p>

<pre><code>byte[] key = new byte[]{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }; 
RMCrypto.Key = key;
</code></pre>

<p>Be sure to use a key that looks like random noise in order to get some security.</p>

<p>Currently your key is too short:</p>

<pre><code>string password = @""myKey123"";
byte[] key = UE.GetBytes(password);
</code></pre>
","9020","<c#><encryption><rijndael><symmetric-key>","4","2","2","2016-04-24 18:36:01","","4","","-1","","2017-05-23 11:59:38","2016-04-24 17:19:48",""
"16138012","Encrypt with PHP Mcrypt and Decrypt with MySQL aes_decrypt?","<p>Is it possible to Encrypt data with PHP <code>mcrypt</code> and decrypt it in the database with MySQL <code>AES_DECRYPT</code>? At the moment, I'm using <code>RIJNDAEL_128</code> for <code>mcrypt</code> on PHP. I've also made sure that the encrypted fields in the database have data type <code>blob</code>. Yet, <code>AES_DECRYPT</code> with the correct key still returns <code>NULL</code>. Any suggestions on how to get this to work?</p>
","<p>If you are encrypting with say mcrypt <code>RIJNDAEL_128</code> on PHP's side then I would recommend to leave decryption on PHP side. I was under the same issue not a long time ago when it came to student ID numbers for one of my applications. I chose against having the database do any sort of encryption / decryption. I highly recommend leaving that to just one system (in this case mcrypt). Reason being now you have less ""moving"" parts that could possibly go wrong allowing for easier maintenance and allows for easier documentation of <a href=""http://en.wikipedia.org/wiki/Audit_trail"" rel=""nofollow"">audit trails</a>. Your database should be used to store data (no surprise) so just make sure the length in the database is suitable for what ever you are storing.</p>

<p>Hopefully this answers your question / helps you out in some sort of way as this is how I would do it / actually am doing it. </p>

<p>Now if you need to see some code on how this would work then just ask. From my understanding though I think you know how to do the encrypt / decrypt but you were just asking if the database should decrypt the information or not. </p>
","8848","<php><mysql><encryption><aes><rijndael>","2","1","3","2015-06-29 15:45:55","16138757","0","2","","","","2013-04-22 01:15:55",""
"16138012","Encrypt with PHP Mcrypt and Decrypt with MySQL aes_decrypt?","<p>Is it possible to Encrypt data with PHP <code>mcrypt</code> and decrypt it in the database with MySQL <code>AES_DECRYPT</code>? At the moment, I'm using <code>RIJNDAEL_128</code> for <code>mcrypt</code> on PHP. I've also made sure that the encrypted fields in the database have data type <code>blob</code>. Yet, <code>AES_DECRYPT</code> with the correct key still returns <code>NULL</code>. Any suggestions on how to get this to work?</p>
","<p>I found some good help <a href=""http://forums.devnetwork.net/viewtopic.php?f=34&amp;t=97082"" rel=""noreferrer"">here</a></p>

<p><strong>Note this works for encrypted text up to 65519 characters in the plain text.</strong> (maybe a bit more if no UTF-8 encoding)</p>

<p>PHP code to encrypt:</p>

<pre><code>// MySQL uses 16 bytes key for 128 encryption/decryption
$key = ""ABCDEF0123456789"";

$plaintext = ""This string was AES-128 / EBC / ZeroBytePadding encrypted."";
// Optionally UTF-8 encode
$plaintext_utf8 = utf8_encode($plaintext);
// Find out what's your padding
$pad_len = 16 - (strlen($plaintext_utf8) % 16);
// Padd your text
$plaintext_utf8 = str_pad($plaintext_utf8, (16 * (floor(strlen($plaintext_utf8) / 16) + 1)), chr($pad_len));

// Encryption
mt_srand();
$td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_ECB, '');
mcrypt_generic_init($td, $key, false);
// Generates a warning about empty IV but it's Ok
$ciphertext = mcrypt_generic($td, $plaintext_utf8);
mcrypt_generic_deinit($td);
$ciphertext = mysql_real_escape_string($ciphertext);

// Store in MySQL
$mysqli = new mysqli(""localhost"", ""test"", ""test"", ""test"");
$mysqli-&gt;set_charset(""utf8"");
$mysqli-&gt;query(""insert into test(content) value ('$ciphertext')"");
$mysqli-&gt;close();
</code></pre>

<p>SQL query to search for <code>string was</code>:</p>

<pre><code>SELECT CAST(AES_DECRYPT(content,'ABCDEF0123456789') AS CHAR) AS content
FROM test
WHERE CAST(AES_DECRYPT(content,'ABCDEF0123456789') AS CHAR) like '%string was%';
</code></pre>

<p>Output is:</p>

<pre><code>This string was AES-128 / EBC / ZeroBytePadding encrypted.
</code></pre>

<p>Note: MySQL table was created by:</p>

<pre><code>create table test (
id int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
content blob ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
</code></pre>
","8848","<php><mysql><encryption><aes><rijndael>","2","5","3","2015-06-29 15:45:55","16138757","0","2","","","","2013-04-22 01:15:55",""
"16138012","Encrypt with PHP Mcrypt and Decrypt with MySQL aes_decrypt?","<p>Is it possible to Encrypt data with PHP <code>mcrypt</code> and decrypt it in the database with MySQL <code>AES_DECRYPT</code>? At the moment, I'm using <code>RIJNDAEL_128</code> for <code>mcrypt</code> on PHP. I've also made sure that the encrypted fields in the database have data type <code>blob</code>. Yet, <code>AES_DECRYPT</code> with the correct key still returns <code>NULL</code>. Any suggestions on how to get this to work?</p>
","<p>Decrypting data in the dabatase during search seems like it could be a problem if you want your solution to be scalable to many users.</p>

<p>I would suggest that you look up the old gem the ""bloom filter"". It is commonly used for spellcheckers but can be used for speeding up search in databases as well.
<a href=""https://en.wikipedia.org/wiki/Bloom_filter"" rel=""nofollow"">https://en.wikipedia.org/wiki/Bloom_filter</a></p>

<p>A bloom filter is a bitmask. You need to create a series of different hashing functions which generate hashes the same size as the bloom filter but where only one random bit is set by each hashing function.</p>

<p>Then you run a word (string) through these hashing functions and add these bits to your filter. Now the filter ""knows"" your word is in it.</p>

<p>The filter is compact because words can overlap each other in the filter.</p>

<p>To check if a word is in the filter you just run your hashing functions on it and check if all bits are set in the filter with a binary AND operation. MySQL supports binary operations.</p>

<p><strong>You can never remove a word from the filter</strong> since the bits can be part of multiple words.</p>

<p>The <strong>text can never be recovered</strong> from a bloom filter.</p>

<p>A bloom filter <strong>can never give a false negative</strong> but it <strong>can give a false positive</strong>. If you get false positives then your filter is too small compared to your data set (words stored in filter) or your hashing functions are not good enough.
How many hashing functions you need depends on the size of the data, try 5-20.</p>

<p>Tip! You can also add pairs of words or triplets of words to your bloom filter.</p>
","8848","<php><mysql><encryption><aes><rijndael>","2","0","3","2015-06-29 15:45:55","16138757","0","2","","","","2013-04-22 01:15:55",""
"9574850","Rijndael padding or length is invalid","<p>I am trying to encrypt/decrypt a string using eith Rijndael or Aes and the code below.</p>

<pre><code>public class Crypto
{
    private const string defaultVector = ""asdfg123456789"";
    private const CipherMode cipherMode = CipherMode.CBC;
    //Have tried PaddingMode.ISO10126, PaddingMode.None, and PaddingMode.PKCS7
    private const PaddingMode paddingMode = PaddingMode.ISO10126;
    private const int iterations = 2;
    private static Rijndael GetCrypto(string passphrase)
    {
        var crypt = Rijndael.Create();
        crypt.Mode = cipherMode;
        crypt.Padding = paddingMode;
        crypt.BlockSize = 256;
        crypt.KeySize = 256;
        crypt.Key =
            new Rfc2898DeriveBytes(passphrase, Encoding.Unicode.GetBytes(defaultVector), iterations).GetBytes(32);
        crypt.IV = new Rfc2898DeriveBytes(passphrase, Encoding.Unicode.GetBytes(defaultVector), iterations).GetBytes(32);
        return crypt;
    }
    public static string Encrypt(string plainText, string passphrase)
    {
        byte[] clearData = Encoding.Unicode.GetBytes(plainText);
        byte[] encryptedData;
        var crypt = GetCrypto(passphrase);
        using (var ms = new MemoryStream())
        {
            using (var cs = new CryptoStream(ms, crypt.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(clearData, 0, clearData.Length);
                //cs.FlushFinalBlock(); //Have tried this active and commented with no change.
            }
            encryptedData = ms.ToArray();
        }
        //Changed per Xint0's answer.
        return Convert.ToBase64String(encryptedData);
    }
    public static string Decrypt(string cipherText, string passphrase)
    {
        //Changed per Xint0's answer.
        byte[] encryptedData = Convert.FromBase64String(cipherText);
        byte[] clearData;
        var crypt = GetCrypto(passphrase);
        using (var ms = new MemoryStream())
        {
                using (var cs = new CryptoStream(ms, crypt.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(encryptedData, 0, encryptedData.Length);
                    //I have tried adding a cs.FlushFinalBlock(); here as well.
                }
                clearData = ms.ToArray();
        }
        return Encoding.Unicode.GetString(clearData);
    }
}
</code></pre>

<p>//Edits: I have changed over the Unicode calls to Convert.ToBase64String per Xint0's answer below. </p>

<p>On the cs.Write in Decrypt method, I am getting the error that ""Padding is invalid and cannot be removed.""</p>

<p>I have tried setting the padding to PaddingMode.None but I get ""Length of the data to encrypt is invalid."" on the cs.Write in the Encrypt method.</p>

<p>I've looked at these and nothing they've said seems to work.</p>

<p><a href=""https://stackoverflow.com/questions/8061581/padding-is-invalid-and-cannot-be-removed"">Padding is invalid and cannot be removed</a></p>

<p><a href=""https://stackoverflow.com/questions/8583112/padding-is-invalid-and-cannot-be-removed"">Padding is invalid and cannot be removed?</a></p>

<p>Stack trace shows System.Security.CryptographicException is coming from RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode paddingMode, Boolean fLast).</p>
","<p>I see two problems:</p>

<ol>
<li><p>You are not flushing and closing the streams before calling <code>ms.ToArray()</code>. Change it to:</p>

<pre><code>...
using (var cs = new CryptoStream(ms, crypt.CreateEncryptor(), CryptoStreamMode.Write))
{
    cs.Write(clearData, 0, clearData.Length);
    cs.FlushFinalBlock();
    cs.Close();
}

ms.Close();
encryptedData = ms.ToArray();
...
</code></pre></li>
<li><p>In <code>Encrypt</code> the resulting byte array <code>encryptedData</code> is <strong>NOT</strong> a Unicode string, yet you are using a Unicode encoder to get a string from the byte array.  Instead of that use <code>System.Convert.ToBase64String()</code> in <code>Encrypt</code> and <code>System.Convert.FromBase64String()</code> in <code>Decrypt</code>.</p></li>
</ol>

<p>In <code>Encrypt</code> do:</p>

<pre><code>return System.Convert.ToBase64String(encryptedData);
</code></pre>

<p>In <code>Decrypt</code> do:</p>

<pre><code>byte[] encryptedData = System.Convert.FromBase64String(cipherText);
</code></pre>

<p><strong>EDIT</strong></p>

<p>The biggest problem is the return value of <code>Encrypt</code>. The result of encrypting the byte representation of a Unicode string is <strong><em>NOT</em></strong> a byte representation of a Unicode string.  You should not use the value of <code>encryptedData</code> with <code>Encoding.Unicode.GetString()</code> to get a string representation of the encrypted data. Use <code>System.Convert.ToBase64String()</code> to get a string representation of the encrypted data.  Please see the Remarks section in the <a href=""http://msdn.microsoft.com/en-us/library/86hf4sb8.aspx"" rel=""nofollow"">Encoding Class</a> MSDN Documentation.</p>

<p><strong>EDIT 2</strong></p>

<p>Note that Rijndael is not exactly AES, if you are interoperating with AES the block size should always be 128-bits, independent of the key size. For details you can read about it <a href=""http://blogs.msdn.com/b/shawnfa/archive/2006/10/09/the-differences-between-rijndael-and-aes.aspx"" rel=""nofollow"">here</a>.</p>
","8761","<c#><aes><rijndael><encryption-symmetric>","1","1","3","2015-02-02 12:14:53","9575191","0","0","-1","","2017-05-23 12:12:08","2012-03-05 22:12:40",""
"9574850","Rijndael padding or length is invalid","<p>I am trying to encrypt/decrypt a string using eith Rijndael or Aes and the code below.</p>

<pre><code>public class Crypto
{
    private const string defaultVector = ""asdfg123456789"";
    private const CipherMode cipherMode = CipherMode.CBC;
    //Have tried PaddingMode.ISO10126, PaddingMode.None, and PaddingMode.PKCS7
    private const PaddingMode paddingMode = PaddingMode.ISO10126;
    private const int iterations = 2;
    private static Rijndael GetCrypto(string passphrase)
    {
        var crypt = Rijndael.Create();
        crypt.Mode = cipherMode;
        crypt.Padding = paddingMode;
        crypt.BlockSize = 256;
        crypt.KeySize = 256;
        crypt.Key =
            new Rfc2898DeriveBytes(passphrase, Encoding.Unicode.GetBytes(defaultVector), iterations).GetBytes(32);
        crypt.IV = new Rfc2898DeriveBytes(passphrase, Encoding.Unicode.GetBytes(defaultVector), iterations).GetBytes(32);
        return crypt;
    }
    public static string Encrypt(string plainText, string passphrase)
    {
        byte[] clearData = Encoding.Unicode.GetBytes(plainText);
        byte[] encryptedData;
        var crypt = GetCrypto(passphrase);
        using (var ms = new MemoryStream())
        {
            using (var cs = new CryptoStream(ms, crypt.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(clearData, 0, clearData.Length);
                //cs.FlushFinalBlock(); //Have tried this active and commented with no change.
            }
            encryptedData = ms.ToArray();
        }
        //Changed per Xint0's answer.
        return Convert.ToBase64String(encryptedData);
    }
    public static string Decrypt(string cipherText, string passphrase)
    {
        //Changed per Xint0's answer.
        byte[] encryptedData = Convert.FromBase64String(cipherText);
        byte[] clearData;
        var crypt = GetCrypto(passphrase);
        using (var ms = new MemoryStream())
        {
                using (var cs = new CryptoStream(ms, crypt.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(encryptedData, 0, encryptedData.Length);
                    //I have tried adding a cs.FlushFinalBlock(); here as well.
                }
                clearData = ms.ToArray();
        }
        return Encoding.Unicode.GetString(clearData);
    }
}
</code></pre>

<p>//Edits: I have changed over the Unicode calls to Convert.ToBase64String per Xint0's answer below. </p>

<p>On the cs.Write in Decrypt method, I am getting the error that ""Padding is invalid and cannot be removed.""</p>

<p>I have tried setting the padding to PaddingMode.None but I get ""Length of the data to encrypt is invalid."" on the cs.Write in the Encrypt method.</p>

<p>I've looked at these and nothing they've said seems to work.</p>

<p><a href=""https://stackoverflow.com/questions/8061581/padding-is-invalid-and-cannot-be-removed"">Padding is invalid and cannot be removed</a></p>

<p><a href=""https://stackoverflow.com/questions/8583112/padding-is-invalid-and-cannot-be-removed"">Padding is invalid and cannot be removed?</a></p>

<p>Stack trace shows System.Security.CryptographicException is coming from RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode paddingMode, Boolean fLast).</p>
","<p>I have spend a lot of my time for finding what was causing <strong>CryptographicException</strong> and I was googling too including Stackoverflow.<br>
It was a stupid mistake (as often when programming with copy-paste) as follow:</p>

<p>It was throwing on method <em>FlushFinalBlock()</em> from instance of <em>CryptoStream</em>.</p>

<p>Look at <strong>WRONG</strong> code:</p>

<pre><code>CryptoStream cs = new CryptoStream(ms, rj.CreateDecryptor(rj.Key, rj.IV), CryptoStreamMode.Write);
</code></pre>

<p>I used it to encrypt so you can see <em>CryptoStreamMode.<strong>Write</em></strong> but in the same instruction I was creating decryptor instead of encryptor (see second parameter in the constructor).</p>

<p>Be careful and check it to avoid wasting your precious time ;)</p>

<p>Regards<br>
Bronek</p>
","8761","<c#><aes><rijndael><encryption-symmetric>","1","3","3","2015-02-02 12:14:53","9575191","0","0","-1","","2017-05-23 12:12:08","2012-03-05 22:12:40",""
"9574850","Rijndael padding or length is invalid","<p>I am trying to encrypt/decrypt a string using eith Rijndael or Aes and the code below.</p>

<pre><code>public class Crypto
{
    private const string defaultVector = ""asdfg123456789"";
    private const CipherMode cipherMode = CipherMode.CBC;
    //Have tried PaddingMode.ISO10126, PaddingMode.None, and PaddingMode.PKCS7
    private const PaddingMode paddingMode = PaddingMode.ISO10126;
    private const int iterations = 2;
    private static Rijndael GetCrypto(string passphrase)
    {
        var crypt = Rijndael.Create();
        crypt.Mode = cipherMode;
        crypt.Padding = paddingMode;
        crypt.BlockSize = 256;
        crypt.KeySize = 256;
        crypt.Key =
            new Rfc2898DeriveBytes(passphrase, Encoding.Unicode.GetBytes(defaultVector), iterations).GetBytes(32);
        crypt.IV = new Rfc2898DeriveBytes(passphrase, Encoding.Unicode.GetBytes(defaultVector), iterations).GetBytes(32);
        return crypt;
    }
    public static string Encrypt(string plainText, string passphrase)
    {
        byte[] clearData = Encoding.Unicode.GetBytes(plainText);
        byte[] encryptedData;
        var crypt = GetCrypto(passphrase);
        using (var ms = new MemoryStream())
        {
            using (var cs = new CryptoStream(ms, crypt.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(clearData, 0, clearData.Length);
                //cs.FlushFinalBlock(); //Have tried this active and commented with no change.
            }
            encryptedData = ms.ToArray();
        }
        //Changed per Xint0's answer.
        return Convert.ToBase64String(encryptedData);
    }
    public static string Decrypt(string cipherText, string passphrase)
    {
        //Changed per Xint0's answer.
        byte[] encryptedData = Convert.FromBase64String(cipherText);
        byte[] clearData;
        var crypt = GetCrypto(passphrase);
        using (var ms = new MemoryStream())
        {
                using (var cs = new CryptoStream(ms, crypt.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(encryptedData, 0, encryptedData.Length);
                    //I have tried adding a cs.FlushFinalBlock(); here as well.
                }
                clearData = ms.ToArray();
        }
        return Encoding.Unicode.GetString(clearData);
    }
}
</code></pre>

<p>//Edits: I have changed over the Unicode calls to Convert.ToBase64String per Xint0's answer below. </p>

<p>On the cs.Write in Decrypt method, I am getting the error that ""Padding is invalid and cannot be removed.""</p>

<p>I have tried setting the padding to PaddingMode.None but I get ""Length of the data to encrypt is invalid."" on the cs.Write in the Encrypt method.</p>

<p>I've looked at these and nothing they've said seems to work.</p>

<p><a href=""https://stackoverflow.com/questions/8061581/padding-is-invalid-and-cannot-be-removed"">Padding is invalid and cannot be removed</a></p>

<p><a href=""https://stackoverflow.com/questions/8583112/padding-is-invalid-and-cannot-be-removed"">Padding is invalid and cannot be removed?</a></p>

<p>Stack trace shows System.Security.CryptographicException is coming from RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode paddingMode, Boolean fLast).</p>
","<p>I had a similar problem, the issue in decrypt method was initializing an empty memory stream. when it worked when I initialized it with the cipher text byte array like this:</p>

<pre><code>MemoryStream ms = new MemoryStream(cipherText);
</code></pre>
","8761","<c#><aes><rijndael><encryption-symmetric>","1","0","3","2015-02-02 12:14:53","9575191","0","0","-1","","2017-05-23 12:12:08","2012-03-05 22:12:40",""
"5758739","Another 'Length of the data to decrypt is invalid.' error","<p>I am receiving a 'Length of the data to decrypt is invalid.' error when attempting to decrypt a string.  I have looked at a number of other references to this error on this site, and tried a number of the suggestions found there, but so far nothing has worked.</p>

<p>I'm sure that I'm missing something fundamental, but I can't see what it is.</p>

<p>I'm using the same key and IV when encrypting and decrypting.  I added <code>FlushFinalBlock()</code> calls when encrypting and decrypting.  I had even attempted to set <code>encryptStream.Position = 0</code>, but that throws an <code>ObjectDisposedException</code>.</p>

<p>I created a console app that illustrates the problem.  The code is below in its entirety:</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Crypto
{
    class Program
    {
        static void Main(string[] args)
        {
            _CryptoString = AESStringEncryption(CRYPTO_STRING);
            _CryptoString = AESStringDecryption(_CryptoString);
        }

        private const string CRYPTO_STRING = ""The quick brown fox jumped over the lazy dog."";

        private static byte[] _KY = { 47, 53, 94, 65, 243, 197, 42, 80, 125, 255, 144, 41, 130, 76, 2, 142, 43, 1, 120, 124, 255, 248, 232, 139, 170, 42, 243, 52, 4, 17, 60, 174 };
        private static byte[] _VI = { 68, 42, 157, 47, 99, 8, 174, 169, 119, 255, 144, 218, 8, 30, 60, 42 };

        private static string _CryptoString;

        /// &lt;summary&gt;
        /// Applies .NET Framework AES (Advanced Encryption Standard) Level encryption to the provided string parameter.
        /// Utilizies the UTF8 encoding stardard for the conversion from string to byte[].
        /// &lt;/summary&gt;
        public static string AESStringEncryption(string unencryptedString)
        {
            byte[] unencryptedBytes = Encoding.UTF8.GetBytes(unencryptedString);
            byte[] encryptedBytes = AESByteArrayEncryption(unencryptedBytes);
            string encryptedString = Encoding.UTF8.GetString(encryptedBytes);

            return encryptedString;
        }

        /// &lt;summary&gt;
        /// Applies .NET Framework AES (Advanced Encryption Standard) Level decryption to the provided string parameter.
        /// Utilizies the UTF8 encoding stardard for the conversion from byte[] to string.
        /// &lt;/summary&gt;
        public static string AESStringDecryption(string encryptedString)
        {
            byte[] encryptedBytes = Encoding.UTF8.GetBytes(encryptedString);
            byte[] decryptedBytes = AESByteArrayDecryption(encryptedBytes);
            string decryptedString = Encoding.UTF8.GetString(decryptedBytes);

            return decryptedString;
        }

        /// &lt;summary&gt;
        /// Applies .NET Framework AES (Advanced Encryption Standard) Level encryption to the provided byte array parameter.
        /// &lt;/summary&gt;
        public static byte[] AESByteArrayEncryption(byte[] unencryptedBytes)
        {
            using (var rm = new RijndaelManaged())
            {
                var encryptor = rm.CreateEncryptor(_KY, _VI);
                using (var encryptStream = new MemoryStream())
                {
                    using (var cryptoStream = new CryptoStream(encryptStream, encryptor, CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(unencryptedBytes, 0, unencryptedBytes.Length);
                        cryptoStream.FlushFinalBlock();
                    }

                    //encryptStream.Position = 0;

                    byte[] encryptedBytes = encryptStream.ToArray();

                    return encryptedBytes;
                }
            }
        }

        /// &lt;summary&gt;
        /// Applies .NET Framework AES (Advanced Encryption Standard) Level decryption to the provided byte array parameter.
        /// &lt;/summary&gt;
        public static byte[] AESByteArrayDecryption(byte[] encryptedBytes)
        {
            using (var rm = new RijndaelManaged())
            {
                var decryptor = rm.CreateDecryptor(_KY, _VI);
                using (var decryptStream = new MemoryStream())
                {
                    using (var cryptoStream = new CryptoStream(decryptStream, decryptor, CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(encryptedBytes, 0, encryptedBytes.Length);
                        cryptoStream.FlushFinalBlock();
                    }

                    //decryptStream.Position = 0;

                    byte[] decryptedBytes = decryptStream.ToArray();

                    return decryptedBytes;
                }
            }
        }
    }
}
</code></pre>
","<p>You can't convert a binary array to UTF-8 - they're not the same thing.  Use Base64 instead.</p>

<p>Inside the encrypt method, the second to last line should be:</p>

<pre><code>string encryptedString = Convert.ToBase64String(encryptedBytes);
</code></pre>

<p>And the decrypt method, the first line is:</p>

<pre><code>byte[] encryptedBytes = Convert.FromBase64String(encryptedString);
</code></pre>
","8410","<c#-4.0><encryption><rijndael>","3","7","1","2011-04-22 18:48:52","5758863","0","","","","","2011-04-22 18:35:43",""
"1937243","How does RFC2898DeriveBytes generate an AES key?","<p>I saw some code like</p>

<pre><code>string password = ""11111111"";
byte[] salt = Encoding.ASCII.GetBytes(""22222222"");
Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, salt);
RijndaelAlg.Key = key.GetBytes(RijndaelAlg.KeySize / 8);
</code></pre>

<p>I can see the key is generated by Rfc2898DeriveBytes with passphrase and salt. Then AES retrieves the key by GetBytes.</p>

<p>But the question is, what does RFC2898DeriveBytes do and what key.GetBytes(cb) do? Could anyone elaborate this? I couldn't get it from the documentation.</p>
","<p>RFC2898 refers to a password-based cryptography specification published in September 2000. Effectively, <code>Rfc2898DeriveBytes</code> takes a password and salt to generate keys. The method it uses is known as PBKDF2 (Password Based Key Derivation Function #2) and is defined in section 5.2 of RFC2898. From section 5.2:</p>

<blockquote>
  <p>PBKDF2 applies a pseudorandom function (see Appendix B.1 for an example) to derive keys. The length of the derived key is essentially unbounded. (However, the maximum effective search space for the derived key may be limited by the structure of the underlying pseudorandom function. See Appendix B.1 for further discussion.) PBKDF2 is recommended for new applications.</p>
</blockquote>

<p>For further details, see <a href=""http://www.ietf.org/rfc/rfc2898.txt"" rel=""noreferrer"">RFC2898</a>.</p>

<p>As for what <code>Rfc2898DeriveBytes.GetBytes</code> does, it returns a different key on each invocation; it effectively just applies PBKDF2 repeatedly with the same password and salt but also an iteration count.</p>

<p>This is outlined in RFC doc where PBKDF2 is defined as</p>

<pre><code>PBKDF2 (P, S, c, dkLen)
</code></pre>

<p>where <code>P</code> is the password, <code>S</code> is the salt, <code>c</code> is the iteration count and <code>dkLen</code> is the length of the desired key.</p>

<p>The <a href=""http://en.wikipedia.org/wiki/Request_for_Comments"" rel=""noreferrer"">RFCs</a> are in general very interesting and historically quite important. <a href=""http://tools.ietf.org/html/rfc1149"" rel=""noreferrer"">RFC 1149</a> is quite important, as is <a href=""http://tools.ietf.org/html/rfc2324"" rel=""noreferrer"">RFC 2324</a>.</p>
","7876","<c#><encryption><aes><rijndael><rfc2898>","6","12","2","2012-06-04 18:31:03","1937303","0","","600500","","2011-08-13 01:16:48","2009-12-20 22:06:50",""
"1937243","How does RFC2898DeriveBytes generate an AES key?","<p>I saw some code like</p>

<pre><code>string password = ""11111111"";
byte[] salt = Encoding.ASCII.GetBytes(""22222222"");
Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, salt);
RijndaelAlg.Key = key.GetBytes(RijndaelAlg.KeySize / 8);
</code></pre>

<p>I can see the key is generated by Rfc2898DeriveBytes with passphrase and salt. Then AES retrieves the key by GetBytes.</p>

<p>But the question is, what does RFC2898DeriveBytes do and what key.GetBytes(cb) do? Could anyone elaborate this? I couldn't get it from the documentation.</p>
","<p>From looking at the implementation in Reflector:</p>

<pre><code>public Rfc2898DeriveBytes(string password, byte[] salt) : this(password, salt, 0x3e8)
{
}

public Rfc2898DeriveBytes(string password, int saltSize, int iterations)
{
    if (saltSize &lt; 0)
    {
        throw new ArgumentOutOfRangeException(""saltSize"", Environment.GetResourceString(""ArgumentOutOfRange_NeedNonNegNum""));
    }
    byte[] data = new byte[saltSize];
    Utils.StaticRandomNumberGenerator.GetBytes(data);
    this.Salt = data;
    this.IterationCount = iterations;
    this.m_hmacsha1 = new HMACSHA1(new UTF8Encoding(false).GetBytes(password));
    this.Initialize();
}


public override byte[] GetBytes(int cb)
{
    if (cb &lt;= 0)
    {
        throw new ArgumentOutOfRangeException(""cb"", Environment.GetResourceString(""ArgumentOutOfRange_NeedNonNegNum""));
    }
    byte[] dst = new byte[cb];
    int dstOffset = 0;
    int count = this.m_endIndex - this.m_startIndex;
    if (count &gt; 0)
    {
        if (cb &lt; count)
        {
            Buffer.InternalBlockCopy(this.m_buffer, this.m_startIndex, dst, 0, cb);
            this.m_startIndex += cb;
            return dst;
        }
        Buffer.InternalBlockCopy(this.m_buffer, this.m_startIndex, dst, 0, count);
        this.m_startIndex = this.m_endIndex = 0;
        dstOffset += count;
    }
    while (dstOffset &lt; cb)
    {
        byte[] src = this.Func();
        int num3 = cb - dstOffset;
        if (num3 &gt; 20)
        {
            Buffer.InternalBlockCopy(src, 0, dst, dstOffset, 20);
            dstOffset += 20;
        }
        else
        {
            Buffer.InternalBlockCopy(src, 0, dst, dstOffset, num3);
            dstOffset += num3;
            Buffer.InternalBlockCopy(src, num3, this.m_buffer, this.m_startIndex, 20 - num3);
            this.m_endIndex += 20 - num3;
            return dst;
        }
    }
    return dst;
}
</code></pre>
","7876","<c#><encryption><aes><rijndael><rfc2898>","6","5","2","2012-06-04 18:31:03","1937303","0","","600500","","2011-08-13 01:16:48","2009-12-20 22:06:50",""
"15752959","Xcode AES encrypt / decrypt - php compatibilty issues","<p>I am trying to encrypt a string in Xcode and decrypt it with PHP or encrypt with PHP and decrypt with Xcode.</p>

<p>So first of all I am trying to get the same <code>AES encryption</code> result.</p>

<p>Here is my Xcode file (I've put everything in a single file for simplicity):</p>

<pre><code>#import ""t.h""
#import &lt;CommonCrypto/CommonCryptor.h&gt;

@interface NSData(AES)
- (NSData*)AES256EncryptWithKey:(NSString*)key;
- (NSData*)AES256DecryptWithKey:(NSString*)key;
@end

@implementation NSData (AES)

- (NSData*)AES256EncryptWithKey:(NSString*)key {
char keyPtr[kCCKeySizeAES256];

[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];

NSString *iv = @""1234567812345678"";
char ivPtr[kCCKeySizeAES128];

[iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSASCIIStringEncoding];    

NSUInteger dataLength = [self length];

size_t bufferSize           = dataLength + kCCBlockSizeAES128;
void* buffer                = malloc(bufferSize);

size_t numBytesEncrypted    = 0;
CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, NULL,
                                      keyPtr, kCCKeySizeAES256,
                                      ivPtr /* initialization vector (optional) */,
                                      [self bytes], dataLength, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesEncrypted);

if (cryptStatus == kCCSuccess)
{
    return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
}

free(buffer); //free the buffer;
return nil;
}

- (NSData*)AES256DecryptWithKey:(NSString*)key {
char keyPtr[kCCKeySizeAES256];  

NSString *iv = @""1234567812345678"";
char ivPtr[kCCKeySizeAES128];

[iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSASCIIStringEncoding];


// fetch key data
[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];

NSUInteger dataLength = [self length];

size_t bufferSize           = dataLength + kCCBlockSizeAES128;
void* buffer                = malloc(bufferSize);

size_t numBytesDecrypted    = 0;
CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, NULL,
                                      keyPtr, kCCKeySizeAES256,
                                      ivPtr /* initialization vector (optional) */,
                                      [self bytes], dataLength, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesDecrypted);

if (cryptStatus == kCCSuccess)
{
    return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];
}

free(buffer); //free the buffer;
return nil;
}

@end



@interface t ()
@end

@implementation t

- (void)viewDidLoad
{
[super viewDidLoad];


NSString *key = @""12345678123456781234567812345678"";

NSData *plaintext =  [[@""aaa0000000000000"" dataUsingEncoding:NSASCIIStringEncoding] AES256EncryptWithKey: key];

label1.text = [[NSString alloc] initWithData:plaintext encoding:NSASCIIStringEncoding];


}

@end
</code></pre>

<p>And now the PHP code: </p>

<pre><code>&lt;?php

$key256 = ""12345678123456781234567812345678"";
$iv128 = ""1234567812345678"";
$text = ""aaa"";

$blocksize = 16;
$len = strlen($text);
$pad = $blocksize - ($len % $blocksize);

$text .= str_repeat(""0"", $pad);

$cipher = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key256, $text, MCRYPT_MODE_CBC, $iv128);

echo $cipher;

?&gt;
</code></pre>

<p>The Xcode encrypted string and the php encrypted string are different.</p>

<p>PHP: <code>â5¢Ð[Iüf#hÂ(Æ</code></p>

<p>Xcode: <code>¡#yZPbEs¿D6ñ</code></p>

<p>What can I do to make it work? Am I doing something wrong?</p>

<p>I will further explain what the code does and how it is structured so you can easier understand the problem (correct me if I am wrong):</p>

<ol>
<li><p>Both PHP and Xcode use CBC for AES encryption so I guess there is no problem there.</p></li>
<li><p>As you can see I am just trying to get the same result - security does not matter here - so I used no padding - the text is exactly 128 bits in length (16 characters).</p></li>
<li><p>The key is 256 bits (32 characters).</p></li>
<li><p>The Initialization Vector is 128 bits (16 characters).</p></li>
</ol>

<p>Thank you very much. </p>

<p>Any help is appreciated! </p>
","<p>Change:</p>

<pre><code>[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];
</code></pre>

<p>to</p>

<pre><code>[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];
</code></pre>

<p>I believe this is an encoding issue</p>
","7832","<php><ios><xcode><aes><rijndael>","1","0","3","2013-05-29 21:13:58","15899586","2","2","1579613","","2013-04-02 06:52:22","2013-04-01 22:21:57",""
"15752959","Xcode AES encrypt / decrypt - php compatibilty issues","<p>I am trying to encrypt a string in Xcode and decrypt it with PHP or encrypt with PHP and decrypt with Xcode.</p>

<p>So first of all I am trying to get the same <code>AES encryption</code> result.</p>

<p>Here is my Xcode file (I've put everything in a single file for simplicity):</p>

<pre><code>#import ""t.h""
#import &lt;CommonCrypto/CommonCryptor.h&gt;

@interface NSData(AES)
- (NSData*)AES256EncryptWithKey:(NSString*)key;
- (NSData*)AES256DecryptWithKey:(NSString*)key;
@end

@implementation NSData (AES)

- (NSData*)AES256EncryptWithKey:(NSString*)key {
char keyPtr[kCCKeySizeAES256];

[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];

NSString *iv = @""1234567812345678"";
char ivPtr[kCCKeySizeAES128];

[iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSASCIIStringEncoding];    

NSUInteger dataLength = [self length];

size_t bufferSize           = dataLength + kCCBlockSizeAES128;
void* buffer                = malloc(bufferSize);

size_t numBytesEncrypted    = 0;
CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, NULL,
                                      keyPtr, kCCKeySizeAES256,
                                      ivPtr /* initialization vector (optional) */,
                                      [self bytes], dataLength, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesEncrypted);

if (cryptStatus == kCCSuccess)
{
    return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
}

free(buffer); //free the buffer;
return nil;
}

- (NSData*)AES256DecryptWithKey:(NSString*)key {
char keyPtr[kCCKeySizeAES256];  

NSString *iv = @""1234567812345678"";
char ivPtr[kCCKeySizeAES128];

[iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSASCIIStringEncoding];


// fetch key data
[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];

NSUInteger dataLength = [self length];

size_t bufferSize           = dataLength + kCCBlockSizeAES128;
void* buffer                = malloc(bufferSize);

size_t numBytesDecrypted    = 0;
CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, NULL,
                                      keyPtr, kCCKeySizeAES256,
                                      ivPtr /* initialization vector (optional) */,
                                      [self bytes], dataLength, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesDecrypted);

if (cryptStatus == kCCSuccess)
{
    return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];
}

free(buffer); //free the buffer;
return nil;
}

@end



@interface t ()
@end

@implementation t

- (void)viewDidLoad
{
[super viewDidLoad];


NSString *key = @""12345678123456781234567812345678"";

NSData *plaintext =  [[@""aaa0000000000000"" dataUsingEncoding:NSASCIIStringEncoding] AES256EncryptWithKey: key];

label1.text = [[NSString alloc] initWithData:plaintext encoding:NSASCIIStringEncoding];


}

@end
</code></pre>

<p>And now the PHP code: </p>

<pre><code>&lt;?php

$key256 = ""12345678123456781234567812345678"";
$iv128 = ""1234567812345678"";
$text = ""aaa"";

$blocksize = 16;
$len = strlen($text);
$pad = $blocksize - ($len % $blocksize);

$text .= str_repeat(""0"", $pad);

$cipher = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key256, $text, MCRYPT_MODE_CBC, $iv128);

echo $cipher;

?&gt;
</code></pre>

<p>The Xcode encrypted string and the php encrypted string are different.</p>

<p>PHP: <code>â5¢Ð[Iüf#hÂ(Æ</code></p>

<p>Xcode: <code>¡#yZPbEs¿D6ñ</code></p>

<p>What can I do to make it work? Am I doing something wrong?</p>

<p>I will further explain what the code does and how it is structured so you can easier understand the problem (correct me if I am wrong):</p>

<ol>
<li><p>Both PHP and Xcode use CBC for AES encryption so I guess there is no problem there.</p></li>
<li><p>As you can see I am just trying to get the same result - security does not matter here - so I used no padding - the text is exactly 128 bits in length (16 characters).</p></li>
<li><p>The key is 256 bits (32 characters).</p></li>
<li><p>The Initialization Vector is 128 bits (16 characters).</p></li>
</ol>

<p>Thank you very much. </p>

<p>Any help is appreciated! </p>
","<p>Finally got it! (after asking Apple about it)</p>

<p>Apparently getting getCString from NSString is wrong because the routine tries to null terminate the string and a 32-byte buffer is not big enough to terminate a 32-chars string.</p>

<p>The correct way to get the key or IV would be:</p>

<pre><code>[key cStringUsingEncoding:NSASCIIStringEncoding];
</code></pre>
","7832","<php><ios><xcode><aes><rijndael>","1","2","3","2013-05-29 21:13:58","15899586","2","2","1579613","","2013-04-02 06:52:22","2013-04-01 22:21:57",""
"15752959","Xcode AES encrypt / decrypt - php compatibilty issues","<p>I am trying to encrypt a string in Xcode and decrypt it with PHP or encrypt with PHP and decrypt with Xcode.</p>

<p>So first of all I am trying to get the same <code>AES encryption</code> result.</p>

<p>Here is my Xcode file (I've put everything in a single file for simplicity):</p>

<pre><code>#import ""t.h""
#import &lt;CommonCrypto/CommonCryptor.h&gt;

@interface NSData(AES)
- (NSData*)AES256EncryptWithKey:(NSString*)key;
- (NSData*)AES256DecryptWithKey:(NSString*)key;
@end

@implementation NSData (AES)

- (NSData*)AES256EncryptWithKey:(NSString*)key {
char keyPtr[kCCKeySizeAES256];

[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];

NSString *iv = @""1234567812345678"";
char ivPtr[kCCKeySizeAES128];

[iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSASCIIStringEncoding];    

NSUInteger dataLength = [self length];

size_t bufferSize           = dataLength + kCCBlockSizeAES128;
void* buffer                = malloc(bufferSize);

size_t numBytesEncrypted    = 0;
CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, NULL,
                                      keyPtr, kCCKeySizeAES256,
                                      ivPtr /* initialization vector (optional) */,
                                      [self bytes], dataLength, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesEncrypted);

if (cryptStatus == kCCSuccess)
{
    return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
}

free(buffer); //free the buffer;
return nil;
}

- (NSData*)AES256DecryptWithKey:(NSString*)key {
char keyPtr[kCCKeySizeAES256];  

NSString *iv = @""1234567812345678"";
char ivPtr[kCCKeySizeAES128];

[iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSASCIIStringEncoding];


// fetch key data
[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];

NSUInteger dataLength = [self length];

size_t bufferSize           = dataLength + kCCBlockSizeAES128;
void* buffer                = malloc(bufferSize);

size_t numBytesDecrypted    = 0;
CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, NULL,
                                      keyPtr, kCCKeySizeAES256,
                                      ivPtr /* initialization vector (optional) */,
                                      [self bytes], dataLength, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesDecrypted);

if (cryptStatus == kCCSuccess)
{
    return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];
}

free(buffer); //free the buffer;
return nil;
}

@end



@interface t ()
@end

@implementation t

- (void)viewDidLoad
{
[super viewDidLoad];


NSString *key = @""12345678123456781234567812345678"";

NSData *plaintext =  [[@""aaa0000000000000"" dataUsingEncoding:NSASCIIStringEncoding] AES256EncryptWithKey: key];

label1.text = [[NSString alloc] initWithData:plaintext encoding:NSASCIIStringEncoding];


}

@end
</code></pre>

<p>And now the PHP code: </p>

<pre><code>&lt;?php

$key256 = ""12345678123456781234567812345678"";
$iv128 = ""1234567812345678"";
$text = ""aaa"";

$blocksize = 16;
$len = strlen($text);
$pad = $blocksize - ($len % $blocksize);

$text .= str_repeat(""0"", $pad);

$cipher = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key256, $text, MCRYPT_MODE_CBC, $iv128);

echo $cipher;

?&gt;
</code></pre>

<p>The Xcode encrypted string and the php encrypted string are different.</p>

<p>PHP: <code>â5¢Ð[Iüf#hÂ(Æ</code></p>

<p>Xcode: <code>¡#yZPbEs¿D6ñ</code></p>

<p>What can I do to make it work? Am I doing something wrong?</p>

<p>I will further explain what the code does and how it is structured so you can easier understand the problem (correct me if I am wrong):</p>

<ol>
<li><p>Both PHP and Xcode use CBC for AES encryption so I guess there is no problem there.</p></li>
<li><p>As you can see I am just trying to get the same result - security does not matter here - so I used no padding - the text is exactly 128 bits in length (16 characters).</p></li>
<li><p>The key is 256 bits (32 characters).</p></li>
<li><p>The Initialization Vector is 128 bits (16 characters).</p></li>
</ol>

<p>Thank you very much. </p>

<p>Any help is appreciated! </p>
","<p>When using this code from the very beginning of the page, I am able to encrypt only 16 characters of text. Actually I am able to encrypt any size of text, but when I decrypt that encrypted NSData, I get only 16 characters or 128bits. </p>

<p>Does this has something to do with IV? Is this code made to encrypt ONLY 128bits and if I have bigger size of the text, I need to provide (for better security) new IV and encrypt second block?</p>
","7832","<php><ios><xcode><aes><rijndael>","1","0","3","2013-05-29 21:13:58","15899586","2","2","1579613","","2013-04-02 06:52:22","2013-04-01 22:21:57",""
"7052219","PHP to Delphi and back Encryption-Decryption using Rijndael","<p>I have problems with decrypting strings sent from PHP to Delphi using the rijndael cipher.
I'm using mcrypt on the PHP side and DCP_rijndael on the Delphi side.</p>

<p>At the moment I have the below code.</p>

<p>PHP:</p>

<pre><code>function encRJ($key, $iv, $data)
{
    $r = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $data, MCRYPT_MODE_CBC, $iv);
    $r = base64_encode($r);
    return $r;
}
</code></pre>

<p>And in Delphi:</p>

<pre><code>function decRJ(Data: string; Key: string; IV: string): string;
var ciph: TDCP_rijndael;
begin
  Data := Base64DecodeStr(Data);

  ciph:= TDCP_rijndael.Create(Self);
  ciph.Init(Key[1], 256, @IV[1]);
  ciph.DecryptCBC(Data[1], Data[1], Length(Data));
  ciph.Free;

  Result := Data;
end;
</code></pre>

<p>I have tried using several Units on the Internet implementing the cipher, and found out most people are saying about the DCP components. Even so, I haven't managed to make it correctly decrypt. I've tried using Byte arrays for the parameters, AnsiStrings, WideStrings, etc, but unfortunately no luck.</p>

<p>Excuse me if I'm missing something really obvious here, as my mind isn't in good shape atm, after hours of searching for the matter.</p>
","<p>Neither your PHP nor your Delphi methods appear to specify any padding.  If the default paddings are different then you will get problems.  Explicitly specify PKCS7 (or PKCS5) for both.</p>

<p>GregS' comment about the result of decoding Base64 is correct.  You are supplying encrypted cyphertext to your decRJ() method.  That will be random appearing bytes.  Attempting to convert it to UTF-8 will mangle it enough that it cannot be decrypted.  The incoming cyphertext must be converted from Base64 direct to a byte array.  Cyphertext is not a character string, which is why it needs to be converted to Base64 to be transmitted as text.  It will only be text again <strong>after</strong> it has been decrypted back to plaintext.</p>
","7370","<php><delphi><encryption><rijndael>","2","0","2","2018-04-30 07:42:52","","5","3","893271","","2011-08-14 17:39:10","2011-08-13 17:47:58",""
"7052219","PHP to Delphi and back Encryption-Decryption using Rijndael","<p>I have problems with decrypting strings sent from PHP to Delphi using the rijndael cipher.
I'm using mcrypt on the PHP side and DCP_rijndael on the Delphi side.</p>

<p>At the moment I have the below code.</p>

<p>PHP:</p>

<pre><code>function encRJ($key, $iv, $data)
{
    $r = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $data, MCRYPT_MODE_CBC, $iv);
    $r = base64_encode($r);
    return $r;
}
</code></pre>

<p>And in Delphi:</p>

<pre><code>function decRJ(Data: string; Key: string; IV: string): string;
var ciph: TDCP_rijndael;
begin
  Data := Base64DecodeStr(Data);

  ciph:= TDCP_rijndael.Create(Self);
  ciph.Init(Key[1], 256, @IV[1]);
  ciph.DecryptCBC(Data[1], Data[1], Length(Data));
  ciph.Free;

  Result := Data;
end;
</code></pre>

<p>I have tried using several Units on the Internet implementing the cipher, and found out most people are saying about the DCP components. Even so, I haven't managed to make it correctly decrypt. I've tried using Byte arrays for the parameters, AnsiStrings, WideStrings, etc, but unfortunately no luck.</p>

<p>Excuse me if I'm missing something really obvious here, as my mind isn't in good shape atm, after hours of searching for the matter.</p>
","<p>I seem to have spent too long on this but...</p>

<p>Your problem is the block size. TDCP_rijndael is equivalent to MCRYPT_RIJNDAEL_128 (not _256). The '256' value in ciph.Init(...) call is still correct though. Other than that it looks pretty much ok. That is, assuming you're using ansistrings for key/iv or you're using non-unicode Delphi.<br/>
For unicode Delphi versions I'd be inclined to use TBytes and key[0] / iv[0].</p>

<p>Padding may still be an issue. If so, then here's what I've mangled up based on the PHP manual pages and some trial and error.</p>

<p>PHP:</p>

<pre><code>function Encrypt($src, $key, $iv)
{
  $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, 'cbc');
  //echo ""Block size: "" . $block . ""\r\n"";
  $pad = $block - (strlen($src) % $block);
  $src .= str_repeat(chr($pad), $pad);  

  $enc = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $src, MCRYPT_MODE_CBC, $iv);
  $r = base64_encode($enc);
  return $r;
}

function Decrypt($src, $key, $iv)
{
  $enc = base64_decode($src);
  $dec = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $enc, MCRYPT_MODE_CBC, $iv);

  $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, 'cbc');
  $pad = ord($dec[($len = strlen($dec)) - 1]);
  return substr($dec, 0, strlen($dec) - $pad);
}
</code></pre>

<p>Delphi:</p>

<pre><code>function DecryptData(Data: string; AKey: AnsiString; AIv: AnsiString): string;
var
  key, iv, src, dest: TBytes;
  cipher: TDCP_rijndael;
  slen, pad: integer;
begin
  //key := Base64DecodeBytes(TEncoding.UTF8.GetBytes(AKey));
  //iv := Base64DecodeBytes(TEncoding.UTF8.GetBytes(AIv));
  key := TEncoding.ASCII.GetBytes(AKey);
  iv := TEncoding.ASCII.GetBytes(AIv);

  src := Base64DecodeBytes(TEncoding.UTF8.GetBytes(Data));

  cipher := TDCP_rijndael.Create(nil);
  try
    cipher.CipherMode := cmCBC;
    slen := Length(src);
    SetLength(dest, slen);
    cipher.Init(key[0], 256, @iv[0]); // DCP uses key size in BITS not BYTES
    cipher.Decrypt(src[0], dest[0], slen);
    // Remove the padding. Get the numerical value of the last byte and remove
    // that number of bytes
    pad := dest[slen - 1];
    SetLength(dest, slen - pad);

    // Base64 encode it
    result := TEncoding.Default.GetString(dest);
  finally
    cipher.Free;
  end;
end;

function EncryptData(Data: string; AKey: AnsiString; AIv: AnsiString): string;
var
  cipher: TDCP_rijndael;
  key, iv, src, dest, b64: TBytes;
  index, slen, bsize, pad: integer;
begin
  //key := Base64DecodeBytes(TEncoding.UTF8.GetBytes(AKey));
  //iv := Base64DecodeBytes(TEncoding.UTF8.GetBytes(AIv));
  key := TEncoding.ASCII.GetBytes(AKey);
  iv := TEncoding.ASCII.GetBytes(AIv);

  src := TEncoding.UTF8.GetBytes(Data);

  cipher := TDCP_rijndael.Create(nil);
  try
    cipher.CipherMode := cmCBC;
    // Add padding.
    // Resize the Value array to make it a multiple of the block length.
    // If it's already an exact multiple then add a full block of padding.
    slen := Length(src);
    bsize := (cipher.BlockSize div 8);
    pad := bsize - (slen mod bsize);
    Inc(slen, pad);
    SetLength(src, slen);
    for index := pad downto 1 do
    begin
      src[slen - index] := pad;
    end;

    SetLength(dest, slen);
    cipher.Init(key[0], 256, @iv[0]); // DCP uses key size in BITS not BYTES
    cipher.Encrypt(src[0], dest[0], slen);

    b64 := Base64EncodeBytes(dest);
    result := TEncoding.Default.GetString(b64);
  finally
    cipher.Free;
  end;
end;
</code></pre>

<p>The PHP and Delphi functions now give me the same answer.</p>

<p>EDIT</p>

<p>Base64DecodeBytes was a bit of code I added to the DCP Base64 unit:</p>

<pre><code>function Base64DecodeBytes(Input: TBytes): TBytes;
var
  ilen, rlen: integer;
begin
  ilen := Length(Input);
  SetLength(result, (ilen div 4) * 3);
  rlen := Base64Decode(@Input[0], @result[0], ilen);
  // Adjust the length of the output buffer according to the number of valid
  // b64 characters
  SetLength(result, rlen);
end; 
</code></pre>

<p><strong>EDIT 2018</strong> (Raising the dead...):</p>

<p>As requested, here is the encoding method, unchecked and pulled straight from an old source file I found.   </p>

<p>DISCLAIMER: It is <em>many</em> years old and untested in recent memory and not used since Delphi 2010. There are probably many better alternatives now. Use at your own risk.</p>

<pre><code>function Base64EncodeBytes(Input: TBytes): TBytes;
var
  ilen: integer;
begin
  ilen := Length(Input);
  SetLength(result, ((ilen + 2) div 3) * 4);
  Base64Encode(@Input[0], @result[0], ilen);
end;
</code></pre>
","7370","<php><delphi><encryption><rijndael>","2","8","2","2018-04-30 07:42:52","","5","3","893271","","2011-08-14 17:39:10","2011-08-13 17:47:58",""
"10136585","RIJNDAEL encryption with Java","<p>I need to encode a cleartext in Java and php where the result must be the same.</p>

<p>The following conditions are given:</p>

<ol>
<li>algorithm: RIJNDAEL-128</li>
<li>key: 1234567890123456</li>
<li>mode: cfb</li>
<li>initialization vector: 1234567890123456</li>
</ol>

<p>The following codes works and fulfils the first an the second requirement but it uses ECB as mode and therefore does not use an initalization vector:</p>

<p>PHP:</p>

<pre><code> &lt;?php  
        $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_ECB, '');     
        $cleartext = 'abcdefghijklmnop';    
        $key128 = '1234567890123456';
        $iv = '1234567890123456';

        if (mcrypt_generic_init($cipher, $key128, $iv) != -1)  //Parameter iv will be ignored in ECB mode
        {
            $cipherText = mcrypt_generic($cipher,$cleartext );
            mcrypt_generic_deinit($cipher);     
            printf(bin2hex($cipherText));       
        }
    ?&gt;
</code></pre>

<p>Output is: fcad715bd73b5cb0488f840f3bad7889</p>

<p>JAVA:</p>

<pre><code>public class AES {

    public static void main(String[] args) throws Exception {
        String cleartext = ""abcdefghijklmnop"";
        String key = ""1234567890123456"";
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(cleartext.getBytes());
        System.out.println(asHex(encrypted));
    }

    public static String asHex(byte buf[]) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;
        for (i = 0; i &lt; buf.length; i++) {
            if (((int) buf[i] &amp; 0xff) &lt; 0x10)
                strbuf.append(""0"");
            strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
        }
        return strbuf.toString();
    }

}
</code></pre>

<p>Output is (the same as in the PHP version): fcad715bd73b5cb0488f840f3bad7889</p>

<p>So now in order to fulfill requirement 3 and 4 I changed the mode to MCRYPT_MODE_CFB in my PHP version so that the code looks like this:</p>

<pre><code> &lt;?php  
        $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CFB, '');     
        $cleartext = 'abcdefghijklmnop';    
        $key128 = '1234567890123456';
        $iv = '1234567890123456';


        if (mcrypt_generic_init($cipher, $key128, $iv) != -1)  //Parameter iv will be ignored in ECB mode
        {
            $cipherText = mcrypt_generic($cipher,$cleartext );
            mcrypt_generic_deinit($cipher);     
            printf(bin2hex($cipherText));       
        }
    ?&gt;
</code></pre>

<p>This results in the following output: 14a53328feee801b3ee67b2fd627fea0</p>

<p>In the JAVA version I also adapted the mode and added the iv to the init function of my Cipher object.</p>

<pre><code>public class AES {

    public static void main(String[] args) throws Exception {
        String cleartext = ""abcdefghijklmnop"";
        String key = ""1234567890123456"";
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CFB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec,  new IvParameterSpec(""1234567890123456"".getBytes()));
        byte[] encrypted = cipher.doFinal(cleartext.getBytes());
        System.out.println(asHex(encrypted));
    }

    public static String asHex(byte buf[]) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;
        for (i = 0; i &lt; buf.length; i++) {
            if (((int) buf[i] &amp; 0xff) &lt; 0x10)
                strbuf.append(""0"");
            strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
        }
        return strbuf.toString();
    }

}
</code></pre>

<p>But here the output is 141eae68b93af782b284879a55b36f70 which is different to the PHP version.</p>

<p>Does anybody have a clue what the difference betwenn the JAVA and the PHP version could be?</p>
","<p>Three things here:</p>

<ul>
<li><p>It's very possible that PHP's ""MCRYPT_RIJNDAEL_128"" isn't exactly the same algorithm as Java's ""AES"". The <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES Wiki entry</a> talks about the difference between RIJNDAEL and AES at the bottom of the intro.</p></li>
<li><p>You're using CBC in the PHP version, while you're using CFB in the Java version. Even if the algorithms are the same, this will definitely give you different output. </p></li>
<li><p>The PHP version has no padding, while the Java version is using PKCS5Padding. The Java version should instantiate cipher with ""Cipher.getInstance(""AES/CFB/NoPadding"");""</p></li>
</ul>

<p>Also, instead of constructing the SecretKeySpec with the bytes of the key String, you're going to want to actually want to generate an AES key. This will look like:</p>

<pre><code>KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
SecureRandom sec = new SecureRandom(key.getBytes());
keygen.init(128, sec);
Key key = keygen.generateKey();
SecretKeySpec skeySpec = new SecretKeySpec(key.getEncoded(), ""AES"");
...
</code></pre>

<p>Essentially, the String key is a seed for generating a SecretKey, rather than the key itself.</p>
","7166","<java><php><rijndael>","4","3","2","2014-07-24 10:32:35","","3","4","759866","","2014-07-24 10:32:35","2012-04-13 07:05:12",""
"10136585","RIJNDAEL encryption with Java","<p>I need to encode a cleartext in Java and php where the result must be the same.</p>

<p>The following conditions are given:</p>

<ol>
<li>algorithm: RIJNDAEL-128</li>
<li>key: 1234567890123456</li>
<li>mode: cfb</li>
<li>initialization vector: 1234567890123456</li>
</ol>

<p>The following codes works and fulfils the first an the second requirement but it uses ECB as mode and therefore does not use an initalization vector:</p>

<p>PHP:</p>

<pre><code> &lt;?php  
        $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_ECB, '');     
        $cleartext = 'abcdefghijklmnop';    
        $key128 = '1234567890123456';
        $iv = '1234567890123456';

        if (mcrypt_generic_init($cipher, $key128, $iv) != -1)  //Parameter iv will be ignored in ECB mode
        {
            $cipherText = mcrypt_generic($cipher,$cleartext );
            mcrypt_generic_deinit($cipher);     
            printf(bin2hex($cipherText));       
        }
    ?&gt;
</code></pre>

<p>Output is: fcad715bd73b5cb0488f840f3bad7889</p>

<p>JAVA:</p>

<pre><code>public class AES {

    public static void main(String[] args) throws Exception {
        String cleartext = ""abcdefghijklmnop"";
        String key = ""1234567890123456"";
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(cleartext.getBytes());
        System.out.println(asHex(encrypted));
    }

    public static String asHex(byte buf[]) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;
        for (i = 0; i &lt; buf.length; i++) {
            if (((int) buf[i] &amp; 0xff) &lt; 0x10)
                strbuf.append(""0"");
            strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
        }
        return strbuf.toString();
    }

}
</code></pre>

<p>Output is (the same as in the PHP version): fcad715bd73b5cb0488f840f3bad7889</p>

<p>So now in order to fulfill requirement 3 and 4 I changed the mode to MCRYPT_MODE_CFB in my PHP version so that the code looks like this:</p>

<pre><code> &lt;?php  
        $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CFB, '');     
        $cleartext = 'abcdefghijklmnop';    
        $key128 = '1234567890123456';
        $iv = '1234567890123456';


        if (mcrypt_generic_init($cipher, $key128, $iv) != -1)  //Parameter iv will be ignored in ECB mode
        {
            $cipherText = mcrypt_generic($cipher,$cleartext );
            mcrypt_generic_deinit($cipher);     
            printf(bin2hex($cipherText));       
        }
    ?&gt;
</code></pre>

<p>This results in the following output: 14a53328feee801b3ee67b2fd627fea0</p>

<p>In the JAVA version I also adapted the mode and added the iv to the init function of my Cipher object.</p>

<pre><code>public class AES {

    public static void main(String[] args) throws Exception {
        String cleartext = ""abcdefghijklmnop"";
        String key = ""1234567890123456"";
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CFB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec,  new IvParameterSpec(""1234567890123456"".getBytes()));
        byte[] encrypted = cipher.doFinal(cleartext.getBytes());
        System.out.println(asHex(encrypted));
    }

    public static String asHex(byte buf[]) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;
        for (i = 0; i &lt; buf.length; i++) {
            if (((int) buf[i] &amp; 0xff) &lt; 0x10)
                strbuf.append(""0"");
            strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
        }
        return strbuf.toString();
    }

}
</code></pre>

<p>But here the output is 141eae68b93af782b284879a55b36f70 which is different to the PHP version.</p>

<p>Does anybody have a clue what the difference betwenn the JAVA and the PHP version could be?</p>
","<p>It isn't documented well, but PHP's <code>MCRYPT_RIJNDAEL_128</code> with <code>MCRYPT_MODE_CFB</code> produces results consistent with Java's <code>AES/CFB8/NoPadding</code>.</p>

<p>So this line in PHP:</p>

<pre><code>$encrypted = base64_encode( mcrypt_encrypt( MCRYPT_RIJNDAEL_128, $key, $cleartext, MCRYPT_MODE_CFB, $iv ) );
</code></pre>

<p>Matches up to this block in Java:</p>

<pre><code>SecretKeySpec   key = new SecretKeySpec(KEY.getBytes(), ""AES"");
IvParameterSpec iv  = new IvParameterSpec(IV.getBytes());

Cipher cipher = Cipher.getInstance(""AES/CFB8/NoPadding"");
cipher.init(Cipher.ENCRYPT_MODE, key, iv);

byte[] output = cipher.doFinal(cleartext.getBytes());

String signature = Base64.encode(output);
</code></pre>
","7166","<java><php><rijndael>","4","7","2","2014-07-24 10:32:35","","3","4","759866","","2014-07-24 10:32:35","2012-04-13 07:05:12",""
"3505453","Rewrite Rijndael 256 C# Encryption Code in PHP","<p>I have an encryption/decryption algorithm written in C# - I need to be able to produce the same encryption in PHP so I can send the encrypted text over HTTP to be decrypted on the C# side.
Here is the C# code for the encryption.</p>

<pre><code>this.m_plainText = string.Empty;
this.m_passPhrase = ""passpharse"";
this.m_saltValue = ""saltvalue"";
this.m_hashAlgorithm = ""SHA1"";
this.m_passwordIterations = 2;
this.m_initVector = ""1a2b3c4d5e6f7g8h"";
this.m_keySize = 256;

public string Encrypt()
{
    string plainText = this.m_plainText;
    string passPhrase = this.m_passPhrase;
    string saltValue = this.m_saltValue;
    string hashAlgorithm = this.m_hashAlgorithm;
    int passwordIterations = this.m_passwordIterations;
    string initVector = this.m_initVector;
    int keySize = this.m_keySize;

    // Convert strings into byte arrays.
    // Let us assume that strings only contain ASCII codes.
    // If strings include Unicode characters, use Unicode, UTF7, or UTF8 
    // encoding.
    byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
    byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

    // Convert our plaintext into a byte array.
    // Let us assume that plaintext contains UTF8-encoded characters.
    byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);

    // First, we must create a password, from which the key will be derived.
    // This password will be generated from the specified passphrase and 
    // salt value. The password will be created using the specified hash 
    // algorithm. Password creation can be done in several iterations.
    PasswordDeriveBytes password = new PasswordDeriveBytes(
                                                    passPhrase,
                                                    saltValueBytes,
                                                    hashAlgorithm,
                                                    passwordIterations);

    // Use the password to generate pseudo-random bytes for the encryption
    // key. Specify the size of the key in bytes (instead of bits).
    byte[] keyBytes = password.GetBytes(keySize / 8);

    // Create uninitialized Rijndael encryption object.
    RijndaelManaged symmetricKey = new RijndaelManaged();

    // It is reasonable to set encryption mode to Cipher Block Chaining
    // (CBC). Use default options for other symmetric key parameters.
    symmetricKey.Mode = CipherMode.CBC;

    // Generate encryptor from the existing key bytes and initialization 
    // vector. Key size will be defined based on the number of the key 
    // bytes.
    ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                                                     keyBytes,
                                                     initVectorBytes);

    // Define memory stream which will be used to hold encrypted data.
    MemoryStream memoryStream = new MemoryStream();

    // Define cryptographic stream (always use Write mode for encryption).
    CryptoStream cryptoStream = new CryptoStream(memoryStream,
                                                 encryptor,
                                                 CryptoStreamMode.Write);
    // Start encrypting.
    cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

    // Finish encrypting.
    cryptoStream.FlushFinalBlock();

    // Convert our encrypted data from a memory stream into a byte array.
    byte[] cipherTextBytes = memoryStream.ToArray();

    // Close both streams.
    memoryStream.Close();
    cryptoStream.Close();

    // Convert encrypted data into a base64-encoded string.
    string cipherText = Convert.ToBase64String(cipherTextBytes);

    // Return encrypted string.
    return cipherText;
}
</code></pre>

<p>I have some similar PHP code that may help.  It doesn't do exactly as needed, but I think it may be a good place to start.</p>

<pre><code>&lt;?php

/*
 * DEFINE CONSTANTS
 */
$HashPassPhrase = ""passpharse"";
$HashSalt = ""saltvalue"";
$HashAlgorithm = ""SHA1"";
$HashIterations = ""2"";
$InitVector = ""1a2b3c4d5e6f7g8h"";        // Must be 16 bytes
$keySize = ""256"";

class Cipher {
    private $securekey, $iv;
    function __construct($textkey) {
        $this-&gt;securekey = hash($HashAlgorithm,$textkey,TRUE);
        $this-&gt;iv = $InitVector;
    }
    function encrypt($input) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, $input, MCRYPT_MODE_CBC, $this-&gt;iv));
    }
    function decrypt($input) {
        return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, base64_decode($input), MCRYPT_MODE_CBC, $this-&gt;iv));
    }
}

$cipher = new Cipher($HashPassPhrase);

$encryptedtext = $cipher-&gt;encrypt(""Text To Encrypt"");
echo ""-&gt;encrypt = $encryptedtext&lt;br /&gt;"";

$decryptedtext = $cipher-&gt;decrypt($encryptedtext);
echo ""-&gt;decrypt = $decryptedtext&lt;br /&gt;"";

var_dump($cipher);
</code></pre>

<p>?></p>
","<p>You need to derive the key from the pass phrase the same way as the C# code does in the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.passwordderivebytes.aspx"" rel=""noreferrer"">PasswordDeriveBytes</a>. This is documented to do PBKDF1 key derivation, as per <a href=""http://www.ietf.org/rfc/rfc2898.txt"" rel=""noreferrer"">RFC2898</a>:</p>

<blockquote>
  <p>This class uses an extension of the
  PBKDF1 algorithm defined in the PKCS#5
  v2.0 standard to derive bytes suitable
  for use as key material from a
  password. The standard is documented
  in IETF RRC 2898.</p>
</blockquote>

<p>there are PHP libraries that implement PBKDF1 out there, but is really simple to write one from scratch based ont he RFC:</p>

<blockquote>
  <p>PBKDF1 (P, S, c, dkLen)</p>
  
  <p>Options:        Hash<br>
  underlying hash function</p>
  
  <p>Input:          P<br>
  password, an octet string
                     S          salt, an eight-octet string
                     c          iteration count, a positive integer
                     dkLen      intended length in octets of derived key,
                                a positive integer, at most 16 for MD2
  or
                                MD5 and 20 for SHA-1</p>
  
  <p>Output:         DK         derived
  key, a dkLen-octet string</p>
  
  <p>Steps:</p>

<pre><code>  1. If dkLen &gt; 16 for MD2 and MD5, or dkLen &gt; 20 for SHA-1, output
     ""derived key too long"" and stop.

  2. Apply the underlying hash function Hash for c iterations to the
     concatenation of the password P and the salt S, then extract
     the first dkLen octets to produce a derived key DK:

               T_1 = Hash (P || S) ,
               T_2 = Hash (T_1) ,
               ...
               T_c = Hash (T_{c-1}) ,
               DK = Tc&lt;0..dkLen-1&gt;

  3. Output the derived key DK.
</code></pre>
</blockquote>

<p><strong>Updated</strong></p>

<p>When you find youself in this situation, you usually search for an example implementaiton that shows the values at every step. for instance the one at <a href=""http://www.di-mgt.com.au/cryptoKDFs.html#examplespbkdf"" rel=""noreferrer"">http://www.di-mgt.com.au/cryptoKDFs.html#examplespbkdf</a>:</p>

<pre><code>Password = ""password"" 
         = (0x)70617373776F7264
Salt     = (0x)78578E5A5D63CB06
Count    = 1000
kLen     = 16
Key      = PBKDF1(Password, Salt, Count, kLen)
         = (0x)DC19847E05C64D2FAF10EBFB4A3D2A20

P || S = 70617373776F726478578E5A5D63CB06
T_1=     D1F94C4D447039B034494400F2E7DF9DCB67C308
T_2=     2BB479C1D369EA74BB976BBA2629744E8259C6F5
...
T_999=   6663F4611D61571068B5DA168974C6FF2C9775AC
T_1000=  DC19847E05C64D2FAF10EBFB4A3D2A20B4E35EFE
Key=     DC19847E05C64D2FAF10EBFB4A3D2A20
</code></pre>

<p>So now lets write a PHP function that does this:</p>

<pre><code>function PBKDF1($pass,$salt,$count,$dklen) { 
    $t = $pass.$salt;
    //echo 'S||P: '.bin2hex($t).'&lt;br/&gt;';
    $t = sha1($t, true); 
    //echo 'T1:' . bin2hex($t) . '&lt;br/&gt;';
    for($i=2; $i &lt;= $count; $i++) { 
        $t = sha1($t, true); 
        //echo 'T'.$i.':' . bin2hex($t) . '&lt;br/&gt;';
    } 
    $t = substr($t,0,$dklen); 
    return $t;      
}
</code></pre>

<p>Now you can see the errs of your ways: you did not specify the all important <code>raw=true</code> parameter to <code>sha1</code>. Lets see what is our function output:</p>

<pre><code>$HashPassPhrase = pack(""H*"",""70617373776F7264"");
$HashSalt = pack(""H*"",""78578E5A5D63CB06""); 
$HashIterations = 1000; 
$devkeylength = 16; 
$devkey = PBKDF1($HashPassPhrase,$HashSalt,$HashIterations,$devkeylength);
echo 'Key:' . bin2hex(substr($devkey, 0, 8)) . '&lt;br/&gt;';
echo 'IV:' . bin2hex(substr($devkey, 8, 8)) .'&lt;br/&gt;';
echo 'Expected: DC19847E05C64D2FAF10EBFB4A3D2A20&lt;br/&gt;';
</code></pre>

<p>this output exactly the expected result:</p>

<pre><code>Key:dc19847e05c64d2f
IV:af10ebfb4a3d2a20
Expected: DC19847E05C64D2FAF10EBFB4A3D2A20
</code></pre>

<p>Next, we can validate that the C# function does the same:</p>

<pre><code>            byte[] password = Encoding.ASCII.GetBytes(""password"");
            byte[] salt = new byte[] { 0x78, 0x57, 0x8e, 0x5a, 0x5d, 0x63, 0xcb, 0x06};

            PasswordDeriveBytes pdb = new PasswordDeriveBytes(
                password, salt, ""SHA1"", 1000);

            byte[] key = pdb.GetBytes(8);
            byte[] iv = pdb.GetBytes(8);

            Console.Out.Write(""Key: "");
            foreach (byte b in key)
            {
                Console.Out.Write(""{0:x} "", b);
            }
            Console.Out.WriteLine();

            Console.Out.Write(""IV: "");
            foreach (byte b in iv)
            {
                Console.Out.Write(""{0:x} "", b);
            }
            Console.Out.WriteLine();
</code></pre>

<p>this produces the very same output:</p>

<pre><code>Key: dc 19 84 7e 5 c6 4d 2f
IV: af 10 eb fb 4a 3d 2a 20
</code></pre>

<p><strong>QED</strong></p>

<h1>bonus explanation</h1>

<p>Please don't do crypto if you don't know <em>exactly</em> what you're doing. Even after you get the PHP implementaiton correct, your posted C# code has some serious problems. You are mixing byte arrays with stirng representing hex dumps, you use a hard coded IV instead of deriving it from the passphrase and salt, is just overall plain wrong. Please use an off-the shelf encryption scheme, like SSL or S-MIME and do not re-invent your own. You will get it <strong>wrong</strong>.</p>
","7087","<c#><php><encryption><aes><rijndael>","12","17","4","2012-10-16 15:10:23","","0","2","","","","2010-08-17 17:59:53",""
"3505453","Rewrite Rijndael 256 C# Encryption Code in PHP","<p>I have an encryption/decryption algorithm written in C# - I need to be able to produce the same encryption in PHP so I can send the encrypted text over HTTP to be decrypted on the C# side.
Here is the C# code for the encryption.</p>

<pre><code>this.m_plainText = string.Empty;
this.m_passPhrase = ""passpharse"";
this.m_saltValue = ""saltvalue"";
this.m_hashAlgorithm = ""SHA1"";
this.m_passwordIterations = 2;
this.m_initVector = ""1a2b3c4d5e6f7g8h"";
this.m_keySize = 256;

public string Encrypt()
{
    string plainText = this.m_plainText;
    string passPhrase = this.m_passPhrase;
    string saltValue = this.m_saltValue;
    string hashAlgorithm = this.m_hashAlgorithm;
    int passwordIterations = this.m_passwordIterations;
    string initVector = this.m_initVector;
    int keySize = this.m_keySize;

    // Convert strings into byte arrays.
    // Let us assume that strings only contain ASCII codes.
    // If strings include Unicode characters, use Unicode, UTF7, or UTF8 
    // encoding.
    byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
    byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

    // Convert our plaintext into a byte array.
    // Let us assume that plaintext contains UTF8-encoded characters.
    byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);

    // First, we must create a password, from which the key will be derived.
    // This password will be generated from the specified passphrase and 
    // salt value. The password will be created using the specified hash 
    // algorithm. Password creation can be done in several iterations.
    PasswordDeriveBytes password = new PasswordDeriveBytes(
                                                    passPhrase,
                                                    saltValueBytes,
                                                    hashAlgorithm,
                                                    passwordIterations);

    // Use the password to generate pseudo-random bytes for the encryption
    // key. Specify the size of the key in bytes (instead of bits).
    byte[] keyBytes = password.GetBytes(keySize / 8);

    // Create uninitialized Rijndael encryption object.
    RijndaelManaged symmetricKey = new RijndaelManaged();

    // It is reasonable to set encryption mode to Cipher Block Chaining
    // (CBC). Use default options for other symmetric key parameters.
    symmetricKey.Mode = CipherMode.CBC;

    // Generate encryptor from the existing key bytes and initialization 
    // vector. Key size will be defined based on the number of the key 
    // bytes.
    ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                                                     keyBytes,
                                                     initVectorBytes);

    // Define memory stream which will be used to hold encrypted data.
    MemoryStream memoryStream = new MemoryStream();

    // Define cryptographic stream (always use Write mode for encryption).
    CryptoStream cryptoStream = new CryptoStream(memoryStream,
                                                 encryptor,
                                                 CryptoStreamMode.Write);
    // Start encrypting.
    cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

    // Finish encrypting.
    cryptoStream.FlushFinalBlock();

    // Convert our encrypted data from a memory stream into a byte array.
    byte[] cipherTextBytes = memoryStream.ToArray();

    // Close both streams.
    memoryStream.Close();
    cryptoStream.Close();

    // Convert encrypted data into a base64-encoded string.
    string cipherText = Convert.ToBase64String(cipherTextBytes);

    // Return encrypted string.
    return cipherText;
}
</code></pre>

<p>I have some similar PHP code that may help.  It doesn't do exactly as needed, but I think it may be a good place to start.</p>

<pre><code>&lt;?php

/*
 * DEFINE CONSTANTS
 */
$HashPassPhrase = ""passpharse"";
$HashSalt = ""saltvalue"";
$HashAlgorithm = ""SHA1"";
$HashIterations = ""2"";
$InitVector = ""1a2b3c4d5e6f7g8h"";        // Must be 16 bytes
$keySize = ""256"";

class Cipher {
    private $securekey, $iv;
    function __construct($textkey) {
        $this-&gt;securekey = hash($HashAlgorithm,$textkey,TRUE);
        $this-&gt;iv = $InitVector;
    }
    function encrypt($input) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, $input, MCRYPT_MODE_CBC, $this-&gt;iv));
    }
    function decrypt($input) {
        return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, base64_decode($input), MCRYPT_MODE_CBC, $this-&gt;iv));
    }
}

$cipher = new Cipher($HashPassPhrase);

$encryptedtext = $cipher-&gt;encrypt(""Text To Encrypt"");
echo ""-&gt;encrypt = $encryptedtext&lt;br /&gt;"";

$decryptedtext = $cipher-&gt;decrypt($encryptedtext);
echo ""-&gt;decrypt = $decryptedtext&lt;br /&gt;"";

var_dump($cipher);
</code></pre>

<p>?></p>
","<p>It looks like your main problem is that you're using PHP's <code>hash()</code> in place of the <code>PasswordDeriveBytes()</code> step on the C# side.  Those two methods are not equivalent.  The latter implements the <a href=""http://tools.ietf.org/html/rfc2898#section-5.1"" rel=""nofollow noreferrer"">PBKDF1</a> password derivation algorithm, while <code>hash()</code> is just a hash.  It looks like <a href=""http://pear.php.net/pepr/pepr-proposal-show.php?id=591"" rel=""nofollow noreferrer"">PEAR might have a PBKDF1 implementation</a>, but otherwise you might have to write it yourself.</p>

<p>You also need to make sure your text encoding is consistent on both sides, if you haven't already.</p>

<p>Finally, you should consider not doing what you're doing because <a href=""http://www.schneier.com/essay-037.html"" rel=""nofollow noreferrer"">cryptography is harder than it looks</a>.  Since you're using HTTP, you can make use of the SSL protocol in lieu of writing your own.  This will net you far better security and less hassle on low-level details like keeping incremental IVs in sync and whatnot.</p>
","7087","<c#><php><encryption><aes><rijndael>","12","4","4","2012-10-16 15:10:23","","0","2","","","","2010-08-17 17:59:53",""
"3505453","Rewrite Rijndael 256 C# Encryption Code in PHP","<p>I have an encryption/decryption algorithm written in C# - I need to be able to produce the same encryption in PHP so I can send the encrypted text over HTTP to be decrypted on the C# side.
Here is the C# code for the encryption.</p>

<pre><code>this.m_plainText = string.Empty;
this.m_passPhrase = ""passpharse"";
this.m_saltValue = ""saltvalue"";
this.m_hashAlgorithm = ""SHA1"";
this.m_passwordIterations = 2;
this.m_initVector = ""1a2b3c4d5e6f7g8h"";
this.m_keySize = 256;

public string Encrypt()
{
    string plainText = this.m_plainText;
    string passPhrase = this.m_passPhrase;
    string saltValue = this.m_saltValue;
    string hashAlgorithm = this.m_hashAlgorithm;
    int passwordIterations = this.m_passwordIterations;
    string initVector = this.m_initVector;
    int keySize = this.m_keySize;

    // Convert strings into byte arrays.
    // Let us assume that strings only contain ASCII codes.
    // If strings include Unicode characters, use Unicode, UTF7, or UTF8 
    // encoding.
    byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
    byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

    // Convert our plaintext into a byte array.
    // Let us assume that plaintext contains UTF8-encoded characters.
    byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);

    // First, we must create a password, from which the key will be derived.
    // This password will be generated from the specified passphrase and 
    // salt value. The password will be created using the specified hash 
    // algorithm. Password creation can be done in several iterations.
    PasswordDeriveBytes password = new PasswordDeriveBytes(
                                                    passPhrase,
                                                    saltValueBytes,
                                                    hashAlgorithm,
                                                    passwordIterations);

    // Use the password to generate pseudo-random bytes for the encryption
    // key. Specify the size of the key in bytes (instead of bits).
    byte[] keyBytes = password.GetBytes(keySize / 8);

    // Create uninitialized Rijndael encryption object.
    RijndaelManaged symmetricKey = new RijndaelManaged();

    // It is reasonable to set encryption mode to Cipher Block Chaining
    // (CBC). Use default options for other symmetric key parameters.
    symmetricKey.Mode = CipherMode.CBC;

    // Generate encryptor from the existing key bytes and initialization 
    // vector. Key size will be defined based on the number of the key 
    // bytes.
    ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                                                     keyBytes,
                                                     initVectorBytes);

    // Define memory stream which will be used to hold encrypted data.
    MemoryStream memoryStream = new MemoryStream();

    // Define cryptographic stream (always use Write mode for encryption).
    CryptoStream cryptoStream = new CryptoStream(memoryStream,
                                                 encryptor,
                                                 CryptoStreamMode.Write);
    // Start encrypting.
    cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

    // Finish encrypting.
    cryptoStream.FlushFinalBlock();

    // Convert our encrypted data from a memory stream into a byte array.
    byte[] cipherTextBytes = memoryStream.ToArray();

    // Close both streams.
    memoryStream.Close();
    cryptoStream.Close();

    // Convert encrypted data into a base64-encoded string.
    string cipherText = Convert.ToBase64String(cipherTextBytes);

    // Return encrypted string.
    return cipherText;
}
</code></pre>

<p>I have some similar PHP code that may help.  It doesn't do exactly as needed, but I think it may be a good place to start.</p>

<pre><code>&lt;?php

/*
 * DEFINE CONSTANTS
 */
$HashPassPhrase = ""passpharse"";
$HashSalt = ""saltvalue"";
$HashAlgorithm = ""SHA1"";
$HashIterations = ""2"";
$InitVector = ""1a2b3c4d5e6f7g8h"";        // Must be 16 bytes
$keySize = ""256"";

class Cipher {
    private $securekey, $iv;
    function __construct($textkey) {
        $this-&gt;securekey = hash($HashAlgorithm,$textkey,TRUE);
        $this-&gt;iv = $InitVector;
    }
    function encrypt($input) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, $input, MCRYPT_MODE_CBC, $this-&gt;iv));
    }
    function decrypt($input) {
        return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, base64_decode($input), MCRYPT_MODE_CBC, $this-&gt;iv));
    }
}

$cipher = new Cipher($HashPassPhrase);

$encryptedtext = $cipher-&gt;encrypt(""Text To Encrypt"");
echo ""-&gt;encrypt = $encryptedtext&lt;br /&gt;"";

$decryptedtext = $cipher-&gt;decrypt($encryptedtext);
echo ""-&gt;decrypt = $decryptedtext&lt;br /&gt;"";

var_dump($cipher);
</code></pre>

<p>?></p>
","<p>Is there a good reason why you can't just use <a href=""http://php.net/manual/en/function.mcrypt-module-open.php"" rel=""nofollow noreferrer"">http://php.net/manual/en/function.mcrypt-module-open.php</a> and use rijndael-256 as the algorithm????</p>
","7087","<c#><php><encryption><aes><rijndael>","12","0","4","2012-10-16 15:10:23","","0","2","","","","2010-08-17 17:59:53",""
"3505453","Rewrite Rijndael 256 C# Encryption Code in PHP","<p>I have an encryption/decryption algorithm written in C# - I need to be able to produce the same encryption in PHP so I can send the encrypted text over HTTP to be decrypted on the C# side.
Here is the C# code for the encryption.</p>

<pre><code>this.m_plainText = string.Empty;
this.m_passPhrase = ""passpharse"";
this.m_saltValue = ""saltvalue"";
this.m_hashAlgorithm = ""SHA1"";
this.m_passwordIterations = 2;
this.m_initVector = ""1a2b3c4d5e6f7g8h"";
this.m_keySize = 256;

public string Encrypt()
{
    string plainText = this.m_plainText;
    string passPhrase = this.m_passPhrase;
    string saltValue = this.m_saltValue;
    string hashAlgorithm = this.m_hashAlgorithm;
    int passwordIterations = this.m_passwordIterations;
    string initVector = this.m_initVector;
    int keySize = this.m_keySize;

    // Convert strings into byte arrays.
    // Let us assume that strings only contain ASCII codes.
    // If strings include Unicode characters, use Unicode, UTF7, or UTF8 
    // encoding.
    byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
    byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

    // Convert our plaintext into a byte array.
    // Let us assume that plaintext contains UTF8-encoded characters.
    byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);

    // First, we must create a password, from which the key will be derived.
    // This password will be generated from the specified passphrase and 
    // salt value. The password will be created using the specified hash 
    // algorithm. Password creation can be done in several iterations.
    PasswordDeriveBytes password = new PasswordDeriveBytes(
                                                    passPhrase,
                                                    saltValueBytes,
                                                    hashAlgorithm,
                                                    passwordIterations);

    // Use the password to generate pseudo-random bytes for the encryption
    // key. Specify the size of the key in bytes (instead of bits).
    byte[] keyBytes = password.GetBytes(keySize / 8);

    // Create uninitialized Rijndael encryption object.
    RijndaelManaged symmetricKey = new RijndaelManaged();

    // It is reasonable to set encryption mode to Cipher Block Chaining
    // (CBC). Use default options for other symmetric key parameters.
    symmetricKey.Mode = CipherMode.CBC;

    // Generate encryptor from the existing key bytes and initialization 
    // vector. Key size will be defined based on the number of the key 
    // bytes.
    ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                                                     keyBytes,
                                                     initVectorBytes);

    // Define memory stream which will be used to hold encrypted data.
    MemoryStream memoryStream = new MemoryStream();

    // Define cryptographic stream (always use Write mode for encryption).
    CryptoStream cryptoStream = new CryptoStream(memoryStream,
                                                 encryptor,
                                                 CryptoStreamMode.Write);
    // Start encrypting.
    cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

    // Finish encrypting.
    cryptoStream.FlushFinalBlock();

    // Convert our encrypted data from a memory stream into a byte array.
    byte[] cipherTextBytes = memoryStream.ToArray();

    // Close both streams.
    memoryStream.Close();
    cryptoStream.Close();

    // Convert encrypted data into a base64-encoded string.
    string cipherText = Convert.ToBase64String(cipherTextBytes);

    // Return encrypted string.
    return cipherText;
}
</code></pre>

<p>I have some similar PHP code that may help.  It doesn't do exactly as needed, but I think it may be a good place to start.</p>

<pre><code>&lt;?php

/*
 * DEFINE CONSTANTS
 */
$HashPassPhrase = ""passpharse"";
$HashSalt = ""saltvalue"";
$HashAlgorithm = ""SHA1"";
$HashIterations = ""2"";
$InitVector = ""1a2b3c4d5e6f7g8h"";        // Must be 16 bytes
$keySize = ""256"";

class Cipher {
    private $securekey, $iv;
    function __construct($textkey) {
        $this-&gt;securekey = hash($HashAlgorithm,$textkey,TRUE);
        $this-&gt;iv = $InitVector;
    }
    function encrypt($input) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, $input, MCRYPT_MODE_CBC, $this-&gt;iv));
    }
    function decrypt($input) {
        return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $this-&gt;securekey, base64_decode($input), MCRYPT_MODE_CBC, $this-&gt;iv));
    }
}

$cipher = new Cipher($HashPassPhrase);

$encryptedtext = $cipher-&gt;encrypt(""Text To Encrypt"");
echo ""-&gt;encrypt = $encryptedtext&lt;br /&gt;"";

$decryptedtext = $cipher-&gt;decrypt($encryptedtext);
echo ""-&gt;decrypt = $decryptedtext&lt;br /&gt;"";

var_dump($cipher);
</code></pre>

<p>?></p>
","<p>Check OpenSSL routines in PHP, they should be able to handle what you need to do.</p>
","7087","<c#><php><encryption><aes><rijndael>","12","0","4","2012-10-16 15:10:23","","0","2","","","","2010-08-17 17:59:53",""
"9243034","How secure is VB.NET Rijndael Managed Encryption or AES?","<p>I am using a slightly modified version of <a href=""http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael"" rel=""nofollow"">this code</a>. to create a mission critical application. That files that will be encrypted are very important. This has to be done from scratch because there are some other things that has to be done along with this.</p>

<p>How secure is this? Its impossible to crack this encryption right?</p>

<p>Am very sorry here is a working link. <a href=""http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael"" rel=""nofollow"">http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael</a></p>

<pre><code>Imports System
Imports System.IO
Imports System.Security
Imports System.Security.Cryptography


'*************************
'** Global Variables
'*************************

Dim strFileToEncrypt As String
Dim strFileToDecrypt As String
Dim strOutputEncrypt As String
Dim strOutputDecrypt As String
Dim fsInput As System.IO.FileStream
Dim fsOutput As System.IO.FileStream



'*************************
'** Create A Key
'*************************

Private Function CreateKey(ByVal strPassword As String) As Byte()
    'Convert strPassword to an array and store in chrData.
    Dim chrData() As Char = strPassword.ToCharArray
    'Use intLength to get strPassword size.
    Dim intLength As Integer = chrData.GetUpperBound(0)
    'Declare bytDataToHash and make it the same size as chrData.
    Dim bytDataToHash(intLength) As Byte

    'Use For Next to convert and store chrData into bytDataToHash.
    For i As Integer = 0 To chrData.GetUpperBound(0)
        bytDataToHash(i) = CByte(Asc(chrData(i)))
    Next

    'Declare what hash to use.
    Dim SHA512 As New System.Security.Cryptography.SHA512Managed
    'Declare bytResult, Hash bytDataToHash and store it in bytResult.
    Dim bytResult As Byte() = SHA512.ComputeHash(bytDataToHash)
    'Declare bytKey(31).  It will hold 256 bits.
    Dim bytKey(31) As Byte

    'Use For Next to put a specific size (256 bits) of 
    'bytResult into bytKey. The 0 To 31 will put the first 256 bits
    'of 512 bits into bytKey.
    For i As Integer = 0 To 31
        bytKey(i) = bytResult(i)
    Next

    Return bytKey 'Return the key.
End Function


'*************************
'** Create An IV
'*************************

Private Function CreateIV(ByVal strPassword As String) As Byte()
    'Convert strPassword to an array and store in chrData.
    Dim chrData() As Char = strPassword.ToCharArray
    'Use intLength to get strPassword size.
    Dim intLength As Integer = chrData.GetUpperBound(0)
    'Declare bytDataToHash and make it the same size as chrData.
    Dim bytDataToHash(intLength) As Byte

    'Use For Next to convert and store chrData into bytDataToHash.
    For i As Integer = 0 To chrData.GetUpperBound(0)
        bytDataToHash(i) = CByte(Asc(chrData(i)))
    Next

    'Declare what hash to use.
    Dim SHA512 As New System.Security.Cryptography.SHA512Managed
    'Declare bytResult, Hash bytDataToHash and store it in bytResult.
    Dim bytResult As Byte() = SHA512.ComputeHash(bytDataToHash)
    'Declare bytIV(15).  It will hold 128 bits.
    Dim bytIV(15) As Byte

    'Use For Next to put a specific size (128 bits) of bytResult into bytIV.
    'The 0 To 30 for bytKey used the first 256 bits of the hashed password.
    'The 32 To 47 will put the next 128 bits into bytIV.
    For i As Integer = 32 To 47
        bytIV(i - 32) = bytResult(i)
    Next

    Return bytIV 'Return the IV.
End Function
</code></pre>

<p>Encryption and Decryption</p>

<pre><code>'****************************
'** Encrypt/Decrypt File
'****************************

Private Enum CryptoAction
    'Define the enumeration for CryptoAction.
    ActionEncrypt = 1
    ActionDecrypt = 2
End Enum

Private Sub EncryptOrDecryptFile(ByVal strInputFile As String, _
                                 ByVal strOutputFile As String, _
                                 ByVal bytKey() As Byte, _
                                 ByVal bytIV() As Byte, _
                                 ByVal Direction As CryptoAction)
    Try 'In case of errors.

        'Setup file streams to handle input and output.
        fsInput = New System.IO.FileStream(strInputFile, FileMode.Open, _
                                              FileAccess.Read)
        fsOutput = New System.IO.FileStream(strOutputFile, _
                                               FileMode.OpenOrCreate, _
                                               FileAccess.Write)
        fsOutput.SetLength(0) 'make sure fsOutput is empty

        'Declare variables for encrypt/decrypt process.
        Dim bytBuffer(4096) As Byte 'holds a block of bytes for processing
        Dim lngBytesProcessed As Long = 0 'running count of bytes processed
        Dim lngFileLength As Long = fsInput.Length 'the input file's length
        Dim intBytesInCurrentBlock As Integer 'current bytes being processed
        Dim csCryptoStream As CryptoStream
        'Declare your CryptoServiceProvider.
        Dim cspRijndael As New System.Security.Cryptography.RijndaelManaged
        'Setup Progress Bar
        pbStatus.Value = 0
        pbStatus.Maximum = 100

        'Determine if ecryption or decryption and setup CryptoStream.
        Select Case Direction
            Case CryptoAction.ActionEncrypt
                csCryptoStream = New CryptoStream(fsOutput, _
                cspRijndael.CreateEncryptor(bytKey, bytIV), _
                CryptoStreamMode.Write)

            Case CryptoAction.ActionDecrypt
                csCryptoStream = New CryptoStream(fsOutput, _
                cspRijndael.CreateDecryptor(bytKey, bytIV), _
                CryptoStreamMode.Write)
        End Select

        'Use While to loop until all of the file is processed.
        While lngBytesProcessed &lt; lngFileLength
            'Read file with the input filestream.
            intBytesInCurrentBlock = fsInput.Read(bytBuffer, 0, 4096)
            'Write output file with the cryptostream.
            csCryptoStream.Write(bytBuffer, 0, intBytesInCurrentBlock)
            'Update lngBytesProcessed
            lngBytesProcessed = lngBytesProcessed + _
                                    CLng(intBytesInCurrentBlock)
            'Update Progress Bar
            pbStatus.Value = CInt((lngBytesProcessed / lngFileLength) * 100)
        End While

        'Close FileStreams and CryptoStream.
        csCryptoStream.Close()
        fsInput.Close()
        fsOutput.Close()
</code></pre>

<p>I have pasted the main codes from there to here.</p>
","<p>Nothing is ever impossible, especially if you use a weak IV or key. However it's so statistically insignificant that you should be able to sleep well at night. If you're asking if other people use this algorithm for mission-critical encryption, the answer is most definitely yes.</p>
","5929","<vb.net><encryption><aes><rijndael>","3","3","2","2012-02-12 08:40:31","9243452","3","2","363661","","2012-02-12 08:40:31","2012-02-11 18:51:28",""
"9243034","How secure is VB.NET Rijndael Managed Encryption or AES?","<p>I am using a slightly modified version of <a href=""http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael"" rel=""nofollow"">this code</a>. to create a mission critical application. That files that will be encrypted are very important. This has to be done from scratch because there are some other things that has to be done along with this.</p>

<p>How secure is this? Its impossible to crack this encryption right?</p>

<p>Am very sorry here is a working link. <a href=""http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael"" rel=""nofollow"">http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael</a></p>

<pre><code>Imports System
Imports System.IO
Imports System.Security
Imports System.Security.Cryptography


'*************************
'** Global Variables
'*************************

Dim strFileToEncrypt As String
Dim strFileToDecrypt As String
Dim strOutputEncrypt As String
Dim strOutputDecrypt As String
Dim fsInput As System.IO.FileStream
Dim fsOutput As System.IO.FileStream



'*************************
'** Create A Key
'*************************

Private Function CreateKey(ByVal strPassword As String) As Byte()
    'Convert strPassword to an array and store in chrData.
    Dim chrData() As Char = strPassword.ToCharArray
    'Use intLength to get strPassword size.
    Dim intLength As Integer = chrData.GetUpperBound(0)
    'Declare bytDataToHash and make it the same size as chrData.
    Dim bytDataToHash(intLength) As Byte

    'Use For Next to convert and store chrData into bytDataToHash.
    For i As Integer = 0 To chrData.GetUpperBound(0)
        bytDataToHash(i) = CByte(Asc(chrData(i)))
    Next

    'Declare what hash to use.
    Dim SHA512 As New System.Security.Cryptography.SHA512Managed
    'Declare bytResult, Hash bytDataToHash and store it in bytResult.
    Dim bytResult As Byte() = SHA512.ComputeHash(bytDataToHash)
    'Declare bytKey(31).  It will hold 256 bits.
    Dim bytKey(31) As Byte

    'Use For Next to put a specific size (256 bits) of 
    'bytResult into bytKey. The 0 To 31 will put the first 256 bits
    'of 512 bits into bytKey.
    For i As Integer = 0 To 31
        bytKey(i) = bytResult(i)
    Next

    Return bytKey 'Return the key.
End Function


'*************************
'** Create An IV
'*************************

Private Function CreateIV(ByVal strPassword As String) As Byte()
    'Convert strPassword to an array and store in chrData.
    Dim chrData() As Char = strPassword.ToCharArray
    'Use intLength to get strPassword size.
    Dim intLength As Integer = chrData.GetUpperBound(0)
    'Declare bytDataToHash and make it the same size as chrData.
    Dim bytDataToHash(intLength) As Byte

    'Use For Next to convert and store chrData into bytDataToHash.
    For i As Integer = 0 To chrData.GetUpperBound(0)
        bytDataToHash(i) = CByte(Asc(chrData(i)))
    Next

    'Declare what hash to use.
    Dim SHA512 As New System.Security.Cryptography.SHA512Managed
    'Declare bytResult, Hash bytDataToHash and store it in bytResult.
    Dim bytResult As Byte() = SHA512.ComputeHash(bytDataToHash)
    'Declare bytIV(15).  It will hold 128 bits.
    Dim bytIV(15) As Byte

    'Use For Next to put a specific size (128 bits) of bytResult into bytIV.
    'The 0 To 30 for bytKey used the first 256 bits of the hashed password.
    'The 32 To 47 will put the next 128 bits into bytIV.
    For i As Integer = 32 To 47
        bytIV(i - 32) = bytResult(i)
    Next

    Return bytIV 'Return the IV.
End Function
</code></pre>

<p>Encryption and Decryption</p>

<pre><code>'****************************
'** Encrypt/Decrypt File
'****************************

Private Enum CryptoAction
    'Define the enumeration for CryptoAction.
    ActionEncrypt = 1
    ActionDecrypt = 2
End Enum

Private Sub EncryptOrDecryptFile(ByVal strInputFile As String, _
                                 ByVal strOutputFile As String, _
                                 ByVal bytKey() As Byte, _
                                 ByVal bytIV() As Byte, _
                                 ByVal Direction As CryptoAction)
    Try 'In case of errors.

        'Setup file streams to handle input and output.
        fsInput = New System.IO.FileStream(strInputFile, FileMode.Open, _
                                              FileAccess.Read)
        fsOutput = New System.IO.FileStream(strOutputFile, _
                                               FileMode.OpenOrCreate, _
                                               FileAccess.Write)
        fsOutput.SetLength(0) 'make sure fsOutput is empty

        'Declare variables for encrypt/decrypt process.
        Dim bytBuffer(4096) As Byte 'holds a block of bytes for processing
        Dim lngBytesProcessed As Long = 0 'running count of bytes processed
        Dim lngFileLength As Long = fsInput.Length 'the input file's length
        Dim intBytesInCurrentBlock As Integer 'current bytes being processed
        Dim csCryptoStream As CryptoStream
        'Declare your CryptoServiceProvider.
        Dim cspRijndael As New System.Security.Cryptography.RijndaelManaged
        'Setup Progress Bar
        pbStatus.Value = 0
        pbStatus.Maximum = 100

        'Determine if ecryption or decryption and setup CryptoStream.
        Select Case Direction
            Case CryptoAction.ActionEncrypt
                csCryptoStream = New CryptoStream(fsOutput, _
                cspRijndael.CreateEncryptor(bytKey, bytIV), _
                CryptoStreamMode.Write)

            Case CryptoAction.ActionDecrypt
                csCryptoStream = New CryptoStream(fsOutput, _
                cspRijndael.CreateDecryptor(bytKey, bytIV), _
                CryptoStreamMode.Write)
        End Select

        'Use While to loop until all of the file is processed.
        While lngBytesProcessed &lt; lngFileLength
            'Read file with the input filestream.
            intBytesInCurrentBlock = fsInput.Read(bytBuffer, 0, 4096)
            'Write output file with the cryptostream.
            csCryptoStream.Write(bytBuffer, 0, intBytesInCurrentBlock)
            'Update lngBytesProcessed
            lngBytesProcessed = lngBytesProcessed + _
                                    CLng(intBytesInCurrentBlock)
            'Update Progress Bar
            pbStatus.Value = CInt((lngBytesProcessed / lngFileLength) * 100)
        End While

        'Close FileStreams and CryptoStream.
        csCryptoStream.Close()
        fsInput.Close()
        fsOutput.Close()
</code></pre>

<p>I have pasted the main codes from there to here.</p>
","<p>As stated nothing is impossible to crack, you can only follow best practices to make it as hard as possible for any potential attacker.</p>

<p>Actually, the code you linked to is not regarded as state-of-the-art anymore (if it ever was). It creates the symmetric encryption key by hashing a password. This is bad because passwords generally don't possess enough entropy to thwart sophisticated attacks based on dictionaries. In addition, it doesn't use any <a href=""http://en.wikipedia.org/wiki/Salt_%28cryptography%29"" rel=""noreferrer"">salt</a> or equivalent, so it's quite easy to attack this with precomputed tables. </p>

<p>Whenever you can, you should generate symmetric keys with a secure PRNG (pseudo-random number generator). If there's no particular need for involving passwords, don't do it. If it absolutely has to be passwords, use PBKDF2 from <a href=""http://www.rsa.com/rsalabs/node.asp?id=2127"" rel=""noreferrer"">PKCS5</a> or alternatives like bcrypt or scrypt.</p>

<p>The IV should also always be generated from a secure PRNG, and never reused if possible. There's no need to derive it from the password, too, as is shown in the example you linked.
The IV is public information, that means you may safely publish it - but it is mandatory that it stays unpredictable and random - otherwise you are susceptible to some <a href=""http://blog.cryptographyengineering.com/2011/09/brief-diversion-beast-attack-on-tlsssl.html"" rel=""noreferrer"">dedicated attacks</a> unless you are using an Authenticated Encryption mode such as GCM.</p>

<p>If you are unfamiliar with these topics and in doubt, I would strongly recommend to consult specialists. If the data to be secured is as important as you say, the extra money should be well spent. If not experienced in the area, chances are just too high that you may overlook something important when hand-crafting your own solution.</p>
","5929","<vb.net><encryption><aes><rijndael>","3","9","2","2012-02-12 08:40:31","9243452","3","2","363661","","2012-02-12 08:40:31","2012-02-11 18:51:28",""
"11160788","Decrypting data with openssl commandline tool","<p>I have to following code and as far as I know it is correct, but it does not work. I am trying to encode data with PHP's Mcrpyt and then decode it with the openssl commandline tool.</p>

<p>This is my PHP code:</p>

<pre><code>/*
 * Convert a normal ascii string to a hexadecimal string.
 * Complement of hexToString().
*/
function stringToHex($str)
{
    $hex_str = """";
    for ($i = 0; $i &lt; strlen($str); ++$i)
    {
        $hex_str .= sprintf(""%02X"", ord($str[$i]));
    }

    return $hex_str;
}


    $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_DEV_RANDOM);

    $block_size = mcrypt_get_block_size(""rijndael-128"", ""cbc"");
    $pad = $block_size - (strlen($data) % $block_size);
    $data .= str_repeat(chr($pad), $pad);

    $encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, ""1234567812345678"", $data, MCRYPT_MODE_CBC, $iv);

    $message = stringToHex($iv) . base64_encode($encrypted);
</code></pre>

<p>I append the IV to the encoded message. Say for example the IV is 00000000000000000000000000000000 (size is 32), then I use the following command for decryption:</p>

<pre><code>openssl enc -d -aes-128-cbc -A -nosalt -K 31323334353637383132333435363738 -iv 00000000000000000000000000000000 -in file_in &gt; file_out
</code></pre>

<p>Also note that 1234567812345678 is hex is 31323334353637383132333435363738. But I keep getting the same error message:</p>

<blockquote>
  <p>bad decrypt
  1340:error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length:./crypto/evp/evp_enc.c:454:</p>
</blockquote>

<p>Anyone?</p>

<p>Thanks in advance,
all love,
Jori.</p>
","<p>Well, I tested your code and it worked with a couple of changes. </p>

<p>1) Input for openssl should include only the ciphertext, not the prepended IV (as your code was incomplete I was not sure if you indeed stripped the IV from the ciphertext before processing it with openssl).</p>

<p>2) Your openssl command was missing a parameter (-a), required to actually do the Base64 decoding (just using -A won't enable this). Again, as your description was incomplete I was not sure if you indeed Base64-decoded the message before storing it in file_in.</p>

<p>Just to be complete, this is the code I used to test your code (I run it from the command line, not using the web server).</p>

<pre><code>&lt;?php

$data = ""
This is a test. This is only a test.
Stack Overflow is collaboratively built and maintained
by your fellow programmers.
"";
$keybin = ""1234567812345678"";


//$iv = mcrypt_create_iv (mcrypt_get_iv_size (MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_DEV_RANDOM);
$iv = mcrypt_create_iv (mcrypt_get_iv_size (MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND);
$block_size = mcrypt_get_block_size (""rijndael-128"", ""cbc"");
$pad = $block_size - (strlen ($data) % $block_size);
$data .= str_repeat (chr ($pad), $pad);
$encrypted = mcrypt_encrypt (MCRYPT_RIJNDAEL_128, $keybin, $data, MCRYPT_MODE_CBC, $iv);
$message = base64_encode ($encrypted);

echo ""CIPHERTEXT=  "" . $message . ""\n"";
echo ""IV=  "" . bin2hex ($iv) . ""\n"";
echo ""KEY=  "" . bin2hex ($keybin) . ""\n"";

echo ""\nTest with:\n\necho $message | openssl enc -d -aes-128-cbc -nosalt -a -A -K "" . bin2hex ($keybin) . "" -iv "" . bin2hex ($iv) . ""\n\n"";

?&gt;
</code></pre>

<p>Other minor differences was I used PHP's bin2hex.</p>

<p>It will produce an output like:</p>

<pre><code>CIPHERTEXT=  /e81Ua/0jxgff3j5GjKXaNilv5WqPYV7yRYy4AzsTUmGQeK0hcMjuUYp1Yrfthaox9zTI0DeDQT4fba+y/qTQahZpYRAKcZa209RVg4W1HrySfZPMRCxE+y8r8scL3Xmj+oMGFpS+cDo111OPqwHhNwWSHbMlsoJLvMr70ZiQmE=
IV=  56c7c7248c68127cee8f0e54d89b4fc1
KEY=  31323334353637383132333435363738

Test with:

echo /e81Ua/0jxgff3j5GjKXaNilv5WqPYV7yRYy4AzsTUmGQeK0hcMjuUYp1Yrfthaox9zTI0DeDQT4fba+y/qTQahZpYRAKcZa209RVg4W1HrySfZPMRCxE+y8r8scL3Xmj+oMGFpS+cDo111OPqwHhNwWSHbMlsoJLvMr70ZiQmE= | openssl enc -d -aes-128-cbc -nosalt -a -A -K 31323334353637383132333435363738 -iv 56c7c7248c68127cee8f0e54d89b4fc1
</code></pre>

<p>The error you had (bad decrypt, digital envelope routines EVP_DecryptFinal_ex) usually means a wrong key or a corrupted ciphertext. I think in your example the problem was a corrupted ciphertext, caused by the prepended IV and/or lack of Base64 decoding.</p>
","5783","<php><openssl><mcrypt><rijndael>","2","2","2","2012-06-24 08:47:57","11176128","3","1","1124737","","2012-06-24 08:32:48","2012-06-22 16:57:27",""
"11160788","Decrypting data with openssl commandline tool","<p>I have to following code and as far as I know it is correct, but it does not work. I am trying to encode data with PHP's Mcrpyt and then decode it with the openssl commandline tool.</p>

<p>This is my PHP code:</p>

<pre><code>/*
 * Convert a normal ascii string to a hexadecimal string.
 * Complement of hexToString().
*/
function stringToHex($str)
{
    $hex_str = """";
    for ($i = 0; $i &lt; strlen($str); ++$i)
    {
        $hex_str .= sprintf(""%02X"", ord($str[$i]));
    }

    return $hex_str;
}


    $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_DEV_RANDOM);

    $block_size = mcrypt_get_block_size(""rijndael-128"", ""cbc"");
    $pad = $block_size - (strlen($data) % $block_size);
    $data .= str_repeat(chr($pad), $pad);

    $encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, ""1234567812345678"", $data, MCRYPT_MODE_CBC, $iv);

    $message = stringToHex($iv) . base64_encode($encrypted);
</code></pre>

<p>I append the IV to the encoded message. Say for example the IV is 00000000000000000000000000000000 (size is 32), then I use the following command for decryption:</p>

<pre><code>openssl enc -d -aes-128-cbc -A -nosalt -K 31323334353637383132333435363738 -iv 00000000000000000000000000000000 -in file_in &gt; file_out
</code></pre>

<p>Also note that 1234567812345678 is hex is 31323334353637383132333435363738. But I keep getting the same error message:</p>

<blockquote>
  <p>bad decrypt
  1340:error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length:./crypto/evp/evp_enc.c:454:</p>
</blockquote>

<p>Anyone?</p>

<p>Thanks in advance,
all love,
Jori.</p>
","<p><a href=""http://www.openssl.org/docs/apps/enc.html"" rel=""nofollow""><code>openssl enc</code></a> uses PKCS#5 padding that you kind of implemented, except the mandatory padding block if the data is a multiple of the block size. Since you test with 16 bytes (which is the block size) you need to add another 16 bytes containing <code>chr(16)</code>.</p>
","5783","<php><openssl><mcrypt><rijndael>","2","1","2","2012-06-24 08:47:57","11176128","3","1","1124737","","2012-06-24 08:32:48","2012-06-22 16:57:27",""
"751759","Rijndael / AES from C# to VB6","<p>I need to encrypt a byte array in VB6 and decrypt it in C# (NET 2.0). And viceversa (C# to VB6).</p>

<p>In C# I used RijndaelManaged class. In VB6 I used free pieces of from Internet. The best seems to be <a href=""http://www.frez.co.uk/freecode.htm#rijndael"" rel=""nofollow noreferrer"">http://www.frez.co.uk/freecode.htm#rijndael</a>
But the two implementations generate different outputs starting from the same input  :(</p>

<p>Perhaps it's a problem with the IV vector in RijndaelManaged ... I don't understand...</p>

<p>Any solution / experience using Rijndael / AES between VB6 and NET ?   Or TripleDes....</p>

<p>thank you</p>

<p>UPDATE:  IMPORTANT: The machine where vb6 app runs, has not NET framework. So I cannot use Interop and/or a NET wrapper class exposed as COM. :( </p>
","<p>You could use interop from .NET to call the C# implementation from VB6.  That way both sides would be using the same library.</p>

<p>Here's some additional info: <a href=""http://msdn.microsoft.com/en-us/library/hfzzah2c(vs.71).aspx"" rel=""noreferrer"">http://msdn.microsoft.com/en-us/library/hfzzah2c(vs.71).aspx</a></p>
","5233","<c#><vb6><aes><rijndaelmanaged><rijndael>","4","8","6","2011-07-05 14:25:11","","1","","95573","","2009-08-05 17:42:35","2009-04-15 13:44:55",""
"751759","Rijndael / AES from C# to VB6","<p>I need to encrypt a byte array in VB6 and decrypt it in C# (NET 2.0). And viceversa (C# to VB6).</p>

<p>In C# I used RijndaelManaged class. In VB6 I used free pieces of from Internet. The best seems to be <a href=""http://www.frez.co.uk/freecode.htm#rijndael"" rel=""nofollow noreferrer"">http://www.frez.co.uk/freecode.htm#rijndael</a>
But the two implementations generate different outputs starting from the same input  :(</p>

<p>Perhaps it's a problem with the IV vector in RijndaelManaged ... I don't understand...</p>

<p>Any solution / experience using Rijndael / AES between VB6 and NET ?   Or TripleDes....</p>

<p>thank you</p>

<p>UPDATE:  IMPORTANT: The machine where vb6 app runs, has not NET framework. So I cannot use Interop and/or a NET wrapper class exposed as COM. :( </p>
","<p>Maybe I'll give you some informations regarding IV.</p>

<p>Initialization Vector is a clear-text sent data that should be generated randomly for each encryption to make stereotype headers attack harder or imposible to perform. Of course both encrypter and decrypter MUST have same value set.</p>

<p>Also there are some modes in which encryption and decryption may run. Have a look at this page: <a href=""http://en.wikipedia.org/wiki/Cipher_feedback"" rel=""nofollow noreferrer"">Wikipedia: Block cipher modes of operation</a>. You should also ensure that this mode is same for both of them.</p>
","5233","<c#><vb6><aes><rijndaelmanaged><rijndael>","4","0","6","2011-07-05 14:25:11","","1","","95573","","2009-08-05 17:42:35","2009-04-15 13:44:55",""
"751759","Rijndael / AES from C# to VB6","<p>I need to encrypt a byte array in VB6 and decrypt it in C# (NET 2.0). And viceversa (C# to VB6).</p>

<p>In C# I used RijndaelManaged class. In VB6 I used free pieces of from Internet. The best seems to be <a href=""http://www.frez.co.uk/freecode.htm#rijndael"" rel=""nofollow noreferrer"">http://www.frez.co.uk/freecode.htm#rijndael</a>
But the two implementations generate different outputs starting from the same input  :(</p>

<p>Perhaps it's a problem with the IV vector in RijndaelManaged ... I don't understand...</p>

<p>Any solution / experience using Rijndael / AES between VB6 and NET ?   Or TripleDes....</p>

<p>thank you</p>

<p>UPDATE:  IMPORTANT: The machine where vb6 app runs, has not NET framework. So I cannot use Interop and/or a NET wrapper class exposed as COM. :( </p>
","<p>I just grabbed <a href=""http://code.google.com/p/slowaes"" rel=""nofollow noreferrer"">SlowAES</a>, a Javascript implementation of AES, and embedded it into a Windows Script Component, which makes it accessible via COM.  I was then able to call into the component from COM clients.  I didn't try VB6 because i don't have Visual Studio 6.  But for the COM clients I tried, I found the encryption to be completely compatible with .NET and the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""nofollow noreferrer"">RijndaelManaged</a>() class, when I use the same key, IV, mode, and keysize.</p>

<p>SlowAES is sort of limited; i didn't see an ECB mode for example.  But the stuff I tested is compatible with .NET. </p>

<p><a href=""http://cheeso.members.winisp.net/srcview.aspx?dir=AES-example"" rel=""nofollow noreferrer"">The source for the WSC file is available</a>. That source also includes a RFC2898-compliant PBKDF2 usable from VB6. So you can set the key from a password.  It is compatible with the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.aspx"" rel=""nofollow noreferrer"">Rfc2898DeriveBytes</a> class in .NET.  </p>

<p>See also, <a href=""https://stackoverflow.com/questions/270510/how-to-encrypt-in-vbscript-using-aes"">a related question</a>. </p>
","5233","<c#><vb6><aes><rijndaelmanaged><rijndael>","4","1","6","2011-07-05 14:25:11","","1","","95573","","2009-08-05 17:42:35","2009-04-15 13:44:55",""
"751759","Rijndael / AES from C# to VB6","<p>I need to encrypt a byte array in VB6 and decrypt it in C# (NET 2.0). And viceversa (C# to VB6).</p>

<p>In C# I used RijndaelManaged class. In VB6 I used free pieces of from Internet. The best seems to be <a href=""http://www.frez.co.uk/freecode.htm#rijndael"" rel=""nofollow noreferrer"">http://www.frez.co.uk/freecode.htm#rijndael</a>
But the two implementations generate different outputs starting from the same input  :(</p>

<p>Perhaps it's a problem with the IV vector in RijndaelManaged ... I don't understand...</p>

<p>Any solution / experience using Rijndael / AES between VB6 and NET ?   Or TripleDes....</p>

<p>thank you</p>

<p>UPDATE:  IMPORTANT: The machine where vb6 app runs, has not NET framework. So I cannot use Interop and/or a NET wrapper class exposed as COM. :( </p>
","<p>Take a look at :</p>

<p><a href=""http://www.frez.co.uk/freecode.htm"" rel=""nofollow noreferrer"">http://www.frez.co.uk/freecode.htm</a></p>
","5233","<c#><vb6><aes><rijndaelmanaged><rijndael>","4","0","6","2011-07-05 14:25:11","","1","","95573","","2009-08-05 17:42:35","2009-04-15 13:44:55",""
"751759","Rijndael / AES from C# to VB6","<p>I need to encrypt a byte array in VB6 and decrypt it in C# (NET 2.0). And viceversa (C# to VB6).</p>

<p>In C# I used RijndaelManaged class. In VB6 I used free pieces of from Internet. The best seems to be <a href=""http://www.frez.co.uk/freecode.htm#rijndael"" rel=""nofollow noreferrer"">http://www.frez.co.uk/freecode.htm#rijndael</a>
But the two implementations generate different outputs starting from the same input  :(</p>

<p>Perhaps it's a problem with the IV vector in RijndaelManaged ... I don't understand...</p>

<p>Any solution / experience using Rijndael / AES between VB6 and NET ?   Or TripleDes....</p>

<p>thank you</p>

<p>UPDATE:  IMPORTANT: The machine where vb6 app runs, has not NET framework. So I cannot use Interop and/or a NET wrapper class exposed as COM. :( </p>
","<p>VbCorLib now supports cryptography, included Rijndael.</p>

<p>It's free and .NET-like. Link: <a href=""http://vbcorlib.blogspot.com/"" rel=""nofollow"">http://vbcorlib.blogspot.com/</a></p>
","5233","<c#><vb6><aes><rijndaelmanaged><rijndael>","4","0","6","2011-07-05 14:25:11","","1","","95573","","2009-08-05 17:42:35","2009-04-15 13:44:55",""
"751759","Rijndael / AES from C# to VB6","<p>I need to encrypt a byte array in VB6 and decrypt it in C# (NET 2.0). And viceversa (C# to VB6).</p>

<p>In C# I used RijndaelManaged class. In VB6 I used free pieces of from Internet. The best seems to be <a href=""http://www.frez.co.uk/freecode.htm#rijndael"" rel=""nofollow noreferrer"">http://www.frez.co.uk/freecode.htm#rijndael</a>
But the two implementations generate different outputs starting from the same input  :(</p>

<p>Perhaps it's a problem with the IV vector in RijndaelManaged ... I don't understand...</p>

<p>Any solution / experience using Rijndael / AES between VB6 and NET ?   Or TripleDes....</p>

<p>thank you</p>

<p>UPDATE:  IMPORTANT: The machine where vb6 app runs, has not NET framework. So I cannot use Interop and/or a NET wrapper class exposed as COM. :( </p>
","<p>If you can do a simple C to C# conversion here is a nice solution. It works great with VB6/php and C. Have a look at <a href=""http://www.expertcore.org/viewtopic.php?f=49&amp;t=1816"" rel=""nofollow"">Encryption for C++, Visual Basic, php using PC1</a>.</p>
","5233","<c#><vb6><aes><rijndaelmanaged><rijndael>","4","0","6","2011-07-05 14:25:11","","1","","95573","","2009-08-05 17:42:35","2009-04-15 13:44:55",""
"6130989","Php Decrypt a String from C# .NET RIJNDAEL 256","<p>Fixed it.</p>

<pre><code>$data = base64_decode(str_replace(' ', '+', $_GET['data']));
</code></pre>

<p>for whatever reason, Php was converting the +'s from the GET variablesinto spaces</p>

<p>--</p>

<p>I am trying to decrypt a string that is being decrypted in C#.NET.</p>

<p>The results of the code vary, There were several occasions where the final string had some parts decrypted, and the rest of it was random characters.</p>

<p>Most of the time the ""decrypted"" string is just all random characters, I also tried some Php functions to remove PKCS7 padding but none of them fixed the problem.</p>

<p>I've looked at several similar questions on the site but none of them were of help.</p>

<p><strong>C#</strong></p>

<pre><code>// called as Response.Redirect(url + encryptParams(param));

private string encryptData(string data)
{
    Rijndael aes = Rijndael.Create();
    aes.KeySize = 256;
    aes.BlockSize = 256;
    aes.Mode = CipherMode.CBC;
    aes.Padding = PaddingMode.PKCS7;
    aes.Key = Convert.FromBase64String(""b0dJN2c6cklVUX1qUGlFfGMweXRKbH5fSEMuXjAgfQo="");

    ICryptoTransform crypto = aes.CreateEncryptor(aes.Key, aes.IV);
    byte[] txt = ASCIIEncoding.UTF8.GetBytes(data);          
    byte[] cipherText = crypto.TransformFinalBlock(txt, 0, txt.Length);

    return ""&amp;data="" + Convert.ToBase64String(cipherText) + ""&amp;iv="" + Convert.ToBase64String(aes.IV);
}
</code></pre>

<p><strong>Php:</strong></p>

<pre><code>   $data = base64_decode($_GET['data']);
   $iv = base64_decode($_GET['iv']);

   echo ""&lt;br /&gt;&lt;b&gt;IV&lt;/b&gt;: "" . $_GET['iv'] .
       ""&lt;br /&gt;&lt;b&gt;Encrypted String&lt;/b&gt;: &lt;br /&gt;&lt;textarea&gt;"".$_GET['data'].""&lt;/textarea&gt;"" .
       ""&lt;br /&gt;&lt;b&gt;key size:&lt;/b&gt; "" . mcrypt_get_key_size ( MCRYPT_RIJNDAEL_256,  MCRYPT_MODE_CBC) .
       ""&lt;br /&gt;&lt;b&gt;block size:&lt;/b&gt; "" . mcrypt_get_block_size ( MCRYPT_RIJNDAEL_256,  MCRYPT_MODE_CBC) .
       ""&lt;br /&gt;&lt;b&gt;cipher:&lt;/b&gt; "" . mcrypt_get_cipher_name ( MCRYPT_RIJNDAEL_256 ) .
       ""&lt;br /&gt;&lt;b&gt;iv size:&lt;/b&gt; "" .  mcrypt_get_iv_size  ( MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC) . ""&lt;br /&gt;""; 

   echo ""Result: "" . 
      mcrypt_decrypt
      (
          MCRYPT_RIJNDAEL_256,
          base64_decode(""b0dJN2c6cklVUX1qUGlFfGMweXRKbH5fSEMuXjAgfQo=""),
          $data,
          MCRYPT_MODE_CBC,
          $iv
       );
</code></pre>

<p><strong>Php output:</strong></p>

<p><strong>IV:</strong> WzsMlG39tfCGuX2EQM3vq8CoqGA xC0nW jICls8Cno=<br>
<strong>key</strong>: b0dJN2c6cklVUX1qUGlFfGMweXRKbH5fSEMuXjAgfQo=  </p>

<p><strong>Encrypted String:</strong>  oLxa21fxfQGg0EJ5rwMjEzMblvcaTq0AInDAsD88wAkNeLqOdon0ukLjz49Hpp36KPTKcTGkj1f7EPYPAAbuADnr3Ff0zpptZkx2d22VRbHrMgj QLF9vDxQRT3er3UAXsAfKKTyW8qeSIgrzACFLX3yoro/bzWic rt7ED7y0jZ7a1Hci3GMz/4KhwaftarbV QQWStJlSOqdxAdmtRRe84Vi3085S6um51bNrh5QzGRH PcpucfqaTb3junfO9g67j2JUQaM/Tj1EGnv6oX3wATR/LuWyhnhrCH86u10I=</p>

<p><strong>key size:</strong> 32<br>
<strong>block size:</strong> 32<br>
<strong>cipher:</strong> Rijndael-256<br>
<strong>iv size:</strong> 32<br>
<strong>Result:</strong>
/ci�����^/�c�g�������s��c�(��</p>

<p><strong>Original String (JSON):</strong>
{""user"":""jsmith"",""firstName"":""John"",""lastName"":""Smith"",""phone"":""12223334444.5555"",""email"":""john.smith@domain.com"",""address"":""123 Some Street"",""address2"":""apt 456"",""city"":""Some City"",""state"":""LA"",""zip"":""55555""}</p>
","<p>Fixed it by using the following code.</p>

<pre><code>$data = base64_decode(str_replace(' ', '+', $_GET['data']));
</code></pre>

<p>For whatever reason, PHP was converting the +'s from the GET variablesinto spaces.</p>
","5214","<c#><php><rijndael>","8","2","1","2014-05-12 14:27:10","6284157","7","2","474876","","2011-05-26 13:57:29","2011-05-25 21:11:23",""
"6672482","Encrypt and Decrypt xlsx, docx files using C# AES or Rijndael","<p>We encrypt all types of files using Rijndael encryption. Newer .xlsx and .docx files are throwing errors when trying to open (after encrypting and trying to decrypt). Error when Excel 2003 tries to open file: ""The converter failed to open the file"". I have Excel add on installed and when not using encryption/decryption I am able to open xlsx files in Excel 2003.  </p>

<p>I have changed out the code to use AES, with same type of issue (but in this case the file will not download, just sits there in the Firefox download list). I've read suggestions here to pay attention to byte size/lengths of encrypted/decrypted files but am at a loss as to how to fix this, I see that if I upload a xls file the length of the encrypted file going in is different from the decrypted file coming out and xls save and open fine, so I don't know how to test if this is the issue since these lenghts differ on files that do work. I am including the code to see if anyone can spot any issues that could be contributing to xlsx/docx file encryption errors. I've minimized the code, so if any syntax errors, is probably due to that.</p>

<p>I have installed Excel 2007 to see if the .xlsx files that are encrypted and decrypted will open in Excel 2007. When I attempt to open the file, I get a prompt:""Excel found unreadable content in 'myfile.xlsx'. Do you want to recover the contents of this workbook?"". Excel 2007 is able to recover/repair the file with message: ""Excel completed the file level validation and repair. Some parts of this workbook may have been repaired or discarded"". So, the encryption/decryption creates invalid file but Excel 2007 is able to repair this; Excel 2003 converter cannot do anything with the file.</p>

<pre><code>public byte [] Encrypt(byte [] bytes)
        {
            if (myRijndael == null)
                myRijndael = new RijndaelManaged();
            ICryptoTransform encryptor = myRijndael.CreateEncryptor(key, IV);
            MemoryStream msEncrypt = new MemoryStream();
            CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
            csEncrypt.Write(bytes, 0, bytes.Length);
            csEncrypt.FlushFinalBlock();
            return msEncrypt.ToArray();
        }

public byte [] Decrypt(byte [] encrypted, string text)
        {
            if (myRijndael == null)
{
                    myRijndael = new RijndaelManaged();
}
            ICryptoTransform decryptor = myRijndael.CreateDecryptor(key, IV);
            MemoryStream msDecrypt = new MemoryStream(encrypted);
            CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
            byte [] fromEncrypt = new byte[encrypted.Length];
csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);
            return fromEncrypt;
}


Usage:
ENCRYPT:
ClcCrypto crypt; // Our class for saving keys etc.
ClcCrypto(CLC.WebUtil.ClcCrypto.GetDecryptionKey(), Group.IV);
BinaryReader br = new BinaryReader(NewFile);// NewFile is Stream from filMyFile.PostedFile.InputStream
byte[] EncryptedContents = crypt.Encrypt(br.ReadBytes((int)NewFile.Length));
FileStream fs = File.Create(DestFileName);
BinaryWriter bw = new BinaryWriter(fs);
bw.Write(EncryptedContents);
bw.Close();
fs.Close();
br.Close();

DECRYPT (file download):
byte[] baOut = null;
baOut = fiOut.GetFileData(out lLength); // See below for method
Response.AddHeader(""content-disposition"", ""attachment; filename="" + FileName));
Response.ContentType = fiOut.MimeType;
Response.AddHeader(""content-length"", lLength.ToString());
Response.BinaryWrite(baOut);
Response.End();

public byte[] GetFileData(out long intFileSize)
{
FileStream fsOut = new FileStream(FilePath, FileMode.Open, FileAccess.Read);
      intFileSize = fsOut.Length;
      byte[] Buffer = null;
      ClcCrypto crypt;
      crypt = new CLC.WebUtil.ClcCrypto(CLC.WebUtil.ClcCrypto.GetDecryptionKey(), IV);
      BinaryReader br = new BinaryReader(fsOut);
      Buffer = crypt.Decrypt(br.ReadBytes((int)fsOut.Length), null);
      br.Close();
      fsOut.Close();
      return Buffer;
}
</code></pre>
","<p>If the padding is of concern, here is something for you:</p>

<p><a href=""https://stackoverflow.com/questions/3962900/how-do-i-encrypt-a-string-in-vb-net-using-rijndaelmanaged-and-using-pkcs5-paddin/3962945#3962945"">How do I encrypt a string in vb.net using RijndaelManaged, and using PKCS5 padding?</a></p>
","5115","<c#><encryption><aes><xlsx><rijndael>","0","0","2","2011-07-13 18:19:29","","0","","638303","","2011-07-13 17:54:18","2011-07-12 23:36:09",""
"6672482","Encrypt and Decrypt xlsx, docx files using C# AES or Rijndael","<p>We encrypt all types of files using Rijndael encryption. Newer .xlsx and .docx files are throwing errors when trying to open (after encrypting and trying to decrypt). Error when Excel 2003 tries to open file: ""The converter failed to open the file"". I have Excel add on installed and when not using encryption/decryption I am able to open xlsx files in Excel 2003.  </p>

<p>I have changed out the code to use AES, with same type of issue (but in this case the file will not download, just sits there in the Firefox download list). I've read suggestions here to pay attention to byte size/lengths of encrypted/decrypted files but am at a loss as to how to fix this, I see that if I upload a xls file the length of the encrypted file going in is different from the decrypted file coming out and xls save and open fine, so I don't know how to test if this is the issue since these lenghts differ on files that do work. I am including the code to see if anyone can spot any issues that could be contributing to xlsx/docx file encryption errors. I've minimized the code, so if any syntax errors, is probably due to that.</p>

<p>I have installed Excel 2007 to see if the .xlsx files that are encrypted and decrypted will open in Excel 2007. When I attempt to open the file, I get a prompt:""Excel found unreadable content in 'myfile.xlsx'. Do you want to recover the contents of this workbook?"". Excel 2007 is able to recover/repair the file with message: ""Excel completed the file level validation and repair. Some parts of this workbook may have been repaired or discarded"". So, the encryption/decryption creates invalid file but Excel 2007 is able to repair this; Excel 2003 converter cannot do anything with the file.</p>

<pre><code>public byte [] Encrypt(byte [] bytes)
        {
            if (myRijndael == null)
                myRijndael = new RijndaelManaged();
            ICryptoTransform encryptor = myRijndael.CreateEncryptor(key, IV);
            MemoryStream msEncrypt = new MemoryStream();
            CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
            csEncrypt.Write(bytes, 0, bytes.Length);
            csEncrypt.FlushFinalBlock();
            return msEncrypt.ToArray();
        }

public byte [] Decrypt(byte [] encrypted, string text)
        {
            if (myRijndael == null)
{
                    myRijndael = new RijndaelManaged();
}
            ICryptoTransform decryptor = myRijndael.CreateDecryptor(key, IV);
            MemoryStream msDecrypt = new MemoryStream(encrypted);
            CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
            byte [] fromEncrypt = new byte[encrypted.Length];
csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);
            return fromEncrypt;
}


Usage:
ENCRYPT:
ClcCrypto crypt; // Our class for saving keys etc.
ClcCrypto(CLC.WebUtil.ClcCrypto.GetDecryptionKey(), Group.IV);
BinaryReader br = new BinaryReader(NewFile);// NewFile is Stream from filMyFile.PostedFile.InputStream
byte[] EncryptedContents = crypt.Encrypt(br.ReadBytes((int)NewFile.Length));
FileStream fs = File.Create(DestFileName);
BinaryWriter bw = new BinaryWriter(fs);
bw.Write(EncryptedContents);
bw.Close();
fs.Close();
br.Close();

DECRYPT (file download):
byte[] baOut = null;
baOut = fiOut.GetFileData(out lLength); // See below for method
Response.AddHeader(""content-disposition"", ""attachment; filename="" + FileName));
Response.ContentType = fiOut.MimeType;
Response.AddHeader(""content-length"", lLength.ToString());
Response.BinaryWrite(baOut);
Response.End();

public byte[] GetFileData(out long intFileSize)
{
FileStream fsOut = new FileStream(FilePath, FileMode.Open, FileAccess.Read);
      intFileSize = fsOut.Length;
      byte[] Buffer = null;
      ClcCrypto crypt;
      crypt = new CLC.WebUtil.ClcCrypto(CLC.WebUtil.ClcCrypto.GetDecryptionKey(), IV);
      BinaryReader br = new BinaryReader(fsOut);
      Buffer = crypt.Decrypt(br.ReadBytes((int)fsOut.Length), null);
      br.Close();
      fsOut.Close();
      return Buffer;
}
</code></pre>
","<p>Sounds like a truncation issue; possibly because of the way you're creating the memory stream; when I decrypt it looks like the following</p>

<pre><code>MemoryStream msDecrypt = new MemoryStream();
CryptoStream csDecrypt = new CryptoStream(
    msDecrypt, 
    decryptor, 
    CryptoStreamMode.Write);
csStream.Write(encrypted, 0, encrypted.Length);
csStream.Flush();
return csDecrypt.ToArray();
</code></pre>

<p>I'd guess that there are extra null bytes being appended, and using the alternate approach may alleviate this.</p>
","5115","<c#><encryption><aes><xlsx><rijndael>","0","0","2","2011-07-13 18:19:29","","0","","638303","","2011-07-13 17:54:18","2011-07-12 23:36:09",""
"27244449","Crypto++ pbkdf2 output is different than Rfc2898DeriveBytes (C#) and crypto.pbkdf2 (JavaScript)","<p>So I'm trying to use PBKDF2 to derive a key given a base64 string of 256bits. I am able to use C#'s Rfc2898DeriveBytes and node-crypto's pbkdf2 to derive the same key, however, I can't say the same for C++. I'm not sure if I'm doing wrong conversions or using the functions improperly, but I'll let you guys look at it.</p>

<p>C++</p>

<pre><code>/* 256bit key */
string key = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ="";
string decodedKey;
StringSource(key, true, new Base64Decoder(new StringSink(decodedKey)));
const byte* keyByte = (const byte*) decodedKey.data();

/* Generate IV */
/*
    AutoSeededRandomPool prng;
    byte iv[AES::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
*/

/* FOR TESTING PURPOSES, HARDCODE IV */
string iv = ""5iFv54dCRq5icQbD7QHQzg=="";
string decodedIv;
StringSource(iv, true, new Base64Decoder(new StringSink(decodedIv)));
const byte* ivByte = (const byte *) decodedIv.data();

byte derivedKey[32];
PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf2;
pbkdf2.DeriveKey(derivedKey, 32, 0, keyByte, 32, ivByte, 16, 100);

/* 
 * derivedKey: 9tRyXCoQLTbUOLqm3M4OPGT6N25g+o0K090fVp/hflk=
 */
</code></pre>

<p>C#</p>

<pre><code>// string key = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ=""; // need to convert it to byte data
string key = Convert.FromBase64String(""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ=""); // change above to this
RijndaelManaged symKey = new RijndaelManaged();
symKey.GenerateIV(); /* Assume hardcoded IV same as above */
Rfc2898DeriveBytes derivedKey = new Rfc2898DeriveBytes (key, symKey.IV, 100);

/*
 * derivedKey: dZqBpZKyUPKn8pU4pyyeAw7Rg8uYd6yyj3WI1MIJSyc=
 */
</code></pre>

<p>JS</p>

<pre><code>// var key = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ=""; // need to convert it to byte data
var key = new Buffer(""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ="", ""base64""); // changed above to this
var iv = crypto.randomBytes(16);
iv = ""5iFv54dCRq5icQbD7QHQzg==""; /* HARDCODE IV */
crypto.pbkdf2(key, iv, 100, 32, function(err, derivedKey) { }

/*
 * derivedKey: dZqBpZKyUPKn8pU4pyyeAw7Rg8uYd6yyj3WI1MIJSyc=
 */
</code></pre>

<blockquote>
  <p>Well the main questions is, what am I doing wrong on C++'s CryptoPP
  library that it is not deriving the same value.</p>
</blockquote>

<p><strong>SOLUTION: I was being dumb... I realized after review my original implementation on JavaScript and C# I missed a crucial step that for some reason I did not get a complain from the compiler. Basically the problem was that I did not convert the key used into byte data before the algorithm on my C# and JS implementation...</strong></p>

<p><strong>Anyways, proposed solution is: do not code at 4 AM and make sure to be consistent on your data conversion...</strong></p>

<p><strong>I guess the TL;DR of this is that C# and JS was converting my 256bit key to byte data as ASCII instead of base64 conversion.</strong></p>
","<blockquote>
  <p>Well the main questions is, what am I doing wrong on C++'s CryptoPP library that it is not deriving the same value.</p>
</blockquote>

<p>Well, I don't think you are doing anything wrong in C++ with Crypto++ and PBKDF2. I think the other libraries are setting up the parameters differently, or they are a tad-bit non-standard.</p>

<p>I was able to arrive at the IETF's <a href=""http://www.ietf.org/rfc/rfc6070.txt"" rel=""nofollow"">test vectors for PBKDF2</a> using Crypto++:</p>

<pre><code>// From https://www.ietf.org/rfc/rfc6070.txt
//   PKCS #5: Password-Based Key Derivation Function 2 (PBKDF2) Test Vectors
//
//      Input:
//       P = ""password"" (8 octets)
//       S = ""salt"" (4 octets)
//       c = 1
//       dkLen = 20
//
//     Output:
//       DK = 0c 60 c8 0f 96 1f 0e 71
//            f3 a9 b5 24 af 60 12 06
//            2f e0 37 a6    (20 octets)

int main(int argc, char* argv[])
{
    byte password[] =""password"";
    size_t plen = strlen((const char*)password);

    byte salt[] = ""salt"";
    size_t slen = strlen((const char*)salt);

    int c = 1;
    byte derived[20];

    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf2;
    pbkdf2.DeriveKey(derived, sizeof(derived), 0, password, plen, salt, slen, c);

    string result;
    HexEncoder encoder(new StringSink(result));

    encoder.Put(derived, sizeof(derived));
    encoder.MessageEnd();

    cout &lt;&lt; ""Derived: "" &lt;&lt; result &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>And a run of the program:</p>

<pre><code>$ ./cryptopp-test.exe
Derived: 0C60C80F961F0E71F3A9B524AF6012062FE037A6
</code></pre>

<hr>

<p>I think the first thing you should do is verify the C# and Javascript implementations are using the same character encoding as Crypto++ and the IETF.</p>

<p>If that's not it, then check to see if C# and Javascript use the purpose byte. Crypto++ does not, and you can see the implementation at <a href=""http://www.cryptopp.com/docs/ref/pwdbased_8h_source.html"" rel=""nofollow"">pwdbased.h</a>.</p>

<hr>

<p>Unfortunately, I get something a little different when I dial in your parameters:</p>

<pre><code>int main(int argc, char* argv[])
{
    string t1 = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ="";
    string t2 = ""5iFv54dCRq5icQbD7QHQzg=="";

    string pw, iv;

    Base64Decoder b1(new StringSink(pw));
    b1.Put((const byte*)t1.data(), t1.size());
    b1.MessageEnd();

    Base64Decoder b2(new StringSink(iv));
    b2.Put((const byte*)t2.data(), t2.size());
    b2.MessageEnd();

    int c = 100;
    byte derived[32];

    cout &lt;&lt; ""pw size: "" &lt;&lt; pw.size() &lt;&lt; endl;
    cout &lt;&lt; ""iv size: "" &lt;&lt; iv.size() &lt;&lt; endl;

    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf2;
    pbkdf2.DeriveKey(derived, sizeof(derived), 0, (byte*)pw.data(), pw.size(), (byte*)iv.data(), iv.size(), c);

    string result;
    HexEncoder encoder(new StringSink(result));

    encoder.Put(derived, sizeof(derived));
    encoder.MessageEnd();

    cout &lt;&lt; ""Derived: "" &lt;&lt; result &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>A run results in:</p>

<pre><code>$ ./cryptopp-test.exe
pw size: 32
iv size: 16
Derived: F6D4725C2A102D36D438BAA6DCCE0E3C64FA376E60FA8D0AD3DD1F569FE17E59
</code></pre>
","5077","<c++><rijndael><crypto++><pbkdf2><hmacsha1>","6","3","1","2019-07-08 07:41:42","27261798","2","1","4314646","","2014-12-03 09:20:24","2014-12-02 07:58:32",""
"10661357","How to convert string key and IV to byte arrays for Rijndael","<p>The documentation says ""If you use the following values, then you will get this result"".</p>

<blockquote>
  <p><strong>Block Size:</strong> 128 
  <strong>Cipher Mode:</strong> CBC 
  <strong>Padding Mode:</strong> Zeros</p>
</blockquote>

<p><strong>Key:</strong> BTikvHBatPdAtgT3317QIQqGFY25WpIz</p>

<p><strong>IV:</strong> a5Sg4U9m11Mw2tIZ</p>

<p><strong>Value to be encyrpted:</strong> 2008-06-02 13:28:45,Statements,1234567,,06/01/2008,06/01/2008,0</p>

<p>And this how the encryption result should look like after all these values are used according the developer guides.</p>

<blockquote>
  <p>b97f3985245be1065604c5808cebaa2e15813bf938cfaa3c198fd464565c13ced7c91ac6
  b68326ce5ed5e81cb7de81acb9fcd1b1636127efbac3203da5bdccea</p>
</blockquote>

<p>However, I cannot get this result for some reason, this is the code I used to populate this result but it gives me same characters at first and later on the characters changes as you may see in the result at very bottom of this question.</p>

<p>This is the code and below is the new output:</p>

<pre><code>public static void Main(string[] args)
{
  RijndaelManaged rij = new RijndaelManaged();
  rij.Mode = CipherMode.CBC;
  rij.Padding = PaddingMode.Zeros;
  rij.Key = ASCIIEncoding.UTF8.GetBytes(""BTikvHBatPdAtgT3317QIQqGFY25WpIz"");
  rij.IV = ASCIIEncoding.UTF8.GetBytes(""a5Sg4U9m11Mw2tIZ"");
  ICryptoTransform transform = rij.CreateEncryptor();

  byte[] data = Encoding.ASCII.GetBytes(""2008-06-02 13:28:45,Statements,1234567,,06/01/2008,06/01/2008,0"");
  byte[] result = transform.TransformFinalBlock(data, 0, data.Length);
  Console.WriteLine(ByteArrayToString(result));
}

public static string ByteArrayToString(byte[] ba)
{
  StringBuilder hex = new StringBuilder(ba.Length * 2);
  foreach (byte b in ba)
    hex.AppendFormat(""{0:x2}"", b);
  return hex.ToString();
}
</code></pre>

<p>My output :</p>

<blockquote>
  <p>b97f3985245be1065604c5808cebaa2e15813bf938cfaa3c198fd464565c13ced7c91ac6b68326ce5ed5e81cb7de81ac</p>
</blockquote>

<p>Note: I needed to update the question as I advanced and found a better solution but the new problem has arose right now.</p>
","<p>This key and IV you have look like base64 encoding...</p>

<pre><code>rij.Key = Convert.FromBase64String(""BTikvHBatPdAtgT3317QIQqGFY25WpIz"");
rij.IV = Convert.FromBase64String(""a5Sg4U9m11Mw2tIZ"");
</code></pre>
","4981","<c#><.net><rijndael>","2","2","2","2012-05-19 15:34:17","10661401","0","","44852","","2012-05-19 04:19:41","2012-05-19 00:34:17",""
"10661357","How to convert string key and IV to byte arrays for Rijndael","<p>The documentation says ""If you use the following values, then you will get this result"".</p>

<blockquote>
  <p><strong>Block Size:</strong> 128 
  <strong>Cipher Mode:</strong> CBC 
  <strong>Padding Mode:</strong> Zeros</p>
</blockquote>

<p><strong>Key:</strong> BTikvHBatPdAtgT3317QIQqGFY25WpIz</p>

<p><strong>IV:</strong> a5Sg4U9m11Mw2tIZ</p>

<p><strong>Value to be encyrpted:</strong> 2008-06-02 13:28:45,Statements,1234567,,06/01/2008,06/01/2008,0</p>

<p>And this how the encryption result should look like after all these values are used according the developer guides.</p>

<blockquote>
  <p>b97f3985245be1065604c5808cebaa2e15813bf938cfaa3c198fd464565c13ced7c91ac6
  b68326ce5ed5e81cb7de81acb9fcd1b1636127efbac3203da5bdccea</p>
</blockquote>

<p>However, I cannot get this result for some reason, this is the code I used to populate this result but it gives me same characters at first and later on the characters changes as you may see in the result at very bottom of this question.</p>

<p>This is the code and below is the new output:</p>

<pre><code>public static void Main(string[] args)
{
  RijndaelManaged rij = new RijndaelManaged();
  rij.Mode = CipherMode.CBC;
  rij.Padding = PaddingMode.Zeros;
  rij.Key = ASCIIEncoding.UTF8.GetBytes(""BTikvHBatPdAtgT3317QIQqGFY25WpIz"");
  rij.IV = ASCIIEncoding.UTF8.GetBytes(""a5Sg4U9m11Mw2tIZ"");
  ICryptoTransform transform = rij.CreateEncryptor();

  byte[] data = Encoding.ASCII.GetBytes(""2008-06-02 13:28:45,Statements,1234567,,06/01/2008,06/01/2008,0"");
  byte[] result = transform.TransformFinalBlock(data, 0, data.Length);
  Console.WriteLine(ByteArrayToString(result));
}

public static string ByteArrayToString(byte[] ba)
{
  StringBuilder hex = new StringBuilder(ba.Length * 2);
  foreach (byte b in ba)
    hex.AppendFormat(""{0:x2}"", b);
  return hex.ToString();
}
</code></pre>

<p>My output :</p>

<blockquote>
  <p>b97f3985245be1065604c5808cebaa2e15813bf938cfaa3c198fd464565c13ced7c91ac6b68326ce5ed5e81cb7de81ac</p>
</blockquote>

<p>Note: I needed to update the question as I advanced and found a better solution but the new problem has arose right now.</p>
","<p>You were talking about weird characters in your output - actually, the output you posted is hex encoding, so you should try to encode yours to hex, too, as explained <a href=""https://stackoverflow.com/questions/311165/how-do-you-convert-byte-array-to-hexadecimal-string-and-vice-versa-in-c"">here</a>.</p>

<p>Edit:</p>

<p>I figured it out now. You need to additionally <code>Close()</code> either the stream or the writer - in CBC mode, this is needed to finalize the padding on the last block, if it is omitted then the last block will not be output. Next problem is that if you do this, then you will still end up with a slightly different output than the one expected in your example. Here's why: if you decrypt your example ciphertext, you will get:</p>

<pre><code>2008-06-02 13:28:45,Statements,1234567,,06/01/2007,06/01/2007,0
</code></pre>

<p>It differs from your plaintext in that there's a 2007 at the end where you have 2008. If you fix this and properly close the stream then you will finally receive exactly the same output as in the example.</p>
","4981","<c#><.net><rijndael>","2","2","2","2012-05-19 15:34:17","10661401","0","","44852","","2012-05-19 04:19:41","2012-05-19 00:34:17",""
"9011635","How do I convert this C# Rijndael encryption to PHP?","<p>There are already some helpful questions on SO:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/3431950/rijndael-256-encrypt-decrypt-between-c-sharp-and-php"">Rijndael 256 Encrypt/decrypt between c# and php?</a></li>
<li><a href=""https://stackoverflow.com/questions/3505453/rewrite-rijndael-256-c-sharp-encryption-code-in-php"">Rewrite Rijndael 256 C# Encryption Code in PHP</a></li>
<li><a href=""https://stackoverflow.com/questions/8411177/rijndael-aes-decryption-c-sharp-to-php-conversion"">Rijndael/AES decryption C# to PHP conversion</a></li>
</ul>

<p>However I am still having difficulties with my particular case.</p>

<p>I've tried various methods but end up getting the error <code>""The IV parameter must be as long as the blocksize""</code> or text that doesn't match the resulting hash.</p>

<p>I don't understand encryption enough to work out what I'm doing wrong.</p>

<p>Here is the php version:</p>

<pre><code>$pass = 'hello';
$salt = 'application-salt';

echo Encrypt('hello', 'application-salt');

function Encrypt($pass, $salt)
{
    $derived = PBKDF1($pass, $salt, 100, 16);
    $key = bin2hex(substr($derived, 0, 8));
    $iv = bin2hex(substr($derived, 8, 8));
    return mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $pass, MCRYPT_MODE_CBC, $iv);
}

function PBKDF1($pass, $salt, $count, $dklen)
{
    $t = $pass.$salt;
    $t = sha1($t, true);
    for($i=2; $i &lt;= $count; $i++)
    {
        $t = sha1($t, true);
    }
    $t = substr($t,0,$dklen-1);
    return $t;
}
</code></pre>

<p>And the C# version:</p>

<pre><code>Console.WriteLine(Encrypt(""hello"", ""application-salt""));
// output: ""Hk4he+qKGsO5BcL2HDtbkA==""

public static string Encrypt(string clearText, string Password)
{
    byte[] clearData = System.Text.Encoding.Unicode.GetBytes(clearText);
    PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
        new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });

    MemoryStream ms = new MemoryStream();
    Rijndael alg = Rijndael.Create();
    alg.Key = pdb.GetBytes(32);
    alg.IV = pdb.GetBytes(16);
    CryptoStream cs = new CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write);
    cs.Write(clearData, 0, clearData.Length);
    cs.Close();
    byte[] encryptedData = ms.ToArray();

    return Convert.ToBase64String(encryptedData);
}
</code></pre>

<p>I want to be able to validate user logins in a new php-based application which will communicate to the same MySQL database as an existing C# application. I intend to encrypt the password and compare the resulting hash to the one stored in the database to authenticate.</p>

<p>Any pointers would be most appreciated.</p>

<p><strong>Edit:</strong></p>

<p>I realize that in the C# function, the <code>PasswordDeriveBytes</code> is being called and passed a byte array as an argument for which I don't have an analog in the PHP version. I discovered that this originates from a <a href=""http://www.codeproject.com/KB/security/DotNetCrypto.aspx?msg=1790665"" rel=""nofollow noreferrer"">Codeproject example</a> and that the byte array in ASCII spells ""Ivan Medvedev"" whom I assume to be the example author. Unfortunately I cannot change this.</p>
","<p>PHP already has this capability built into its Mcrypt module.</p>

<p>Try this: <a href=""http://www.php.net/manual/en/book.mcrypt.php"" rel=""nofollow"">http://www.php.net/manual/en/book.mcrypt.php</a></p>
","4837","<c#><php><encryption><rijndael>","3","-1","3","2018-03-12 09:59:21","9012662","1","1","-1","","2017-05-23 11:51:45","2012-01-25 22:55:58",""
"9011635","How do I convert this C# Rijndael encryption to PHP?","<p>There are already some helpful questions on SO:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/3431950/rijndael-256-encrypt-decrypt-between-c-sharp-and-php"">Rijndael 256 Encrypt/decrypt between c# and php?</a></li>
<li><a href=""https://stackoverflow.com/questions/3505453/rewrite-rijndael-256-c-sharp-encryption-code-in-php"">Rewrite Rijndael 256 C# Encryption Code in PHP</a></li>
<li><a href=""https://stackoverflow.com/questions/8411177/rijndael-aes-decryption-c-sharp-to-php-conversion"">Rijndael/AES decryption C# to PHP conversion</a></li>
</ul>

<p>However I am still having difficulties with my particular case.</p>

<p>I've tried various methods but end up getting the error <code>""The IV parameter must be as long as the blocksize""</code> or text that doesn't match the resulting hash.</p>

<p>I don't understand encryption enough to work out what I'm doing wrong.</p>

<p>Here is the php version:</p>

<pre><code>$pass = 'hello';
$salt = 'application-salt';

echo Encrypt('hello', 'application-salt');

function Encrypt($pass, $salt)
{
    $derived = PBKDF1($pass, $salt, 100, 16);
    $key = bin2hex(substr($derived, 0, 8));
    $iv = bin2hex(substr($derived, 8, 8));
    return mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $pass, MCRYPT_MODE_CBC, $iv);
}

function PBKDF1($pass, $salt, $count, $dklen)
{
    $t = $pass.$salt;
    $t = sha1($t, true);
    for($i=2; $i &lt;= $count; $i++)
    {
        $t = sha1($t, true);
    }
    $t = substr($t,0,$dklen-1);
    return $t;
}
</code></pre>

<p>And the C# version:</p>

<pre><code>Console.WriteLine(Encrypt(""hello"", ""application-salt""));
// output: ""Hk4he+qKGsO5BcL2HDtbkA==""

public static string Encrypt(string clearText, string Password)
{
    byte[] clearData = System.Text.Encoding.Unicode.GetBytes(clearText);
    PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
        new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });

    MemoryStream ms = new MemoryStream();
    Rijndael alg = Rijndael.Create();
    alg.Key = pdb.GetBytes(32);
    alg.IV = pdb.GetBytes(16);
    CryptoStream cs = new CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write);
    cs.Write(clearData, 0, clearData.Length);
    cs.Close();
    byte[] encryptedData = ms.ToArray();

    return Convert.ToBase64String(encryptedData);
}
</code></pre>

<p>I want to be able to validate user logins in a new php-based application which will communicate to the same MySQL database as an existing C# application. I intend to encrypt the password and compare the resulting hash to the one stored in the database to authenticate.</p>

<p>Any pointers would be most appreciated.</p>

<p><strong>Edit:</strong></p>

<p>I realize that in the C# function, the <code>PasswordDeriveBytes</code> is being called and passed a byte array as an argument for which I don't have an analog in the PHP version. I discovered that this originates from a <a href=""http://www.codeproject.com/KB/security/DotNetCrypto.aspx?msg=1790665"" rel=""nofollow noreferrer"">Codeproject example</a> and that the byte array in ASCII spells ""Ivan Medvedev"" whom I assume to be the example author. Unfortunately I cannot change this.</p>
","<p>I think that the PHP version may actually add 00h valued bytes to the key and IV. They both have an invalid size : 8 bytes for each. They need to be extended to 16 bytes for AES-128. In your C# code you use 32 bytes for the key, which will therefore use AES with a <em>key size</em> of 256 bits.</p>

<p>Futhermore, you don't specify the number of iterations in <code>PasswordDeriveBytes</code>, you should specify it as the class does not specify the default number of iterations - according to your comments, this would be 100, lets assume it is.</p>

<p>Oh, and you use the incorrect encryption method. MCRYPT_RIJNDAEL_256 specifies the Rijndael algorithm using a <em>blocksize</em> of 256 bits, not <em>keys</em> of 256 bits. Presumably, the bitsize of the keys is simply the number of bytes of the key times 8.</p>

<p>Could you replace your Encrypt function with this and try again?</p>

<pre><code>function Encrypt($pass, $salt)
{
     $derived = PBKDF1($pass, $salt, 100, 48);
     $key = bin2hex(substr($derived, 0, 32));
     $iv = bin2hex(substr($derived, 32, 16));
     return mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $pass, MCRYPT_MODE_CBC, $iv);
}
</code></pre>

<p>Finally, please check if the generated IV and key match with the ones in PHP before performing encryption or decryption. Are you sure that that PHP PBKDF1 function is correct?</p>

<p>UPDATE:
<a href=""http://bouncy-castle.1462172.n4.nabble.com/NET-PasswordDeriveBytes-td1462616.html"" rel=""nofollow"">Here</a> is some more information on the M$ PBKDF1 routines in PasswordDeriveBytes (including Java code which you may try and convert):</p>

<blockquote>
  <p>ha, I see your point.</p>
  
  <p>Interestingly, using .NET: the results are different when calling 48
  or calling 32 followed by 16:</p>
  
  <p>.NET GetBytes( 32 +16 ):
  04DD9D139DCB9DE889946D3662B319682159FF9C9B47FA15ED205C7CAF890922655D8DD89AE1CAAC60A8041FCD7E8DA4</p>
  
  <p>.NET GetBytes( 32 )
  04DD9D139DCB9DE889946D3662B319682159FF9C9B47FA15ED205C7CAF890922
  Followed by GetBytes( 16 ) 89946D3662B3196860A8041FCD7E8DA4</p>
</blockquote>

<p>True Microsoft code, and they cannot change it because it could break applications in the field. Note that they also would return different results when calling it with 16 and then 8 bytes or directly by 24 bytes <em>by design</em>. You'd better upgrade to PBKDF2, and keep PBKDF1 limited to 20 bytes max, as defined in the standards.</p>
","4837","<c#><php><encryption><rijndael>","3","2","3","2018-03-12 09:59:21","9012662","1","1","-1","","2017-05-23 11:51:45","2012-01-25 22:55:58",""
"9011635","How do I convert this C# Rijndael encryption to PHP?","<p>There are already some helpful questions on SO:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/3431950/rijndael-256-encrypt-decrypt-between-c-sharp-and-php"">Rijndael 256 Encrypt/decrypt between c# and php?</a></li>
<li><a href=""https://stackoverflow.com/questions/3505453/rewrite-rijndael-256-c-sharp-encryption-code-in-php"">Rewrite Rijndael 256 C# Encryption Code in PHP</a></li>
<li><a href=""https://stackoverflow.com/questions/8411177/rijndael-aes-decryption-c-sharp-to-php-conversion"">Rijndael/AES decryption C# to PHP conversion</a></li>
</ul>

<p>However I am still having difficulties with my particular case.</p>

<p>I've tried various methods but end up getting the error <code>""The IV parameter must be as long as the blocksize""</code> or text that doesn't match the resulting hash.</p>

<p>I don't understand encryption enough to work out what I'm doing wrong.</p>

<p>Here is the php version:</p>

<pre><code>$pass = 'hello';
$salt = 'application-salt';

echo Encrypt('hello', 'application-salt');

function Encrypt($pass, $salt)
{
    $derived = PBKDF1($pass, $salt, 100, 16);
    $key = bin2hex(substr($derived, 0, 8));
    $iv = bin2hex(substr($derived, 8, 8));
    return mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $pass, MCRYPT_MODE_CBC, $iv);
}

function PBKDF1($pass, $salt, $count, $dklen)
{
    $t = $pass.$salt;
    $t = sha1($t, true);
    for($i=2; $i &lt;= $count; $i++)
    {
        $t = sha1($t, true);
    }
    $t = substr($t,0,$dklen-1);
    return $t;
}
</code></pre>

<p>And the C# version:</p>

<pre><code>Console.WriteLine(Encrypt(""hello"", ""application-salt""));
// output: ""Hk4he+qKGsO5BcL2HDtbkA==""

public static string Encrypt(string clearText, string Password)
{
    byte[] clearData = System.Text.Encoding.Unicode.GetBytes(clearText);
    PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
        new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });

    MemoryStream ms = new MemoryStream();
    Rijndael alg = Rijndael.Create();
    alg.Key = pdb.GetBytes(32);
    alg.IV = pdb.GetBytes(16);
    CryptoStream cs = new CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write);
    cs.Write(clearData, 0, clearData.Length);
    cs.Close();
    byte[] encryptedData = ms.ToArray();

    return Convert.ToBase64String(encryptedData);
}
</code></pre>

<p>I want to be able to validate user logins in a new php-based application which will communicate to the same MySQL database as an existing C# application. I intend to encrypt the password and compare the resulting hash to the one stored in the database to authenticate.</p>

<p>Any pointers would be most appreciated.</p>

<p><strong>Edit:</strong></p>

<p>I realize that in the C# function, the <code>PasswordDeriveBytes</code> is being called and passed a byte array as an argument for which I don't have an analog in the PHP version. I discovered that this originates from a <a href=""http://www.codeproject.com/KB/security/DotNetCrypto.aspx?msg=1790665"" rel=""nofollow noreferrer"">Codeproject example</a> and that the byte array in ASCII spells ""Ivan Medvedev"" whom I assume to be the example author. Unfortunately I cannot change this.</p>
","<p>Below snippet may be helpful who are looking for exact conversion from C# to PHP </p>

<pre><code>&lt;?php
    class Foo {
      protected $mcrypt_cipher = MCRYPT_RIJNDAEL_128;
      protected $mcrypt_mode = MCRYPT_MODE_CBC;

      public function decrypt($key, $iv, $encrypted)
      {
        return mcrypt_decrypt($this-&gt;mcrypt_cipher, $key, base64_decode($encrypted), $this-&gt;mcrypt_mode, $iv);
      }

      public function encrypt($key, $iv, $password)
      {
        $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
          $padding = $block - (strlen($password) % $block);
          $password .= str_repeat(chr($padding), $padding);
        return mcrypt_encrypt($this-&gt;mcrypt_cipher, $key, $password, $this-&gt;mcrypt_mode, $iv);
      }
    }
    $foo = new Foo;
    $pass = 'p@ss';
    $salt = 's@1t';

    $key = PBKDF1($pass, $salt, 2, 32);

    $iv = ""@1B2c3D4e5F6g7H8"";

    $encrypted = $foo-&gt;encrypt($key,$iv,'test@123');

    $encrypted = base64_encode($encrypted);

    echo 'Encrypted: '.$encrypted.'&lt;/br&gt;';
    echo 'Decrypted: '.$foo-&gt;decrypt($key, $iv, $encrypted);



    function PBKDF1($pass, $salt, $count, $cb)
    {
      static $base;
      static $extra;
      static $extracount= 0;
      static $hashno;
      static $state = 0;

      if ($state == 0)
      {
        $hashno = 0;
        $state = 1;

        $key = $pass . $salt;
        $base = sha1($key, true);
        for($i = 2; $i &lt; $count; $i++)
        {
          $base = sha1($base, true);
        }
      }

      $result = """";

      if ($extracount &gt; 0)
      {
        $rlen = strlen($extra) - $extracount;
        if ($rlen &gt;= $cb)
        {
          $result = substr($extra, $extracount, $cb);
          if ($rlen &gt; $cb)
          {
            $extracount += $cb;
          }
          else
          {
            $extra = null;
            $extracount = 0;
          }
          return $result;
        }
        $result = substr($extra, $rlen, $rlen);
      }

      $current = """";
      $clen = 0;
      $remain = $cb - strlen($result);
      while ($remain &gt; $clen)
      {
        if ($hashno == 0)
        {
          $current = sha1($base, true);
        }
        else if ($hashno &lt; 1000)
        {
          $n = sprintf(""%d"", $hashno);
          $tmp = $n . $base;
          $current .= sha1($tmp, true);
        }
        $hashno++;
        $clen = strlen($current);     
      }

      // $current now holds at least as many bytes as we need
      $result .= substr($current, 0, $remain);

      // Save any left over bytes for any future requests
      if ($clen &gt; $remain)
      {
        $extra = $current;
        $extracount = $remain;
      }

      return $result; 
    }
</code></pre>
","4837","<c#><php><encryption><rijndael>","3","3","3","2018-03-12 09:59:21","9012662","1","1","-1","","2017-05-23 11:51:45","2012-01-25 22:55:58",""
"2044517","How to decode Rijndael in ruby (encoded in VB.net)","<p>I am using Rinjael to encode in VB.NET and need to decode in Ruby. My VB.NET encryption class looks like this:</p>

<pre><code>Private Class Encryptor
        Private symmetricKey As System.Security.Cryptography.RijndaelManaged
        Private iVector As Byte()
        Private Key As Byte()
        Public Function encrypt(ByVal data As String) As String
            Try
                Dim plainTextBytes As Byte() = System.Text.Encoding.ASCII.GetBytes(data)
                Dim encryptor As System.Security.Cryptography.ICryptoTransform = symmetricKey.CreateEncryptor(Key, iVector)
                Dim memoryStream As New System.IO.MemoryStream
                Dim cryptoStream As System.Security.Cryptography.CryptoStream = New System.Security.Cryptography.CryptoStream(memoryStream, encryptor, System.Security.Cryptography.CryptoStreamMode.Write)
                cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length)
                cryptoStream.FlushFinalBlock()
                Dim cipherTextBytes As Byte() = memoryStream.ToArray()
                memoryStream.Close()
                cryptoStream.Close()
                Return Convert.ToBase64String(cipherTextBytes)
            Catch
                Return """"
            End Try
        End Function
        Public Function decrypt(ByVal data As String) As String
            Try
                Dim crypted As Byte() = Convert.FromBase64String(data)
                Dim decryptor As System.Security.Cryptography.ICryptoTransform = symmetricKey.CreateDecryptor(Key, iVector)
                Dim memoryStream As New System.IO.MemoryStream(crypted)
                Dim cryptoStream As System.Security.Cryptography.CryptoStream = New System.Security.Cryptography.CryptoStream(memoryStream, decryptor, System.Security.Cryptography.CryptoStreamMode.Read)
                Dim plain(crypted.Length) As Byte
                Dim count As Integer = cryptoStream.Read(plain, 0, plain.Length)
                memoryStream.Close()
                cryptoStream.Close()
                Return System.Text.Encoding.UTF8.GetString(plain, 0, count)
            Catch
                Return """"
            End Try
        End Function

        Public Sub New(ByVal clientkey As String)
            iVector = System.Text.Encoding.ASCII.GetBytes(""1234567890123456"")
            Key = System.Text.Encoding.ASCII.GetBytes(clientkey)
            symmetricKey = New System.Security.Cryptography.RijndaelManaged
            symmetricKey.Mode = System.Security.Cryptography.CipherMode.CBC
        End Sub
    End Class
</code></pre>

<p>this works ok and I am able to decrypt in java using the AES/CBC/PKCS5Padding. Now, my password and iv are 16 characters long (16*16bit = 256). When I try to decrypt in Ruby, it complains that my password is to short... I assume that it is using 8bit chars. I use this class for decryption in ruby:</p>

<pre><code>    require 'openssl'

module Crypt
  # Decrypts a block of data (encrypted_data) given an encryption key
  # and an initialization vector (iv).  Keys, iv's, and the data 
  # returned are all binary strings.  Cipher_type should be
  # ""AES-256-CBC"", ""AES-256-ECB"", or any of the cipher types
  # supported by OpenSSL.  Pass nil for the iv if the encryption type
  # doesn't use iv's (like ECB).
  #:return: =&gt; String
  #:arg: encrypted_data =&gt; String 
  #:arg: key =&gt; String
  #:arg: iv =&gt; String
  #:arg: cipher_type =&gt; String
  def Crypt.decrypt(encrypted_data, key, iv, cipher_type)
    aes = OpenSSL::Cipher::Cipher.new(cipher_type)
    aes.decrypt
    aes.key = key
    aes.iv = iv if iv != nil
    aes.update(encrypted_data) + aes.final  
  end

  # Encrypts a block of data given an encryption key and an 
  # initialization vector (iv).  Keys, iv's, and the data returned 
  # are all binary strings.  Cipher_type should be ""AES-256-CBC"",
  # ""AES-256-ECB"", or any of the cipher types supported by OpenSSL.  
  # Pass nil for the iv if the encryption type doesn't use iv's (like
  # ECB).
  #:return: =&gt; String
  #:arg: data =&gt; String 
  #:arg: key =&gt; String
  #:arg: iv =&gt; String
  #:arg: cipher_type =&gt; String  
  def Crypt.encrypt(data, key, iv, cipher_type)
    aes = OpenSSL::Cipher::Cipher.new(cipher_type)
    aes.encrypt
    aes.key = key
    aes.iv = iv if iv != nil
    aes.update(data) + aes.final      
  end
end
</code></pre>

<p>Now. By trying to decrypt using Crypt.decrypt(data,key,iv, ""AES-CBC-256"") i am certain that preliminary string/byte transformations have to be done on my data,key,iv to work correctly.</p>

<p>How shall I call Crypt.decrypt using key = ""passwordpassword"" and iv=""1234567890123456""?
Do I need to base64 decode my data?</p>

<p>Here's my decryption call, which doesn't seem to work (trying padding with zeroes):</p>

<pre><code>   text = Base64.decode64(text)
   pass = Digest::SHA1.hexdigest(""#{@pass}0000000000000000"").unpack('a2'*32).map{|x| x.hex}.pack('c'*32)
   iv = Digest::SHA1.hexdigest(""12345678901234560000000000000000"").unpack('a2'*32).map{|x| x.hex}.pack('c'*32)
   return Crypt.decrypt(text,pass,iv,""AES-256-CBC"")
</code></pre>
","<p>Because the VB app encodes the result as base64, it does look like the ruby script will need to use the Base64 module to decode it first.</p>

<p>I believe the key given to the Ruby AES key must be 256 bits. So your password would need to be 32 bytes long exactly in that case.  It would be better to use a scheme such as <a href=""http://snippets.dzone.com/posts/show/576"" rel=""nofollow noreferrer"">this</a>.</p>
","4816","<ruby-on-rails><ruby><aes><rijndaelmanaged><rijndael>","3","1","2","2010-01-24 19:38:44","","1","2","95573","","2010-01-24 19:38:44","2010-01-11 19:56:03",""
"2044517","How to decode Rijndael in ruby (encoded in VB.net)","<p>I am using Rinjael to encode in VB.NET and need to decode in Ruby. My VB.NET encryption class looks like this:</p>

<pre><code>Private Class Encryptor
        Private symmetricKey As System.Security.Cryptography.RijndaelManaged
        Private iVector As Byte()
        Private Key As Byte()
        Public Function encrypt(ByVal data As String) As String
            Try
                Dim plainTextBytes As Byte() = System.Text.Encoding.ASCII.GetBytes(data)
                Dim encryptor As System.Security.Cryptography.ICryptoTransform = symmetricKey.CreateEncryptor(Key, iVector)
                Dim memoryStream As New System.IO.MemoryStream
                Dim cryptoStream As System.Security.Cryptography.CryptoStream = New System.Security.Cryptography.CryptoStream(memoryStream, encryptor, System.Security.Cryptography.CryptoStreamMode.Write)
                cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length)
                cryptoStream.FlushFinalBlock()
                Dim cipherTextBytes As Byte() = memoryStream.ToArray()
                memoryStream.Close()
                cryptoStream.Close()
                Return Convert.ToBase64String(cipherTextBytes)
            Catch
                Return """"
            End Try
        End Function
        Public Function decrypt(ByVal data As String) As String
            Try
                Dim crypted As Byte() = Convert.FromBase64String(data)
                Dim decryptor As System.Security.Cryptography.ICryptoTransform = symmetricKey.CreateDecryptor(Key, iVector)
                Dim memoryStream As New System.IO.MemoryStream(crypted)
                Dim cryptoStream As System.Security.Cryptography.CryptoStream = New System.Security.Cryptography.CryptoStream(memoryStream, decryptor, System.Security.Cryptography.CryptoStreamMode.Read)
                Dim plain(crypted.Length) As Byte
                Dim count As Integer = cryptoStream.Read(plain, 0, plain.Length)
                memoryStream.Close()
                cryptoStream.Close()
                Return System.Text.Encoding.UTF8.GetString(plain, 0, count)
            Catch
                Return """"
            End Try
        End Function

        Public Sub New(ByVal clientkey As String)
            iVector = System.Text.Encoding.ASCII.GetBytes(""1234567890123456"")
            Key = System.Text.Encoding.ASCII.GetBytes(clientkey)
            symmetricKey = New System.Security.Cryptography.RijndaelManaged
            symmetricKey.Mode = System.Security.Cryptography.CipherMode.CBC
        End Sub
    End Class
</code></pre>

<p>this works ok and I am able to decrypt in java using the AES/CBC/PKCS5Padding. Now, my password and iv are 16 characters long (16*16bit = 256). When I try to decrypt in Ruby, it complains that my password is to short... I assume that it is using 8bit chars. I use this class for decryption in ruby:</p>

<pre><code>    require 'openssl'

module Crypt
  # Decrypts a block of data (encrypted_data) given an encryption key
  # and an initialization vector (iv).  Keys, iv's, and the data 
  # returned are all binary strings.  Cipher_type should be
  # ""AES-256-CBC"", ""AES-256-ECB"", or any of the cipher types
  # supported by OpenSSL.  Pass nil for the iv if the encryption type
  # doesn't use iv's (like ECB).
  #:return: =&gt; String
  #:arg: encrypted_data =&gt; String 
  #:arg: key =&gt; String
  #:arg: iv =&gt; String
  #:arg: cipher_type =&gt; String
  def Crypt.decrypt(encrypted_data, key, iv, cipher_type)
    aes = OpenSSL::Cipher::Cipher.new(cipher_type)
    aes.decrypt
    aes.key = key
    aes.iv = iv if iv != nil
    aes.update(encrypted_data) + aes.final  
  end

  # Encrypts a block of data given an encryption key and an 
  # initialization vector (iv).  Keys, iv's, and the data returned 
  # are all binary strings.  Cipher_type should be ""AES-256-CBC"",
  # ""AES-256-ECB"", or any of the cipher types supported by OpenSSL.  
  # Pass nil for the iv if the encryption type doesn't use iv's (like
  # ECB).
  #:return: =&gt; String
  #:arg: data =&gt; String 
  #:arg: key =&gt; String
  #:arg: iv =&gt; String
  #:arg: cipher_type =&gt; String  
  def Crypt.encrypt(data, key, iv, cipher_type)
    aes = OpenSSL::Cipher::Cipher.new(cipher_type)
    aes.encrypt
    aes.key = key
    aes.iv = iv if iv != nil
    aes.update(data) + aes.final      
  end
end
</code></pre>

<p>Now. By trying to decrypt using Crypt.decrypt(data,key,iv, ""AES-CBC-256"") i am certain that preliminary string/byte transformations have to be done on my data,key,iv to work correctly.</p>

<p>How shall I call Crypt.decrypt using key = ""passwordpassword"" and iv=""1234567890123456""?
Do I need to base64 decode my data?</p>

<p>Here's my decryption call, which doesn't seem to work (trying padding with zeroes):</p>

<pre><code>   text = Base64.decode64(text)
   pass = Digest::SHA1.hexdigest(""#{@pass}0000000000000000"").unpack('a2'*32).map{|x| x.hex}.pack('c'*32)
   iv = Digest::SHA1.hexdigest(""12345678901234560000000000000000"").unpack('a2'*32).map{|x| x.hex}.pack('c'*32)
   return Crypt.decrypt(text,pass,iv,""AES-256-CBC"")
</code></pre>
","<p>Solution. It was a 128bit encryption (wrongly thinking that the default in .NET managed was 256). Hence, this code works (notice ""AES-128-CBC""):</p>

<pre><code>   text = Base64.decode64(text)
   pass = ""passwordpassword""
   iv = ""1234567890123456""
   return Crypt.decrypt(text,pass,iv,""AES-128-CBC"")
</code></pre>
","4816","<ruby-on-rails><ruby><aes><rijndaelmanaged><rijndael>","3","3","2","2010-01-24 19:38:44","","1","2","95573","","2010-01-24 19:38:44","2010-01-11 19:56:03",""
"9226487","Delphi DEC library (Rijndael) encryption","<p>I am trying to use the <strong>DEC 3.0 library</strong> (<a href=""http://www.torry.net/vcl/security/strong/chipher.zip"" rel=""nofollow"">Delphi Encryption Compedium Part I</a>) to encrypt data in Delphi 7 and send it to a PHP script through POST, where I am decrypting it with <strong>mcrypt</strong> (RIJNDAEL_256, ECB mode).</p>

<p>Delphi part:</p>

<pre><code>uses Windows, DECUtil, Cipher, Cipher1;

function EncryptMsgData(MsgData, Key: string): string;
var RCipher: TCipher_Rijndael;
begin
  RCipher:= TCipher_Rijndael.Create(KeyStr, nil);
  RCipher.Mode:= cmECB;
  Result:= RCipher.CodeString(MsgData, paEncode, fmtMIME64);
  RCipher.Free;
end;
</code></pre>

<p>PHP part:</p>

<pre><code>function decryptMsgContent($msgContent, $sKey) {
    return mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $sKey, base64_decode($msgContent), MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND));
}
</code></pre>

<p><strong>The problem is that the decryption from PHP doesn't work and the output is gibberish, differing from the actual data.</strong></p>

<p>Of course, Delphi <code>Key</code> and PHP <code>$Key</code> is the same 24 characters string.</p>

<p>Now I know DEC 3.0 is old and outdated, and I'm not an expert in encryption and can't tell if the inplementation is actually Rijndael 256. Maybe someone can tell me how this implementation differs from PHP's mcrypt w/ RIJNDAEL_256. Maybe the keysize is different, or the block size, but can't tell this from the code. Here's an excerpt from Cipher1.pas:</p>

<pre><code>const
{ don’t change this }
  Rijndael_Blocks =  4;
  Rijndael_Rounds = 14;

class procedure TCipher_Rijndael.GetContext(var ABufSize, AKeySize, AUserSize: Integer);
begin
  ABufSize := Rijndael_Blocks * 4;
  AKeySize := 32;
  AUserSize := (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(Integer) * 2;
end;
</code></pre>

<p>Side question:</p>

<p>I know ECB mode isn't recommended and I'll use CBC as soon as I get ECB working. The question is, do I have to transmit the generated IV in Delphi to the PHP script also? Or knowing the key is sufficient, like for ECB?</p>
","<p>You are calling the TCipher.Create(const Password: String; AProtection: TProtection); constructor, which will compute a hash of the password before passing it to the Init method, which performs the standard key schedule of the implemented algorithm. To override this key derivation, use:</p>

<pre><code>function EncryptMsgData(MsgData, Key: string): string;
var RCipher: TCipher_Rijndael;
begin
  RCipher:= TCipher_Rijndael.Create('', nil);
  RCipher.Init(Pointer(Key)^,Length(Key),nil);
  RCipher.Mode:= cmECB;
  Result:= RCipher.CodeString(MsgData, paEncode, fmtMIME64);
  RCipher.Free;
</code></pre>

<p>end;</p>
","4807","<php><delphi><delphi-7><mcrypt><rijndael>","7","6","3","2015-02-10 14:34:03","9227155","7","4","7841","","2015-02-10 14:34:03","2012-02-10 10:43:53",""
"9226487","Delphi DEC library (Rijndael) encryption","<p>I am trying to use the <strong>DEC 3.0 library</strong> (<a href=""http://www.torry.net/vcl/security/strong/chipher.zip"" rel=""nofollow"">Delphi Encryption Compedium Part I</a>) to encrypt data in Delphi 7 and send it to a PHP script through POST, where I am decrypting it with <strong>mcrypt</strong> (RIJNDAEL_256, ECB mode).</p>

<p>Delphi part:</p>

<pre><code>uses Windows, DECUtil, Cipher, Cipher1;

function EncryptMsgData(MsgData, Key: string): string;
var RCipher: TCipher_Rijndael;
begin
  RCipher:= TCipher_Rijndael.Create(KeyStr, nil);
  RCipher.Mode:= cmECB;
  Result:= RCipher.CodeString(MsgData, paEncode, fmtMIME64);
  RCipher.Free;
end;
</code></pre>

<p>PHP part:</p>

<pre><code>function decryptMsgContent($msgContent, $sKey) {
    return mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $sKey, base64_decode($msgContent), MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND));
}
</code></pre>

<p><strong>The problem is that the decryption from PHP doesn't work and the output is gibberish, differing from the actual data.</strong></p>

<p>Of course, Delphi <code>Key</code> and PHP <code>$Key</code> is the same 24 characters string.</p>

<p>Now I know DEC 3.0 is old and outdated, and I'm not an expert in encryption and can't tell if the inplementation is actually Rijndael 256. Maybe someone can tell me how this implementation differs from PHP's mcrypt w/ RIJNDAEL_256. Maybe the keysize is different, or the block size, but can't tell this from the code. Here's an excerpt from Cipher1.pas:</p>

<pre><code>const
{ don’t change this }
  Rijndael_Blocks =  4;
  Rijndael_Rounds = 14;

class procedure TCipher_Rijndael.GetContext(var ABufSize, AKeySize, AUserSize: Integer);
begin
  ABufSize := Rijndael_Blocks * 4;
  AKeySize := 32;
  AUserSize := (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(Integer) * 2;
end;
</code></pre>

<p>Side question:</p>

<p>I know ECB mode isn't recommended and I'll use CBC as soon as I get ECB working. The question is, do I have to transmit the generated IV in Delphi to the PHP script also? Or knowing the key is sufficient, like for ECB?</p>
","<p>OK, so to sum this up, there were 3 problems with my code:</p>

<ol>
<li><p>Due to my poor understanding of mcrypt and ciphers in general, MCRYPT_RIJNDAEL_256 refers to 128 bits <strong>block</strong> and doesn't refer to the keysize. My correct choice should have been MCRYPT_RIJNDAEL_128, which is the AES standard and is also supported by DEC 3.0.</p></li>
<li><p>DEC has it's own default key derivation, so I needed to bypass it so I wouldn't have to implement it in PHP also. In actuality, I am using my own key derivation algorithm that was easy to reproduce in PHP (first 32 characters of sha1(key)).</p></li>
<li><p>DEC doesn't pad plaintext to a multiple of the block size of the cipher, as mcrypt expects, so I had to do it manually.</p></li>
</ol>

<p>Providing working code below:</p>

<p>Delphi:</p>

<pre><code>uses Windows, DECUtil, Cipher, Cipher1, CryptoAPI;

function EncryptMsgData(MsgData, Key: string): string;
var RCipher: TCipher_Rijndael;
    KeyStr: string;
begin
  Result:= '';
  try
    // key derivation; just making sure to feed the cipher a 24 chars key
    HashStr(HASH_SHA1, Key, KeyStr);
    KeyStr:= Copy(KeyStr, 1, 24);
    RCipher:= TCipher_Rijndael.Create('', nil);
    RCipher.Init(Pointer(KeyStr)^, Length(KeyStr), nil);
    RCipher.Mode:= cmECB;
    Result:= RCipher.CodeString(MsgData + StringOfChar(#0,16-(Length(MsgData) mod 16)), paEncode, fmtMIME64);
    RCipher.Free;
  except
  end;
end;
</code></pre>

<p>PHP:</p>

<pre><code>function decryptMsgContent($msgContent, $sKey) {
    $sKey = substr(sha1(sKey), 0, 24);
    return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $sKey, base64_decode($msgContent), MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB), MCRYPT_RAND)));
}
</code></pre>
","4807","<php><delphi><delphi-7><mcrypt><rijndael>","7","2","3","2015-02-10 14:34:03","9227155","7","4","7841","","2015-02-10 14:34:03","2012-02-10 10:43:53",""
"9226487","Delphi DEC library (Rijndael) encryption","<p>I am trying to use the <strong>DEC 3.0 library</strong> (<a href=""http://www.torry.net/vcl/security/strong/chipher.zip"" rel=""nofollow"">Delphi Encryption Compedium Part I</a>) to encrypt data in Delphi 7 and send it to a PHP script through POST, where I am decrypting it with <strong>mcrypt</strong> (RIJNDAEL_256, ECB mode).</p>

<p>Delphi part:</p>

<pre><code>uses Windows, DECUtil, Cipher, Cipher1;

function EncryptMsgData(MsgData, Key: string): string;
var RCipher: TCipher_Rijndael;
begin
  RCipher:= TCipher_Rijndael.Create(KeyStr, nil);
  RCipher.Mode:= cmECB;
  Result:= RCipher.CodeString(MsgData, paEncode, fmtMIME64);
  RCipher.Free;
end;
</code></pre>

<p>PHP part:</p>

<pre><code>function decryptMsgContent($msgContent, $sKey) {
    return mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $sKey, base64_decode($msgContent), MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND));
}
</code></pre>

<p><strong>The problem is that the decryption from PHP doesn't work and the output is gibberish, differing from the actual data.</strong></p>

<p>Of course, Delphi <code>Key</code> and PHP <code>$Key</code> is the same 24 characters string.</p>

<p>Now I know DEC 3.0 is old and outdated, and I'm not an expert in encryption and can't tell if the inplementation is actually Rijndael 256. Maybe someone can tell me how this implementation differs from PHP's mcrypt w/ RIJNDAEL_256. Maybe the keysize is different, or the block size, but can't tell this from the code. Here's an excerpt from Cipher1.pas:</p>

<pre><code>const
{ don’t change this }
  Rijndael_Blocks =  4;
  Rijndael_Rounds = 14;

class procedure TCipher_Rijndael.GetContext(var ABufSize, AKeySize, AUserSize: Integer);
begin
  ABufSize := Rijndael_Blocks * 4;
  AKeySize := 32;
  AUserSize := (Rijndael_Rounds + 1) * Rijndael_Blocks * SizeOf(Integer) * 2;
end;
</code></pre>

<p>Side question:</p>

<p>I know ECB mode isn't recommended and I'll use CBC as soon as I get ECB working. The question is, do I have to transmit the generated IV in Delphi to the PHP script also? Or knowing the key is sufficient, like for ECB?</p>
","<p>A 256 bit key I found is 32 charachters, or 32 bytes. Not 24. This may be the issue.</p>

<p>[EDIT]</p>

<p>I combined everyone's ideas (ansistring, etc) into one single idea with a fix.</p>

<p>Also, you are using codestring( -- it should be Encodestring(</p>

<p>I pasted working Encrypt and Decrypt source below:</p>

<hr>

<pre><code>function EncryptMsgData(MsgData, Key: AnsiString): AnsiString;
var RCipher: TCipher_Rijndael;
begin
  RCipher:= TCipher_Rijndael.Create('', nil);
  RCipher.Init(Pointer(Key)^,Length(Key),nil);
  RCipher.Mode:= cmCBC;
  Result:= RCipher.EncodeString(MsgData);
  RCipher.Free;
end;

function DecryptMsgData(MsgData, Key: AnsiString): AnsiString;
var RCipher: TCipher_Rijndael;
begin
  RCipher:= TCipher_Rijndael.Create('',nil);
  RCipher.Init(Pointer(Key)^,Length(Key),nil);
  RCipher.Mode:= cmCBC;
  Result:= RCipher.DecodeString(MsgData);
  RCipher.Free;
end;
</code></pre>

<hr>

<p>Use that with a 32 charachter key and you get proper encryption and decryption. </p>

<p>In order to store and use the encrypted data as a string you may want to use Base64Encode(</p>

<p>But do not forget to Base64Decode prior to decrypting.</p>

<p>This is the same technique needed for Blowfish. Sometimes the charachters actually are like a backspace, and perform the function rather than showing on screen. Base64Encode basically converts the charachters to something you can display in text.</p>

<p>Prior to transferring the encoded data across the internet or to another application in the same or another language, you MUST base64encode and decode in order to not loose data. Don't forget it in PHP too!</p>
","4807","<php><delphi><delphi-7><mcrypt><rijndael>","7","0","3","2015-02-10 14:34:03","9227155","7","4","7841","","2015-02-10 14:34:03","2012-02-10 10:43:53",""
"21552809","Invalid length for a Base-64 char array during Decryption through Rijndael AES","<p>I am getting the error ""Invalid length for a Base-64 char array."" </p>

<p>My code is :-</p>

<pre><code>public string Encrypt(string clearText)
{
    string EncryptionKey = ""MAKV2SPBNI99212"";
    byte[] clearBytes = Encoding.Unicode.GetBytes(clearText);
    using (Aes encryptor = Aes.Create())
    {
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(EncryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
        encryptor.Key = pdb.GetBytes(32);
        encryptor.IV = pdb.GetBytes(16);
        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(clearBytes, 0, clearBytes.Length);
                cs.Close();
            }
            clearText = Convert.ToBase64String(ms.ToArray());
        }
    }
    return clearText;
}

public string Decrypt(string cipherText)
{
    string EncryptionKey = ""MAKV2SPBNI99212"";

    byte[] cipherBytes = Convert.FromBase64String(cipherText); //it gives error

    using (Aes encryptor = Aes.Create())
    {
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(EncryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
        encryptor.Key = pdb.GetBytes(32);
        encryptor.IV = pdb.GetBytes(16);
        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateDecryptor(), CryptoStreamMode.Write))
            {
                cs.Write(cipherBytes, 0, cipherBytes.Length);
                cs.Close();
            }
            cipherText = Encoding.Unicode.GetString(ms.ToArray());
        }
    }
    return cipherText;
}
</code></pre>

<p>I am able to Encrypt the Xml, the Encrypt method is working as expected. but  Decrypt method gives error.  How to resolve it?</p>
","<p>It works fine for me.
But have a look here: </p>

<p><a href=""https://stackoverflow.com/questions/2925729/invalid-length-for-a-base-64-char-array"">Invalid length for a Base-64 char array</a></p>

<p><a href=""http://social.msdn.microsoft.com/Forums/vstudio/en-US/a5607e26-7c81-467b-8e90-c6d71d11de6d/invalid-length-for-a-base64-char-array-or-string?forum=vbgeneral"" rel=""nofollow noreferrer"">http://social.msdn.microsoft.com/Forums/vstudio/en-US/a5607e26-7c81-467b-8e90-c6d71d11de6d/invalid-length-for-a-base64-char-array-or-string?forum=vbgeneral</a></p>
","4715","<c#><xml><encryption><encryption-symmetric><rijndael>","1","0","1","2014-02-04 12:53:56","","1","","1195620","","2014-02-04 12:53:56","2014-02-04 12:37:54",""
"5793621","Rijndael encryption","<p>i'm using DCPcrypt library found <a href=""http://www.cityinthesky.co.uk/opensource/dcpcrypt"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Here is a little code to encrypt a string</p>

<pre><code>InitializationVector: AnsiString;
const Key: Ansistring = 'keykeykeykey';
// Encrypt a string and return the Base64 encoded result
function Encrypt(DataToEncrypt: ansistring):ansistring;
var
  Cipher : TDCP_rijndael;
  Data: string;
  IV: array[0..15] of byte;      // the initialization vector
  i:Integer;
begin
  // Pad Key, IV and Data with zeros as appropriate
  FillChar(IV,Sizeof(IV),0);            // make the IV all zeros

  Data := PadWithZeros(DataToEncrypt,BlockSize);

  for i := 0 to (Length(IV) - 1) do   //just random values for the IV
    IV[i] := Random(256);

  Cipher := TDCP_rijndael.Create(nil);

  if Length(Key) &lt;= 16 then
    Cipher.Init(Key[1],128,@IV[1])
  else if Length(Key) &lt;= 24 then
    Cipher.Init(Key[1],192,@IV[1])
  else
    Cipher.Init(Key[1],256,@IV[1]);
  // Encrypt the data
  Cipher.EncryptCBC(Data[1],Data[1],Length(Data));
  // Free the cipher and clear sensitive information
  Cipher.Free;

  SetString(InitializationVector,PAnsiChar(@IV[1]),Length(IV));
  InitializationVector := Base64EncodeStr(InitializationVector);

  //Base64 encoded result
  Result := Base64EncodeStr(Data);
end;
</code></pre>

<p>I can decrypt the resulted string, but only half of it. Found one similar post, but he found answer when encoding cryptogram with base64 which i'm doing. <a href=""https://stackoverflow.com/questions/2975472/rijndael-encryption-only-part-of-the-string-is-decrypted"">Here</a>.</p>

<p>Any help is appreciated!</p>
","<p>Strings in Delphi 2009/2010 and XE are Unicode strings by default.<br>
This means that individual characters can take up 1 or <strong>more bytes</strong>.<br>
You put good old <code>AnsiString</code> in the code, but forgot one.</p>

<p>This means that the translation to Unicode is messing up your decryption, since with encryption even a <em>single</em> changed bit will mess everything up.</p>

<p>Stick with AnsiStrings throughout and you should be fine. </p>

<p>Change:</p>

<pre><code>function Encrypt(DataToEncrypt: ansistring):ansistring;
var
  Cipher : TDCP_rijndael;
  Data: string;
  IV: array[0..15] of byte;      // the initialization vector
  i:Integer;
begin
</code></pre>

<p>to</p>

<pre><code>// Encrypt a string and return the Base64 encoded result
function Encrypt(DataToEncrypt: AnsiString): AnsiString;
var
  Cipher: TDCP_rijndael;
  //Data: string; &lt;&lt;- change to ansistring
  Data: AnsiString;
  IV: array[0..15] of byte;      // the initialization vector
  i: Integer;
</code></pre>
","4645","<delphi><encryption><rijndael>","1","4","1","2012-08-11 20:37:12","5796443","1","1","-1","","2017-05-23 12:23:04","2011-04-26 16:49:45",""
"15804895","Rijndael 256 encryption: Java and .NET do not match","<p>I need to translate a powershell script with Rijandael encryption to Java.
Here is the source powershell code:</p>

<pre><code>[Reflection.Assembly]::LoadWithPartialName(""System.Security"")
Add-Type -AssemblyName System.Web

$sKy = ""bbee9a3e8e44e28edb4539186d182aaa""  
$sIV  = ""131a68dc13160766f37dc931d7e518aa""

$myRijndael = New-Object System.Security.Cryptography.RijndaelManaged
$myRijndael.KeySize = 256
$myRijndael.BlockSize = 256
$myRijndael.Mode = [System.Security.Cryptography.CipherMode]::CBC
$myRijndael.Padding = [System.Security.Cryptography.PaddingMode]::Zeros

[byte[]] $key = [Text.Encoding]::ASCII.GetBytes($sKy)
[byte[]] $IV = [Text.Encoding]::ASCII.GetBytes($sIV)

$encryptor = $myRijndael.CreateEncryptor($key, $IV)
$msEncrypt = new-Object IO.MemoryStream 
$csEncrypt = new-Object Security.Cryptography.CryptoStream $msEncrypt,$encryptor,""Write""

$toEncrypt = [Text.Encoding]::ASCII.GetBytes(""TEST_TEXT_TO_ENCODE"")

$csEncrypt.Write($toEncrypt, 0, $toEncrypt.Length)
$csEncrypt.FlushFinalBlock()
$encrypted = $msEncrypt.ToArray()
</code></pre>

<p>For Java encryption I use bouncycastle and its RijndaelEngine with same parameters - CBC, 256 block size, zero padding. Here is my java code snippet:</p>

<pre><code>byte[] sessionKey = ""bbee9a3e8e44e28edb4539186d182aaa"".getBytes(); 
byte[] iv = ""131a68dc13160766f37dc931d7e518aa"".getBytes();
byte[] plaintext = ""TEST_TEXT_TO_ENCODE"".getBytes();

PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(
    new CBCBlockCipher(new RijndaelEngine(256)), new ZeroBytePadding());

int keySize = 256 / 8;

CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(sessionKey, 0, keySize), iv, 0, keySize);

cipher.init(true, ivAndKey);
byte[] encrypted  = new byte[cipher.getOutputSize(plaintext.length)];
int oLen = cipher.processBytes(plaintext, 0, plaintext.length, encrypted, 0);
cipher.doFinal(encrypted, oLen);
</code></pre>

<p>Bytes arrays for secret key, initial vector and text to encrypt are absolutely the same:</p>

<pre><code>secret key: [98, 98, 101, 101, 57, 97, 51, 101, 56, 101, 52, 52, 101, 50, 56, 101, 100, 98, 52, 53, 51, 57, 49, 56, 54, 100, 49, 56, 50, 97, 97, 97]
initial vector: [49, 51, 49, 97, 54, 56, 100, 99, 49, 51, 49, 54, 48, 55, 54, 54, 102, 51, 55, 100, 99, 57, 51, 49, 100, 55, 101, 53, 49, 56, 97, 97]
text to encrypt: [84, 69, 83, 84, 95, 84, 69, 88, 84, 95, 84, 79, 95, 69, 78, 67, 79, 68, 69]
</code></pre>

<p>But the result array for powershell and Java differs:</p>

<pre><code>powershell: [241, 100, 194, 184, 166, 85, 15, 212, 186, 220, 85, 136, 16, 194, 93, 11, 243, 245, 230, 207, 224, 88, 255, 153, 185, 9, 43, 78, 219, 138, 7, 222]
java: [-15, 100, -62, -72, -90, 85, 15, -44, -70, -36, 85, -120, 16, -62, 93, 11, -13, -11, -26, -49, -32, 88, -1, -103, -71, 9, 43, 78, -37, -118, 7, -34]
</code></pre>

<p>Please, can somebody help me to figure out what am I doing wrong in Java with bouncycastle? I was stack with it for whole day...</p>
","<p>Your results <em>are</em> the same, as far as I can see - it's just that in Java, bytes are signed. (That's icky, but it doesn't affect the actual bits you're getting.)</p>

<p>If you add 256 to every negative value in the Java results, you'll see they're the same as the .NET code:</p>

<pre><code>.NET:      241  100  194  184  166

Java:      -15  100  -62  -72  -90

Java+256:  241  100  194  184  166
for -ve
</code></pre>

<p>(etc)</p>

<p>Alternatively, just print out the unsigned hex representation of the two byte arrays - or even base64-encode them - and you'll see they're the same.</p>
","4458","<java><.net><powershell><bouncycastle><rijndael>","7","12","1","2013-04-04 07:23:09","15804940","0","2","","","","2013-04-04 07:20:35",""
"4925798","Rijndael Padding Error","<p>Hello I am trying to encrypt / decrypt a string via Rijaendal. 
I simply can't figure out why the decryption blows up. I always end up with an incorrect padding error. One thing that throws me off is the result of my encryption which I return as HEX array. It has a length of 14 bytes. In my decryption function, the same byte array ends up having 16 bytes upon conversion from HEX.</p>

<p>Any help would be appreciated:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace rjandal
{
    class Program
    {
        static void Main(string[] args)
        {
            string DataForEncrypting = ""this is a test"";

            string key = string.Empty;
            string iv = string.Empty;

            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                rmt.GenerateKey();
                rmt.GenerateIV();
                key = Convert.ToBase64String(rmt.Key);
                iv = Convert.ToBase64String(rmt.IV);
            }

            string encryptedData = _encrypt(DataForEncrypting, key, iv);
            string unencryptedData = _decrypt(key, iv, HexString2Ascii(encryptedData));

            Console.WriteLine(unencryptedData);
            Console.WriteLine(encryptedData);
            Console.ReadKey();
        }

        private static string _encrypt(string value, string key, string initVector)
        {
            byte[] buffer = ASCIIEncoding.ASCII.GetBytes(value);
            byte[] encBuffer;
            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                encBuffer = rmt.CreateEncryptor(Convert.FromBase64String(key),
                    Convert.FromBase64String(initVector)).TransformFinalBlock(buffer, 0, buffer.Length);
            }
            string encryptValue = ConvertToHex(ASCIIEncoding.ASCII.GetString(encBuffer));
            return encryptValue;
        }

        private static string _decrypt(string key, string initVector, string value)
        {
            byte[] hexBuffer = ASCIIEncoding.ASCII.GetBytes(value);
            byte[] decBuffer;
            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                decBuffer = rmt.CreateDecryptor(Convert.FromBase64String(key),
                    Convert.FromBase64String(initVector)).TransformFinalBlock(hexBuffer, 0, hexBuffer.Length);
            }

            return System.Text.ASCIIEncoding.ASCII.GetString(decBuffer);
        } 

        private static string ConvertToHex(string asciiString)
        {
            string hex = """";
            foreach (char c in asciiString)
            {
                int tmp = c;
                hex += String.Format(""{0:x2}"", (uint)System.Convert.ToUInt32(tmp.ToString()));
            }
            return hex;
        }

        private static string HexString2Ascii(string hexString)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &lt;= hexString.Length - 2; i += 2)
            {
                sb.Append(Convert.ToString(Convert.ToChar(Int32.Parse(hexString.Substring(i, 2), System.Globalization.NumberStyles.HexNumber))));
            }
            return sb.ToString();
        }

    }
}
</code></pre>
","<p>You shouldn't be using ASCII character encoding as an intermediate step; you should change your functions that go from hex to ASCII (and back again) to go from a <code>byte[]</code> to hex (and back again) instead.</p>

<pre><code>    private static string ConvertToHex(byte[] data)
    {
        string hex = """";
        foreach (byte b in data)
        {
            hex += b.ToString(""X2"");
        }
        return hex;
    }

    private static byte[] HexString2ByteArray(string hexString)
    {
        byte[] output = new byte[hexString.Length / 2];

        for (int i = 0; i &lt;= hexString.Length - 2; i += 2)
        {
             output[i/2] = Convert.ToByte(hexString.Substring(i, 2), 16);
        }
        return output;
    }
</code></pre>

<p>As a side note, is there a reason that you're looking for a hex representation of the array versus something more compact like Base64? You're using Base64 in your example to transfer the key and IV, so I'm just curious about what makes you want to return the encrypted data as hex here.</p>

<p>In any case, here's something that should work for you:</p>

<pre><code>    private static string _encrypt(string value, string key, string initVector)
    {
        byte[] buffer = Encoding.Unicode.GetBytes(value);
        byte[] encBuffer;
        using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
        {
            rmt.KeySize = 256;
            rmt.BlockSize = 128;
            rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
            rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
            encBuffer = rmt.CreateEncryptor(Convert.FromBase64String(key),
                Convert.FromBase64String(initVector)).TransformFinalBlock(buffer, 0, buffer.Length);
        }
        string encryptValue = ConvertToHex(encBuffer);
        return encryptValue;
    }

    private static string _decrypt(string key, string initVector, string value)
    {
        byte[] hexBuffer = HexString2ByteArray(value);
        byte[] decBuffer;
        using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
        {
            rmt.KeySize = 256;
            rmt.BlockSize = 128;
            rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
            rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
            decBuffer = rmt.CreateDecryptor(Convert.FromBase64String(key),
                Convert.FromBase64String(initVector)).TransformFinalBlock(hexBuffer, 0, hexBuffer.Length);
        }

        return Encoding.Unicode.GetString(decBuffer);
    } 
</code></pre>
","4387","<c#><encryption><aes><rijndael>","4","2","3","2012-11-26 23:18:25","4925840","0","1","47961","","2011-02-07 19:56:44","2011-02-07 19:51:27",""
"4925798","Rijndael Padding Error","<p>Hello I am trying to encrypt / decrypt a string via Rijaendal. 
I simply can't figure out why the decryption blows up. I always end up with an incorrect padding error. One thing that throws me off is the result of my encryption which I return as HEX array. It has a length of 14 bytes. In my decryption function, the same byte array ends up having 16 bytes upon conversion from HEX.</p>

<p>Any help would be appreciated:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace rjandal
{
    class Program
    {
        static void Main(string[] args)
        {
            string DataForEncrypting = ""this is a test"";

            string key = string.Empty;
            string iv = string.Empty;

            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                rmt.GenerateKey();
                rmt.GenerateIV();
                key = Convert.ToBase64String(rmt.Key);
                iv = Convert.ToBase64String(rmt.IV);
            }

            string encryptedData = _encrypt(DataForEncrypting, key, iv);
            string unencryptedData = _decrypt(key, iv, HexString2Ascii(encryptedData));

            Console.WriteLine(unencryptedData);
            Console.WriteLine(encryptedData);
            Console.ReadKey();
        }

        private static string _encrypt(string value, string key, string initVector)
        {
            byte[] buffer = ASCIIEncoding.ASCII.GetBytes(value);
            byte[] encBuffer;
            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                encBuffer = rmt.CreateEncryptor(Convert.FromBase64String(key),
                    Convert.FromBase64String(initVector)).TransformFinalBlock(buffer, 0, buffer.Length);
            }
            string encryptValue = ConvertToHex(ASCIIEncoding.ASCII.GetString(encBuffer));
            return encryptValue;
        }

        private static string _decrypt(string key, string initVector, string value)
        {
            byte[] hexBuffer = ASCIIEncoding.ASCII.GetBytes(value);
            byte[] decBuffer;
            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                decBuffer = rmt.CreateDecryptor(Convert.FromBase64String(key),
                    Convert.FromBase64String(initVector)).TransformFinalBlock(hexBuffer, 0, hexBuffer.Length);
            }

            return System.Text.ASCIIEncoding.ASCII.GetString(decBuffer);
        } 

        private static string ConvertToHex(string asciiString)
        {
            string hex = """";
            foreach (char c in asciiString)
            {
                int tmp = c;
                hex += String.Format(""{0:x2}"", (uint)System.Convert.ToUInt32(tmp.ToString()));
            }
            return hex;
        }

        private static string HexString2Ascii(string hexString)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &lt;= hexString.Length - 2; i += 2)
            {
                sb.Append(Convert.ToString(Convert.ToChar(Int32.Parse(hexString.Substring(i, 2), System.Globalization.NumberStyles.HexNumber))));
            }
            return sb.ToString();
        }

    }
}
</code></pre>
","<p>You're doing way too much conversion between text and data, basically. Look at this, for example:</p>

<pre><code>string encryptValue = ConvertToHex(ASCIIEncoding.ASCII.GetString(encBuffer));
</code></pre>

<p>Once you've got an ASCII string, why would you need to convert <em>that</em> into hex? It's already text! But by then you'll already have lost the data. Unless you really <em>need</em> it in hex (in which case follow Adam's suggestion and change your HexToAscii method to take a byte[] instead of a string) you should just use Convert.ToBase64String:</p>

<pre><code>string encryptValue = Convert.ToBase64String(encBuffer);
</code></pre>

<p>Use <code>Convert.FromBase64String</code> at the other end when decrypting. You can then get rid of your hex methods completely.</p>

<p>Oh, and in general I wouldn't use <code>Encoding.ASCII</code> to start with... I'd almost always use <code>Encoding.UTF8</code> instead. Currently you'll fail to encrypt (correctly) any strings containing non-ASCII characters such as accents.</p>

<p>Here's a rejigged version of your test program, with a few of those changes made. Note that the names ""cipher text"" and ""plain text"" are in terms of encryption... they're still binary data rather than text!</p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        string DataForEncrypting = ""this is a test"";

        string key = string.Empty;
        string iv = string.Empty;

        using (RijndaelManaged rmt = new RijndaelManaged())
        {
            rmt.KeySize = 256;
            rmt.BlockSize = 128;
            rmt.Mode = CipherMode.CBC;
            rmt.Padding = PaddingMode.ISO10126;
            rmt.GenerateKey();
            rmt.GenerateIV();
            key = Convert.ToBase64String(rmt.Key);
            iv = Convert.ToBase64String(rmt.IV);
        }

        string encryptedData = _encrypt(DataForEncrypting, key, iv);
        string unencryptedData = _decrypt(key, iv, encryptedData);

        Console.WriteLine(unencryptedData);
        Console.WriteLine(encryptedData);
        Console.ReadKey();
    }

    private static string _encrypt(string value, string key, string initVector)
    {
        using (RijndaelManaged rmt = new RijndaelManaged())
        {
            rmt.KeySize = 256;
            rmt.BlockSize = 128;
            rmt.Mode = CipherMode.CBC;
            rmt.Padding = PaddingMode.ISO10126;
            byte[] plainText = Encoding.UTF8.GetBytes(value);
            byte[] cipherText = rmt.CreateEncryptor(Convert.FromBase64String(key),
                                                    Convert.FromBase64String(initVector))
                                   .TransformFinalBlock(plainText, 0, plainText.Length);
            return Convert.ToBase64String(cipherText);
        }
    }

    private static string _decrypt(string key, string initVector, string value)
    {
        using (RijndaelManaged rmt = new RijndaelManaged())
        {
            rmt.KeySize = 256;
            rmt.BlockSize = 128;
            rmt.Mode = CipherMode.CBC;
            rmt.Padding = PaddingMode.ISO10126;
            byte[] cipherText = Convert.FromBase64String(value);
            byte[] plainText = rmt.CreateDecryptor(Convert.FromBase64String(key),
                                                   Convert.FromBase64String(initVector))
                                  .TransformFinalBlock(cipherText, 0, cipherText.Length);
            return Encoding.UTF8.GetString(plainText);
        }
    }
}
</code></pre>
","4387","<c#><encryption><aes><rijndael>","4","5","3","2012-11-26 23:18:25","4925840","0","1","47961","","2011-02-07 19:56:44","2011-02-07 19:51:27",""
"4925798","Rijndael Padding Error","<p>Hello I am trying to encrypt / decrypt a string via Rijaendal. 
I simply can't figure out why the decryption blows up. I always end up with an incorrect padding error. One thing that throws me off is the result of my encryption which I return as HEX array. It has a length of 14 bytes. In my decryption function, the same byte array ends up having 16 bytes upon conversion from HEX.</p>

<p>Any help would be appreciated:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace rjandal
{
    class Program
    {
        static void Main(string[] args)
        {
            string DataForEncrypting = ""this is a test"";

            string key = string.Empty;
            string iv = string.Empty;

            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                rmt.GenerateKey();
                rmt.GenerateIV();
                key = Convert.ToBase64String(rmt.Key);
                iv = Convert.ToBase64String(rmt.IV);
            }

            string encryptedData = _encrypt(DataForEncrypting, key, iv);
            string unencryptedData = _decrypt(key, iv, HexString2Ascii(encryptedData));

            Console.WriteLine(unencryptedData);
            Console.WriteLine(encryptedData);
            Console.ReadKey();
        }

        private static string _encrypt(string value, string key, string initVector)
        {
            byte[] buffer = ASCIIEncoding.ASCII.GetBytes(value);
            byte[] encBuffer;
            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                encBuffer = rmt.CreateEncryptor(Convert.FromBase64String(key),
                    Convert.FromBase64String(initVector)).TransformFinalBlock(buffer, 0, buffer.Length);
            }
            string encryptValue = ConvertToHex(ASCIIEncoding.ASCII.GetString(encBuffer));
            return encryptValue;
        }

        private static string _decrypt(string key, string initVector, string value)
        {
            byte[] hexBuffer = ASCIIEncoding.ASCII.GetBytes(value);
            byte[] decBuffer;
            using (System.Security.Cryptography.RijndaelManaged rmt = new System.Security.Cryptography.RijndaelManaged())
            {
                rmt.KeySize = 256;
                rmt.BlockSize = 128;
                rmt.Mode = System.Security.Cryptography.CipherMode.CBC;
                rmt.Padding = System.Security.Cryptography.PaddingMode.ISO10126;
                decBuffer = rmt.CreateDecryptor(Convert.FromBase64String(key),
                    Convert.FromBase64String(initVector)).TransformFinalBlock(hexBuffer, 0, hexBuffer.Length);
            }

            return System.Text.ASCIIEncoding.ASCII.GetString(decBuffer);
        } 

        private static string ConvertToHex(string asciiString)
        {
            string hex = """";
            foreach (char c in asciiString)
            {
                int tmp = c;
                hex += String.Format(""{0:x2}"", (uint)System.Convert.ToUInt32(tmp.ToString()));
            }
            return hex;
        }

        private static string HexString2Ascii(string hexString)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &lt;= hexString.Length - 2; i += 2)
            {
                sb.Append(Convert.ToString(Convert.ToChar(Int32.Parse(hexString.Substring(i, 2), System.Globalization.NumberStyles.HexNumber))));
            }
            return sb.ToString();
        }

    }
}
</code></pre>
","<p>You may avoid the issues with Decypting/Encrypting and usign System.Text.Encoding and avoid using Base64 encoding work around, by adding a few methods that completely bypass microsoft's mismatched conversions in the System.Text.Encoding, by allowing you to encrypt the real bytes in memory without any translations.</p>

<p>Since using these I have avoided padding errors caused by System.Text.Encoding methods, without using the Base64 conversions either.</p>

<pre><code>    private static Byte[] GetBytes(String SomeString)
    {
        Char[] SomeChars = SomeString.ToCharArray();
        Int32 Size = SomeChars.Length * 2;
        List&lt;Byte&gt; TempList = new List&lt;Byte&gt;(Size);
        foreach (Char Character in SomeChars)
        {
            TempList.AddRange(BitConverter.GetBytes(Character));
        }
        return TempList.ToArray();
    }
    private static String GetString(Byte[] ByteArray)
    {
        Int32 Size = ByteArray.Length / 2;
        List&lt;Char&gt; TempList = new List&lt;Char&gt;(Size);
        for (Int32 i = 0; i &lt; ByteArray.Length; i += 2)
        {
            TempList.Add(BitConverter.ToChar(ByteArray, i));
        }
        return new String(TempList.ToArray());
    }
</code></pre>

<p>And how they are used with encryption</p>

<pre><code>    private static String Encrypt(String Test1, Byte[] Key, Byte[] IV)
    {
        Byte[] Encrypted;
        using (AesCryptoServiceProvider AesMan = new AesCryptoServiceProvider())
        {
            AesMan.Mode              = CipherMode.CBC;
            AesMan.Padding           = PaddingMode.ISO10126;
            ICryptoTransform EncThis = AesMan.CreateEncryptor(Key, IV);

            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, EncThis, CryptoStreamMode.Write))
                {

                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(Test1);
                    }
                    Encrypted = msEncrypt.ToArray();
                }
            }
        };
        return GetString(Encrypted);
    }

    private static String Decrypt(String Data, Byte[] Key, Byte[] IV)
    {
        String Decrypted;
        using (AesCryptoServiceProvider AesMan = new AesCryptoServiceProvider())
        {
            AesMan.Mode              = CipherMode.CBC;
            AesMan.Padding           = PaddingMode.ISO10126;
            ICryptoTransform EncThis = AesMan.CreateDecryptor(Key, IV);

            using (MemoryStream msDecrypt = new MemoryStream(GetBytes(Data)))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, EncThis, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {

                        // Read the decrypted bytes from the decrypting stream 
                        // and place them in a string.
                        Decrypted = srDecrypt.ReadToEnd();
                    }
                }
            }
        }
        return Decrypted;
    }
</code></pre>
","4387","<c#><encryption><aes><rijndael>","4","2","3","2012-11-26 23:18:25","4925840","0","1","47961","","2011-02-07 19:56:44","2011-02-07 19:51:27",""
"521220","Decrypting RijndaelManaged Encrypted strings with CryptDecrypt","<p>Ok I'm trying to use the Win32 Crypto API in C++ to decrypt a string encrypted in C# (.NET 2) with the RijndaelManaged Class.  But I'm having no luck at all i get jibberish or a bad data Win32 error code.  All my keys, IV and salt match, I've looked in the watch for both test apps.  I've spent all say looking at it and I'm officialy stuck.</p>

<p>Anyway here is the C#</p>

<pre><code>            Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(GetPassPhrase(), salt, 1000);
        RijndaelManaged rijndael = new RijndaelManaged();
        rijndael.BlockSize = 128;
        rijndael.KeySize = 256;
        rijndael.Mode = CipherMode.CBC;

        rijndael.Key = pdb.GetBytes(m_KeySize);
        rijndael.IV = GetIV(iv);

        ICryptoTransform encryptor = rijndael.CreateEncryptor(); 
        MemoryStream msEncrypt = new MemoryStream();
        CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
        Byte[] encryptedBytes = null;
        Byte[] toBeEncrypted = UnicodeEncoding.Unicode.GetBytes(value);

        csEncrypt.Write(toBeEncrypted, 0, toBeEncrypted.Length);
        csEncrypt.FlushFinalBlock();
        encryptedBytes = msEncrypt.ToArray();
</code></pre>

<p>The C++ to decrypt it is:</p>

<pre><code>                                    keyBlob.hdr.bType = PLAINTEXTKEYBLOB;
                keyBlob.hdr.bVersion = CUR_BLOB_VERSION;
                keyBlob.hdr.reserved = 0;
                keyBlob.hdr.aiKeyAlg = CALG_AES_256;
                keyBlob.cbKeySize = KEY_SIZE;
                keyBlob.rgbKeyData = &amp;byKey[0];

                if ( CryptImportKey( hProv, (const LPBYTE) &amp;keyBlob, sizeof(BLOBHEADER) + sizeof(DWORD) + KEY_SIZE, 0, CRYPT_EXPORTABLE, &amp;hKey ) )
                {

                    if ( CryptSetKeyParam( hKey, KP_IV, (const BYTE *) &amp;byIV, 0))
                    {
                        DWORD dwLen = iDestLen;
                        if ( CryptDecrypt( hKey, 0, TRUE, 0, pbyData, &amp;dwLen))
                        {

                            if ( dwLen &lt; (DWORD) *plOutSize)
                            {
                                memcpy_s(pbyOutput, *plOutSize, pbyData, dwLen);

                                *plOutSize = dwLen;

                                bRet = TRUE; 
                            }
                        }
                        else
                        {
                            // Log
                            DWORD dwErr = ::GetLastError();
                            int y =0;
                        }
                    }
                }
</code></pre>

<p>I'm calling CryptAcquireContext successfully and my C++ is executing fine.  Can anyone spot the error in my ways.  It's starting to depress me know :(</p>
","<p>I see that you are using CBC chaining mode to encrypt the plain text.</p>

<p>Are you sure you are using the same chaining mode to decrypt the cypher text?</p>

<p>(I am sorry. I am not able to understand that from the code)</p>
","4228","<c#><c++><aes><rijndaelmanaged><rijndael>","0","0","3","2009-11-24 21:00:16","529090","0","","95573","","2009-08-05 17:43:02","2009-02-06 17:20:17",""
"521220","Decrypting RijndaelManaged Encrypted strings with CryptDecrypt","<p>Ok I'm trying to use the Win32 Crypto API in C++ to decrypt a string encrypted in C# (.NET 2) with the RijndaelManaged Class.  But I'm having no luck at all i get jibberish or a bad data Win32 error code.  All my keys, IV and salt match, I've looked in the watch for both test apps.  I've spent all say looking at it and I'm officialy stuck.</p>

<p>Anyway here is the C#</p>

<pre><code>            Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(GetPassPhrase(), salt, 1000);
        RijndaelManaged rijndael = new RijndaelManaged();
        rijndael.BlockSize = 128;
        rijndael.KeySize = 256;
        rijndael.Mode = CipherMode.CBC;

        rijndael.Key = pdb.GetBytes(m_KeySize);
        rijndael.IV = GetIV(iv);

        ICryptoTransform encryptor = rijndael.CreateEncryptor(); 
        MemoryStream msEncrypt = new MemoryStream();
        CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
        Byte[] encryptedBytes = null;
        Byte[] toBeEncrypted = UnicodeEncoding.Unicode.GetBytes(value);

        csEncrypt.Write(toBeEncrypted, 0, toBeEncrypted.Length);
        csEncrypt.FlushFinalBlock();
        encryptedBytes = msEncrypt.ToArray();
</code></pre>

<p>The C++ to decrypt it is:</p>

<pre><code>                                    keyBlob.hdr.bType = PLAINTEXTKEYBLOB;
                keyBlob.hdr.bVersion = CUR_BLOB_VERSION;
                keyBlob.hdr.reserved = 0;
                keyBlob.hdr.aiKeyAlg = CALG_AES_256;
                keyBlob.cbKeySize = KEY_SIZE;
                keyBlob.rgbKeyData = &amp;byKey[0];

                if ( CryptImportKey( hProv, (const LPBYTE) &amp;keyBlob, sizeof(BLOBHEADER) + sizeof(DWORD) + KEY_SIZE, 0, CRYPT_EXPORTABLE, &amp;hKey ) )
                {

                    if ( CryptSetKeyParam( hKey, KP_IV, (const BYTE *) &amp;byIV, 0))
                    {
                        DWORD dwLen = iDestLen;
                        if ( CryptDecrypt( hKey, 0, TRUE, 0, pbyData, &amp;dwLen))
                        {

                            if ( dwLen &lt; (DWORD) *plOutSize)
                            {
                                memcpy_s(pbyOutput, *plOutSize, pbyData, dwLen);

                                *plOutSize = dwLen;

                                bRet = TRUE; 
                            }
                        }
                        else
                        {
                            // Log
                            DWORD dwErr = ::GetLastError();
                            int y =0;
                        }
                    }
                }
</code></pre>

<p>I'm calling CryptAcquireContext successfully and my C++ is executing fine.  Can anyone spot the error in my ways.  It's starting to depress me know :(</p>
","<p>There are a handful of things you should check, since some of the code (declarations etc) are missing:</p>

<ul>
<li>Block size - this usually should be the same as key size, I think it might even be the default since you dont specify it on C++ side. Set it to 256 on C# side, I guess it best that you explicitly specify it in C++ too.</li>
<li>Padding - the managed classes have PKCS7 as their default padding, I <em>think</em> its the default for cryptoAPI functions too, but I'm not sure.</li>
<li>I assume that GetPassPhrase, GetIV etc give you he same keys you're using on the C++ side?</li>
<li>It's not clear how the encrypted data is passed between the programs, is it possible there is some kind of translation error? E.g. base64, URL encode, etc.</li>
</ul>
","4228","<c#><c++><aes><rijndaelmanaged><rijndael>","0","0","3","2009-11-24 21:00:16","529090","0","","95573","","2009-08-05 17:43:02","2009-02-06 17:20:17",""
"521220","Decrypting RijndaelManaged Encrypted strings with CryptDecrypt","<p>Ok I'm trying to use the Win32 Crypto API in C++ to decrypt a string encrypted in C# (.NET 2) with the RijndaelManaged Class.  But I'm having no luck at all i get jibberish or a bad data Win32 error code.  All my keys, IV and salt match, I've looked in the watch for both test apps.  I've spent all say looking at it and I'm officialy stuck.</p>

<p>Anyway here is the C#</p>

<pre><code>            Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(GetPassPhrase(), salt, 1000);
        RijndaelManaged rijndael = new RijndaelManaged();
        rijndael.BlockSize = 128;
        rijndael.KeySize = 256;
        rijndael.Mode = CipherMode.CBC;

        rijndael.Key = pdb.GetBytes(m_KeySize);
        rijndael.IV = GetIV(iv);

        ICryptoTransform encryptor = rijndael.CreateEncryptor(); 
        MemoryStream msEncrypt = new MemoryStream();
        CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
        Byte[] encryptedBytes = null;
        Byte[] toBeEncrypted = UnicodeEncoding.Unicode.GetBytes(value);

        csEncrypt.Write(toBeEncrypted, 0, toBeEncrypted.Length);
        csEncrypt.FlushFinalBlock();
        encryptedBytes = msEncrypt.ToArray();
</code></pre>

<p>The C++ to decrypt it is:</p>

<pre><code>                                    keyBlob.hdr.bType = PLAINTEXTKEYBLOB;
                keyBlob.hdr.bVersion = CUR_BLOB_VERSION;
                keyBlob.hdr.reserved = 0;
                keyBlob.hdr.aiKeyAlg = CALG_AES_256;
                keyBlob.cbKeySize = KEY_SIZE;
                keyBlob.rgbKeyData = &amp;byKey[0];

                if ( CryptImportKey( hProv, (const LPBYTE) &amp;keyBlob, sizeof(BLOBHEADER) + sizeof(DWORD) + KEY_SIZE, 0, CRYPT_EXPORTABLE, &amp;hKey ) )
                {

                    if ( CryptSetKeyParam( hKey, KP_IV, (const BYTE *) &amp;byIV, 0))
                    {
                        DWORD dwLen = iDestLen;
                        if ( CryptDecrypt( hKey, 0, TRUE, 0, pbyData, &amp;dwLen))
                        {

                            if ( dwLen &lt; (DWORD) *plOutSize)
                            {
                                memcpy_s(pbyOutput, *plOutSize, pbyData, dwLen);

                                *plOutSize = dwLen;

                                bRet = TRUE; 
                            }
                        }
                        else
                        {
                            // Log
                            DWORD dwErr = ::GetLastError();
                            int y =0;
                        }
                    }
                }
</code></pre>

<p>I'm calling CryptAcquireContext successfully and my C++ is executing fine.  Can anyone spot the error in my ways.  It's starting to depress me know :(</p>
","<p>Ok my fault, I didn't include the Struct def for the keyblob in the C++ and it turns out you need a contigous block of data for the key with the header but I was using the MSDN example that had a pointer to the key data.  Which is wrong!</p>
","4228","<c#><c++><aes><rijndaelmanaged><rijndael>","0","1","3","2009-11-24 21:00:16","529090","0","","95573","","2009-08-05 17:43:02","2009-02-06 17:20:17",""
"7387080",".Net and PHP Rijndael encryption not matching","<p>At first i thought it was the padding since mcrypt uses zero padding but i changed the php to use PKCS7 and get the same exact results</p>

<p>Can anyone help? I think it has something to do with the padding in the php</p>

<p>Test output from .Net:</p>

<pre><code>Key: d88f92e4fa27f6d45b49446c7fc76976
Text: Testing123
Encrypted: /DMkj7BL9Eu2LMxKhdGT+A==
Encrypted after base64 decode: ?3$??K?K?,?J???
Decrypted: Testing123
</code></pre>

<p>Test output from PHP: </p>

<pre><code>Key: d88f92e4fa27f6d45b49446c7fc76976
Text: Testing123
Encrypted: K+ke5FNI5T6F6B/XvDF494+S8538Ze83cFz6v1FE89U=
Encrypted after base64 decode: +éäSHå&gt;…è×¼1x÷’óüeï7p\ú¿QDóÕ
Decrypted: Testing123����������������������
</code></pre>

<p>PHP:</p>

<pre><code>class rijndael{
var $mcrypt_cipher = MCRYPT_RIJNDAEL_256;
var $mcrypt_mode = MCRYPT_MODE_CBC;
function decrypt($pass, $encrypted)
{
    $encrypted = base64_decode($encrypted);
    $key = $this-&gt;getkey($pass);
    $iv = $this-&gt;getiv($pass);
    $decrypted = mcrypt_decrypt($this-&gt;mcrypt_cipher, $key, $encrypted, $this-&gt;mcrypt_mode, $iv);

    $block = mcrypt_get_block_size($this-&gt;mcrypt_cipher, $this-&gt;mcrypt_mode);
    $pad = ord($decrypted[($len = strlen($decrypted)) - 1]);
    return substr($decrypted, 0, strlen($decrypted) - $pad);

}
function encrypt($pass, $decrypted)
{
    $key = $this-&gt;getkey($pass);
    $iv = $this-&gt;getiv($pass);
    $block = mcrypt_get_block_size($this-&gt;mcrypt_cipher, $this-&gt;mcrypt_mode);
    $pad = $block - (strlen($str) % $block);
    $str .= str_repeat(chr($pad), $pad);
    $encrypted = mcrypt_encrypt($this-&gt;mcrypt_cipher, $key, $decrypted, $this-&gt;mcrypt_mode, $iv);
    return base64_encode($encrypted);
}
function getkey($passphrase)
{
    $L1 = base64_encode(hash(""sha256"", $passphrase, true));
    $L2 = $passphrase.$L1;
    return hash(""sha256"", $L2, true);
}
function getiv($passphrase)
{
    $L1 = base64_encode(md5($passphrase));
    $L2 = $passphrase.$L1;
    return md5($L2);
}
}
</code></pre>

<p>VB .Net:</p>

<pre><code>Public Class RijnDael

    Public Shared Function Decrypt(ByVal sData As String, ByVal sKey As String)
        Dim bytData() As Byte = Encoding.UTF8.GetBytes(sData)
        Return Decrypt(bytData, sKey)
    End Function
    Public Shared Function Decrypt(ByVal bytData As Byte(), ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        Using oRM As New System.Security.Cryptography.RijndaelManaged
            oRM.KeySize = 256
            oRM.Key = GeKey(strPass)
            oRM.IV = GetIV(strPass)
            oRM.Mode = CipherMode.CBC
            oRM.Padding = PaddingMode.PKCS7
            Using oMS As New MemoryStream(bytData)
                Using oCS As New Cryptography.CryptoStream(oMS, oRM.CreateDecryptor, Security.Cryptography.CryptoStreamMode.Read)
                    Dim TempDecryptArr As Byte()
                    ReDim TempDecryptArr(bytData.Length)
                    Dim decryptedByteCount As Integer
                    decryptedByteCount = oCS.Read(TempDecryptArr, 0, bytData.Length)
                    '
                    ReDim bytResult(decryptedByteCount)
                    Array.Copy(TempDecryptArr, bytResult, decryptedByteCount)
                    '
                    oCS.Close()
                End Using
                oMS.Close()
            End Using
        End Using
        Return bytResult
    End Function

    Public Shared Function Encrypt(ByVal sData As String, ByVal sKey As String)
        Dim bytData() As Byte = Encoding.UTF8.GetBytes(sData)
        Return Encrypt(bytData, sKey)
    End Function
    Public Shared Function Encrypt(ByVal bytData As Byte(), ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        Using oRM As New Cryptography.RijndaelManaged
            oRM.KeySize = 256
            oRM.Key = GeKey(strPass)
            oRM.IV = GetIV(strPass)
            oRM.Mode = CipherMode.CBC
            oRM.Padding = PaddingMode.PKCS7
            Using oMS As New MemoryStream
                Using oCS As New Cryptography.CryptoStream(oMS, oRM.CreateEncryptor, Cryptography.CryptoStreamMode.Write)
                    oCS.Write(bytData, 0, bytData.Length)
                    oCS.FlushFinalBlock()
                    bytResult = oMS.ToArray()
                    oCS.Close()
                End Using
                oMS.Close()
            End Using
        End Using
        Return bytResult
    End Function

    Private Shared Function GeKey(ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        'Generate a byte array of required length as the encryption key.
        'A SHA256 hash of the passphrase has just the required length. It is used twice in a manner of self-salting.
        Using oSHA256 As New Cryptography.SHA256Managed
            Dim L1 As String = System.Convert.ToBase64String(oSHA256.ComputeHash(Encoding.UTF8.GetBytes(strPass)))
            Dim L2 As String = strPass &amp; L1
            bytResult = oSHA256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(L2))
            oSHA256.Clear()
        End Using
        Return bytResult
    End Function

    Private Shared Function GetIV(ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        'Generate a byte array of required length as the iv.
        'A MD5 hash of the passphrase has just the required length. It is used twice in a manner of self-salting.
        Using oMD5 As New Cryptography.MD5CryptoServiceProvider
            Dim L1 As String = System.Convert.ToBase64String(oMD5.ComputeHash(Encoding.UTF8.GetBytes(strPass)))
            Dim L2 As String = strPass &amp; L1
            bytResult = oMD5.ComputeHash(System.Text.Encoding.UTF8.GetBytes(L2))
            oMD5.Clear()
        End Using
        Return bytResult
    End Function

End Class
</code></pre>
","<p>For starters the 2 bits of code will create different initialization vectors (PHP is using sha256, and .net md5). And you're not truncating the PHP output by then first null char. There are several potential char set issues in the code too.</p>
","4200","<php><vb.net><encryption><mcrypt><rijndael>","4","3","2","2012-02-12 22:29:43","7391489","0","1","3043","","2012-02-12 22:29:43","2011-09-12 11:22:11",""
"7387080",".Net and PHP Rijndael encryption not matching","<p>At first i thought it was the padding since mcrypt uses zero padding but i changed the php to use PKCS7 and get the same exact results</p>

<p>Can anyone help? I think it has something to do with the padding in the php</p>

<p>Test output from .Net:</p>

<pre><code>Key: d88f92e4fa27f6d45b49446c7fc76976
Text: Testing123
Encrypted: /DMkj7BL9Eu2LMxKhdGT+A==
Encrypted after base64 decode: ?3$??K?K?,?J???
Decrypted: Testing123
</code></pre>

<p>Test output from PHP: </p>

<pre><code>Key: d88f92e4fa27f6d45b49446c7fc76976
Text: Testing123
Encrypted: K+ke5FNI5T6F6B/XvDF494+S8538Ze83cFz6v1FE89U=
Encrypted after base64 decode: +éäSHå&gt;…è×¼1x÷’óüeï7p\ú¿QDóÕ
Decrypted: Testing123����������������������
</code></pre>

<p>PHP:</p>

<pre><code>class rijndael{
var $mcrypt_cipher = MCRYPT_RIJNDAEL_256;
var $mcrypt_mode = MCRYPT_MODE_CBC;
function decrypt($pass, $encrypted)
{
    $encrypted = base64_decode($encrypted);
    $key = $this-&gt;getkey($pass);
    $iv = $this-&gt;getiv($pass);
    $decrypted = mcrypt_decrypt($this-&gt;mcrypt_cipher, $key, $encrypted, $this-&gt;mcrypt_mode, $iv);

    $block = mcrypt_get_block_size($this-&gt;mcrypt_cipher, $this-&gt;mcrypt_mode);
    $pad = ord($decrypted[($len = strlen($decrypted)) - 1]);
    return substr($decrypted, 0, strlen($decrypted) - $pad);

}
function encrypt($pass, $decrypted)
{
    $key = $this-&gt;getkey($pass);
    $iv = $this-&gt;getiv($pass);
    $block = mcrypt_get_block_size($this-&gt;mcrypt_cipher, $this-&gt;mcrypt_mode);
    $pad = $block - (strlen($str) % $block);
    $str .= str_repeat(chr($pad), $pad);
    $encrypted = mcrypt_encrypt($this-&gt;mcrypt_cipher, $key, $decrypted, $this-&gt;mcrypt_mode, $iv);
    return base64_encode($encrypted);
}
function getkey($passphrase)
{
    $L1 = base64_encode(hash(""sha256"", $passphrase, true));
    $L2 = $passphrase.$L1;
    return hash(""sha256"", $L2, true);
}
function getiv($passphrase)
{
    $L1 = base64_encode(md5($passphrase));
    $L2 = $passphrase.$L1;
    return md5($L2);
}
}
</code></pre>

<p>VB .Net:</p>

<pre><code>Public Class RijnDael

    Public Shared Function Decrypt(ByVal sData As String, ByVal sKey As String)
        Dim bytData() As Byte = Encoding.UTF8.GetBytes(sData)
        Return Decrypt(bytData, sKey)
    End Function
    Public Shared Function Decrypt(ByVal bytData As Byte(), ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        Using oRM As New System.Security.Cryptography.RijndaelManaged
            oRM.KeySize = 256
            oRM.Key = GeKey(strPass)
            oRM.IV = GetIV(strPass)
            oRM.Mode = CipherMode.CBC
            oRM.Padding = PaddingMode.PKCS7
            Using oMS As New MemoryStream(bytData)
                Using oCS As New Cryptography.CryptoStream(oMS, oRM.CreateDecryptor, Security.Cryptography.CryptoStreamMode.Read)
                    Dim TempDecryptArr As Byte()
                    ReDim TempDecryptArr(bytData.Length)
                    Dim decryptedByteCount As Integer
                    decryptedByteCount = oCS.Read(TempDecryptArr, 0, bytData.Length)
                    '
                    ReDim bytResult(decryptedByteCount)
                    Array.Copy(TempDecryptArr, bytResult, decryptedByteCount)
                    '
                    oCS.Close()
                End Using
                oMS.Close()
            End Using
        End Using
        Return bytResult
    End Function

    Public Shared Function Encrypt(ByVal sData As String, ByVal sKey As String)
        Dim bytData() As Byte = Encoding.UTF8.GetBytes(sData)
        Return Encrypt(bytData, sKey)
    End Function
    Public Shared Function Encrypt(ByVal bytData As Byte(), ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        Using oRM As New Cryptography.RijndaelManaged
            oRM.KeySize = 256
            oRM.Key = GeKey(strPass)
            oRM.IV = GetIV(strPass)
            oRM.Mode = CipherMode.CBC
            oRM.Padding = PaddingMode.PKCS7
            Using oMS As New MemoryStream
                Using oCS As New Cryptography.CryptoStream(oMS, oRM.CreateEncryptor, Cryptography.CryptoStreamMode.Write)
                    oCS.Write(bytData, 0, bytData.Length)
                    oCS.FlushFinalBlock()
                    bytResult = oMS.ToArray()
                    oCS.Close()
                End Using
                oMS.Close()
            End Using
        End Using
        Return bytResult
    End Function

    Private Shared Function GeKey(ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        'Generate a byte array of required length as the encryption key.
        'A SHA256 hash of the passphrase has just the required length. It is used twice in a manner of self-salting.
        Using oSHA256 As New Cryptography.SHA256Managed
            Dim L1 As String = System.Convert.ToBase64String(oSHA256.ComputeHash(Encoding.UTF8.GetBytes(strPass)))
            Dim L2 As String = strPass &amp; L1
            bytResult = oSHA256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(L2))
            oSHA256.Clear()
        End Using
        Return bytResult
    End Function

    Private Shared Function GetIV(ByVal strPass As String) As Byte()
        Dim bytResult As Byte()
        'Generate a byte array of required length as the iv.
        'A MD5 hash of the passphrase has just the required length. It is used twice in a manner of self-salting.
        Using oMD5 As New Cryptography.MD5CryptoServiceProvider
            Dim L1 As String = System.Convert.ToBase64String(oMD5.ComputeHash(Encoding.UTF8.GetBytes(strPass)))
            Dim L2 As String = strPass &amp; L1
            bytResult = oMD5.ComputeHash(System.Text.Encoding.UTF8.GetBytes(L2))
            oMD5.Clear()
        End Using
        Return bytResult
    End Function

End Class
</code></pre>
","<p>The problems in your two pieces of code are:</p>

<ul>
<li><p>Use <em>Rijndael-128</em> with a key and block size of 16 bytes / 128 bit in both the .NET and the PHP code. For Rijndael-256, your code generates an IV with the wrong length. And I don't know how to use AES-256 in PHP (key length of 32 bytes / 256 bits, block size of 16 bytes / 128 bit).</p></li>
<li><p><em>Use of MD5</em>: In the PHP code, add a second parameter <code>true</code> to the <code>md5()</code> function (in two places) so the result is binary data and not a hexadecimal string.</p></li>
<li><p>In the encrypt() function in your PHP code, replace the variable <code>$str</code> with <code>$decrypted</code> (in two places). <code>$str</code> is never assigned a value and never used, so the padding has no effect.</p></li>
</ul>

<p>If you fix these problems, then both programs will return the result:</p>

<pre><code>Encrypted: /DMkj7BL9Eu2LMxKhdGT+A==
</code></pre>

<p>I haven't tried to decrypt it.</p>
","4200","<php><vb.net><encryption><mcrypt><rijndael>","4","3","2","2012-02-12 22:29:43","7391489","0","1","3043","","2012-02-12 22:29:43","2011-09-12 11:22:11",""
"12165619","Decrypting the .ASPXAUTH Cookie WITH protection=validation","<p>For quite sometime I've been trying to decipher the ASP .ASPXAUTH cookie and decrypt it using PHP.  My reasons are huge and I need to do this, there is no alternative.  In PHP so far I have successfully managed to read the data from this cookie, but I cannot seem to do it while it is encrypted.  Anyway, here it goes...</p>

<p>First you need to alter your servers Web.config file (protection needs to be set to Validation):</p>

<pre><code>    &lt;authentication mode=""None""&gt;
        &lt;forms name="".ASPXAUTH"" protection=""Validation"" cookieless=""UseCookies"" timeout=""10080"" enableCrossAppRedirects=""true""/&gt;
    &lt;/authentication&gt;
</code></pre>

<p>Then in a PHP script on the same domain, you can do the following to read the data, this is a very basic example, but is proof:</p>

<pre><code>$authCookie = $_COOKIE['_ASPXAUTH'];
echo 'ASPXAUTH: '.$authCookie.'&lt;br /&gt;'.""\n"";//This outputs your plaintext hex cookie
$packed = pack(""H*"",$authCookie);
$packed_exp = explode(""\0"",$packed);//This will separate your data using NULL
$random_bytes = array_shift($packed_exp);//This will shift off the random bytes
echo print_r($packed_exp,TRUE); //This will return your cookies data without the random bytes
</code></pre>

<p>This breaks down the cookie, or at least the unencrypted data:</p>

<p><img src=""https://i.stack.imgur.com/PkLxA.jpg"" alt=""http://i.stack.imgur.com/stisu.jpg""></p>

<p>Now that I know I can get the data, I removed the 'protection=""validation""' string from my Web.config and I tried to decrypt it using PHP mcrypt.  I have tried countless methods, but here is a promising example (which fails)...</p>

<pre><code>define('ASP_DECRYPT_KEY','0BC95D748C57F6162519C165E0C5DEB69EA1145676F453AB93DA9645B067DFB8');//This is a decryption key found in my Machine.config file (please note this is forged for example)
$iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC), MCRYPT_RAND);
$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, ASP_DECRYPT_KEY, $authCookie, MCRYPT_MODE_CBC, $iv);//$authCookie is the pack()'d cookie data
</code></pre>

<p>This however fails.  I've tried variations of IV with all zeros @ 16 bytes.  I've tried different Rijndael sizes (128 vs 256).  I've tried base64_decode()ing, nothing seems to work.  I've found this <a href=""https://stackoverflow.com/questions/7387080/net-and-php-rijndael-encryption-not-matching"">stackoverflow post here</a> and started using variations of the key/iv that are made using sha256, but that isn't really working either.</p>

<p>Anybody have a clue what I should do?</p>
","<p>I know what a pain is to decrypt in PHP something encrypted in .NET and vice versa.</p>

<p>I had to end up coding myself the Rijndael algorithm ( translated it from another language ).</p>

<p>Here is the link to the source code of the algorithm: <a href=""http://pastebin.com/EnCJBLSY"" rel=""nofollow"">http://pastebin.com/EnCJBLSY</a></p>

<p>At the end of the source code there is some usage example.</p>

<p>But on .NET, you should use zero padding when encrypting. Also test it with ECB mode, I'm not sure if CBC works.</p>

<p>Good luck and hope it helps</p>

<p><i><b>edit:</b> the algorithm returns the hexadecimal string when encrypts, and also expects hexadecimal string when decrypting.</i></p>
","4167","<php><asp.net><encryption><mcrypt><rijndael>","12","-1","3","2013-06-11 16:20:30","12385616","3","2","-1","","2017-05-23 12:09:42","2012-08-28 18:53:23",""
"12165619","Decrypting the .ASPXAUTH Cookie WITH protection=validation","<p>For quite sometime I've been trying to decipher the ASP .ASPXAUTH cookie and decrypt it using PHP.  My reasons are huge and I need to do this, there is no alternative.  In PHP so far I have successfully managed to read the data from this cookie, but I cannot seem to do it while it is encrypted.  Anyway, here it goes...</p>

<p>First you need to alter your servers Web.config file (protection needs to be set to Validation):</p>

<pre><code>    &lt;authentication mode=""None""&gt;
        &lt;forms name="".ASPXAUTH"" protection=""Validation"" cookieless=""UseCookies"" timeout=""10080"" enableCrossAppRedirects=""true""/&gt;
    &lt;/authentication&gt;
</code></pre>

<p>Then in a PHP script on the same domain, you can do the following to read the data, this is a very basic example, but is proof:</p>

<pre><code>$authCookie = $_COOKIE['_ASPXAUTH'];
echo 'ASPXAUTH: '.$authCookie.'&lt;br /&gt;'.""\n"";//This outputs your plaintext hex cookie
$packed = pack(""H*"",$authCookie);
$packed_exp = explode(""\0"",$packed);//This will separate your data using NULL
$random_bytes = array_shift($packed_exp);//This will shift off the random bytes
echo print_r($packed_exp,TRUE); //This will return your cookies data without the random bytes
</code></pre>

<p>This breaks down the cookie, or at least the unencrypted data:</p>

<p><img src=""https://i.stack.imgur.com/PkLxA.jpg"" alt=""http://i.stack.imgur.com/stisu.jpg""></p>

<p>Now that I know I can get the data, I removed the 'protection=""validation""' string from my Web.config and I tried to decrypt it using PHP mcrypt.  I have tried countless methods, but here is a promising example (which fails)...</p>

<pre><code>define('ASP_DECRYPT_KEY','0BC95D748C57F6162519C165E0C5DEB69EA1145676F453AB93DA9645B067DFB8');//This is a decryption key found in my Machine.config file (please note this is forged for example)
$iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC), MCRYPT_RAND);
$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, ASP_DECRYPT_KEY, $authCookie, MCRYPT_MODE_CBC, $iv);//$authCookie is the pack()'d cookie data
</code></pre>

<p>This however fails.  I've tried variations of IV with all zeros @ 16 bytes.  I've tried different Rijndael sizes (128 vs 256).  I've tried base64_decode()ing, nothing seems to work.  I've found this <a href=""https://stackoverflow.com/questions/7387080/net-and-php-rijndael-encryption-not-matching"">stackoverflow post here</a> and started using variations of the key/iv that are made using sha256, but that isn't really working either.</p>

<p>Anybody have a clue what I should do?</p>
","<p>I don't know how encryption is made in .NET AuthCookies, but I can try to answer.</p>

<p>Assuming the encryption occurs in AES CBC-IV mode, with randomly generated IVs, you need to first find out where the IV is.</p>

<p>The code snippet you show cannot work, as you are generating a random IV (which will be incorrect). That being said, even if you get the IV wrong, in CBC mode you will only have the first 16 bytes of your decrypted ciphertext ""garbled"" and the rest will decrypt properly - you can use this as a test to know if you're doing the rest correctly. In practice when using random IVs, it's very likely that it's prepended to the ciphertext. To check if this correct, you can try to check if len(ciphertext) = len(plaintext) + 16. This would mean that most likely the first 16 bytes are your IV (and therefore it should be removed from the ciphertext before attempting to decrypt it).</p>

<p>Also on your code snippet, it seems you are using the key as an ascii-string, whereas it should be a byte array. Try:</p>

<pre><code>define('ASP_DECRYPT_KEY',hex2bin('0BC95D748C57F6162519C165E0C5DEB69EA1145676F453AB93DA9645B067DFB8'));
</code></pre>

<p>Also, this seems to be a 32 byte key, so you need to use AES-256. I don't know how the authcookie looks like, but if it's base64 encoded, you also need to decode it first obviously.</p>

<p>Hope this helps!</p>

<p>Note: I don't recomment doing this for important production code, however - because there are many things that can go wrong if you try to implement even your own decryption routine as you are doing here. In particular, I would guess there should be a MAC tag somewhere that you <em>have to</em> check before attempting decryption, but there are many other things that can go wrong implementing your own crypto.</p>
","4167","<php><asp.net><encryption><mcrypt><rijndael>","12","5","3","2013-06-11 16:20:30","12385616","3","2","-1","","2017-05-23 12:09:42","2012-08-28 18:53:23",""
"12165619","Decrypting the .ASPXAUTH Cookie WITH protection=validation","<p>For quite sometime I've been trying to decipher the ASP .ASPXAUTH cookie and decrypt it using PHP.  My reasons are huge and I need to do this, there is no alternative.  In PHP so far I have successfully managed to read the data from this cookie, but I cannot seem to do it while it is encrypted.  Anyway, here it goes...</p>

<p>First you need to alter your servers Web.config file (protection needs to be set to Validation):</p>

<pre><code>    &lt;authentication mode=""None""&gt;
        &lt;forms name="".ASPXAUTH"" protection=""Validation"" cookieless=""UseCookies"" timeout=""10080"" enableCrossAppRedirects=""true""/&gt;
    &lt;/authentication&gt;
</code></pre>

<p>Then in a PHP script on the same domain, you can do the following to read the data, this is a very basic example, but is proof:</p>

<pre><code>$authCookie = $_COOKIE['_ASPXAUTH'];
echo 'ASPXAUTH: '.$authCookie.'&lt;br /&gt;'.""\n"";//This outputs your plaintext hex cookie
$packed = pack(""H*"",$authCookie);
$packed_exp = explode(""\0"",$packed);//This will separate your data using NULL
$random_bytes = array_shift($packed_exp);//This will shift off the random bytes
echo print_r($packed_exp,TRUE); //This will return your cookies data without the random bytes
</code></pre>

<p>This breaks down the cookie, or at least the unencrypted data:</p>

<p><img src=""https://i.stack.imgur.com/PkLxA.jpg"" alt=""http://i.stack.imgur.com/stisu.jpg""></p>

<p>Now that I know I can get the data, I removed the 'protection=""validation""' string from my Web.config and I tried to decrypt it using PHP mcrypt.  I have tried countless methods, but here is a promising example (which fails)...</p>

<pre><code>define('ASP_DECRYPT_KEY','0BC95D748C57F6162519C165E0C5DEB69EA1145676F453AB93DA9645B067DFB8');//This is a decryption key found in my Machine.config file (please note this is forged for example)
$iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC), MCRYPT_RAND);
$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, ASP_DECRYPT_KEY, $authCookie, MCRYPT_MODE_CBC, $iv);//$authCookie is the pack()'d cookie data
</code></pre>

<p>This however fails.  I've tried variations of IV with all zeros @ 16 bytes.  I've tried different Rijndael sizes (128 vs 256).  I've tried base64_decode()ing, nothing seems to work.  I've found this <a href=""https://stackoverflow.com/questions/7387080/net-and-php-rijndael-encryption-not-matching"">stackoverflow post here</a> and started using variations of the key/iv that are made using sha256, but that isn't really working either.</p>

<p>Anybody have a clue what I should do?</p>
","<p>I understand this may not have been possible for the OP but for other people heading down this route here is a simple alternative.</p>

<ol>
<li><p>Create a .net web service with a method like:</p>

<p>public FormsAuthenticationTicket DecryptFormsAuthCookie(string ticket)<br>
        {<br>
            return FormsAuthentication.Decrypt(ticket);<br>
        }  </p></li>
<li><p>Pass cookie to web service from PHP:</p>

<p>$authCookie = $_COOKIE['.ASPXAUTH'];<br>
$soapClient = new SoapClient(""http://<code>localhost</code>/Service1.svc?wsdl"");<br>
$params= array(<br>
    ""ticket""  => $authCookie<br>
    );<br>
$result = $soapClient->DecryptFormsAuthCookie($params);</p></li>
</ol>
","4167","<php><asp.net><encryption><mcrypt><rijndael>","12","1","3","2013-06-11 16:20:30","12385616","3","2","-1","","2017-05-23 12:09:42","2012-08-28 18:53:23",""
"10357630","Decrypting Rijndael in Android","<p>I basically need to decrypt a password I retrieve from a server encrypted with Rijndael, I have never worked with encrypting/decrypting before and I am completely lost. I found somewhere in this web that Java has some methods implemented without need of external libraries to do so but I didn't get it. The only thing I need is the decrypt since I won't be writing back into the server anyways.</p>

<p>Any idea on how to do it or where I could find documentation about it?</p>

<p>I don't know if this code, taken from an answer <a href=""https://stackoverflow.com/questions/587357/rijndael-support-in-java"">here</a> is what I am looking for, I don't understand much of it, as I said, I've never worked with this kind of stuff before:</p>

<pre><code>byte[] sessionKey = null; //Where you get this from is beyond the scope of this post
byte[] iv = null ; //Ditto
byte[] plaintext = null; //Whatever you want to encrypt/decrypt
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
//You can use ENCRYPT_MODE or DECRYPT_MODE
cipher.calling init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sessionKey, ""AES""), new IvParameterSpec(iv));
byte[] ciphertext = cipher.doFinal(plaintext);
</code></pre>

<p>Thanks in advance.</p>
","<p>Here is a Simple Crypto utility class that might be of help to you.  Its based on the code written by ferenc.hechler posted at the following url :
<a href=""http://www.androidsnippets.com/encryptdecrypt-strings"" rel=""nofollow"">http://www.androidsnippets.com/encryptdecrypt-strings</a>
I have made some changes to it to fit my needs.</p>

<pre><code>import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class SimpleCrypto {

    private static final int KEY_SIZE = 128;

    public static String encrypt(String seed, String cleartext) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = encrypt(rawKey, cleartext.getBytes());
        return bin2hex(result);
    }

    public static String decrypt(String seed, String encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] enc = toByte(encrypted);
        final byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    public static String decrypt(String seed, byte[] encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = decrypt(rawKey, encrypted);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws NoSuchAlgorithmException {
        final KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        final SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(KEY_SIZE, sr); // 192 and 256 bits may not be available
        final SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    public static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        final byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    public static byte[] decrypt(byte[] raw, byte[] encrypted) throws IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        final byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return bin2hex(txt.getBytes());
    }

    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        final int len = hexString.length() / 2;
        final byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++) {
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
        }
        return result;
    }

    public static byte[] getHash(String str) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance(""SHA-256"");
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        digest.reset();
        return digest.digest(str.getBytes());
    }

    static String bin2hex(byte[] data) {
        return String.format(""%0"" + (data.length * 2) + ""X"", new BigInteger(1, data));
    }
}
</code></pre>

<p>Here is how you would use it to decrypt something :</p>

<pre><code>    final String ssid = ""MY_WIFI_SSID"";
    final String encWifiKey = ""myEncryptedWifiKeyString"";

    String wifiKey = """";
    try {
        wifiKey = new String(SimpleCrypto.decrypt(SimpleCrypto.getHash(ssid), Base64.decode(encWifiKey, Base64.DEFAULT)));
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    }
</code></pre>
","4098","<java><android><encryption><rijndael>","1","0","1","2012-05-10 01:27:18","","7","4","-1","","2017-05-23 11:51:26","2012-04-27 20:47:44",""
"5812232","C# AES Rijndael - detecting invalid passwords","<p>I'm using Rijndael to encrypt some sensitive data in my program.</p>

<p>When the user enters an incorrect password, most of the time a <code>CryptographicException</code> is thrown with the message ""Padding is invalid and cannot be removed."".</p>

<p>However, with very small probability, the CryptStream does not throw an exception with the wrong password, but instead gives back an incorrectly decrypted stream. In other words, it decrypts to garbage.</p>

<p>Any idea how to detect/prevent this? The simplest way I can think of would be to put a ""magic number"" at the start of the message when encrypting, and check if it's still there after decrypting.</p>

<p>But if there's an easier way, I'd love to hear it!</p>
","<p>Checksums are exactly for this purpose. Get a hash of your data before encrypting. Encrypt the data and put it along with the hash into storage. After decrypting, get the hash of the decrypted data and compare it with the former. If you use a crypto grade hash (i.e. SHA512) your data will be safe. After all, this is exactly what encrypted compression software does.</p>

<p>For ultimate security, you can encrypt both the hashes and data separately then decrypt and compare. If both data and hash decrypts to corrupted data, there is very minuscule chances that they will match.</p>
","4044","<c#><encryption><rijndaelmanaged><rijndael><encryption-symmetric>","9","3","6","2019-05-16 07:19:10","5823151","7","1","","","","2011-04-28 00:21:49",""
"5812232","C# AES Rijndael - detecting invalid passwords","<p>I'm using Rijndael to encrypt some sensitive data in my program.</p>

<p>When the user enters an incorrect password, most of the time a <code>CryptographicException</code> is thrown with the message ""Padding is invalid and cannot be removed."".</p>

<p>However, with very small probability, the CryptStream does not throw an exception with the wrong password, but instead gives back an incorrectly decrypted stream. In other words, it decrypts to garbage.</p>

<p>Any idea how to detect/prevent this? The simplest way I can think of would be to put a ""magic number"" at the start of the message when encrypting, and check if it's still there after decrypting.</p>

<p>But if there's an easier way, I'd love to hear it!</p>
","<p>Though I can agree somewhat with Teoman Soygul post about CRC/Hash there is one very important thing to note.  Never encrypt the hash as this can make it easier to find the resulting key.  Even without encrypting the hash you still gave them an easy way to test if they have successfully gained the correct password; however, let's assume that is already possible.  Since I know what kind of data you encrypted, be it text, or serialized objects, or whatever, it's likely I can write code to recognize it.</p>

<p>That said, I've used derivations of the following code to encrypt/decrypt data:</p>

<pre><code>    static void Main()
    {
        byte[] test = Encrypt(Encoding.UTF8.GetBytes(""Hello World!""), ""My Product Name and/or whatever constant"", ""password"");
        Console.WriteLine(Convert.ToBase64String(test));
        string plain = Encoding.UTF8.GetString(Decrypt(test, ""My Product Name and/or whatever constant"", ""passwords""));
        Console.WriteLine(plain);
    }
    public static byte[] Encrypt(byte[] data, string iv, string password)
    {
        using (RijndaelManaged m = new RijndaelManaged())
        using (SHA256Managed h = new SHA256Managed())
        {
            m.KeySize = 256;
            m.BlockSize = 256;
            byte[] hash = h.ComputeHash(data);
            byte[] salt = new byte[32];
            new RNGCryptoServiceProvider().GetBytes(salt);
            m.IV = h.ComputeHash(Encoding.UTF8.GetBytes(iv));
            m.Key = new Rfc2898DeriveBytes(password, salt) { IterationCount = 10000 }.GetBytes(32);

            using (MemoryStream ms = new MemoryStream())
            {
                ms.Write(hash, 0, hash.Length);
                ms.Write(salt, 0, salt.Length);
                using (CryptoStream cs = new CryptoStream(ms, m.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(data, 0, data.Length);
                    cs.FlushFinalBlock();
                    return ms.ToArray();
                }
            }
        }
    }

    public static byte[] Decrypt(byte[] data, string iv, string password)
    {
        using (MemoryStream ms = new MemoryStream(data, false))
        using (RijndaelManaged m = new RijndaelManaged())
        using (SHA256Managed h = new SHA256Managed())
        {
            try
            {
                m.KeySize = 256;
                m.BlockSize = 256;

                byte[] hash = new byte[32];
                ms.Read(hash, 0, 32);
                byte[] salt = new byte[32];
                ms.Read(salt, 0, 32);

                m.IV = h.ComputeHash(Encoding.UTF8.GetBytes(iv));
                m.Key = new Rfc2898DeriveBytes(password, salt) { IterationCount = 10000 }.GetBytes(32);
                using (MemoryStream result = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, m.CreateDecryptor(), CryptoStreamMode.Read))
                    {
                        byte[] buffer = new byte[1024];
                        int len;
                        while ((len = cs.Read(buffer, 0, buffer.Length)) &gt; 0)
                            result.Write(buffer, 0, len);
                    }

                    byte[] final = result.ToArray();
                    if (Convert.ToBase64String(hash) != Convert.ToBase64String(h.ComputeHash(final)))
                        throw new UnauthorizedAccessException();

                    return final;
                }
            }
            catch
            {
                //never leak the exception type...
                throw new UnauthorizedAccessException();
            }
        }
    }
</code></pre>
","4044","<c#><encryption><rijndaelmanaged><rijndael><encryption-symmetric>","9","0","6","2019-05-16 07:19:10","5823151","7","1","","","","2011-04-28 00:21:49",""
"5812232","C# AES Rijndael - detecting invalid passwords","<p>I'm using Rijndael to encrypt some sensitive data in my program.</p>

<p>When the user enters an incorrect password, most of the time a <code>CryptographicException</code> is thrown with the message ""Padding is invalid and cannot be removed."".</p>

<p>However, with very small probability, the CryptStream does not throw an exception with the wrong password, but instead gives back an incorrectly decrypted stream. In other words, it decrypts to garbage.</p>

<p>Any idea how to detect/prevent this? The simplest way I can think of would be to put a ""magic number"" at the start of the message when encrypting, and check if it's still there after decrypting.</p>

<p>But if there's an easier way, I'd love to hear it!</p>
","<p>HMAC is what you need. It is exactly made for this purpose. It combines the key and the message (which in this case, will be your password) and hashes them in a way that it will ensure the authenticity and integrity of the content, as long as the hash function used is secure. You can attach the HMAC to the encrypted data, and it can be used later to validate if the decryption was made correctly.</p>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/HMAC"" rel=""noreferrer"">HMAC, Wikipedia</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.hmac.aspx"" rel=""noreferrer"">System.Security.Cryptography.HMAC</a></li>
</ul>
","4044","<c#><encryption><rijndaelmanaged><rijndael><encryption-symmetric>","9","6","6","2019-05-16 07:19:10","5823151","7","1","","","","2011-04-28 00:21:49",""
"5812232","C# AES Rijndael - detecting invalid passwords","<p>I'm using Rijndael to encrypt some sensitive data in my program.</p>

<p>When the user enters an incorrect password, most of the time a <code>CryptographicException</code> is thrown with the message ""Padding is invalid and cannot be removed."".</p>

<p>However, with very small probability, the CryptStream does not throw an exception with the wrong password, but instead gives back an incorrectly decrypted stream. In other words, it decrypts to garbage.</p>

<p>Any idea how to detect/prevent this? The simplest way I can think of would be to put a ""magic number"" at the start of the message when encrypting, and check if it's still there after decrypting.</p>

<p>But if there's an easier way, I'd love to hear it!</p>
","<p>I like <a href=""https://stackoverflow.com/questions/5812232/c-aes-rijndael-detecting-invalid-passwords/5823151#5823151"">Can Gencer's answer</a>; you cannot really verify a decryption without the HMAC. </p>

<p>But, if you have a very a very large plaintext, then the decrypting can be very expensive. You might do a ton of work just to find out that the password was invalid. It would be nice to be able to do a quick rejection of wrong passwords, without going through all that work.  There is a way using the <a href=""http://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow noreferrer"">PKCS#5 PBKDF2</a>. (standardized in <a href=""http://www.faqs.org/rfcs/rfc2898.html"" rel=""nofollow noreferrer"">RFC2898</a>, which is accessible to your c# program in <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.aspx"" rel=""nofollow noreferrer"">Rfc2898DeriveBytes</a>).  </p>

<p>Normally the data protocol calls for generation of the key from a password and salt using PBKDF2, at 1000 cycles or some specified number. Then maybe also (optionally) the initialization vector, via a contniuation of the same algorithm.  </p>

<p>To implement the quick password check, generate <em>two more bytes</em> via the PBKDF2. If you don't generate and use an IV, then just generate 32 bytes and keep the last 2.  Store or transmit this pair of bytes adjacent to your cryptotext.  On the decrypting side, get the password, generate the key and (maybe throwaway) IV, then generate the 2 additional bytes, and check them against the stored data.  If the pairs don't match you <em>know</em> you have a wrong password, without any decryption. </p>

<p>If they match, it is not a guarantee that the password is correct. You still need the HMAC of the full plaintext for that. But you can save yourself a ton of work, and maybe wall clock time, in most cases of ""wrong password"", and without compromising the security of the overall system. </p>

<hr>

<p><em>ps</em>:  you wrote: </p>

<blockquote>
  <p>The simplest way I can think of would be to put a ""magic number"" at the start of the message when encrypting, and check if it's still there after decrypting.</p>
</blockquote>

<p>Avoid putting plaintext into the cryptotext. It only exposes another attack vector, makes it easier for an attacker to eliminate wrong turns.  The password verification thing I mentioned above is a different animal, does not expose this risk.  </p>
","4044","<c#><encryption><rijndaelmanaged><rijndael><encryption-symmetric>","9","-1","6","2019-05-16 07:19:10","5823151","7","1","","","","2011-04-28 00:21:49",""
"5812232","C# AES Rijndael - detecting invalid passwords","<p>I'm using Rijndael to encrypt some sensitive data in my program.</p>

<p>When the user enters an incorrect password, most of the time a <code>CryptographicException</code> is thrown with the message ""Padding is invalid and cannot be removed."".</p>

<p>However, with very small probability, the CryptStream does not throw an exception with the wrong password, but instead gives back an incorrectly decrypted stream. In other words, it decrypts to garbage.</p>

<p>Any idea how to detect/prevent this? The simplest way I can think of would be to put a ""magic number"" at the start of the message when encrypting, and check if it's still there after decrypting.</p>

<p>But if there's an easier way, I'd love to hear it!</p>
","<pre><code> Public Sub decryptFile(ByVal input As String, ByVal output As String)

        inputFile = New FileStream(input, FileMode.Open, FileAccess.Read)
        outputFile = New FileStream(output, FileMode.OpenOrCreate, FileAccess.Write)
        outputFile.SetLength(0)

        Dim buffer(4096) As Byte
        Dim bytesProcessed As Long = 0
        Dim fileLength As Long = inputFile.Length
        Dim bytesInCurrentBlock As Integer
        Dim rijandael As New RijndaelManaged
        Dim cryptoStream As CryptoStream = New CryptoStream(outputFile, rijandael.CreateDecryptor(encryptionKey, encryptionIV), CryptoStreamMode.Write)

        While bytesProcessed &lt; fileLength
            bytesInCurrentBlock = inputFile.Read(buffer, 0, 4096)
            cryptoStream.Write(buffer, 0, bytesInCurrentBlock)
            bytesProcessed = bytesProcessed + CLng(bytesInCurrentBlock)
        End While
        Try
            cryptoStream.Close() 'this will raise error if wrong password used
            inputFile.Close()
            outputFile.Close()
            File.Delete(input)
            success += 1
        Catch ex As Exception
            fail += 1
            inputFile.Close()
            outputFile.Close()
            outputFile = Nothing
            File.Delete(output)
        End Try
</code></pre>

<p>I use that code to decrypt any file. Wrong password detected on <code>cryptostream.close()</code>. Catch this line as error when a wrong key is used to decrypt file. When error happens, just close the output stream and release it (set <code>outputFile</code> to <code>Nothing</code>), then delete output file. It's working for me.</p>
","4044","<c#><encryption><rijndaelmanaged><rijndael><encryption-symmetric>","9","-1","6","2019-05-16 07:19:10","5823151","7","1","","","","2011-04-28 00:21:49",""
"5812232","C# AES Rijndael - detecting invalid passwords","<p>I'm using Rijndael to encrypt some sensitive data in my program.</p>

<p>When the user enters an incorrect password, most of the time a <code>CryptographicException</code> is thrown with the message ""Padding is invalid and cannot be removed."".</p>

<p>However, with very small probability, the CryptStream does not throw an exception with the wrong password, but instead gives back an incorrectly decrypted stream. In other words, it decrypts to garbage.</p>

<p>Any idea how to detect/prevent this? The simplest way I can think of would be to put a ""magic number"" at the start of the message when encrypting, and check if it's still there after decrypting.</p>

<p>But if there's an easier way, I'd love to hear it!</p>
","<p>To check if the password you are using is correct, you can use this code</p>

<pre><code>            Dim decryptedByteCount As Integer
            Try
                decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length)
            Catch exp As System.Exception
                Return ""Password Not Correct""
            End Try
</code></pre>

<p>in essence, check if an error message is generated during decryption.</p>

<p>I report all the decoding code below</p>

<pre><code>    Public Shared Function Decrypt(ByVal cipherText As String) As String

    If System.Web.HttpContext.Current.Session(""Crypto"") = """" Then
        HttpContext.Current.Response.Redirect(""http://yoursite.com"")
    Else
        If cipherText &lt;&gt; """" Then
            'Setto la password per criptare il testo
            Dim passPhrase As String = System.Web.HttpContext.Current.Session(""Crypto"")

            'Ottieni lo stream completo di byte che rappresentano: [32 byte di Salt] + [32 byte di IV] + [n byte di testo cifrato]
            Dim cipherTextBytesWithSaltAndIv = Convert.FromBase64String(cipherText)

            'Ottieni i Salt bytes estraendo i primi 32 byte dai byte di testo cifrato forniti
            Dim saltStringBytes = cipherTextBytesWithSaltAndIv.Take((Keysize)).ToArray

            'Ottieni i IV byte estraendo i successivi 32 byte dai byte testo cifrato forniti.
            Dim ivStringBytes = cipherTextBytesWithSaltAndIv.Skip((Keysize)).Take((Keysize)).ToArray

            'Ottieni i byte del testo cifrato effettivo rimuovendo i primi 64 byte dal testo cifrato.
            Dim cipherTextBytes = cipherTextBytesWithSaltAndIv.Skip(((Keysize) * 2)).Take((cipherTextBytesWithSaltAndIv.Length - ((Keysize) * 2))).ToArray

            Dim password = New Rfc2898DeriveBytes(passPhrase, saltStringBytes, DerivationIterations)
            Dim keyBytes = password.GetBytes((Keysize))
            Dim symmetricKey = New RijndaelManaged
            symmetricKey.BlockSize = 256
            symmetricKey.Mode = CipherMode.CBC
            symmetricKey.Padding = PaddingMode.PKCS7

            Dim decryptor = symmetricKey.CreateDecryptor(keyBytes, ivStringBytes)
            Dim memoryStream = New MemoryStream(cipherTextBytes)
            Dim cryptoStream = New CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read)
            Dim plainTextBytes = New Byte((cipherTextBytes.Length) - 1) {}

            Dim decryptedByteCount As Integer
            Try
                decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length)
            Catch exp As System.Exception
                Return ""La password di Cryptazione non è corretta""
            End Try

            memoryStream.Close()
            cryptoStream.Close()
            Return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount)
        Else
            Decrypt = """"
        End If
    End If

End Function
</code></pre>
","4044","<c#><encryption><rijndaelmanaged><rijndael><encryption-symmetric>","9","1","6","2019-05-16 07:19:10","5823151","7","1","","","","2011-04-28 00:21:49",""
"31432218","MCRYPT_RIJNDAEL_256 PHP Encryption in Java","<p>I have the following source code provided by DHL that performs MCRYPT_RIJNDAEL_256 and MCRYPT_RIJNDAEL_128 encryption in PHP:</p>

<pre><code>&lt;?php
    function encrypt_128($data, $key) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_ECB));
    }

    function encrypt_256($data, $key) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $data, MCRYPT_MODE_ECB));
    }

    $data = ""sellerid=Company&amp;returnsreference=0003&amp;contents_value=101&amp;contents_description=clothes&amp;fullname=Joe%20Bloggs&amp;company=Company&amp;email=joe.bloggs@gmail.com&amp;email_confirm=joe.bloggs@gmail.com&amp;telephone=123&amp;address_line_1=1&amp;city=Acampo&amp;postcode=952200001&amp;country_code=US&amp;weight=1&amp;height=2&amp;length=3&amp;width=4"";
    $key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
    echo '128:' . PHP_EOL;
    echo encrypt_128($data, $key) . PHP_EOL;
    echo PHP_EOL;
    echo '256:' . PHP_EOL;
    echo encrypt_256($data, $key) . PHP_EOL;
    echo PHP_EOL;
?&gt;
</code></pre>

<p>Which outputs:</p>

<pre><code>128:
AEt1OHf8hjEnQYeJq07qIxj1j8M0Tyzbg4/5NCwzMwIAA72SecGEdi4XoxwXlgpTbNRyum642KVM3POo2pcPPiRiA6+WPEf6XB0eTAzIUVp8yt2Ibjk83SsNVHCK7n4lR5wXICQ4Go/zFdz68Uwc2Y2mu3SCdiferc2noyhLaInEtej8Q8yF2NwwsZreLtf/6zM7S4RKR6SDa7G2EM3wu0FjOhcyA+6HaTpl+3ZFSdMs5YwqksZjWD5SYQskVXks5y4wtw++sduJ77p2iMe/bLdIAtNwgwLHty9y7jFellxlWMeWmysmyYFNUPaoUPbXM4kDlBle3jz4sjpLiUdjQdLJIfCN6UWyQf47vFzxubt3IfsbiqHU2Qo9mHb7WQh4vtPC+U3wjM9kzV9eXcMCRQ==

256:
BUMVdaCQoce//aQWEsMgSHNRsWVPvi02ljCtF1PUfEA8Wm0tTZ6EUBEGsAiTOSINwiWikaoGm5jyBRaajHgtgj4y/7R8t5KkxEwM5H9iU/X56c8H65p3pV2P7wNayLiu5eUcLJBXb+siqCCi2VFETgGOMC8o9zjXPQ0oNCYYy5+tT2NGxSGebjM7XMIOAkIKCKvSbF+lUdxPRS1vs5ILuvzx9LP4+461ZYGYmmDKX35qPbCnsx8xaYkXnhAO8W1ddm1ylcanyAFWb2hk6UUmS7SGpSmJMAVwyUDT2uFxaizL4Z6p+KeBRgjPW2i9b5gC/MpjphJO4IKhTqKfHwziinYQ6FZOtDKtD7JC8om1kINpaMIZEHLXHEHF/iuqRbaFcH+M1Qph4Uu95d0eJ0x1A2rs2zRdlWVR72RHVIWez0w=
</code></pre>

<p>I need to perform 256 bit Rijndael encryption in Java. I have written the following code:</p>

<pre><code>import org.apache.commons.codec.binary.Base64;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;

public class Encrypt {
    public static byte[] ivBytes = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    public static void main(String[] args) throws InvalidKeyException, UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        String data = ""sellerid=Company&amp;returnsreference=0003&amp;contents_value=101&amp;contents_description=clothes&amp;fullname=Joe%20Bloggs&amp;company=Company&amp;email=joe.bloggs@gmail.com&amp;email_confirm=joe.bloggs@gmail.com&amp;telephone=123&amp;address_line_1=1&amp;city=Acampo&amp;postcode=952200001&amp;country_code=US&amp;weight=1&amp;height=2&amp;length=3&amp;width=4"";
        String key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
        String encoded = encode(data, key);
        System.out.println(""Encoded: "" + encoded);
        String decoded = decode(encoded, key);
        System.out.println(""Decoded: "" + decoded);
    }

    public static String encode(String data, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] textBytes = data.getBytes(""UTF-8"");
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
        return Base64.encodeBase64String(cipher.doFinal(textBytes));
    }

    public static String decode(String data, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] textBytes = Base64.decodeBase64(data);
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
        return new String(cipher.doFinal(textBytes), ""UTF-8"");
    }
}
</code></pre>

<p>Which is outputting:</p>

<pre><code>Encoded: AEt1OHf8hjEnQYeJq07qIxtV0c4Zcfro0Yidrx/rb91OBcbyZ1RZ5id7dYCVhJe4WUvIb2OWyOVDqeVu7cHkM7zHrxRoY5hyQDWKsj4BIuxqxKO0grLYRgqQ2MZtm23D5Ko23h5sJetEYsKI1AxeXJLPQmUDB+RecELIDzJparWto9UcU6llik/v8ZX7DDmrg6K57xaSlCKWVkCKI2HivblAYwTirh7D9n/hO46c3MLngM1/Ao32S1y2XwkNX8k7PTFce5M6BLsDlzoZKjkv+t8n8GTAPPLheC0z9iLBHQbEs2WhzVY4UoCNStITWitn6QI9EwCuVX7oRVlQMi2pqow0GaGwFJ3kqGn5nbXlrbc5Lg4G8SUnM1NB01LbIEBVnVuzXQg8y+Zam47uMJ/0iQ==
Decoded: sellerid=Company&amp;returnsreference=0003&amp;contents_value=101&amp;contents_description=clothes&amp;fullname=Joe%20Bloggs&amp;company=Company&amp;email=joe.bloggs@gmail.com&amp;email_confirm=joe.bloggs@gmail.com&amp;telephone=123&amp;address_line_1=1&amp;city=Acampo&amp;postcode=952200001&amp;country_code=US&amp;weight=1&amp;height=2&amp;length=3&amp;width=4
</code></pre>

<p>i.e. It is encrypting it with 128 bit encryption. How do I get 256 bit Rijndael encryption?</p>
","<p>Found the solution from Artjom.</p>

<pre><code>import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.RijndaelEngine;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.paddings.ZeroBytePadding;
import org.bouncycastle.crypto.params.KeyParameter;

import java.nio.charset.Charset;

public class Encrypt {
    public static void main(String[] args) throws InvalidCipherTextException {
        String key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
        String data = ""sellerid=Company&amp;returnsreference=0003&amp;contents_value=101&amp;contents_description=clothes&amp;fullname=Joe%20Bloggs&amp;company=Company&amp;email=joe.bloggs@gmail.com&amp;email_confirm=joe.bloggs@gmail.com&amp;telephone=123&amp;address_line_1=1&amp;city=Acampo&amp;postcode=952200001&amp;country_code=US&amp;weight=1&amp;height=2&amp;length=3&amp;width=4"";
        encrypt(key, data);
    }

    private static void encrypt(String key, String data) throws InvalidCipherTextException {
        byte[] givenKey = key.getBytes(Charset.forName(""ASCII""));
        final int keysize = 256;
        byte[] keyData = new byte[keysize / Byte.SIZE];
        System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
        KeyParameter keyParameter = new KeyParameter(keyData);
        BlockCipher rijndael = new RijndaelEngine(256);
        ZeroBytePadding c = new ZeroBytePadding();
        PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);
        pbbc.init(true, keyParameter);
        byte[] plaintext = data.getBytes(Charset.forName(""UTF8""));
        byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];
        int offset = 0;
        offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
        offset += pbbc.doFinal(ciphertext, offset);
        System.out.println(""Encrypted: "" + Base64.encodeBase64String(ciphertext));
    }
}
</code></pre>

<p>This prints out the following:</p>

<pre><code>Encrypted: BUMVdaCQoce//aQWEsMgSHNRsWVPvi02ljCtF1PUfEA8Wm0tTZ6EUBEGsAiTOSINwiWikaoGm5jyBRaajHgtgj4y/7R8t5KkxEwM5H9iU/X56c8H65p3pV2P7wNayLiu5eUcLJBXb+siqCCi2VFETgGOMC8o9zjXPQ0oNCYYy5+tT2NGxSGebjM7XMIOAkIKCKvSbF+lUdxPRS1vs5ILuvzx9LP4+461ZYGYmmDKX35qPbCnsx8xaYkXnhAO8W1ddm1ylcanyAFWb2hk6UUmS7SGpSmJMAVwyUDT2uFxaizL4Z6p+KeBRgjPW2i9b5gC/MpjphJO4IKhTqKfHwziinYQ6FZOtDKtD7JC8om1kINpaMIZEHLXHEHF/iuqRbaFcH+M1Qph4Uu95d0eJ0x1A2rs2zRdlWVR72RHVIWez0w=
</code></pre>
","3932","<java><php><encryption><rijndael>","2","3","1","2015-07-15 14:50:09","","0","3","","","","2015-07-15 13:45:35","2015-07-15 15:23:50"
"7308663","Is it possible to NOT use the IV when implementing Rijndael decryption?","<p>I am implementing a decryption of ciphertext using Rijndael's algorithm. Unfortunately, I have not got access to the encryption of the data and have only been provided with a password (to generate the key with) and the type of algorithm.</p>

<p>I do not have a salt (which seems to be ok), and I do not have the IV. Now, my question is whether I absolutely have to have the IV in order to perform decryption? I suspect the developers who wrote the encryption made no use of salt, or IV (if this is even possible).</p>

<p>I have tried to set the IV to null, with no luck, and generating a Rijndael instance creates a default IV, and this is distorting the first 16 characters of my plaintext after decryption. </p>

<p>Is there any way to negate the effect of the IV? Or do a need to try and get hold of what IV was used in the encryption?</p>
","<p>If the cipher has been used to encrypt in CBC mode (which <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.mode.aspx"" rel=""nofollow"">is the default</a>) then you have to know the IV, there's no way around it.</p>

<p>However, since the purpose of the IV is not the same as the purpose of the password, sometimes you find the IV prepended to the encrypted data (so that the recipient can easily grab it to use when decrypting).</p>
","3929","<c#><encryption><rijndael>","4","3","3","2016-05-17 06:39:35","7308701","4","3","","","","2011-09-05 13:17:11",""
"7308663","Is it possible to NOT use the IV when implementing Rijndael decryption?","<p>I am implementing a decryption of ciphertext using Rijndael's algorithm. Unfortunately, I have not got access to the encryption of the data and have only been provided with a password (to generate the key with) and the type of algorithm.</p>

<p>I do not have a salt (which seems to be ok), and I do not have the IV. Now, my question is whether I absolutely have to have the IV in order to perform decryption? I suspect the developers who wrote the encryption made no use of salt, or IV (if this is even possible).</p>

<p>I have tried to set the IV to null, with no luck, and generating a Rijndael instance creates a default IV, and this is distorting the first 16 characters of my plaintext after decryption. </p>

<p>Is there any way to negate the effect of the IV? Or do a need to try and get hold of what IV was used in the encryption?</p>
","<p>If it was encrypted with an IV, then yes, you will need the IV in order to correctly decrypt.</p>

<p>From your description about the first 16 characters, it sounds like you're working in CBC mode.  See the diagram here for why you'll need the IV: <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29"" rel=""nofollow"">http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29</a>.</p>
","3929","<c#><encryption><rijndael>","4","1","3","2016-05-17 06:39:35","7308701","4","3","","","","2011-09-05 13:17:11",""
"7308663","Is it possible to NOT use the IV when implementing Rijndael decryption?","<p>I am implementing a decryption of ciphertext using Rijndael's algorithm. Unfortunately, I have not got access to the encryption of the data and have only been provided with a password (to generate the key with) and the type of algorithm.</p>

<p>I do not have a salt (which seems to be ok), and I do not have the IV. Now, my question is whether I absolutely have to have the IV in order to perform decryption? I suspect the developers who wrote the encryption made no use of salt, or IV (if this is even possible).</p>

<p>I have tried to set the IV to null, with no luck, and generating a Rijndael instance creates a default IV, and this is distorting the first 16 characters of my plaintext after decryption. </p>

<p>Is there any way to negate the effect of the IV? Or do a need to try and get hold of what IV was used in the encryption?</p>
","<p>You can use the ECB mode and it will ignore the IV. You need an IV for other modes like CBC, though.</p>
","3929","<c#><encryption><rijndael>","4","3","3","2016-05-17 06:39:35","7308701","4","3","","","","2011-09-05 13:17:11",""
"4508646","Rijndael alternative for Linux","<p>I have a project in c#, Windows that uses Rijndael object.</p>

<p>I'm suppoesd to write it in c++,Linux.</p>

<p>I understood that I'm supposed to use openssl/aes, but couldn't figure out how.</p>

<p>What are the includes? what is the class name? the methods?</p>

<p>what should I use instead of: Rijndael.create(), Rijndael.KeySize(),Rijndael.IV(), etc.</p>

<p>Thanks in Advance.</p>

<p>Sara</p>
","<p>Example source code is available <a href=""http://saju.net.in/blog/?p=36"" rel=""nofollow"">here</a>. Make sure you link with <code>-lcrypto</code>.</p>

<p>EDIT the link currently does not work; I copy the source from <a href=""http://web.archive.org/web/20140802152721/http://saju.net.in/blog/?p=36"" rel=""nofollow"">an archive</a>:</p>

<pre><code>/**
  AES encryption/decryption demo program using OpenSSL EVP apis
  gcc -Wall openssl_aes.c -lcrypto

  this is public domain code. 

  Saju Pillai (saju.pillai@gmail.com)
**/

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/evp.h&gt;

/**
 * Create an 256 bit key and IV using the supplied key_data. salt can be added for taste.
 * Fills in the encryption and decryption ctx objects and returns 0 on success
 **/
int aes_init(unsigned char *key_data, int key_data_len, unsigned char *salt, EVP_CIPHER_CTX *e_ctx, 
         EVP_CIPHER_CTX *d_ctx)
{
  int i, nrounds = 5;
  unsigned char key[32], iv[32];

  /*
   * Gen key &amp; IV for AES 256 CBC mode. A SHA1 digest is used to hash the supplied key material.
   * nrounds is the number of times the we hash the material. More rounds are more secure but
   * slower.
   */
  i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha1(), salt, key_data, key_data_len, nrounds, key, iv);
  if (i != 32) {
    printf(""Key size is %d bits - should be 256 bits\n"", i);
    return -1;
  }

  EVP_CIPHER_CTX_init(e_ctx);
  EVP_EncryptInit_ex(e_ctx, EVP_aes_256_cbc(), NULL, key, iv);
  EVP_CIPHER_CTX_init(d_ctx);
  EVP_DecryptInit_ex(d_ctx, EVP_aes_256_cbc(), NULL, key, iv);

  return 0;
}

/*
 * Encrypt *len bytes of data
 * All data going in &amp; out is considered binary (unsigned char[])
 */
unsigned char *aes_encrypt(EVP_CIPHER_CTX *e, unsigned char *plaintext, int *len)
{
  /* max ciphertext len for a n bytes of plaintext is n + AES_BLOCK_SIZE -1 bytes */
  int c_len = *len + AES_BLOCK_SIZE, f_len = 0;
  unsigned char *ciphertext = malloc(c_len);

  /* allows reusing of 'e' for multiple encryption cycles */
  EVP_EncryptInit_ex(e, NULL, NULL, NULL, NULL);

  /* update ciphertext, c_len is filled with the length of ciphertext generated,
    *len is the size of plaintext in bytes */
  EVP_EncryptUpdate(e, ciphertext, &amp;c_len, plaintext, *len);

  /* update ciphertext with the final remaining bytes */
  EVP_EncryptFinal_ex(e, ciphertext+c_len, &amp;f_len);

  *len = c_len + f_len;
  return ciphertext;
}

/*
 * Decrypt *len bytes of ciphertext
 */
unsigned char *aes_decrypt(EVP_CIPHER_CTX *e, unsigned char *ciphertext, int *len)
{
  /* because we have padding ON, we must allocate an extra cipher block size of memory */
  int p_len = *len, f_len = 0;
  unsigned char *plaintext = malloc(p_len + AES_BLOCK_SIZE);

  EVP_DecryptInit_ex(e, NULL, NULL, NULL, NULL);
  EVP_DecryptUpdate(e, plaintext, &amp;p_len, ciphertext, *len);
  EVP_DecryptFinal_ex(e, plaintext+p_len, &amp;f_len);

  *len = p_len + f_len;
  return plaintext;
}

int main(int argc, char **argv)
{
  /* ""opaque"" encryption, decryption ctx structures that libcrypto uses to record
     status of enc/dec operations */
  EVP_CIPHER_CTX en, de;

  /* 8 bytes to salt the key_data during key generation. This is an example of
     compiled in salt. We just read the bit pattern created by these two 4 byte 
     integers on the stack as 64 bits of contigous salt material - 
     ofcourse this only works if sizeof(int) &gt;= 4 */
  unsigned int salt[] = {12345, 54321};
  unsigned char *key_data;
  int key_data_len, i;
  char *input[] = {""a"", ""abcd"", ""this is a test"", ""this is a bigger test"", 
               ""\nWho are you ?\nI am the 'Doctor'.\n'Doctor' who ?\nPrecisely!"",
               NULL};

  /* the key_data is read from the argument list */
  key_data = (unsigned char *)argv[1];
  key_data_len = strlen(argv[1]);

  /* gen key and iv. init the cipher ctx object */
  if (aes_init(key_data, key_data_len, (unsigned char *)&amp;salt, &amp;en, &amp;de)) {
    printf(""Couldn't initialize AES cipher\n"");
    return -1;
  }

  /* encrypt and decrypt each input string and compare with the original */
  for (i = 0; input[i]; i++) {
    char *plaintext;
    unsigned char *ciphertext;
    int olen, len;

    /* The enc/dec functions deal with binary data and not C strings. strlen() will 
       return length of the string without counting the '\0' string marker. We always
       pass in the marker byte to the encrypt/decrypt functions so that after decryption 
       we end up with a legal C string */
    olen = len = strlen(input[i])+1;

    ciphertext = aes_encrypt(&amp;en, (unsigned char *)input[i], &amp;len);
    plaintext = (char *)aes_decrypt(&amp;de, ciphertext, &amp;len);

    if (strncmp(plaintext, input[i], olen)) 
      printf(""FAIL: enc/dec failed for \""%s\""\n"", input[i]);
    else 
      printf(""OK: enc/dec ok for \""%s\""\n"", plaintext);

    free(ciphertext);
    free(plaintext);
  }

  EVP_CIPHER_CTX_cleanup(&amp;en);
  EVP_CIPHER_CTX_cleanup(&amp;de);

  return 0;
}
</code></pre>
","3859","<c++><linux><encryption><openssl><rijndael>","1","1","2","2015-12-11 14:52:00","4508723","0","","","","","2010-12-22 11:21:53",""
"4508646","Rijndael alternative for Linux","<p>I have a project in c#, Windows that uses Rijndael object.</p>

<p>I'm suppoesd to write it in c++,Linux.</p>

<p>I understood that I'm supposed to use openssl/aes, but couldn't figure out how.</p>

<p>What are the includes? what is the class name? the methods?</p>

<p>what should I use instead of: Rijndael.create(), Rijndael.KeySize(),Rijndael.IV(), etc.</p>

<p>Thanks in Advance.</p>

<p>Sara</p>
","<p>have a look at <a href=""http://www.cryptopp.com/"" rel=""nofollow"">cryptopp</a>. They have Rijndael (AES) ""raw"" and in block modes (CBC etc.). Look at their wiki documentation, they have many code samples.</p>

<p>It is a popular crypto library, they have also a Windows version, so you can use on both platforms. If you wish to keep your current implementation on Windows, you may want to have your custom wrapper, so that you can choose an underlying implementation on each platform.</p>

<p><strong>EDIT</strong>: a sample from my code</p>

<pre><code>using namespace CryptoPP;

CBC_Mode&lt; CryptoPP::AES &gt;::Encryption encryptor;

std::string clearText(""hello world"");
std::string encrypted;

StringSource( clearText, true,
    new StreamTransformationFilter( encryptor,
        new StringSink( encrypted )
    )
);
</code></pre>
","3859","<c++><linux><encryption><openssl><rijndael>","1","4","2","2015-12-11 14:52:00","4508723","0","","","","","2010-12-22 11:21:53",""
"11595389","Rijndael 128 Encrypt/decrypt between vb.net and php","<p><strong>EDIT:</strong></p>

<p>sorry for this question, i solved it immediately by myself ...
the only thing i had to do was to set the padding to zeros:</p>

<pre><code>aes.Padding = PaddingMode.Zeros
</code></pre>

<p>i am trying to encrypt the traffic between my VB.Net Application without SSL (cause the user should not be able to see only some sensitive arguments). So try to achieve the same encryption/decrytion results in PHP and VB.Net, but it doesnt work.</p>

<p>At first my small VB.Net encrytion function:</p>

<pre><code>Friend Enum CryptionMode
    Encrypt
    Decrypt
End Enum

Friend Function cryptAes(ByVal mode As CryptionMode, ByVal input As Byte(), ByVal pw As String) As Byte()
    Dim salt As Byte() = {42, 248, 0, 22, 19, 46, 162, 81, 192, 167, 174, 102, 233}
    Dim aes As New RijndaelManaged

    Dim keyGen As New Rfc2898DeriveBytes(pw, salt)
    aes.Key = keyGen.GetBytes(aes.Key.Length)
    aes.IV = keyGen.GetBytes(aes.IV.Length)

    Debug.WriteLine(Convert.ToBase64String(aes.Key))
    Debug.WriteLine(Convert.ToBase64String(aes.IV))

    Dim ms As New MemoryStream
    Dim cs As New CryptoStream(ms, If(mode = CryptionMode.Decrypt, aes.CreateDecryptor, aes.CreateEncryptor), CryptoStreamMode.Write)
    Try
        cs.Write(input, 0, input.Length)
        cs.Close()
        Dim output As Byte() = ms.ToArray
        Debug.WriteLine(output.Length)
        ms.Close()
        Return output
    Catch ex As Exception
        Debug.WriteLine(""Error"")
        Return Nothing
    End Try
End Function

Friend Function cryptAesToBase64(ByVal mode As CryptionMode, ByVal input As Byte(), ByVal pw As String) As String
    Return Convert.ToBase64String(cryptAes(mode, input, pw))
End Function
</code></pre>

<p>By executing this line</p>

<pre><code>cryptAesToBase64(CryptionMode.Encrypt, System.Text.Encoding.ASCII.GetBytes(""hallihallo""), ""pass"")
</code></pre>

<p>i got the following</p>

<pre><code>9sNq3BjYaU6ZIrLEfG1hXrkdOoGc6FoeCQ3T2asXSs4= (key)
oxBgLuPha+Rvm7KV5+3V3A== (IV)
16 (output length)
""hwcc7Cog9FornwAzo6hIuA=="" (output)
</code></pre>

<p>But now there is the PHP encryption: 
At first i needed to define an function which is equivalent to the Rfc2898DeriveBytes function:</p>

<pre><code>function pbkdf2($algorithm, $password, $salt, $count, $key_length, $raw_output = false)
{
    $algorithm = strtolower($algorithm);
    if(!in_array($algorithm, hash_algos(), true))
        die('PBKDF2 ERROR: Invalid hash algorithm.');
    if($count &lt;= 0 || $key_length &lt;= 0)
        die('PBKDF2 ERROR: Invalid parameters.');

    $hash_length = strlen(hash($algorithm, """", true));
    $block_count = ceil($key_length / $hash_length);

    $output = """";
    for($i = 1; $i &lt;= $block_count; $i++) {
        // $i encoded as 4 bytes, big endian.
        $last = $salt . pack(""N"", $i);
        // first iteration
        $last = $xorsum = hash_hmac($algorithm, $last, $password, true);
        // perform the other $count - 1 iterations
        for ($j = 1; $j &lt; $count; $j++) {
            $xorsum ^= ($last = hash_hmac($algorithm, $last, $password, true));
        }
        $output .= $xorsum;
    }
    return substr($output, 0, $key_length);
}
</code></pre>

<p>Now the encryption commands:</p>

<pre><code>$mySalt = base64_decode(""KvgAFhMuolHAp65m6Q=="");
$dev = pbkdf2(""sha1"", ""pass"", $mySalt, 1000, 48, true);
$key = substr($dev, 0, 32); //Keylength: 32
$iv = substr($dev, 32, 16); // IV-length: 16

echo ""key: "".base64_encode($key).""&lt;br&gt;"";
echo ""iv: "".base64_encode($iv).""&lt;br&gt;"";

$text = base64_decode(""aGFsbGloYWxsbw==""); //""hallihallo"";
$crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $text, MCRYPT_MODE_CBC, $iv);
echo strlen($crypttext).""&lt;br&gt;"";
echo base64_encode($crypttext);
</code></pre>

<p>By executing this, i get the following output:</p>

<pre><code>key: 9sNq3BjYaU6ZIrLEfG1hXrkdOoGc6FoeCQ3T2asXSs4=
iv: oxBgLuPha+Rvm7KV5+3V3A==
16 (output length)
BeyMKI9PAy5IThiM6XcsVQ==
</code></pre>

<p>Now i'm a bit confused because i have in PHP and VB.Net the same keys, same IV's, same input, same Ciphermode, but not the same output. Does anyone now whats wrong here?</p>

<p>Thank you and sorry for my bad english :)</p>
","","3807","<php><vb.net><encryption><rijndael>","5","","0","2012-07-21 20:12:58","","4","1","1543123","","2012-07-21 20:12:58","2012-07-21 19:49:54","2018-11-01 23:00:16"
"11540924","Figuring out the exact key created by PHP's mcrypt","<p>A PHP application I'm maintaining uses Rijndael_256 with EBC_MODE encryption with mcrypt. Fun has it that the key isn't 256 bits long, but only 160. According to the <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php"" rel=""noreferrer""><code>mcrypt_encrypt</code></a> documentation the key is padded with \0 to get the required size if it's too small.</p>

<blockquote>
  <p>The key with which the data will be encrypted. If it's smaller than
  the required keysize, it is padded with '\0'. It is better not to use
  ASCII strings for keys.</p>
</blockquote>

<p>This seem to happen at around the start of <a href=""https://github.com/php/php-src/blob/master/ext/mcrypt/mcrypt.c#L1186"" rel=""noreferrer"">line 1186 in mcrypt.c</a> and modifying the key at line 1213.</p>

<p>So lets say we've got <code>$key = 'abcdefghijkm';</code> which is too short, but PHP's implementation of mcrypt makes sure it's extended to 32 characters (or 256 bit) when using RIJNDAEL_256. What will the final key look like?</p>

<p>I'm asking this because another application is being built that uses the same encrypted data, but is in another language. Perl to be exact and I'm using <a href=""https://metacpan.org/module/Crypt::Rijndael"" rel=""noreferrer""><code>Crypto::Rijndael</code></a>. For the given example key, what is the exact key I would have to feed to <code>Crypto::Rijndael</code> (or any other for that matter) to be able to decrypt the data again?</p>

<p><strong>Update</strong></p>

<p>With Perl I can generate a key that's \0 padded doing <code>pack('a32', 'my secret key');</code> (or <code>Z32</code>), <code>length()</code> will report 32 and the <code>Crypt::Rijndael</code> module accepts the key. Looking at the source of PHP's mcrypt this should be the key that's being generated (\0 padded), but it simply won't take it.</p>

<p>In theory in PHP <code>pack('a32', 'my secret key');</code> should result in the same \0 padded key that PHP's mcrypt generates, but this isn't the case.</p>

<p>I'm very close to just encrypt everything again but with a new key. This is taking too much time.</p>
","<p>'\0' means NULL, the hex value of it is 00 !
So i tested 3 codes, and they returned all the same :)</p>

<ol>
<li>Let mcrypt_encrypt do the '\0' padding</li>
<li>Added with PHP NULL values</li>
<li>Added with PHP converted 0 hex values</li>
</ol>

<p>Code:
    

<pre><code>function encryptThis($text,$key){
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
    $crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_ECB, $iv);
    return ($crypttext);
}

echo bin2hex(encryptThis(""Meet me at 11 o'clock behind the monument."", ""abcdefghijklmnopqrstuvwxyz"")).""&lt;br/&gt;"";

echo bin2hex(encryptThis(""Meet me at 11 o'clock behind the monument."", ""abcdefghijklmnopqrstuvwxyz"" . NULL . NULL . NULL . NULL . NULL . NULL)).""&lt;br/&gt;"";

echo bin2hex(encryptThis(""Meet me at 11 o'clock behind the monument."", ""abcdefghijklmnopqrstuvwxyz"" . hex2bin(0) . hex2bin(0) . hex2bin(0) . hex2bin(0) . hex2bin(0) . hex2bin(0))).""&lt;br/&gt;"";

?&gt;
</code></pre>
","3788","<php><mcrypt><rijndael>","12","4","2","2012-07-27 03:14:29","11679464","6","1","83982","","2012-07-19 09:36:00","2012-07-18 12:03:08",""
"11540924","Figuring out the exact key created by PHP's mcrypt","<p>A PHP application I'm maintaining uses Rijndael_256 with EBC_MODE encryption with mcrypt. Fun has it that the key isn't 256 bits long, but only 160. According to the <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php"" rel=""noreferrer""><code>mcrypt_encrypt</code></a> documentation the key is padded with \0 to get the required size if it's too small.</p>

<blockquote>
  <p>The key with which the data will be encrypted. If it's smaller than
  the required keysize, it is padded with '\0'. It is better not to use
  ASCII strings for keys.</p>
</blockquote>

<p>This seem to happen at around the start of <a href=""https://github.com/php/php-src/blob/master/ext/mcrypt/mcrypt.c#L1186"" rel=""noreferrer"">line 1186 in mcrypt.c</a> and modifying the key at line 1213.</p>

<p>So lets say we've got <code>$key = 'abcdefghijkm';</code> which is too short, but PHP's implementation of mcrypt makes sure it's extended to 32 characters (or 256 bit) when using RIJNDAEL_256. What will the final key look like?</p>

<p>I'm asking this because another application is being built that uses the same encrypted data, but is in another language. Perl to be exact and I'm using <a href=""https://metacpan.org/module/Crypt::Rijndael"" rel=""noreferrer""><code>Crypto::Rijndael</code></a>. For the given example key, what is the exact key I would have to feed to <code>Crypto::Rijndael</code> (or any other for that matter) to be able to decrypt the data again?</p>

<p><strong>Update</strong></p>

<p>With Perl I can generate a key that's \0 padded doing <code>pack('a32', 'my secret key');</code> (or <code>Z32</code>), <code>length()</code> will report 32 and the <code>Crypt::Rijndael</code> module accepts the key. Looking at the source of PHP's mcrypt this should be the key that's being generated (\0 padded), but it simply won't take it.</p>

<p>In theory in PHP <code>pack('a32', 'my secret key');</code> should result in the same \0 padded key that PHP's mcrypt generates, but this isn't the case.</p>

<p>I'm very close to just encrypt everything again but with a new key. This is taking too much time.</p>
","<p>The issue isn't the key's padding, it's that you're using two different block sizes.  In PHP, using <code>MCRYPT_RIJNDAEL_256</code> uses a block size of... 256 bits.  However, in perl using <code>Crypt::Rijndael</code>, they note:</p>

<blockquote>
  <p><strong>blocksize</strong><br>
  The blocksize for Rijndael is 16 bytes (128 bits), although the algorithm actually supports any blocksize that is any multiple of our bytes. <strong>128 bits, is however, the AES-specified block size, so this is all we support</strong>.</p>
</blockquote>

<p>So there's no key that will allow for conversion between those different algorithms.  You can either switch to 128 bits in PHP:</p>

<pre><code>&lt;?
$key = ""abcdefghijklmnopqrstuvwxyz"";
$data = ""Meet me at 11 o'clock behind the monument."";
$crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_ECB, nil);
echo bin2hex($crypttext) . ""\n"";
// prints c613d1804f52f535cb4740242270b1bcbf85151ce4c874848fd1fc2add06e0cc2d26b6403feef4a8df18f7dd7f8ac67d
?&gt;
</code></pre>

<p>Which Perl can decrypt without a problem using Crypt::Rijndael:</p>

<pre><code>use Crypt::Rijndael;
$key = ""abcdefghijklmnopqrstuvwxyz\0\0\0\0\0\0"";
$crypttext = ""c613d1804f52f535cb4740242270b1bcbf85151ce4c874848fd1fc2add06e0cc2d26b6403feef4a8df18f7dd7f8ac67d"";
$cipher = Crypt::Rijndael-&gt;new($key, Crypt::Rijndael::MODE_ECB());
print $cipher-&gt;decrypt(pack('H*', $crypttext));
# prints ""Meet me at 11 o'clock behind the monument.""
</code></pre>

<p>Or you can switch to a different Perl module that supports more block sizes, e.g., <a href=""http://search.cpan.org/~delta/Crypt-Rijndael_PP-0.04/Rijndael_PP.pm"">Crypt::Rijndael_PP</a>:</p>

<pre><code># Same PHP code except using MCRYPT_RIJNDAEL_256
# prints f38469ec9deaadbbf49bb25fd7fc8b76462ebfbcf149a667306c8d1c033232322ee5b83fa87d49e4e927437647dbf7193e6d734242d583157b492347a2b1514c
</code></pre>

<p>Perl:</p>

<pre><code>use Crypt::Rijndael_PP ':all';
$key = ""abcdefghijklmnopqrstuvwxyz\0\0\0\0\0\0"";
$crypttext = ""f38469ec9deaadbbf49bb25fd7fc8b76462ebfbcf149a667306c8d1c033232322ee5b83fa87d49e4e927437647dbf7193e6d734242d583157b492347a2b1514c"";
print rijndael_decrypt(unpack('H*', $key), MODE_ECB, pack('H*', $crypttext), 256, 256);
# prints ""Meet me at 11 o'clock behind the monument.""
</code></pre>
","3788","<php><mcrypt><rijndael>","12","12","2","2012-07-27 03:14:29","11679464","6","1","83982","","2012-07-19 09:36:00","2012-07-18 12:03:08",""
"2975472","rijndael encryption - only part of the string is decrypted","<p>Only part of the string is getting decrypted, i think it has to do with my encoding.</p>

<p>Here is what happens:</p>

<pre><code>        string s = ""The brown fox jumped over the green frog"";
        string k = ""urieurut"";
        string enc = EncryptString(s, k);
        string dec = DecryptString(enc, k);
</code></pre>

<p>The RESULT is this:  The brown fox juϼ㴘裴혽Ή⪻ㆉr th≸ g⟤een frog</p>

<pre><code>public static string EncryptString(string stringToEncrypt, string encryptionKey)
{
    string encrypted = String.Empty;

    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateEncryptor(key, key), CryptoStreamMode.Write);

    byte[] encryptedString = UE.GetBytes(stringToEncrypt);
    cs.Write(encryptedString, 0, encryptedString.Length);
    cs.FlushFinalBlock();
    cs.Close();

    encrypted = UE.GetString(ms.ToArray());
    return encrypted;
}

public static string DecryptString(string stringToDecrypt, string encryptionKey)
{
    string decrypted = String.Empty;

    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);
    byte[] data = UE.GetBytes(stringToDecrypt);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateDecryptor(key, key), CryptoStreamMode.Write);
    cs.Write(data, 0, data.Length);
    cs.FlushFinalBlock();
    cs.Close();

    decrypted = UE.GetString(ms.ToArray());

    return decrypted;
}
</code></pre>
","<p>Not sure about your specific code chunk, but Jeff Atwood did a nice little library that I've used before:</p>

<p><a href=""http://www.codeproject.com/KB/security/SimpleEncryption.aspx"" rel=""nofollow noreferrer"">http://www.codeproject.com/KB/security/SimpleEncryption.aspx</a></p>

<p>It's worth a look as it simplifies the process of encrypting things a lot, I actually had to port to C# as there wasn't a port available when I saw it.  However there is now a C# port (in the comments section).</p>
","3685","<c#><encryption><rijndael>","2","0","3","2010-06-10 10:32:34","2975666","2","1","","","","2010-06-04 15:19:23",""
"2975472","rijndael encryption - only part of the string is decrypted","<p>Only part of the string is getting decrypted, i think it has to do with my encoding.</p>

<p>Here is what happens:</p>

<pre><code>        string s = ""The brown fox jumped over the green frog"";
        string k = ""urieurut"";
        string enc = EncryptString(s, k);
        string dec = DecryptString(enc, k);
</code></pre>

<p>The RESULT is this:  The brown fox juϼ㴘裴혽Ή⪻ㆉr th≸ g⟤een frog</p>

<pre><code>public static string EncryptString(string stringToEncrypt, string encryptionKey)
{
    string encrypted = String.Empty;

    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateEncryptor(key, key), CryptoStreamMode.Write);

    byte[] encryptedString = UE.GetBytes(stringToEncrypt);
    cs.Write(encryptedString, 0, encryptedString.Length);
    cs.FlushFinalBlock();
    cs.Close();

    encrypted = UE.GetString(ms.ToArray());
    return encrypted;
}

public static string DecryptString(string stringToDecrypt, string encryptionKey)
{
    string decrypted = String.Empty;

    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);
    byte[] data = UE.GetBytes(stringToDecrypt);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateDecryptor(key, key), CryptoStreamMode.Write);
    cs.Write(data, 0, data.Length);
    cs.FlushFinalBlock();
    cs.Close();

    decrypted = UE.GetString(ms.ToArray());

    return decrypted;
}
</code></pre>
","<p>I solved my issue by using base64 string for the encryption - i may look at other options but i only needed these methods for a small amount of data, here is the final code:</p>

<pre><code>public static string EncryptString(string stringToEncrypt, string encryptionKey)
{
    string encrypted = String.Empty;
    byte[] key = Encoding.Unicode.GetBytes(encryptionKey);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    RMCrypto.Padding = PaddingMode.PKCS7;
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateEncryptor(key, key), CryptoStreamMode.Write);

    byte[] encryptedString = Encoding.ASCII.GetBytes(stringToEncrypt);
    cs.Write(encryptedString, 0, encryptedString.Length);
    cs.FlushFinalBlock();
    cs.Close();

    //encrypted = Encoding.ASCII.GetString(ms.ToArray());
    return Convert.ToBase64String(ms.ToArray());
}

public static string DecryptString(string stringToDecrypt, string encryptionKey)
{
    string decrypted = String.Empty;
    byte[] key = Encoding.Unicode.GetBytes(encryptionKey);
    byte[] data = Convert.FromBase64String(stringToDecrypt);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    RMCrypto.Padding = PaddingMode.PKCS7;
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateDecryptor(key, key), CryptoStreamMode.Write);
    cs.Write(data, 0, data.Length);
    cs.FlushFinalBlock();
    cs.Close();

    decrypted = Encoding.ASCII.GetString(ms.ToArray());

    return decrypted;
}
</code></pre>
","3685","<c#><encryption><rijndael>","2","1","3","2010-06-10 10:32:34","2975666","2","1","","","","2010-06-04 15:19:23",""
"2975472","rijndael encryption - only part of the string is decrypted","<p>Only part of the string is getting decrypted, i think it has to do with my encoding.</p>

<p>Here is what happens:</p>

<pre><code>        string s = ""The brown fox jumped over the green frog"";
        string k = ""urieurut"";
        string enc = EncryptString(s, k);
        string dec = DecryptString(enc, k);
</code></pre>

<p>The RESULT is this:  The brown fox juϼ㴘裴혽Ή⪻ㆉr th≸ g⟤een frog</p>

<pre><code>public static string EncryptString(string stringToEncrypt, string encryptionKey)
{
    string encrypted = String.Empty;

    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateEncryptor(key, key), CryptoStreamMode.Write);

    byte[] encryptedString = UE.GetBytes(stringToEncrypt);
    cs.Write(encryptedString, 0, encryptedString.Length);
    cs.FlushFinalBlock();
    cs.Close();

    encrypted = UE.GetString(ms.ToArray());
    return encrypted;
}

public static string DecryptString(string stringToDecrypt, string encryptionKey)
{
    string decrypted = String.Empty;

    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);
    byte[] data = UE.GetBytes(stringToDecrypt);

    RijndaelManaged RMCrypto = new RijndaelManaged();
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, RMCrypto.CreateDecryptor(key, key), CryptoStreamMode.Write);
    cs.Write(data, 0, data.Length);
    cs.FlushFinalBlock();
    cs.Close();

    decrypted = UE.GetString(ms.ToArray());

    return decrypted;
}
</code></pre>
","<p>Here you go:</p>

<pre><code>    string s = ""The brown fox jumped over the green frog"";
    string k = ""urieurut"";
    byte[] enc = EncryptString(s, k);
    string dec = DecryptString(enc, k);
</code></pre>

<p>You can't attempt to interpret an encrypted bunch of bytes as a Unicode string.  Keep them as bytes.  The decrypted version can be converted back to string.</p>

<p>Also note the disposing of disposable objects below.  You could wind up with some resources being held too long or leak if you don't release them properly with <code>using()</code> or <code>Dispose()</code>.</p>

<pre><code>public static byte[] EncryptString(string stringToEncrypt, string encryptionKey)
{
    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);

    using (RijndaelManaged RMCrypto = new RijndaelManaged())
    using (MemoryStream ms = new MemoryStream())
    using (ICryptoTransform encryptor = RMCrypto.CreateEncryptor(key, key))
    using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
    {
        byte[] encryptedString = UE.GetBytes(stringToEncrypt);
        cs.Write(encryptedString, 0, encryptedString.Length);
        cs.FlushFinalBlock();
        return ms.ToArray();
    }
}

public static string DecryptString(byte[] stringToDecrypt, string encryptionKey)
{
    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(encryptionKey);

    using (RijndaelManaged RMCrypto = new RijndaelManaged())
    using (MemoryStream ms = new MemoryStream())
    using (ICryptoTransform decryptor = RMCrypto.CreateDecryptor(key, key))
    using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write))
    {
        cs.Write(stringToDecrypt, 0, stringToDecrypt.Length);
        cs.FlushFinalBlock();
        return UE.GetString(ms.ToArray());
    }
}
</code></pre>
","3685","<c#><encryption><rijndael>","2","3","3","2010-06-10 10:32:34","2975666","2","1","","","","2010-06-04 15:19:23",""
"3236224","PHP AES decryption","<p>I'm really struggling to decrypt a given cipher text in PHP and I'm hoping that one of you will be able to spot where I'm going wrong with this one.</p>

<p>So this is the string I'm trying to decode</p>

<pre><code>Wq+J2IlE7Cug1gJNiwy1beIcFggGhn+gZHkTCQ4J/DR3OY45OMs4RXN850xbfAmy
</code></pre>

<p>I know its encrypted with AES/CBC/PKCS5Padding with an IV of </p>

<pre><code>2ZqVSHjqn3kMump0rvd8AA==
</code></pre>

<p>and I'll email you the key upon request.</p>

<pre><code>public static function aes128cbcDecrypt($key, $encrypted_text, $iv) 
{
  $td = mcrypt_module_open(MCRYPT_RIJNDAEL_192, '', MCRYPT_MODE_CBC, '');
  mcrypt_generic_init($td, $key, $iv);
  $decrypted = mdecrypt_generic($td, $encrypted_text);
  mcrypt_generic_deinit($td);
  mcrypt_module_close($td);
  return trim($decrypted);
}
</code></pre>

<p>When I've tried running this I get complete gibberish</p>

<pre><code>ã5‡³/.3p›¤ý°$² —ïÅ»&lt;9 ‘m ê|Ÿ.ÂYº|Šû^w¬¾‚=l“½·F›VársT~ê H�ÿfß]7ñH
</code></pre>

<p>Equally, when I encrypt the known plain text, I get a load of gibberish instead of the ascii string that its meant to be.</p>

<pre><code>† —4†º¢V�Öæƒ{ Zsöœl ò°Þ 
PegöE&amp;£á=ÇºÜ€
</code></pre>

<p>Have any of you got any ideas as where I'm going wrong?</p>
","<p>Maybe a stupid question, but should the IV not be base64-decoded before it is used?</p>

<pre><code>$realIV = base64_decode($iv);
</code></pre>
","3463","<php><encryption><aes><mcrypt><rijndael>","1","5","1","2012-12-20 23:04:38","3236389","2","0","206403","","2012-12-20 23:04:38","2010-07-13 10:31:00",""
"10066582","Is there a JavaScript library that does Rijndael 256bit encryption like PHP?","<p>I've been extensively using Rijndael 256bit encryption in PHP for my API and would like to use it for my API wrapper that is written in JavaScript as well, but I've been unable to find a solution that gets the same result as in PHP.</p>

<p>By what PHP does I mean the following:</p>

<pre><code>base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256,$password,$secretInformation,MCRYPT_MODE_CBC,$iv));
</code></pre>

<p>and</p>

<pre><code>base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256,$password,$secretInformation,MCRYPT_MODE_EBC));
</code></pre>

<p>.. as well as the decryption variants.</p>

<p>I know that the many 256bit AES libraries don't get the same result that PHP does with its Rijndael 256bit encryption, thus I'm wondering if there is a library that is able to do what PHP does in the examples above?</p>

<p>Thanks!</p>
","<p>MCRYPT_RIJNDAEL_256 is not AES with a 256 bit key, its basically ""AES"" with a 256 bit block size( AES normally has a 128 bit block size). Rinjdael had a bunch of options and was standardized into AES by reduces those options to just the 128 or 256 bit key size. As such, must libraries support the standard (AES) and not the prototype. </p>

<p>If you want AES 256 or 128 , which is what almost all libraries actually support, use MCRYPT_RIJNDAEL_128 with a 128 bit or 256 bit key. The difference in block size doesn't really make much of a difference security wise .</p>

<p>Also, using a raw password as a key is a really really bad idea. You get keys from a password by using a password based key derivation function like PBKDF2.</p>
","3364","<php><javascript><encryption><mcrypt><rijndael>","3","1","1","2012-05-03 03:21:00","10424639","9","","","","","2012-04-08 21:15:28",""
"21216379","Cannot Convert From Byte to String","<p>I am building a C# application that encrypt text and display the result in a text box using <code>System.Security.Cryptography.Rijndael</code> so the receiver copy the results and decrypt it using the same key.</p>

<p>The problem is happening when I am converting the encrypted text from byte[] returned by <code>EncryptStringToBytes</code> function to a string that can be displayed in a textBox in order to be copied and decrypted later.</p>

<p>I have used the below conversion methods but none of them where able to display a meaningful string that can be used later for decryption and can be re-converted to the ORIGINAL byte shape returned previously from <code>EncryptStringToBytes</code>.</p>

<p>Below are the methods used to perform the conversions:</p>

<p>Converting from byte[] to string in order to be displayed in the textBox:</p>

<pre><code>textBox3.Text = Encoding.Default.GetString(encryptionResult)
</code></pre>

<p>Converting from string copied from the textBox to byte[] in order to be sent as argument to <code>DecryptStringFromBytes</code> in order to complete the decrytion process:</p>

<pre><code>byte[] textToByte = Encoding.Default.GetBytes(textToDecrypt)
</code></pre>
","<p>You should try encode and decode in 64encoding.
Use Convert Class.</p>

<pre><code>textBox3.Text =Convert.ToBase64String(encryptionResult)

byte[] textToByte = Convert.FromBase64String(textToDecrypt);
</code></pre>

<p>If you still want to use encode, choose:</p>

<pre><code>string decodedString = Encoding.UTF8.GetString(textToDecrypt);
</code></pre>
","3202","<c#><encryption><aes><rijndael>","1","5","1","2014-01-19 12:04:25","21216465","1","","","","","2014-01-19 11:53:16",""
"11697947","How do I translate this C# encrypt function into Java?","<p>I need to translate the below C# codes into Java, however, I could not find any Java equivalent to the Rfc2898DerivedBytes and Rijndael of C#.</p>

<pre><code>    private static string Encrypt(string sData, string sEncryptionKey)
{
    string str = null;
    string str2;
    try
    {
        Rfc2898DeriveBytes bytes = new Rfc2898DeriveBytes(sEncryptionKey, 8);
        Rijndael rijndael = Rijndael.Create();
        rijndael.IV = bytes.GetBytes(rijndael.BlockSize / 8);
        rijndael.Key = bytes.GetBytes(rijndael.KeySize / 8);
        byte[] buffer = Encoding.Unicode.GetBytes(sData);
        using (MemoryStream stream = new MemoryStream())
        {
            using (CryptoStream stream2 = new CryptoStream(stream, rijndael.CreateEncryptor(), CryptoStreamMode.Write))
            {
                stream.Write(bytes.Salt, 0, bytes.Salt.Length);
                stream2.Write(buffer, 0, buffer.Length);
                stream2.Close();
                str = Convert.ToBase64String(stream.ToArray());
                str2 = str;
            }
        }
    }
    catch (Exception exception)
    {
       System.out.println(exception.getMessage());
    }
    return str2;

}
</code></pre>

<blockquote>
  <p><strong>[Update]</strong></p>
</blockquote>

<p>I need to use this function to encrypt the password for new created user, and the encrypted password should also be correctly decrypted by other invoker including C#.</p>

<p>I follow the documents which list in the comments and answer, and try to write below simply sample for quickly verification.</p>

<pre><code>public class testEncrypt {
public static void main(String[] args) throws Exception {

    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");

    char[] password = ""passkey"".toCharArray();

    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[8];
    random.nextBytes(salt);

    KeySpec spec = new PBEKeySpec(password, salt, 1000, 256); 
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
    byte[] ciphertext = cipher.doFinal(""301a7fed-54e4-4ae2-9b4d-6db057f75c91"".getBytes(""UTF-8""));

    System.out.println(ciphertext.length);

}
</code></pre>

<p>}</p>

<p>However, the length of the ciphertext is 48, but actually in C#, it looks like this format</p>

<blockquote>
  <p>WHUNV5xrsfETEiCwcT0M731+Ak1jibsWEodJSaBraP1cmmkS1TpGWqwt/6p/a7oy8Yq30ImZPbFF+Y0JNLa3Eu2UGuazZtuhEepUIIdaDEtA2FO0JYIj2A==</p>
</blockquote>

<p>total 120 characters.</p>

<p>Is there something wrong with the code? </p>
","<p>RFC2898 is the official name for PBKDF2 (Password Based Key Derivation Function). </p>

<p>This question seems to use the <code>SecretKeyFactory</code> class for PBKDF2. </p>

<p><a href=""https://stackoverflow.com/questions/2375541/password-verification-with-pbkdf2-in-java"">Password Verification with PBKDF2 in Java</a></p>

<p>If you cannot find any implementation that you are satisfied with, I suggest you take a look at <a href=""https://stackoverflow.com/questions/3210795/pbkdf2-in-bouncy-castle-c-sharp"">my question</a> where I used a few classes from BouncyCastle (for C#, but should work for Java) and created the algorithm. I had to create this for C# because there was no <code>Rfc2898DeriveBytes</code> for the .NET Compact Framework.</p>

<p><a href=""https://stackoverflow.com/questions/8674018/pbkdf2-with-bouncycastle-in-java"">This question</a> should definitely help you too!</p>

<p>You can also find an implementation <a href=""http://www.jmedved.com/2010/05/java-rfc2898derivebytes/"" rel=""nofollow noreferrer"">here</a> that was done by someone who stumbled across your same problem.</p>

<p>Also to answer the second part of your question,</p>

<p>Rijndael doesn't differ much from AES. To quote this <a href=""http://blogs.msdn.com/b/shawnfa/archive/2006/10/09/the-differences-between-rijndael-and-aes.aspx"" rel=""nofollow noreferrer"">webpage</a></p>

<blockquote>
  <p>Namely, Rijndael allows for both key and block sizes to be chosen
  independently from the set of { 128, 160, 192, 224,  256 } bits.  (And
  the key size does not in fact have to match the block size).  However,
  FIPS-197 specifies that the block size must always be 128 bits in AES,
  and that the key size may be either 128, 192, or 256 bits.</p>
</blockquote>

<p>Rijndael algorithm was chosen by the NIST to be the Advanced Encryption algorithm.</p>

<p>So you can use the <a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption"">AES algorithm in Java</a>.</p>
","3167","<java><encryption><rijndael><cryptostream><rfc2898>","-1","5","1","2012-08-03 09:14:34","11698326","2","4","258938","","2012-08-03 09:14:34","2012-07-28 03:13:23",""
"2669231","Rijndael encryption from Action Script to C#","<p>I am trying to share encryption between Action Script and C#</p>

<p>My task is to decrypt the following message within C#</p>

<p>f1ca22a365ba54c005c3eb599d84b19c354d26dcf475ab4be775b991ac97884791017b12471000def05bb77bfe9c3a97d44ef78c9449f12daf6e25b61ab1a281</p>

<p>It uses Rijndael encyption , ECB mode (electronic code book), Key: Pas5pr@se , 128 bit key size and block size.</p>

<p>The problem I have is I can't seem to do it, anyone help me on this?</p>
","<p>This is an implementation of Rijndael Encryption which one of my websites is currently using. See if this does the trick:</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace CMS.Core.Domain
{
    /// &lt;summary&gt;
    /// Summary description for EncryptionManager
    /// &lt;/summary&gt;
    public static class EncryptionManager
    {
        public static string EncryptRijndael(string value, string encryptionKey) {
            try {
                var key = Encoding.UTF8.GetBytes(encryptionKey); //must be 16 chars
                var rijndael = new RijndaelManaged {
                    BlockSize = 128,
                    IV = key,
                    KeySize = 128,
                    Key = key
                };

                var transform = rijndael.CreateEncryptor();
                using (var ms = new MemoryStream()) {
                    using (var cs = new CryptoStream(ms, transform, CryptoStreamMode.Write)) {
                        byte[] buffer = Encoding.UTF8.GetBytes(value);

                        cs.Write(buffer, 0, buffer.Length);
                        cs.FlushFinalBlock();
                        cs.Close();
                    }
                    ms.Close();
                    return Convert.ToBase64String(ms.ToArray());
                }
            }
            catch {
                return string.Empty;
            }
        }

        public static string DecryptRijndael(string value, string encryptionKey)
        {
            try
            {
                var key = Encoding.UTF8.GetBytes(encryptionKey); //must be 16 chars
                var rijndael = new RijndaelManaged
                                               {
                                                   BlockSize = 128,
                                                   IV = key,
                                                   KeySize = 128,
                                                   Key = key
                                               };

                var buffer = Convert.FromBase64String(value);
                var transform = rijndael.CreateDecryptor();
                string decrypted;
                using (var ms = new MemoryStream())
                {
                    using (var cs = new CryptoStream(ms, transform, CryptoStreamMode.Write))
                    {
                        cs.Write(buffer, 0, buffer.Length);
                        cs.FlushFinalBlock();
                        decrypted = Encoding.UTF8.GetString(ms.ToArray());
                        cs.Close();
                    }
                    ms.Close();
                }

                return decrypted;
            }
            catch
            {
                return null;
            }
        }
    }
}
</code></pre>

<p><strong>Update</strong></p>

<p>One thing I just noticed with your input is that your encryption key is only 9 characters and my code above requires a 16 character key. I am not sure if this is a hard requirement of the Rijndael encryption algorithm, but the above code will not work with an encryption key that is not exactly 16 characters.</p>
","3087","<c#><actionscript-3><encryption><rijndael>","2","7","3","2010-05-01 13:18:11","2698004","0","2","","","","2010-04-19 16:48:45",""
"2669231","Rijndael encryption from Action Script to C#","<p>I am trying to share encryption between Action Script and C#</p>

<p>My task is to decrypt the following message within C#</p>

<p>f1ca22a365ba54c005c3eb599d84b19c354d26dcf475ab4be775b991ac97884791017b12471000def05bb77bfe9c3a97d44ef78c9449f12daf6e25b61ab1a281</p>

<p>It uses Rijndael encyption , ECB mode (electronic code book), Key: Pas5pr@se , 128 bit key size and block size.</p>

<p>The problem I have is I can't seem to do it, anyone help me on this?</p>
","<p>I came across this link which addresses both C# and ActionScript for the AES Rijndael encryption</p>

<p><a href=""http://ryoushin.com/cmerighi/en-us/42,2007-03-02/AES-Rijndael_with_ActionScript_and_ASP_Net.aspx"" rel=""nofollow noreferrer"">http://ryoushin.com/cmerighi/en-us/42,2007-03-02/AES-Rijndael_with_ActionScript_and_ASP_Net.aspx</a></p>
","3087","<c#><actionscript-3><encryption><rijndael>","2","0","3","2010-05-01 13:18:11","2698004","0","2","","","","2010-04-19 16:48:45",""
"2669231","Rijndael encryption from Action Script to C#","<p>I am trying to share encryption between Action Script and C#</p>

<p>My task is to decrypt the following message within C#</p>

<p>f1ca22a365ba54c005c3eb599d84b19c354d26dcf475ab4be775b991ac97884791017b12471000def05bb77bfe9c3a97d44ef78c9449f12daf6e25b61ab1a281</p>

<p>It uses Rijndael encyption , ECB mode (electronic code book), Key: Pas5pr@se , 128 bit key size and block size.</p>

<p>The problem I have is I can't seem to do it, anyone help me on this?</p>
","<p>You could try <a href=""http://shrinkrays.net/code-snippets/csharp/c-symmetric-encryption-wrapper.aspx"" rel=""nofollow noreferrer"">this wrapper</a> for Rijndael as it may be an issue with the IV or the passphrase padding (I'd be interested to know if it doesn't work)</p>
","3087","<c#><actionscript-3><encryption><rijndael>","2","0","3","2010-05-01 13:18:11","2698004","0","2","","","","2010-04-19 16:48:45",""
"8093248","How can I encrypt Rijndael with CFB Mode, Blocksize of 256 bit and Bouncycastle?","<p>I'm trying to encrypt a string with rijndael (keysize 256 bit, blocksize 256 bit, CFB mode)
currently i'm doing something like this:</p>

<pre><code>BufferedBlockCipher c = new BufferedBlockCipher(new CFBBlockCipher(new RijndaelEngine(256), 256));
    c.init(false, new ParametersWithIV(new KeyParameter(keybytes), iv));
</code></pre>

<p>I can encrypt and decrypt my own stuff just fine. Unfortunately the string i have to decrypt comes from mcrypt in php.</p>

<p>I cant decrypt this string and i guess the failure is on my side. could anybody give me an example how to configure a cipher with the required parameters?</p>

<p><strong>EDIT:</strong></p>

<p>following some advice here and in the php documentation comments. i changed my cypher to:</p>

<pre><code>PaddedBufferedBlockCipher c = new PaddedBufferedBlockCipher(new CFBBlockCipher(new RijndaelEngine(256)), new ZeroBytePadding());
</code></pre>

<p>still the encryptions are not compatible.</p>

<p><strong>EDIT 2</strong></p>

<p>got it working in CBC mode. I guess the problem is somewhere in iv.</p>
","<pre><code>PaddedBufferedBlockCipher c = new PaddedBufferedBlockCipher(new CFBBlockCipher(new RijndaelEngine(256), 8), new ZeroBytePadding());
c.init(false, new ParametersWithIV(new KeyParameter(keybytes), iv));
</code></pre>

<p>this did the trick. All examples and tutorials say that the second param of the CFBBlockCipher object is the blocksize of the chiffre, which would work, but mcrypt uses a blocksize of 8 bit for CFB.</p>
","3045","<java><encryption><bouncycastle><rijndael>","1","2","1","2012-12-31 05:12:59","8121979","7","","465274","","2011-11-14 10:41:58","2011-11-11 11:22:19",""
"25353757","C# Rijndael IV size doesn't match block size, while it should","<p>I have the following code: </p>

<pre><code>private void EncryptFile(string inputFile, string outputFile, string pass)
    {
        try
        {
            string password = @pass;
            UnicodeEncoding UE = new UnicodeEncoding();
            byte[] key = UE.GetBytes(password);
            byte[] iv = new byte[128];
            for(int i =0; i &lt; iv.Length; i++)
            {
                iv[i] = Convert.ToByte(true);
            }
            string cryptFile = outputFile;
            FileStream fsCrypt = new FileStream(cryptFile, FileMode.Create);

            RijndaelManaged RMCrypto = new RijndaelManaged();
            MessageBox.Show(RMCrypto.BlockSize + ""\n"" + iv.Length);
            CryptoStream cs = new CryptoStream(fsCrypt,
                RMCrypto.CreateEncryptor(key, iv),
                CryptoStreamMode.Write);

            FileStream fsIn = new FileStream(inputFile, FileMode.Open);

            int data;
            while ((data = fsIn.ReadByte()) != -1)
                cs.WriteByte((byte)data);


            fsIn.Close();
            cs.Close();
            fsCrypt.Close();
        }
        catch(Exception ex)
        {
            //MessageBox.Show(""Encryption failed!"", ""Error"");
            MessageBox.Show(ex.Message);
        }
    }
</code></pre>

<p>But have a problem with the IV size. Using a simple message box I found that (probably) the block size is 128. So, I set the IV to a 128 bytes array full of ""1"" values to test. The first message box confirms the blocksize and the IV array length are both 128. However, I get an exception saying <code>Specified initialization vector (IV) does not match the block size for this algorithm.</code></p>

<p>Why is this and how to fix the issue?</p>
","<p>AES <a href=""http://en.wikipedia.org/wiki/Block_size_(cryptography)"" rel=""nofollow"">block size</a> is 128 <strong>bits</strong>. Not bytes. Bits.</p>

<blockquote>
  <p>The winner of the AES contest, Rijndael, supports block and key sizes of 128, 192, and 256 <strong>bits</strong>, but in AES the block size is always 128 <strong>bits</strong>. The extra block sizes were not adopted by the AES standard</p>
</blockquote>
","3006","<c#><encryption><aes><rijndael>","1","3","1","2014-08-20 11:19:45","25353784","0","","589259","","2014-08-20 11:19:45","2014-08-17 21:23:49",""
"15731911","C# Rijndael CryptographicException ""Length of the data to encrypt is invalid.""","<p>I am trying to encrypt and decrypt a file with the rijndael algorythm, but i have been getting the error ""Length of the data to encrypt is invalid."". I am able to encrypt the file, but i can't decrypt it. This is my decryption function;</p>

<pre><code>    public static byte[] Decrypt(byte[] toEncryptArray)
    {
        byte[] keyArray = UTF8Encoding.UTF8.GetBytes(""-key-"");
        RijndaelManaged rDel = new RijndaelManaged();
        rDel.Key = keyArray;
        rDel.Padding = PaddingMode.PKCS7;
        ICryptoTransform cTransform = rDel.CreateDecryptor();
        return cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
    }
</code></pre>

<p>I honestly have no idea what i am doing wrong, as i can encrypt it perfectly fine. The file i am trying to decrypt is 11 kb.</p>
","<p>You should be using the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.cryptostream.aspx"" rel=""nofollow"">CryptoStream</a> object, which will automatically call the correct <code>ICryptoTransform.TransformFinalBlock</code> and <code>ICryptoTransform.TransformBlock</code> methods.</p>

<p>You haven't posted the encryption code but check that the <em>Padding</em> mode the same (i.e. <code>PaddingMode.PKCS7</code>) and the initiation vector is set to the same string.</p>
","2989","<c#><encryption><rijndael>","2","0","1","2015-08-05 23:50:00","15733438","4","","","","","2013-03-31 16:50:32",""
"1674821","ASP.net rijndael decrypt - Length of data to decrypt","<p>A lot of items I've found so far have been a bit vague or ... unspecific so I'm hoping to get an answer.</p>

<p>I've got two little methods - easy ones that look as such...</p>

<pre><code>    private const string initVector = ""1234567890123456"";
    private const string SaltValue = ""ThisIsMySaltValue"";
    private const int KeySize = 256;

    public static string Encrypt(string textToEncrypt)
    {
        var rijndael = new RijndaelManaged {KeySize = KeySize};
        var salt = SaltValue.ToByteArray();
        var vector = initVector.ToByteArray();

        var rfcBytes = new Rfc2898DeriveBytes(vector, salt, 2);
        var key = rfcBytes.GetBytes(rijndael.KeySize/8);

        ICryptoTransform encrypt = rijndael.CreateEncryptor(key, vector);

        var stream = new MemoryStream();
        var data = Encoding.ASCII.GetBytes(textToEncrypt);
        stream.Write(data, 0, data.Length);

        var cryptoStream = new CryptoStream(stream, encrypt, CryptoStreamMode.Write);
        cryptoStream.Write(data, 0, data.Length);
        cryptoStream.FlushFinalBlock();

        cryptoStream.Close();
        return Convert.ToBase64String(stream.ToArray());
    }


    public static string Decrypt(string textToDecrypt)
    {
        var vector = initVector.ToByteArray();
        var salt = SaltValue.ToByteArray();
        var encrypted = textToDecrypt.ToByteArray();

        var rijndael = new RijndaelManaged {KeySize = KeySize};

        var rfcBytes = new Rfc2898DeriveBytes(vector, salt, 2);
        var key = rfcBytes.GetBytes(rijndael.KeySize/8);

        var decrypt = rijndael.CreateDecryptor(key, vector);

        var stream = new MemoryStream(encrypted);
        var cryptoStream = new CryptoStream(stream, decrypt, CryptoStreamMode.Read);

        byte[] plainBytes = new byte[textToDecrypt.Length];

        var decryptedLength = cryptoStream.Read(plainBytes, 0, plainBytes.Length);

        var plainText = Encoding.UTF8.GetString(plainBytes, 0, decryptedLength);
        return plainText;
    }
</code></pre>

<p>Unit Test looks something like this ...</p>

<pre><code>    [Test]
    public void JustTestingThisOut()
    {
        var encryptMe = ""SomethingToEncrypt"";
        string result = encryptMe.ConvertToEncrypted();
        result.ShouldNotEqual(encryptMe);
        string backToReadAble = result.ConvertToDecrpted();
        backToReadAble.ShouldEqual(encryptMe);
    }
</code></pre>

<p>ToByteArray just does a return Encoding.UTF8.GetBytes(toByte); and my test string is simple - ""SomethingToEncrypt"".  I've went down the rabbit hole of finding <a href=""https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=325676"" rel=""nofollow noreferrer"">this</a> thinking that might have been the problem (Convert.ToBase64String and Convert.FromBase64String) that doesn't seem to make any difference.  As for the error ...</p>

<blockquote>
  <p>TestCase
  'Tests.Encryption.EncryptionUnitTests.JustTestingThisOut'
  failed:
  System.Security.Cryptography.CryptographicException
  : Length of the data to decrypt is
  invalid.  at
  System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(Byte[]
  inputBuffer, Int32 inputOffset, Int32
  inputCount)</p>
</blockquote>

<p>I have the FlushFinalBlock() in there, and I THOUGHT that'd do it, but ...nope, makes no difference as well.  Any ideas? Things to try?</p>
","<p>When encrypting, you first write <code>data</code> to <code>stream</code>, then you wrap <code>stream</code> with a <code>CryptoStream</code> and write <code>data</code> again, this time with encryption. Why? The decryption fails because the first thing it encounters is unencrypted data.</p>

<p>Print the value of the ciphertext <em>before</em> base64 encoding to verify this. You should see the plaintext followed by a bunch of gobbledygook that is the ciphertext.</p>

<p>Also, you are using the initialization vector as a password. They are definitely not the same thing, and using it like this will compromise security.</p>
","2965","<asp.net><encryption><rijndaelmanaged><rijndael>","1","0","3","2013-10-21 15:31:21","1674997","0","","95573","","2010-01-24 19:38:22","2009-11-04 16:06:08",""
"1674821","ASP.net rijndael decrypt - Length of data to decrypt","<p>A lot of items I've found so far have been a bit vague or ... unspecific so I'm hoping to get an answer.</p>

<p>I've got two little methods - easy ones that look as such...</p>

<pre><code>    private const string initVector = ""1234567890123456"";
    private const string SaltValue = ""ThisIsMySaltValue"";
    private const int KeySize = 256;

    public static string Encrypt(string textToEncrypt)
    {
        var rijndael = new RijndaelManaged {KeySize = KeySize};
        var salt = SaltValue.ToByteArray();
        var vector = initVector.ToByteArray();

        var rfcBytes = new Rfc2898DeriveBytes(vector, salt, 2);
        var key = rfcBytes.GetBytes(rijndael.KeySize/8);

        ICryptoTransform encrypt = rijndael.CreateEncryptor(key, vector);

        var stream = new MemoryStream();
        var data = Encoding.ASCII.GetBytes(textToEncrypt);
        stream.Write(data, 0, data.Length);

        var cryptoStream = new CryptoStream(stream, encrypt, CryptoStreamMode.Write);
        cryptoStream.Write(data, 0, data.Length);
        cryptoStream.FlushFinalBlock();

        cryptoStream.Close();
        return Convert.ToBase64String(stream.ToArray());
    }


    public static string Decrypt(string textToDecrypt)
    {
        var vector = initVector.ToByteArray();
        var salt = SaltValue.ToByteArray();
        var encrypted = textToDecrypt.ToByteArray();

        var rijndael = new RijndaelManaged {KeySize = KeySize};

        var rfcBytes = new Rfc2898DeriveBytes(vector, salt, 2);
        var key = rfcBytes.GetBytes(rijndael.KeySize/8);

        var decrypt = rijndael.CreateDecryptor(key, vector);

        var stream = new MemoryStream(encrypted);
        var cryptoStream = new CryptoStream(stream, decrypt, CryptoStreamMode.Read);

        byte[] plainBytes = new byte[textToDecrypt.Length];

        var decryptedLength = cryptoStream.Read(plainBytes, 0, plainBytes.Length);

        var plainText = Encoding.UTF8.GetString(plainBytes, 0, decryptedLength);
        return plainText;
    }
</code></pre>

<p>Unit Test looks something like this ...</p>

<pre><code>    [Test]
    public void JustTestingThisOut()
    {
        var encryptMe = ""SomethingToEncrypt"";
        string result = encryptMe.ConvertToEncrypted();
        result.ShouldNotEqual(encryptMe);
        string backToReadAble = result.ConvertToDecrpted();
        backToReadAble.ShouldEqual(encryptMe);
    }
</code></pre>

<p>ToByteArray just does a return Encoding.UTF8.GetBytes(toByte); and my test string is simple - ""SomethingToEncrypt"".  I've went down the rabbit hole of finding <a href=""https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=325676"" rel=""nofollow noreferrer"">this</a> thinking that might have been the problem (Convert.ToBase64String and Convert.FromBase64String) that doesn't seem to make any difference.  As for the error ...</p>

<blockquote>
  <p>TestCase
  'Tests.Encryption.EncryptionUnitTests.JustTestingThisOut'
  failed:
  System.Security.Cryptography.CryptographicException
  : Length of the data to decrypt is
  invalid.  at
  System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(Byte[]
  inputBuffer, Int32 inputOffset, Int32
  inputCount)</p>
</blockquote>

<p>I have the FlushFinalBlock() in there, and I THOUGHT that'd do it, but ...nope, makes no difference as well.  Any ideas? Things to try?</p>
","<p>I cant see how this will work as jeriley suggests since in the decrypt function you do </p>

<p><code>
var encrypted = textToDecrypt.ToByteArray();
</code></p>

<p>Here textToDecrypt is a base64 string. You first have to convert the base64 back to ordinary bytes which you can then use to decrypt. </p>
","2965","<asp.net><encryption><rijndaelmanaged><rijndael>","1","0","3","2013-10-21 15:31:21","1674997","0","","95573","","2010-01-24 19:38:22","2009-11-04 16:06:08",""
"1674821","ASP.net rijndael decrypt - Length of data to decrypt","<p>A lot of items I've found so far have been a bit vague or ... unspecific so I'm hoping to get an answer.</p>

<p>I've got two little methods - easy ones that look as such...</p>

<pre><code>    private const string initVector = ""1234567890123456"";
    private const string SaltValue = ""ThisIsMySaltValue"";
    private const int KeySize = 256;

    public static string Encrypt(string textToEncrypt)
    {
        var rijndael = new RijndaelManaged {KeySize = KeySize};
        var salt = SaltValue.ToByteArray();
        var vector = initVector.ToByteArray();

        var rfcBytes = new Rfc2898DeriveBytes(vector, salt, 2);
        var key = rfcBytes.GetBytes(rijndael.KeySize/8);

        ICryptoTransform encrypt = rijndael.CreateEncryptor(key, vector);

        var stream = new MemoryStream();
        var data = Encoding.ASCII.GetBytes(textToEncrypt);
        stream.Write(data, 0, data.Length);

        var cryptoStream = new CryptoStream(stream, encrypt, CryptoStreamMode.Write);
        cryptoStream.Write(data, 0, data.Length);
        cryptoStream.FlushFinalBlock();

        cryptoStream.Close();
        return Convert.ToBase64String(stream.ToArray());
    }


    public static string Decrypt(string textToDecrypt)
    {
        var vector = initVector.ToByteArray();
        var salt = SaltValue.ToByteArray();
        var encrypted = textToDecrypt.ToByteArray();

        var rijndael = new RijndaelManaged {KeySize = KeySize};

        var rfcBytes = new Rfc2898DeriveBytes(vector, salt, 2);
        var key = rfcBytes.GetBytes(rijndael.KeySize/8);

        var decrypt = rijndael.CreateDecryptor(key, vector);

        var stream = new MemoryStream(encrypted);
        var cryptoStream = new CryptoStream(stream, decrypt, CryptoStreamMode.Read);

        byte[] plainBytes = new byte[textToDecrypt.Length];

        var decryptedLength = cryptoStream.Read(plainBytes, 0, plainBytes.Length);

        var plainText = Encoding.UTF8.GetString(plainBytes, 0, decryptedLength);
        return plainText;
    }
</code></pre>

<p>Unit Test looks something like this ...</p>

<pre><code>    [Test]
    public void JustTestingThisOut()
    {
        var encryptMe = ""SomethingToEncrypt"";
        string result = encryptMe.ConvertToEncrypted();
        result.ShouldNotEqual(encryptMe);
        string backToReadAble = result.ConvertToDecrpted();
        backToReadAble.ShouldEqual(encryptMe);
    }
</code></pre>

<p>ToByteArray just does a return Encoding.UTF8.GetBytes(toByte); and my test string is simple - ""SomethingToEncrypt"".  I've went down the rabbit hole of finding <a href=""https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=325676"" rel=""nofollow noreferrer"">this</a> thinking that might have been the problem (Convert.ToBase64String and Convert.FromBase64String) that doesn't seem to make any difference.  As for the error ...</p>

<blockquote>
  <p>TestCase
  'Tests.Encryption.EncryptionUnitTests.JustTestingThisOut'
  failed:
  System.Security.Cryptography.CryptographicException
  : Length of the data to decrypt is
  invalid.  at
  System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(Byte[]
  inputBuffer, Int32 inputOffset, Int32
  inputCount)</p>
</blockquote>

<p>I have the FlushFinalBlock() in there, and I THOUGHT that'd do it, but ...nope, makes no difference as well.  Any ideas? Things to try?</p>
","<p>You have an intermittent bug lurking in your code...</p>

<p>You should never use any of the System.Text.Encoding classes for cipher text. You <em>will</em> experience intermittent errors.  You should use Base64 encoding and the System.Convert class methods.</p>

<ol>
<li>To obtain an encrypted string from an encrypted byte[], you should use:</li>
</ol>

<p><code>Convert.ToBase64String(byte[] bytes)</code></p>

<ol>
<li>To obtain a a raw byte[] from a string to be encrypted, you should use:</li>
</ol>

<p><code>Convert.FromBase64String(string data)</code></p>

<p>One additional note is that you'll need to have <code>FlushFinalBlock()</code> when doing the encryption or it won't get padded correctly.</p>

<p>For additional info, please refer to MS Security guru Shawn Fanning's post at <a href=""http://blogs.msdn.com/b/shawnfa/archive/2005/11/10/491431.aspx"" rel=""nofollow"">http://blogs.msdn.com/b/shawnfa/archive/2005/11/10/491431.aspx</a></p>
","2965","<asp.net><encryption><rijndaelmanaged><rijndael>","1","0","3","2013-10-21 15:31:21","1674997","0","","95573","","2010-01-24 19:38:22","2009-11-04 16:06:08",""
"8411177","Rijndael/AES decryption C# to PHP conversion","<p>I have the following code in C#</p>

<pre><code>string s = ""hellowld"";
byte[] bytes = new UnicodeEncoding().GetBytes(s);
FileStream stream = new FileStream(inputFile, FileMode.Open);
RijndaelManaged managed = new RijndaelManaged();
CryptoStream stream2 = new CryptoStream(stream, managed.CreateDecryptor(bytes, bytes), CryptoStreamMode.Read);
FileStream stream3 = new FileStream(outputFile, FileMode.Create);
try
{
    int num;
    while ((num = stream2.ReadByte()) != -1)
    {
        stream3.WriteByte((byte) num);
    }
 [....]
</code></pre>

<p>This code snippet decrypts a certain file and outputs a decrypted version. In the CreateDecryptor method from RijndaelManaged im using the password as KEY and also as IV.</p>

<p>I found some code here on stackoverflow for PHP but if I try to give the key and iv the same Array of Bytes like in C# nothing happens.</p>

<pre><code>$Pass = ""hellowld"";
$Clear = file_get_contents('./file.dat', FILE_USE_INCLUDE_PATH);

$bytePass=array();
$i = 0;
foreach (str_split($Pass) as $value) {
    $bytePass[$i]=ord($value);
    $i++;
}

echo decryptAES($Clear,$bytePass,$bytePass);

function decryptAES($content,$iv, $key,$aes) {

// Setzt den Algorithmus
switch ($aes) {
    case 128:
       $rijndael = 'rijndael-128';
       break;
    case 192:
       $rijndael = 'rijndael-192';
       break;
    default:
       $rijndael = 'rijndael-256';
}

// Setzt den Verschlüsselungsalgorithmus
// und setzt den Output Feedback (OFB) Modus
$cp = mcrypt_module_open($rijndael, '', 'ofb', '');

 // Ermittelt die Anzahl der Bits, welche die Schlüssellänge des Keys festlegen
$ks = mcrypt_enc_get_key_size($cp);

// Erstellt den Schlüssel, der für die Verschlüsselung genutzt wird
$key = substr(md5($key), 0, $ks);

// Initialisiert die Verschlüsselung
mcrypt_generic_init($cp, $key, $iv);

// Entschlüsselt die Daten
$decrypted = mdecrypt_generic($cp, $content);

// Beendet die Verschlüsselung
mcrypt_generic_deinit($cp);

// Schließt das Modul
mcrypt_module_close($cp);

return trim($decrypted);

}
</code></pre>

<p>I really need some help how to properly create the code in PHP. Its not necessary that I output a file in PHP, a string would be sufficient.</p>

<p><strong>UPDATE</strong>:
The default C# RijndaelManaged cipher method is AES-128-CBC. I changed my PHP code to that mcrypt module (<a href=""https://stackoverflow.com/questions/2044517/how-to-decode-rijndael-in-ruby-encoded-in-vb-net"">default C# cipher method</a>)</p>

<p><strong>UPDATE 2:</strong>
I did manage to create a Java Decryptor which lead me to another thing. PHP has to use the PKCS7 Padding.</p>
","<p>Your C# code doesn't really look secure, so if you can change it, see below for some tips.
Here is your given PHP code modified to look like it could be equivalent to the C# code given.</p>

<pre><code>function decryptAES128CBC($content,$iv, $key) {

    // AES is Rijndael-128
    $rijndael = 'rijndael-128';

    // key size is 128 bit = 16 bytes
    $ks = 16;

    // CBC mode, not OFB
    $cp = mcrypt_module_open($rijndael, '', 'cbc', '');

    // pad key and IV by zeros (this is not a good idea)
    $key = str_pad($key, $ks, ""\0"");
    $iv = str_pad($key, $iv, ""\0"");

    // initialize the decryptor with key and IV
    mcrypt_generic_init($cp, $key, $iv);

    // the actual work
    $decrypted = mdecrypt_generic($cp, $content);

    // clean up
    mcrypt_generic_deinit($cp);
    mcrypt_module_close($cp);

    // remove padding, see below
    return unpad($decrypted);
}
</code></pre>

<p>The last <code>unpad</code> is there to remove the padding which was likely appended by the encryption function to enlarge the message size to a full number of blocks. The default padding used by RijndaelManaged is PKCS7-padding, which appends a number of bytes (between 1 to 16), each of which being equal to the number of bytes appended. In a real implementation, you would check after decryption that the padding is valid (i.e. that all these bytes have the same value), but for ""quick and dirty"" you can simply use something which checks the last byte and removes that many bytes. See the <a href=""http://de.php.net/manual/en/function.mcrypt-decrypt.php#101069"" rel=""nofollow"">comments to mcrypt_decrypt</a> for an example.</p>

<p><strong>If you can change your C# code:</strong></p>

<ul>
<li><p>Note that it is usually not a good idea to use a fixed value (per key) as an initialization vector, and using the key itself as initialization vector is not good, either. Use a random initialization vector (sent together with the message), or see the next point.</p></li>
<li><p>Also, you normally don't want to use a (rather short) password directly as a key, but instead use a longer passphrase, and hash it with a salt (included with in the message) to derive the key. If you do this, you can also derive the initialization vector from the same two pieces of data (but in a way that they'll be different, using a key derivation function).
To avoid brute-forcing your password from the encrypted file, use a slow hash function here (PBKDF-2 or bcrypt).</p></li>
</ul>
","2880","<c#><php><aes><rijndaelmanaged><rijndael>","1","1","1","2011-12-07 23:28:14","8424148","1","","-1","","2017-05-23 11:48:47","2011-12-07 06:17:34",""
"17547222","Pad block corrupted error decoding Rijndael 256 with BouncyCastle","<p>This is my decoding class, it's using Bouncycastle, Rijndael 256 decryption. I have a error on:</p>

<pre><code>mode.doFinal(decoded, bytesProcessed);
</code></pre>

<p>Stacktrace:</p>

<pre><code>org.bouncycastle.crypto.InvalidCipherTextException: pad block corrupted
    at org.bouncycastle.crypto.paddings.PKCS7Padding.padCount(Unknown Source)
    at org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher.doFinal(Unknown Source)
    at com.imocom.cryptography.Decoder.decrypt(Decoder.java:71)
    at TestingLauncher.main(TestingLauncher.java:46)
</code></pre>

<p>This is the php code doing the encoding:</p>

<pre><code>&lt;?php 
    $string = ""This is a sample string."";
    $secret = ""1234567890987654321234567898765"";

    $result = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256,
                                            $secret,
                                            $string,
                                            MCRYPT_MODE_CBC,
                                            ""1234567890123455555555555555555""
                                           ));

    echo $result.""\n"";

    $back = mcrypt_decrypt(MCRYPT_RIJNDAEL_256,
                          $secret,
                          base64_decode($result),
                          MCRYPT_MODE_CBC,
                          ""12345678999999999999999999999999"");

    echo $back.""\n"";
    ?&gt;
</code></pre>

<p>This is the call:</p>

<pre><code>byte[] decoded;
decoded = decoder.decrypt(Base64.decodeBase64(encodedTextFromServer));
</code></pre>

<p>Can anyone help me, why is this happening ?</p>

<pre><code>public class Decoder {

byte[] IV = null;
byte[] encryptionKey = null;
Cipher cipher;
SecretKeySpec key;
BlockCipher blockCipher;
ParametersWithIV _param;

PaddedBufferedBlockCipher mode;
int blockSize;

public Decoder() {

    Security.addProvider(new BouncyCastleProvider());

    try {

        IV = ""1234543333333333333333333333333"".getBytes(""UTF-8"");
        encryptionKey = ""12222222222222222222222222222222"".getBytes(""UTF-8"");

        blockCipher = new CBCBlockCipher(new RijndaelEngine(256));
        _param = new ParametersWithIV(new KeyParameter(encryptionKey), IV);
        mode = new PaddedBufferedBlockCipher(blockCipher);
        blockSize = blockCipher.getBlockSize();

    } catch (Exception e) {

    }

}

public byte[] decrypt(byte[] encodedText) {

    byte[] decoded = new byte[mode.getOutputSize(encodedText.length)];

    try {
        mode.init(false, _param);


        int bytesProcessed = mode.processBytes(encodedText, 0, encodedText.length, decoded, 0);

        mode.doFinal(decoded, bytesProcessed);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return decoded;
}
</code></pre>
","<p>I suggest that you try treating your strings as hex and not as UTF-8.  For example, your IV is ""81a577a68f9e94d6cc02fe23b6ee64a4"".  That is 16 bytes of hex or 32 bytes of UTF-8.  An AES IV should be 16 bytes to match the block size.  I can see other errors, but I will leave those for you to find since you say this is for a class.</p>
","2825","<java><encryption><bouncycastle><rijndael>","1","-1","2","2013-07-26 10:54:12","17550945","7","","1197399","","2013-07-26 10:54:12","2013-07-09 11:34:42",""
"17547222","Pad block corrupted error decoding Rijndael 256 with BouncyCastle","<p>This is my decoding class, it's using Bouncycastle, Rijndael 256 decryption. I have a error on:</p>

<pre><code>mode.doFinal(decoded, bytesProcessed);
</code></pre>

<p>Stacktrace:</p>

<pre><code>org.bouncycastle.crypto.InvalidCipherTextException: pad block corrupted
    at org.bouncycastle.crypto.paddings.PKCS7Padding.padCount(Unknown Source)
    at org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher.doFinal(Unknown Source)
    at com.imocom.cryptography.Decoder.decrypt(Decoder.java:71)
    at TestingLauncher.main(TestingLauncher.java:46)
</code></pre>

<p>This is the php code doing the encoding:</p>

<pre><code>&lt;?php 
    $string = ""This is a sample string."";
    $secret = ""1234567890987654321234567898765"";

    $result = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256,
                                            $secret,
                                            $string,
                                            MCRYPT_MODE_CBC,
                                            ""1234567890123455555555555555555""
                                           ));

    echo $result.""\n"";

    $back = mcrypt_decrypt(MCRYPT_RIJNDAEL_256,
                          $secret,
                          base64_decode($result),
                          MCRYPT_MODE_CBC,
                          ""12345678999999999999999999999999"");

    echo $back.""\n"";
    ?&gt;
</code></pre>

<p>This is the call:</p>

<pre><code>byte[] decoded;
decoded = decoder.decrypt(Base64.decodeBase64(encodedTextFromServer));
</code></pre>

<p>Can anyone help me, why is this happening ?</p>

<pre><code>public class Decoder {

byte[] IV = null;
byte[] encryptionKey = null;
Cipher cipher;
SecretKeySpec key;
BlockCipher blockCipher;
ParametersWithIV _param;

PaddedBufferedBlockCipher mode;
int blockSize;

public Decoder() {

    Security.addProvider(new BouncyCastleProvider());

    try {

        IV = ""1234543333333333333333333333333"".getBytes(""UTF-8"");
        encryptionKey = ""12222222222222222222222222222222"".getBytes(""UTF-8"");

        blockCipher = new CBCBlockCipher(new RijndaelEngine(256));
        _param = new ParametersWithIV(new KeyParameter(encryptionKey), IV);
        mode = new PaddedBufferedBlockCipher(blockCipher);
        blockSize = blockCipher.getBlockSize();

    } catch (Exception e) {

    }

}

public byte[] decrypt(byte[] encodedText) {

    byte[] decoded = new byte[mode.getOutputSize(encodedText.length)];

    try {
        mode.init(false, _param);


        int bytesProcessed = mode.processBytes(encodedText, 0, encodedText.length, decoded, 0);

        mode.doFinal(decoded, bytesProcessed);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return decoded;
}
</code></pre>
","<p>From the JavaDoc of the constructor <code>PaddedBufferedBlockCipher</code> in Bouncy Castle:</p>

<blockquote>
  <p>Create a buffered block cipher PKCS7 padding</p>
</blockquote>

<p>However PHP by default does not use a good padding mode, instead it simply adds zero valued bytes until the end of the block is reached. This is known as <code>ZeroBytePadding</code> in Bouncy Castle.</p>

<p>So please use either <code>ZeroBytePadding</code>, or better, implement PKCS#7 padding in PHP.</p>
","2825","<java><encryption><bouncycastle><rijndael>","1","3","2","2013-07-26 10:54:12","17550945","7","","1197399","","2013-07-26 10:54:12","2013-07-09 11:34:42",""
"8313992","DCPCrypt/Delphi not properly encoding Rijndael","<p>I have the DCPCrypt package (latest version) and am trying to do AES/Rijndael CBC encoding (128 bit blocks, 256 bit key) in Delphi2007 with test values from the AES Known Answer Test (KAT) Vectors distributed by NIST. One sample test vector:</p>

<pre><code>KEY = 0000000000000000000000000000000000000000000000000000000000000000  
IV = 00000000000000000000000000000000  
PLAINTEXT = 80000000000000000000000000000000  
CIPHERTEXT = ddc6bf790c15760d8d9aeb6f9a75fd4e
</code></pre>

<p>The code below returns:  </p>

<pre><code>Cyphertext (bytes): 58 215 142 114 108 30 192 43 126 191 233 43 35 217 236 52  
Cyphertext (hex): 3AD78E726C1EC02B7EBFE92B23D9EC34  
Cyphertext (base64): OteOcmwewCt+v+krI9nsNA==  
</code></pre>

<p>which is obviously not correct.</p>

<pre><code>procedure TFrmKATVectors.TestData(Key,IV,PlainText: String);  
var  
  InBuf,OutBuf: TestBuffer;  
  KeyBuf: KeyBuffer;  
  IVBuf: IVBuffer;  
  l,i: Integer;  
  Bytes,  
  SOut: String;  
begin  
  Memo1.Lines.Add('Key: ' + Key);  
  Memo1.Lines.Add('IV: ' + IV);  
  Memo1.Lines.Add('Plaintext: ' + Plaintext);  
  l := Length(Key) DIV 2;  
  for i := 1 to l do KeyBuf[i] := HexToInt(Copy(Key,2*(i-1)+1,2));  
  l := Length(IV) DIV 2;  
  for i := 1 to l do IVBuf[i] := HexToInt(Copy(IV,2*(i-1)+1,2));  
  l := Length(PlainText) DIV 2;  
  for i := 1 to l do InBuf[i] := HexToInt(Copy(PlainText,2*(i-1)+1,2));  
  DCP_rijndael1.Init(KeyBuf,32,@IVBuf);  
  DCP_rijndael1.EncryptCBC(InBuf,OutBuf,TestBufSize);  
  SOut := '';  
  for i := 1 to Length(OutBuf) do
   begin
     SOut := SOut + Chr(OutBuf[i]);
     Bytes := Bytes + IntToStr(OutBuf[i]) + ' ';
   end;  
  Memo1.Lines.Add('Cyphertext (bytes): ' + Bytes); 
  Memo1.Lines.Add('Cyphertext (hex): ' + StringToHex(SOut));  
  Memo1.Lines.Add('Cyphertext (base64): ' + Base64EncodeStr(SOut));  
  Memo1.Lines.Add('');  
end;
</code></pre>

<p>I'm calling  </p>

<pre><code>TestData('0000000000000000000000000000000000000000000000000000000000000000',
         '00000000000000000000000000000000', '80000000000000000000000000000000');
</code></pre>

<p>with</p>

<pre><code>const
TestBufSize = 16;

type  
TestBuffer = packed Array[1..TestBufSize] of Byte;  
KeyBuffer = packed Array[1..32] of Byte;  
IVBuffer = packed Array[1..16] of Byte;  
</code></pre>

<p>Given the length of my test data I'm avoiding any padding issues.
What am I doing wrong? Any suggestions?</p>

<p>(No, you don't have to recount the parameter string lengths - I did that several times.)</p>
","<p>Key size parameter in Init method is in bits - as stated by the method comment: </p>

<blockquote>
  <p><em>Do key setup based on the data in Key, size is in bits</em></p>
</blockquote>

<p>You are calculating the AES with KeySize = 32 bits, which is invalid.</p>

<p>So you compute for the lowest available Keysize, which is 128. The returned value is correct for 128 bit - see <a href=""http://csrc.nist.gov/groups/STM/cavp/documents/aes/AESAVS.pdf"" rel=""noreferrer"">http://csrc.nist.gov/groups/STM/cavp/documents/aes/AESAVS.pdf</a> page 20.</p>

<p>Try to specify 256 bits as key size:</p>

<pre><code> DCP_rijndael1.Init(KeyBuf,256,@IVBuf);  
</code></pre>
","2801","<delphi><aes><rijndael>","2","7","1","2011-11-29 17:24:54","8314349","0","1","600500","","2011-11-29 17:24:54","2011-11-29 16:12:35",""
"22236199","Decrypting Rijndael in Java , Encrypted using .NET","<p>We have a use case where we are looking to decrypt data in java which was previously encrypted using .NET</p>

<p>Here is the Crypt class used to Encrypt and Decrypt Data in .NET : </p>

<p><a href=""https://gist.github.com/epinapala/9400064"" rel=""nofollow"">https://gist.github.com/epinapala/9400064</a></p>

<p>I separated the Decrypt method and executed, and It works fine in .NET, I am looking to port the code below:</p>

<pre><code>using System.IO;
using System;
using System.Text;
using System.Security.Cryptography;

class Program
{
    static void Main()
    {
        {
            string line = ""f5EBWYipPKG1FpyTEP7pyPLLJNpqrvwYJFs8iMw9mOY$"";

            line = line.Replace('-', '+').Replace('_', '/').Replace('$', '=');

            while (line.Length % 4 != 0){
                    line = line.PadRight(line.Length + (4 - line.Length % 4), '=');
            }
             Console.WriteLine(line);


            byte[] inputBuffer = Convert.FromBase64String(line);
             Console.WriteLine(inputBuffer.Length);
            byte[] numArray = new byte[16];
            byte[] key = new PasswordDeriveBytes(""ThisIsMyKey"", new byte[13]
      {
        (byte) 73,
        (byte) 118,
        (byte) 97,
        (byte) 110,
        (byte) 32,
        (byte) 77,
        (byte) 101,
        (byte) 100,
        (byte) 118,
        (byte) 101,
        (byte) 100,
        (byte) 101,
        (byte) 118
      }).GetBytes(16);

      Rijndael rijndael = GetRijndael(key);

      for (int index = 0; index &lt; 16; ++index){
          numArray[index] = inputBuffer[index];
      }
           rijndael.IV = numArray;

            string decodedString = Encoding.UTF8.GetString(rijndael.CreateDecryptor().TransformFinalBlock(inputBuffer, 16, inputBuffer.Length - 16));
            Console.WriteLine(decodedString);
        }
    }


    private static Rijndael GetRijndael(byte[] key)
    {
      Rijndael rijndael = Rijndael.Create();
      rijndael.Mode = CipherMode.CBC;
      rijndael.KeySize = key.Length * 8;
      rijndael.Key = key;
      rijndael.Padding = PaddingMode.PKCS7;
      return rijndael;
    }
}
</code></pre>

<p>Here is what I tried so far:</p>

<pre><code>   public static void main() {
     ecnryptedData = ""f5EBWYipPKG1FpyTEP7pyPLLJNpqrvwYJFs8iMw9mOY$"";
     ecnryptedData = ecnryptedData.replace('-', '+')
         .replace('_', '/').replace('$', '=');

     while (ecnryptedData.length() % 4 != 0) {
         ecnryptedData = StringUtils.rightPad(ecnryptedData, ecnryptedData.length() + (4 - ecnryptedData.length() % 4),
             ""="");
     }
     System.out.println(Decrypt(ecnryptedData, ""ThisIsMyKey""));
 }

 public static String Decrypt(String text, String key) throws Exception {
     Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
     byte[] keyBytes = new byte[16];
     byte[] b = key.getBytes(""UTF-8"");
     int len = b.length;
     if (len &gt; keyBytes.length) len = keyBytes.length;
     System.arraycopy(b, 0, keyBytes, 0, len);
     SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
     AlgorithmParameterSpec spec = new IvParameterSpec(keyBytes);
     cipher.init(Cipher.DECRYPT_MODE, keySpec, spec);

     BASE64Decoder decoder = new BASE64Decoder();
     byte[] results = cipher.doFinal(decoder.decodeBuffer(text));
     return new String(results, ""UTF-8"");
 }
</code></pre>

<p>I am getting the exception : ""Given final block not properly padded"". Not sure what I did wrong. I appreciate any help on this issue.</p>

<p>[[EDIT]]:</p>

<p>I figured it out. The thing I was missing was that I was using a wrong salt. I decoded the constant salt used(as bytes) in the .NET code into its String counter part, and used it as Salt in my Java code.</p>

<p>Also Thanks to the PasswordDerivedBytes class found here : </p>

<p><a href=""https://github.com/getkksingh/TimesSSO/blob/fc78e4b30d5fd347341757c02eea6c9271575515/src/java/com/timesgroup/sso/hibernate/apis/PasswordDeriveBytes.java"" rel=""nofollow"">https://github.com/getkksingh/TimesSSO/blob/fc78e4b30d5fd347341757c02eea6c9271575515/src/java/com/timesgroup/sso/hibernate/apis/PasswordDeriveBytes.java</a></p>

<pre><code>private static byte[] decryptData(byte[] data, String password,
            String paddingMode, String salt) throws Exception {
        if (data == null || data.length == 0)
            throw new IllegalArgumentException(""data is empty"");
        if (password == null || password == """")
            throw new IllegalArgumentException(""password is empty"");
        if (salt == null || salt == """")
            salt = ""."";
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        byte[] saltBytes = salt.getBytes(""UTF8"");
        byte[] passBytes = password.getBytes(""UTF8"");

        PKCS5S1ParametersGenerator generator = new PasswordDeriveBytes(
                new SHA1Digest());
        generator.init(passBytes, saltBytes, 100);

        byte[] key = ((KeyParameter) generator.generateDerivedParameters(256))
                .getKey();
        passBytes = new byte[16];
        saltBytes = new byte[16];
        System.arraycopy(key, 0, passBytes, 0, 16);
        System.arraycopy(key, 16, saltBytes, 0, 16);

        Cipher cipher = Cipher.getInstance(""AES/CBC/"" + paddingMode, ""BC"");
        SecretKeySpec keySpec = new SecretKeySpec(passBytes, ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, keySpec,
                new IvParameterSpec(saltBytes));

        byte[] original = cipher.doFinal(data);
        return original;
    }
</code></pre>
","<p>You are using a custom Base64 variant in the C# code: <code>_</code> and <code>-</code> as characters 62 and 63 and <code>$</code> as padding. The C# code converts these to normal Base64 before attempting decoding.</p>

<p>Your java code passes invalid data to the Base64 decoder. This should throw an <code>IllegalArgumentException</code> before the code even reaches the crypto.</p>

<p>Another issue is that your C# code uses PBKDF1 to derive the key from the password, the java code directly uses the password as key bytes.</p>
","2769","<java><.net><rijndael>","1","1","1","2015-03-13 18:56:49","22236489","0","3","450117","","2014-03-06 22:06:23","2014-03-06 21:18:23",""
"32701948","How to decrypt a message in node.js that was encrypted with Rijndael-256?","<p>I have a message that is encrypted using PHP before it is stored in MySQL database.</p>

<p>I need to be able to decipher this message using node.js/javascript.</p>

<p>While researching how to do this, I came across the <a href=""https://nodejs.org/docs/latest/api/crypto.html"" rel=""nofollow"">crypto</a> module. I tried to use it, but I am running into the following error</p>

<pre><code>C:\Program Files\nodejs\node_modules\mysql\lib\protocol\Parser.js:82
        throw err;
              ^
TypeError: Not a buffer
    at TypeError (native)
    at new Decipheriv (crypto.js:282:16)
    at Object.Decipheriv (crypto.js:279:12)
    at Query.&lt;anonymous&gt; (C:\Program Files\nodejs\modules\validator.js:76:27)
    at Query._callback (C:\Program Files\nodejs\modules\dbconnect.js:46:14)
    at Query.Sequence.end (C:\Program Files\nodejs\node_modules\mysql\lib\protoc
ol\sequences\Sequence.js:96:24)
    at Query._handleFinalResultPacket (C:\Program Files\nodejs\node_modules\mysq
l\lib\protocol\sequences\Query.js:144:8)
    at Query.EofPacket (C:\Program Files\nodejs\node_modules\mysql\lib\protocol\
sequences\Query.js:128:8)
    at Protocol._parsePacket (C:\Program Files\nodejs\node_modules\mysql\lib\pro
tocol\Protocol.js:274:23)
    at Parser.write (C:\Program Files\nodejs\node_modules\mysql\lib\protocol\Par
ser.js:77:12)
</code></pre>

<p>This is how I am trying to decript the message using the crypto module</p>

<pre><code>var crypto = require('crypto');
var encryptedText = new Buffer(rows[0]['password'], 'base64');
var decipher = crypto.createDecipheriv('sha256', 'The encryption password', 32);
var decrypted = decipher.update(encryptedText, 'hex', 'utf8') + decipher.final('utf8');

console.log('My Pass: ' + decrypted);
</code></pre>

<p>This is how I encrypt the message using PHP</p>

<pre><code>define('PHP_HASH_ALGORITHIM','sha256');
define('PHP_MCRYPT_CIPHERNAME','rijndael-256');
define('PHP_MCRYPT_MODE','ecb');
define('PHP_MCRYPT_KEY','The encryption password');

function encrypt($input, $textkey = PHP_MCRYPT_KEY) {
    $securekey = hash(PHP_HASH_ALGORITHIM, $textkey, TRUE);
    $iv = mcrypt_create_iv(32);
    return base64_encode(mcrypt_encrypt(PHP_MCRYPT_CIPHERNAME, $securekey, $input, PHP_MCRYPT_MODE, $iv));
}
</code></pre>

<p>This is how I would decrypt the message using PHP</p>

<pre><code>function decrypt($input, $textkey = PHP_MCRYPT_KEY) {
    $securekey = hash(PHP_HASH_ALGORITHIM, $textkey, TRUE);
    $iv = mcrypt_create_iv(32);
    return trim(mcrypt_decrypt(PHP_MCRYPT_CIPHERNAME, $securekey, base64_decode($input), PHP_MCRYPT_MODE, $iv));
}
</code></pre>

<p>How can I correctly decrypt the message using crypto?</p>
","<p>In PHP, you're using Rijndael with a <em>block size of 256 bit</em> (""rijndael-256"") and a key size of 256 bit (determined through SHA-256 output). Rijndael also supports the block sizes of 128 and 192 bit. Node.js' crypto module only supports AES which is the same as Rijndael with a <em>fixed block size of 128 bit</em> and variable key size (128, 192 or 256 bit). It means that you can't recreate the same functionality with Node.js' crypto module.</p>

<p>You need to find a module that supports Rijndael-256. <a href=""https://www.npmjs.com/package/mcrypt"">mcrypt</a> and <a href=""https://www.npmjs.com/package/node-rijndael"">node-rijndael</a> come to mind which both are simple wrappers around libmcrypt which you would need to install additionally.</p>

<p>It would be probably easier, if you could change the PHP code to use AES (rijndael-128).</p>

<p>Keep in mind that SHA-256 is a hashing function and not an encryption algorithm. You need to use <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm""><code>crypto.createHash(algorithm)</code></a> instead of <code>crypto.createDecipheriv()</code> to derive the key from a password.</p>

<hr>

<h3>Security considerations:</h3>

<ul>
<li><p>When you derive a key, you should do that with a random salt and many iterations. Use PBKDF2, bcrypt or scrypt for that. If the password is short (less than 20 characters) then it would be easy to brute-force.</p></li>
<li><p>Don't use MCrypt. It's abandonware. PHP and Node.js both support OpenSSL encryption which makes it easier to find compatible ciphers. (Still need to select the same mode of operation and padding.)</p></li>
<li><p>Don't use ECB mode. It's not semantically secure. At least use CBC mode with a random Initialization Vector (IV). The IV doesn't have to be secret, so simply prepend it to the ciphertext.</p></li>
<li><p>Authenticate your ciphertexts either with an encrypt-then-MAC scheme with a strong MAC like HMAC-SHA256 or use an authenticated mode of operation like GCM or EAX.</p></li>
</ul>
","2767","<javascript><php><node.js><encryption><rijndael>","2","6","1","2015-09-21 20:19:43","32703858","3","","1816580","","2015-09-21 20:19:43","2015-09-21 18:11:44",""
"17641957","C# AES: Encrypt a file causes ""Length of the data to encrypt is invalid."" error","<p>I have a PDF File.<br/>
When I want to encrypt it using codes below the <code>Length of the data to encrypt is invalid.</code> error occurred:</p>

<pre><code>  string inputFile = @""C:\sample.pdf"";
  string outputFile = @""C:\sample_enc.pdf"";

  try
  {    
    using (RijndaelManaged aes = new RijndaelManaged())
    {
      byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
      byte[] iv = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

      aes.Key = key;
      aes.IV = iv;

      aes.Mode = CipherMode.CFB;
      aes.Padding = PaddingMode.None;
      aes.KeySize = 128;
      aes.BlockSize = 128;

      using (FileStream fsCrypt = new FileStream(outputFile, FileMode.Create))
      {
        using (ICryptoTransform encryptor = aes.CreateEncryptor(key,iv))
        {
          using (CryptoStream cs = new CryptoStream(fsCrypt, encryptor, CryptoStreamMode.Write))
          {
            using (FileStream fsIn = new FileStream(inputFile, FileMode.Open))
            {
              int data;
              while ((data = fsIn.ReadByte()) != -1)
              {
                cs.WriteByte((byte)data);
              }
            }
          }
        }
      }
    }
  }
  catch (Exception ex)
  {
    // Length of the data to encrypt is invalid.
    Console.WriteLine(ex.Message);
  }
</code></pre>

<p><br/>
With <code>CipherMode.CBC</code> and <code>PaddingMode.PKCS7</code>, I don't have any errors.<br/>
But because of my client, I have to encrypt the file using <strong>AES/CFB</strong> with <strong>No Padding</strong>.</p>

<p>Any ideas what's happening here?</p>
","<p>A block cipher expects input with a length that is a multiple of the block size. With AES, the length of the input must be a multiple of 16.</p>

<p>You must apply some sort of padding to the plaintext so that this requirement is satisfied. PKCS#7 padding is the best choice.</p>

<p>However, on second thought, CFB mode turns a block cipher into a stream cipher. Stream ciphers don't need padding. The .NET implementation seems to be broken in this regard.</p>
","2764","<c#><encryption><aes><rijndael>","2","4","3","2015-03-13 18:01:32","17642336","0","2","","","","2013-07-14 17:45:48",""
"17641957","C# AES: Encrypt a file causes ""Length of the data to encrypt is invalid."" error","<p>I have a PDF File.<br/>
When I want to encrypt it using codes below the <code>Length of the data to encrypt is invalid.</code> error occurred:</p>

<pre><code>  string inputFile = @""C:\sample.pdf"";
  string outputFile = @""C:\sample_enc.pdf"";

  try
  {    
    using (RijndaelManaged aes = new RijndaelManaged())
    {
      byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
      byte[] iv = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

      aes.Key = key;
      aes.IV = iv;

      aes.Mode = CipherMode.CFB;
      aes.Padding = PaddingMode.None;
      aes.KeySize = 128;
      aes.BlockSize = 128;

      using (FileStream fsCrypt = new FileStream(outputFile, FileMode.Create))
      {
        using (ICryptoTransform encryptor = aes.CreateEncryptor(key,iv))
        {
          using (CryptoStream cs = new CryptoStream(fsCrypt, encryptor, CryptoStreamMode.Write))
          {
            using (FileStream fsIn = new FileStream(inputFile, FileMode.Open))
            {
              int data;
              while ((data = fsIn.ReadByte()) != -1)
              {
                cs.WriteByte((byte)data);
              }
            }
          }
        }
      }
    }
  }
  catch (Exception ex)
  {
    // Length of the data to encrypt is invalid.
    Console.WriteLine(ex.Message);
  }
</code></pre>

<p><br/>
With <code>CipherMode.CBC</code> and <code>PaddingMode.PKCS7</code>, I don't have any errors.<br/>
But because of my client, I have to encrypt the file using <strong>AES/CFB</strong> with <strong>No Padding</strong>.</p>

<p>Any ideas what's happening here?</p>
","<p>A (not ideal) solution I have used in this situation is to place the raw length of the plaintext into the first x bytes of data to be encrypted. The length then is encrypted with the rest of the data. When decrypting using the stream you simply read the first x bytes and convert them using the BitConverter class back to the length. This then tells you how many subsequent decrypted bytes are part of your message. Any data beyond that can be ignored as padding.</p>
","2764","<c#><encryption><aes><rijndael>","2","1","3","2015-03-13 18:01:32","17642336","0","2","","","","2013-07-14 17:45:48",""
"17641957","C# AES: Encrypt a file causes ""Length of the data to encrypt is invalid."" error","<p>I have a PDF File.<br/>
When I want to encrypt it using codes below the <code>Length of the data to encrypt is invalid.</code> error occurred:</p>

<pre><code>  string inputFile = @""C:\sample.pdf"";
  string outputFile = @""C:\sample_enc.pdf"";

  try
  {    
    using (RijndaelManaged aes = new RijndaelManaged())
    {
      byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
      byte[] iv = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

      aes.Key = key;
      aes.IV = iv;

      aes.Mode = CipherMode.CFB;
      aes.Padding = PaddingMode.None;
      aes.KeySize = 128;
      aes.BlockSize = 128;

      using (FileStream fsCrypt = new FileStream(outputFile, FileMode.Create))
      {
        using (ICryptoTransform encryptor = aes.CreateEncryptor(key,iv))
        {
          using (CryptoStream cs = new CryptoStream(fsCrypt, encryptor, CryptoStreamMode.Write))
          {
            using (FileStream fsIn = new FileStream(inputFile, FileMode.Open))
            {
              int data;
              while ((data = fsIn.ReadByte()) != -1)
              {
                cs.WriteByte((byte)data);
              }
            }
          }
        }
      }
    }
  }
  catch (Exception ex)
  {
    // Length of the data to encrypt is invalid.
    Console.WriteLine(ex.Message);
  }
</code></pre>

<p><br/>
With <code>CipherMode.CBC</code> and <code>PaddingMode.PKCS7</code>, I don't have any errors.<br/>
But because of my client, I have to encrypt the file using <strong>AES/CFB</strong> with <strong>No Padding</strong>.</p>

<p>Any ideas what's happening here?</p>
","<p>When you use PaddingMode.None you can wrap the ICrytoTransform and handle final block yourself:</p>

<pre><code>new CryptoStream(fsCrypt, new NoPaddingTransformWrapper(encryptor), CryptoStreamMode.Write)
</code></pre>

<p>The following is a wrapper class itself:</p>

<pre><code>public class NoPaddingTransformWrapper : ICryptoTransform
{

    private ICryptoTransform m_Transform;

    public NoPaddingTransformWrapper(ICryptoTransform symmetricAlgoTransform)
    {
        if (symmetricAlgoTransform == null)
            throw new ArgumentNullException(""symmetricAlgoTransform"");

        m_Transform = symmetricAlgoTransform;
    }

    #region simple wrap

    public bool CanReuseTransform
    {
        get { return m_Transform.CanReuseTransform; }
    }

    public bool CanTransformMultipleBlocks
    {
        get { return m_Transform.CanTransformMultipleBlocks; }
    }

    public int InputBlockSize
    {
        get { return m_Transform.InputBlockSize; }
    }

    public int OutputBlockSize
    {
        get { return m_Transform.OutputBlockSize; }
    }

    public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
    {
        return m_Transform.TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }

    #endregion

    public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
    {
        if (inputCount % m_Transform.InputBlockSize == 0)
            return m_Transform.TransformFinalBlock(inputBuffer, inputOffset, inputCount);
        else
        {
            byte[] lastBlocks = new byte[inputCount / m_Transform.InputBlockSize +  m_Transform.InputBlockSize];
            Buffer.BlockCopy(inputBuffer,inputOffset, lastBlocks, 0, inputCount);
            byte[] result = m_Transform.TransformFinalBlock(lastBlocks, 0, lastBlocks.Length);
            Debug.Assert(inputCount &lt; result.Length);
            Array.Resize(ref result, inputCount);
            return result;
        }
    }

    public void Dispose()
    {
        m_Transform.Dispose();
    }
}
</code></pre>

<p>OR you can wrap a SymmetricAlgorithm so that it will do appropriate wrapping in CreateEncryptor/CreateDecryptor depending on padding mode:</p>

<pre><code>public class NoPadProblemSymmetricAlgorithm : SymmetricAlgorithm
{
    private SymmetricAlgorithm m_Algo;

    public NoPadProblemSymmetricAlgorithm(SymmetricAlgorithm algo)
    {
        if (algo == null)
            throw new ArgumentNullException();

        m_Algo = algo;
    }

    public override ICryptoTransform  CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
    {
        if (m_Algo.Padding == PaddingMode.None)
            return new NoPaddingTransformWrapper(m_Algo.CreateDecryptor(rgbKey, rgbIV));
        else
            return m_Algo.CreateDecryptor(rgbKey, rgbIV);
    }

    public override ICryptoTransform  CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
    {
        if (m_Algo.Padding == PaddingMode.None)
            return new NoPaddingTransformWrapper(m_Algo.CreateEncryptor(rgbKey, rgbIV));
        else
            return m_Algo.CreateEncryptor(rgbKey, rgbIV);
    }

    #region simple wrap

    public override void  GenerateIV()
    {
        m_Algo.GenerateIV();
    }

    public override void  GenerateKey()
    {
        m_Algo.GenerateIV();
    }

    public override int BlockSize
    {
        get { return m_Algo.BlockSize; }
        set { m_Algo.BlockSize = value; }
    }

    public override int FeedbackSize
    {
        get { return m_Algo.FeedbackSize; }
        set { m_Algo.FeedbackSize = value; }
    }

    public override byte[] IV
    {
        get { return m_Algo.IV; }
        set { m_Algo.IV = value; }
    }

    public override byte[] Key
    {
        get { return m_Algo.Key; }
        set { m_Algo.Key = value; }
    }

    public override int KeySize
    {
        get { return m_Algo.KeySize; } 
        set { m_Algo.KeySize = value; }
    }

    public override KeySizes[] LegalBlockSizes
    {
        get { return m_Algo.LegalBlockSizes; }
    }

    public override KeySizes[] LegalKeySizes
    {
        get { return m_Algo.LegalKeySizes; }
    }

    public override CipherMode Mode
    {
        get { return m_Algo.Mode; }
        set { m_Algo.Mode = value; }
    }

    public override PaddingMode Padding
    {
        get { return m_Algo.Padding; }
        set { m_Algo.Padding = m_Algo.Padding; }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
            m_Algo.Dispose();

        base.Dispose(disposing);
    }

    #endregion

}
</code></pre>
","2764","<c#><encryption><aes><rijndael>","2","1","3","2015-03-13 18:01:32","17642336","0","2","","","","2013-07-14 17:45:48",""
"12798947","Rijndael: Same input / different output on multiple machines","<p>Some software i wrote uses the Rijndael algorithm from .Net4.0 to encrypt and decrypt license information.</p>

<p>The Problem is as followed:
The program generates a string, which is transformed into a byte[]. This byte[] is then encrypted with Rijndael into another byte[] which is then transferred to other computers.
There, this encrypted byte[] is decrypted again and the resulting byte[] is transformed back again into a string to retrieve the information from it.</p>

<p>Basically this works perfectly fine ... but not that perfect i guess.</p>

<p>There is one computer in our office that seems to encrypt and decrypt in a different way.</p>

<p>If i try to decrypt the byte[] on another computer, it gives me something like that:</p>

<pre><code>{""Zeichenabstände sind ungültig und können nicht entfernt werden.""}
 bei System.Security.Cryptography.RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode paddingMode, Boolean fLast)
 bei System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount)
 bei System.Security.Cryptography.CryptoStream.FlushFinalBlock()
 bei System.Security.Cryptography.CryptoStream.Dispose(Boolean disposing)
 bei System.IO.Stream.Close()
</code></pre>

<p>The code doing the encryption looks like this:</p>

<pre><code>private byte[] EncryptBytes(byte[] originalBytes) {
    MemoryStream ms = new MemoryStream();
    Rijndael crypt = Rijndael.Create();
    crypt.Key = KeyBytes;
    crypt.IV = IVBytes;
    CryptoStream cs = new CryptoStream(ms, crypt.CreateEncryptor(), CryptoStreamMode.Write);
    cs.Write(originalBytes, 0, originalBytes.Length);
    cs.Close();
    Byte[] cryptedBytes = ms.ToArray();
    ms.Close();
    return cryptedBytes;
}
</code></pre>

<p>For decryption it's the same, just with CreateDecryptor() instead of CreateEncryptor().</p>

<p>For testing and solving the problem, i did the following:</p>

<p>On both computers i encrypted exactly the same string.
I checked that this string is transformed into exactly the same byte[] on both machines.
The Rijndael object has the same property values on both machines so its configured the same way (Key, IV, Padding etc.)</p>

<p>The encrypted byte[] output afterwards is completely different on both machines.</p>

<p>This is where I'm stuck. I can't think of a reason for this behaviour and neither could the internet help me. Both computers run Windows XP x86 with .Net4.0</p>

<p>I am very gratefull for any hint and thank you in advance,
mls</p>

<p>Fun fact: It has worked fine on 12 different computers, machine 13 is bitching around :)</p>
","<p>The message means</p>

<pre><code>Padding is invalid and cannot be removed
</code></pre>

<p>I'm guessing that the actual data being encrypted is different. If it is <em>supposed</em> to be the same, the difference could be in the encoding. I think system default encoding can vary, as will the system locale (System.Globalization.Culture and CurrentCulture).</p>

<p>Anyways, in one of the cases, the padding is incorrect. Rijndael input needs to be padded to certain sizes in order for encryption to be supported. You should check the documentation for Rijndael crypt.</p>

<p>Chances are, there is a flag you can use to have the input <em>automatically</em> be default-padded (take care of this when decrypting, because you will get the source + padding back, not just the source)</p>
","2601","<c#><rijndael>","2","1","1","2012-10-09 11:43:23","","4","","85371","","2012-10-09 11:43:23","2012-10-09 11:21:54",""
"52699604","How to use Rijndael algorithm with 256 long block size in dotnet core 2.1","<p>I'm trying to encrypt a string with <code>RijndaelManaged</code> in order to send it to a third-party service. I've implemented the procedure in older versions of .Net framework (4.5, 4.6.x) like below:</p>

<pre><code>RijndaelManaged rm= new RijndaelManaged();
rm.KeySize = 256;
rm.BlockSize = 256;//causes exception in dotnet core 2.1
rm.Padding = PaddingMode.PKCS7;
rm.Key = Convert.FromBase64String(this.Key);
rm.IV = Convert.FromBase64String(this.IV);

var encrypt = rm.CreateEncryptor(rm.Key, rm.IV);
</code></pre>

<p>According to <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rijndaelmanaged?view=netcore-2.1#remarks"" rel=""noreferrer"">documentation</a>, <code>RijndaelManaged</code> class can be used with <code>BlockSize = 256</code>. But, when the code is running in dotenet core 2.1, an exception thrown:</p>

<blockquote>
  <p>System.PlatformNotSupportedException: BlockSize must be 128 in this implementation.
     at System.Security.Cryptography.RijndaelManaged.set_BlockSize(Int32 value)</p>
</blockquote>

<p><strong>UPDATE</strong></p>

<p>Thanks to @Access-Denied's response, according to <a href=""https://github.com/dotnet/corefx/blob/master/src/System.Security.Cryptography.Algorithms/src/Internal/Cryptography/RijndaelImplementation.cs"" rel=""noreferrer"">this</a>, I've noticed that it may be a mistake in dotnet core documentation and I can't use a 256 long <code>BlockSize</code> with <code>RijndaelManaged</code> class. As I mentioned, encrypted data is going to be sent to a third-party service. I have to use Rijndael with a 32 long <code>IV</code>. How can I handle that?</p>
","<p>The best documentation is a source code. According to their <a href=""https://github.com/dotnet/corefx/blob/master/src/System.Security.Cryptography.Algorithms/src/Internal/Cryptography/RijndaelImplementation.cs"" rel=""nofollow noreferrer"">source code</a> only 128 is supported:</p>

<pre><code>public override int BlockSize
        {
            get { return _impl.BlockSize; }
            set
            {
                Debug.Assert(BlockSizeValue == 128);

                // Values which were legal in desktop RijndaelManaged but not here in this wrapper type
                if (value == 192 || value == 256)
                    throw new PlatformNotSupportedException(SR.Cryptography_Rijndael_BlockSize);

                // Any other invalid block size will get the normal ""invalid block size"" exception.
                if (value != 128)
                    throw new CryptographicException(SR.Cryptography_Rijndael_BlockSize);
          }
      }
</code></pre>

<p>Use BouncyCastle.NetCore. There is a code snippet available at the following <a href=""https://github.com/dotnet/corefx/issues/12064"" rel=""nofollow noreferrer"">link</a>:</p>

<pre><code>var keyBytes = password.GetBytes(Keysize / 8);
var engine = new RijndaelEngine(256);
var blockCipher = new CbcBlockCipher(engine);
var cipher = new PaddedBufferedBlockCipher(blockCipher, new Pkcs7Padding());
var keyParam = new KeyParameter(keyBytes);
var keyParamWithIV = new ParametersWithIV(keyParam, ivStringBytes, 0, 32);

cipher.Init(true, keyParamWithIV);
var comparisonBytes = new byte[cipher.GetOutputSize(cipherTextBytes.Length)];
var length = cipher.ProcessBytes(cipherTextBytes, comparisonBytes, 0);
cipher.DoFinal(comparisonBytes, length);
</code></pre>
","2589","<c#><encryption><.net-core><rijndael><.net-core-2.1>","6","6","1","2018-10-09 13:05:24","52700206","5","3","1578952","","2018-10-09 08:49:33","2018-10-08 09:48:46",""
"8276833","AES Rijndael on PHP server and iOS generates sometimes different ciphers","<p>I'm using NSData+AESCrypt category by Jim Dovey and NSString+AESCrypt by Michael Sedlaczek (2011-02-22).</p>

<p>And on PHP I have a simple script:</p>

<pre><code>&lt;?php
$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
$key = '01234567890123456789012345678901';
$plaintext = ""myworda"";

$ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $plaintext, MCRYPT_MODE_ECB);
$base64encoded_ciphertext = base64_encode($ciphertext);
echo ""ciphertext: "".$base64encoded_ciphertext.""&lt;br/&gt;"";
?&gt;
</code></pre>

<p>In ObjC:</p>

<pre><code>NSString *key = @""01234567890123456789012345678901"";
NSString *plaintext = [@""+l56Ia4yyK19D2x2+oCXuw=="" AES256DecryptWithKey: key];
NSLog(@""plaintext: %@"", plaintext);
</code></pre>

<p>I change the variable $plaintext in PHP, run script and copy and paste the output-cipher to the Objective-c to decrypt it.</p>

<p>And: </p>

<ol>
<li><p>""myword"" gives me ""+l56Ia4yyK19D2x2+oCXuw=="" and I decrypt in and get ""myword"" on iOS [OK]</p></li>
<li><p>""good morning"" gives me ""5UdImsV1pQs60ovXmH74HQ=="" and I decrypt in and get ""good morning"" on iOS [OK]</p></li>
<li>""Schröder"" gives me ""KqNSCE8nGsYUYVdGZ2tnMw=="" and I decrypt in and get ""Schröder"" on iOS [OK]</li>
<li>""Schröder"" gives me ""KqNSCE8nGsYUYVdGZ2tnMw=="" and I decrypt in and get ""Schröder"" on iOS [OK]</li>
<li>""very long text"" gives me ""lsa+QF3IHQnAFiOjl2Heyg=="" and I decrypt in and get ""very long text"" on iOS [OK]</li>
<li>""very very very very long text"" gives me ""kl/ThEyuyUMmKSqU4/fJSzzJOyvsXrGRt5/zsnqjQww="" and I cannot decrypt it on iOS [FAIL]</li>
</ol>

<p>Why #5 fails? If I try to encrypt ""very very very very long text"" using Xcode, I get ""kl/ThEyuyUMmKSqU4/fJS90UZoJ73S4gox2uCoWoIL8="" notice that:
kl/ThEyuyUMmKSqU4/fJS == kl/ThEyuyUMmKSqU4/fJS
zzJOyvsXrGRt5/zsnqjQww != 90UZoJ73S4gox2uCoWoIL8=</p>

<p>But going further, encrypting ""good morning"" on Xcode gives me ""hVq1AuR8PAXSOztK26pmMw=="", while PHP gave ""5UdImsV1pQs60ovXmH74HQ=="", but Xcode decrypts both to ""good morning"" using the same key.</p>

<p>Please help.</p>
","<p>You encrypt the message using <code>MCRYPT_RIJNDAEL_128</code> which gives you a block size of 128 bits, or 16 bytes.
You'll notice that <code>very very very very long text</code> is larger than 16 bytes.</p>

<p>So I'm guessing you're decryption on ios uses a different block size. I'm not familiar with ios, but <code>AES256DecryptWithKey</code> seems to indicate it uses a block size of 256 bits.</p>

<p>Try using <code>MCRYPT_RIJNDAEL_256</code> in your PHP code, or change the ios code to use <code>AES128DecryptWithKey</code> (I don't know if that exist, again, I don't know ios)</p>
","2563","<php><ios><encryption><aes><rijndael>","2","-3","2","2013-06-07 10:02:34","","1","3","15168","","2011-11-26 11:45:23","2011-11-26 06:53:31",""
"8276833","AES Rijndael on PHP server and iOS generates sometimes different ciphers","<p>I'm using NSData+AESCrypt category by Jim Dovey and NSString+AESCrypt by Michael Sedlaczek (2011-02-22).</p>

<p>And on PHP I have a simple script:</p>

<pre><code>&lt;?php
$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
$key = '01234567890123456789012345678901';
$plaintext = ""myworda"";

$ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $plaintext, MCRYPT_MODE_ECB);
$base64encoded_ciphertext = base64_encode($ciphertext);
echo ""ciphertext: "".$base64encoded_ciphertext.""&lt;br/&gt;"";
?&gt;
</code></pre>

<p>In ObjC:</p>

<pre><code>NSString *key = @""01234567890123456789012345678901"";
NSString *plaintext = [@""+l56Ia4yyK19D2x2+oCXuw=="" AES256DecryptWithKey: key];
NSLog(@""plaintext: %@"", plaintext);
</code></pre>

<p>I change the variable $plaintext in PHP, run script and copy and paste the output-cipher to the Objective-c to decrypt it.</p>

<p>And: </p>

<ol>
<li><p>""myword"" gives me ""+l56Ia4yyK19D2x2+oCXuw=="" and I decrypt in and get ""myword"" on iOS [OK]</p></li>
<li><p>""good morning"" gives me ""5UdImsV1pQs60ovXmH74HQ=="" and I decrypt in and get ""good morning"" on iOS [OK]</p></li>
<li>""Schröder"" gives me ""KqNSCE8nGsYUYVdGZ2tnMw=="" and I decrypt in and get ""Schröder"" on iOS [OK]</li>
<li>""Schröder"" gives me ""KqNSCE8nGsYUYVdGZ2tnMw=="" and I decrypt in and get ""Schröder"" on iOS [OK]</li>
<li>""very long text"" gives me ""lsa+QF3IHQnAFiOjl2Heyg=="" and I decrypt in and get ""very long text"" on iOS [OK]</li>
<li>""very very very very long text"" gives me ""kl/ThEyuyUMmKSqU4/fJSzzJOyvsXrGRt5/zsnqjQww="" and I cannot decrypt it on iOS [FAIL]</li>
</ol>

<p>Why #5 fails? If I try to encrypt ""very very very very long text"" using Xcode, I get ""kl/ThEyuyUMmKSqU4/fJS90UZoJ73S4gox2uCoWoIL8="" notice that:
kl/ThEyuyUMmKSqU4/fJS == kl/ThEyuyUMmKSqU4/fJS
zzJOyvsXrGRt5/zsnqjQww != 90UZoJ73S4gox2uCoWoIL8=</p>

<p>But going further, encrypting ""good morning"" on Xcode gives me ""hVq1AuR8PAXSOztK26pmMw=="", while PHP gave ""5UdImsV1pQs60ovXmH74HQ=="", but Xcode decrypts both to ""good morning"" using the same key.</p>

<p>Please help.</p>
","<p>Your PHP code is using ECB mode.  I cannot see where you are setting the mode in ObjC.  Presumably you are using its default mode.  It is possible that the ObjC default mode is not ECB, more likely CBC.  Also notice that whenever your plaintext is 16 bytes or less (that is one block or less) the decryption works.  When it is greater than 16 bytes (that is it extends into a second block) it fails.</p>

<p>I suspect that the ObjC default is CBC mode with a zero IV.  That will act as if it is ECB for the first block only, and differ for the second and subsequent blocks.</p>

<p>ECB mode is unsafe and leaks information.  Use CBC mode with a specified IV instead.  At the very least change your PHP code to use CBC mode instead of ECB mode.</p>
","2563","<php><ios><encryption><aes><rijndael>","2","4","2","2013-06-07 10:02:34","","1","3","15168","","2011-11-26 11:45:23","2011-11-26 06:53:31",""
"17164281","padding is invalid and cannot be removed ERROR firing at cs.FlushFinalBlock() line","<p>I am trying to use the <code>Rijndael</code> method to encrypt and decrypt data. It encrypts fine but when I try to decrypt it it gives <code>padding is invalid and cannot be removed</code>  at the line <code>cs.FlushFinalBlock();</code> in the <code>private static byte[] DecryptString(byte[] cipherData, byte[] Key, byte[] IV)</code> method. I tried many sources like </p>

<ul>
<li><a href=""https://stackoverflow.com/questions/2116607/rijndaelmanaged-padding-is-invalid-and-cannot-be-removed-that-only-occurs-when"">RijndaelManaged &quot;Padding is invalid and cannot be removed&quot; that only occurs when decrypting in production</a> </li>
<li><a href=""https://stackoverflow.com/questions/15640857/stopping-decryption-before-eof-throws-exception-padding-is-invalid-and-cannot-b"">Stopping decryption before EOF throws exception: Padding is invalid and cannot be removed</a></li>
<li><a href=""http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/0fa69204-3bba-48a9-9bdc-32a12b0da4a0"" rel=""nofollow noreferrer"">http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/0fa69204-3bba-48a9-9bdc-32a12b0da4a0</a></li>
</ul>

<p>I know this is a common question and might be even a <strong>duplicate</strong>.  I searched onlne from the morning and came up with  no solutions. following is my code.</p>

<pre><code>    //clearText -&gt; the string to be encrypted
    //passowrd -&gt; encryption key
    public string EncryptString(string clearText, string Password)
    {
        // First we need to turn the input string into a byte array. 
        byte[] clearBytes =
            Encoding.Unicode.GetBytes(clearText);

        // Then, we need to turn the password into Key and IV 
        // We are using salt to make it harder to guess our key
        // using a dictionary attack - 
        // trying to guess a password by enumerating all possible words. 
        var pdb = new PasswordDeriveBytes(Password,
                                          new byte[]
                                              {
                                                  0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d,
                                                  0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76
                                              });

        // Now get the key/IV and do the encryption using the
        // function that accepts byte arrays. 
        // Using PasswordDeriveBytes object we are first getting
        // 32 bytes for the Key 
        // (the default Rijndael key length is 256bit = 32bytes)
        // and then 16 bytes for the IV. 
        // IV should always be the block size, which is by default
        // 16 bytes (128 bit) for Rijndael. 
        // If you are using DES/TripleDES/RC2 the block size is
        // 8 bytes and so should be the IV size. 
        // You can also read KeySize/BlockSize properties off
        // the algorithm to find out the sizes. 
        byte[] encryptedData = EncryptString(clearBytes,
                                             pdb.GetBytes(32), pdb.GetBytes(16));

        // Now we need to turn the resulting byte array into a string. 
        // A common mistake would be to use an Encoding class for that.
        //It does not work because not all byte values can be
        // represented by characters. 
        // We are going to be using Base64 encoding that is designed
        //exactly for what we are trying to do. 
        return Convert.ToBase64String(encryptedData);
    }
    //cipherText -&gt; the string to be decrypted
    //passowrd -&gt; decryption key
    public string DecryptString(string cipherText, string Password)
    {
        // First we need to turn the input string into a byte array. 
        // We presume that Base64 encoding was used 
        byte[] cipherBytes = Convert.FromBase64String(cipherText);

        // Then, we need to turn the password into Key and IV 
        // We are using salt to make it harder to guess our key
        // using a dictionary attack - 
        // trying to guess a password by enumerating all possible words. 
        var pdb = new PasswordDeriveBytes(Password,
                                          new byte[]
                                              {
                                                  0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65,
                                                  0x64, 0x76, 0x65, 0x64, 0x65, 0x76
                                              });

        // Now get the key/IV and do the decryption using
        // the function that accepts byte arrays. 
        // Using PasswordDeriveBytes object we are first
        // getting 32 bytes for the Key 
        // (the default Rijndael key length is 256bit = 32bytes)
        // and then 16 bytes for the IV. 
        // IV should always be the block size, which is by
        // default 16 bytes (128 bit) for Rijndael. 
        // If you are using DES/TripleDES/RC2 the block size is
        // 8 bytes and so should be the IV size. 
        // You can also read KeySize/BlockSize properties off
        // the algorithm to find out the sizes. 
        byte[] decryptedData = DecryptString(cipherBytes,
                                             pdb.GetBytes(32), pdb.GetBytes(16));

        // Now we need to turn the resulting byte array into a string. 
        // A common mistake would be to use an Encoding class for that.
        // It does not work 
        // because not all byte values can be represented by characters. 
        // We are going to be using Base64 encoding that is 
        // designed exactly for what we are trying to do. 
        return Encoding.Unicode.GetString(decryptedData);
    }

    // Encrypt a byte array into a byte array using a key and an IV 
    private static byte[] EncryptString(byte[] clearData, byte[] Key, byte[] IV)
    {
        // Create a MemoryStream to accept the encrypted bytes 
        var ms = new MemoryStream();

        // Create a symmetric algorithm. 
        // We are going to use Rijndael because it is strong and
        // available on all platforms. 
        // You can use other algorithms, to do so substitute the
        // next line with something like 
        //      TripleDES alg = TripleDES.Create(); 
        Rijndael alg = Rijndael.Create();

        // Now set the key and the IV. 
        // We need the IV (Initialization Vector) because
        // the algorithm is operating in its default 
        // mode called CBC (Cipher Block Chaining).
        // The IV is XORed with the first block (8 byte) 
        // of the data before it is encrypted, and then each
        // encrypted block is XORed with the 
        // following block of plaintext.
        // This is done to make encryption more secure. 

        // There is also a mode called ECB which does not need an IV,
        // but it is much less secure. 
        alg.Key = Key;
        alg.IV = IV;

        // Create a CryptoStream through which we are going to be
        // pumping our data. 
        // CryptoStreamMode.Write means that we are going to be
        // writing data to the stream and the output will be written
        // in the MemoryStream we have provided. 
        var cs = new CryptoStream(ms,
                                  alg.CreateEncryptor(), CryptoStreamMode.Write);

        // Write the data and make it do the encryption 
        cs.Write(clearData, 0, clearData.Length);

        // Close the crypto stream (or do FlushFinalBlock). 
        // This will tell it that we have done our encryption and
        // there is no more data coming in, 
        // and it is now a good time to apply the padding and
        // finalize the encryption process. 
        cs.FlushFinalBlock();

        // Now get the encrypted data from the MemoryStream.
        // Some people make a mistake of using GetBuffer() here,
        // which is not the right way. 
        byte[] encryptedData = ms.ToArray();

        return encryptedData;
    }

    private static byte[] DecryptString(byte[] cipherData,
                                        byte[] Key, byte[] IV)
    {
        // Create a MemoryStream that is going to accept the
        // decrypted bytes 
        var ms = new MemoryStream();

        // Create a symmetric algorithm. 
        // We are going to use Rijndael because it is strong and
        // available on all platforms. 
        // You can use other algorithms, to do so substitute the next
        // line with something like 
        //     TripleDES alg = TripleDES.Create(); 
        Rijndael alg = Rijndael.Create();

        // Now set the key and the IV. 
        // We need the IV (Initialization Vector) because the algorithm
        // is operating in its default 
        // mode called CBC (Cipher Block Chaining). The IV is XORed with
        // the first block (8 byte) 
        // of the data after it is decrypted, and then each decrypted
        // block is XORed with the previous 
        // cipher block. This is done to make encryption more secure. 
        // There is also a mode called ECB which does not need an IV,
        // but it is much less secure. 
        alg.Key = Key;
        alg.IV = IV;

        // Create a CryptoStream through which we are going to be
        // pumping our data. 
        // CryptoStreamMode.Write means that we are going to be
        // writing data to the stream 
        // and the output will be written in the MemoryStream
        // we have provided. 
        var cs = new CryptoStream(ms,
                                  alg.CreateDecryptor(), CryptoStreamMode.Write);

        // Write the data and make it do the decryption 
        cs.Write(cipherData, 0, cipherData.Length);

        // Close the crypto stream (or do FlushFinalBlock). 
        // This will tell it that we have done our decryption
        // and there is no more data coming in, 
        // and it is now a good time to remove the padding
        // and finalize the decryption process. 
        cs.FlushFinalBlock();

        // Now get the decrypted data from the MemoryStream. 
        // Some people make a mistake of using GetBuffer() here,
        // which is not the right way. 
        byte[] decryptedData = ms.ToArray();

        return decryptedData;
    }
</code></pre>

<p>Thank you very much :)
<strong>PS</strong> : i grabbed this code from online and edited a bit to suit my program </p>
","<p>You need to get past the exception so you can diagnose what is going on.  In order to do that, you need to set the decryption side only to expect no padding.  That will let it accept anything.  Once you have done that, you can have a look at what is emerging from your decryption and start diagnosing faults.  Note that this is not a solution, it is a way to ignore the exception.  Whatever is causing the exception is still there.</p>

<p>Have a look at what emerges.  Is is all garbage?  Is it part garbage and part the original plaintext?  If it is mixed, where does the garbage appear: at the start, at the end, both, in the middle somewhere?  Tell us what you see and we can point you to probable causes of the problems.</p>

<p>When everything is working, set both encryption and decryption to PKCS#7 padding.  Do not leave the no padding in place.</p>
","2550","<c#><encryption><rijndael><rijndaelmanaged>","1","1","1","2013-06-18 13:15:49","","0","1","-1","","2017-05-23 12:15:32","2013-06-18 08:40:07",""
"8356689","Python equivalent of PHP's MCRYPT_RIJNDAEL_256 CBC","<p>I need a Python implementation of this function - I want to use it on appengine.</p>

<p>I am not so good in Python so please help.</p>

<pre><code>function encrypt($data) {
  return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256 ,'oqufXQ(?bc=6_hR2I3sMZChDpb6dDlw4', $data , MCRYPT_MODE_CBC, utf8_encode('fOaiIOkD8*9Xeu_s4_bb87Ox_UG+D9GA')));
}
</code></pre>
","<p>Have you tried <a href=""http://wiki.birth-online.de/_media/snippets/python/rijndael.py"" rel=""nofollow"">this one</a> (also included below)? It implements the Rijndael block cipher for 16, 24 or 32 bytes. You are using the 256 bit (32 byte) version of the block cipher.</p>

<pre><code>""""""
A pure python (slow) implementation of rijndael with a decent interface

To include -

from rijndael import rijndael

To do a key setup -

r = rijndael(key, block_size = 16)

key must be a string of length 16, 24, or 32
blocksize must be 16, 24, or 32. Default is 16

To use -

ciphertext = r.encrypt(plaintext)
plaintext = r.decrypt(ciphertext)

If any strings are of the wrong length a ValueError is thrown
""""""

# ported from the Java reference code by Bram Cohen, April 2001
# this code is public domain, unless someone makes 
# an intellectual property claim against the reference 
# code, in which case it can be made public domain by 
# deleting all the comments and renaming all the variables

import copy
import string

shifts = [[[0, 0], [1, 3], [2, 2], [3, 1]],
          [[0, 0], [1, 5], [2, 4], [3, 3]],
          [[0, 0], [1, 7], [3, 5], [4, 4]]]

# [keysize][block_size]
num_rounds = {16: {16: 10, 24: 12, 32: 14}, 24: {16: 12, 24: 12, 32: 14}, 32: {16: 14, 24: 14, 32: 14}}

A = [[1, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 1],
     [1, 0, 0, 0, 1, 1, 1, 1],
     [1, 1, 0, 0, 0, 1, 1, 1],
     [1, 1, 1, 0, 0, 0, 1, 1],
     [1, 1, 1, 1, 0, 0, 0, 1]]

# produce log and alog tables, needed for multiplying in the
# field GF(2^m) (generator = 3)
alog = [1]
for i in range(255):
    j = (alog[-1] &lt;&lt; 1) ^ alog[-1]
    if j &amp; 0x100 != 0:
        j ^= 0x11B
    alog.append(j)

log = [0] * 256
for i in range(1, 255):
    log[alog[i]] = i

# multiply two elements of GF(2^m)
def mul(a, b):
    if a == 0 or b == 0:
        return 0
    return alog[(log[a &amp; 0xFF] + log[b &amp; 0xFF]) % 255]

# substitution box based on F^{-1}(x)
box = [[0] * 8 for i in range(256)]
box[1][7] = 1
for i in range(2, 256):
    j = alog[255 - log[i]]
    for t in range(8):
        box[i][t] = (j &gt;&gt; (7 - t)) &amp; 0x01

B = [0, 1, 1, 0, 0, 0, 1, 1]

# affine transform:  box[i] &lt;- B + A*box[i]
cox = [[0] * 8 for i in range(256)]
for i in range(256):
    for t in range(8):
        cox[i][t] = B[t]
        for j in range(8):
            cox[i][t] ^= A[t][j] * box[i][j]

# S-boxes and inverse S-boxes
S =  [0] * 256
Si = [0] * 256
for i in range(256):
    S[i] = cox[i][0] &lt;&lt; 7
    for t in range(1, 8):
        S[i] ^= cox[i][t] &lt;&lt; (7-t)
    Si[S[i] &amp; 0xFF] = i

# T-boxes
G = [[2, 1, 1, 3],
    [3, 2, 1, 1],
    [1, 3, 2, 1],
    [1, 1, 3, 2]]

AA = [[0] * 8 for i in range(4)]

for i in range(4):
    for j in range(4):
        AA[i][j] = G[i][j]
        AA[i][i+4] = 1

for i in range(4):
    pivot = AA[i][i]
    if pivot == 0:
        t = i + 1
        while AA[t][i] == 0 and t &lt; 4:
            t += 1
            assert t != 4, 'G matrix must be invertible'
            for j in range(8):
                AA[i][j], AA[t][j] = AA[t][j], AA[i][j]
            pivot = AA[i][i]
    for j in range(8):
        if AA[i][j] != 0:
            AA[i][j] = alog[(255 + log[AA[i][j] &amp; 0xFF] - log[pivot &amp; 0xFF]) % 255]
    for t in range(4):
        if i != t:
            for j in range(i+1, 8):
                AA[t][j] ^= mul(AA[i][j], AA[t][i])
            AA[t][i] = 0

iG = [[0] * 4 for i in range(4)]

for i in range(4):
    for j in range(4):
        iG[i][j] = AA[i][j + 4]

def mul4(a, bs):
    if a == 0:
        return 0
    r = 0
    for b in bs:
        r &lt;&lt;= 8
        if b != 0:
            r = r | mul(a, b)
    return r

T1 = []
T2 = []
T3 = []
T4 = []
T5 = []
T6 = []
T7 = []
T8 = []
U1 = []
U2 = []
U3 = []
U4 = []

for t in range(256):
    s = S[t]
    T1.append(mul4(s, G[0]))
    T2.append(mul4(s, G[1]))
    T3.append(mul4(s, G[2]))
    T4.append(mul4(s, G[3]))

    s = Si[t]
    T5.append(mul4(s, iG[0]))
    T6.append(mul4(s, iG[1]))
    T7.append(mul4(s, iG[2]))
    T8.append(mul4(s, iG[3]))

    U1.append(mul4(t, iG[0]))
    U2.append(mul4(t, iG[1]))
    U3.append(mul4(t, iG[2]))
    U4.append(mul4(t, iG[3]))

# round constants
rcon = [1]
r = 1
for t in range(1, 30):
    r = mul(2, r)
    rcon.append(r)

del A
del AA
del pivot
del B
del G
del box
del log
del alog
del i
del j
del r
del s
del t
del mul
del mul4
del cox
del iG

class rijndael:
    def __init__(self, key, block_size = 16):
        if block_size != 16 and block_size != 24 and block_size != 32:
            raise ValueError('Invalid block size: ' + str(block_size))
        if len(key) != 16 and len(key) != 24 and len(key) != 32:
            raise ValueError('Invalid key size: ' + str(len(key)))
        self.block_size = block_size

        ROUNDS = num_rounds[len(key)][block_size]
        BC = block_size // 4
        # encryption round keys
        Ke = [[0] * BC for i in range(ROUNDS + 1)]
        # decryption round keys
        Kd = [[0] * BC for i in range(ROUNDS + 1)]
        ROUND_KEY_COUNT = (ROUNDS + 1) * BC
        KC = len(key) // 4

        # copy user material bytes into temporary ints
        tk = []
        for i in range(0, KC):
            tk.append((ord(key[i * 4]) &lt;&lt; 24) | (ord(key[i * 4 + 1]) &lt;&lt; 16) |
                (ord(key[i * 4 + 2]) &lt;&lt; 8) | ord(key[i * 4 + 3]))

        # copy values into round key arrays
        t = 0
        j = 0
        while j &lt; KC and t &lt; ROUND_KEY_COUNT:
            Ke[t // BC][t % BC] = tk[j]
            Kd[ROUNDS - (t // BC)][t % BC] = tk[j]
            j += 1
            t += 1
        tt = 0
        rconpointer = 0
        while t &lt; ROUND_KEY_COUNT:
            # extrapolate using phi (the round key evolution function)
            tt = tk[KC - 1]
            tk[0] ^= (S[(tt &gt;&gt; 16) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 24 ^  \
                     (S[(tt &gt;&gt;  8) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 16 ^  \
                     (S[ tt        &amp; 0xFF] &amp; 0xFF) &lt;&lt;  8 ^  \
                     (S[(tt &gt;&gt; 24) &amp; 0xFF] &amp; 0xFF)       ^  \
                     (rcon[rconpointer]    &amp; 0xFF) &lt;&lt; 24
            rconpointer += 1
            if KC != 8:
                for i in range(1, KC):
                    tk[i] ^= tk[i-1]
            else:
                for i in range(1, KC // 2):
                    tk[i] ^= tk[i-1]
                tt = tk[KC // 2 - 1]
                tk[KC // 2] ^= (S[ tt        &amp; 0xFF] &amp; 0xFF)       ^ \
                               (S[(tt &gt;&gt;  8) &amp; 0xFF] &amp; 0xFF) &lt;&lt;  8 ^ \
                               (S[(tt &gt;&gt; 16) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 16 ^ \
                               (S[(tt &gt;&gt; 24) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 24
                for i in range(KC // 2 + 1, KC):
                    tk[i] ^= tk[i-1]
            # copy values into round key arrays
            j = 0
            while j &lt; KC and t &lt; ROUND_KEY_COUNT:
                Ke[t // BC][t % BC] = tk[j]
                Kd[ROUNDS - (t // BC)][t % BC] = tk[j]
                j += 1
                t += 1
        # inverse MixColumn where needed
        for r in range(1, ROUNDS):
            for j in range(BC):
                tt = Kd[r][j]
                Kd[r][j] = U1[(tt &gt;&gt; 24) &amp; 0xFF] ^ \
                           U2[(tt &gt;&gt; 16) &amp; 0xFF] ^ \
                           U3[(tt &gt;&gt;  8) &amp; 0xFF] ^ \
                           U4[ tt        &amp; 0xFF]
        self.Ke = Ke
        self.Kd = Kd

    def encrypt(self, plaintext):
        if len(plaintext) != self.block_size:
            raise ValueError('wrong block length, expected ' + str(self.block_size) + ' got ' + str(len(plaintext)))
        Ke = self.Ke

        BC = self.block_size // 4
        ROUNDS = len(Ke) - 1
        if BC == 4:
            SC = 0
        elif BC == 6:
            SC = 1
        else:
            SC = 2
        s1 = shifts[SC][1][0]
        s2 = shifts[SC][2][0]
        s3 = shifts[SC][3][0]
        a = [0] * BC
        # temporary work array
        t = []
        # plaintext to ints + key
        for i in range(BC):
            t.append((ord(plaintext[i * 4    ]) &lt;&lt; 24 |
                      ord(plaintext[i * 4 + 1]) &lt;&lt; 16 |
                      ord(plaintext[i * 4 + 2]) &lt;&lt;  8 |
                      ord(plaintext[i * 4 + 3])        ) ^ Ke[0][i])
        # apply round transforms
        for r in range(1, ROUNDS):
            for i in range(BC):
                a[i] = (T1[(t[ i           ] &gt;&gt; 24) &amp; 0xFF] ^
                        T2[(t[(i + s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^
                        T3[(t[(i + s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^
                        T4[ t[(i + s3) % BC]        &amp; 0xFF]  ) ^ Ke[r][i]
            t = copy.copy(a)
        # last round is special
        result = []
        for i in range(BC):
            tt = Ke[ROUNDS][i]
            result.append((S[(t[ i           ] &gt;&gt; 24) &amp; 0xFF] ^ (tt &gt;&gt; 24)) &amp; 0xFF)
            result.append((S[(t[(i + s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^ (tt &gt;&gt; 16)) &amp; 0xFF)
            result.append((S[(t[(i + s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^ (tt &gt;&gt;  8)) &amp; 0xFF)
            result.append((S[ t[(i + s3) % BC]        &amp; 0xFF] ^  tt       ) &amp; 0xFF)
        return ''.join(map(chr, result))

    def decrypt(self, ciphertext):
        if len(ciphertext) != self.block_size:
            raise ValueError('wrong block length, expected ' + str(self.block_size) + ' got ' + str(len(ciphertext)))
        Kd = self.Kd

        BC = self.block_size // 4
        ROUNDS = len(Kd) - 1
        if BC == 4:
            SC = 0
        elif BC == 6:
            SC = 1
        else:
            SC = 2
        s1 = shifts[SC][1][1]
        s2 = shifts[SC][2][1]
        s3 = shifts[SC][3][1]
        a = [0] * BC
        # temporary work array
        t = [0] * BC
        # ciphertext to ints + key
        for i in range(BC):
            t[i] = (ord(ciphertext[i * 4    ]) &lt;&lt; 24 |
                    ord(ciphertext[i * 4 + 1]) &lt;&lt; 16 |
                    ord(ciphertext[i * 4 + 2]) &lt;&lt;  8 |
                    ord(ciphertext[i * 4 + 3])        ) ^ Kd[0][i]
        # apply round transforms
        for r in range(1, ROUNDS):
            for i in range(BC):
                a[i] = (T5[(t[ i           ] &gt;&gt; 24) &amp; 0xFF] ^
                        T6[(t[(i + s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^
                        T7[(t[(i + s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^
                        T8[ t[(i + s3) % BC]        &amp; 0xFF]  ) ^ Kd[r][i]
            t = copy.copy(a)
        # last round is special
        result = []
        for i in range(BC):
            tt = Kd[ROUNDS][i]
            result.append((Si[(t[ i           ] &gt;&gt; 24) &amp; 0xFF] ^ (tt &gt;&gt; 24)) &amp; 0xFF)
            result.append((Si[(t[(i + s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^ (tt &gt;&gt; 16)) &amp; 0xFF)
            result.append((Si[(t[(i + s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^ (tt &gt;&gt;  8)) &amp; 0xFF)
            result.append((Si[ t[(i + s3) % BC]        &amp; 0xFF] ^  tt       ) &amp; 0xFF)
        return ''.join(map(chr, result))

def encrypt(key, block):
    return rijndael(key, len(block)).encrypt(block)

def decrypt(key, block):
    return rijndael(key, len(block)).decrypt(block)
</code></pre>

<p>Note that the <code>rijndael.py</code> file only implements the block cipher. The <code>encrypt</code> / <code>decrypt</code> functions only handle plaintexts that are precisely the block size. This means that the caller of these functions will have to provide the block cipher mode of operation and the zero padding himself.</p>

<p>Example python code (from a Java programmer, beware):</p>

<pre><code>class zeropad:

    def __init__(self, block_size):
        assert block_size &gt; 0 and block_size &lt; 256
        self.block_size = block_size

    def pad(self, pt):
        ptlen = len(pt)
        padsize = self.block_size - ((ptlen + self.block_size - 1) % self.block_size + 1)
        return pt + ""\0"" * padsize

    def unpad(self, ppt):
        assert len(ppt) % self.block_size == 0
        offset = len(ppt)
        if (offset == 0):
            return ''
        end = offset - self.block_size + 1
        while (offset &gt; end):
            offset -= 1;
            if (ppt[offset] != ""\0""):
                return ppt[:offset + 1]
        assert false

class cbc:

    def __init__(self, padding, cipher, iv):
        assert padding.block_size == cipher.block_size;
        assert len(iv) == cipher.block_size;
        self.padding = padding
        self.cipher = cipher
        self.iv = iv

    def encrypt(self, pt):
        ppt = self.padding.pad(pt)
        offset = 0
        ct = ''
        v = self.iv
        while (offset &lt; len(ppt)):
            block = ppt[offset:offset + self.cipher.block_size]
            block = self.xorblock(block, v)
            block = self.cipher.encrypt(block)
            ct += block
            offset += self.cipher.block_size
            v = block
        return ct;

    def decrypt(self, ct):
        assert len(ct) % self.cipher.block_size == 0
        ppt = ''
        offset = 0
        v = self.iv
        while (offset &lt; len(ct)):
            block = ct[offset:offset + self.cipher.block_size]
            decrypted = self.cipher.decrypt(block)
            ppt += self.xorblock(decrypted, v)
            offset += self.cipher.block_size
            v = block
        pt = self.padding.unpad(ppt)
        return pt;

    def xorblock(self, b1, b2):
        # sorry, not very Pythonesk
        i = 0
        r = '';
        while (i &lt; self.cipher.block_size):
             r += chr(ord(b1[i]) ^ ord(b2[i]))
             i += 1
        return r
</code></pre>
","2528","<php><python><rijndael>","4","4","1","2014-12-07 13:55:25","9221193","0","2","889949","","2011-12-02 14:13:03","2011-12-02 13:01:39",""
"11564719","Encryption / Decryption using Rijndael with key 256bit on Android","<p>I am developing an Android application that consumes a WS.
For exchange of information between the android application and WebService, you must use the algorithm encryption / decryption Rijndael with 256 bit key.</p>

<p>That is, all the information returned from the WS, will be encrypted, so I decrypts them using the algorithm.</p>

<p>Likewise, all the information I send to WS should be encrypted. Therefore, I will use the encryption algorithm.</p>

<p>I have not found the Rijndael ready to be used in the android platform. But I have the same algorithm in C #.</p>

<pre><code>public class KeydKey
{
    public KeydKey()
    {

    }


    #region Metodos de Criptografia
    #region key
    public string key(string vstrTextToBeEncrypted, string vstrEncryptionKey)
    {
        byte[] bytValue;
        byte[] bytKey;
        byte[] bytEncoded;
        byte[] bytIV = { 121, 241, 10, 1, 132, 74, 11, 39, 255, 91, 45, 78, 14, 211, 22, 62 };
        int intLength;
        int intRemaining;
        MemoryStream objMemoryStream = new MemoryStream();
        CryptoStream objCryptoStream;
        RijndaelManaged objRijndaelManaged;

        //O valor deve estar dentro da tabela ASCII (i.e., no DBCS chars)  
        bytValue = Encoding.UTF32.GetBytes(vstrTextToBeEncrypted.ToCharArray());
        intLength = vstrEncryptionKey.Length;

        /* 
           ******A chave cifrada será de 256 bits long (32 bytes)                             
           ****** Se for maior que 32 bytes então será truncado.                               
           ****** Se for menor que 32 bytes será alocado.                                        
           ****** Usando upper-case Xs
         */
        if (intLength &gt;= 32)
        {
            vstrEncryptionKey = vstrEncryptionKey.Substring(0, 32);
        }
        else
        {
            intLength = vstrEncryptionKey.Length;
            intRemaining = 32 - intLength;
            string tmp = """";
            vstrEncryptionKey = vstrEncryptionKey + tmp.PadRight(intRemaining, 'X');
        }

        bytKey = Encoding.ASCII.GetBytes(vstrEncryptionKey.ToCharArray());
        objRijndaelManaged = new RijndaelManaged();

        /*  ****** Cria o valor a ser crifrado e depois escreve                                  
            ****** Convertido em uma disposição do byte 
         */
        try
        {
            objCryptoStream = new CryptoStream(objMemoryStream, objRijndaelManaged.CreateEncryptor(bytKey, bytIV), CryptoStreamMode.Write);
            objCryptoStream.Write(bytValue, 0, bytValue.Length);

            objCryptoStream.FlushFinalBlock();

            bytEncoded = objMemoryStream.ToArray();
            objMemoryStream.Close();
            objCryptoStream.Close();
            return Convert.ToBase64String(bytEncoded);
        }
        catch (Exception ex)
        {
            return null;
        }
    }
    #endregion

    #region dkey
    public string dkey(string vstrstringToBeDecrypted, string vstrDecryptionKey)
    {
        byte[] bytDataToBeDecrypted;
        byte[] bytTemp = new byte[0];
        byte[] bytIV = { 121, 241, 10, 1, 132, 74, 11, 39, 255, 91, 45, 78, 14, 211, 22, 62 };
        MemoryStream objMemoryStream = new MemoryStream();
        CryptoStream objCryptoStream;
        RijndaelManaged objRijndaelManaged;
        byte[] bytDecryptionKey;
        int intLength;
        int intRemaining;
        string strReturnstring = string.Empty;

        //Convert base64 cifrada para byte array
        bytDataToBeDecrypted = Convert.FromBase64String(vstrstringToBeDecrypted);
        intLength = vstrDecryptionKey.Length;

        /* 
           ******A chave cifrada será de 256 bits long (32 bytes)                             
           ****** Se for maior que 32 bytes então será truncado.                               
           ****** Se for menor que 32 bytes será alocado.                                        
           ****** Usando upper-case Xs
         */
        if (intLength &gt;= 32)
        {
            vstrDecryptionKey = vstrDecryptionKey.Substring(0, 32);
        }
        else
        {
            intLength = vstrDecryptionKey.Length;
            intRemaining = 32 - intLength;
            string tmp = """";
            vstrDecryptionKey = vstrDecryptionKey + tmp.PadRight(intRemaining, 'X');
        }

        bytDecryptionKey = Encoding.ASCII.GetBytes(vstrDecryptionKey.ToCharArray());
        objRijndaelManaged = new RijndaelManaged();

        Array.Resize(ref bytTemp, bytDataToBeDecrypted.Length);

        objMemoryStream = new MemoryStream(bytDataToBeDecrypted);


        try
        {

            objCryptoStream = new CryptoStream(objMemoryStream, objRijndaelManaged.CreateDecryptor(bytDecryptionKey, bytIV), CryptoStreamMode.Read);
            objCryptoStream.Read(bytTemp, 0, bytTemp.Length);
            //objCryptoStream.FlushFinalBlock();
            objMemoryStream.Close();
            objCryptoStream.Close();
            return Encoding.UTF32.GetString(bytTemp).Replace(""\0"", """");
        }
        catch (Exception ex)
        {
            return null;
        }
    }

    #endregion

    #endregion


}
</code></pre>

<p>Someone tell me where I can get the algorithm for android? Or help me translate the algorithm that I have Java?</p>

<p>Thank you!</p>
","<p><code>Cipher.getInstance(""AES/CBC/PKCS5Padding"")</code> should do the trick. You will have to match (character)-encodings and you may use <code>SecretKeySpec(byte[32])</code> to create a 256 bit AES key.</p>
","2445","<android><web-services><encryption><rijndael>","0","3","1","2012-07-19 18:28:29","","8","4","","","","2012-07-19 15:57:19",""
"3128758","Store IV and Key for Rijndael","<p>I need to store username and password in an app.config. I want to encrypt these values using Rijndael algorithm. Where do I store the key and IV for decrypting the un and pw? I need to deploy the application to different servers with different users.</p>
","<p>Definitely don't store in the assembly - a relatively simple look at the IL would probably give up the secret. Even obsfuciating it, would provide little extra security.</p>

<p>Easiest would be to use the OS \ file-system security locally on the different servers to control read access to the key file.</p>
","2445","<c#><encryption><key><store><rijndael>","0","0","4","2014-01-16 01:42:50","3128824","1","","","","","2010-06-27 20:20:12",""
"3128758","Store IV and Key for Rijndael","<p>I need to store username and password in an app.config. I want to encrypt these values using Rijndael algorithm. Where do I store the key and IV for decrypting the un and pw? I need to deploy the application to different servers with different users.</p>
","<p>Ideally on a text file in a location not accessible via web, only via the local filesystem with tight permissions.</p>

<p>If you need to distribute the app, you could use the following structure</p>

<ul>
<li><code>C:\MyApp</code> for the key and other private information</li>
<li><code>C:\MyApp\www</code> for the virtual directory</li>
</ul>

<p>This will prevent prying eyes (or webserver bugs) to access the data. Only physical access to the machine will potentially reveal it, and that usually can be better controlled.</p>
","2445","<c#><encryption><key><store><rijndael>","0","0","4","2014-01-16 01:42:50","3128824","1","","","","","2010-06-27 20:20:12",""
"3128758","Store IV and Key for Rijndael","<p>I need to store username and password in an app.config. I want to encrypt these values using Rijndael algorithm. Where do I store the key and IV for decrypting the un and pw? I need to deploy the application to different servers with different users.</p>
","<p>Encrypting the web.config or app.config file is usually done with RSA or DPAPI encryption.</p>

<p>I'm not sure if it would suit you in your case, it's only effective if the users of the applications are restricted and not administrators.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ff647398.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/ff647398.aspx</a></p>
","2445","<c#><encryption><key><store><rijndael>","0","1","4","2014-01-16 01:42:50","3128824","1","","","","","2010-06-27 20:20:12",""
"3128758","Store IV and Key for Rijndael","<p>I need to store username and password in an app.config. I want to encrypt these values using Rijndael algorithm. Where do I store the key and IV for decrypting the un and pw? I need to deploy the application to different servers with different users.</p>
","<p>How about using machine key encryption to do it? There is (as far as I know) no easy way of doing this, but you can hack your way into the framework using reflection. The machine key is either not or only partially stored on a machine. If you configure ASP.NET to 'Generate a unique key for each application', the application's path is used to derive the key.</p>

<p>The code would be something like this:</p>

<pre><code>private static MethodInfo _cookieEncryptMethod;
private static MethodInfo _cookieDecryptMethod;

public static string MachineKeyEncrypt(string data)
{
    if (_cookieEncryptMethod == null)
    {
        _cookieEncryptMethod = Type.GetType(""System.Web.Security.CookieProtectionHelper"").GetMethod(""Encode"", BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod);
    }

    var dataBytes = Encoding.UTF8.GetBytes(data);

    return (string) _cookieEncryptMethod.Invoke(null, new object[] { CookieProtection.All, dataBytes, dataBytes.Length });
}

public static string MachineKeyDecrypt(string source)
{
    if (_cookieDecryptMethod == null)
    {
        _cookieDecryptMethod = Type.GetType(""System.Web.Security.CookieProtectionHelper"").GetMethod(""Decode"", BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod);
    }

    var data = (byte[]) _cookieDecryptMethod.Invoke(null, new object[] { CookieProtection.All, source });

    return Encoding.UTF8.GetString(data);
}
</code></pre>
","2445","<c#><encryption><key><store><rijndael>","0","0","4","2014-01-16 01:42:50","3128824","1","","","","","2010-06-27 20:20:12",""
"18374550","Rijndael AES-128 encryption decryption in Ruby","<p>I want to use rijndael aes128 for encryption in ruby. I have this code:</p>

<pre><code>cipher = OpenSSL::Cipher::Cipher.new(""aes-128-cbc"")
cipher.encrypt
cipher.key = 'abcdef0123456789abcdef0123456789'
cipher.iv = '0000000000000000'
encrypted =   cipher.update('2~1~000024~0910~20130723092446~T~00002000~USD~F~375019001012120~0~0~00000000000~')
encrypted &lt;&lt; cipher.final
</code></pre>

<p>which is not working.  But using this PHP function:</p>

<pre><code>&lt;?php 
 function hex2bin($hex_string) 
  {
     return pack('H*', $hex_string);
  } 
 $data_to_encrypt = '2~1~000024~0910~20130723092446~T~00002000~USD~F~375019001012120~0~0~00000000000~';
  $key = 'abcdef0123456789abcdef0123456789'; 
  $iv = '0000000000000000'; 
  $key = hex2bin($key);
  $iv = hex2bin($iv); 
  $data_encrypted = bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data_to_encrypt, MCRYPT_MODE_CBC, $iv));
  echo ""Data encrypted: "".strtoupper($data_encrypted).""&lt;br/&gt;""; echo ""Length: "".strlen($data_encrypted).""&lt;br/&gt;"";
  ?&gt;
</code></pre>

<p>I got my desired output:</p>

<pre><code>0D5835AFEBEE04C6DC2421538DB7C38A1283970EB31F21A47D2E3CC623D29EF0461279C7ACF93B031BE2B69CE45C9339554957F29EF609F019EEC975983A03B537622D7E0F196BE148F1C7CBB88E602A
</code></pre>

<p>How can I get my Ruby code to produce the same output?</p>
","<pre><code>require 'openssl'

cleartext = '2~1~000024~0910~20130723092446~T~00002000~USD~F~375019001012120~0~0~00000000000~'
key = 'abcdef0123456789abcdef0123456789'
iv = '0000000000000000'

cipher = OpenSSL::Cipher::Cipher.new(""aes-128-cbc"")
cipher.encrypt
cipher.padding = 0
cipher.key = [key].pack('H*')
cipher.iv = [iv].pack('H*')
encrypted = cipher.update(cleartext)
encrypted &lt;&lt; cipher.final
puts encrypted.unpack('H*').first.upcase
</code></pre>

<p>Output:</p>

<pre><code>0D5835AFEBEE04C6DC2421538DB7C38A1283970EB31F21A47D2E3CC623D29EF0461279C7ACF93B031BE2B69CE45C9339554957F29EF609F019EEC975983A03B537622D7E0F196BE148F1C7CBB88E602A
</code></pre>
","2370","<php><ruby><openssl><aes><rijndael>","0","4","2","2015-09-30 21:33:22","19095694","1","3","238886","","2015-09-30 21:33:22","2013-08-22 07:49:06",""
"18374550","Rijndael AES-128 encryption decryption in Ruby","<p>I want to use rijndael aes128 for encryption in ruby. I have this code:</p>

<pre><code>cipher = OpenSSL::Cipher::Cipher.new(""aes-128-cbc"")
cipher.encrypt
cipher.key = 'abcdef0123456789abcdef0123456789'
cipher.iv = '0000000000000000'
encrypted =   cipher.update('2~1~000024~0910~20130723092446~T~00002000~USD~F~375019001012120~0~0~00000000000~')
encrypted &lt;&lt; cipher.final
</code></pre>

<p>which is not working.  But using this PHP function:</p>

<pre><code>&lt;?php 
 function hex2bin($hex_string) 
  {
     return pack('H*', $hex_string);
  } 
 $data_to_encrypt = '2~1~000024~0910~20130723092446~T~00002000~USD~F~375019001012120~0~0~00000000000~';
  $key = 'abcdef0123456789abcdef0123456789'; 
  $iv = '0000000000000000'; 
  $key = hex2bin($key);
  $iv = hex2bin($iv); 
  $data_encrypted = bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data_to_encrypt, MCRYPT_MODE_CBC, $iv));
  echo ""Data encrypted: "".strtoupper($data_encrypted).""&lt;br/&gt;""; echo ""Length: "".strlen($data_encrypted).""&lt;br/&gt;"";
  ?&gt;
</code></pre>

<p>I got my desired output:</p>

<pre><code>0D5835AFEBEE04C6DC2421538DB7C38A1283970EB31F21A47D2E3CC623D29EF0461279C7ACF93B031BE2B69CE45C9339554957F29EF609F019EEC975983A03B537622D7E0F196BE148F1C7CBB88E602A
</code></pre>

<p>How can I get my Ruby code to produce the same output?</p>
","<p>The problem is that mcrypt isn't padding the last block, whereas Ruby's OpenSSL binding uses the default OpenSSL padding method, which is PKCS padding. I can't really improve on the description from the OpenSSL documentation:</p>

<p>PKCS padding works by adding n padding bytes of value n to make the total length of the data a multiple of the block size. Padding is always added so if the data is already a multiple of the block size n will equal the block size. For example if the block size is 8   and 11 bytes are to be encrypted then 5 padding bytes of value 5 will be added.
You'll need to manually add proper padding to the end of the cleartext in PHP before encrypting. To do that, pass your $cleartext through this pkcs5_pad function on the PHP side before you encrypt it (passing 16 as the blocksize).</p>

<pre><code>function pkcs5_pad ($text, $blocksize)
{
   $pad = $blocksize - (strlen($text) % $blocksize);
   return $text . str_repeat(chr($pad), $pad);
}
</code></pre>

<p>If you also go the other way (encrypt in Ruby and decrypt with mcrypt), you'll have to strip off the padding bytes after decrypting.</p>

<p>Side note: The reason you have to add padding even if the cleartext is already a multiple of the blocksize (a whole block of padding), is so that when you are decrypting you know that the last byte of the last block is always the amount of padding added. Otherwise, you couldn't tell the difference between cleartext with a single padding byte and a cleartext with no padding bytes that just happened to end in the value 0x01.</p>
","2370","<php><ruby><openssl><aes><rijndael>","0","4","2","2015-09-30 21:33:22","19095694","1","3","238886","","2015-09-30 21:33:22","2013-08-22 07:49:06",""
"12000124","Delphi program using DCPcrypt does not decrypt from PHP after upgrade to XE2","<p>I have an application developed in Delphi 2007 in which a value is encrypted by PHP and decrypted in the application.  Encryption algorithm is RIJNDAEL 128.  When I moved the XE2 and installed the latest version of DCPcrypt the application run but is no longer able to decrypt the encrypted string from PHP.  The result appears like Chinese characters so I am wondering if I need to modify my handling of the encryption key, vector, or encrypted string to account for the fact that XE2 uses Unicode characters.</p>

<p>The PHP encryption is performed by the following:
    (mcrypt_cbc(MCRYPT_RIJNDAEL_128,$key,$date_str,MCRYPT_ENCRYPT,$iv))</p>

<p>And the two relevant Delphi functions are here:</p>

<pre><code>function PadWithZeros(const str : string; size : integer) : string;
var
  origsize, i : integer;
begin
  Result := str;
  origsize := Length(Result);
  if ((origsize mod size) &lt;&gt; 0) or (origsize = 0) then
  begin
    SetLength(Result,((origsize div size)+1)*size);
    for i := origsize+1 to Length(Result) do
      Result[i] := #0;
  end;
end;

procedure TfrmMain.btnDecryptClick(Sender: TObject);
var
  Cipher : TDCP_rijndael;
  Data, Key, IV : string;
begin
  // Pad Key and IV with zeros as appropriate
  Key := PadWithZeros(boxKey.Text,KeySize);
  IV := PadWithZeros(boxIV.Text,BlockSize);
  // Decode the Base64 encoded string
  Data := Base64DecodeStr(boxCipherTextIn.Text);
  // Create the cipher and initialise according to the key length
  Cipher := TDCP_rijndael.Create(Self);
  if Length(boxKey.Text) &lt;= 16 then
    Cipher.Init(Key[1],128,@IV[1])
  else if Length(boxKey.Text) &lt;= 24 then
    Cipher.Init(Key[1],192,@IV[1])
  else
    Cipher.Init(Key[1],256,@IV[1]);
  // Decrypt the data
  Cipher.DecryptCBC(Data[1],Data[1],Length(Data));
  // Free the cipher and clear sensitive information
  Cipher.Free;
  FillChar(Key[1],Length(Key),0);
  // Display the result
  boxPlainTextOut.Text := Data;
end;
</code></pre>
","<p>The issue is related to character encoding but it is not that DCPCrypt is incapable of handling UTF-16.</p>

<p>PHP strings are UTF-8. So you are passing the password ('Key') from PHP to Dephi as a base64 encoded string. Bizarrely you are storing the decoded key in a UTF-16LE string. More appropriate would have been a rawbytestring or a TBytes or a TMemoryStream. The binary layout of the payload of Key is now different to what it would be on the encoding side because it is typed as a UTF16-LE (In incorrect Delphi terminology, 'unicode string' - A Microsoft and Embarcadero malapropism).</p>

<p>Also this line of code is wrong in a 'unicode' (sic) compiler for obvious reasons...</p>

<pre><code>FillChar(Key[1],Length(Key),0);
</code></pre>

<h2>Side note</h2>

<p>I am the author of TurboPower LockBox 3, and the number one issue I get in forums springs from confusion between ansistrings, utf-8 strings and utf-16le strings. A lot of people think that the password 'abc' as PHP understands it, is the same password as 'abc' in Delphi 2010. What cryptographic libraries use from password strings is the binary payload resulting from the encoding of the string, not its semantic meaning as a string.</p>
","2333","<php><delphi><rijndael>","4","9","2","2012-08-28 08:57:44","","2","2","","","","2012-08-17 05:12:37",""
"12000124","Delphi program using DCPcrypt does not decrypt from PHP after upgrade to XE2","<p>I have an application developed in Delphi 2007 in which a value is encrypted by PHP and decrypted in the application.  Encryption algorithm is RIJNDAEL 128.  When I moved the XE2 and installed the latest version of DCPcrypt the application run but is no longer able to decrypt the encrypted string from PHP.  The result appears like Chinese characters so I am wondering if I need to modify my handling of the encryption key, vector, or encrypted string to account for the fact that XE2 uses Unicode characters.</p>

<p>The PHP encryption is performed by the following:
    (mcrypt_cbc(MCRYPT_RIJNDAEL_128,$key,$date_str,MCRYPT_ENCRYPT,$iv))</p>

<p>And the two relevant Delphi functions are here:</p>

<pre><code>function PadWithZeros(const str : string; size : integer) : string;
var
  origsize, i : integer;
begin
  Result := str;
  origsize := Length(Result);
  if ((origsize mod size) &lt;&gt; 0) or (origsize = 0) then
  begin
    SetLength(Result,((origsize div size)+1)*size);
    for i := origsize+1 to Length(Result) do
      Result[i] := #0;
  end;
end;

procedure TfrmMain.btnDecryptClick(Sender: TObject);
var
  Cipher : TDCP_rijndael;
  Data, Key, IV : string;
begin
  // Pad Key and IV with zeros as appropriate
  Key := PadWithZeros(boxKey.Text,KeySize);
  IV := PadWithZeros(boxIV.Text,BlockSize);
  // Decode the Base64 encoded string
  Data := Base64DecodeStr(boxCipherTextIn.Text);
  // Create the cipher and initialise according to the key length
  Cipher := TDCP_rijndael.Create(Self);
  if Length(boxKey.Text) &lt;= 16 then
    Cipher.Init(Key[1],128,@IV[1])
  else if Length(boxKey.Text) &lt;= 24 then
    Cipher.Init(Key[1],192,@IV[1])
  else
    Cipher.Init(Key[1],256,@IV[1]);
  // Decrypt the data
  Cipher.DecryptCBC(Data[1],Data[1],Length(Data));
  // Free the cipher and clear sensitive information
  Cipher.Free;
  FillChar(Key[1],Length(Key),0);
  // Display the result
  boxPlainTextOut.Text := Data;
end;
</code></pre>
","<p>The application now compiles properly in XE2 and is able to decrypt records from the version compiled with Delphi 2007.  Thanks to all for your comments.  The different perspectives help to make clear when variables needed to be defined as ANSI string.</p>

<p>In case anyone else is trying a similar update and needs to decrypt cipher text generated in PHP, my decrypt function and the supporting padWithZeros() function came from the DCPcrypt site so I posting my modified code here.  I should also not that I installed the 7/21/2012 update to DCPcrypt for XE2 made available at the following location: <a href=""http://www.pepak.net/files/tools/dcpcrypt.zip"" rel=""nofollow"">http://www.pepak.net/files/tools/dcpcrypt.zip</a>.</p>

<pre><code>function TForm1.AESDecrypt(const DecKeyStr: AnsiString;
                              const DecIVStr: AnsiString;
                              const CypherTextIn: AnsiString): String;
var
  Cipher : TDCP_rijndael;
  Data, Key, IV : AnsiString;
begin
  // Pad Key and IV with zeros as appropriate
  Key := PadWithZeros(DecKeyStr,KeySize);
  IV := PadWithZeros(DecIVStr,BlockSize);
  // Decode the Base64 encoded string
  Data := Base64DecodeStr(CypherTextIn);
  // Create the cipher and initialise according to the key length
  Cipher := TDCP_rijndael.Create(nil);
  if Length(DecKeyStr) &lt;= 16 then
    Cipher.Init(Key[1],128,@IV[1])
  else if Length(DecKeyStr) &lt;= 24 then
    Cipher.Init(Key[1],192,@IV[1])
  else
    Cipher.Init(Key[1],256,@IV[1]);
  // Decrypt the data
  Cipher.DecryptCBC(Data[1],Data[1],Length(Data));
  // Free the cipher and clear sensitive information
  Cipher.Free;
  FillChar(Key[1],Length(Key),0);
  // Display the result
  Result := String(Data);
(* *)
end;

function TForm1.PadWithZeros(const str:AnsiString; size:integer):AnsiString;
var
  origsize, i : integer;
begin
  Result := str;
  origsize := Length(Result);
  if ((origsize mod size) &lt;&gt; 0) or (origsize = 0) then
  begin
    SetLength(Result,((origsize div size)+1)*size);
    for i := origsize+1 to Length(Result) do
      Result[i] := #0;
  end;
end;
</code></pre>
","2333","<php><delphi><rijndael>","4","3","2","2012-08-28 08:57:44","","2","2","","","","2012-08-17 05:12:37",""
"18249681","Cakephp encrypt an decrypt with RIJNDAEL","<p>I have a beforeSave and afterFind function in my Model. The function encrypt and decrypt the string successfully: </p>

<pre><code>    public function beforeSave($options = array()) {
   foreach($this-&gt;encryptedFields as $fieldName){
    if(!empty($this-&gt;data[$this-&gt;alias][$fieldName])){
        $this-&gt;data[$this-&gt;alias][$fieldName] = Security::rijndael($this-&gt;data[$this-&gt;alias][$fieldName], Configure::read('Security.key'), 'encrypt');
    }
}
return true;
</code></pre>

<p>}</p>

<p>But. If I do this</p>

<pre><code>    $mobileno = 1234
    $mobile = Security::rijndael($mobileNo, Configure::read('Security.key'), 'encrypt');
</code></pre>

<p>and then I run query for example like:</p>

<pre><code>   select * from table where mobileno = $mobileno;
</code></pre>

<p>I cant get the result. Because now the <code>mobileno</code> which is I encrypt above is different from the encrypt mobile number which is in db.</p>
","<p>That is because <a href=""https://github.com/cakephp/cakephp/blob/7d4f2293102fc8fd8b808da628052a5ff7eec85c/lib/Cake/Utility/Security.php#L206"" rel=""nofollow noreferrer""><code>Security::rijndael()</code></a> uses a random <a href=""http://de2.php.net/manual/en/function.mcrypt-create-iv.php"" rel=""nofollow noreferrer"">initialization vector</a> on every call.</p>

<p>In order to workaround this you would have to use a fixed IV, however this would degrade security, so that's not a good idea!</p>

<p>For such situations I usually add another field to the table where the unencrypted value is stored in the form of an <a href=""http://php.net/manual/en/function.hash-hmac.php"" rel=""nofollow noreferrer"">HMAC hash</a> (<em>not</em> a regular hash! Also should use a different secret/key than the one used for encryption!), that way the select can be easily done with the hash of the given value.</p>

<p>If you aren't able to use such a technique (ie utilizing a different value for identifying the record), then you might not get around selecting all datasets, decrypting them, and searching for the record in question manually.</p>

<p>If your DBMS supports AES encryption/decryption, you could try utilizing that functionality, it will most likely perform better than decrypting and selecting with PHP. But make sure that you assess possible security related pitfalls that might be introduced by exposing the encryption key to the DBMS!</p>
","2332","<cakephp><encryption><cakephp-2.0><cakephp-2.1><rijndael>","1","1","1","2019-02-05 14:45:58","18250735","0","","1368218","","2013-08-15 10:23:08","2013-08-15 09:17:02",""
"10952483","Decrypting AES with PHP's mcrypt","<p>Short question: I have encrypted a string with AES-256 with the openssl commandline tool. How can I decrypt this with PHP's openssl library? (since Rijndael-256 and AES-256 are not the same, and there is no AES-256 option)</p>

<p>Thanks in advance,
Jori.</p>
","<p>Shouldn't it be acceptable to use any routine to decrypt, as long as it decrypts AES-256?</p>

<p>Try this, previously seen on stackoverflow... it was just a google away... <a href=""https://stackoverflow.com/questions/3422759/php-aes-encrypt-decrypt"">PHP AES encrypt / decrypt</a></p>
","2313","<php><openssl><aes><rijndael>","1","-1","2","2012-06-08 17:49:54","10953662","4","","","","","2012-06-08 16:16:09",""
"10952483","Decrypting AES with PHP's mcrypt","<p>Short question: I have encrypted a string with AES-256 with the openssl commandline tool. How can I decrypt this with PHP's openssl library? (since Rijndael-256 and AES-256 are not the same, and there is no AES-256 option)</p>

<p>Thanks in advance,
Jori.</p>
","<p>You should use <code>MCRYPT_RIJNDAEL_128</code> instead of <code>MCRYPT_RIJNDAEL_256</code> but you should use a 256 bit key, preferably the one you encrypted the data with.</p>

<p>The X in <code>MCRYPT_RIJNDAEL_X</code> is the <em>block size</em> of the cipher. Rijndael has several block and key sizes, but only Rijndael with a block size of 128 bits and a key size of 128, 192 or 256 bits (and the key size specific vectors and number of rounds) should be called AES.</p>

<p>Make sure you also match the encryption mode (the unsafe ECB or CBC encoding) and make sure your (un)padding is correct.</p>
","2313","<php><openssl><aes><rijndael>","1","2","2","2012-06-08 17:49:54","10953662","4","","","","","2012-06-08 16:16:09",""
"331468","Encryption algorithm/library for .NET 2.0 + C++","<p>I need a standard, Microsoft delivered, encryption library that works for both .NET 2.0 and C++. What would you suggest?</p>

<p>We find that AES is only offered in .NET 3.5 (and available in C++)</p>

<p>We find that Rijndael is used in .NET 2.0 but not available in the standard C++ libraries.</p>

<p>If I am wrong (very good chance), can you point me in the right direction?</p>

<p>Worst case scenario, I suppose I can call the Rijndael algorithm from .NET using PInvoke but I would rather have a native solution.</p>
","<p>3DES is available via Capicom.  See <a href=""http://msdn.microsoft.com/en-us/library/aa382010(VS.85).aspx"" rel=""nofollow noreferrer"">here</a> for info.</p>
","2304","<c++><encryption><.net-2.0><aes><rijndael>","2","0","4","2009-05-13 15:37:06","331932","0","1","","","","2008-12-01 17:02:35",""
"331468","Encryption algorithm/library for .NET 2.0 + C++","<p>I need a standard, Microsoft delivered, encryption library that works for both .NET 2.0 and C++. What would you suggest?</p>

<p>We find that AES is only offered in .NET 3.5 (and available in C++)</p>

<p>We find that Rijndael is used in .NET 2.0 but not available in the standard C++ libraries.</p>

<p>If I am wrong (very good chance), can you point me in the right direction?</p>

<p>Worst case scenario, I suppose I can call the Rijndael algorithm from .NET using PInvoke but I would rather have a native solution.</p>
","<p>AES and Rijndael are essentially the same algorithm with a restriction on block size and cipher mode. So as long as you can live with the <a href=""http://blogs.msdn.com/shawnfa/archive/2006/10/09/The-Differences-Between-Rijndael-and-AES.aspx"" rel=""nofollow noreferrer"">restrictions</a> (which are not onerous) you can use them interchangeably.</p>
","2304","<c++><encryption><.net-2.0><aes><rijndael>","2","3","4","2009-05-13 15:37:06","331932","0","1","","","","2008-12-01 17:02:35",""
"331468","Encryption algorithm/library for .NET 2.0 + C++","<p>I need a standard, Microsoft delivered, encryption library that works for both .NET 2.0 and C++. What would you suggest?</p>

<p>We find that AES is only offered in .NET 3.5 (and available in C++)</p>

<p>We find that Rijndael is used in .NET 2.0 but not available in the standard C++ libraries.</p>

<p>If I am wrong (very good chance), can you point me in the right direction?</p>

<p>Worst case scenario, I suppose I can call the Rijndael algorithm from .NET using PInvoke but I would rather have a native solution.</p>
","<p>We successfully do a similar thing that I hope might help you:</p>

<h3>C++ CryptoAPI</h3>

<ul>
<li><a href=""http://msdn.microsoft.com/en-us/library/aa380239(VS.85).aspx"" rel=""nofollow noreferrer"">CryptoAPI</a> is pure Win32 (c/c++), native to all Microsoft OS's. </li>
<li>Use <a href=""http://msdn.microsoft.com/en-us/library/aa386986(VS.85).aspx"" rel=""nofollow noreferrer"">Enhanced Cryptographic Provider</a> (<code>MS_ENHANCED_PROV</code>) </li>
<li>Use <a href=""http://msdn.microsoft.com/en-us/library/aa382020(VS.85).aspx"" rel=""nofollow noreferrer"">Triple DES</a> (<code>CALG_3DES</code>) algorithm</li>
</ul>

<h3>.NET TripleDes Provider</h3>

<ul>
<li>Use <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledescryptoserviceprovider(VS.80).aspx"" rel=""nofollow noreferrer"">TripleDESCryptoServiceProvider</a> on the .NET side.</li>
</ul>

<h3>Side Notes</h3>

<ul>
<li>We <strong>avoid CAPICOM</strong> like the plague as the deployment nightmares that come with it are not worth the hassle.</li>
<li>Byte order on the .NET side can come into play at times. For example, to consume a key that is generated on the C++ (CryptoAPI)  side, you need to reverse the byte array prior to using it within the TripleDESCryptoServiceProvider.</li>
</ul>

<p>If you would like more details please leave a comment and I can give more. Happy crypto!</p>
","2304","<c++><encryption><.net-2.0><aes><rijndael>","2","3","4","2009-05-13 15:37:06","331932","0","1","","","","2008-12-01 17:02:35",""
"331468","Encryption algorithm/library for .NET 2.0 + C++","<p>I need a standard, Microsoft delivered, encryption library that works for both .NET 2.0 and C++. What would you suggest?</p>

<p>We find that AES is only offered in .NET 3.5 (and available in C++)</p>

<p>We find that Rijndael is used in .NET 2.0 but not available in the standard C++ libraries.</p>

<p>If I am wrong (very good chance), can you point me in the right direction?</p>

<p>Worst case scenario, I suppose I can call the Rijndael algorithm from .NET using PInvoke but I would rather have a native solution.</p>
","<p>Windows includes a C/C++ AES encryption library, as part of the <a href=""http://msdn.microsoft.com/en-us/library/aa386979(VS.85).aspx"" rel=""nofollow noreferrer"">AES Cryptographic Services Provider</a>.   It is suitable for use from within native C/C++ applications. </p>
","2304","<c++><encryption><.net-2.0><aes><rijndael>","2","0","4","2009-05-13 15:37:06","331932","0","1","","","","2008-12-01 17:02:35",""
"12897260","Java AES-256 Decryption - translating code from ActionScript 3","<p>I have a working decryption in ActionScript 3, now I want to get the same result when decrypting in Java. (I know that the OFB-mode and NullPadding is probably not preferred, but that's what I used back then and that is what I need to decrypt now...)</p>

<p>(very old) Adobe ActionScript 3 code:</p>

<pre><code>static public function decryptTest(): Boolean {
    var iv: String = ""0df1eff724d50157ab048d9ff214b73c"";
    var cryptext: String = ""2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f"";
    var kkey: String = ""375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be"";

    var kdata: ByteArray = Hex.toArray(kkey);
    var data: ByteArray = Hex.toArray(cryptext);
    var name: String = 'aes-256-ofb';
    var pad:IPad = new NullPad();
    var mode: ICipher = Crypto.getCipher(name, kdata, pad);
    pad.setBlockSize(mode.getBlockSize());
    trace(""mode block size: "" + mode.getBlockSize());

    if (mode is IVMode) {
        var ivmode:IVMode = mode as IVMode;
        ivmode.IV = Hex.toArray(iv);
    }
    mode.decrypt(data);

    var res: String = data.toString();
    trace(""result: "" + res);

    return res == ""01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef"";
}

trace(""decryption test: "" + netplay.decryptTest());
</code></pre>

<p>Flash output is:</p>

<pre><code>mode block size: 16
result: 01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef
decryption test: true
</code></pre>

<p><strong>What have I tried?</strong></p>

<p>I have tried two different approaches in Java, one using the built-in <code>Cipher</code> class, and one using <a href=""http://www.devkb.org/java/50-AES-256-bits-encrypter-decrypter-Java-source-code"" rel=""nofollow"">this code/class</a>. However, the first approach gives me an IllegalKeyException and the other is giving me garbage. Also, the second approach doesn't clearly specify how to enter the IV-data for the decryption, nor does it let me specify the OFB-mode or the padding.</p>

<pre><code>java.security.InvalidKeyException: Illegal key size
    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1023)
    at javax.crypto.Cipher.implInit(Cipher.java:789)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:848)
    at javax.crypto.Cipher.init(Cipher.java:1347)
    at javax.crypto.Cipher.init(Cipher.java:1281)
    at test.net.zomis.ZomisTest.decryptCipher(ZomisTest.java:112)
@Test
public void decryptCipher() throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
    String iv = ""0df1eff724d50157ab048d9ff214b73c"";
    String cryptext = ""2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f"";
    String key = ""375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be""; // Hexadecimal String, will be converted to non-hexadecimal String
    String expectedResult = ""01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef"";

    byte[] kdata = Util.hex2byte(key);

    Assert.assertEquals(32, kdata.length); // 32 bytes = 256-bit key

    String result;

    Cipher cipher;
    cipher = Cipher.getInstance(""AES/OFB/NoPadding"");
    // Below line is 112, which is causing exception
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(kdata, ""AES""), new IvParameterSpec(iv.getBytes(""UTF-8"")));
    byte[] cryptData = Util.hex2byte(cryptext);
    byte[] ciphertext = cipher.doFinal(cryptData);
    result = new String(ciphertext);


    Assert.assertEquals(expectedResult, result);
}

@Test
public void decryptAES() {
    String iv = ""0df1eff724d50157ab048d9ff214b73c""; 
    // Problem: Where should I specify the IV ???? Currently it is an unused variable...

    String cryptext = ""2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f"";
    String key = ""375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be""; // Hexadecimal String, will be converted to non-hexadecimal String
    String expectedResult = ""01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef"";

    Assert.assertEquals(64, key.length());

    AES aes = new AES();
    aes.setKey(Util.hex2byte(key));
    byte[] byteCryptedData = Util.hex2byte(cryptext);
    String byteCryptedString = new String(byteCryptedData);

    while (byteCryptedString.length() % 16 != 0) byteCryptedString += "" "";


    String result = aes.Decrypt(byteCryptedString);
    Assert.assertEquals(expectedResult, result); // Assertion Failed
}
</code></pre>

<p><strong>The question:</strong>
How can I make Java decrypt in the same way that ActionScript 3 does? Of course, I'd like to get the same result on both.</p>
","<p>Yes there are such libraries, have a look at <a href=""http://www.bouncycastle.org/"" rel=""nofollow noreferrer"">http://www.bouncycastle.org/</a> . This is a bit more specific <a href=""https://stackoverflow.com/questions/2435338/java-bouncy-castle-cryptography-encrypt-with-aes"">Java Bouncy Castle Cryptography - Encrypt with AES</a></p>
","2273","<java><actionscript-3><encryption><aes><rijndael>","1","0","2","2013-11-11 12:55:22","12897547","1","","1310566","","2013-11-07 13:48:45","2012-10-15 14:01:03",""
"12897260","Java AES-256 Decryption - translating code from ActionScript 3","<p>I have a working decryption in ActionScript 3, now I want to get the same result when decrypting in Java. (I know that the OFB-mode and NullPadding is probably not preferred, but that's what I used back then and that is what I need to decrypt now...)</p>

<p>(very old) Adobe ActionScript 3 code:</p>

<pre><code>static public function decryptTest(): Boolean {
    var iv: String = ""0df1eff724d50157ab048d9ff214b73c"";
    var cryptext: String = ""2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f"";
    var kkey: String = ""375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be"";

    var kdata: ByteArray = Hex.toArray(kkey);
    var data: ByteArray = Hex.toArray(cryptext);
    var name: String = 'aes-256-ofb';
    var pad:IPad = new NullPad();
    var mode: ICipher = Crypto.getCipher(name, kdata, pad);
    pad.setBlockSize(mode.getBlockSize());
    trace(""mode block size: "" + mode.getBlockSize());

    if (mode is IVMode) {
        var ivmode:IVMode = mode as IVMode;
        ivmode.IV = Hex.toArray(iv);
    }
    mode.decrypt(data);

    var res: String = data.toString();
    trace(""result: "" + res);

    return res == ""01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef"";
}

trace(""decryption test: "" + netplay.decryptTest());
</code></pre>

<p>Flash output is:</p>

<pre><code>mode block size: 16
result: 01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef
decryption test: true
</code></pre>

<p><strong>What have I tried?</strong></p>

<p>I have tried two different approaches in Java, one using the built-in <code>Cipher</code> class, and one using <a href=""http://www.devkb.org/java/50-AES-256-bits-encrypter-decrypter-Java-source-code"" rel=""nofollow"">this code/class</a>. However, the first approach gives me an IllegalKeyException and the other is giving me garbage. Also, the second approach doesn't clearly specify how to enter the IV-data for the decryption, nor does it let me specify the OFB-mode or the padding.</p>

<pre><code>java.security.InvalidKeyException: Illegal key size
    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1023)
    at javax.crypto.Cipher.implInit(Cipher.java:789)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:848)
    at javax.crypto.Cipher.init(Cipher.java:1347)
    at javax.crypto.Cipher.init(Cipher.java:1281)
    at test.net.zomis.ZomisTest.decryptCipher(ZomisTest.java:112)
@Test
public void decryptCipher() throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
    String iv = ""0df1eff724d50157ab048d9ff214b73c"";
    String cryptext = ""2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f"";
    String key = ""375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be""; // Hexadecimal String, will be converted to non-hexadecimal String
    String expectedResult = ""01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef"";

    byte[] kdata = Util.hex2byte(key);

    Assert.assertEquals(32, kdata.length); // 32 bytes = 256-bit key

    String result;

    Cipher cipher;
    cipher = Cipher.getInstance(""AES/OFB/NoPadding"");
    // Below line is 112, which is causing exception
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(kdata, ""AES""), new IvParameterSpec(iv.getBytes(""UTF-8"")));
    byte[] cryptData = Util.hex2byte(cryptext);
    byte[] ciphertext = cipher.doFinal(cryptData);
    result = new String(ciphertext);


    Assert.assertEquals(expectedResult, result);
}

@Test
public void decryptAES() {
    String iv = ""0df1eff724d50157ab048d9ff214b73c""; 
    // Problem: Where should I specify the IV ???? Currently it is an unused variable...

    String cryptext = ""2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f"";
    String key = ""375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be""; // Hexadecimal String, will be converted to non-hexadecimal String
    String expectedResult = ""01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef"";

    Assert.assertEquals(64, key.length());

    AES aes = new AES();
    aes.setKey(Util.hex2byte(key));
    byte[] byteCryptedData = Util.hex2byte(cryptext);
    String byteCryptedString = new String(byteCryptedData);

    while (byteCryptedString.length() % 16 != 0) byteCryptedString += "" "";


    String result = aes.Decrypt(byteCryptedString);
    Assert.assertEquals(expectedResult, result); // Assertion Failed
}
</code></pre>

<p><strong>The question:</strong>
How can I make Java decrypt in the same way that ActionScript 3 does? Of course, I'd like to get the same result on both.</p>
","<p>The first approach is giving you an <code>Illegal key size</code> error message because you don't have the unrestricted policy files installed. Java will refuse to work with ""strong"" key lengths (e.g. 256-bit AES) without these in place.</p>

<p>If it is legal to do so in your jurisdiction, Google for ""<em>Unlimited Strength Jurisdiction Policy Files</em>"" and download the version applicable to your Java installation. You will end up with two files to dump into <code>lib/security</code> in your JRE.</p>
","2273","<java><actionscript-3><encryption><aes><rijndael>","1","2","2","2013-11-11 12:55:22","12897547","1","","1310566","","2013-11-07 13:48:45","2012-10-15 14:01:03",""
"20781538","Decrypt a file in iOS Objective-C encrypted using RijndaelManaged class","<p>I am encrypting files in C# using the RijndaelManaged class using the following code:</p>

<pre><code>RijndaelManaged RMCrypto = new RijndaelManaged();

byte[] keyArray = UTF8Encoding.UTF8.GetBytes(""**Random Passphrase**""); // 256-AES key             
RMCrypto.Key = keyArray;
RMCrypto.Mode = CipherMode.ECB;

FileStream fsCrypt = new FileStream(outputFile, FileMode.Create);

ICryptoTransform cTransform = RMCrypto.CreateEncryptor();
CryptoStream cs = new CryptoStream(fsCrypt, cTransform, CryptoStreamMode.Write);

FileStream fsIn = new FileStream(inputFile, FileMode.Open);

byte[] buffer = new byte[8 * 16384];
int len;
while ((len = fsIn.Read(buffer, 0, buffer.Length)) &gt; 0)
{
    cs.Write(buffer, 0, len);
}

fsIn.Close();
cs.Close();
fsCrypt.Close();
</code></pre>

<p>How can I decrypt the same file in iOS Objective-C and use it?</p>
","<p>You should be able to use the Apple supplied CommonCrypto functions. There are several answers here on SO with code and several 3rd party project such as RNCryptor that encapsulate CommonCrypto including availability via CocoaPods.</p>

<p>What is necessary is matching all the parameters such as key size (128/192/256), key, iv, data, mode and padding.</p>

<p>AES is a subset of Rijndael and generally there is no compatibility issue as long as the block size is 128 bits.</p>

<p>See my SO <a href=""https://stackoverflow.com/a/10078625/451475"">example code</a>.</p>
","2269","<c#><objective-c><encryption><aes><rijndael>","1","1","1","2014-10-06 17:57:56","20786282","0","","447156","","2013-12-26 08:21:40","2013-12-26 08:20:45",""
"5296532","Rijndael encryption in Ruby","<p>I am totally new to encryption, so this question might be trivial - however, I had to google for 2 hours to understand even the basic terms, so bear with me.</p>

<p>The string I need to send is a Base64 Encoded String of an encrypted JSON object. Here's the spec they sent me:</p>

<ul>
<li>Encryption Method: Rijndael </li>
<li>Cipher Mode: CBC </li>
<li>Padding Mode: PKCS7</li>
<li>We will provide you with a custom Base64Encoded Key and IV.</li>
</ul>

<p>I checked out crypt's Rijndael algorithm, but I don't see where to plug the IV into... Not sure if CBC and PKCS7 are default - if they aren't, I don't know how to change these either...</p>

<p>So:</p>

<ul>
<li>Can be crypt easily modified to support this stuff?</li>
<li>Maybe it does support it already as-it-is, just my total lack of cryptographic knowledge doesn't allow for a proper use?</li>
<li>If neither of the above, is it possible to do this in Ruby?</li>
</ul>
","<p>I pretty much doubt they really use Rijndael. They likely use AES (which is is subset of Rijndael with fixed 128 bits block size and only three standardized key size (128,192 and 256 bits)). Without them supplying blocksize and keysize you cannot be sure anyway, you can likely assume AES-128, but their spec is incomplete at best.</p>

<p>The IV is not related to the cipher algorithm but to the chaining mode, in your case CBC.</p>

<p>AES, CBC, PKCS7 are available in Ruby via OpenSSL, shouldn't be too much trouble.</p>

<p>Edit: people thinking they use Rijndael make me think they use .NET, in which case that question should solve your issues : <a href=""https://stackoverflow.com/questions/2044517/how-to-decode-rijndael-in-ruby-encoded-in-vb-net"">How to decode Rijndael in ruby (encoded in VB.net)</a></p>
","2200","<ruby><encryption><rijndael>","1","3","2","2014-08-07 18:01:15","5298276","0","","","","","2011-03-14 09:00:58",""
"5296532","Rijndael encryption in Ruby","<p>I am totally new to encryption, so this question might be trivial - however, I had to google for 2 hours to understand even the basic terms, so bear with me.</p>

<p>The string I need to send is a Base64 Encoded String of an encrypted JSON object. Here's the spec they sent me:</p>

<ul>
<li>Encryption Method: Rijndael </li>
<li>Cipher Mode: CBC </li>
<li>Padding Mode: PKCS7</li>
<li>We will provide you with a custom Base64Encoded Key and IV.</li>
</ul>

<p>I checked out crypt's Rijndael algorithm, but I don't see where to plug the IV into... Not sure if CBC and PKCS7 are default - if they aren't, I don't know how to change these either...</p>

<p>So:</p>

<ul>
<li>Can be crypt easily modified to support this stuff?</li>
<li>Maybe it does support it already as-it-is, just my total lack of cryptographic knowledge doesn't allow for a proper use?</li>
<li>If neither of the above, is it possible to do this in Ruby?</li>
</ul>
","<h1><a href=""http://ruby-doc.org/gems/docs/c/crypt-1.1.4/Crypt/Rijndael.html"" rel=""nofollow"">Crypt::Rijndael</a></h1>

<p>This is included in ruby now and can do the decryption of Rijndael easily.</p>
","2200","<ruby><encryption><rijndael>","1","0","2","2014-08-07 18:01:15","5298276","0","","","","","2011-03-14 09:00:58",""
"25494592","Why does RijndaelManaged 256 bit is giving me ""specified key is not a valid size for this algorithm"" error?","<p>I'm unable to make the C# RijndaelManaged encryption work with PHP mcrypt_encrypt as I kept getting ""Specified key is not a valid size for this algorithm"".</p>

<p>The PHP specification use 256 bit, with ECB cipher mode.   My understanding is Initization Vector is not used when in ECB mode.</p>

<p>We're using temporary key to get this working in development project, to keep on building the developmental application and we'll issue a new secure key much later.</p>

<pre><code>[PHP]
$plaintext = '1~ABCDEFG~1408740350~0~';

for($i = 1; $i &lt;= 32; $i++) { $key .= chr($i); }

$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $plaintext, 'ecb', '');


[C#]
string postFormData = ""1~ABCDEFG~1408740350~0~"";
StringBuilder sb = new StringBuilder();
foreach (var b in Encoding.ASCII.GetBytes(String.Concat(Enumerable.Range(1, 32)))) { sb.AppendFormat(""{0}"", b); }
postedFormData = RijndaelAES.Encrypt(postedFormData, sb.ToString());

public static string Encrypt(string plainText, string key)
{
    string cipherText;
    var rijndael = new RijndaelManaged()
    {
        Key = Encoding.UTF8.GetBytes(key),
        Mode = CipherMode.ECB,
        BlockSize = 256, //128,
        Padding = PaddingMode.Zeros//, 
        //IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    };
    ICryptoTransform encryptor = rijndael.CreateEncryptor(rijndael.Key, null);

    using (var memoryStream = new MemoryStream())
    {
        using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
        {
            using (var streamWriter = new StreamWriter(cryptoStream))
            {
                streamWriter.Write(plainText);
                streamWriter.Flush();
            }
            cipherText = Convert.ToBase64String(memoryStream.ToArray());
        }
    }
    return cipherText;
}
</code></pre>
","<p>Rijndael/AES has a fixed block size of 128 (in all implementations). You probably meant to set the <em>key size</em>, not the block size.</p>

<p>Also, the way you convert the key to bytes is highly unusual (it is amazing, actually). I don't think you really understand encodings. This is an important topic to research. Probably, that PHP version is assuming the string to be ASCII. In C#, you can do it like this:</p>

<pre><code>string keyStr = ...;
Debug.Assert(keyStr.Length == (256 / 8));

byte[] keyBytesASCII = Encoding.ASCII.GetBytes(keyStr);
Debug.Assert(keyBytesASCII.Length == (256 / 8));
Debug.Assert(keyBytesASCII.Length == keyStr.Length);
</code></pre>

<p>In the future you can debug problems like this by looking at important values using the <strong>debugger</strong>. I think you'd find that the key you set is not of the expected length.</p>
","2164","<c#><rijndael><rijndaelmanaged>","0","1","1","2014-08-26 20:25:40","25495483","8","","1633604","","2014-08-26 20:25:40","2014-08-25 21:23:45",""
"15170808","Encrypt and decrypt doesn't give the same plain text using AES/ECB/NoPadding","<pre><code>String plain1= ""Test"";
byte[] cipher = SplashSecure.getInstance().encrypt2(plain1);
String plain2 = SplashSecure.getInstance().decrypt2(cipher);
</code></pre>

<blockquote>
  <p>plain = Test������������������������</p>
</blockquote>

<p>After decryption <code>plainText2</code> should be equal to <code>plaintext</code>. But it's not.</p>

<p>Encrypt/Decrypt methods.</p>

<pre><code> public void initKey(String key) {
    String paddedKey = Utils.padString(key);
    mKeyspec = new SecretKeySpec(Utils.getBytes(paddedKey), ""AES/ECB/NoPadding"");
                   // Utils.getBytes returns ""paddedKey.getBytes(""CP1252"")""
 }

public byte[] encrypt2(String data) {
    try {
        Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, mKeyspec);
        String paddedData = Utils.padString(data);
        return cipher.doFinal(Utils.getBytes(paddedData));

    } catch(InvalidKeyException e) {
        e.printStackTrace();
    // Series of catch blocks
    }
    return null;
}

public String decrypt2(byte[] cypherText) {
    try {
        Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");
        cipher.init(Cipher.DECRYPT_MODE, mKeyspec);
        byte[] plainTextBytes = cipher.doFinal(cypherText);
        return Utils.getString(plainTextBytes);
        // Utils.getString returns ""new String(bytes, ""CP1252"");""
    } catch(InvalidKeyException e) {
        // Series of catch blocks.
    } 
    return null;
}
</code></pre>

<h2>Edit</h2>

<pre><code>public static String padString(String source) {
    char paddingChar = '\0';
    int size = 16;
    int padLength = size - source.length() % size;

    for (int i = 0; i &lt; padLength; i++) {
        source += paddingChar;
    }

    return source;
}
</code></pre>

<h2>Edit</h2>

<p>I'm trying to get the encryption-decryption working across Windows (other client that encrypts, and server) and Android. The Windows client is a VC++ app that uses a Rijndael class (<a href=""http://svn.openfoundry.org/pcman/2007.06.03/Lite/Rijndael.h"" rel=""nofollow noreferrer"">http://svn.openfoundry.org/pcman/2007.06.03/Lite/Rijndael.h</a>) and Android uses <a href=""http://www.cs.ucdavis.edu/~rogaway/ocb/ocb-java/Rijndael.java"" rel=""nofollow noreferrer"">http://www.cs.ucdavis.edu/~rogaway/ocb/ocb-java/Rijndael.java</a>. The Windows client has encrypted the data and stored it on the server. I need to build a client for android that fetches the encrypted data, decrypt it and display to the user. </p>

<p>I'm sure I'm using the correct key to decrypt. </p>
","<p>AES has a block size of 128 bits (i.e 16 bytes). It can <em>only</em> process data in blocks of this size, so even though you have told it to use <code>NoPadding</code> it is unable to comply.</p>

<p>The most likely thing that is happening here is that the AES implementation you are using is internally padding your four bytes of input up to 16 bytes and encrypting the result. When you decrypt, you get the same 16 bytes back out, i.e. 'T', 'e', 's', 't' and 12 garbage bytes.</p>

<p>The output you see supports this: ""Test"" followed by 24 <code>?</code> symbols. I don't know why it's printing two <code>?</code> symbols for each garbage byte, but I'm guessing it's something to do with interpreting the garbage bytes in unicode. You could see what is going on by printing out the raw byte values of the decrypted blob.</p>

<p>The short answer is that 'NoPadding' doesn't make sense for a block cipher (or, rather, if you are going to use NoPadding then you have to pad and unpad things yourself).</p>
","2145","<java><encryption><aes><rijndael>","1","2","1","2019-09-09 21:07:04","","15","3","472495","","2019-09-09 21:07:04","2013-03-02 04:44:47",""
"14409371","PHP decrypt with Rijndael-128","<p>I have a function in php which decrypt as the title.
This function decode from base64 and decrypt correctly:</p>

<pre><code>function decrypt($base64encoded_ciphertext) {

    $key = 'a16byteslongkey!a16byteslongkey!';

    $plaintext = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, base64_decode($base64encoded_ciphertext), MCRYPT_MODE_CBC);
    $plaintext = trim($plaintext);

    //Sostituisco tutti i caratteri fasulli
    for($i=0; $i&lt;32; $i++) $plaintext = str_replace(chr($i), """", $plaintext);

    return $plaintext;
}
</code></pre>

<p>But..if i send in input this string: <strong>Da/itClhHEVQH9BfL/gIug==</strong></p>

<p>it return this: <strong>100000065912248XNš!†Özé‰ÎªãaóÒ]`-ÐüõÁÔ…ayã›[¿gp—›s.ýý 3á«uÛ§hZ¼ú™R2.</strong></p>

<p>instead of only <strong>100000065912248</strong></p>

<p>I have tried with a tool online and a encrypted string is correctly..</p>

<p><img src=""https://i.stack.imgur.com/Ax3O9.png"" alt=""the online tool""></p>

<p>Thank you!</p>
","","2134","<php><aes><encryption><rijndael>","0","","0","2013-07-30 14:42:46","","8","","1973344","","2013-01-18 23:51:46","2013-01-18 23:36:10",""
"29306758","Rijndael 128/256 decryption","<p>I tried many answers from SO and all over the web but still without success. </p>

<p>I use following <a href=""http://www.bierkandt.org/encryption/symmetric_encryption.php"" rel=""nofollow"">tool</a> to encrypt.</p>

<pre><code>text to encrypt: tom
key: exo123exo1exo123
input (textfield or selected file above) is: text/binary
Convert output to: [i leave this unselected]
Mode: CTR
Ciphers: Rijndael-128 and Rijndael-256
</code></pre>

<p>After getting result I move <a href=""http://www.bierkandt.org/encryption/encoding.php"" rel=""nofollow"">here</a>:</p>

<p>and encode it with base64. </p>

<p>Then I copy string and send it as a parameter to my function:</p>

<pre><code>public String authenticate(String base64EncodedData){

    byte[] input = Base64.decodeBase64(base64EncodedData);
    byte[] ivBytes = ""1234567812345678"".getBytes();


    Cipher cipher = Cipher.getInstance(""AES/CTR/NoPadding"");

    cipher.init(
        Cipher.DECRYPT_MODE,
        new SecretKeySpec(""exo123exo1exo123"".getBytes(), ""AES""),
        new IvParameterSpec(ivBytes)
    );

    byte[] plainText = new byte[cipher.getOutputSize(input.length)];
    int plainTextLength = cipher.update(input, 0, input.length, plainText, 0);
    plainTextLength += cipher.doFinal(plainText, plainTextLength);

    return new String(plainText);  
  }
</code></pre>

<p>Result I got is always something similar to this (no matter if I use Rijndael-128 or 256 encrypted string):</p>

<pre><code>.�v�Y�
</code></pre>

<p>When I try to return <code>input</code> value - I get the encrypted string. So base64 works just fine. 
What I do wrong? 
Am slowly getting mad here. 
Thank you.</p>
","<p>There are some problem with your assumptions and your code:</p>

<ol>
<li><p>The output of the first tool is already Base 64 encoded. RIJNDAEL-128: <code>r0GR</code> and RIJNDAEL-256: <code>yAVy</code>. It doesn't need to be encoded a second time. It automatically selects this option, because binary data cannot be printed.</p></li>
<li><p>There is no native Rijndael-256 in Java, you will have to use BouncyCastle for this. Rijndael-128 is supposed to be AES which means that both have a block size of 128-bit.</p></li>
<li><p>The IV almost certainly needs to consist of zero bytes. For example:</p>

<pre><code>byte[] ivBytes = new byte[16];
Arrays.fill(ivBytes, (byte)0); // might not be necessary
</code></pre>

<p>Note that CTR mode doesn't use an IV, but rather a nonce.</p></li>
<li><p>Always specify an encoding when retrieving bytes: <code>""exo123exo1exo123"".getBytes(""UTF-8"")</code>. It is probably best to use UTF-8 everywhere. If you send data across systems that use different system encodings, it will lead to hard to find problems.</p></li>
</ol>

<hr>

<p>On second look at the online tool is not usable for anything, because it is unclear how it works. What I found:</p>

<ul>
<li><p>Any key produces a ciphertext regardless of size, which suggests that the ""key"" that you enter is actually <em>hashed</em> and there exist a million ways that could be done. I could decrypt it with the above method, so the key is actually uses as-is without hashing. This suggests that the key is filled up with 0x00 bytes until a valid key size. When the key size is too big, it is probably truncated.</p></li>
<li><p>Plaintext of 16 characters encrypts to a ciphertext of 16 bytes (encoded 24) and a plaintext of 17 characters encrypts to a ciphertext of 32 bytes (encoded 44). This means that no discernible padding is used which might actually be zero padding.</p></li>
</ul>

<p>And here is the <strong>deal breaker</strong>:</p>

<ul>
<li>Every time you encrypt something, you get a different ciphertext. In CBC mode it means a random IV is generated before encrypting. The problem is that this IV is not shown. So there is no way to decrypt this fully. So if you encrypt more than 16 characters you can recover all but the first 16 characters when you decrypt it in the way I describe it in the first part of this answer.</li>
</ul>

<hr>

<p>You shouldn't make your system dependent on closed source online tools. Write your own encryption tool. Some general advice:</p>

<ul>
<li><p>IV should be generated randomly every time you encrypt something. It is not secrect, but should be unique. Simply prepend it to the ciphertext after encryption and slice it off before decryption.</p></li>
<li><p>Use an authenticated mode like CCM or GCM where possible. It is harder to do authenticated encryption yourself, but the other way to go would be to use encrypt-then-mac paradigm.</p></li>
</ul>
","2123","<java><encryption><aes><rijndael>","1","2","1","2015-03-27 23:31:49","29307140","3","","1816580","","2015-03-27 23:04:18","2015-03-27 17:34:29",""
"12661675","rijndael: Encrypt/decrypt the same data in C and Python","<p>I'm trying to figure out how to mirror encryption/decryption from an existing C function over to python. However, in my tests of encrypting with C and decrypting with python, I can't figure out some elements around the key.</p>

<p>These were all code samples online, so I commented things like the base64 call in Python, and at this point I'm unsure on:</p>

<p><strong>1) If I correctly determined the KEYBIT to KEY_SIZE/BLOCK_SIZE settings.</strong></p>

<p><strong>2) How to get from password to key in python to match the C code.</strong></p>

<p><strong>3) Am I  missing any core conversion steps?</strong></p>

<p>rijndael.h in C:</p>

<pre><code>#define KEYLENGTH(keybits) ((keybits)/8)
#define RKLENGTH(keybits)  ((keybits)/8+28)
#define NROUNDS(keybits)   ((keybits)/32+6)
</code></pre>

<p>encrypting in C</p>

<pre><code>#define KEYBITS 256

unsigned long rk[RKLENGTH(KEYBITS)];
unsigned char key[KEYLENGTH(KEYBITS)];

char *password = ""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"";

for (i = 0; i &lt; sizeof(key); i++)
    key[i] = *password != 0 ? *password++ : 0;  

nrounds = rijndaelSetupEncrypt(rk, key, 256);

count = 0;
while (count &lt; strlen(input)) {
    unsigned char ciphertext[16];
    unsigned char plaintext[16];
    for (i = 0; i &lt; sizeof(plaintext); i++) {
        if (count &lt; strlen(input))
            plaintext[i] = input[count++];
        else
            plaintext[i] = 0;
    }
    rijndaelEncrypt(rk, nrounds, plaintext, ciphertext);
    if (fwrite(ciphertext, sizeof(ciphertext), 1, output) != 1)             
        fclose(file);
        fputs(""File write error"", stderr);
        return 0;
    }
}
</code></pre>

<p>Decrypt in Python</p>

<pre><code>KEY_SIZE = 32
BLOCK_SIZE = 16

def decrypt(password, filename):

    #
    # I KNOW THIS IS WRONG, BUT HOW DO I CONVERT THE PASSWD TO KEY?
    #
    key = password

    padded_key = key.ljust(KEY_SIZE, '\0')

    #ciphertext = base64.b64decode(encoded)
    ciphertext = file_get_contents(filename);

    r = rijndael(padded_key, BLOCK_SIZE)

    padded_text = ''
    for start in range(0, len(ciphertext), BLOCK_SIZE):
        padded_text += r.decrypt(ciphertext[start:start+BLOCK_SIZE])

    plaintext = padded_text.split('\x00', 1)[0]

    return plaintext
</code></pre>

<p>Thanks!</p>
","<p>The example C code just copies 32 bytes from the <code>password</code> string into the key. If the key is less than 32 bytes, it padds on the right with zeroes.
Translated into python, this would be:</p>

<pre><code>key = password[:32]+b'\x00'*(32-len(password))
</code></pre>

<p>Which actually produces the same result as</p>

<pre><code>password.ljust(32, '\0')
</code></pre>

<p>You should note however that this method of generating keys is considerd <a href=""http://bityard.blogspot.nl/2012/08/symmetric-crypto-with-pycrypto-part-3.html"" rel=""nofollow""><em>extremely unsafe</em></a>. If the attacker suspects that the key consists of ASCII characters padded with 0 bytes, the keyspace (amount of possible keys) is reduced considerably. If the key is made out of random bytes, there are 256^32 = 1.15e77 keys. If the key e.g. begins with 8 ASCII characters followed by zeroes, there are only (127-32)^8 =  6.63e15 possible keys. And since there are <a href=""http://www.skullsecurity.org/wiki/index.php/Passwords"" rel=""nofollow"">dictionaries</a> out there with often-used passwords, the attacker probably wouldn't have to exhaust this reduced keyspace; he would try the relatively small dictionaries first.</p>

<p>Consider using a <a href=""http://en.wikipedia.org/wiki/Cryptographic_hash_function"" rel=""nofollow"">cryptographic hash function</a> or another proper <a href=""http://en.wikipedia.org/wiki/Key_derivation_function"" rel=""nofollow"">key derivation function</a> to convert the passphrase into a key. </p>

<p>Try using the <a href=""https://www.dlitz.net/software/pycrypto/"" rel=""nofollow"">pycrypto</a> toolkit. It implements <a href=""https://www.dlitz.net/software/pycrypto/doc/#crypto-cipher-encryption-algorithms"" rel=""nofollow"">Rijndael/AES and other ciphers</a>.</p>
","2107","<python><c><encryption><rijndael>","2","0","1","2012-09-30 21:12:54","12662098","5","1","1219295","","2012-09-30 14:34:52","2012-09-30 13:40:20",""
"1369817","Help using Rijndael Algorithm in Delphi 2007. Net","<p>I'm working in Delphi 2007. Net, where I can find an example of using the Rijndael algorithm.</p>

<p>Bye.</p>
","<p>Some time ago I wrote this code, should work ok.</p>

<pre><code>uses
   System.Security.Cryptography, 
   System.Text;

type
  TDynamicArrayOfByte = array of Byte;

function Encrypt(StrtoEncrypt, PK: string): TDynamicArrayOfByte; // pk, must be of a string of 32 characters
var
   miRijndael:  Rijndael;
   encrypted:   TDynamicArrayOfByte;
   toEncrypt:   TDynamicArrayOfByte;
   bytPK:       TDynamicArrayOfByte;
   i: integer;
begin
   Result     := nil;
   miRijndael := System.Security.Cryptography.RijndaelManaged.Create;
   try
    toEncrypt :=  System.Text.Encoding.UTF8.GetBytes(StrtoEncrypt);
    bytPK     :=  System.Text.Encoding.UTF8.GetBytes(PK);    
    miRijndael.Key := bytPK;
    miRijndael.GenerateIV;
    encrypted := (miRijndael.CreateEncryptor()).TransformFinalBlock(toEncrypt, 0, Length(toEncrypt));
    setlength(result, Length(miRijndael.IV) + Length(encrypted));

      for i:=0 to Length(miRijndael.IV)-1 do
         result[i] := miRijndael.IV[i];

      for i:=0 to Length(encrypted)-1 do
         result[i + Length(miRijndael.IV)] := encrypted[i];

   finally
      miRijndael.Clear();
   end;
end;

function DesEncrypt(BufferEncrypted: TDynamicArrayOfByte; PK: string): string; //   pk, must be of a string of 32 characters
var
   miRijndael:  Rijndael;
   encrypted:   TDynamicArrayOfByte;
   tempArray:   TDynamicArrayOfByte;
   bytPK:       TDynamicArrayOfByte;
   i : integer;
begin
   Result     := '';
   miRijndael := System.Security.Cryptography.RijndaelManaged.Create;
   setlength(tempArray, Length(miRijndael.IV));
   setlength(encrypted, Length(BufferEncrypted) - Length(miRijndael.IV));
   try
    bytPK     :=  System.Text.Encoding.UTF8.GetBytes(PK);
    miRijndael.Key :=  bytPK;

      for i:=0 to Length(tempArray)-1 do
         tempArray[i] := BufferEncrypted[i];

      for i:=0 to Length(encrypted)-1 do
         encrypted[i] := BufferEncrypted[i + Length(tempArray)];

    miRijndael.IV := tempArray;
    Result :=  System.Text.Encoding.UTF8.GetString((miRijndael.CreateDecryptor()).TransformFinalBlock(encrypted, 0, Length(encrypted)));
   finally
     miRijndael.Clear();
   end;
end;
</code></pre>

<p>Bye.</p>
","2023","<delphi><rijndael>","1","7","4","2009-09-07 15:56:37","1370024","0","2","37971","","2009-09-03 01:53:06","2009-09-02 20:01:06",""
"1369817","Help using Rijndael Algorithm in Delphi 2007. Net","<p>I'm working in Delphi 2007. Net, where I can find an example of using the Rijndael algorithm.</p>

<p>Bye.</p>
","<p>Turbo Power LockBox, It provides
  support for Blowfish, RSA, MD5, SHA-1, DES, triple- DES, <strong>Rijndael</strong> and
  digital signing of messages.</p>

<p><a href=""https://sourceforge.net/projects/tplockbox/"" rel=""nofollow noreferrer"">https://sourceforge.net/projects/tplockbox/</a></p>
","2023","<delphi><rijndael>","1","0","4","2009-09-07 15:56:37","1370024","0","2","37971","","2009-09-03 01:53:06","2009-09-02 20:01:06",""
"1369817","Help using Rijndael Algorithm in Delphi 2007. Net","<p>I'm working in Delphi 2007. Net, where I can find an example of using the Rijndael algorithm.</p>

<p>Bye.</p>
","<p>There is some delphi source at <a href=""http://rcolonel.tripod.com/"" rel=""nofollow noreferrer"">http://rcolonel.tripod.com/</a>.  YOu may be able to use that in Delphi.net.  However you may be better off finding a .net module and just using that.  You should be able to use a c# or vb.net module in delphi.net.</p>
","2023","<delphi><rijndael>","1","0","4","2009-09-07 15:56:37","1370024","0","2","37971","","2009-09-03 01:53:06","2009-09-02 20:01:06",""
"1369817","Help using Rijndael Algorithm in Delphi 2007. Net","<p>I'm working in Delphi 2007. Net, where I can find an example of using the Rijndael algorithm.</p>

<p>Bye.</p>
","<p>The Delphi Cryptography Page DCP cryptographic components contain an implementation of Rijndael algorithm. Written by David Barton (davebarton@bigfoot.com) <a href=""http://www.scramdisk.clara.net/"" rel=""nofollow noreferrer"">http://www.scramdisk.clara.net/</a>, DCP Crypto components are very comprehensive, free to export, symmetric key cryptographic components.</p>
","2023","<delphi><rijndael>","1","0","4","2009-09-07 15:56:37","1370024","0","2","37971","","2009-09-03 01:53:06","2009-09-02 20:01:06",""
"16361767","length of data to decrypt is invalid rijndael c# sql","<p>I am trying to encrypt / decrypt sensitive data such as SSN, the encryption process goes fine, saving in DB looks good too, retrieval looks good too, but when I am on the last step to decrypt the data I am getting error message: length of data to decrypt is invalid.</p>

<p>I created a SQL Server table for testing which has one column to hold the data, of <code>varbinary</code> type with size of 500. </p>

<p>This is how the data looks like in the table:</p>

<p><img src=""https://i.stack.imgur.com/X1fe6.png"" alt=""enter image description here""></p>

<p>Now here is whole code in C# which is used to encrypt the data, insert in the db, get the last record (test) and decrypt. As I said the error happens on the last step in the decryption step:</p>

<p>Encryption Step</p>

<pre><code> public byte[] EncryptStringToBytes(string plainText)
 {
             // Check arguments. 
             if (plainText == null || plainText.Length &lt;= 0)
                 throw new ArgumentNullException(""plainText"");           
             byte[] encrypted;
             // Create an RijndaelManaged object 
             // with the specified key and IV. 
             using (RijndaelManaged rijAlg = new RijndaelManaged())
             {
                 rijAlg.Mode = CipherMode.CBC;
                 rijAlg.Padding = PaddingMode.PKCS7;
                 string keyStr = ""cGFzc3dvcmQAAAAAAAAAAA=="";
                 string ivStr = ""cGFzc3dvcmQAAAAAAAAAAA=="";
                 byte[] ivArr = Convert.FromBase64String(keyStr);
                 byte[] keyArr = Convert.FromBase64String(ivStr);
                 rijAlg.Key = keyArr;
                 rijAlg.KeySize = 256;
                 rijAlg.BlockSize = 128;
                 rijAlg.IV = ivArr;

                 // Create a decrytor to perform the stream transform.
                 ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

                 // Create the streams used for encryption. 
                 using (MemoryStream msEncrypt = new MemoryStream())
                 {
                     using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                     {
                         using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                         {
                             //Write all data to the stream.
                             swEncrypt.Write(plainText);
                         }
                         encrypted = msEncrypt.ToArray();
                         SaveData(encrypted);
                     }
                 }
            }
             // Return the encrypted bytes from the memory stream. 
             return encrypted;
         }
</code></pre>

<p>Saving data to database</p>

<pre><code>public void SaveData(byte[] cipherText) {
   string queryStmt = ""INSERT INTO TestSSN(SSN) VALUES(@Content)"";

   using (SqlConnection _con = new SqlConnection(ConfigurationManager.ConnectionStrings[""ApplicationServices""].ConnectionString))
   using (SqlCommand _cmd = new SqlCommand(queryStmt, _con))
   {
      SqlParameter param = _cmd.Parameters.Add(""@Content"", SqlDbType.VarBinary);
      param.Value = cipherText;

      _con.Open();
      _cmd.ExecuteNonQuery();
      _con.Close();
   }
   GetSSNData(1); }
</code></pre>

<p>Getting data from database</p>

<pre><code>public byte[] GetSSNData(int id)
{
    byte[] cipherData = new byte[500];
    string queryStmt = ""SELECT SSN FROM TestSSN WHERE ID=7"";

    using (SqlConnection _con = new SqlConnection(ConfigurationManager.ConnectionStrings[""ApplicationServices""].ConnectionString))
    using (SqlCommand _cmd = new SqlCommand(queryStmt, _con))
    {              
          _con.Open();
          SqlDataReader rdr = _cmd.ExecuteReader();

          if (rdr.HasRows)
          {
              while (rdr.Read())
              {
                    cipherData = Encoding.ASCII.GetBytes(rdr[0].ToString());
              }
          }
          _con.Close();
    }
    string roundtrip = DecryptStringFromBytes(cipherData);          
    return cipherData;
}
</code></pre>

<p>Trying to decrypt the data(you will notice two different ways for decryption here, but I'll get the same message for both of them)</p>

<pre><code> static string DecryptStringFromBytes(byte[] cipherText)
 {
     // Check arguments. 
     if (cipherText == null || cipherText.Length &lt;= 0)
         throw new ArgumentNullException(""cipherText"");           

     // Declare the string used to hold 
     // the decrypted text. 
     string plaintext = null;

     // Create an RijndaelManaged object 
     // with the specified key and IV. 
     using (RijndaelManaged rijAlg = new RijndaelManaged())
     {
         rijAlg.Mode = CipherMode.CBC;
         rijAlg.Padding = PaddingMode.PKCS7;
         string keyStr = ""cGFzc3dvcmQAAAAAAAAAAA=="";
         string ivStr = ""cGFzc3dvcmQAAAAAAAAAAA=="";
         byte[] ivArr = Convert.FromBase64String(keyStr);
         byte[] keyArr = Convert.FromBase64String(ivStr);
         rijAlg.Key = keyArr;
         rijAlg.KeySize = 256;
         rijAlg.BlockSize = 128;
         rijAlg.IV = ivArr;
         // Create a decrytor to perform the stream transform.
         ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

         byte[] decryptedText = decryptor.TransformFinalBlock(cipherText, 0, cipherText.Length);
         string decrpyted = ASCIIEncoding.UTF8.GetString(decryptedText);          

         // Create the streams used for decryption. 
         using (MemoryStream msDecrypt = new MemoryStream(cipherText))
         {
             using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
             {
                 using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                 {
                     //  byte[] decryptedText = decryptor.TransformFinalBlock(cipherText, 0, cipherText.Length);
                     // Read the decrypted bytes from the decrypting stream 
                     // and place them in a string.
                     plaintext = srDecrypt.ReadToEnd();
                 }
             }
         }
     }

     return plaintext;
   }
</code></pre>

<p>Advices more then welcome, I've been battling with the decryption whole day.</p>

<p>Thanks, Laziale</p>
","<p>Check the place where you read your data from DB:</p>

<pre><code>cipherData = Encoding.ASCII.GetBytes(rdr[0].ToString());
</code></pre>

<p>If <code>rdr[0]</code> is a <code>byte</code> array I don't think that you will get the string of bytes, probably you will get ""System.Byte[]"". And if you will get ""0xFFAA"" - <code>Encoding.ASCII.GetBytes</code> will not give you a byte array with { 0xFF, 0xAA } data. You should use <a href=""http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqldatareader.getbytes.aspx"" rel=""nofollow"">SqlDataReader.GetBytes</a> to read this data. </p>

<p>Also I want to remind you that SSN is sensitive information. You should inform your users that you are going to save this information. If you need this information just to verify identity - you can use last 4 digits or hash. Please consider to not save SSN if you don't have real justification for this.</p>
","2020","<c#><asp.net><encryption><aes><rijndael>","1","0","1","2013-05-03 16:33:42","","1","","13302","","2013-05-03 16:33:42","2013-05-03 14:50:17",""
"21805799","serpent encryption - better than rijndael?","<p>Is Serpent-256 better than Rijndael-256 in terms of security? (speed doesn't matter)</p>

<p>Would Serpent encryption combined with SHA-512 be enough to safeguard sensitive data?
And to what extent? (SECRET, TOP SECRET, CLASSIFIED etc.)</p>

<p>Moreover, Rijndael has a max of 16 rounds. Serpent has 32 rounds, so it must be more secure.
As I've read that the Rijndael cipher is cryptographically broken, why isn't Serpent
adopted more widely? Would it be <em>that</em> slow if implemented on hardware?</p>

<p>Any other technical specifications about Serpent that you can link me to, I would be very grateful.</p>

<p>Thank you.</p>
","<p>The number of rounds, by itself, doesn't determine the security of a cipher. You need to take the round function into account before the number of rounds means anything.</p>

<p>Nonetheless, I'd agree that there's a pretty decent chance that Serpent is more secure than AES. There are attacks currently known against AES that reduce the complexity by a factor of approximately 4 compared to a pure brute-force attack.</p>

<p>Cryptographers count that as a successful attack--but from a practical viewpoint, it's of precisely zero consequence. Even if you restrict yourself to AES-128, it's basically reducing complexity from 16 times the estimated life of the universe to only 4 times the estimated life of the universe (I'm sort of making up numbers here, but you get the general idea). With AES-256, the number is so much larger the factor of four shrinks to a new level of utterly meaningless insignificance. </p>

<p>Until/unless a <em>dramatically</em> better attack is found, real security is completely unaffected. In essentially every case, the problems you need to deal with and worry about are in how the cipher is used, how keys are generated, stored, and exchanged, etc. Changing from AES to Serpent (or Mars, Twofish, etc.) is extremely unlikely to improve your security (or anybody else's).</p>

<p>I should probably add: I'm probably as strong an advocate as anybody of having more cipher algorithms available and standardized. If you do a little looking, you can find where I'm cited in the papers submitted to NIST during AES standardization on that subject, giving use cases where including more than one algorithm in the standard would have been useful. Nonetheless, I have to admit that no (publicly known) current attack even comes close to giving a real reason to choose a different cipher algorithm.</p>
","2016","<encryption><crypt><rijndael>","1","3","1","2014-02-16 01:17:16","","3","","","","","2014-02-16 00:46:10","2014-12-30 09:47:03"
"46221650","Python Rijndael Encryption","<p>I'm trying to mimic the Rijndael (AES) encryption of <a href=""http://www.hanewin.net/encrypt/aes/aes-test.htm"" rel=""nofollow noreferrer"">http://www.hanewin.net/encrypt/aes/aes-test.htm</a> in Python3.  </p>

<p>Specifically, when I use the following inputs:</p>

<pre><code>Key in hex = AAAABBBBCCCCDDDDEEEEFFFF00001111 
Plaintext in hex = 11112222333344445555666677778888 
</code></pre>

<p>I want the output to be:</p>

<pre><code>Ciphertext in hex = ec151e51fc722c06073928d17fa4f6da
</code></pre>

<p>From looking at the source code of the webpage, it is using ECB.  I've installed PyCrypto and followed the examples for encrypting, and this is what I've gotten:</p>

<pre><code>&gt;&gt;&gt; from Crypto.Cipher import AES
&gt;&gt;&gt;
&gt;&gt;&gt; KEY = 'AAAABBBBCCCCDDDDEEEEFFFF00001111'
&gt;&gt;&gt; rijn = AES.new(KEY, AES.MODE_ECB)
&gt;&gt;&gt; plaintext = '11112222333344445555666677778888'
&gt;&gt;&gt; ciphertext = rijn.encrypt(plaintext)
&gt;&gt;&gt; ciphertext
b'\xf8Gy\x17\x85$\xf4?\xd3}\x91\xa1\xad\xab\xa1\x07g\xf7P\xd4:\x7f\xc0\x18m)\rTu,\xd0\xa2'
</code></pre>

<p>So my ciphertext is that long binary string (if that's the right terminology).  Assuming all of the settings were correct, it should be the equivalent of <code>ec151e51fc722c06073928d17fa4f6da</code>.  How can I convert <code>b'\xf8Gy\x17\x85$\xf4?\xd3}\x91\xa1\xad\xab\xa1\x07g\xf7P\xd4:\x7f\xc0\x18m)\rTu,\xd0\xa2'</code> to <code>ec151e51fc722c06073928d17fa4f6da</code>?</p>

<p><strong>Update</strong>:
With Jon's suggestion in the comments, I've imported binascci and now I'm getting the following output:</p>

<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; 
&gt;&gt;&gt; binascii.hexlify(ciphertext)
b'f84779178524f43fd37d91a1adaba10767f750d43a7fc0186d290d54752cd0a2'
</code></pre>

<p>So it may still be that I have the right cipher, but something is different in the conversion.  Here are some excerpts from the webpage's source code:</p>

<pre><code>theForm.ciphertext.value = byteArrayToHex(rijndaelEncrypt(pt, key, ""ECB""));


// This function takes an array of bytes (byteArray) and converts them
// to a hexadecimal string. Array element 0 is found at the beginning of 
// the resulting string, high nibble first. Consecutive elements follow
// similarly, for example [16, 255] --&gt; ""10ff"". The function returns a 
// string.

function byteArrayToHex(byteArray) {
  var result = """";
  if (!byteArray)
    return;
  for (var i=0; i&lt;byteArray.length; i++)
    result += ((byteArray[i]&lt;16) ? ""0"" : """") + byteArray[i].toString(16);

  return result;
}
</code></pre>
","<p>As shared above, here is the answer that the commenters helped to arrive at:</p>

<pre><code>&gt;&gt;&gt; from Crypto.Cipher import AES
&gt;&gt;&gt; import binascii
&gt;&gt;&gt; KEY = binascii.unhexlify('AAAABBBBCCCCDDDDEEEEFFFF00001111')
&gt;&gt;&gt; plaintext = binascii.unhexlify('11112222333344445555666677778888')
&gt;&gt;&gt; rijn = AES.new(KEY, AES.MODE_ECB)
&gt;&gt;&gt; ciphertext = rijn.encrypt(plaintext)
&gt;&gt;&gt; binascii.hexlify(ciphertext)
b'ec151e51fc722c06073928d17fa4f6da'
&gt;&gt;&gt; print(binascii.hexlify(ciphertext).decode('utf-8'))
ec151e51fc722c06073928d17fa4f6da
</code></pre>
","1996","<python><encryption><rijndael>","1","2","1","2018-11-25 18:53:08","50297137","4","","100297","","2018-11-25 18:53:08","2017-09-14 14:23:45",""
"5097475","How to make Rijndael CBC mode work in vb.net","<p>I'm trying to make rijndael work in CBC mode. I'm not exactly sure how should I do it. I think problem in my current code is that the stream is initialized every time in the beginning of encryption, so no avalanche effect occurs (same data is encrypted twice and the output of those two encryption is the same which it should not be).</p>

<p>I tried to initialize the cryptostream only once but then my coded crashed because the canwrite property of cryptostream goes to false after the first write to the cryptostream.</p>

<p>Here is the code what I have now:</p>

<pre><code>
Sub Main()

        Dim rij As New RijndaelManaged
        Dim iv(15) As Byte
        Dim key(15) As Byte
        Dim secret() As Byte = {59, 60, 61}

        Dim cs As ICryptoTransform
        Dim cstream As CryptoStream

        Dim out() As Byte
        Dim NewRandom As New RNGCryptoServiceProvider()

        NewRandom.GetBytes(iv)
        NewRandom.GetBytes(key)

        rij = New RijndaelManaged()

        rij.KeySize = 128
        rij.Padding = PaddingMode.PKCS7

        rij.Mode = CipherMode.CBC

        rij.IV = iv
        rij.Key = key
        cs = rij.CreateEncryptor()

        Dim ms_in As New MemoryStream
        cstream = New CryptoStream(ms_in, cs, CryptoStreamMode.Write)


        Using cstream
            cstream.Write(secret, 0, 3)
        End Using

        out = ms_in.ToArray
        Console.WriteLine(ArrayToString(out, out.Length))
        Erase out

        ms_in = New MemoryStream
        cstream = New CryptoStream(ms_in, cs, CryptoStreamMode.Write)


        Using cstream
            cstream.Write(secret, 0, 3)
        End Using

        out = ms_in.ToArray
        Console.WriteLine(ArrayToString(out, out.Length))

    End Sub

</code></pre>

<p>and the conversion function to convert an array to string</p>

<pre><code>
 Public Function ArrayToString(ByVal bytes() As Byte, ByVal length As Integer) As String

        If bytes.Length = 0 Then Return String.Empty
        Dim sb As New System.Text.StringBuilder(length)

        Dim k As Integer = length - 1
        Dim i As Integer

        For i = 0 To k
            sb.Append(Chr(bytes(i)))
        Next


        Return sb.ToString()

    End Function
</code></pre>

<hr>

<p>This is what I need:</p>

<pre><code>    cs = rij.CreateEncryptor()
    Dim ms_in As New MemoryStream
    cstream = New CryptoStream(ms_in, cs, CryptoStreamMode.Write)

    Using cstream
        cstream.Write(secret, 0, 3) 'encrypt
    End Using

    out = ms_in.ToArray
    Console.WriteLine(ArrayToString(out, out.Length)) 'see the encrypted message
    Erase out

    Using cstream
        cstream.Write(secret, 0, 3) 'encrypt, this will crash here and this is the problem I'm trying to solve
    End Using

    out = ms_in.ToArray
    Console.WriteLine(ArrayToString(out, out.Length)) 'see the encrypted message this should not be the same as the first one
</code></pre>
","<p>Try this: </p>

<pre><code>Public Sub Run()
    Dim key() As Byte = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}

    Dim plaintext1 As Byte() = {59, 60, 61}

    Dim plaintext2 As Byte() = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15, _
                             0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15, _
                             0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15, _
                             0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 _
                             }

    Roundtrip(plaintext1, key)
    System.Console.WriteLine()
    Roundtrip(plaintext2, key)

End Sub


Public Sub Roundtrip(ByRef plaintext As Byte(), ByRef key As Byte())

    Dim rij As New RijndaelManaged
    Dim iv(15) As Byte

    Dim encryptor As ICryptoTransform
    Dim decryptor As ICryptoTransform

    Dim out() As Byte

    'Dim NewRandom As New RNGCryptoServiceProvider()
    'NewRandom.GetBytes(iv)
    'NewRandom.GetBytes(key)

    Console.WriteLine(""Original:"")
    Console.WriteLine(ArrayToString(plaintext))
    System.Console.WriteLine()

    rij = New RijndaelManaged()
    rij.KeySize = key.Length * 8  ' 16 byte key == 128 bits
    rij.Padding = PaddingMode.PKCS7
    rij.Mode = CipherMode.CBC
    rij.IV = iv
    rij.Key = key
    encryptor = rij.CreateEncryptor()

    Using msIn = New MemoryStream

        Using cstream = New CryptoStream(msIn, encryptor, CryptoStreamMode.Write)
            cstream.Write(plaintext, 0, plaintext.Length)
        End Using

        out = msIn.ToArray
        Console.WriteLine(""Encrypted:"")
        Console.WriteLine(""{0}"", ArrayToString(out))
        System.Console.WriteLine()

    End Using

    decryptor = rij.CreateDecryptor()
    Using msIn = New MemoryStream

        Using cstream = New CryptoStream(msIn, decryptor, CryptoStreamMode.Write)
            cstream.Write(out, 0, out.Length)
        End Using

        out = msIn.ToArray
        Console.WriteLine(""Decrypted:  "")
        Console.WriteLine(""{0}"", ArrayToString(out))
        System.Console.WriteLine()

    End Using

End Sub


Public Shared Function ArrayToString(ByVal bytes As Byte()) As String

    Dim sb As New System.Text.StringBuilder()

    Dim i As Integer
    For i = 0 To bytes.Length-1
        if (i &lt;&gt; 0 AND i mod 16 = 0) Then
            sb.Append(Environment.NewLine)
        End If
        sb.Append(System.String.Format(""{0:X2} "", bytes(i)))
    Next

    Return sb.ToString().Trim()

End Function
</code></pre>

<p>I made these basic changes to get it to work: </p>

<ul>
<li>create a Decryptor   </li>
<li>properly manage buffers and streams (see the <code>Using</code> clauses I added)</li>
</ul>

<p>I also re-organized a little, and modified your code slightly to use a constant IV (all zeros) and use a constant key.  This is so that you can get repeatable results from one run to the next. In a real app you would use a randomized IV and use a password-derived key.  (See <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.aspx"" rel=""nofollow"">Rfc2898DeriveBytes</a>)</p>

<hr>

<p>ok, that allows the code to compile. I think you want to see the effect of chaining. That is not  so easy, but maybe something like this will show you what you want to see: </p>

<pre><code>        For i As Integer = 1 To 2
            Using ms = New MemoryStream
                Using cstream = New CryptoStream(ms, encryptor, CryptoStreamMode.Write)
                    For j As Integer = 1 To i
                        cstream.Write(plaintext, 0, plaintext.Length)
                    Next j
                End Using
                out = ms.ToArray
                Console.WriteLine(""Encrypted (cycle {0}):"", i)
                Console.WriteLine(""{0}"", ArrayToString(out))
                System.Console.WriteLine()

            End Using
        Next i
</code></pre>
","1970","<vb.net><aes><rijndael>","1","0","1","2011-02-28 09:22:52","","2","","631084","","2011-02-28 09:22:52","2011-02-23 21:35:58",""
"1006841","Calculate maximum size for encrypted data","<p>Is there any way to calculate the largest outcome from an Rijndael encryption with a fixed array length?</p>

<p>Encryption method: RijndaelManaged</p>

<p>Padding: PKCS7</p>

<p>CipherMode: CBC</p>

<p>BlockSize 128</p>

<p>KeySize: 128</p>

<p>I need this as im converting a database where all string are going to be encrypted so i need to change the size of all string fields.</p>
","<p>Yes. Round up your input size to the nearest multiple of your block size (e.g. 128 / 8 = 16 bytes).</p>

<pre><code>extraBytesNeeded = (16 - (inputSize % 16)) % 16;
maxSize = inputSize + extraBytesNeeded.
</code></pre>
","1964","<math><encryption><aes><rijndaelmanaged><rijndael>","8","2","3","2018-06-25 10:13:12","1035507","0","2","1033581","","2018-06-25 10:13:12","2009-06-17 12:55:19",""
"1006841","Calculate maximum size for encrypted data","<p>Is there any way to calculate the largest outcome from an Rijndael encryption with a fixed array length?</p>

<p>Encryption method: RijndaelManaged</p>

<p>Padding: PKCS7</p>

<p>CipherMode: CBC</p>

<p>BlockSize 128</p>

<p>KeySize: 128</p>

<p>I need this as im converting a database where all string are going to be encrypted so i need to change the size of all string fields.</p>
","<p>Jeff's answer is almost correct, except that PKCS7 will always add padding to the message, even if the message exactly fits inside an integral number of blocks. Also, don't forget that if using a random IV that the IV has to be stored too. The corrected formula for the length of a PKCS7 padded message is:</p>

<pre><code>extraBytesNeeded = (16 - (inputSize % 16)); // whole block of padding if input fits exactly
maxSize = inputSize + extraBytesNeeded + IVbytes;
</code></pre>
","1964","<math><encryption><aes><rijndaelmanaged><rijndael>","8","2","3","2018-06-25 10:13:12","1035507","0","2","1033581","","2018-06-25 10:13:12","2009-06-17 12:55:19",""
"1006841","Calculate maximum size for encrypted data","<p>Is there any way to calculate the largest outcome from an Rijndael encryption with a fixed array length?</p>

<p>Encryption method: RijndaelManaged</p>

<p>Padding: PKCS7</p>

<p>CipherMode: CBC</p>

<p>BlockSize 128</p>

<p>KeySize: 128</p>

<p>I need this as im converting a database where all string are going to be encrypted so i need to change the size of all string fields.</p>
","<p>Everything you need to try this out:</p>

<pre><code>
   public partial class Form1 : Form
   {
      private SymmetricAlgorithm mEncryptionType;

      public Form1()
      {
         mEncryptionType = new RijndaelManaged();
         mEncryptionType.Padding = PaddingMode.PKCS7; //PaddingMode.None;
         mEncryptionType.Mode = CipherMode.CBC;
         mEncryptionType.BlockSize = 128; // 192; // 256; // Update byte array to IV when changed
         mEncryptionType.KeySize = 128; // 192; // 256; // Update byte array to Key when changed
         mEncryptionType.IV = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                                           0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
         mEncryptionType.Key = new byte[] { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                                           0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF };

         int encrypted_size = CalculateEncryptedSize(new byte[] { 0x22, 0x23, 0x44 });
         // Shows Theran's point about exact block size
         encrypted_size = CalculateEncryptedSize(new byte[] { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                                           0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF  });
      }

      /// &ltsummary>
      /// Calculate the encrypted size of input buffer
      /// &lt/summary>
      /// &ltparam name=""inputBuffer"">The input buffer&lt/param>
      /// &ltreturns>Size of the encrypted buffer&lt/returns>
      public int CalculateEncryptedSize(byte[] inputBuffer)
      {
         int extra_padding = 0;
         if (mEncryptionType.Padding != PaddingMode.None)
         {
            int padding_size = (mEncryptionType.BlockSize / 8);
            extra_padding = (padding_size - (inputBuffer.Length % padding_size));
         }
         return inputBuffer.Length + extra_padding;
      }
   }
</code></pre>
","1964","<math><encryption><aes><rijndaelmanaged><rijndael>","8","3","3","2018-06-25 10:13:12","1035507","0","2","1033581","","2018-06-25 10:13:12","2009-06-17 12:55:19",""
"30743395","32-character PHP AES Key for mcrypt_encrypt","<p>Consider the following PHP code:</p>

<pre><code>&lt;?php
$key = ""1234567812345678"";
$iv = ""1234567812345678"";
$data = ""Test string"";

$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128,
                            $key,
                            $data,
                            MCRYPT_MODE_CBC,
                            $iv);

print ""Encoded1: "" . base64_encode($encrypted) . ""\n"";

$key = ""12345678123456781234567812345678"";

$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128,
                            $key,
                            $data,
                            MCRYPT_MODE_CBC,
                            $iv);

print ""Encoded2: "" . base64_encode($encrypted) . ""\n"";
</code></pre>

<p>When run, this produces the output:</p>

<pre><code>Encoded1: iz1qFlQJfs6Ycp+gcc2z4w==
Encoded2: n3D26h/m8CSH0CE+z6okkw==
</code></pre>

<p>Note that I stole the first bit of code from <a href=""https://stackoverflow.com/questions/10842509/php-java-aes-cbc-encryption-different-results"">PHP Java AES CBC Encryption Different Results</a></p>

<p>Now - here's the question:</p>

<p>In the first case, the key that was passed in was a string of 16 characters.  If each of the individual characters was interpreted as an 8-bit quantity, this gives the 128-bit key size that one would expect.  Indeed, the Java code that's on the StackOverflow page that I referenced above does exactly that, and obtains the same result as the PHP.</p>

<p>In the second call to <code>mcrypt_encrypt</code> above, I have doubled the length of the key.  <code>mcrypt_encrypt</code> accepts this happily, but produces a different encrypted output than in the first case.  Clearly, therefore, it considers this a different key - it does not, for example take only the first 128 bits and discard any past that.</p>

<p>So, how does <code>mcrypt_encrypt</code> process the input key string to come up with the 128-bit key that the <code>MCRYPT_RIJNDAEL_128</code> algorithm requires?  </p>

<p>If it makes any difference, the case I'm specifically interested in is when a 32-character string is passed in like my second example - I have to create a matching decryption routine (in Java), so I need to figure out how the key is actually generated in this case.  The page I cited has perfectly-good Java code (which works with all my test cases) - I'm just missing the proper set of key bytes.</p>
","<p>There are two important parameters for the Rijndael algorithm. There is the <strong>key size</strong> (128-bit, 192-bit and 256-bit) and then there is the <strong>block size</strong> (128-bit, 192-bit and 256-bit). The <code>128</code> in <code>MCRYPT_RIJNDAEL_128</code> refers to the block size. The key size is variable.</p>

<p>When you pass keys of different lengths into MCrypt, it will select the appropriate key size automatically, so you don't and can't set it. <code>MCRYPT_RIJNDAEL_128</code> is AES (AES-128, AES-192, AES-256). <code>MCRYPT_RIJNDAEL_192</code> and <code>MCRYPT_RIJNDAEL_256</code> are not AES anymore.</p>

<p>If the Java code produced a matching result for the 128-bit key, then it will produce a matching result for the 256-bit key as well.</p>

<p>MCrypt is a little strange. Before PHP version 5.6.0 it would take any key length and not just 128-bit, 192-bit or 256-bit. The key would be filled up with 0x00 bytes up to the next valid key length.</p>

<hr>

<p>Since Java doesn't support ZeroPadding out of the box, you should use a proper padding scheme such as PKCS#5/PKCS#7 padding in PHP. <a href=""https://stackoverflow.com/a/27590539/1816580"">This answer</a> has a very good implementation of it.</p>
","1958","<php><encryption><aes><rijndael><symmetric-key>","3","3","1","2015-06-09 22:53:19","","0","2","-1","","2017-05-23 12:30:00","2015-06-09 21:44:15",""
"11260161","Rijndael or AES to match java encryption - with salt and key","<p>I need to encrypt a string using a salt and a key to match a java encryption so that the 3rd party provider can decrypt the values on the other side. </p>

<p>I have tried several StackOverflow articles as I am no expert in encryption and just cannot get the same encryption string using SALT and KEY as the 3rd party provider.</p>

<p>I need to know which encryption type and mode in C# to use to match java's AES encryptions as used here</p>

<p><a href=""https://gist.github.com/ca958d5921d47c4c0a0f"" rel=""nofollow"">https://gist.github.com/ca958d5921d47c4c0a0f</a></p>
","<p>OK - I figured it out even though it's cheating to a degree. Because I could not find any encryption technique that would match the plain AES encryption provided by the 3rd party I asked them to change it to </p>

<p>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");</p>

<p>With this I amended my C# code and finally got the integration working:</p>

<pre><code>public static string Encrypt2(string plainText)
    {
        string PassPhrase = ""somepassphrase"";
        string SaltValue = ""somesalt"";
        int PasswordIterations = 0; //amend to match java encryption iteration
        string InitVector = ""someiv"";
        int KeySize = 0; //amend to match java encryption key size

        byte[] initVectorBytes = Encoding.ASCII.GetBytes(InitVector);
        byte[] saltValueBytes = Encoding.ASCII.GetBytes(SaltValue);

        byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);

        Rfc2898DeriveBytes password = new Rfc2898DeriveBytes(
                                                        PassPhrase,
                                                        saltValueBytes,
                                                        PasswordIterations);

        byte[] keyBytes = password.GetBytes(KeySize / 8);
        RijndaelManaged symmetricKey = new RijndaelManaged();
        symmetricKey.Mode = CipherMode.CBC;

        ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                                                         keyBytes,
                                                         initVectorBytes);
        MemoryStream memoryStream = new MemoryStream();

        CryptoStream cryptoStream = new CryptoStream(memoryStream,
                                                     encryptor,
                                                     CryptoStreamMode.Write);

        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
        cryptoStream.FlushFinalBlock();
        byte[] cipherTextBytes = memoryStream.ToArray();

        memoryStream.Close();
        cryptoStream.Close();

        string cipherText = Convert.ToBase64String(cipherTextBytes);

        return cipherText;
    }
</code></pre>
","1952","<c#><java><aes><rijndael>","0","3","1","2012-07-03 10:12:22","11308726","0","","","","","2012-06-29 10:29:08",""
"13079150","Encrypt and Decrypt with Rijndael data too long","<p>I'm trying to get this code to encrypt and decrypt but I keep getting data length too long when decrypting during the <code>.FlushFinalBlock()</code>.</p>

<p>I'm not sure what I'm doing wrong here because I'm out of my element on this issue.</p>

<p>Can anyone tell me what I'm doing wrong here? Encryption is OK, but it cannot decrypt its encryption.</p>

<pre><code>   static byte[] u8_Salt = new byte[] { 0x26, 0x19, 0x81, 0x4E, 0xA0, 0x6D, 0x95, 0x34, 0x26, 0x75, 0x64, 0x05, 0xF6 };

   public static string Encrypt(string data, string password)
    {
        //
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, u8_Salt);
        //
        Rijndael i_Alg = Rijndael.Create();
        i_Alg.Padding = PaddingMode.None;
        i_Alg.Key = pdb.GetBytes(32);
        i_Alg.IV = pdb.GetBytes(16);
        //
        using (var cryptoProvider = new DESCryptoServiceProvider())
        using (var memoryStream = new MemoryStream())
        using (var cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateEncryptor(), CryptoStreamMode.Write))
        using (var writer = new StreamWriter(cryptoStream))
        {
            writer.Write(data);
            writer.Flush();
            cryptoStream.FlushFinalBlock();
            writer.Flush();
            return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
        }
    }
    public static string Decrypt(string data, string password)
    {
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, u8_Salt);
        //
        Rijndael i_Alg = Rijndael.Create();
        i_Alg.Padding = PaddingMode.None;
        i_Alg.Key = pdb.GetBytes(32);
        i_Alg.IV = pdb.GetBytes(16);
        //
        using (var cryptoProvider = new DESCryptoServiceProvider())
        using (var memoryStream = new MemoryStream())
        using (var cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateDecryptor(), CryptoStreamMode.Write))
        using (var writer = new StreamWriter(cryptoStream))
        {
            writer.Write(data);
            writer.Flush();
            cryptoStream.FlushFinalBlock();
            writer.Flush();
            return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
        }
    }
</code></pre>
","<p>There are a few problems with your code. First, you are creating a <em>Rijndael (AES)</em> object. However, you're using the <code>DESCryptoServiceProvider</code> which means that you are actually using DES, not Rijndael. Because of that you also have the problem that you are not setting the key for the algorithm. Below are your two functions re-written using the <code>RijndaelManaged</code> algorithm which is the managed implementation of the <code>AES</code> algorithm on .NET.  I've tested and you can encrypt and decrypt with no problem. Also: don't use that salt value, it's all over the internet.</p>

<pre><code>static byte[] u8_Salt = new byte[] { 0x26, 0x19, 0x81, 0x4E, 0xA0, 0x6D, 0x95, 0x34, 0x26, 0x75, 0x64, 0x05, 0xF6 };

public static string EncryptString(string plainText, string password)
{
    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, u8_Salt);
    using (RijndaelManaged i_Alg = new RijndaelManaged { Key = pdb.GetBytes(32), IV = pdb.GetBytes(16) })
    {
        using (var memoryStream = new MemoryStream())
        using (var cryptoStream = new CryptoStream(memoryStream, i_Alg.CreateEncryptor(), CryptoStreamMode.Write))
        {
            byte[] data = Encoding.UTF8.GetBytes(plainText);
            cryptoStream.Write(data, 0, data.Length);
            cryptoStream.FlushFinalBlock();

            return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
        }
    }
}

public static string Decrypt(string cipherText, string password)
{
    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, u8_Salt);

    using (RijndaelManaged i_Alg = new RijndaelManaged { Padding = PaddingMode.Zeros, Key = pdb.GetBytes(32), IV = pdb.GetBytes(16) })
    {
        using (var memoryStream = new MemoryStream())
        {
            using (var cryptoStream = new CryptoStream(memoryStream, i_Alg.CreateDecryptor(), CryptoStreamMode.Write))
            {
                byte[] data = Convert.FromBase64String(cipherText);
                cryptoStream.Write(data, 0, data.Length);
                cryptoStream.Flush();

                return Encoding.UTF8.GetString(memoryStream.ToArray());
            }
        }
    }
}
</code></pre>

<p>To generate a random salt I would use the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.getbytes.aspx"" rel=""nofollow"">RNGCryptoServiceProvider</a>  this will generate a cryptographically secure random byte array that you can use.  You'll need to generate it in a separate process and use it as your salt.</p>
","1945","<c#><.net><security><aes><rijndael>","1","3","1","2012-11-06 00:36:29","13206276","1","","","user1693593","2012-11-03 06:15:23","2012-10-26 00:14:18",""
"15670942","Rijndael encrypt file in C# and decrypt as string in Delphi","<p>I am trying to encrypt a file in C# and decrypt the content in delphi as a string. I have tried several settings, key/block sizes and modes. Currently the code on C# side is:</p>

<pre><code>private void EncryptFile(string inputFile, string keyCode, string outputFile)
{
    try         {   
        byte[] key = Encoding.Unicode.GetBytes(keyCode);
        byte[] iv = new byte[16];
        Array.Copy(key, iv, 16);

        FileStream fsCrypt = new FileStream(outputFile, FileMode.Create);

        var RMCrypto = new AesManaged();
        RMCrypto.KeySize = 256;
        RMCrypto.BlockSize = 128;
        RMCrypto.Mode = CipherMode.ECB;

        CryptoStream cs = new CryptoStream(fsCrypt,
                                           RMCrypto.CreateEncryptor(key, iv),
                                           CryptoStreamMode.Write);

        FileStream fsIn = new FileStream(inputFile, FileMode.Open);

        int data;
        while ((data = fsIn.ReadByte()) != -1)
            cs.WriteByte((byte)data);

        fsIn.Close();
        cs.Close();
        fsCrypt.Close();
    }
    catch (Exception e)
    {
        MessageBox.Show(e.Message);
    }
}
</code></pre>

<p>The key parameter is a C# string ""1234567887654321"".
And the reverse part in delphi using the DEC library looks like that:</p>

<pre><code>    procedure TForm1.Button1Click(Sender: TObject);

var
  RCipher: TCipher_Rijndael;
  FileStream: TFileStream;
  StringStream: TStringStream;
  StringBytes: TBytes;
  Key: String;

begin

  Key := '1234567887654321';

  StringBytes := TEncoding.Unicode.GetBytes(Key);

  RCipher := TCipher_Rijndael.Create();
  FileStream := TFileStream.Create('C:\path\to\file.txt', fmOpenRead);

  StringStream := TStringStream.Create('', TEncoding.ANSI);

  RCipher.Init(StringBytes[0], 32, StringBytes[0], 16);
  RCipher.Mode := cmECBx;
  RCipher.DecodeStream(FileStream, StringStream, FileStream.Size);

  Memo1.Text := StringStream.DataString;

  RCipher.Free;
  FileStream.Free;
  StringStream.Free;

end;
</code></pre>

<p>but all i get is random characters... where could be the problem? Are the algorithms incompatible with each other?</p>

<p>EDIT: Replaced term 'chinese characters' by 'random characters' to avoid confusion with unicode issues.</p>

<p>Thanks to pf1957 the solution was unexpected yet simple. I was using the Delphi Encryption Compendium  library 5.1 which was obviously not AEC compliant. After i upgraded the code to the <a href=""https://code.google.com/p/delphidec/"" rel=""nofollow"">DEC 5.2</a> library all worked fine.</p>
","<p>You are using 16 byte (128-bit) key data, while you are setting encryptor/decryptor to use 256-bit key.</p>

<p>So, after you'll fix the usage of TStringStream (<em>never</em> use it with binary data), check code or documentation for both libraries to know what is done with key data - most likely it is not used directly as key but used as 'password' for key derivation process.</p>
","1929","<c#><delphi><encryption><aes><rijndael>","1","-1","1","2013-03-28 15:01:44","","20","1","355485","","2013-03-28 15:01:44","2013-03-27 22:41:44",""
"5827600","How to Decrypt File which was encrypted using RijndaelManaged","<h2>I can encrypt image file. but can not decrypt that file.</h2>

<h2>            while ((readLen = cryptStrm.Read(bs, 0, bs.Length)) > 0)</h2>

<p>anyone can guess which part is wrong?
the code i programmed is the following.</p>

<p>when i read encrypted file, i can not read at all. 
and the CryptoStream's property called length and position has ""NotSupportedException"", 
when i see cryptstream's property using vss.</p>

<p>I waste many hours to solve this problem.....
Pls help me.....</p>

<p>Encrypt
[Bitmap >> encrypted fie]</p>

<p>Decrypt
[encrypted fie >> file]</p>

<hr>

<h2>Encrypt</h2>

<pre><code>    public static void EncryptFile(
        Bitmap bmp, string destFile, byte[] key, byte[] iv)
    {

        System.Security.Cryptography.RijndaelManaged rijndael =
            new System.Security.Cryptography.RijndaelManaged();

        rijndael.Key = key;
        rijndael.IV = iv;

        System.IO.FileStream outFs = new System.IO.FileStream(
            destFile, System.IO.FileMode.Create, System.IO.FileAccess.Write);

        System.Security.Cryptography.ICryptoTransform encryptor =
            rijndael.CreateEncryptor();

        System.Security.Cryptography.CryptoStream cryptStrm =
            new System.Security.Cryptography.CryptoStream(
                outFs, encryptor,
                System.Security.Cryptography.CryptoStreamMode.Write);

        MemoryStream ms = new MemoryStream();
        bmp.Save(ms, ImageFormat.Jpeg);


        byte[] bs = new byte[1024];
        int readLen;
        while ((readLen = ms.Read(bs, 0, bs.Length)) &gt; 0)
        {
            cryptStrm.Write(bs, 0, readLen);
        }

        ms.Close();
        cryptStrm.Close();
        encryptor.Dispose();
        outFs.Close();
    }
</code></pre>

<hr>

<h2>Decrypt</h2>

<pre><code>    public static void DecryptFile(
        string sourceFile, string destFile, byte[] key, byte[] iv)
    {

        System.Security.Cryptography.RijndaelManaged rijndael =
            new System.Security.Cryptography.RijndaelManaged();

        rijndael.Key = key;
        rijndael.IV = iv;

        System.IO.FileStream inFs = new System.IO.FileStream(
            sourceFile, System.IO.FileMode.Open, System.IO.FileAccess.Read);

        System.Security.Cryptography.ICryptoTransform decryptor =
            rijndael.CreateDecryptor();

        System.Security.Cryptography.CryptoStream cryptStrm =
            new System.Security.Cryptography.CryptoStream(
                inFs, decryptor,
                System.Security.Cryptography.CryptoStreamMode.Read);

        System.IO.FileStream outFs = new System.IO.FileStream(
            destFile, System.IO.FileMode.Create, System.IO.FileAccess.Write);
        byte[] bs = new byte[1024];
        int readLen;

        while ((readLen = cryptStrm.Read(bs, 0, bs.Length)) &gt; 0)
        {
            outFs.Write(bs, 0, readLen);
        }

        outFs.Close();
        cryptStrm.Close();
        decryptor.Dispose();
        inFs.Close();
    }
</code></pre>
","<p>Try setting the Mode and Padding members of rijndael.<br>
The default padding mode caused problems when I did a similar implementation.
<code><pre>
            // It is reasonable to set encryption mode to Cipher Block Chaining
            // (CBC). Use default options for other symmetric key parameters.
            rijndael.Mode = CipherMode.CBC;
            rijndael.Padding = PaddingMode.None;
</pre></code></p>
","1911","<c#><encryption><rijndael>","3","0","1","2011-04-30 18:27:21","","0","","","","","2011-04-29 03:43:00",""
"36196425","Converting C# Cryptography.Rijndael encryption to Javascript (pref. crypto-js)","<p>I have two system which are sharing a user database, so authentication needs to be the same.</p>

<p>The passwords are currently encrypted using C#'s <code>Cryptography.Rijndael</code>(N.B. <strong>not</strong> RijndaelManaged). Using a custom key and iv (initialisation vector). (CBC mode and Pkcs7 padding)</p>

<p>The C# encryption is as follows:</p>

<pre><code>Rijndael alg = Rijndael.Create();
alg.Key = key;
alg.IV = IV;
CryptoStream cs = new CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write);
cs.Write(clearData, 0, clearData.Length);
cs.Close();
byte[] encryptedData = ms.ToArray();
</code></pre>

<p><code>key</code> is 256 bits (32 bytes) and <code>iv</code> (initialisation vector) is 128 bits (16 bytes). The block size is 128 bits (16 bytes).</p>

<p>key and iv are a byte arrays from a base64 strings via: </p>

<pre><code>byte[] key = Convert.FromBase64String(base64Key);
byte[] iv = Convert.FromBase64String(base64IV);
</code></pre>

<p>N.B. I have no control on the C# code (legacy system).</p>

<p>On the javascript based system I have to encrypt the passwords exactly the same way. I've tried using node <code>crypto-js</code> to no avail.
my code looks something like this:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(password), keyCodeWords, {
    iv: ivCodeWords,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>keyCodeWords and ivCodeWords are CryptoJS code words from the same base64 key and iv as follows:</p>

<pre><code>var keyCodeWords = CryptoJS.enc.Base64.parse(base64Key);
var ivCodeWords = CryptoJS.enc.Base64.parse(base64IV);
</code></pre>

<p>The encryption does work (in the sense that I can encrypt and then decrypt to get the same value). However, the issue is that the encrypted value (<code>encrypted.ciphertext</code>) is not the same as the C# one, so I'm unable to authenticate.</p>

<p>The comparison is done base comparing the base64 encrypted output strings.</p>

<p><strong>How do I make crypto-js (or any other javascript encryption library) consistent with C# Rijndael?</strong></p>
","<p>The code works correctly... Your problem is probably in the handling of the password/IV in C# or in Javascript... In C#: <a href=""https://ideone.com/APC4MM"" rel=""nofollow"">https://ideone.com/APC4MM</a> and in Javascript: <a href=""https://jsfiddle.net/jjwy5472/"" rel=""nofollow"">https://jsfiddle.net/jjwy5472/</a></p>

<p>I've used in both cases the same password:</p>

<pre><code>byte[] key = new byte[] 
{ 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
};

byte[] iv = new byte[] 
{ 
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
};
</code></pre>

<p>the plaintext is</p>

<pre><code>""Hello world! This is a wonderful day! àèéìòù""
</code></pre>

<p>and in both cases the resulting encrypted text is</p>

<pre><code>aa429aa5c1c928b86d81b43ff3fb6cc46f24cc73957bc7c00829357bf441eb3be9cf8aef2ff6f819f9b95c69886b169b6959c4f7ece0620c6a28f849516adee9
</code></pre>

<p>But note that the <code>encrypted</code> variable in Javascript is a complex object, containing various properties with various versions of your encrypted data. <code>encrypted.toString()</code> returns the base64 version of the encrypted data, <code>encrypted.ciphertext</code> is a <code>WordArray</code> (the equivalent of CryptoJS of <code>byte[]</code>), and <code>encrypted.ciphertext.toString()</code> is the hex version of it (equivalent to doing <code>BitConverter.ToString(encryptedData).Replace(""-"", """").ToLowerInvariant()</code> in C#).</p>
","1843","<javascript><c#><cryptojs><rijndael>","0","3","1","2016-03-24 10:04:15","36197421","7","1","3907388","","2016-03-24 09:56:52","2016-03-24 09:03:09",""
"2245737","Cannot decrypt data with C# that was encrypted using PHP (Rijdael-128)","<p>I decrypt data using PHP with this code:</p>

<pre><code>$content=""1234"";
$cp = mcrypt_module_open('rijndael-128', '', 'cbc', '');
$iv = mcrypt_create_iv(16, MCRYPT_RAND);
$key = pack(""H*"",md5('a'));
mcrypt_generic_init($cp, $key, $iv);
$encrypted = mcrypt_generic($cp, $content);
echo base64_encode($key).""\n"";
echo base64_encode($iv).""\n"";
echo base64_encode($encrypted).""\n"";
mcrypt_generic_deinit($cp);
mcrypt_module_close($cp);
</code></pre>

<p>$iv and $encrypted is then saved to file and read in the C# sample app:</p>

<pre><code>var iv=...;
var encrypted=...;
var md5 = new MD5CryptoServiceProvider();
var key = md5.ComputeHash(Encoding.Default.GetBytes(""a""));
md5.Clear();

Console.WriteLine(Convert.ToBase64String(key));
Console.WriteLine(Convert.ToBase64String(iv));
Console.WriteLine(Convert.ToBase64String(encrypted));
</code></pre>

<p>The output here is exactly the same as the output from PHP, so I can assure there is no encoding error inbetween.</p>

<pre><code>var rd = new RijndaelManaged {
  Key = key,
  IV = iv,
  Mode = CipherMode.CBC,
  KeySize = 128,
  Padding = PaddingMode.Zeros
};

var buffer = new byte[encrypted.Length];
using(var ms = new MemoryStream(buffer)) {
  using(var cs = new CryptoStream(ms, rd.CreateDecryptor(), CryptoStreamMode.Write)) {
    cs.Write(encrypted, 0, encrypted.Length);
    ms.Read(buffer, 0, buffer.Length);
    Console.WriteLine(Encoding.Default.GetString(buffer));
  } 
}
rd.Clear();
</code></pre>

<p>The result of the decryption varies on every program start, even with exactly the same input data:</p>

<p>First run:<br>
DMF1ucDxtqgxw5niaXcmYQ==   &lt;-Key<br>
GoCeRkrL/EMKNH/BYeLsqQ==   &lt;-IV<br>
UBE3DkgbJgj1K/TISugLxA==   &lt;-Encrypted<br>
OlOB99yiCYRDoLx+0xxZxQ==   &lt;-""Decrypted""  </p>

<p>Second run:<br>
DMF1ucDxtqgxw5niaXcmYQ==   &lt;-Key<br>
GoCeRkrL/EMKNH/BYeLsqQ==   &lt;-IV<br>
UBE3DkgbJgj1K/TISugLxA==   &lt;-Encrypted<br>
w5fcY5Fbb9KRgoHfhqAztA==   &lt;-""Decrypted""  </p>

<p>Key, IV, Encrypted data are identical, but still the decrypted date varies and is always wrong. buffer should contain ""1234"" or ""1234"" plus 12 trailing zeros.</p>

<p>I don't see why the results vary and what is not working, but I have been staring at this darn piece of code for several hours now, and probably miss the obvious error...</p>

<p>Reversing the CryptoStream like this creates identically wrong results:</p>

<pre><code>using(var ms = new MemoryStream(encrypted)) {
  using(var cs = new CryptoStream(ms, rd.CreateDecryptor(), CryptoStreamMode.Read)) {
    cs.Read(buffer, 0, buffer.Length);
    Console.WriteLine(Convert.ToBase64String(buffer));
  }
}
</code></pre>

<p>Help?
Thanks!
Alexander</p>
","<p>Well, modifying an old sample of my sins of the past I ended up with this:</p>

<pre><code>static string Decrypt() {            
  byte[] keyBytes = Convert.FromBase64String(""DMF1ucDxtqgxw5niaXcmYQ=="");
  byte[] iv = Convert.FromBase64String(""GoCeRkrL/EMKNH/BYeLsqQ=="");
  byte[] cipherTextBytes = Convert.FromBase64String(""UBE3DkgbJgj1K/TISugLxA=="");

  var symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC, IV = iv, KeySize = 128, Key = keyBytes, Padding = PaddingMode.Zeros};

  using (var decryptor = symmetricKey.CreateDecryptor())
  using (var ms = new MemoryStream(cipherTextBytes))
  using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read)) {
    var plainTextBytes = new byte[cipherTextBytes.Length];
    int decryptedByteCount = cs.Read(plainTextBytes, 0, plainTextBytes.Length);
    return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
  }
}
</code></pre>

<p>which gave ""1234"" with trailing \0 characters.. Did you just forget to convert the byte[] to a string again? What other difference am I missing?</p>
","1838","<c#><php><encryption><rijndael>","6","5","1","2010-02-11 16:32:51","2245925","0","1","","","","2010-02-11 16:03:50",""
"11588032","Problems with the key encryption / decryption AES (Rijndael)","<p>I'm working on a Android project that uses the AES algorithm (Rijndael) to encrypt and decrypt information trafficked.</p>

<p>WS I consume has a fixed key for encryption and decryption. So I have to have the same key in the source code.</p>

<p>However, this key undergoes a treatment to be subsequently used to encrypt / decrypt. The problem is that the key is not going through proper treatment. The reason: special characters. I tried using other keys without special characters, and it worked perfectly.</p>

<p>Here is an excerpt of the algorithm below:</p>

<pre><code>final String KEY_GENERATION_ALG = ""d(*Mu96p@lg91¨%0c*f7&amp;d^`pkçly$f7"";
    final int HASH_ITERATIONS = 10000;
    final int KEY_LENGTH = 256;

    char[] humanPassphrase = { 'P', 'e', 'r', ' ', 'v', 'a', 'l', 'l', 'u',
            'm', ' ', 'd', 'u', 'c', 'e', 's', ' ', 'L', 'a', 'b', 'a',
            'n', 't' };
    byte[] salt = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xE,
            0xF }; 

    PBEKeySpec myKeyspec = new PBEKeySpec(humanPassphrase, salt, HASH_ITERATIONS, KEY_LENGTH);
    SecretKeyFactory keyfactory = null;
    SecretKey sk = null;
    SecretKeySpec skforAES = null;

    try {
        keyfactory = SecretKeyFactory.getInstance(KEY_GENERATION_ALG);
        sk = keyfactory.generateSecret(myKeyspec);

    } catch (NoSuchAlgorithmException nsae) {
        Log.e(""AESdemo"",
                ""no key factory support for PBEWITHSHAANDTWOFISH-CBC"");

    } catch (InvalidKeySpecException ikse) {
        Log.e(""AESdemo"", ""invalid key spec for PBEWITHSHAANDTWOFISH-CBC"");

    }

    byte[] skAsByteArray = sk.getEncoded();
    skforAES = new SecretKeySpec(skAsByteArray, ""AES"");

    final String CIPHERMODEPADDING = ""AES/CBC/PKCS7Padding"";

    byte[] iv = { 0xA, 1, 0xB, 5, 4, 0xF, 7, 9, 0x17, 3, 1, 6, 8, 0xC, 0xD,
            91 };
    IvParameterSpec IV = new IvParameterSpec(iv);

    String decrypted = new String(decrypt(CIPHERMODEPADDING, skforAES, IV, ciphertext));

    return decrypted;
</code></pre>

<p>Here's the key: d(*Mu96p@lg91¨%0c*f7&amp;d^`pkçly$f7</p>

<p>The application crashes on the catch block ""NoSuchAlgorithmException"".</p>

<p>Has anyone experienced this? I have no idea what to do to fix this problem.</p>

<p>Thanks a lot!</p>

<hr>

<p>Still did not work, Marcus. :/</p>

<p>The error is this:</p>

<p>""Invalid key exception.""</p>

<p>See how is my code.</p>

<pre><code>public class MainActivity extends Activity {
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    String desc = ""starting work..."";
    TextView tv1 = (TextView) findViewById(R.id.tv1);
    tv1.setText(desc);

    byte[] KEY_GENERATION_ALG = null;
    try {
        KEY_GENERATION_ALG = (""teste"").getBytes(""ISO-8859-1"");
    } catch (UnsupportedEncodingException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
    final int HASH_ITERATIONS = 10000;
    final int KEY_LENGTH= 256;
    SecretKeySpec skforAES=null;
    // Obviously, you must not embed the human-friendly passphrase in your code, as I have done here.
    // The passphrase should be kept outside the mobile device, and the user prompted to enter it.
    // It is supplied as a literal here for convenience of this demonstration
    /*char [] humanPassphrase = {'P','e','r',' ','v','a','l','l','u','m',' ',
                               'd','u','c','e','s',' ','L','a','b','a','n','t' };
    byte [] salt = {0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xD,0xE,0xF};  // must save this for next time we want the key


    PBEKeySpec myKeyspec = new PBEKeySpec(humanPassphrase, salt, HASH_ITERATIONS, KEY_LENGTH);
    tv1.setText(""PBEKeySpec generated"");
    SecretKeyFactory keyfactory=null;
    SecretKey sk=null;
    SecretKeySpec skforAES=null;
    try {
        keyfactory = SecretKeyFactory.getInstance(KEY_GENERATION_ALG);
        sk = keyfactory.generateSecret(myKeyspec);

    } catch (NoSuchAlgorithmException nsae) {
        Log.e(""AESdemo"", ""no key factory support for PBEWITHSHAANDTWOFISH-CBC"" );
    } catch (InvalidKeySpecException ikse) {
        Log.e(""AESdemo"", ""invalid key spec for PBEWITHSHAANDTWOFISH-CBC"" );
    }

    // This is our secret key.  We could just save this to a file instead of regenerating it
    // each time it is needed.  But that file cannot be on the device (too insecure).  It could
    // be secure if we kept it on a server accessible through https.
    byte[] skAsByteArray = sk.getEncoded();*/
    try {
        skforAES = new SecretKeySpec(KEY_GENERATION_ALG, ""AES"");
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    final String CIPHERMODEPADDING = ""AES/CBC/PKCS7Padding"";

    // must save the IV for use when we want to decrypt the text
    byte [] iv = {0xA,1,0xB,5,4,0xF,7,9,0x17,3,1,6,8,0xC,0xD,91};   
    IvParameterSpec IV = new IvParameterSpec(iv);
    byte[] plaintext=null;
    try {
        // Obviously in a real use scenario, the plaintext will not be a literal in your app.
        // This plaintext comes from chapter X of ""Alice's Adventures in Wonderland"" by Lewis Carroll
        // I like the emphasis the author places on clear explanations ...
        plaintext = (
                  ""Tis the voice of the Lobster; I heard him declare,\n""
                + ""    \""You have baked me too brown, I must sugar my hair.\""\n ""
                + ""    As a duck with its eyelids, so he with his nose\n""
                + ""    Trims his belt and his buttons, and turns out his toes.'\n""
                + ""`I should like to have it explained,' said the Mock Turtle.\n""
                + ""`She can't explain it,' said the Gryphon hastily. `Go on with the next verse.'\n""
                + ""Alice did not dare to disobey, though she felt sure it would all come wrong, ""
                + ""and she went on in a trembling voice:-- \n""
                + ""    `I passed by his garden, and marked, with one eye, \n""
                + ""     How the Owl and the Panther were sharing a pie--' \n""
                + ""`What is the use of repeating all that stuff,' the Mock Turtle interrupted, ""
                + ""`if you don't explain it as you go on? It's by far the most confusing thing I ever heard!'""
                ).getBytes(""ISO-8859-1"");
    } catch (UnsupportedEncodingException uee) {
        Log.e(""AESdemo"", ""no String support for ISO-8859-1"" );
    }

    Log.i(""AESdemo"", ""plaintext length ="" + plaintext.length );


    byte[] ciphertext = encrypt(CIPHERMODEPADDING, skforAES, IV, plaintext);

    String decrypted = new String( decrypt(CIPHERMODEPADDING, skforAES, IV, ciphertext) );

    tv1.setText(decrypted);
}

//  Use this method if you want to add the padding manually
//  AES deals with messages in blocks of 16 bytes.
//  This method looks at the length of the message, and adds bytes at the end
//  so that the entire message is a multiple of 16 bytes.
//  the padding is a series of bytes, each set to the total bytes added (a number in range 1..16).
byte [] addPadding (byte[] plain) {
    byte plainpad[] = null;
    int shortage  = 16 - (plain.length % 16);
    // if already an exact multiple of 16, need to add another block of 16 bytes
    if (shortage==0) shortage=16;

    // reallocate array bigger to be exact multiple, adding shortage bits.
    plainpad = new byte[ plain.length+shortage ];
    for (int i=0;i&lt; plain.length; i++) {
        plainpad[i]=plain[i];
    }
    for (int i=plain.length;i&lt;plain.length+shortage;i++) {
        plainpad[i]=(byte)shortage;
    }
    return plainpad;
}

//  Use this method if you want to remove the padding manually
// This method removes the padding bytes
byte [] dropPadding (byte[] plainpad) {
    byte plain[] = null;
    int drop  = plainpad[plainpad.length-1];  //last byte gives number of bytes to drop

    // reallocate array smaller, dropping the pad bytes.
    plain = new byte[ plainpad.length - drop ];
    for (int i=0;i&lt; plain.length; i++) {
        plain[i]=plainpad[i];
        plainpad[i]=0;  // don't keep a copy of the decrypt
    }
    return plain;
}


byte [] encrypt(String cmp, SecretKey sk, IvParameterSpec IV, byte[] msg) {
    try {
        Cipher c = Cipher.getInstance(cmp);
        c.init(Cipher.ENCRYPT_MODE, sk, IV);
        return c.doFinal(msg);
    } catch (NoSuchAlgorithmException nsae) {
        Log.e(""AESdemo"", ""no cipher getinstance support for ""+cmp );
    } catch (NoSuchPaddingException nspe) {
        Log.e(""AESdemo"", ""no cipher getinstance support for padding "" + cmp );
    } catch (InvalidKeyException e) {
        Log.e(""AESdemo"", ""invalid key exception"" );
    } catch (InvalidAlgorithmParameterException e) {
        Log.e(""AESdemo"", ""invalid algorithm parameter exception"" );
    } catch (IllegalBlockSizeException e) {
        Log.e(""AESdemo"", ""illegal block size exception"" );
    } catch (BadPaddingException e) {
        Log.e(""AESdemo"", ""bad padding exception"" );
    }
    return null;
}

byte [] decrypt(String cmp, SecretKey sk, IvParameterSpec IV, byte[] ciphertext) {
    try {
        Cipher c = Cipher.getInstance(cmp);
        c.init(Cipher.DECRYPT_MODE, sk, IV);
        return c.doFinal(ciphertext);
    } catch (NoSuchAlgorithmException nsae) {
        Log.e(""AESdemo"", ""no cipher getinstance support for ""+cmp );
    } catch (NoSuchPaddingException nspe) {
        Log.e(""AESdemo"", ""no cipher getinstance support for padding "" + cmp );
    } catch (InvalidKeyException e) {
        Log.e(""AESdemo"", ""invalid key exception"" );
    } catch (InvalidAlgorithmParameterException e) {
        Log.e(""AESdemo"", ""invalid algorithm parameter exception"" );
    } catch (IllegalBlockSizeException e) {
        Log.e(""AESdemo"", ""illegal block size exception"" );
    } catch (BadPaddingException e) {
        Log.e(""AESdemo"", ""bad padding exception"" );
    }
    return null;
}
</code></pre>

<p>}</p>
","<p>I'm not really following what you're doing here, but it looks like you're not using the APIs correctly. The argument to <code>SecretKeyFactory.getInstance()</code> is supposed to be the name of the key algorithm, not the actual key. And since you already have the key, you shouldn't need to use the SecretKeyFactory to generate one for you.</p>

<p>Try creating instance of SecretKeySpec directly with your key, like this:</p>

<pre><code>skforAES = new SecretKeySpec(KEY.getBytes(""utf-8""), ""AES"");
</code></pre>
","1808","<android><key><aes><rijndael>","0","0","1","2012-07-23 00:52:39","","0","4","16587","","2012-07-23 00:52:39","2012-07-20 23:07:41",""
"36336629","AES encryption with Go and PHP","<p>I am using AES encryption in Go and PHP. But both the languages does not encrypt/decrypt each other ciphertext. Following i have tried in php</p>

<pre><code>       class Crypto {
    private $encryptKey = ""keyforencryption"";
    private $iv = 'ivusedforencrypt';
    private $blocksize = 16;
    public function encrypt($toEncrypt){
        $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CFB);
        //$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
        return base64_encode($this-&gt;iv . mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this-&gt;encryptKey, $toEncrypt, MCRYPT_MODE_CFB, $this-&gt;iv));
    }

    public function decrypt($toDecrypt){
       $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CFB);//$this-&gt;blocksize;
       $toDecrypt = base64_decode($toDecrypt);
       return rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;encryptKey, substr($toDecrypt, $iv_size), MCRYPT_MODE_CFB, substr($toDecrypt, 0, $iv_size)));
    }

}

$c = new Crypto();
echo ""Encrypted : "".$e =  $c-&gt;encrypt(""test"");
echo ""&lt;br/&gt;Decrypted : "".$c-&gt;decrypt($e);
</code></pre>

<p>output : aXZ1c2VkZm9yZW5jcnlwdDpdZEinU2rB</p>

<p>and this one in Go with AES</p>

<pre><code>    package main

import (
    ""crypto/aes""
    ""crypto/cipher""
    ""crypto/rand""
    ""encoding/base64""
    ""errors""
    ""fmt""
    ""io""
    ""log""
)

func main() {
    key := []byte(""keyforencryption"")
    plaintext := []byte(""test"")
    fmt.Printf(""%s\n"", plaintext)
    ciphertext, err := encrypt(key, plaintext)
    if err != nil {
        log.Fatal(err)
    }
    b := base64.StdEncoding.EncodeToString(ciphertext)
    fmt.Printf(""Encrypted text : %s\n"", b)
    result, err := decrypt(key, b)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""Decrypted Text : %s\n"", result)
}

func encrypt(key, text []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    //b := base64.StdEncoding.EncodeToString(text)
    ciphertext := make([]byte, aes.BlockSize+len(text))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return nil, err
    }
    cfb := cipher.NewCFBEncrypter(block, iv)
    cfb.XORKeyStream(ciphertext[aes.BlockSize:], []byte(text))
    return ciphertext, nil
}

func decrypt(key []byte, text1 string) ([]byte, error) {
    text, _ := base64.StdEncoding.DecodeString(string(text1))
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    if len(text) &lt; aes.BlockSize {
        return nil, errors.New(""ciphertext too short"")
    }
    iv := text[:aes.BlockSize]
    text = text[aes.BlockSize:]
    cfb := cipher.NewCFBDecrypter(block, iv)
    cfb.XORKeyStream(text, text)
    b := base64.StdEncoding.EncodeToString(text)
    data, err := base64.StdEncoding.DecodeString(string(b))
    if err != nil {
        return nil, err
    }
    return data, nil
}
</code></pre>

<p>output : ZVnhCXjIvtGKBdqvjwHRZKcVy34=</p>

<p>any help would be appreciable.</p>
","<p>CFB mode has an issue, this will work in CBC mode</p>

<pre><code>class Crypto {
    private $encryptKey = ""keyforencryption"";
    public function encrypt($toEncrypt){
        $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
        $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
        return base64_encode($iv . mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this-&gt;encryptKey, $toEncrypt, MCRYPT_MODE_CBC, $iv));
    }

    public function decrypt($toDecrypt){
       $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
       echo ""&lt;br/&gt;"".$toDecrypt = base64_decode($toDecrypt);
       return rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;encryptKey, substr($toDecrypt, $iv_size), MCRYPT_MODE_CBC, substr($toDecrypt, 0, $iv_size)));
    }
}

$c = new Crypto();
echo ""Encrypted : "".$e =  $c-&gt;encrypt(""test123"");
echo ""&lt;br/&gt;Decrypted : "".$c-&gt;decrypt($e);
</code></pre>

<p>and this one in golang</p>

<pre><code>package main

import (
    ""crypto/aes""
    ""crypto/cipher""
    ""crypto/rand""
    ""encoding/base64""
    ""fmt""
    ""io""
    ""bytes""
)

func main() {
    e:= cbcEncrypt()
    fmt.Printf(""Encrypted String : %s\n"", e)

    d:= cbcDecrypt(e)
    fmt.Printf(""Decrypted String : %s\n"", d)
}

func cbcDecrypt(text1 string) []byte{
    key := []byte(""keyforencryption"")
    ciphertext, _ := base64.StdEncoding.DecodeString(string(text1))
    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // include it at the beginning of the ciphertext.
    if len(ciphertext) &lt; aes.BlockSize {
        panic(""ciphertext too short"")
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]

    // CBC mode always works in whole blocks.
    if len(ciphertext)%aes.BlockSize != 0 {
        panic(""ciphertext is not a multiple of the block size"")
    }

    mode := cipher.NewCBCDecrypter(block, iv)

    // CryptBlocks can work in-place if the two arguments are the same.
    mode.CryptBlocks(ciphertext, ciphertext)
    ciphertext = PKCS5UnPadding(ciphertext)
    return ciphertext
}

func cbcEncrypt() string{
    key := []byte(""keyforencryption"")
    plaintext := []byte(""testssssss"")
    plaintext = PKCS5Padding(plaintext, 16)
    // CBC mode works on blocks so plaintexts may need to be padded to the
    // next whole block. For an example of such padding, see
    // https://tools.ietf.org/html/rfc5246#section-6.2.3.2. Here we'll
    // assume that the plaintext is already of the correct length.
    if len(plaintext)%aes.BlockSize != 0 {
        panic(""plaintext is not a multiple of the block size"")
    }

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // The IV needs to be unique, but not secure. Therefore it's common to
    // include it at the beginning of the ciphertext.
    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        panic(err)
    }

    mode := cipher.NewCBCEncrypter(block, iv)
    mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)

    // It's important to remember that ciphertexts must be authenticated
    // (i.e. by using crypto/hmac) as well as being encrypted in order to
    // be secure.

    return base64.StdEncoding.EncodeToString(ciphertext)
}

func PKCS5Padding(src []byte, blockSize int) []byte {
    padding := blockSize - len(src)%blockSize
    padtext := bytes.Repeat([]byte{byte(padding)}, padding)
    return append(src, padtext...)
}

func PKCS5UnPadding(src []byte) []byte {
    length := len(src)
    unpadding := int(src[length-1])
    return src[:(length - unpadding)]
}
</code></pre>

<p>this should work</p>
","1805","<php><encryption><go><aes><rijndael>","4","4","2","2018-10-04 07:01:59","36370023","6","1","2224584","","2016-04-18 00:19:24","2016-03-31 14:42:06",""
"36336629","AES encryption with Go and PHP","<p>I am using AES encryption in Go and PHP. But both the languages does not encrypt/decrypt each other ciphertext. Following i have tried in php</p>

<pre><code>       class Crypto {
    private $encryptKey = ""keyforencryption"";
    private $iv = 'ivusedforencrypt';
    private $blocksize = 16;
    public function encrypt($toEncrypt){
        $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CFB);
        //$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
        return base64_encode($this-&gt;iv . mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this-&gt;encryptKey, $toEncrypt, MCRYPT_MODE_CFB, $this-&gt;iv));
    }

    public function decrypt($toDecrypt){
       $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CFB);//$this-&gt;blocksize;
       $toDecrypt = base64_decode($toDecrypt);
       return rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;encryptKey, substr($toDecrypt, $iv_size), MCRYPT_MODE_CFB, substr($toDecrypt, 0, $iv_size)));
    }

}

$c = new Crypto();
echo ""Encrypted : "".$e =  $c-&gt;encrypt(""test"");
echo ""&lt;br/&gt;Decrypted : "".$c-&gt;decrypt($e);
</code></pre>

<p>output : aXZ1c2VkZm9yZW5jcnlwdDpdZEinU2rB</p>

<p>and this one in Go with AES</p>

<pre><code>    package main

import (
    ""crypto/aes""
    ""crypto/cipher""
    ""crypto/rand""
    ""encoding/base64""
    ""errors""
    ""fmt""
    ""io""
    ""log""
)

func main() {
    key := []byte(""keyforencryption"")
    plaintext := []byte(""test"")
    fmt.Printf(""%s\n"", plaintext)
    ciphertext, err := encrypt(key, plaintext)
    if err != nil {
        log.Fatal(err)
    }
    b := base64.StdEncoding.EncodeToString(ciphertext)
    fmt.Printf(""Encrypted text : %s\n"", b)
    result, err := decrypt(key, b)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""Decrypted Text : %s\n"", result)
}

func encrypt(key, text []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    //b := base64.StdEncoding.EncodeToString(text)
    ciphertext := make([]byte, aes.BlockSize+len(text))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return nil, err
    }
    cfb := cipher.NewCFBEncrypter(block, iv)
    cfb.XORKeyStream(ciphertext[aes.BlockSize:], []byte(text))
    return ciphertext, nil
}

func decrypt(key []byte, text1 string) ([]byte, error) {
    text, _ := base64.StdEncoding.DecodeString(string(text1))
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    if len(text) &lt; aes.BlockSize {
        return nil, errors.New(""ciphertext too short"")
    }
    iv := text[:aes.BlockSize]
    text = text[aes.BlockSize:]
    cfb := cipher.NewCFBDecrypter(block, iv)
    cfb.XORKeyStream(text, text)
    b := base64.StdEncoding.EncodeToString(text)
    data, err := base64.StdEncoding.DecodeString(string(b))
    if err != nil {
        return nil, err
    }
    return data, nil
}
</code></pre>

<p>output : ZVnhCXjIvtGKBdqvjwHRZKcVy34=</p>

<p>any help would be appreciable.</p>
","<p>Also use padding for encoding and unpadding for decode in php.</p>

<pre><code>function pkcs5_pad($text)
{
    $blocksize = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $pad = $blocksize - (strlen($text) % $blocksize);
    return $text . str_repeat(chr($pad), $pad);
}

function pkcs5_unpad($text)
{
    $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $pad = ord($text[($len = strlen($text)) - 1]);
    $len = strlen($text);
    $pad = ord($text[$len-1]);
    return substr($text, 0, strlen($text) - $pad);
}
</code></pre>
","1805","<php><encryption><go><aes><rijndael>","4","1","2","2018-10-04 07:01:59","36370023","6","1","2224584","","2016-04-18 00:19:24","2016-03-31 14:42:06",""
"7400661","Encryption - symmetric key","<p>I’m using Rijndael (as AES algorithm) for encrypting. I encrypt the values (objects properties) and serialize the object to xml an dsend the xml to the receiver via a web service. I want to pass along the encrypted symmetric key that I used to encrypt the data. But what key should I pass along?
My decryption algorithm looks like this (vb.net):</p>

<pre><code>Public Function Encrypt(ByVal stringToEncrypt As String) As String

    Dim textConverter As New ASCIIEncoding()
    Dim myRijndael As New RijndaelManaged()
    Dim encrypted() As Byte
    Dim stringToEncryptAsByte() As Byte
    Dim encryptedAsString As String
    Dim key() As Byte
    Dim IV() As Byte

        ' Set symetric key size og chiper mode
        myRijndael.Mode = CipherMode.CBC
        myRijndael.KeySize = 128

        ' Create a new key and initialization vector.
        myRijndael.GenerateKey()
        myRijndael.GenerateIV()

        ' Get the key and IV.
        key = myRijndael.Key
        IV = myRijndael.IV

        ' Get an encryptor.
        Dim encryptor As ICryptoTransform = myRijndael.CreateEncryptor(key, IV)

        ' Encrypt the data.
        Dim msEncrypt As New MemoryStream()
        Dim csEncrypt As New CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)

        ' Convert the data to a byte array.
        stringToEncryptAsByte = textConverter.GetBytes(stringToEncrypt)

        ' Write all data to the crypto stream and flush it.
        csEncrypt.Write(stringToEncryptAsByte, 0, stringToEncryptAsByte.Length)
        csEncrypt.FlushFinalBlock()

        ' Get encrypted array of bytes.
        encrypted = msEncrypt.ToArray()
        encryptedAsString = Convert.ToBase64String(encrypted)

        Return encryptedAsString
End Function
</code></pre>

<p>If I want to decrypt the encrypted string I have to use both key and IV, but I think I have to pass along only a key value. Do I have to do this another way or what should I pass along?
My specification says that the values have to be encrypted using AES and a 128 bits key.</p>
","<p>If you pass the encryption key along with the encrypted data, this is equivalent to not encrypting the data at all (other than one can't read it with plain eyes, but then a simple Base64 encoding or similar would do the same.</p>

<p>To use a symmetric encryption algorithm, sender and receiver <em>must share a secret</em> (the symmetric key, or something from which the key can be derived). If this is not possible, you might want to use a hybrid symmetric/asymmetric encryption scheme: Here the sender encrypts the secret key using a public key algorithm, and sends it together with the symmetrically encrypted data. (In this case, the sender must know the public key corresponding to the receiver's private key.)</p>

<p>That said, with chaining modes of operation for block ciphers (like CBC), the sender usually passes the initialization vector along with the data.</p>
","1790","<vb.net><encryption><key><aes><rijndael>","1","1","2","2011-09-13 11:09:45","","0","","600500","","2011-09-13 11:01:05","2011-09-13 10:51:27",""
"7400661","Encryption - symmetric key","<p>I’m using Rijndael (as AES algorithm) for encrypting. I encrypt the values (objects properties) and serialize the object to xml an dsend the xml to the receiver via a web service. I want to pass along the encrypted symmetric key that I used to encrypt the data. But what key should I pass along?
My decryption algorithm looks like this (vb.net):</p>

<pre><code>Public Function Encrypt(ByVal stringToEncrypt As String) As String

    Dim textConverter As New ASCIIEncoding()
    Dim myRijndael As New RijndaelManaged()
    Dim encrypted() As Byte
    Dim stringToEncryptAsByte() As Byte
    Dim encryptedAsString As String
    Dim key() As Byte
    Dim IV() As Byte

        ' Set symetric key size og chiper mode
        myRijndael.Mode = CipherMode.CBC
        myRijndael.KeySize = 128

        ' Create a new key and initialization vector.
        myRijndael.GenerateKey()
        myRijndael.GenerateIV()

        ' Get the key and IV.
        key = myRijndael.Key
        IV = myRijndael.IV

        ' Get an encryptor.
        Dim encryptor As ICryptoTransform = myRijndael.CreateEncryptor(key, IV)

        ' Encrypt the data.
        Dim msEncrypt As New MemoryStream()
        Dim csEncrypt As New CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)

        ' Convert the data to a byte array.
        stringToEncryptAsByte = textConverter.GetBytes(stringToEncrypt)

        ' Write all data to the crypto stream and flush it.
        csEncrypt.Write(stringToEncryptAsByte, 0, stringToEncryptAsByte.Length)
        csEncrypt.FlushFinalBlock()

        ' Get encrypted array of bytes.
        encrypted = msEncrypt.ToArray()
        encryptedAsString = Convert.ToBase64String(encrypted)

        Return encryptedAsString
End Function
</code></pre>

<p>If I want to decrypt the encrypted string I have to use both key and IV, but I think I have to pass along only a key value. Do I have to do this another way or what should I pass along?
My specification says that the values have to be encrypted using AES and a 128 bits key.</p>
","<p>The IV is simple, just send it as-is.  It is common practice to prepend it to the cyphertext so the receiver just strips it off when needed.  There is no need to keep the IV secret.</p>

<p>The key is not so simple because it <strong>must</strong> be kept secret.  There are two general solutions:</p>

<ol>
<li><p>Use Diffie-Hellman to agree a new secret key with your recipient each time you need to send them an encrypted file.</p></li>
<li><p>Use their RSA public key to encrypt the AES key and send it to them that way.</p></li>
</ol>

<p>You may also want to investigate the use of HMAC to ensure that the file has not been tampered with during transmission.</p>
","1790","<vb.net><encryption><key><aes><rijndael>","1","1","2","2011-09-13 11:09:45","","0","","600500","","2011-09-13 11:01:05","2011-09-13 10:51:27",""
"19209741","C# Rijndael issue run-time error while trying to decrypt Padding is invalid or cannot be removed","<p>I get a run-time error <code>Padding is invalid and cannot be removed</code> while trying to decrypt some data. I have read all the similar threads I found on stackoverflow and considered the following issues: </p>

<ol>
<li><p>Given a different key for decryption than the one used for encryption might bring the above issue. However, as you can see in the source for testing purposes I hard-coded the keys and I still get a runtime error. </p></li>
<li><p>The application may be trying to use a different padding mode for decryption than the one used for encryption. Setting the mode explicitly during the encryption or decryption process didn't solve the problem. </p></li>
<li><p>Some say that you would need to use the <code>FlushFinalBlock</code> method so you can tell the application to put the final bits into the <code>blocksize</code>. Tried putting it below the Write method, didn't work either.</p></li>
</ol>

<p><code></p>

<pre><code>using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
{
    //Write all data to the stream.
    swEncrypt.Write(plainText);
    csEncrypt.FlushFinalBlock();
}
</code></pre>

<p></code></p>

<p>Below are the snippets of my code: </p>

<pre><code>// Encrypt 
private byte[] EncryptStringToBytes(string plainText, byte[] Key, byte[] IV)
{
    Key = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6 };
    IV = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6 };

    // Check arguments. 
    if (plainText == null || plainText.Length &lt;= 0)
        throw new ArgumentNullException(""plainText"");
    if (Key == null || Key.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");
    if (IV == null || IV.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");

    byte[] encrypted;

    // Create an RijndaelManaged object 
    // with the specified key and IV. 
    using (RijndaelManaged rijAlg = new RijndaelManaged())
    {
        rijAlg.Key = Key;
        rijAlg.IV = IV;
        rijAlg.Padding = PaddingMode.PKCS7;

        // Create a decrytor to perform the stream transform.
        ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

        // Create the streams used for encryption. 
        using (MemoryStream msEncrypt = new MemoryStream())
        {
            using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
            {
                using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                {
                    // Write all data to the stream.
                    swEncrypt.Write(plainText);
                    csEncrypt.FlushFinalBlock();
                }

                encrypted = msEncrypt.ToArray();
                MessageBox.Show(""Encrypted str: "" + Encoding.UTF8.GetString(encrypted).ToString());
            }
        }
    }

    // Update buffer length
    this.Buflen = encrypted.Length;
    MessageBox.Show(""Byte count: "" + (Encoding.UTF8.GetByteCount(encrypted.ToString())).ToString());
    MessageBox.Show(""Decrypted: "" + DecryptStringFromBytes(encrypted, this.Encryption_key, this.Encryption_iv));

    // Return the encrypted bytes from the memory stream. 
    return encrypted;
}

// Decrypt
private string DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV)
{
    Key = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6 };
    IV = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6 };

    UTF8Encoding e = new UTF8Encoding();
    MessageBox.Show(""ciperText "" + cipherText.Length);
    //cipherText = e.GetBytes(cipherText);
    //MessageBox.Show(""ciperText2 Length "" + cipherText.Length);

    // Check arguments. 
    if (cipherText == null || cipherText.Length &lt;= 0)
        throw new ArgumentNullException(""cipherText"");
    if (Key == null || Key.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");
    if (IV == null || IV.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");

    // Declare the string used to hold 
    // the decrypted text. 
    string plaintext = null;

    // Create an RijndaelManaged object 
    // with the specified key and IV. 
    using (RijndaelManaged rijAlg = new RijndaelManaged())
    {
        rijAlg.Key = Key;
        rijAlg.IV = IV;
        rijAlg.Padding = PaddingMode.PKCS7;

        // Create a decrytor to perform the stream transform.
        ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

        // Create the streams used for decryption. 
        using (MemoryStream msDecrypt = new MemoryStream(cipherText))
        {
            using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
            {
                using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                {
                    // Read the decrypted bytes from the decrypting stream 
                    // and place them in a string.
                    if (cipherText.Length != rijAlg.BlockSize)
                    {
                        throw new InvalidOperationException(""Invalid cipherText length"");
                    }

                    plaintext = srDecrypt.ReadToEnd();

                    csDecrypt.FlushFinalBlock();
                }
            }
        }
    }

    return plaintext;
}

byte[] encoded_message = new byte[16];
encoded_message = EncryptStringToBytes(""test"", this.Encryption_key,this.Encryption_iv);
</code></pre>

<p>I'm trying to get this working since yesterday morning. None of the solutions I found so far worked in my application. I know the code may look a bit of a mess, but please never mind the parts which are not being used - once I get this working it will surely need a bit of refactoring. </p>

<p>As you can see, while using a hard-coded key and IV for testing purposes the run-time error still occurs so passing different credentials for decryption than the ones used for encryption is not the cause. </p>

<p>Can anyone come up with an idea on how to resolve this? Thanks.</p>
","<p>I'm writing this thread for anyone who has tried to send encrypted data through sockets as I have been having trouble doing this over the last 3 days. As you know, encrypted data might contain padding characters and special symbols that, mixed with the way packets are sent through the socket (usually in binary form and in chunks), might not come out on the other side the way you expect. The errors that you will usually get are <strong>Padding is invalid and cannot be removed</strong> or <strong>*<em>Length of data to decrypt is invalid *</em></strong>. I've come across this while writing an application which sends encrypted Rijndael credentials through a UDP socket. So usually what you sent is not what you get, a padding character is being added (or several like it) which results in bugos encrypted data which can not be recognized by the rijndael algorithm (please note that this may also result while trying to decrypt any other type of encryption and I suppose it actually does). So I'm giving you my solution below with the intention to help to anyone who's in the process of sending encrypted data and trying to do this correctly, (I'm not saying that this is the ONLY and this is the most proper way to do this, but this is the way that I found to work and that I personally used): </p>

<p>1) Having in mind that most encryption functions take a byte array as a parameter, and most socket functions for sending data also do so, first we get our encrypted string in bytes array form: </p>

<pre><code>byte[] encrypted_string = new byte[lengthofblocksize]; // where lengthofblocksize would be the length in bytes of the blocksize for the used algorithm, for rijndael that usually is 16
//getting the encrypted byte array
encrypted_string = EncryptStringToBytes(messageInPlainText, key, iv); 
</code></pre>

<p>where messageInPlainText is your plain text message, key and iv are your key and iv parameters. </p>

<p>2) Before sending the data When sending the data through the socket, encrypt it into a base64 string. Suppose we store our string in the variable ""textdata"". The first step would be
    string encrypted_string_base64 = Convert.ToBase64String(textdata);</p>

<p>3) now you have the base64 string as string. What you need is to get it in bytes array, which can be done using the UTF8Encoding GetBytes method: 
   encrypted_string = enc.GetBytes(encrypted_string_base64.ToString());
4) and THEN you are ready to send the data through the socket so you can get a proper encoded binary data on the other side. 
   sck.Send(encrypted_string);</p>

<p>5) So on the other side you get the string usually in binary data, let's suppose it's in the variable recvdata. What you need to do is to convert the byte array to a string: </p>

<pre><code> string recv_textdata = Convert.FromBase64String(recvdata);
</code></pre>

<p>However, before this you might need to create a method which clears out all unnecesssary padding and symbols: </p>

<pre><code> UTF8Encoding enc = new UTF8ENcoding();
 string recv_textdata = FormatStringAsBase64(enc.GetString(recvdata)).Trim();
(please scroll to the bottom in order to see the full definition of the above method)
</code></pre>

<p>6) What you have now is the encrypted data as a base64 string, which you are still not ready to pass to your decrypt method, as you need to decode it from base64 and convert it to bytes array, which can be done directly using the Convert.FromBase64String method (at least mine is taking a byte array as a parameter) - it takes a string as a parameter and returns a byte array as a result: </p>

<pre><code>byte[] recv_textdata_encrypted_ready = new byte[lengthofblocksize]; //length of blocksize is 16 for rijndael as explained
recv_textdata_encrypted_ready = Convert.FromBase64String(recv_textdata);
</code></pre>

<p>7) NOW you are ready to pass your encrypted byte array for decryption: 
    string decrypted = DecryptStringFromBytes(recv_textdata_encrypted_ready, this.Encryption_key, this.Encryption_iv);</p>

<p>So, back to the definition of FormatAsBase64String and why you need it. As you pass the base64 encoded string through the UDP socket, the datagram is sent in chunks and might add unnecessary padding, which usually can only be seen by comparing the md5 hash of the data you send through the socket and the data you receive through the socket, or by writing it to a binary file (this is the way I used) and opening the result using text editor supporting UTF8 Encoding (or any other encoding you used in point 5) ). So if you do not use the method below, the data you SEND might not be the same as the data you RECEIVE, which will result in a string with unnecessary padding ineligible for decryption through the .NET decryption libraries as they will not recognise it, or what happened in my case, the Convert.FromBase64String method will not recognize it as a valid base64 encoded string and will spit out an error that the string contains an invalid padding and is not in a valid base64 encoded format. So, to validate your string as a valid base64 only so you do not have trouble while convert it to the normally binary encrypted bytes array, you may need something like this: </p>

<pre><code>    private static string FormatStringAsBase64(string message_encrypted_base64)
    {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; message_encrypted_base64.Length; i++)
        {
            //current char
            char currchar = message_encrypted_base64[i];

            //check if we got a valid base64 symbol
            /* From Microsoft MSDN Official Convert.ToBase64String Method (http://msdn.microsoft.com/en-us/library/dhx0d524.aspx):
             * The base-64 digits in ascending order from zero are the uppercase 
             * characters ""A"" to ""Z"", the lowercase characters ""a"" to ""z"", the numerals ""0"" 
             * to ""9"", and the symbols ""+"" and ""/"". 
             * The valueless character, ""="", 
             * is used for trailing padding.
             * 
             */
            if (char.IsLetterOrDigit(currchar) || currchar == '=' || currchar == '+' || currchar == '/')
            {
                sb.Append(currchar);
            }
        }
        return sb.ToString();
    }
</code></pre>

<p>I'm writing this for anyone trying to send an encrypted rijndael data through a UDP socket. I lost 3 days to figure this out myself (well, I may be looking like a moron for taking that long to figure this out but when you have a messed code with all the ways trying to figure out what's the issue that happens) after reading a whole bunch of threads with similar errors on stackoverflow. None of them had the exact same issue nor a solution to it. So if you are trying to <strong>send encrypted data through a UDP socket</strong> and geting an error like <strong>Invalid padding and padding cannot be removed</strong> or <strong>Length of data to decrypt is invalid</strong> this thread might come handy. </p>

<p>I believe this thread might help to many others who have come across the described problem and will save time to many users on this forum. If the mods do not believe or find the thread unnecessary or inappropriate you can get rid of it, I just decided to spare some of my time in order to describe the problem I met and how to resolve it as it may save plenty of time to others, believe me this was really getting me mad until I found a solution to what is obviously quite an easy to fix issue. </p>
","1786","<c#><.net><encryption><rijndael><system.security>","1","0","1","2013-10-11 19:45:13","","5","","2246344","","2013-10-06 14:35:28","2013-10-06 14:07:40",""
"8021475","Decrypt PHP AES/CBC encrypted string in JavaScript","<p>I'm getting literally crazy trying to decrypt in JavaScript a string encrypted in PHP with the following code snippet:</p>

<pre><code>function myencrypt($str) {
    $iv = '1234567890abcdef';
    $key = 'abcdef1234567890';

    $td = mcrypt_module_open('rijndael-128', '', 'cbc', $iv);
    mcrypt_generic_init($td, $key, $iv);
    $encrypted = mcrypt_generic($td, $str);

    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);

    return bin2hex($encrypted);
}
</code></pre>

<p>I've tried slowAES, gibberish-aes and some other available JS libraries, but always failed to correctly decrypt a single string.</p>

<p>I've also extensively searched in SO, but was unable to find a solution applicable to my situation.</p>

<p>Any pointer toward the right solution would be more than welcome!</p>

<p>Thanks,
Alessandro</p>
","<p>have you tried the <a href=""http://code.google.com/p/crypto-js/"" rel=""nofollow"">crypto-js library</a>? Sorry but i'm not sure what <code>mcrypt_module_open('rijndael-128'</code> does exactly but if it just uses CBC it should work</p>
","1780","<php><javascript><aes><mcrypt><rijndael>","1","0","1","2011-11-05 16:58:04","8021716","1","","","","","2011-11-05 16:22:18",""
"13649632","file encryption and decryption c# Rijndael cipher","<p>I can encrypt a text file that is located on my desktop using the following code.</p>

<pre><code> private void btnEncrypt_Click(object sender, EventArgs e)
    {
        //EncryptFile(); 
        try
        {
            OpenFileDialog dialog = new OpenFileDialog();
            dialog.Filter = ""All Files (*.*)|"";
            dialog.InitialDirectory = @""Desktop"";
            dialog.Title = ""Please select a file to encrypt."";

            dialog.ShowDialog();

            inputFile = dialog.FileName;

            outputFile = inputFile;

            string password = @""myKey123""; // Your Key Here
            UnicodeEncoding UE = new UnicodeEncoding();
            byte[] key = UE.GetBytes(password);

            string cryptFile = outputFile;
            FileStream fsCrypt = new FileStream(cryptFile, FileMode.Create);

            RijndaelManaged RMCrypto = new RijndaelManaged();

            CryptoStream cs = new CryptoStream(fsCrypt,
                RMCrypto.CreateEncryptor(key, key),
                CryptoStreamMode.Write);

            FileStream fsIn = new FileStream(inputFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

            int data;
            while ((data = fsIn.ReadByte()) != -1)
                cs.WriteByte((byte)data);


            fsIn.Close();
            cs.Close();
            fsCrypt.Close();
        }
        catch (Exception ex)
        {
            MessageBox.Show(ex.Message);
        }
</code></pre>

<p>this works great but when i try to decrypt the same text file nothing happens, no error message is thrown to let me know what is going on, i use the following code for decryption</p>

<pre><code>private void btnDecrypt_Click(object sender, EventArgs e)
    {
        try
        {
            OpenFileDialog dialog = new OpenFileDialog();
            dialog.Filter = ""All Files (*.*)|"";
            dialog.InitialDirectory = @""Desktop"";
            dialog.Title = ""Please select a file to decrypt."";

            dialog.ShowDialog();

            inputFile = dialog.FileName; // ""C:\\Users\\daniel\\Desktop\\text.txt"";
            outputFile = inputFile;


                string password = @""myKey123""; // Your Key Here

                UnicodeEncoding UE = new UnicodeEncoding();
                byte[] key = UE.GetBytes(password);

                FileStream fsCrypt = new FileStream(inputFile, FileMode.Open);

                RijndaelManaged RMCrypto = new RijndaelManaged();

                CryptoStream cs = new CryptoStream(fsCrypt,
                    RMCrypto.CreateDecryptor(key, key),
                    CryptoStreamMode.Read);

                FileStream fsOut = new FileStream(outputFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

                int data;
                while ((data = cs.ReadByte()) != -1)
                    fsOut.WriteByte((byte)data);

                fsOut.Close();
                cs.Close();
                fsCrypt.Close();

            }
        catch(Exception ex)
        {
            MessageBox.Show(ex.Message);
        }

        }
    }
</code></pre>

<p>can anybody help?</p>
","<p><code>fsOut</code> is open as a read-only stream.  Try this instead.</p>

<pre><code> FileStream fsOut = new FileStream(
       outputFile, 
       FileMode.Open, 
       FileAccess.Write, 
       FileShare.ReadWrite);
</code></pre>

<p><em>Note</em>:  I would also write to a temp file and copy over the original when completed but I don't have a <em>great</em> reason for it.</p>
","1760","<c#><visual-studio-2010><encryption><rijndael>","1","0","1","2012-11-30 17:09:25","","4","","265419","","2012-11-30 17:00:01","2012-11-30 16:58:34",""
"20567056","Rijndael Encryption/Decryption C# vs PHP","<p>I'm trying to encrypt data on client side(C#) then transmit it to the server through POST and decode it at the server side(PHP).</p>

<p>For this test purpose I'm also attaching to the POST all values were used on the client side to match it for the server
Values are:</p>

<ul>
<li>Plain Text</li>
<li>Pass Phrase</li>
<li>IV</li>
<li>Generated By Client Encrypted Text</li>
</ul>

<p>These parameters im re-using at the server side, it is mean i'm using the same plain text, the same pass phrase and the same IV 
however results doesn't match</p>

<p>Encrypted text at the client side doesn't match to the encrypted text from server side where both of them were generated from the same input parameters</p>

<p>Here is Console output where you can clearly see what is going on:
<a href=""https://dl.dropboxusercontent.com/u/15715229/ConsoleOutput.JPG"" rel=""nofollow"">https://dl.dropboxusercontent.com/u/15715229/ConsoleOutput.JPG</a></p>

<p>As You see server generate different hash with use of same ""in"" parameters...</p>

<p>What am I doing wrong?</p>

<p>here is my code:</p>

<p><strong>C# Code:</strong></p>

<pre><code>static void Main(string[] args)
    {
        string url = ""http://localhost/temp.php"";
        WebClient web = new WebClient();

        string plainText = ""This is sentence I want to encrypt"";
        string passPhrase = ""MyPassPhrase"";
        string IV = DateTime.Now.ToLongTimeString() + ""InVector"";

        Console.WriteLine("""");
        Console.WriteLine(""----- Start Client -----"");
        Console.WriteLine(""Plain text = "" + plainText);
        Console.WriteLine(""PassPhrase = "" + passPhrase);
        Console.WriteLine(""IV = "" + IV);

        string encryptedText = Encrypt(plainText, passPhrase, IV);
        Console.WriteLine(""Encrypted Text = "" + encryptedText);

        string decryptedText = Decrypt(encryptedText, passPhrase, IV);
        Console.WriteLine(""Decrypted Text = "" + decryptedText);
        Console.WriteLine(""----- End Client -----"");
        Console.WriteLine("""");

        NameValueCollection postData = new NameValueCollection();
        postData.Add(""plainText"", plainText);
        postData.Add(""encryptedText"", encryptedText);
        postData.Add(""passPhrase"", passPhrase);
        postData.Add(""IV"", IV);

        string webData = Encoding.UTF8.GetString(web.UploadValues(url, ""POST"", postData));
        Console.WriteLine(""----- Start Server Respond -----"");
        Console.WriteLine(webData);
        Console.WriteLine(""----- End Server Respond -----"");
    }

    public static string Encrypt(string plainText, string passPhrase, string IV)
    {
        byte[] initVectorBytes = Encoding.UTF8.GetBytes(IV);
        byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);
        byte[] keyBytes = Encoding.UTF8.GetBytes(passPhrase);

        RijndaelManaged symmetricKey = new RijndaelManaged();
        symmetricKey.Mode = CipherMode.CBC;

        ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes);

        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
        cryptoStream.FlushFinalBlock();

        byte[] cipherTextBytes = memoryStream.ToArray();
            memoryStream.Close();
            cryptoStream.Close();

        return Convert.ToBase64String(cipherTextBytes);
    }

    public static string Decrypt(string cipherText, string passPhrase, string IV)
    {
        byte[] initVectorBytes = Encoding.UTF8.GetBytes(IV);
        byte[] cipherTextBytes = Convert.FromBase64String(cipherText);
        byte[] keyBytes = Encoding.UTF8.GetBytes(passPhrase);

        RijndaelManaged symmetricKey = new RijndaelManaged();
        symmetricKey.Mode = CipherMode.CBC;

        ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);

        MemoryStream memoryStream = new MemoryStream(cipherTextBytes);
        CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);

        byte[] plainTextBytes = new byte[cipherTextBytes.Length];
        int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
            memoryStream.Close();
            cryptoStream.Close();

        return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
    }
</code></pre>

<p><strong>My PHP Code:</strong></p>

<pre><code>&lt;?php

if(isset($_POST['plainText']))
{
    $plainText = $_POST['plainText'];
    $clientEncryptedText = $_POST['encryptedText'];
    $passPhrase = $_POST['passPhrase'];
    $iv = $_POST['IV'];

    echo ""Plain text = "".$plainText.""\n"";
    echo ""PassPhrase = "".$passPhrase.""\n"";
    echo ""IV = "".$iv.""\n"";

    $encryptedText = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $passPhrase, $plainText, MCRYPT_MODE_CBC, $iv ));
    echo ""Server Encrypted Text = "".$encryptedText.""\n"";
    echo ""Client Encrypted Text = "".$clientEncryptedText.""\n"";

    $decryptedText = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $passPhrase, base64_decode($encryptedText), MCRYPT_MODE_CBC, $iv );
    echo ""Server Decrypted Text = "".$decryptedText.""\n"";

    $decryptedText = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $passPhrase, base64_decode($clientEncryptedText), MCRYPT_MODE_CBC, $iv );
    echo ""Decrypted text from Client = "".$decryptedText.""\n"";

}
else
{
    echo ""POST is not set"";
}
</code></pre>

<p>Can you please tell me what am i doing wrong and where? at the client (C#) or at the server (PHP)?</p>

<p><strong>Regards</strong>
Vadims Briksins</p>
","<p>Your Passphrase is not a key of the appropriate length. Same goes for the IV. Thus, some kind of padding, truncation or hashing will happen. PHP and C# likely do it differently. Also, you don't specify if AES-128 or AES-256 is to be used in C# - thus, you are likely using AES-256 in C#, while decrypting with AES-128. Also C# could, theoretically, also use different block sizes (it likely doesn't). Padding could also differ, which could cause issues later down the road.</p>

<p>Make sure your IV matches the block size used (should be 128 bit = 16 byte) and the passphrase/key matches whatever key size you chose.</p>

<p>If you will be using real passphrases in practice, you need to use something like PBKDF2 to derive keys from them.</p>

<p>You also may want to add integrity checking (e.g. using HMAC with a <em>separate</em> key).</p>

<p>Also, don't implement crypto yourself if you don't have to. Check if SSL/TLS could fix the problem for you, and then use it if possible. You can use hardcoded selfsigned certificates if you want to and it matches your requirements, but using an existing crypto protocol is usually a better idea than building your own.</p>
","1760","<c#><php><encryption><rijndael>","0","1","2","2013-12-13 21:17:46","20576173","4","","","","","2013-12-13 12:54:25",""
"20567056","Rijndael Encryption/Decryption C# vs PHP","<p>I'm trying to encrypt data on client side(C#) then transmit it to the server through POST and decode it at the server side(PHP).</p>

<p>For this test purpose I'm also attaching to the POST all values were used on the client side to match it for the server
Values are:</p>

<ul>
<li>Plain Text</li>
<li>Pass Phrase</li>
<li>IV</li>
<li>Generated By Client Encrypted Text</li>
</ul>

<p>These parameters im re-using at the server side, it is mean i'm using the same plain text, the same pass phrase and the same IV 
however results doesn't match</p>

<p>Encrypted text at the client side doesn't match to the encrypted text from server side where both of them were generated from the same input parameters</p>

<p>Here is Console output where you can clearly see what is going on:
<a href=""https://dl.dropboxusercontent.com/u/15715229/ConsoleOutput.JPG"" rel=""nofollow"">https://dl.dropboxusercontent.com/u/15715229/ConsoleOutput.JPG</a></p>

<p>As You see server generate different hash with use of same ""in"" parameters...</p>

<p>What am I doing wrong?</p>

<p>here is my code:</p>

<p><strong>C# Code:</strong></p>

<pre><code>static void Main(string[] args)
    {
        string url = ""http://localhost/temp.php"";
        WebClient web = new WebClient();

        string plainText = ""This is sentence I want to encrypt"";
        string passPhrase = ""MyPassPhrase"";
        string IV = DateTime.Now.ToLongTimeString() + ""InVector"";

        Console.WriteLine("""");
        Console.WriteLine(""----- Start Client -----"");
        Console.WriteLine(""Plain text = "" + plainText);
        Console.WriteLine(""PassPhrase = "" + passPhrase);
        Console.WriteLine(""IV = "" + IV);

        string encryptedText = Encrypt(plainText, passPhrase, IV);
        Console.WriteLine(""Encrypted Text = "" + encryptedText);

        string decryptedText = Decrypt(encryptedText, passPhrase, IV);
        Console.WriteLine(""Decrypted Text = "" + decryptedText);
        Console.WriteLine(""----- End Client -----"");
        Console.WriteLine("""");

        NameValueCollection postData = new NameValueCollection();
        postData.Add(""plainText"", plainText);
        postData.Add(""encryptedText"", encryptedText);
        postData.Add(""passPhrase"", passPhrase);
        postData.Add(""IV"", IV);

        string webData = Encoding.UTF8.GetString(web.UploadValues(url, ""POST"", postData));
        Console.WriteLine(""----- Start Server Respond -----"");
        Console.WriteLine(webData);
        Console.WriteLine(""----- End Server Respond -----"");
    }

    public static string Encrypt(string plainText, string passPhrase, string IV)
    {
        byte[] initVectorBytes = Encoding.UTF8.GetBytes(IV);
        byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);
        byte[] keyBytes = Encoding.UTF8.GetBytes(passPhrase);

        RijndaelManaged symmetricKey = new RijndaelManaged();
        symmetricKey.Mode = CipherMode.CBC;

        ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes);

        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
        cryptoStream.FlushFinalBlock();

        byte[] cipherTextBytes = memoryStream.ToArray();
            memoryStream.Close();
            cryptoStream.Close();

        return Convert.ToBase64String(cipherTextBytes);
    }

    public static string Decrypt(string cipherText, string passPhrase, string IV)
    {
        byte[] initVectorBytes = Encoding.UTF8.GetBytes(IV);
        byte[] cipherTextBytes = Convert.FromBase64String(cipherText);
        byte[] keyBytes = Encoding.UTF8.GetBytes(passPhrase);

        RijndaelManaged symmetricKey = new RijndaelManaged();
        symmetricKey.Mode = CipherMode.CBC;

        ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);

        MemoryStream memoryStream = new MemoryStream(cipherTextBytes);
        CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);

        byte[] plainTextBytes = new byte[cipherTextBytes.Length];
        int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
            memoryStream.Close();
            cryptoStream.Close();

        return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
    }
</code></pre>

<p><strong>My PHP Code:</strong></p>

<pre><code>&lt;?php

if(isset($_POST['plainText']))
{
    $plainText = $_POST['plainText'];
    $clientEncryptedText = $_POST['encryptedText'];
    $passPhrase = $_POST['passPhrase'];
    $iv = $_POST['IV'];

    echo ""Plain text = "".$plainText.""\n"";
    echo ""PassPhrase = "".$passPhrase.""\n"";
    echo ""IV = "".$iv.""\n"";

    $encryptedText = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $passPhrase, $plainText, MCRYPT_MODE_CBC, $iv ));
    echo ""Server Encrypted Text = "".$encryptedText.""\n"";
    echo ""Client Encrypted Text = "".$clientEncryptedText.""\n"";

    $decryptedText = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $passPhrase, base64_decode($encryptedText), MCRYPT_MODE_CBC, $iv );
    echo ""Server Decrypted Text = "".$decryptedText.""\n"";

    $decryptedText = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $passPhrase, base64_decode($clientEncryptedText), MCRYPT_MODE_CBC, $iv );
    echo ""Decrypted text from Client = "".$decryptedText.""\n"";

}
else
{
    echo ""POST is not set"";
}
</code></pre>

<p>Can you please tell me what am i doing wrong and where? at the client (C#) or at the server (PHP)?</p>

<p><strong>Regards</strong>
Vadims Briksins</p>
","<p>finally got it sorted. Whole day was fighting with it and now would love to share the code with you.</p>

<p>Code is 100% working - Tested and Verified!</p>

<p><strong>Content of C# CryptoMaster.cs file (Client Side):</strong></p>

<pre><code>using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace EncryptionClient
{
    class CryptoMaster
    {
        private string encryptedText;

        public void StartEncryption()
        {
            Console.WriteLine("""");
            Console.WriteLine(""----- Client Start -----"");
            string plainText = ""Hello, this is a message we need to encrypt"";
            Console.WriteLine(""Plain Text = "" + plainText);
            string passPhrase =""Pass Phrase Can be any length"";
            string saltValue = DateTime.Now.ToLongTimeString(); //slat should be 8 bite len, in my case im using Time HH:MM:SS as it is dynamic value
            string hashAlgorithm = ""SHA1"";
            int passwordIterations = 1;
            string initVector = ""InitVector Should be 32 bite len"";
            int keySize = 256;

            encryptedText = Encrypt(plainText, passPhrase, saltValue, hashAlgorithm, passwordIterations, initVector, keySize);
            Console.WriteLine(""Encrypted Text = "" + encryptedText);

            string decryptedText = Decrypt(encryptedText, passPhrase, saltValue, hashAlgorithm, passwordIterations, initVector, keySize);
            Console.WriteLine(""Decripted Text = "" + decryptedText);
            Console.WriteLine(""----- Client End -----"");

            SendDataToWebServer(plainText, passPhrase, saltValue, hashAlgorithm, passwordIterations, initVector, keySize);
        }

        private void SendDataToWebServer(string plainText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize)
        {

            NameValueCollection POST = new NameValueCollection();
            //NOTE: I'm Including all this data to POST only for TESTING PURPOSE 
            //and to avoid manual entering of the same data at server side.
            //In real live example you have to keep sensative data hidden
            POST.Add(""plainText"", plainText);
            POST.Add(""passPhrase"", passPhrase);
            POST.Add(""saltValue"", saltValue);
            POST.Add(""hashAlgorithm"", hashAlgorithm);
            POST.Add(""passwordIterations"", passwordIterations+"""");
            POST.Add(""initVector"", initVector);
            POST.Add(""keySize"", keySize+"""");
            POST.Add(""encryptedText"", encryptedText);


            WebClient web = new WebClient();
            string URL = ""http://localhost/Encryptor.php"";
            Console.WriteLine("""");
            string serverRespond = Encoding.UTF8.GetString(web.UploadValues(URL, ""POST"", POST));
            Console.WriteLine(""----- Server Start -----"");
            Console.WriteLine(serverRespond);
            Console.WriteLine(""----- Server End -----"");

        }

        public string Encrypt(string plainText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize)
        {

            byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
            byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);
            byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);

            Rfc2898DeriveBytes password = new Rfc2898DeriveBytes(passPhrase, saltValueBytes, passwordIterations);

            byte[] keyBytes = password.GetBytes(keySize / 8);

            RijndaelManaged symmetricKey = new RijndaelManaged();
            symmetricKey.BlockSize = 256;
            symmetricKey.KeySize = 256;
            symmetricKey.Padding = PaddingMode.Zeros;
            symmetricKey.Mode = CipherMode.CBC;

            ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes);

            MemoryStream memoryStream = new MemoryStream();
            CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

            cryptoStream.FlushFinalBlock();
            byte[] cipherTextBytes = memoryStream.ToArray();

            memoryStream.Close();
            cryptoStream.Close();

            string cipherText = Convert.ToBase64String(cipherTextBytes);

            return cipherText;
        }

        public static string Decrypt(string cipherText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize)
        {

            byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
            byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);
            byte[] cipherTextBytes = Convert.FromBase64String(cipherText);

            Rfc2898DeriveBytes password = new Rfc2898DeriveBytes(passPhrase, saltValueBytes, passwordIterations);

            byte[] keyBytes = password.GetBytes(keySize / 8);

            RijndaelManaged symmetricKey = new RijndaelManaged();
            symmetricKey.BlockSize = 256;
            symmetricKey.KeySize = 256;
            symmetricKey.Padding = PaddingMode.Zeros;
            symmetricKey.Mode = CipherMode.CBC;

            ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);

            MemoryStream memoryStream = new MemoryStream(cipherTextBytes);

            CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);

            byte[] plainTextBytes = new byte[cipherTextBytes.Length];

            int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);

            memoryStream.Close();
            cryptoStream.Close();

            string plainText = Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);

            return plainText;
        }
    }
}
</code></pre>

<p><strong>Content of PHP Encryptor.PHP file (Server Side):</strong></p>

<pre><code>&lt;?php
error_reporting(0);


if (isset($_POST['plainText'])) {

    $plainText = $_POST['plainText'];
    $passPhrase = $_POST['passPhrase'];
    $saltValue = $_POST['saltValue'];
    $hashAlgorithm = $_POST['hashAlgorithm'];
    $passwordIterations = $_POST['passwordIterations'];
    $initVector = $_POST['initVector'];
    $keySize = $_POST['keySize'];
    $clientEncryptedText = $_POST['encryptedText'];

    $key = getKey($passPhrase,$saltValue, $passwordIterations, $keySize, $hashAlgorithm);

    echo ""Plain Text = "".$plainText.""\n"";
    echo ""Client Encrypted Text = "".$clientEncryptedText.""\n"";

    $encryptedText = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $plainText, MCRYPT_MODE_CBC, $initVector));
    echo ""Server Encrypted Text = "".$encryptedText.""\n"";

    $decryptedText = rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, base64_decode($encryptedText), MCRYPT_MODE_CBC, $initVector), ""\0"");
    echo ""Server Decrypted Text = "".$decryptedText.""\n"";

    $decryptedText = rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, base64_decode($clientEncryptedText), MCRYPT_MODE_CBC, $initVector), ""\0"");
    echo ""Client Decrypted Text = "".$decryptedText;

}

function getKey( $passPhrase, $saltValue, $passwordIterations, $keySize, $hashAlgorithm ) {

    $hl = strlen(hash($hashAlgorithm, null, true));
    $kb = ceil($keySize / $hl);
    $dk = '';

    for ( $block = 1; $block &lt;= $kb; $block ++ ) {

        $ib = $b = hash_hmac($hashAlgorithm, $saltValue . pack('N', $block), $passPhrase, true);

        for ( $i = 1; $i &lt; $passwordIterations; $i ++ )

            $ib ^= ($b = hash_hmac($hashAlgorithm, $b, $passPhrase, true));

        $dk .= $ib;
    }

    return substr($dk, 0, $keySize);
}

?&gt;
</code></pre>

<p>Console <a href=""https://dl.dropboxusercontent.com/u/15715229/CorrectConsoleOutput.JPG"" rel=""nofollow"">Output can be viewed by this link</a></p>
","1760","<c#><php><encryption><rijndael>","0","0","2","2013-12-13 21:17:46","20576173","4","","","","","2013-12-13 12:54:25",""
"36937917","Android: Unable to Decrypt Value","<p>Successfully get Right encrypted value but facing problem to decrypt that value(already encrypted).</p>

<p><strong>Value</strong>:   123456</p>

<p><strong>Encrpted</strong>:   ncSzDj4j8l44iM5qgaqHgA==</p>

<p>Why i got java.lang.Exception: [decrypt] Invalid int: ""Bo"" ?</p>

<p>Is there any solution / Suggestion it would be appreciated. Thanks  </p>

<p>MainActivity.java</p>

<pre><code>    import android.support.v7.app.AppCompatActivity;
    import android.os.Bundle;
    import android.util.Log;

    import java.net.URLDecoder;

    public class MainActivity extends AppCompatActivity {
        ApiCrypter3 apiCrypter;

    //123456
    //ncSzDj4j8l44iM5qgaqHgA==

      @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            apiCrypter = new ApiCrypter3();
            try {
                byte[] encryptedRequest = this.apiCrypter.encrypt(value);
                String EncryptStr = new String(encryptedRequest, ""UTF-8"");
                Log.e(""ENCRYPTION: "", EncryptStr.toString());

                String res = new String(this.apiCrypter.decrypt(EncryptStr), ""UTF-8"");
                res = URLDecoder.decode(res, ""UTF-8"");
                Log.e(""DECRYPTION: "", res.toString());

               } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>

<p>ApiCrypter3.java</p>

<pre><code>  package &lt;your package name&gt;;

    import android.util.Base64;
    import java.security.NoSuchAlgorithmException;
    import javax.crypto.Cipher;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    public class ApiCrypter3 {

    private byte[] sessionKey = {your 16 character key}; //Where you get this from is beyond the scope of this post
    private byte[] iv = {your 16 character value}; //Ditto
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    public ApiCrypter3()
    {
        ivspec = new IvParameterSpec(iv);
        keyspec = new SecretKeySpec(sessionKey, ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0) {
            throw new Exception(""Empty string"");
        }
        byte[] encrypted = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            encrypted =  Base64.encode(cipher.doFinal(text.getBytes(""UTF-8"")), Base64.DEFAULT);
        }
        catch (Exception e) {
            throw new Exception(""[encrypt] "" + e.getMessage());
        }
        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0) {
            throw new Exception(""Empty string"");
        }
        byte[] decrypted = null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
            //decrypted = Base64.decode(cipher.doFinal(code.getBytes()),Base64.DEFAULT);
            decrypted = Base64.decode(cipher.doFinal(hexToBytes(code)),Base64.DEFAULT);
        }
        catch (Exception e) {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }

    public static String bytesToHex(byte[] data) {
        if (data==null) {
            return null;
        }
        int len = data.length;
        String str = """";
        for (int i=0; i&lt;len; i++) {
            if ((data[i]&amp;0xFF)&lt;16) {
                str = str + ""0"" + Integer.toHexString(data[i]&amp;0xFF);
            }
            else {
                str = str + Integer.toHexString(data[i]&amp;0xFF);
            }
        }
        return str;
    }

    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        }
        else if (str.length() &lt; 2) {
            return null;
        }
        else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i&lt;len; i++) {
                //No effect
                //buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
                buffer[i]=Integer.valueOf(str.substring(i*2,i*2+2),16).byteValue();
                }
            return buffer;
        }
    }
}
</code></pre>

<p>Logs:</p>

<pre><code>04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption E/ENCRYPTION:: ncSzDj4j8l44iM5qgaqHgA==
04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption W/System.err: java.lang.Exception: [decrypt] Invalid int: ""nc""
04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption W/System.err:     at com.test.com.encrytiondecryption.ApiCrypter3.decrypt(ApiCrypter3.java:64)
04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption W/System.err:     at com.test.com.encrytiondecryption.MainActivity.onCreate(MainActivity.java:41)
</code></pre>
","<p>It looks like the exception is being thrown by this line in your <code>hexToBytes</code> function, and then caught and rethrown in <code>decrypt</code>:</p>

<pre><code>buffer[i]=Integer.valueOf(str.substring(i*2,i*2+2),16).byteValue();
</code></pre>

<p>The problem is that the string you are passing in to the hexToBytes function is Base64 encoded, it's not a hex string, so reading the first two characters as an integer causes an exception.</p>

<p>Change the line in decrypt to this:</p>

<pre><code>decrypted = cipher.doFinal(Base64.decode(code,Base64.DEFAULT)); 
</code></pre>

<p>When you encrypt you are encrypting and then Base64 encoding, so when you decrypt you should do it in the reverse order: Base64 decode then decrypt.</p>
","1746","<java><android><encryption><rijndael>","1","1","2","2016-04-29 13:58:35","36938197","1","3","1969537","","2016-04-29 13:58:35","2016-04-29 12:03:52",""
"36937917","Android: Unable to Decrypt Value","<p>Successfully get Right encrypted value but facing problem to decrypt that value(already encrypted).</p>

<p><strong>Value</strong>:   123456</p>

<p><strong>Encrpted</strong>:   ncSzDj4j8l44iM5qgaqHgA==</p>

<p>Why i got java.lang.Exception: [decrypt] Invalid int: ""Bo"" ?</p>

<p>Is there any solution / Suggestion it would be appreciated. Thanks  </p>

<p>MainActivity.java</p>

<pre><code>    import android.support.v7.app.AppCompatActivity;
    import android.os.Bundle;
    import android.util.Log;

    import java.net.URLDecoder;

    public class MainActivity extends AppCompatActivity {
        ApiCrypter3 apiCrypter;

    //123456
    //ncSzDj4j8l44iM5qgaqHgA==

      @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            apiCrypter = new ApiCrypter3();
            try {
                byte[] encryptedRequest = this.apiCrypter.encrypt(value);
                String EncryptStr = new String(encryptedRequest, ""UTF-8"");
                Log.e(""ENCRYPTION: "", EncryptStr.toString());

                String res = new String(this.apiCrypter.decrypt(EncryptStr), ""UTF-8"");
                res = URLDecoder.decode(res, ""UTF-8"");
                Log.e(""DECRYPTION: "", res.toString());

               } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>

<p>ApiCrypter3.java</p>

<pre><code>  package &lt;your package name&gt;;

    import android.util.Base64;
    import java.security.NoSuchAlgorithmException;
    import javax.crypto.Cipher;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    public class ApiCrypter3 {

    private byte[] sessionKey = {your 16 character key}; //Where you get this from is beyond the scope of this post
    private byte[] iv = {your 16 character value}; //Ditto
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    public ApiCrypter3()
    {
        ivspec = new IvParameterSpec(iv);
        keyspec = new SecretKeySpec(sessionKey, ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0) {
            throw new Exception(""Empty string"");
        }
        byte[] encrypted = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            encrypted =  Base64.encode(cipher.doFinal(text.getBytes(""UTF-8"")), Base64.DEFAULT);
        }
        catch (Exception e) {
            throw new Exception(""[encrypt] "" + e.getMessage());
        }
        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0) {
            throw new Exception(""Empty string"");
        }
        byte[] decrypted = null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
            //decrypted = Base64.decode(cipher.doFinal(code.getBytes()),Base64.DEFAULT);
            decrypted = Base64.decode(cipher.doFinal(hexToBytes(code)),Base64.DEFAULT);
        }
        catch (Exception e) {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }

    public static String bytesToHex(byte[] data) {
        if (data==null) {
            return null;
        }
        int len = data.length;
        String str = """";
        for (int i=0; i&lt;len; i++) {
            if ((data[i]&amp;0xFF)&lt;16) {
                str = str + ""0"" + Integer.toHexString(data[i]&amp;0xFF);
            }
            else {
                str = str + Integer.toHexString(data[i]&amp;0xFF);
            }
        }
        return str;
    }

    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        }
        else if (str.length() &lt; 2) {
            return null;
        }
        else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i&lt;len; i++) {
                //No effect
                //buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
                buffer[i]=Integer.valueOf(str.substring(i*2,i*2+2),16).byteValue();
                }
            return buffer;
        }
    }
}
</code></pre>

<p>Logs:</p>

<pre><code>04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption E/ENCRYPTION:: ncSzDj4j8l44iM5qgaqHgA==
04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption W/System.err: java.lang.Exception: [decrypt] Invalid int: ""nc""
04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption W/System.err:     at com.test.com.encrytiondecryption.ApiCrypter3.decrypt(ApiCrypter3.java:64)
04-29 16:51:26.399 10918-10918/com.test.com.encrytiondecryption W/System.err:     at com.test.com.encrytiondecryption.MainActivity.onCreate(MainActivity.java:41)
</code></pre>
","<p>Do This simple way::</p>

<pre><code>package com.encrytiondecryption;

import android.util.Base64;

import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class ApiCrypter5 {
    byte[] sessionKey = {your 16 character key}; //Where you get this from is beyond the scope of this post
    private byte[] iv = {your 16 character value }; //Ditto
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    public ApiCrypter5() {
        ivspec = new IvParameterSpec(iv);
        keyspec = new SecretKeySpec(sessionKey, ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    public String encrytData(String text) throws Exception {

        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

        byte[] results = cipher.doFinal(text.getBytes());

        return Base64.encodeToString(results, Base64.NO_WRAP | Base64.DEFAULT);

    }


    public String decryptData(String text) throws Exception {
        byte[] encryted_bytes = Base64.decode(text, Base64.DEFAULT);

        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

        byte[] decrypted = cipher.doFinal(encryted_bytes);

        return new String(decrypted);

    }

}
</code></pre>
","1746","<java><android><encryption><rijndael>","1","2","2","2016-04-29 13:58:35","36938197","1","3","1969537","","2016-04-29 13:58:35","2016-04-29 12:03:52",""
"27334093","Decrypt MCRYPT_RIJNDAEL_256 with 32-byte initialization vectors with PyCrypto","<p>I have data that was encrypted in PHP as follows:</p>

<pre><code>mcrypt_encrypt(MCRYPT_RIJNDAEL_256, SECRET, $data, MCRYPT_MODE_CBC, $iv)
</code></pre>

<p>I need to decrypt this data in a Python 3 application. I am trying to use PyCrypto but I am open to other libraries. I expect the following to work:</p>

<pre><code>decryptor = AES.new(key, mode, IV=IV)
plain = decryptor.decrypt(ciphertext)
</code></pre>

<p>My initialization vector is 32 bytes, and the following exception is thrown:</p>

<pre><code>ValueError: IV must be 16 bytes long
</code></pre>

<p>How can I set PyCrypto to use a 32 byte initialization vector and 32 byte block size?
Alternatively, is there a different library that I can use to decrypt the data?</p>
","<p>Thanks to the comments I implemented a suitable solution. I modified <code>rijndael.py</code> in the linked duplicate question to accept bytes rather than strings. I then use it as follows to decrypt 32-byte blocks with the 32-byte initialization vectors.</p>

<pre><code>from rijndael import rijndael

iv = b'myInitializationVectorfoobarfoob'
key = b'myKeyfoobarfoobarfoobarfoobarfoo'
text = b'myCipherTextFoobarfoobarfoobarfo'

r = rijndael(key, block_size=32)
plaintext = r.decrypt(text)
l = ''.join([chr(a ^ b) for a, b in zip(plaintext.encode('latin-1'), iv)])
print(l)
</code></pre>

<p>Note that using this rather than PyCrypto is only necessary because libmcrypt incorrectly sets the data block sizes, and thus the initialization vector sizes, to be equal to the key sizes. As far as I understand, data block sizes should always be 128 bits for AES-Rijndael.</p>
","1738","<python-3.x><aes><pycrypto><rijndael><cbc-mode>","3","0","1","2014-12-07 03:15:27","","4","","","","","2014-12-06 16:59:12",""
"20290310","Android Rijndael-256 not working","<p>I've got this code to decrypt a php (mcrypt) token.</p>

<p>The problem is, that the decode method always uses Rijndael-128 not -256. When I encode on the php side with -128, I can decode in Android. When using 256 its not working. (getHash returns a SHA-256 hashed key):</p>

<pre><code>    String key = ""987654321"";
    SecretKeySpec keyspec = new SecretKeySpec(getHash(key), ""AES"");
    Cipher cipherDecode = Cipher.getInstance(""AES/ECB/ZeroBytePadding"");
    byte[] text = Base64.decode(
            ""wdRe00YxTFGQ65QmWukPxFLlZRSPqmRY8tHufikBHW0="",
            Base64.DEFAULT);
    cipherDecode.init(Cipher.DECRYPT_MODE, keyspec);

    final byte[] decrypted = cipherDecode.doFinal(text);

    String decyptedText = new String(decrypted);
</code></pre>

<p>This should give the Text 'wdRe00YxTFGQ65QmWukPxFLlZRSPqmRY8tHufikBHW0=', but it doesn't.</p>

<p>How can I specifiy or force the correct code to be used?</p>
","<p>Your issue is (probably) that you are using <code>MCRYPT_RIJNDAEL_256</code>. This is not equal to AES-256. <code>MCRYPT_RIJNDAEL_256</code> specifies a <strong>block size</strong> for the Rijndael cipher of 256 bits. AES-256 on the other hand specifies a <strong>key size</strong> for the AES cipher of 256 bits. Rijndael with a block size of 128 bits was accepted by NIST to be the AES algorithm.</p>

<p>Probably it is best to keep to <code>MCRYPT_RIJNDAEL_128</code> as <code>MCRYPT_RIJNDAEL_256</code> does not specify a standardized cipher. You can still use AES-128, AES-192 or AES-256 by using 16, 24 or 32 keys (respectively). Be warned that PHP mcrypt does allow other key sizes (by adding zero valued bytes) and does not use any form of standardized padding. <code>""ZeroBytePadding""</code> is not compatible with PHP, as it adds a block of zero's if the plaintext is a multiple of the block size. PHP however does not add a block of zero's in that case.</p>

<p>If you do want to keep to a block size of 256 (but why should you) check out <a href=""https://stackoverflow.com/questions/8083144/how-to-encrypt-or-decrypt-with-rijndael-and-a-block-size-of-256-bits"">this answer</a>.</p>
","1726","<android><encryption><rijndael>","0","1","2","2015-11-12 19:23:40","20295427","0","3","","","","2013-11-29 16:48:56",""
"20290310","Android Rijndael-256 not working","<p>I've got this code to decrypt a php (mcrypt) token.</p>

<p>The problem is, that the decode method always uses Rijndael-128 not -256. When I encode on the php side with -128, I can decode in Android. When using 256 its not working. (getHash returns a SHA-256 hashed key):</p>

<pre><code>    String key = ""987654321"";
    SecretKeySpec keyspec = new SecretKeySpec(getHash(key), ""AES"");
    Cipher cipherDecode = Cipher.getInstance(""AES/ECB/ZeroBytePadding"");
    byte[] text = Base64.decode(
            ""wdRe00YxTFGQ65QmWukPxFLlZRSPqmRY8tHufikBHW0="",
            Base64.DEFAULT);
    cipherDecode.init(Cipher.DECRYPT_MODE, keyspec);

    final byte[] decrypted = cipherDecode.doFinal(text);

    String decyptedText = new String(decrypted);
</code></pre>

<p>This should give the Text 'wdRe00YxTFGQ65QmWukPxFLlZRSPqmRY8tHufikBHW0=', but it doesn't.</p>

<p>How can I specifiy or force the correct code to be used?</p>
","<p>You may use JNCryptor:</p>

<pre><code>JNCryptor myJNCryptor=new AES256JNCryptor();
byte[] ciphertext=cryptor.encryptData(yourtext.getBytes(), KEY.toCharArray());
</code></pre>
","1726","<android><encryption><rijndael>","0","-1","2","2015-11-12 19:23:40","20295427","0","3","","","","2013-11-29 16:48:56",""
"8830070","Rijndael 256 on PHP encryption difficulties","<p>I have to pass a value and have it encrypted to the following spec:</p>

<p>""256-bit key length, 256-bit block length, 32-byte blocks, ECB mode, with
ASCII encoding (encrypted data is expected to be provided as a string
with each character having been converted to a 2-byte HEX value)""</p>

<p>However I must be missing something. This is for verification purposes with a webservice but I keep getting rejected due to a decryption failure.</p>

<p>Here's what I have:</p>

<pre><code>$key = '1324mykey';
$string = 'Ron Swanson';

// 1. Encrypt the string with the key using Rijndael 256 in ECB mode
$td = mcrypt_module_open('rijndael-256', '','ecb', '');
$iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
mcrypt_generic_init($td, $key, $iv);
$encrypted_string = mcrypt_generic($td, $string);

// 2. Base64 encode my string
$encrypted_string = base64_encode($encrypted_string);

// 3. Convert each character of encrypted_string to it's 2-byte HEX value 
$hex='';
for ($i=0; $i &lt; strlen($encrypted_string); $i++)
{
    $hex .= dechex(ord($encrypted_string[$i]));
}

// Now $encrypted_string should match up with the recipe, but it isn't. 
$encrypted_string = $hex;
</code></pre>

<p>I'm hoping there's something basic in the encryption requirements that I'm missing in my step 1 of my process.</p>
","<p>If your requirement is a 256-bit key, shouldn't your <code>$key</code> variable be 32 bytes? (in other words, 32 characters long) ?</p>
","1659","<php><encryption><rijndael>","1","2","2","2012-01-12 15:17:54","","0","","","","","2012-01-12 04:19:10",""
"8830070","Rijndael 256 on PHP encryption difficulties","<p>I have to pass a value and have it encrypted to the following spec:</p>

<p>""256-bit key length, 256-bit block length, 32-byte blocks, ECB mode, with
ASCII encoding (encrypted data is expected to be provided as a string
with each character having been converted to a 2-byte HEX value)""</p>

<p>However I must be missing something. This is for verification purposes with a webservice but I keep getting rejected due to a decryption failure.</p>

<p>Here's what I have:</p>

<pre><code>$key = '1324mykey';
$string = 'Ron Swanson';

// 1. Encrypt the string with the key using Rijndael 256 in ECB mode
$td = mcrypt_module_open('rijndael-256', '','ecb', '');
$iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
mcrypt_generic_init($td, $key, $iv);
$encrypted_string = mcrypt_generic($td, $string);

// 2. Base64 encode my string
$encrypted_string = base64_encode($encrypted_string);

// 3. Convert each character of encrypted_string to it's 2-byte HEX value 
$hex='';
for ($i=0; $i &lt; strlen($encrypted_string); $i++)
{
    $hex .= dechex(ord($encrypted_string[$i]));
}

// Now $encrypted_string should match up with the recipe, but it isn't. 
$encrypted_string = $hex;
</code></pre>

<p>I'm hoping there's something basic in the encryption requirements that I'm missing in my step 1 of my process.</p>
","<p>This has been solved... (un?)fortunately I was simply given a wrong parameter.</p>
","1659","<php><encryption><rijndael>","1","1","2","2012-01-12 15:17:54","","0","","","","","2012-01-12 04:19:10",""
"14280207","Padding is invalid and cannot be removed with Rijndael decryption","<p>I am seeing the ""Padding is invalid and cannot be removed"" error when I call the method below to decrypt the string from a windows application.  String was encrypted from an asp.net application.  Both application references the same assembly.  I am able encrypt and decrypt with out any problem from the asp.net application.  Here is the main code where I do the encryption and decryption.</p>

<pre><code>    private static byte[] EncryptHelper(byte[] arrData, string Password, bool Encrypt)
    {
        //Create the SymetricAlgorithem object
        SymmetricAlgorithm myAlg = new RijndaelManaged();

        //define a salt value to derive the key.
        byte[] salt = System.Text.Encoding.ASCII.GetBytes(""hjkhj877ffasah"");

        //Instantiate Rfc2898DeriveBytes with the password and salt.
        Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(Password, salt);


        myAlg.Key = key.GetBytes(myAlg.KeySize / 8); 
        myAlg.IV = key.GetBytes(myAlg.BlockSize / 8); 
        myAlg.Padding = PaddingMode.PKCS7;
        //Create the ICryptoTransform Object
        ICryptoTransform encrytptor = Encrypt ? myAlg.CreateEncryptor() : myAlg.CreateDecryptor();

        //Create Memorystream to write the encrypted data
        using (MemoryStream aStream = new MemoryStream())
        {

            //Create the CryptoStream Ojbect using the aStream object
            using (CryptoStream encryptStream = new CryptoStream(aStream, encrytptor, CryptoStreamMode.Write))
            {
                //Write the contents to crypto stream
                encryptStream.Write(arrData, 0, arrData.Length);

                //Flush the cryptostream
                encryptStream.FlushFinalBlock();

                //Reposition the memorystream to write the contents to an array.
                aStream.Position = 0;

            }
            aStream.Flush();
            //Convert to an array and return
            return aStream.ToArray();

        }
    }
</code></pre>

<p>This is the method I use to convert the plain text from/to byte array</p>

<pre><code>    private static byte[] GetBytes(string str)
    {
        byte[] bytes = new byte[str.Length * sizeof(char)];
        System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
        return bytes;
    }

    private static string GetString(byte[] bytes)
    {
        char[] chars = new char[bytes.Length / sizeof(char)];
        System.Buffer.BlockCopy(bytes, 0, chars, 0, bytes.Length);
        return new string(chars);
    }
</code></pre>

<p>For persist the cipher text to database I use Convert.ToBase64String() and Convert.FromBase64String.  Is the problem is with the way I use Rfc2898DeriveBytes class?</p>
","<p>Well I think it's important to mention that from a security perspective, you are going to have the same IV for every message with the same password, and a predictable IV is a really <strong>big no no</strong>.  </p>

<p>After that point I kinda don't want to look at it more to see what's going wrong, there are a lot of really bad cut and paste C# encryption on stackoverflow, and they just sit there with no mechanism for update, no one looking at them again except for people finding them to cut and paste again. </p>

<p>Look at <a href=""https://stackoverflow.com/a/10366194/637783"">Modern Examples of Symmetric Authenticated Encryption of a string. c#</a>.</p>

<p>I try to keep it up to date and reviewed.</p>
","1649","<encryption><rijndael>","1","2","1","2013-01-11 15:43:28","","1","","","","","2013-01-11 14:28:36",""
"11334399","Rijndael Encryption issues","<p>I don't know what I'm doing wrong but I've been trying to get this thing working for about 4 hours now and I just can't get it to work... this just gives me the error: ""Please suppy a correct password"" when I try to decrypt.
Encryption seems to work fine though.</p>

<p>Any suggestions? :&lt;</p>

<pre><code>using System;
using System.Text;
using System.Security.Cryptography;
using System.IO;
using System.Security;
using AesApp.Rijndael;
using System.Linq;

    internal class FileEncryption
        {
            private static string password = pw;

            internal static void Encrypt(string inputfile, string outputfile)
            {
                byte[] encryptedPassword;

                // Create a new instance of the RijndaelManaged
                // class.  This generates a new key and initialization
                // vector (IV).
                using (var algorithm = new RijndaelManaged())
                {
                    algorithm.KeySize = 256;
                    algorithm.BlockSize = 128;

                    // Encrypt the string to an array of bytes.
                    encryptedPassword = Cryptology.EncryptStringToBytes(
                        password, algorithm.Key, algorithm.IV);
                }

                string chars = encryptedPassword.Aggregate(string.Empty, (current, b) =&gt; current + b.ToString());
                Cryptology.EncryptFile(@inputfile, @outputfile, chars);
            }

            internal static void Decrypt(string @inputfile, string @outputfile)
            {
                byte[] encryptedPassword;

                // Create a new instance of the RijndaelManaged
                // class.  This generates a new key and initialization
                // vector (IV).
                using (var algorithm = new RijndaelManaged())
                {
                    algorithm.KeySize = 256;
                    algorithm.BlockSize = 128;

                    // Encrypt the string to an array of bytes.
                    encryptedPassword = Cryptology.EncryptStringToBytes(
                        password, algorithm.Key, algorithm.IV);
                }

                string chars = encryptedPassword.Aggregate(string.Empty, (current, b) =&gt; current + b.ToString());
                Cryptology.DecryptFile(@inputfile, @outputfile, chars);
            }
        }
</code></pre>

<p>Reindael.cs</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

    namespace AesApp.Rijndael
    {
        internal sealed class Cryptology
        {
            private const string Salt = ""d5fg4df5sg4ds5fg45sdfg4"";
            private const int SizeOfBuffer = 1024 * 8;

            internal static byte[] EncryptStringToBytes(string plainText, byte[] key, byte[] iv)
            {
                // Check arguments.
                if (plainText == null || plainText.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""plainText"");
                }
                if (key == null || key.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""key"");
                }
                if (iv == null || iv.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""key"");
                }

                byte[] encrypted;
                // Create an RijndaelManaged object
                // with the specified key and IV.
                using (var rijAlg = new RijndaelManaged())
                {
                    rijAlg.Key = key;
                    rijAlg.IV = iv;

                    // Create a decrytor to perform the stream transform.
                    ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

                    // Create the streams used for encryption.
                    using (var msEncrypt = new MemoryStream())
                    {
                        using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                        {
                            using (var swEncrypt = new StreamWriter(csEncrypt))
                            {
                                //Write all data to the stream.
                                swEncrypt.Write(plainText);
                            }
                            encrypted = msEncrypt.ToArray();
                        }
                    }
                }


                // Return the encrypted bytes from the memory stream.
                return encrypted;

            }

            internal static string DecryptStringFromBytes(byte[] cipherText, byte[] key, byte[] iv)
            {
                // Check arguments.
                if (cipherText == null || cipherText.Length &lt;= 0)
                    throw new ArgumentNullException(""cipherText"");
                if (key == null || key.Length &lt;= 0)
                    throw new ArgumentNullException(""key"");
                if (iv == null || iv.Length &lt;= 0)
                    throw new ArgumentNullException(""key"");

                // Declare the string used to hold
                // the decrypted text.
                string plaintext;

                // Create an RijndaelManaged object
                // with the specified key and IV.
                using (var rijAlg = new RijndaelManaged())
                {
                    rijAlg.Key = key;
                    rijAlg.IV = iv;

                    // Create a decrytor to perform the stream transform.
                    ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

                    // Create the streams used for decryption.
                    using (var msDecrypt = new MemoryStream(cipherText))
                    {
                        using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                        {
                            using (var srDecrypt = new StreamReader(csDecrypt))
                            {
                                // Read the decrypted bytes from the decrypting stream
                                // and place them in a string.
                                plaintext = srDecrypt.ReadToEnd();
                            }
                        }
                    }

                }
                return plaintext;
            }

            internal static void EncryptFile(string inputPath, string outputPath, string password)
            {
                var input = new FileStream(inputPath, FileMode.Open, FileAccess.Read);
                var output = new FileStream(outputPath, FileMode.OpenOrCreate, FileAccess.Write);

                // Essentially, if you want to use RijndaelManaged as AES you need to make sure that:
                // 1.The block size is set to 128 bits
                // 2.You are not using CFB mode, or if you are the feedback size is also 128 bits

                var algorithm = new RijndaelManaged { KeySize = 256, BlockSize = 128 };
                var key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(Salt));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                using (var encryptedStream = new CryptoStream(output, algorithm.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    CopyStream(input, encryptedStream);
                }
            }

            internal static void DecryptFile(string inputPath, string outputPath, string password)
            {
                var input = new FileStream(inputPath, FileMode.Open, FileAccess.Read);
                var output = new FileStream(outputPath, FileMode.OpenOrCreate, FileAccess.Write);

                // Essentially, if you want to use RijndaelManaged as AES you need to make sure that:
                // 1.The block size is set to 128 bits
                // 2.You are not using CFB mode, or if you are the feedback size is also 128 bits
                var algorithm = new RijndaelManaged { KeySize = 256, BlockSize = 128 };
                var key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(Salt));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                try
                {
                    using (var decryptedStream = new CryptoStream(output, algorithm.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        CopyStream(input, decryptedStream);
                    }
                }
                catch (CryptographicException)
                {
                    throw new InvalidDataException(""Please suppy a correct password"");
                }
                catch (Exception ex)
                {
                    throw new Exception(ex.Message);
                }
            }

            private static void CopyStream(Stream input, Stream output)
            {
                using (output)
                using (input)
                {
                    byte[] buffer = new byte[SizeOfBuffer];
                    int read;
                    while ((read = input.Read(buffer, 0, buffer.Length)) &gt; 0)
                    {
                        output.Write(buffer, 0, read);
                    }
                }
            }
        }
    }
</code></pre>
","<p>Not entirely sure, but I think I remember a time when 2 successive calls to encryption gave 2 different results.
Therefore, your two successive calls to EncryptStringToBytes may give 2 different passwords : one for encryption and one for decryption... and this cause the failure.</p>

<p>I am not sure these encryptions are necessary... if you have a password hardcoded, it is always possible to anyone to generate other strings that depend on nothing else. You should use this password directly, instead of crypting it a first time:</p>

<pre><code> internal static void Encrypt(string inputfile, string outputfile)
 {
     Cryptology.EncryptFile(inputfile, outputfile, password);
 }

 internal static void Decrypt(string inputfile, string outputfile)
 {
     Cryptology.DecryptFile(inputfile, outputfile, password);
 }
</code></pre>
","1564","<c#><encryption><rijndael>","0","0","3","2012-12-19 15:31:52","11335019","12","","447356","","2012-07-04 20:11:01","2012-07-04 19:16:17",""
"11334399","Rijndael Encryption issues","<p>I don't know what I'm doing wrong but I've been trying to get this thing working for about 4 hours now and I just can't get it to work... this just gives me the error: ""Please suppy a correct password"" when I try to decrypt.
Encryption seems to work fine though.</p>

<p>Any suggestions? :&lt;</p>

<pre><code>using System;
using System.Text;
using System.Security.Cryptography;
using System.IO;
using System.Security;
using AesApp.Rijndael;
using System.Linq;

    internal class FileEncryption
        {
            private static string password = pw;

            internal static void Encrypt(string inputfile, string outputfile)
            {
                byte[] encryptedPassword;

                // Create a new instance of the RijndaelManaged
                // class.  This generates a new key and initialization
                // vector (IV).
                using (var algorithm = new RijndaelManaged())
                {
                    algorithm.KeySize = 256;
                    algorithm.BlockSize = 128;

                    // Encrypt the string to an array of bytes.
                    encryptedPassword = Cryptology.EncryptStringToBytes(
                        password, algorithm.Key, algorithm.IV);
                }

                string chars = encryptedPassword.Aggregate(string.Empty, (current, b) =&gt; current + b.ToString());
                Cryptology.EncryptFile(@inputfile, @outputfile, chars);
            }

            internal static void Decrypt(string @inputfile, string @outputfile)
            {
                byte[] encryptedPassword;

                // Create a new instance of the RijndaelManaged
                // class.  This generates a new key and initialization
                // vector (IV).
                using (var algorithm = new RijndaelManaged())
                {
                    algorithm.KeySize = 256;
                    algorithm.BlockSize = 128;

                    // Encrypt the string to an array of bytes.
                    encryptedPassword = Cryptology.EncryptStringToBytes(
                        password, algorithm.Key, algorithm.IV);
                }

                string chars = encryptedPassword.Aggregate(string.Empty, (current, b) =&gt; current + b.ToString());
                Cryptology.DecryptFile(@inputfile, @outputfile, chars);
            }
        }
</code></pre>

<p>Reindael.cs</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

    namespace AesApp.Rijndael
    {
        internal sealed class Cryptology
        {
            private const string Salt = ""d5fg4df5sg4ds5fg45sdfg4"";
            private const int SizeOfBuffer = 1024 * 8;

            internal static byte[] EncryptStringToBytes(string plainText, byte[] key, byte[] iv)
            {
                // Check arguments.
                if (plainText == null || plainText.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""plainText"");
                }
                if (key == null || key.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""key"");
                }
                if (iv == null || iv.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""key"");
                }

                byte[] encrypted;
                // Create an RijndaelManaged object
                // with the specified key and IV.
                using (var rijAlg = new RijndaelManaged())
                {
                    rijAlg.Key = key;
                    rijAlg.IV = iv;

                    // Create a decrytor to perform the stream transform.
                    ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

                    // Create the streams used for encryption.
                    using (var msEncrypt = new MemoryStream())
                    {
                        using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                        {
                            using (var swEncrypt = new StreamWriter(csEncrypt))
                            {
                                //Write all data to the stream.
                                swEncrypt.Write(plainText);
                            }
                            encrypted = msEncrypt.ToArray();
                        }
                    }
                }


                // Return the encrypted bytes from the memory stream.
                return encrypted;

            }

            internal static string DecryptStringFromBytes(byte[] cipherText, byte[] key, byte[] iv)
            {
                // Check arguments.
                if (cipherText == null || cipherText.Length &lt;= 0)
                    throw new ArgumentNullException(""cipherText"");
                if (key == null || key.Length &lt;= 0)
                    throw new ArgumentNullException(""key"");
                if (iv == null || iv.Length &lt;= 0)
                    throw new ArgumentNullException(""key"");

                // Declare the string used to hold
                // the decrypted text.
                string plaintext;

                // Create an RijndaelManaged object
                // with the specified key and IV.
                using (var rijAlg = new RijndaelManaged())
                {
                    rijAlg.Key = key;
                    rijAlg.IV = iv;

                    // Create a decrytor to perform the stream transform.
                    ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

                    // Create the streams used for decryption.
                    using (var msDecrypt = new MemoryStream(cipherText))
                    {
                        using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                        {
                            using (var srDecrypt = new StreamReader(csDecrypt))
                            {
                                // Read the decrypted bytes from the decrypting stream
                                // and place them in a string.
                                plaintext = srDecrypt.ReadToEnd();
                            }
                        }
                    }

                }
                return plaintext;
            }

            internal static void EncryptFile(string inputPath, string outputPath, string password)
            {
                var input = new FileStream(inputPath, FileMode.Open, FileAccess.Read);
                var output = new FileStream(outputPath, FileMode.OpenOrCreate, FileAccess.Write);

                // Essentially, if you want to use RijndaelManaged as AES you need to make sure that:
                // 1.The block size is set to 128 bits
                // 2.You are not using CFB mode, or if you are the feedback size is also 128 bits

                var algorithm = new RijndaelManaged { KeySize = 256, BlockSize = 128 };
                var key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(Salt));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                using (var encryptedStream = new CryptoStream(output, algorithm.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    CopyStream(input, encryptedStream);
                }
            }

            internal static void DecryptFile(string inputPath, string outputPath, string password)
            {
                var input = new FileStream(inputPath, FileMode.Open, FileAccess.Read);
                var output = new FileStream(outputPath, FileMode.OpenOrCreate, FileAccess.Write);

                // Essentially, if you want to use RijndaelManaged as AES you need to make sure that:
                // 1.The block size is set to 128 bits
                // 2.You are not using CFB mode, or if you are the feedback size is also 128 bits
                var algorithm = new RijndaelManaged { KeySize = 256, BlockSize = 128 };
                var key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(Salt));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                try
                {
                    using (var decryptedStream = new CryptoStream(output, algorithm.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        CopyStream(input, decryptedStream);
                    }
                }
                catch (CryptographicException)
                {
                    throw new InvalidDataException(""Please suppy a correct password"");
                }
                catch (Exception ex)
                {
                    throw new Exception(ex.Message);
                }
            }

            private static void CopyStream(Stream input, Stream output)
            {
                using (output)
                using (input)
                {
                    byte[] buffer = new byte[SizeOfBuffer];
                    int read;
                    while ((read = input.Read(buffer, 0, buffer.Length)) &gt; 0)
                    {
                        output.Write(buffer, 0, read);
                    }
                }
            }
        }
    }
</code></pre>
","<ol>
<li>Your Encrypt function seems to be exactly equal to your decrypt function.</li>
<li>Also, why are you converting all bytes to strings and concatenate them? This transformation is not reversible.</li>
</ol>
","1564","<c#><encryption><rijndael>","0","0","3","2012-12-19 15:31:52","11335019","12","","447356","","2012-07-04 20:11:01","2012-07-04 19:16:17",""
"11334399","Rijndael Encryption issues","<p>I don't know what I'm doing wrong but I've been trying to get this thing working for about 4 hours now and I just can't get it to work... this just gives me the error: ""Please suppy a correct password"" when I try to decrypt.
Encryption seems to work fine though.</p>

<p>Any suggestions? :&lt;</p>

<pre><code>using System;
using System.Text;
using System.Security.Cryptography;
using System.IO;
using System.Security;
using AesApp.Rijndael;
using System.Linq;

    internal class FileEncryption
        {
            private static string password = pw;

            internal static void Encrypt(string inputfile, string outputfile)
            {
                byte[] encryptedPassword;

                // Create a new instance of the RijndaelManaged
                // class.  This generates a new key and initialization
                // vector (IV).
                using (var algorithm = new RijndaelManaged())
                {
                    algorithm.KeySize = 256;
                    algorithm.BlockSize = 128;

                    // Encrypt the string to an array of bytes.
                    encryptedPassword = Cryptology.EncryptStringToBytes(
                        password, algorithm.Key, algorithm.IV);
                }

                string chars = encryptedPassword.Aggregate(string.Empty, (current, b) =&gt; current + b.ToString());
                Cryptology.EncryptFile(@inputfile, @outputfile, chars);
            }

            internal static void Decrypt(string @inputfile, string @outputfile)
            {
                byte[] encryptedPassword;

                // Create a new instance of the RijndaelManaged
                // class.  This generates a new key and initialization
                // vector (IV).
                using (var algorithm = new RijndaelManaged())
                {
                    algorithm.KeySize = 256;
                    algorithm.BlockSize = 128;

                    // Encrypt the string to an array of bytes.
                    encryptedPassword = Cryptology.EncryptStringToBytes(
                        password, algorithm.Key, algorithm.IV);
                }

                string chars = encryptedPassword.Aggregate(string.Empty, (current, b) =&gt; current + b.ToString());
                Cryptology.DecryptFile(@inputfile, @outputfile, chars);
            }
        }
</code></pre>

<p>Reindael.cs</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

    namespace AesApp.Rijndael
    {
        internal sealed class Cryptology
        {
            private const string Salt = ""d5fg4df5sg4ds5fg45sdfg4"";
            private const int SizeOfBuffer = 1024 * 8;

            internal static byte[] EncryptStringToBytes(string plainText, byte[] key, byte[] iv)
            {
                // Check arguments.
                if (plainText == null || plainText.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""plainText"");
                }
                if (key == null || key.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""key"");
                }
                if (iv == null || iv.Length &lt;= 0)
                {
                    throw new ArgumentNullException(""key"");
                }

                byte[] encrypted;
                // Create an RijndaelManaged object
                // with the specified key and IV.
                using (var rijAlg = new RijndaelManaged())
                {
                    rijAlg.Key = key;
                    rijAlg.IV = iv;

                    // Create a decrytor to perform the stream transform.
                    ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

                    // Create the streams used for encryption.
                    using (var msEncrypt = new MemoryStream())
                    {
                        using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                        {
                            using (var swEncrypt = new StreamWriter(csEncrypt))
                            {
                                //Write all data to the stream.
                                swEncrypt.Write(plainText);
                            }
                            encrypted = msEncrypt.ToArray();
                        }
                    }
                }


                // Return the encrypted bytes from the memory stream.
                return encrypted;

            }

            internal static string DecryptStringFromBytes(byte[] cipherText, byte[] key, byte[] iv)
            {
                // Check arguments.
                if (cipherText == null || cipherText.Length &lt;= 0)
                    throw new ArgumentNullException(""cipherText"");
                if (key == null || key.Length &lt;= 0)
                    throw new ArgumentNullException(""key"");
                if (iv == null || iv.Length &lt;= 0)
                    throw new ArgumentNullException(""key"");

                // Declare the string used to hold
                // the decrypted text.
                string plaintext;

                // Create an RijndaelManaged object
                // with the specified key and IV.
                using (var rijAlg = new RijndaelManaged())
                {
                    rijAlg.Key = key;
                    rijAlg.IV = iv;

                    // Create a decrytor to perform the stream transform.
                    ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

                    // Create the streams used for decryption.
                    using (var msDecrypt = new MemoryStream(cipherText))
                    {
                        using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                        {
                            using (var srDecrypt = new StreamReader(csDecrypt))
                            {
                                // Read the decrypted bytes from the decrypting stream
                                // and place them in a string.
                                plaintext = srDecrypt.ReadToEnd();
                            }
                        }
                    }

                }
                return plaintext;
            }

            internal static void EncryptFile(string inputPath, string outputPath, string password)
            {
                var input = new FileStream(inputPath, FileMode.Open, FileAccess.Read);
                var output = new FileStream(outputPath, FileMode.OpenOrCreate, FileAccess.Write);

                // Essentially, if you want to use RijndaelManaged as AES you need to make sure that:
                // 1.The block size is set to 128 bits
                // 2.You are not using CFB mode, or if you are the feedback size is also 128 bits

                var algorithm = new RijndaelManaged { KeySize = 256, BlockSize = 128 };
                var key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(Salt));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                using (var encryptedStream = new CryptoStream(output, algorithm.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    CopyStream(input, encryptedStream);
                }
            }

            internal static void DecryptFile(string inputPath, string outputPath, string password)
            {
                var input = new FileStream(inputPath, FileMode.Open, FileAccess.Read);
                var output = new FileStream(outputPath, FileMode.OpenOrCreate, FileAccess.Write);

                // Essentially, if you want to use RijndaelManaged as AES you need to make sure that:
                // 1.The block size is set to 128 bits
                // 2.You are not using CFB mode, or if you are the feedback size is also 128 bits
                var algorithm = new RijndaelManaged { KeySize = 256, BlockSize = 128 };
                var key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(Salt));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                try
                {
                    using (var decryptedStream = new CryptoStream(output, algorithm.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        CopyStream(input, decryptedStream);
                    }
                }
                catch (CryptographicException)
                {
                    throw new InvalidDataException(""Please suppy a correct password"");
                }
                catch (Exception ex)
                {
                    throw new Exception(ex.Message);
                }
            }

            private static void CopyStream(Stream input, Stream output)
            {
                using (output)
                using (input)
                {
                    byte[] buffer = new byte[SizeOfBuffer];
                    int read;
                    while ((read = input.Read(buffer, 0, buffer.Length)) &gt; 0)
                    {
                        output.Write(buffer, 0, read);
                    }
                }
            }
        }
    }
</code></pre>
","<pre><code>string chars = encryptedPassword.Aggregate(string.Empty, (current, b) =&gt; current + b.ToString());
            Cryptology.EncryptFile(@inputfile, @outputfile, chars);
</code></pre>

<p>The Aggregate() function is the cause. It is creating different values each time you run your application.</p>
","1564","<c#><encryption><rijndael>","0","0","3","2012-12-19 15:31:52","11335019","12","","447356","","2012-07-04 20:11:01","2012-07-04 19:16:17",""
"39446456","Decrypt with Rijndael 128 ecb using javascript in a simple html page","<p>I want to decrypt an encrypted cipher like 4vEUkMYlT2qJq+9J0GT8VQ== using Rijndael 128 ecb algorithm. I found some library but nothing work correctly. some of libraries only work with nodejs others work with php. I have only a simple html page that get an encrypt text from an ajax.and I want to decrypt using same algorithm Rijndael 128 ecb. (encrypt text is 4vEUkMYlT2qJq+9J0GT8VQ== decrypted result is Novaphen)
can every one give me a solution to decrypt with javascript?</p>
","<p>finally I can do it with this link. : <a href=""https://stackoverflow.com/questions/24337317/encrypt-with-php-decrypt-with-javascript-cryptojs"">Encrypt with PHP, Decrypt with Javascript</a>
Here is my Decryption function :</p>

<pre><code>    function DecryptData(encryptedData) {
    var decryptedText = null;
    try {
        // Mcrypt pads a short key with zero bytes
        key = CryptoJS.enc.Utf8.parse('doctorlinktechno')

        iv = CryptoJS.enc.Utf8.parse('keee')

        // Keep the ciphertext in Base64 form
        ciphertext = '4vEUkMYlT2qJq+9J0GT8VQ=='

        // Mcrypt uses ZERO padding
        plaintext = CryptoJS.AES.decrypt(ciphertext, key, { iv: iv, mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.ZeroPadding })

        // I ran this in nodejs
        return CryptoJS.enc.Utf8.stringify(plaintext);
    }
    //Malformed UTF Data due to incorrect password
    catch (err) {
        return """";
    }
}
</code></pre>

<p>the point is you must to include dependent files base on your work. for example I want to use ecb mode and padding zero and I included following files:</p>

<pre><code>&lt;script src=""scripts/aes/core.js""&gt;&lt;/script&gt;
&lt;script src=""scripts/aes/enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""scripts/aes/cipher-core.js""&gt;&lt;/script&gt;
&lt;script src=""scripts/aes/aes.js""&gt;&lt;/script&gt;
&lt;script src=""scripts/aes/mode-ecb.js""&gt;&lt;/script&gt;
&lt;script src=""scripts/aes/pad-zeropadding.js""&gt;&lt;/script&gt;
</code></pre>
","1531","<javascript><encryption><rijndael><ecb>","-1","1","1","2016-09-12 16:13:50","39454608","1","","1597581","","2016-09-12 13:54:35","2016-09-12 08:47:14",""
"8120798","Encrypt file in Perl and decrypt in c#","<p>I'm trying to encrypt a text file using Perl and then decrypt it using a different application written in C#.
Here's my Perl code:</p>

<pre><code>use strict;
use Crypt::CBC;

my $ifh;
my $ofh;
my $line;

my $cipher = Crypt::CBC-&gt;new(
    {
        'key'         =&gt; 'length16length16',
        'cipher'      =&gt; 'Rijndael',
        'iv'          =&gt; 'length16length16',
        'literal_key' =&gt; 1,
        'header'      =&gt; 'none',
    'padding'     =&gt; 'null',
        'keysize'     =&gt; 128 / 8
    }
);

open($ifh,'&lt;', $infile)
            or die ""Can't open $infile for encryption input: $!\n"";
open($ofh, '&gt;', $outfile)
        or die ""Can't open $outfile for encryption output: $!\n"";

$cipher-&gt;start('encrypting');

for $line (&lt;$ifh&gt;) {
    print $ofh $cipher-&gt;crypt($line);
  }

print $ofh $cipher-&gt;finish;

close($ifh)
    or die ""Error closing input file: $!\n"";

close($ofh)
    or die ""Error closing output file: $!\n"";
</code></pre>

<p>And my C# code for decryption:</p>

<pre><code>    RijndaelManaged myRijndael = new System.Security.Cryptography.RijndaelManaged();
    myRijndael.Key = System.Text.Encoding.UTF8.GetBytes(""length16length16"");
    myRijndael.IV = System.Text.Encoding.UTF8-&gt;GetBytes(""length16length16"");
    myRijndael.Mode = CipherMode.CBC;
    myRijndael.Padding = PaddingMode.None;

    // Create a decryptor to perform the stream transform.
    ICryptoTransform decryptor = myRijndael.CreateDecryptor(myRijndael.Key, myRijndael.IV);

    //Create the streams used for decryption.
    FileStream file = File.OpenRead(strInFile);
    CryptoStream csDecrypt = new CryptoStream(file, decryptor, CryptoStreamMode.Read);
    StreamReader srDecrypt = new StreamReader(csDecrypt);

    // Read the decrypted bytes from the decrypting stream
    string decryptedText = srDecrypt.ReadToEnd();
</code></pre>

<p>I keep getting </p>

<blockquote>
  <p>System.Security.Cryptography.CryptographicException: Length of the
  data to decrypt is invalid</p>
</blockquote>

<p>When I try to read the data a few bytes at a time, I notice that the first 100 or so bytes are decrypted properly, but the rest is just garbage.</p>

<p>BTW, I can decrypt the encrypted file using Perl with:</p>

<pre><code>$cipher-&gt;start('decrypting');
</code></pre>

<p>So what am I doing wrong with C# and Perl?</p>

<p>EDIT: I tried following @munissor advice and change the C# code to use </p>

<blockquote>
  <p>PaddingMode.Zeros</p>
</blockquote>

<p>but I still get the same exception. 
Help please...</p>
","<p>If you check the <a href=""http://search.cpan.org/perldoc?Crypt%3a%3aCBC"" rel=""nofollow"">CPAN documentation for Crypt::CBC</a> it says that the ""null"" padding fills the blocks with zeroes. So I think you should use <code>PaddingMode.Zeros</code> on the C# side.</p>
","1529","<c#><.net><perl><encryption><rijndael>","2","3","2","2011-11-15 15:18:38","8138619","2","","150826","","2011-11-14 15:48:41","2011-11-14 11:19:32",""
"8120798","Encrypt file in Perl and decrypt in c#","<p>I'm trying to encrypt a text file using Perl and then decrypt it using a different application written in C#.
Here's my Perl code:</p>

<pre><code>use strict;
use Crypt::CBC;

my $ifh;
my $ofh;
my $line;

my $cipher = Crypt::CBC-&gt;new(
    {
        'key'         =&gt; 'length16length16',
        'cipher'      =&gt; 'Rijndael',
        'iv'          =&gt; 'length16length16',
        'literal_key' =&gt; 1,
        'header'      =&gt; 'none',
    'padding'     =&gt; 'null',
        'keysize'     =&gt; 128 / 8
    }
);

open($ifh,'&lt;', $infile)
            or die ""Can't open $infile for encryption input: $!\n"";
open($ofh, '&gt;', $outfile)
        or die ""Can't open $outfile for encryption output: $!\n"";

$cipher-&gt;start('encrypting');

for $line (&lt;$ifh&gt;) {
    print $ofh $cipher-&gt;crypt($line);
  }

print $ofh $cipher-&gt;finish;

close($ifh)
    or die ""Error closing input file: $!\n"";

close($ofh)
    or die ""Error closing output file: $!\n"";
</code></pre>

<p>And my C# code for decryption:</p>

<pre><code>    RijndaelManaged myRijndael = new System.Security.Cryptography.RijndaelManaged();
    myRijndael.Key = System.Text.Encoding.UTF8.GetBytes(""length16length16"");
    myRijndael.IV = System.Text.Encoding.UTF8-&gt;GetBytes(""length16length16"");
    myRijndael.Mode = CipherMode.CBC;
    myRijndael.Padding = PaddingMode.None;

    // Create a decryptor to perform the stream transform.
    ICryptoTransform decryptor = myRijndael.CreateDecryptor(myRijndael.Key, myRijndael.IV);

    //Create the streams used for decryption.
    FileStream file = File.OpenRead(strInFile);
    CryptoStream csDecrypt = new CryptoStream(file, decryptor, CryptoStreamMode.Read);
    StreamReader srDecrypt = new StreamReader(csDecrypt);

    // Read the decrypted bytes from the decrypting stream
    string decryptedText = srDecrypt.ReadToEnd();
</code></pre>

<p>I keep getting </p>

<blockquote>
  <p>System.Security.Cryptography.CryptographicException: Length of the
  data to decrypt is invalid</p>
</blockquote>

<p>When I try to read the data a few bytes at a time, I notice that the first 100 or so bytes are decrypted properly, but the rest is just garbage.</p>

<p>BTW, I can decrypt the encrypted file using Perl with:</p>

<pre><code>$cipher-&gt;start('decrypting');
</code></pre>

<p>So what am I doing wrong with C# and Perl?</p>

<p>EDIT: I tried following @munissor advice and change the C# code to use </p>

<blockquote>
  <p>PaddingMode.Zeros</p>
</blockquote>

<p>but I still get the same exception. 
Help please...</p>
","<p>Found the solution!!!</p>

<p>In Perl, I had to add after the opening of the output file: </p>

<blockquote>
  <p>binmode $ofh;</p>
</blockquote>

<p>The padding suggestion was helpful, but in the end I omitted the padding directive and used the default which is PKCS7 in Perl and in C#.</p>

<p>My final Perl code looks like this:</p>

<pre><code>use strict;
use Crypt::CBC;

my $ifh;
my $ofh;

my $cipher = Crypt::CBC-&gt;new(
    {
      'key'         =&gt; 'length16length16',
      'cipher'      =&gt; 'Rijndael',
      'iv'          =&gt; 'length16length16',
      'literal_key' =&gt; 1,
      'header'      =&gt; 'none',
      'keysize'     =&gt; 128 / 8
    }
);

#open input and output file
open($ifh,'&lt;', $infile)
        or die ""Can't open $infile for encryption input: $!\n"";
open($ofh, '&gt;', $outfile)
    or die ""Can't open $outfile for encryption output: $!\n"";
binmode &amp;ofh;

$cipher-&gt;start('encrypting');

#write encrypted data to output file
while (read($ifh,my $buffer,1024)) 
{
    print $ofh $cipher-&gt;crypt($buffer);
} 

print $ofh $cipher-&gt;finish;

#close file handles
close($ifh)
    or die ""Error closing input file: $!\n"";
close($ofh)
    or die ""Error closing output file: $!\n"";
</code></pre>

<p>and the C# part:</p>

<pre><code>RijndaelManaged myRijndael = new System.Security.Cryptography.RijndaelManaged();
myRijndael.Key = System.Text.Encoding.UTF8.GetBytes(""length16length16"");
myRijndael.IV = System.Text.Encoding.UTF8-&gt;GetBytes(""length16length16"");
myRijndael.Mode = CipherMode.CBC;

// Create a decryptor to perform the stream transform.
ICryptoTransform decryptor = myRijndael.CreateDecryptor(myRijndael.Key, myRijndael.IV);

//Create the streams used for decryption.
FileStream file = File.OpenRead(strInFile);
CryptoStream csDecrypt = new CryptoStream(file, decryptor, CryptoStreamMode.Read);
StreamReader srDecrypt = new StreamReader(csDecrypt);

// Read the decrypted bytes from the decrypting stream
string decryptedText = srDecrypt.ReadToEnd();
</code></pre>
","1529","<c#><.net><perl><encryption><rijndael>","2","1","2","2011-11-15 15:18:38","8138619","2","","150826","","2011-11-14 15:48:41","2011-11-14 11:19:32",""
"27921093","Rewrite PHP Rijndael algorithm to Java (Android)","<p>I need to encode a string in Java and php where the result must be the same.</p>

<p>The following conditions are given:</p>

<ol>
<li>algorithm: RIJNDAEL-128</li>
<li>key: 5P443m2Q1R9A7f5r3e1z08642</li>
<li>mode: ECB</li>
<li>initialization vector: N/A (Since we're using ECB, IV's are ignored)</li>
</ol>

<p><code>String to encode: 201412181656005P443m2Q1R9A7f5r3e1z08642</code></p>

<h1>PHP</h1>

<pre><code> &lt;?php
        class Cipher
        {
            private $securekey, $iv;

            function __construct($textkey)
            {
                $this-&gt;securekey = $textkey;
                $this-&gt;iv = mcrypt_create_iv(32);
            }

            function encryptR($input)
            {
                $enc = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this-&gt;securekey, $input, MCRYPT_MODE_ECB, $this-&gt;iv);
                return base64_encode($enc);
            }

            function decryptR($input)
            {
                return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;securekey, base64_decode($input), MCRYPT_MODE_ECB, $this-&gt;iv));
            }
        }

        $raw_text = '201412181656005P443m2Q1R9A7f5r3e1z08642';
        $secretKey = '5P443m2Q1R9A7f5r3e1z08642';

        $cipher = new Cipher($secretKey);
        $encrypted = $cipher-&gt;encryptR($raw_text);     
?&gt;
</code></pre>

<h3>Output: MbDHhIanWgySlMTOX+ItgVKudVLXbtj7ig2GMQacVM9JhyAPvVQxLJnHpEj/vhqW</h3>

<h1>JAVA</h1>

<pre><code>encrypted = encrypt(""201412181656005P443m2Q1R9A7f5r3e1z08642"",""5P443m2Q1R9A7f5r3e1z08642"");

public class Crypt {

    private final String characterEncoding = ""UTF-8"";
    private final String cipherTransformation = ""AES/ECB/PKCS5Padding"";
    private final String aesEncryptionAlgorithm = ""AES"";

    public  byte[] decrypt(byte[] cipherText, byte[] key) throws Exception
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy);
        cipherText = cipher.doFinal(cipherText);
        return cipherText;
    }

    public byte[] encrypt(byte[] plainText, byte[] key) throws Exception
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        plainText = cipher.doFinal(plainText);
        return plainText;
    }

    private byte[] getKeyBytes(String key) throws UnsupportedEncodingException{
        byte[] keyBytes= new byte[16];
        byte[] parameterKeyBytes= key.getBytes(characterEncoding);
        System.arraycopy(parameterKeyBytes, 0, keyBytes, 0, Math.min(parameterKeyBytes.length, keyBytes.length));
        return keyBytes;
    }

    @SuppressLint(""NewApi"")
    public String encrypt(String plainText, String key) throws Exception {
        byte[] plainTextbytes = plainText.getBytes(characterEncoding);
        byte[] keyBytes = getKeyBytes(key);
        // Log.i(""iv"", """"+keyBytesIV);
        return Base64.encodeToString(encrypt(plainTextbytes,keyBytes), Base64.DEFAULT);
    }

    @SuppressLint(""NewApi"")
    public String decrypt(String encryptedText, String key) throws Exception {
        byte[] cipheredBytes = Base64.decode(encryptedText, Base64.DEFAULT);
        byte[] keyBytes = getKeyBytes(key);

        return new String(decrypt(cipheredBytes, keyBytes), characterEncoding);
    }

}
</code></pre>

<h3>Output: wd0FHYpLbgdpHhcSql7VVCiKWJWN5hvP0W9F4sgKWAWeDcSjvfKWTM5LHBCZJSRw</h3>

<h2>Updated:</h2>

<p>I changed the padding from <code>NoPadding</code> to <code>PKCS5Padding</code></p>

<p>Is this correct? I'm not sure, cause if you look at the PHP code. There wasn't any padding specified(my own assumption based on syntax).</p>

<p><a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">Info on Mcrypt</a></p>

<h3>Additional Insight:</h3>

<p>Read this <a href=""http://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding"" rel=""nofollow"">document</a> regarding padding(No Padding). Must've been related to the issue.</p>
","<p>Looks like your PHP version uses AES-128, which by definition, uses 128-bit (16-byte) keys. However looks like you passed in a 25-byte key (<code>5P443m2Q1R9A7f5r3e1z08642</code>), which I'm not sure what PHP does when that happens.</p>

<p>Your Java version's getKeyBytes() method only returns the first 16 bytes of the supplied key, so it encrypts with only that.</p>

<p>Try truncating the key in your PHP version to <code>5P443m2Q1R9A7f5r</code> and you'd get the same result. Except the end part which may be different. At that point, the issue then would be the padding. You can apply the <code>pkcs5_pad</code> PHP function on your plaintext so it matches your Java version.</p>

<p>All that said, if this was just for learning purposes, it's ok. Otherwise, for actual use it's important that you <a href=""https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption"">do not use ECB cipher mode</a>.</p>
","1494","<java><php><android><aes><rijndael>","3","3","2","2015-11-17 08:13:10","","4","6","928952","","2015-08-21 06:11:16","2015-01-13 11:28:23",""
"27921093","Rewrite PHP Rijndael algorithm to Java (Android)","<p>I need to encode a string in Java and php where the result must be the same.</p>

<p>The following conditions are given:</p>

<ol>
<li>algorithm: RIJNDAEL-128</li>
<li>key: 5P443m2Q1R9A7f5r3e1z08642</li>
<li>mode: ECB</li>
<li>initialization vector: N/A (Since we're using ECB, IV's are ignored)</li>
</ol>

<p><code>String to encode: 201412181656005P443m2Q1R9A7f5r3e1z08642</code></p>

<h1>PHP</h1>

<pre><code> &lt;?php
        class Cipher
        {
            private $securekey, $iv;

            function __construct($textkey)
            {
                $this-&gt;securekey = $textkey;
                $this-&gt;iv = mcrypt_create_iv(32);
            }

            function encryptR($input)
            {
                $enc = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this-&gt;securekey, $input, MCRYPT_MODE_ECB, $this-&gt;iv);
                return base64_encode($enc);
            }

            function decryptR($input)
            {
                return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;securekey, base64_decode($input), MCRYPT_MODE_ECB, $this-&gt;iv));
            }
        }

        $raw_text = '201412181656005P443m2Q1R9A7f5r3e1z08642';
        $secretKey = '5P443m2Q1R9A7f5r3e1z08642';

        $cipher = new Cipher($secretKey);
        $encrypted = $cipher-&gt;encryptR($raw_text);     
?&gt;
</code></pre>

<h3>Output: MbDHhIanWgySlMTOX+ItgVKudVLXbtj7ig2GMQacVM9JhyAPvVQxLJnHpEj/vhqW</h3>

<h1>JAVA</h1>

<pre><code>encrypted = encrypt(""201412181656005P443m2Q1R9A7f5r3e1z08642"",""5P443m2Q1R9A7f5r3e1z08642"");

public class Crypt {

    private final String characterEncoding = ""UTF-8"";
    private final String cipherTransformation = ""AES/ECB/PKCS5Padding"";
    private final String aesEncryptionAlgorithm = ""AES"";

    public  byte[] decrypt(byte[] cipherText, byte[] key) throws Exception
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy);
        cipherText = cipher.doFinal(cipherText);
        return cipherText;
    }

    public byte[] encrypt(byte[] plainText, byte[] key) throws Exception
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        plainText = cipher.doFinal(plainText);
        return plainText;
    }

    private byte[] getKeyBytes(String key) throws UnsupportedEncodingException{
        byte[] keyBytes= new byte[16];
        byte[] parameterKeyBytes= key.getBytes(characterEncoding);
        System.arraycopy(parameterKeyBytes, 0, keyBytes, 0, Math.min(parameterKeyBytes.length, keyBytes.length));
        return keyBytes;
    }

    @SuppressLint(""NewApi"")
    public String encrypt(String plainText, String key) throws Exception {
        byte[] plainTextbytes = plainText.getBytes(characterEncoding);
        byte[] keyBytes = getKeyBytes(key);
        // Log.i(""iv"", """"+keyBytesIV);
        return Base64.encodeToString(encrypt(plainTextbytes,keyBytes), Base64.DEFAULT);
    }

    @SuppressLint(""NewApi"")
    public String decrypt(String encryptedText, String key) throws Exception {
        byte[] cipheredBytes = Base64.decode(encryptedText, Base64.DEFAULT);
        byte[] keyBytes = getKeyBytes(key);

        return new String(decrypt(cipheredBytes, keyBytes), characterEncoding);
    }

}
</code></pre>

<h3>Output: wd0FHYpLbgdpHhcSql7VVCiKWJWN5hvP0W9F4sgKWAWeDcSjvfKWTM5LHBCZJSRw</h3>

<h2>Updated:</h2>

<p>I changed the padding from <code>NoPadding</code> to <code>PKCS5Padding</code></p>

<p>Is this correct? I'm not sure, cause if you look at the PHP code. There wasn't any padding specified(my own assumption based on syntax).</p>

<p><a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">Info on Mcrypt</a></p>

<h3>Additional Insight:</h3>

<p>Read this <a href=""http://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding"" rel=""nofollow"">document</a> regarding padding(No Padding). Must've been related to the issue.</p>
","<p>I changed <code>byte[] keyBytes= new byte[16];</code> to <code>byte[] keyBytes= new byte[32];</code> in <code>getKeyBytes</code> method then it worked fine.</p>
","1494","<java><php><android><aes><rijndael>","3","0","2","2015-11-17 08:13:10","","4","6","928952","","2015-08-21 06:11:16","2015-01-13 11:28:23",""
"9027431","RijndaelManaged Cryptostream to decrypt file from disc into memory","<p>I have a library I wrote a while back that uses the same logic as the class code below, but when it decrypts a file, it decrypts it onto the disc, and give an option to delete the encrypted version or not. I'm trying to add an option to decrypt the file into memory so I can capture the file as a byte() and send the bytes to a service. I can obviously decrypt the file onto disc, read the file stream, convert it to byte(), delete the decrypted version (because I have to keep the files on disc encrypted).... creating a deleting files over and over again, can cause disc fragmentation, among other things, so I would like to just decrypt the file into memory. Anways, this successfully decrypts the file into the memorystream variable, but when I dumb the bytes into the file viewer, it tells me the file format is not recognized. Does anyone know what I'm doing wrong here?</p>

<p>Here's the code I have so far:</p>

<pre><code>Public Class EncryptionFactory     

Private Shared fsInput As FileStream

            Public Shared Function GetDecryptedFile(ByVal password As String, ByVal encryptedFilePath As String) As Byte()

                Return DecryptFile(encryptedFilePath, Key(password), IV(password))

            End Function


            Private Shared Function DecryptFile(ByVal strInputFile As String, ByVal bytKey As Byte(), ByVal bytIV As Byte()) As Byte()

                fsInput = New FileStream(strInputFile, FileMode.Open, FileAccess.Read)
                Dim memoryStream As MemoryStream
                memoryStream = New MemoryStream()
                Dim array As Byte() = New Byte(&amp;H1001 - 1) {}
                Dim num2 As Long = 0
                Dim length As Long = fsInput.Length
                Dim managed As New RijndaelManaged
                Dim stream As New CryptoStream(memoryStream, managed.CreateDecryptor(bytKey, bytIV), CryptoStreamMode.Write)

                Do While (num2 &lt; length)
                    Dim count As Integer = fsInput.Read(array, 0, &amp;H1000)
                    stream.Write(array, 0, count)
                    num2 = (num2 + count)
                Loop

                Dim data As Byte() = memoryStream.ToByte()

                fsInput.Close()
                fsInput.Dispose()
                memoryStream.Close()
                memoryStream.Dispose()

                Return data

            End Function

            Private Shared Function Key(ByVal strPassword As String) As Byte()
                Dim num5 As Integer
                Dim chArray As Char() = strPassword.ToCharArray
                Dim buffer As Byte() = New Byte((chArray.GetUpperBound(0) + 1) - 1) {}
                Dim upperBound As Integer = chArray.GetUpperBound(0)
                Dim i As Integer = 0
                Do While (i &lt;= upperBound)
                    buffer(i) = CByte(Strings.Asc(chArray(i)))
                    i += 1
                Loop
                Dim buffer3 As Byte() = New SHA512Managed().ComputeHash(buffer)
                Dim buffer2 As Byte() = New Byte(&amp;H20 - 1) {}
                Dim index As Integer = 0
                Do
                    buffer2(index) = buffer3(index)
                    index += 1
                    num5 = &amp;H1F
                Loop While (index &lt;= num5)
                Return buffer2
            End Function

            Private Shared Function IV(ByVal strPassword As String) As Byte()
                Dim num5 As Integer
                Dim chArray As Char() = strPassword.ToCharArray
                Dim buffer As Byte() = New Byte((chArray.GetUpperBound(0) + 1) - 1) {}
                Dim upperBound As Integer = chArray.GetUpperBound(0)
                Dim i As Integer = 0
                Do While (i &lt;= upperBound)
                    buffer(i) = CByte(Strings.Asc(chArray(i)))
                    i += 1
                Loop
                Dim buffer3 As Byte() = New SHA512Managed().ComputeHash(buffer)
                Dim buffer2 As Byte() = New Byte(&amp;H10 - 1) {}
                Dim index As Integer = &amp;H20
                Do
                    buffer2((index - &amp;H20)) = buffer3(index)
                    index += 1
                    num5 = &amp;H2F
                Loop While (index &lt;= num5)
                Return buffer2
            End Function



        End Class
</code></pre>

<p>UPDATE:</p>

<p>I added the cryptostream.FlushFinalBlock()</p>

<p>this is still not working... I feel like it's just not reading the stream all the way to the end.</p>

<pre><code>Private Shared Function DecryptFile(ByVal strInputFile As String, ByVal bytKey As Byte(), ByVal bytIV As Byte()) As Byte()

    fsInput = New FileStream(strInputFile, FileMode.Open, FileAccess.Read)
    Dim memoryStream As MemoryStream
    memoryStream = New MemoryStream()
    Dim array As Byte() = New Byte(&amp;H1001 - 1) {}
    Dim num2 As Long = 0
    Dim length As Long = fsInput.Length
    Dim managed As New RijndaelManaged
    Dim stream As New CryptoStream(memoryStream, managed.CreateDecryptor(bytKey, bytIV), CryptoStreamMode.Write)

    Do While (num2 &lt; length)
        Dim count As Integer = fsInput.Read(array, 0, &amp;H1000)
        stream.Write(array, 0, count)
        num2 = (num2 + count)
    Loop

    stream.FlushFinalBlock()

    Dim data As Byte() = memoryStream.ToByte()

    fsInput.Close()
    fsInput.Dispose()
    memoryStream.Close()
    memoryStream.Dispose()

    Return data

End Function
</code></pre>

<p>UPDATE:</p>

<p>Here's in my ""Encrypt"" Method, using the same IV, and Key methods as the decrypt...</p>

<pre><code>Friend Sub EncryptFile(ByVal strInputFile As String, ByVal strOutputFile As String, ByVal bytKey As Byte(), ByVal bytIV As Byte(), ByVal deleteOrig As Boolean)
    Me.fsInput = New FileStream(strInputFile, FileMode.Open, FileAccess.Read)
    Me.fsOutput = New FileStream(strOutputFile, FileMode.OpenOrCreate, FileAccess.Write)
    Me.fsOutput.SetLength(0)
    Dim array As Byte() = New Byte(&amp;H1001  - 1) {}
    Dim num2 As Long = 0
    Dim length As Long = Me.fsInput.Length
    Dim managed As New RijndaelManaged
    Dim stream As New CryptoStream(Me.fsOutput, managed.CreateEncryptor(bytKey, bytIV), CryptoStreamMode.Write)
    Do While (num2 &lt; length)
        Dim count As Integer = Me.fsInput.Read(array, 0, &amp;H1000)
        stream.Write(array, 0, count)
        num2 = (num2 + count)
    Loop
    stream.Close
    Me.fsInput.Close
    Me.fsOutput.Close
    If deleteOrig Then
        Dim info As New FileInfo(strInputFile)
        If ((info.Attributes And FileAttributes.ReadOnly) &gt; 0) Then
            info.Attributes = (info.Attributes Xor FileAttributes.ReadOnly)
            File.Delete(strInputFile)
        Else
            info.Delete
        End If
    End If
End Sub
</code></pre>

<p>Final UPDATE:</p>

<p>Here's the decrypt file to memory code that was successful:</p>

<pre><code>Private Shared Function DecryptFile(ByVal strInputFile As String, ByVal bytKey As Byte(), ByVal bytIV As Byte()) As Byte()

        fsInput = New FileStream(strInputFile, FileMode.Open, FileAccess.Read)
        Dim memoryStream As MemoryStream
        memoryStream = New MemoryStream()
        Dim array As Byte() = New Byte(&amp;H1001 - 1) {}
        Dim num2 As Long = 0
        Dim length As Long = fsInput.Length
        Dim managed As New RijndaelManaged
        Dim stream As New CryptoStream(memoryStream, managed.CreateDecryptor(bytKey, bytIV), CryptoStreamMode.Write)

        Do While (num2 &lt; length)
            Dim count As Integer = fsInput.Read(array, 0, &amp;H1000)
            stream.Write(array, 0, count)
            num2 = (num2 + count)
        Loop

        stream.FlushFinalBlock()
        stream.Dispose()

        Dim data As Byte() = memoryStream.ToArray()

        fsInput.Close()
        fsInput.Dispose()
        memoryStream.Close()
        memoryStream.Dispose()

        Return data

    End Function
</code></pre>
","<p>After you have finished writing all of the blocks, you need to call cryptoStream.FlushFinalBlock();</p>

<p><em>Off Topic:
Here is an example of using to get the key and IV for your algorithm</em></p>

<pre><code>private void SetAlgorithmKey(SymmetricAlgorithm algorithm, string password, string salt, int iterationCount)
{
    byte[] saltBytes = string.IsNullOrEmpty(salt) ? new byte[0] : Encoding.ASCII.GetBytes(salt);

    // The salt size must be 8 bytes or larger.
    if (saltBytes.Length &lt; 8)
    {
        byte[] newSaltBytes = new byte[8];
        Array.Copy(saltBytes, newSaltBytes, saltBytes.Length);
        for (int i = saltBytes.Length; i &lt; 8; i++)
        {
            newSaltBytes[i] = 0; // pad with zeros?
        }

        saltBytes = newSaltBytes;
    }

    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, saltBytes, iterationCount);
    algorithm.Key = pdb.GetBytes(algorithm.KeySize / 8);
    algorithm.IV = pdb.GetBytes(algorithm.BlockSize / 8);
}
</code></pre>
","1477","<.net><encryption><rijndael><rijndaelmanaged>","0","1","1","2012-01-27 03:33:59","9027733","0","","899821","","2012-01-27 03:33:59","2012-01-27 00:18:48",""
"10846650","Decrypting an AES256-rijdeal encrypted file with initialization vector","<p>I've got a tricky situation at the moment.</p>

<p>I need to create an android method that will decrypt an encrypted file that has been encrypted like this:</p>

<ul>
<li>AES256 (Rijndael)</li>
<li>Cipher-Block-Chaining (CBC) using an initialization vector of 16 bytes that look like:</li>
</ul>

<p>{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 122, 100 }</p>

<p>I also know the encryption key to the file, but for now let's say it's: ""Boat""</p>

<p>I've been searching around on Google but I could not find a online that used this combination of encryption. Some involved the Rijndael algorithm but didn't let me choose an initialization vector, while others did not support AES256 at all.</p>

<p>Can someone point me into the right direction where to find an example or post some sample code that does the above?</p>

<p>N.B. I don't know if it's important to mention but the output file is always .pdf</p>
","<p>This is a very standard configuration, hard to believe you didn't find any samples. All you need to do is create an <code>IvParameterSpec</code> from your IV bytes and initialize the <code>Cipher</code> with it. Something like this: </p>

<pre><code>SecretKey key = getEncryptionKey(); 
byte[] iv = new byte[] { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, (byte)144, (byte)233, 122, 100 };
byte[] cipherBytes = readEncryptedFile();
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
IvParameterSpec ivParams = new IvParameterSpec(iv);
cipher.init(Cipher.DECRYPT_MODE, key, ivParams);
byte[] plaintext = cipher.doFinal(cipherBytes);
</code></pre>

<p>BTW, 'Rijndael' is the same as AES, so you'd get better results if you just search for 'AES'.</p>
","1463","<android><encryption><rijndael>","0","1","1","2012-06-01 08:24:32","10846836","0","2","","","","2012-06-01 08:08:58",""
"3366811",".NET AES/Rijndael — inconsistent decryption when reusing decryptor","<p>I've created a class for encrypting and decrypting using AES.</p>

<pre><code>public class AesEncryptionProvider {
    #region Fields

    // Encryption key
    private static readonly byte[] s_key = new byte[32] {
        // Omitted...
    };

    // Initialization vector
    private static readonly byte[] s_iv = new byte[16] {
        // Omitted...
    };

    private AesCryptoServiceProvider m_provider;
    private ICryptoTransform m_encryptor;
    private ICryptoTransform m_decryptor;

    #endregion

    #region Constructors

    private AesEncryptionProvider () {
        m_provider = new AesCryptoServiceProvider();
        m_encryptor = m_provider.CreateEncryptor(s_key, s_iv);
        m_decryptor = m_provider.CreateDecryptor(s_key, s_iv);
    }

    static AesEncryptionProvider () {
        Instance = new AesEncryptionProvider();
    }

    #endregion

    #region Properties

    public static AesEncryptionProvider Instance { get; private set; }

    #endregion

    #region Methods

    public string Encrypt (string value) {
        if (string.IsNullOrEmpty(value)) {
            throw new ArgumentException(""Value required."");
        }

        return Convert.ToBase64String(
            Transform(
                Encoding.UTF8.GetBytes(value),
                m_encryptor));
    }

    public string Decrypt (string value) {
        if (string.IsNullOrEmpty(value)) {
            throw new ArgumentException(""Value required."");
        }

        return Encoding.UTF8.GetString(
            Transform(
                Convert.FromBase64String(value),
                m_decryptor));
    }

    #endregion

    #region Private methods

    private byte[] Transform (byte[] input, ICryptoTransform transform) {
        byte[] output;
        using (MemoryStream memory = new MemoryStream()) {
            using (CryptoStream crypto = new CryptoStream(
                memory,
                transform,
                CryptoStreamMode.Write
            )) {
                crypto.Write(input, 0, input.Length);
                crypto.FlushFinalBlock();

                output = memory.ToArray();
            }
        }
        return output;
    }

    #endregion
}
</code></pre>

<p>As you can see, in both cases I'm <em>writing</em> to a <code>MemoryStream</code> via a <code>CryptoStream</code>. If I create a new decryptor via <code>m_provider.CreateDecyptor(s_key, s_iv)</code> on every call to <code>Decrypt</code> it works just fine.</p>

<p>What has gone wrong here? Why is the decryptor behaving as if its forgotten the IV? Is there something that the call to <code>StreamReader.ReadToEnd()</code> is doing that helps <code>m_decryptor</code> function correctly?</p>

<p>I would like to avoid either of the two ""working"" approaches I listed here as there is a performance hit on both and this is a very critical path. Thanks in advance.</p>
","<p>Ok, I admit I have no idea why this works, but change <code>AesCryptoServiceProvider</code> to <code>AesManaged</code> and voila.</p>

<p>I also recommend making your class implement <code>IDisposable</code> as it contains three member variables which implement it.  See below for code changes:</p>

<pre><code>public sealed class AesEncryptionProvider : IDisposable
{
    // Encryption key
    private static readonly byte[] key = new byte[]
    {
        // Omitted...
    };

    // Initialization vector
    private static readonly byte[] iv = new byte[]
    {
        // Omitted...
    };

    private static readonly AesEncryptionProvider instance = new AesEncryptionProvider();

    private readonly AesManaged provider;

    private readonly ICryptoTransform encryptor;

    private readonly ICryptoTransform decryptor;

    private AesEncryptionProvider()
    {
        this.provider = new AesManaged();
        this.encryptor = this.provider.CreateEncryptor(key, iv);
        this.decryptor = this.provider.CreateDecryptor(key, iv);
    }

    public static AesEncryptionProvider Instance
    {
        get
        {
            return instance;
        }
    }

    public void Dispose()
    {
        this.decryptor.Dispose();
        this.encryptor.Dispose();
        this.provider.Dispose();
        GC.SuppressFinalize(this);
    }

    public string Encrypt(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            throw new ArgumentException(""Value required."");
        }

        return Convert.ToBase64String(Transform(Encoding.UTF8.GetBytes(value), this.encryptor));
    }

    public string Decrypt(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            throw new ArgumentException(""Value required."");
        }

        return Encoding.UTF8.GetString(Transform(Convert.FromBase64String(value), this.decryptor));
    }

    private static byte[] Transform(byte[] input, ICryptoTransform transform)
    {
        using (var memory = new MemoryStream())
        using (var crypto = new CryptoStream(memory, transform, CryptoStreamMode.Write))
        {
            crypto.Write(input, 0, input.Length);
            crypto.FlushFinalBlock();
            return memory.ToArray();
        }
    }
}
</code></pre>
","1436","<.net><encryption><aes><rijndael>","3","1","1","2013-06-28 14:20:05","3367494","2","1","224995","","2010-07-29 22:33:10","2010-07-29 20:48:57",""
"17666640","C# 2-way Encryption Class - Rijndael possible initialization vector issue (jibberish output)","<p>I am having problems with an encryption class that I made:</p>

<pre><code>public static class Encryption {

    public static string EncryptToString(string TextToEncrypt, byte[] Key, byte[] IV = null)
    {
        return ByteArrToString(EncryptStringToBytes(StrToByteArray(TextToEncrypt), Key, IV));        
    }

    public static string EncryptToString(byte[] BytesToEncrypt, byte[] Key, byte[] IV = null)
    {
        return ByteArrToString(EncryptStringToBytes(BytesToEncrypt, Key, IV));  
    }

    public static byte[] EncryptToBytes(string TextToEncrypt, byte[] Key, byte[] IV = null)
    {
        return EncryptStringToBytes(StrToByteArray(TextToEncrypt), Key, IV);
    }

    public static byte[] EncryptToBytes(byte[] BytesToEncrypt, byte[] Key, byte[] IV = null)
    {
        return EncryptStringToBytes(BytesToEncrypt, Key, IV);
    }

    public static string DecryptToString(string EncryptedText, byte[] Key,byte[] IV=null) 
    {
        return ByteArrToString(DecryptStringFromBytes(StrToByteArray(EncryptedText), Key, IV));            
    }

    public static string DecryptToString(byte[] EncryptedBytes, byte[] Key,byte[] IV=null) 
    {
        return ByteArrToString(DecryptStringFromBytes(EncryptedBytes, Key, IV));            
    }

    public static byte[] DecryptToBytes(string EncryptedText, byte[] Key,byte[] IV=null) 
    {
        return DecryptStringFromBytes(StrToByteArray(EncryptedText), Key, IV);            
    }

    public static byte[] DecryptToBytes(byte[] EncryptedBytes, byte[] Key,byte[] IV=null) 
    {
        return DecryptStringFromBytes(EncryptedBytes, Key, IV);            
    }

    private static byte[] EncryptStringToBytes(byte[] TextToEncrypt, byte[] Key, byte[] IV=null)
    {
        Debug.WriteLine(""Password: "" + ByteArrToString(Key));
        Debug.WriteLine(""IV: "" + ByteArrToString(IV));                        

        byte[] encrypted;
        // Create an Rijndael object 
        // with the specified key and IV. 
        using (Rijndael rijAlg = Rijndael.Create())
        {
            rijAlg.Key = Key;
            rijAlg.IV = IV;

            // Create a decrytor to perform the stream transform.
            ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

            // Create the streams used for encryption. 
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(TextToEncrypt);
                    }
                    encrypted = msEncrypt.ToArray();
                }
            }
        }

        // Return the encrypted bytes from the memory stream. 
        return encrypted;
    }

    private static byte[] DecryptStringFromBytes(byte[] EncryptedText, byte[] Key, byte[] IV)
    {
        Debug.WriteLine(""Password: "" + ByteArrToString(Key));
        Debug.WriteLine(""IV: "" + ByteArrToString(IV));

        byte[] fromEncrypt = new byte[EncryptedText.Length];

        // Create a Rijndael object with the specified key and IV. 
        using (Rijndael rijAlg = Rijndael.Create())
        {
            rijAlg.Key = Key;
            rijAlg.IV = IV;

            // Create a decrytor to perform the stream transform.
            ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

            // Create the streams used for decryption. 
            using (MemoryStream msDecrypt = new MemoryStream(EncryptedText))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    //read stream into byte array
                    csDecrypt.Read(fromEncrypt,0,fromEncrypt.Length);                        
                }
            }
        }

        return fromEncrypt;
    }

    public static byte[] StrToByteArray(string str)
    {
        if (str.Length == 0)
            throw new Exception(""Invalid string value in StrToByteArray"");

        byte[] bytes = new byte[str.Length * sizeof(char)];
        System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
        return bytes;
    }

    public static string ByteArrToString(byte[] bytes)
    {
        char[] chars = new char[bytes.Length / sizeof(char)];
        System.Buffer.BlockCopy(bytes, 0, chars, 0, bytes.Length);
        return new string(chars);
    }

    public static byte[] GetIV()
    {
        byte[] randomArray = new byte[16];
        RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
        rng.GetBytes(randomArray);
        return randomArray;
    }
}
</code></pre>

<p>I test it with the following:</p>

<pre><code>byte[] iv =  Encryption.GetIV();
byte[] password = Encryption.StrToByteArray(""password"");

string encrypted = Encryption.EncryptToString(""Hello"", password, iv);
Debug.WriteLine(""Result: "" + Encryption.DecryptToString(encrypted, password, iv));
</code></pre>

<p>This is the result I get in the debug window:</p>

<blockquote>
  <p>Password: password </p>
  
  <p>IV: 䴞ㆫ튾꛽輔 </p>
  
  <p>Password: password </p>
  
  <p>IV: 䴞ㆫ튾꛽輔</p>
  
  <p>Result: 祓瑳浥䈮瑹孥]</p>
</blockquote>

<p>I don't get any errors; just a jibberish result. </p>

<p>I don't know if it's a problem with the initialization vector, the stream, or something else that I'm missing. </p>
","<p>I believe there are several issues with this code involving string to byte conversions, total crypto length, etc. </p>

<p>here is a piece of code I have which does effectively the same thing and may get you on your way. I have tested it and it does work as expected.</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Security.Cryptography;
using System.IO;


namespace Encryption_test_app
{
    class Program
    {
        static void Main(string[] args)
        {
            var encoding = new UTF8Encoding(false, true);
            var cryptor = new RijndaelEncryptor();

            var plainText = ""Hello World!"";
            Debug.Print(""Plain Text: [{0}]"", plainText);

            byte[] cypherBytes = cryptor.Encrypt(encoding.GetBytes(plainText));
            string decryptedText = encoding.GetString(cryptor.Decrypt(cypherBytes));

            Debug.Print(""Decrypted Text: [{0}]"", decryptedText);
            Debug.Print(""PlainText == Decrypted Text: [{0}]"", plainText == decryptedText);
        }
    }



    /// &lt;summary&gt;
    /// Simple class to encrypt/decrypt a byte array using the &lt;see cref=""RijndaelManaged""/&gt; cryptographic algorithm.
    /// &lt;/summary&gt;
    public class RijndaelEncryptor : IDisposable
    {

        private RijndaelManaged _crypt = new RijndaelManaged();

        #region Constructors

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=""RijndaelEncryptor""/&gt; class using a default key and initial vector (IV).
        /// &lt;/summary&gt;
        public RijndaelEncryptor() : this(""0nce @pon a time..."", ""There lived a princess who 1iked frogs..."") { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=""RijndaelEncryptor""/&gt; class using the plain text key and initial vector
        /// which are used to construct encrypted key and IV values using the maximum allowed key and iv sizes for 
        /// the &lt;see cref=""RijndaelEncryptor""/&gt; cryptographic algorithm.
        /// &lt;/summary&gt;
        /// &lt;param name=""keyPassword""&gt;&lt;/param&gt;
        /// &lt;param name=""ivPassword""&gt;&lt;/param&gt;
        public RijndaelEncryptor(string keyPassword, string ivPassword) 
        {
            if (string.IsNullOrEmpty(keyPassword)) throw new ArgumentOutOfRangeException(""keyPassword"", ""Cannot be null or empty"");
            if (string.IsNullOrEmpty(ivPassword)) throw new ArgumentOutOfRangeException(""ivPassword"", ""Cannot be null or empty"");

            KeyPassword = keyPassword;
            IVPassword = ivPassword;

            _crypt.KeySize = _crypt.LegalKeySizes[0].MaxSize;

            EncryptKey = _stringToBytes(KeyPassword, _crypt.KeySize &gt;&gt; 3);
            EncryptIV = _stringToBytes(IVPassword, _crypt.BlockSize &gt;&gt; 3);

        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=""RijndaelEncryptor""/&gt; class using the user supplied key and initial vector arrays.
        /// NOTE: these arrays will be validated for use with the &lt;see cref=""RijndaelManaged""/&gt; cypher.
        /// &lt;/summary&gt;
        /// &lt;param name=""encryptedKey""&gt;&lt;/param&gt;
        /// &lt;param name=""encryptedIV""&gt;&lt;/param&gt;
        public RijndaelEncryptor(byte[] encryptedKey, byte[] encryptedIV)
        {
            if (encryptedKey == null) throw new ArgumentNullException(""encryptedKey"");
            if (encryptedIV == null) throw new ArgumentNullException(""encryptedIV"");

            //Verify encrypted key length is valid for this cryptor algo.
            int keylen = encryptedKey.Length &lt;&lt; 3;
            if (!_crypt.ValidKeySize(keylen))
            {
                string errmsg = ""Encryption key length("" + keylen.ToString() + "") is not for this algorithm:"" + _crypt.GetType().Name;
                throw new ApplicationException(errmsg);
            }

            //Verify encrypted iv length is valid for this cryptor algo.
            int len = encryptedIV.Length &lt;&lt; 3;
            if (len != _crypt.BlockSize)
            {
                string errmsg = ""Encryption key length("" + len.ToString() + "") is not for this algorithm:"" + _crypt.GetType().Name;
                throw new ApplicationException(errmsg);
            }

            EncryptKey = encryptedKey;
            EncryptIV = encryptedIV;
        }

        #endregion

        /// &lt;summary&gt;
        /// Plain text encryption key. Is used to generate a encrypted key &lt;see cref=""EncryptKey""/&gt;
        /// &lt;/summary&gt;
        public string KeyPassword { get; private set; }

        /// &lt;summary&gt;
        /// Plain text encryption initial vector. Is used to generate a encrypted IV &lt;see cref=""EncryptIV""/&gt;
        /// &lt;/summary&gt;
        public string IVPassword { get; private set; }

        /// &lt;summary&gt;
        /// Encrypted encryption key. (Size must match one of the allowed sizes for this encryption method).
        /// &lt;/summary&gt;
        public byte[] EncryptKey { get; private set; }

        /// &lt;summary&gt;
        /// Encrypted encryption IV. (Size must match one of the allowed sizes for this encryption method).
        /// &lt;/summary&gt;
        public byte[] EncryptIV { get; private set; }


        /// &lt;summary&gt;
        /// Encrypts the given byte array using the defined &lt;see cref=""EncryptKey""/&gt; and &lt;see cref=""EncryptIV""/&gt; values.
        /// &lt;/summary&gt;
        /// &lt;param name=""plaintext""&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public byte[] Encrypt(byte[] plaintext)
        {
            return(_encrypt(plaintext, EncryptKey, EncryptIV));
        }

        /// &lt;summary&gt;
        /// Decrypts the given byte array using the defined &lt;see cref=""EncryptKey""/&gt; and &lt;see cref=""EncryptIV""/&gt; values.
        /// &lt;/summary&gt;
        /// &lt;param name=""cypherBytes""&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public byte[] Decrypt(byte[] cypherBytes)
        {
            return (_decrypt(cypherBytes, EncryptKey, EncryptIV));
        }


        #region Private Encryption methods


        /// &lt;summary&gt;
        /// Used to encrypt the plain-text key and iv values to not so easy to ready byte arrays of the given size.
        /// &lt;/summary&gt;
        /// &lt;param name=""password""&gt;&lt;/param&gt;
        /// &lt;param name=""KeyByteSize""&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private byte[] _stringToBytes(string password, int KeyByteSize)
        {
            byte[] salt = new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0xfe, 0x00, 0xa7, 0xd3, 0x02, 0x02, 0x97, 0xc4, 0xa5, 0x32 };
            PasswordDeriveBytes b = new PasswordDeriveBytes(password, salt);
            return (b.GetBytes(KeyByteSize));
        }

        /// &lt;summary&gt;
        /// Encrypts the &lt;paramref name=""plainBytes""/&gt; array using the given key and initial vector.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// This routine embeds the length of the plain data at the beginning of the encrypted record. This would be 
        /// frowed apon by crypto experts. However, if you dont do this you may get extraneous data (extra null bytes)
        /// at the end of the decrypted byte array. This embedded length is used to trim the final decrypted array to size.
        /// &lt;/remarks&gt;
        /// &lt;param name=""plainBytes""&gt;&lt;/param&gt;
        /// &lt;param name=""key""&gt;&lt;/param&gt;
        /// &lt;param name=""iv""&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private byte[] _encrypt(byte[] plainBytes, byte[] key, byte[] iv)
        {
            try
            {
                // Create a MemoryStream.
                using (MemoryStream mStream = new MemoryStream())
                {
                    // Create a CryptoStream using the MemoryStream 
                    // and the passed key and initialization vector (IV).
                    using (CryptoStream cStream = new CryptoStream(mStream, _crypt.CreateEncryptor(key, iv), CryptoStreamMode.Write))
                    {

                        // Write the byte array to the crypto stream and flush it.
                        byte[] recordLen = BitConverter.GetBytes(plainBytes.Length);
                        cStream.Write(recordLen, 0, recordLen.Length);
                        cStream.Write(plainBytes, 0, plainBytes.Length);

                        if (!cStream.HasFlushedFinalBlock)
                        {
                            cStream.FlushFinalBlock();
                        }

                        // Get an array of bytes from the 
                        // MemoryStream that holds the 
                        // encrypted data.
                        return(mStream.ToArray());

                    }
                }
            }
            catch (CryptographicException ex)
            {
                throw new ApplicationException(""**ERROR** occurred during Encryption"", ex);
            }

        }

        /// &lt;summary&gt;
        /// Decrypts the &lt;paramref name=""cryptBytes""/&gt; array using the given key and initial vector.
        /// &lt;/summary&gt;
        /// &lt;param name=""plainBytes""&gt;&lt;/param&gt;
        /// &lt;param name=""key""&gt;&lt;/param&gt;
        /// &lt;param name=""iv""&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private byte[] _decrypt(byte[] cryptBytes, byte[] key, byte[] iv)
        {
            try
            {
                // Create a new MemoryStream using the passed 
                // array of encrypted data.
                using (MemoryStream msDecrypt = new MemoryStream(cryptBytes))
                {
                    // Create a CryptoStream using the MemoryStream 
                    // and the passed key and initialization vector (IV).
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, _crypt.CreateDecryptor(key, iv), CryptoStreamMode.Read))
                    {
                        byte[] recordLen = BitConverter.GetBytes((int)0);
                        csDecrypt.Read(recordLen, 0, recordLen.Length);
                        int length = BitConverter.ToInt32(recordLen, 0);

                        // Create buffer to hold the decrypted data.
                        byte[] fromEncrypt = new byte[cryptBytes.Length - recordLen.Length];

                        // Read the decrypted data out of the crypto stream
                        // and place it into the temporary buffer.
                        csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);

                        byte[] plainBytes = new byte[length];
                        Array.Copy(fromEncrypt, plainBytes, length);

                        return (plainBytes);
                    }
                }
            }
            catch (CryptographicException ex)
            {
                throw new ApplicationException(""**ERROR** occurred during Decryption"", ex);
            }
        }

        #endregion

        #region IDisposable Members

        private bool disposed = false;  //indicates if this instance has been disposed.

        private void Dispose(bool disposing)
        {
            if (!this.disposed)
            {
                //Dispose managed objects
                if (disposing)
                {
                    if (_crypt != null)
                    {
                        try { _crypt.Clear(); }
                        finally { _crypt = null; }
                    }
                }

                //Dispose Unmanaged objects
            }
            this.disposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~RijndaelEncryptor() { Dispose(false); }

        #endregion


    }

}
</code></pre>
","1424","<c#><vector><initialization><aes><rijndael>","0","1","1","2015-10-06 22:48:48","17669427","0","","1090802","","2015-10-06 22:48:48","2013-07-16 01:34:35",""
"5808107","PHP encryption code converted to ColdFusion","<p>I have this bit of PHP that I'd like to do the equivalent of in ColdFusion. </p>

<pre><code>function &amp; _encryptMessage( $message ) {

   $td = mcrypt_module_open( MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
   mcrypt_generic_init( $td, $this-&gt;key, $this-&gt;iv );
   $encrypted_data = mcrypt_generic( $td, $message );
 mcrypt_generic_deinit($td);
 mcrypt_module_close($td);

   return base64_encode( $encrypted_data );
}
</code></pre>

<p>I think it is just </p>

<pre><code>encrypt(message,"""",""AES"",""Base64"")
</code></pre>

<p>But I have no real way of knowing for sure and it doesn't feel quite right, so I wondered if someone out there would be good enough to point me in the right direction.</p>

<p>UPDATE : 
For information <a href=""https://stackoverflow.com/questions/3196846/un-encrypting-re-encrypting-a-coldfusion-encrypted-string-in-php"">this answer</a> by <a href=""https://stackoverflow.com/users/377852/mister-dai"">Mister Dai</a>, was particularly helpful.</p>

<p>So MCRYPT_RIJNDAEL_256 actually means <a href=""http://www.chilkatsoft.com/p/php_aes.asp"" rel=""nofollow noreferrer"">block size not the encryption strength</a>. The encryption strength is still 256 as the key and salt are generated in PHP using a value  that is hashed at sha-256.</p>

<p>This is the encrypt call I have now :</p>

<p><code>encrypt(arguments.messageXML,instance.key,""AES/CBC/PKCS5Padding"",""Base64"",ivSalt)</code></p>

<p>Unfortunately this blows up because the ivSalt is 32 bytes (256bits) in length and AES is only expecting a 16 bytes iv salt. Looking <a href=""http://kb2.adobe.com/cps/546/e546373d.html#main_block"" rel=""nofollow noreferrer"">here</a> it would seem that the maximum block size in ColdFusion/Java for AES is 16bytes (128bit).  I can't seem to see how I can get a 256bit block size.  Any help would be greatly appreciated.</p>
","<p><a href=""http://help.adobe.com/en_US/ColdFusion/9.0/CFMLRef/WSc3ff6d0ea77859461172e0811cbec22c24-7c52.html"" rel=""nofollow"">http://help.adobe.com/en_US/ColdFusion/9.0/CFMLRef/WSc3ff6d0ea77859461172e0811cbec22c24-7c52.html</a></p>

<p>You could do something as simple as:</p>

<pre><code>&lt;cfset stringName = ""variable 1: "" &amp; variable1 &amp; "" some more text"" /&gt;
&lt;cfset varName = HASH(stringName, ""SHA"") /&gt;
</code></pre>

<p>or even this:</p>

<pre><code>&lt;cfset varName = HASH(""i want this string to be encrypted"", ""SHA"") /&gt;
</code></pre>

<p>Doing something like this is usually what i do for password storage and other sensitive data.</p>

<p>Hope that the link and/or examples help,
Brds</p>
","1419","<php><encryption><coldfusion><aes><rijndael>","0","-2","2","2016-12-02 19:03:45","5876614","7","2","-1","","2017-05-23 11:53:01","2011-04-27 17:27:49",""
"5808107","PHP encryption code converted to ColdFusion","<p>I have this bit of PHP that I'd like to do the equivalent of in ColdFusion. </p>

<pre><code>function &amp; _encryptMessage( $message ) {

   $td = mcrypt_module_open( MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
   mcrypt_generic_init( $td, $this-&gt;key, $this-&gt;iv );
   $encrypted_data = mcrypt_generic( $td, $message );
 mcrypt_generic_deinit($td);
 mcrypt_module_close($td);

   return base64_encode( $encrypted_data );
}
</code></pre>

<p>I think it is just </p>

<pre><code>encrypt(message,"""",""AES"",""Base64"")
</code></pre>

<p>But I have no real way of knowing for sure and it doesn't feel quite right, so I wondered if someone out there would be good enough to point me in the right direction.</p>

<p>UPDATE : 
For information <a href=""https://stackoverflow.com/questions/3196846/un-encrypting-re-encrypting-a-coldfusion-encrypted-string-in-php"">this answer</a> by <a href=""https://stackoverflow.com/users/377852/mister-dai"">Mister Dai</a>, was particularly helpful.</p>

<p>So MCRYPT_RIJNDAEL_256 actually means <a href=""http://www.chilkatsoft.com/p/php_aes.asp"" rel=""nofollow noreferrer"">block size not the encryption strength</a>. The encryption strength is still 256 as the key and salt are generated in PHP using a value  that is hashed at sha-256.</p>

<p>This is the encrypt call I have now :</p>

<p><code>encrypt(arguments.messageXML,instance.key,""AES/CBC/PKCS5Padding"",""Base64"",ivSalt)</code></p>

<p>Unfortunately this blows up because the ivSalt is 32 bytes (256bits) in length and AES is only expecting a 16 bytes iv salt. Looking <a href=""http://kb2.adobe.com/cps/546/e546373d.html#main_block"" rel=""nofollow noreferrer"">here</a> it would seem that the maximum block size in ColdFusion/Java for AES is 16bytes (128bit).  I can't seem to see how I can get a 256bit block size.  Any help would be greatly appreciated.</p>
","<p>A couple of thanks should go out before I answer my own question.  Thanks to <a href=""http://misterdai.wordpress.com/"" rel=""nofollow"">Dave Boyer (Mister Dai)</a>, <a href=""http://www.12robots.com/"" rel=""nofollow"">Jason Dean</a> and <a href=""http://www.cfinsider.com/"" rel=""nofollow"">Jason Delmore</a> for their help.</p>

<p>As Leigh has suggested I had to make use of Bouncy Castle, the light weight API and the Rijndael cipher engine there in.</p>

<p>I ended up with a function to create an rijndael cipher and functions to encrypt and decrypt a string with a key and ivsalt.</p>

<pre><code>&lt;cfcomponent displayname=""Bounce Castle Encryption Component"" hint=""This provides bouncy castle encryption services"" output=""false""&gt;

&lt;cffunction name=""createRijndaelBlockCipher"" access=""private""&gt;
    &lt;cfargument name=""key"" type=""string"" required=""true"" &gt;
    &lt;cfargument name=""ivSalt"" type=""string"" required=""true"" &gt;
    &lt;cfargument name=""bEncrypt"" type=""boolean"" required=""false"" default=""1""&gt;
    &lt;cfargument name=""blocksize"" type=""numeric"" required=""false"" default=256&gt;
    &lt;cfscript&gt;
    // Create a block cipher for Rijndael
    var cryptEngine = createObject(""java"", ""org.bouncycastle.crypto.engines.RijndaelEngine"").init(arguments.blocksize);

    // Create a Block Cipher in CBC mode
    var blockCipher = createObject(""java"", ""org.bouncycastle.crypto.modes.CBCBlockCipher"").init(cryptEngine);

    // Create Padding - Zero Byte Padding is apparently PHP compatible.
    var zbPadding = CreateObject('java', 'org.bouncycastle.crypto.paddings.ZeroBytePadding').init();

    // Create a JCE Cipher from the Block Cipher
    var cipher = createObject(""java"", ""org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher"").init(blockCipher,zbPadding);

    // Create the key params for the cipher     
    var binkey = binarydecode(arguments.key,""hex"");
    var keyParams = createObject(""java"", ""org.bouncycastle.crypto.params.KeyParameter"").init(BinKey);

    var binIVSalt = Binarydecode(ivSalt,""hex"");
    var ivParams = createObject(""java"", ""org.bouncycastle.crypto.params.ParametersWithIV"").init(keyParams, binIVSalt);

    cipher.init(javaCast(""boolean"",arguments.bEncrypt),ivParams);

    return cipher;
    &lt;/cfscript&gt;
&lt;/cffunction&gt;

&lt;cffunction name=""doEncrypt"" access=""public"" returntype=""string""&gt;
    &lt;cfargument name=""message"" type=""string"" required=""true""&gt;
    &lt;cfargument name=""key"" type=""string"" required=""true""&gt;
    &lt;cfargument name=""ivSalt"" type=""string"" required=""true""&gt;

    &lt;cfscript&gt;
    var cipher = createRijndaelBlockCipher(key=arguments.key,ivSalt=arguments.ivSalt);
    var byteMessage = arguments.message.getBytes();
    var outArray = getByteArray(cipher.getOutputSize(arrayLen(byteMessage)));
    var bufferLength = cipher.processBytes(byteMessage, 0, arrayLen(byteMessage), outArray, 0);
    var cipherText = cipher.doFinal(outArray,bufferLength);

    return toBase64(outArray);
    &lt;/cfscript&gt;
&lt;/cffunction&gt;


&lt;cffunction name=""doDecrypt"" access=""public"" returntype=""string""&gt;
    &lt;cfargument name=""message"" type=""string"" required=""true""&gt;
    &lt;cfargument name=""key"" type=""string"" required=""true""&gt;
    &lt;cfargument name=""ivSalt"" type=""string"" required=""true""&gt;

    &lt;cfscript&gt;
    var cipher = createRijndaelBlockCipher(key=arguments.key,ivSalt=arguments.ivSalt,bEncrypt=false);
    var byteMessage = toBinary(arguments.message);
    var outArray = getByteArray(cipher.getOutputSize(arrayLen(byteMessage)));
    var bufferLength = cipher.processBytes(byteMessage, 0, arrayLen(byteMessage), outArray, 0);
    var originalText = cipher.doFinal(outArray,bufferLength);

    return createObject(""java"", ""java.lang.String"").init(outArray);
    &lt;/cfscript&gt;
&lt;/cffunction&gt;

&lt;cfscript&gt;
function getByteArray(someLength)
{
    byteClass = createObject(""java"", ""java.lang.Byte"").TYPE;
    return createObject(""java"",""java.lang.reflect.Array"").newInstance(byteClass, someLength);
}
&lt;/cfscript&gt;

&lt;/cfcomponent&gt;
</code></pre>

<p>The doEncrypt and doDecrypt functions are publically visible, but not the function that creates the rijndael cipher. The encryption and decryption functions take a string, key and ivSalt returning an encrypted or decrypted string respectively.</p>

<p>The createRijndaelBlockCipher takes a key, ivSalt, a boolean to state whether the cipher will be used to encrypt or decrypt and the block size, although the block size is defaulted to 256 bits. The function is fairly well commented so it should make sense.</p>

<p>The UDF at the bottom (special thanks to Jason Delmore for that nugget) ensures that ColdFusion correctly creates a byte array for the decryption.  Some other ways of creating byte arrays just don't work or end up with inconsistent results in decryption or throw pad buffer corrupt errors.</p>

<p>That's about it really. It took far too much effort, when the standard AES encryption uses 128bit blocks and 128 Bit Keys are for classified up to SECRET, 192-bit or higher for TOP-SECRET. 256bit blocks and 256bit keys are just a bit over the top. Just because you can doesn't mean you should.  </p>

<p>Please do remember that MCRYPT_RIJNDAEL_256 is the block size and not the encryption level. The encryption level is set by the strength of key that you pass into mcrypt_encrypt and increasing the block size does not increase the encryption strength.</p>
","1419","<php><encryption><coldfusion><aes><rijndael>","0","3","2","2016-12-02 19:03:45","5876614","7","2","-1","","2017-05-23 11:53:01","2011-04-27 17:27:49",""
"6156839","Is my C# RSA/AES/salt/IV best practices approach missing anything?","<p>While I'm no cryptographer, I do consider myself mostly up to date on the best practices regarding [a]symmetric encryption, hashes, and crypto random number generation. I've searched, and found, many posts, both here on SO, and elsewhere, relating to the persistance of encrypted data, salt, and IV. What I'm asking for, is a look over of what I'm doing, to make sure that the pieces I'm putting together, are put together correctly, i.e. securely. Here's my plan:</p>

<p>In C#, I'm using RSACryptoServiceProvider to generate a nice, large, keypair of 4096 bits. To persist to disk/database, I'm using the ToXmlString(true) method which includes the private key info. I then encrypt the entire Xml document with AES as described here: <a href=""http://msdn.microsoft.com/en-us/library/sb7w85t6(v=VS.90).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/sb7w85t6(v=VS.90).aspx</a>, using a key derived from Rfc2898DeriveBytes using 10,000 rounds and 64 bits of salt generated from RNGCryptoServiceProvider. But now the issues is, storing the salt, as well as the IV. I know the salt can be public, and I'm fairly sure that the IV can be too. So, the most simple way to do things seems to be to shove them into a plain text Xml document, along with the encrypted Xml and be done with it.</p>

<p>Anything at all I'm missing?</p>

<p>Edit0: Yes the IV need not be secret: <a href=""http://www.w3.org/TR/xmlenc-core/#sec-Nonce"" rel=""nofollow"">http://www.w3.org/TR/xmlenc-core/#sec-Nonce</a>.</p>

<p>Edit1: The salt is now produced from the password (still using 10k rounds after padding to a minimum of 64 bits), so it is not persisted separately. The IV is prefixed to the CipherValue automatically.</p>
","<p>The IV and salt should be secure random numbers and may be stored publicly. The iteration count may be stored publicly as well, although it is normally hard coded. Be careful that you keep an upper bound on the iteration count or you may be susceptible to denial of service attacks.</p>

<p>So basically you are doing OK. If encrypting XML I would keep to the XML-encryption specifications, using (the proposed) GCM mode encryption if it is available. Make sure you check <em>all the parameters</em> when decrypting though.</p>
","1409","<rsa><aes><salt><rijndael>","2","0","1","2012-12-30 00:06:47","","7","2","348375","","2011-05-31 16:26:46","2011-05-27 19:29:32",""
"6452091","How to protect the encryption key from reverse engineering?","<p>My software is using AES Rijndael. </p>

<p>I am using a SHA-256 hash to generate a key from a string with an arbitrary length, and then passing this as both the private and public key since in this instance I do not need to differentiate between the two.</p>

<p>How do I protect my key from being hacked out of the executable? </p>

<p>I know not to use a literal but instead generate the key at runtime with some predetermined steps, but all the same the key will still be in memory right before its sent on to the AES initialization function and so can quite easily be retrieved then. </p>

<p>AES is obviously very secure, but what good does that do me if someone breaks the executable instead?</p>

<p>Is there some common practise when solving this problem?</p>
","<p>This can't be done. This is the basic problem with e.g. DRM scheme's on PC's: they need to have the key in memory, so it can be extracted. You can maybe obscure it while it is not in use, but that's about it. And if your application is popular and distributed, then somebody <em>will</em> crack you delicious scheme. That's why some companies use dongles or TPM chips for high value applications.</p>
","1407","<security><aes><encryption-symmetric><rijndael>","2","5","2","2013-12-02 07:54:25","6487666","2","","426242","","2013-12-02 07:54:25","2011-06-23 09:41:18",""
"6452091","How to protect the encryption key from reverse engineering?","<p>My software is using AES Rijndael. </p>

<p>I am using a SHA-256 hash to generate a key from a string with an arbitrary length, and then passing this as both the private and public key since in this instance I do not need to differentiate between the two.</p>

<p>How do I protect my key from being hacked out of the executable? </p>

<p>I know not to use a literal but instead generate the key at runtime with some predetermined steps, but all the same the key will still be in memory right before its sent on to the AES initialization function and so can quite easily be retrieved then. </p>

<p>AES is obviously very secure, but what good does that do me if someone breaks the executable instead?</p>

<p>Is there some common practise when solving this problem?</p>
","<p>There is something - very complex in mathematical theory - called ""whitebox cryptography"". In this case, the AES algorithm is modified in a way, that it builds up the secret during encryption. I do not know exactly, how this is achieved, but this one does not need to have a initialized secret, but the secret is part of the algorithm.
An attacker might see, that your AES implementation is a bit ""different"" but at no time in execution the key is visible in memory. The only chance an attacker will have, is to copy the whole whitebox code but it is really hard to reverse engineer this - he would just be able to use it. Anyway depending on the way you use the AES, this might be enough to break in.</p>
","1407","<security><aes><encryption-symmetric><rijndael>","2","3","2","2013-12-02 07:54:25","6487666","2","","426242","","2013-12-02 07:54:25","2011-06-23 09:41:18",""
"30479266","Encrypt using Rijndael in SQL and decrypt in C#","<p>I need to use Rijndael encryption to encrypt a column. Currently I'm using C# code for both encryption and decryption. Currently I read records from a file using SQL Server Integration Services. The records are send to the column that are subsequently encrypted by a script. This takes a lot of time for files with more than 1000 records.</p>

<p>Can Rijndael encryption be achieved in SQL Server itself? When I need to show decrypted data on the screen, could I use Rijndael decryption of the that same data using a C# defined decryption routine?</p>
","<p>The Answer to your Question is Yes! and <a href=""http://www.codeproject.com/Articles/15296/SQL-Encryption-and-Decryption-Library-Using-Rijnda"" rel=""nofollow"">here is how</a></p>

<p>The link provides the files that you have to build and then register with SQL server and then install its methods into SQL server. Author has well explained the steps.</p>
","1401","<c#><sql-server><encryption><rijndael>","0","0","1","2015-12-29 18:38:00","","1","","589259","","2015-05-27 23:26:55","2015-05-27 10:03:34",""
"5863628","Encryption function gives different output on windows and unix","<p>I have an encryption tool written in C# that take a string as input.
When i run the compiled exe file on my windows machine i get an output that is different from when i run it on the remote UNIX server using mono.</p>

<p>Here is an example:</p>

<p>Windows:</p>

<pre><code>""encrypt.exe 01/01""
Output:
eR4et6LR9P19BfFnhGwPfA==
</code></pre>

<p>Unix:</p>

<pre><code>""mono encrypt.exe 01/01""
Output:
Pa8pJCYBN7+U+R705TFq7Q==
</code></pre>

<p>I even tried to put the input value in the script and then compile and run it again, and i got the same results.</p>

<p>The decrypt function is located on a remote web service and uses hard coded key and IV values (I'm using those values to encrypt),
Decryption output:</p>

<pre><code>Input (String generated on windows):
eR4et6LR9P19BfFnhGwPfA==
Output:
01/01

Input (String generated on Unix):
Pa8pJCYBN7+U+R705TFq7Q==
Output:
????1
</code></pre>

<p>This is the encryption function:</p>

<pre><code>string text = args[0];
byte[] clearData = Encoding.Unicode.GetBytes(text);
PasswordDeriveBytes bytes = new PasswordDeriveBytes(password, new byte[] { 0x19, 0x76, 0x61, 110, 0x20, 0x4d, 0x65, 100, 0x76, 0x65, 100, 0x65, 0xf6 });
string a = Convert.ToBase64String(Encrypt(clearData, bytes.GetBytes(0x20), bytes.GetBytes(0x10)));
Console.Write(a);

public static byte[] Encrypt(byte[] clearData, byte[] Key, byte[] IV)
{
    MemoryStream stream = new MemoryStream();
    Rijndael rijndael = Rijndael.Create();
    rijndael.Key = Key;
    rijndael.IV = IV;
    CryptoStream stream2 = new CryptoStream(stream, rijndael.CreateEncryptor(), CryptoStreamMode.Write);
    stream2.Write(clearData, 0, clearData.Length);
    stream2.Close();
    return stream.ToArray();
}
</code></pre>

<p>This is the decryption function (i cannot make changes to this):</p>

<pre><code>byte[] cipherData = Convert.FromBase64String(encryptedString);
PasswordDeriveBytes bytes2 = new PasswordDeriveBytes(password, new byte[] { 0x19, 0x76, 0x61, 110, 0x20, 0x4d, 0x65, 100, 0x76, 0x65, 100, 0x65, 0xf6 });
byte[] buffer2 = Decrypt(cipherData, bytes2.GetBytes(0x20), bytes2.GetBytes(0x10));
string output = Encoding.Unicode.GetString(buffer2);
Console.Write(output); 

public static byte[] Decrypt(byte[] cipherData, byte[] Key, byte[] IV)
{
        MemoryStream stream = new MemoryStream();
        Rijndael rijndael = Rijndael.Create();
        rijndael.Key = Key;
        rijndael.IV = IV;
        CryptoStream stream2 = new CryptoStream(stream, rijndael.CreateDecryptor(), CryptoStreamMode.Write);
        stream2.Write(cipherData, 0, cipherData.Length);
        stream2.Close();
        return stream.ToArray();
}
</code></pre>
","<p>The problem in this question isn't what you are dealing with, but looking at the difference in results, it appears padding was a concern, so you may want to look at some of the responses in this question, but this answer may help resolve your problem.</p>

<p><a href=""http://social.msdn.microsoft.com/forums/en-US/clr/thread/3df8d5aa-ea99-4553-b071-42a2ea406c7f/"" rel=""nofollow"">http://social.msdn.microsoft.com/forums/en-US/clr/thread/3df8d5aa-ea99-4553-b071-42a2ea406c7f/</a></p>

<blockquote>
  <p>You get this problem when the KEY, the
  IV and the ENCRYPTED DATA are not all
  of the correct block sizes and
  'scheme'. The only way to avoid this
  problem is to use the IV and KEY
  generated by the algorithm. You can
  use GenerateIV to get the algorithm to
  generate you an IV. Store this away
  somewhere safe as you will need it.
  Then simply call the encrypt method
  and pass in the data. The algorithm
  will then encrypt the data and set the
  Key property to the newly generated
  key. Store this with your encrypted
  data. That's all there is to it.</p>
</blockquote>

<p>Though it is dated, the response that there are various reasons for the difference, but if you can decrypt then the reasons for the difference may be valid is given here:
<a href=""http://lists.ximian.com/pipermail/mono-list/2006-November/033456.html"" rel=""nofollow"">http://lists.ximian.com/pipermail/mono-list/2006-November/033456.html</a></p>

<p>So, if you can encrypt on one and decrypt on the other (are you able to do this?) then what difference does it make if the results are different?</p>
","1370","<c#><.net><encryption><mono><rijndael>","7","1","3","2013-03-03 07:44:45","","1","1","41956","","2013-03-03 07:44:45","2011-05-02 23:37:36",""
"5863628","Encryption function gives different output on windows and unix","<p>I have an encryption tool written in C# that take a string as input.
When i run the compiled exe file on my windows machine i get an output that is different from when i run it on the remote UNIX server using mono.</p>

<p>Here is an example:</p>

<p>Windows:</p>

<pre><code>""encrypt.exe 01/01""
Output:
eR4et6LR9P19BfFnhGwPfA==
</code></pre>

<p>Unix:</p>

<pre><code>""mono encrypt.exe 01/01""
Output:
Pa8pJCYBN7+U+R705TFq7Q==
</code></pre>

<p>I even tried to put the input value in the script and then compile and run it again, and i got the same results.</p>

<p>The decrypt function is located on a remote web service and uses hard coded key and IV values (I'm using those values to encrypt),
Decryption output:</p>

<pre><code>Input (String generated on windows):
eR4et6LR9P19BfFnhGwPfA==
Output:
01/01

Input (String generated on Unix):
Pa8pJCYBN7+U+R705TFq7Q==
Output:
????1
</code></pre>

<p>This is the encryption function:</p>

<pre><code>string text = args[0];
byte[] clearData = Encoding.Unicode.GetBytes(text);
PasswordDeriveBytes bytes = new PasswordDeriveBytes(password, new byte[] { 0x19, 0x76, 0x61, 110, 0x20, 0x4d, 0x65, 100, 0x76, 0x65, 100, 0x65, 0xf6 });
string a = Convert.ToBase64String(Encrypt(clearData, bytes.GetBytes(0x20), bytes.GetBytes(0x10)));
Console.Write(a);

public static byte[] Encrypt(byte[] clearData, byte[] Key, byte[] IV)
{
    MemoryStream stream = new MemoryStream();
    Rijndael rijndael = Rijndael.Create();
    rijndael.Key = Key;
    rijndael.IV = IV;
    CryptoStream stream2 = new CryptoStream(stream, rijndael.CreateEncryptor(), CryptoStreamMode.Write);
    stream2.Write(clearData, 0, clearData.Length);
    stream2.Close();
    return stream.ToArray();
}
</code></pre>

<p>This is the decryption function (i cannot make changes to this):</p>

<pre><code>byte[] cipherData = Convert.FromBase64String(encryptedString);
PasswordDeriveBytes bytes2 = new PasswordDeriveBytes(password, new byte[] { 0x19, 0x76, 0x61, 110, 0x20, 0x4d, 0x65, 100, 0x76, 0x65, 100, 0x65, 0xf6 });
byte[] buffer2 = Decrypt(cipherData, bytes2.GetBytes(0x20), bytes2.GetBytes(0x10));
string output = Encoding.Unicode.GetString(buffer2);
Console.Write(output); 

public static byte[] Decrypt(byte[] cipherData, byte[] Key, byte[] IV)
{
        MemoryStream stream = new MemoryStream();
        Rijndael rijndael = Rijndael.Create();
        rijndael.Key = Key;
        rijndael.IV = IV;
        CryptoStream stream2 = new CryptoStream(stream, rijndael.CreateDecryptor(), CryptoStreamMode.Write);
        stream2.Write(cipherData, 0, cipherData.Length);
        stream2.Close();
        return stream.ToArray();
}
</code></pre>
","<p>Perhaps the Issue is that the output is unicode, and the terminal is showing ascii. I commonly see ? in place of misunderstood unicode characters.</p>

<p>Check the Numerical Values of the Byte array, and the quantity.</p>

<p>Ascii is half the quantity of unicode as there are two bytes for each character.</p>
","1370","<c#><.net><encryption><mono><rijndael>","7","0","3","2013-03-03 07:44:45","","1","1","41956","","2013-03-03 07:44:45","2011-05-02 23:37:36",""
"5863628","Encryption function gives different output on windows and unix","<p>I have an encryption tool written in C# that take a string as input.
When i run the compiled exe file on my windows machine i get an output that is different from when i run it on the remote UNIX server using mono.</p>

<p>Here is an example:</p>

<p>Windows:</p>

<pre><code>""encrypt.exe 01/01""
Output:
eR4et6LR9P19BfFnhGwPfA==
</code></pre>

<p>Unix:</p>

<pre><code>""mono encrypt.exe 01/01""
Output:
Pa8pJCYBN7+U+R705TFq7Q==
</code></pre>

<p>I even tried to put the input value in the script and then compile and run it again, and i got the same results.</p>

<p>The decrypt function is located on a remote web service and uses hard coded key and IV values (I'm using those values to encrypt),
Decryption output:</p>

<pre><code>Input (String generated on windows):
eR4et6LR9P19BfFnhGwPfA==
Output:
01/01

Input (String generated on Unix):
Pa8pJCYBN7+U+R705TFq7Q==
Output:
????1
</code></pre>

<p>This is the encryption function:</p>

<pre><code>string text = args[0];
byte[] clearData = Encoding.Unicode.GetBytes(text);
PasswordDeriveBytes bytes = new PasswordDeriveBytes(password, new byte[] { 0x19, 0x76, 0x61, 110, 0x20, 0x4d, 0x65, 100, 0x76, 0x65, 100, 0x65, 0xf6 });
string a = Convert.ToBase64String(Encrypt(clearData, bytes.GetBytes(0x20), bytes.GetBytes(0x10)));
Console.Write(a);

public static byte[] Encrypt(byte[] clearData, byte[] Key, byte[] IV)
{
    MemoryStream stream = new MemoryStream();
    Rijndael rijndael = Rijndael.Create();
    rijndael.Key = Key;
    rijndael.IV = IV;
    CryptoStream stream2 = new CryptoStream(stream, rijndael.CreateEncryptor(), CryptoStreamMode.Write);
    stream2.Write(clearData, 0, clearData.Length);
    stream2.Close();
    return stream.ToArray();
}
</code></pre>

<p>This is the decryption function (i cannot make changes to this):</p>

<pre><code>byte[] cipherData = Convert.FromBase64String(encryptedString);
PasswordDeriveBytes bytes2 = new PasswordDeriveBytes(password, new byte[] { 0x19, 0x76, 0x61, 110, 0x20, 0x4d, 0x65, 100, 0x76, 0x65, 100, 0x65, 0xf6 });
byte[] buffer2 = Decrypt(cipherData, bytes2.GetBytes(0x20), bytes2.GetBytes(0x10));
string output = Encoding.Unicode.GetString(buffer2);
Console.Write(output); 

public static byte[] Decrypt(byte[] cipherData, byte[] Key, byte[] IV)
{
        MemoryStream stream = new MemoryStream();
        Rijndael rijndael = Rijndael.Create();
        rijndael.Key = Key;
        rijndael.IV = IV;
        CryptoStream stream2 = new CryptoStream(stream, rijndael.CreateDecryptor(), CryptoStreamMode.Write);
        stream2.Write(cipherData, 0, cipherData.Length);
        stream2.Close();
        return stream.ToArray();
}
</code></pre>
","<p>Have you checked your test string for new lines?  A Windows test string would have a carriage-return + line-feeds, while the Unix string would only have line-feed.</p>
","1370","<c#><.net><encryption><mono><rijndael>","7","0","3","2013-03-03 07:44:45","","1","1","41956","","2013-03-03 07:44:45","2011-05-02 23:37:36",""
"40012839","Is Asp.net identity hashing Secured?","<p>I have referred the following sites for the Rijndael and Asp.net hashing implementations in the following url.</p>

<ol>
<li>Rijndael - <a href=""https://stackoverflow.com/questions/6482883/how-to-generate-rijndael-key-and-iv-using-a-passphrase"">How to generate Rijndael KEY and IV using a passphrase?</a></li>
<li>Asp.net hashing - <a href=""https://stackoverflow.com/questions/20621950/asp-net-identity-default-password-hasher-how-does-it-work-and-is-it-secure"">ASP.NET Identity default Password Hasher, how does it work and is it secure?</a></li>
</ol>

<p>In both the implementation, 
The following is used to get the random bytes for the password.
<strong>RijnDael</strong></p>

<pre><code>Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, SALT);
</code></pre>

<p><strong>Asp.net Identity hashing</strong></p>

<pre><code>Rfc2898DeriveBytes bytes = new Rfc2898DeriveBytes(providedPassword, salt, HasingIterationsCount)
</code></pre>

<p>After the above code, RijnDael applies the encryption for the returned bytes.
But asp.net identity copy the result as it is with the salt byte array and return the hashed keys.</p>

<p>Here I had a confusion. RijnDael and Asp.net identity hashing uses the same <strong>Rfc2898DeriveBytes</strong>.</p>

<p>When RijnDael can decrypt the encrypted keys (which is done with the help of Rfc2898DeriveBytes), why can we do to decrypt the Asp.net Identity hashed keys?</p>

<p>Is there any possibility to do that? 
Is Asp.net identity secured?</p>
","<p><strong>Yes, ASP.NET's password hashing method is secure.</strong></p>

<p>In the example you provided, the user is using an <strong>encryption</strong> technique known as <em>Advanced Encryption Standard</em> (AES, also known as Rijndael). This is why the secret can be decrypted.</p>

<p>The user only uses the <code>Rfc2898DeriveBytes</code> class in order to get a <a href=""https://en.wikipedia.org/wiki/Key_%28cryptography%29"" rel=""nofollow"">key</a> and an <a href=""https://en.wikipedia.org/wiki/Initialization_vector"" rel=""nofollow"">initialisation vector</a>.</p>

<p>The class is not used to hash the secret message. The encryption is what hides the message.</p>

<p>ASP.NET uses the <code>Rfc2898DeriveBytes</code> class to hash a password. This procedure cannot be reversed.</p>
","1358","<c#><asp.net><encryption><hash><rijndael>","0","1","1","2016-10-13 13:36:40","40022575","6","1","-1","","2017-05-23 10:31:23","2016-10-13 05:19:01",""
"29707840","C# Length of data to decrypt is invalid","<p>There are quite a lot of similar questions on SO about this but ""none"" match my problem.</p>

<p>I a creating a file which is filled with encrypted random bytes. Then within this file at a specific location I write a few encrypted bytes. When I attempt to read in that section of bytes I get the ""Length of data to decrypt is invalid"".</p>

<p>This is the Encrypt and Decrypt Methods (found at some point on SO)</p>

<pre><code> private static readonly byte[] SALT = new byte[] { 0x26, 0xdc, 0xff, 0x00, 0xad, 0xed, 0x7a, 0xee, 0xc5, 0xfe, 0x07, 0xaf, 0x4d, 0x08, 0x22, 0x3c };
        //TODO: The SALT needs to be derived and unique for each user!

        internal  byte[] Encrypt(byte[] plain)
        {
            string password = Properties.Settings.Default.PasswordOne;
            MemoryStream memoryStream;
            CryptoStream cryptoStream;
            Rijndael rijndael = Rijndael.Create();
            Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, SALT);
            rijndael.Key = pdb.GetBytes(32);
            rijndael.IV = pdb.GetBytes(16);
            memoryStream = new MemoryStream();
            cryptoStream = new CryptoStream(memoryStream, rijndael.CreateEncryptor(), CryptoStreamMode.Write);
            cryptoStream.Write(plain, 0, plain.Length);
            cryptoStream.Close();
            return memoryStream.ToArray();
        }

        internal  byte[] Decrypt(byte[] cipher)
        {
            string password = Properties.Settings.Default.PasswordOne;
            MemoryStream memoryStream;
            CryptoStream cryptoStream;
            Rijndael rijndael = Rijndael.Create();
            Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, SALT);
            rijndael.Key = pdb.GetBytes(32);
            rijndael.IV = pdb.GetBytes(16);
            memoryStream = new MemoryStream();
            cryptoStream = new CryptoStream(memoryStream, rijndael.CreateDecryptor(), CryptoStreamMode.Write);
            cryptoStream.Write(cipher, 0, cipher.Length);
            cryptoStream.Close();
            return memoryStream.ToArray();
        }
</code></pre>

<p>I save the new data within the first file using this</p>

<pre><code> private void InsertDEFT2NameLength(FileSystemEncryption fse, string Deft2FileName, FileStream fs, StreamWriter sw)
        {

            string deft2NameLength = ""0"";                                       // init the length
            if (DrivesLog != null) DrivesLog(""Converting DEFT2 Name to Bytes"");
            byte[] bdeft2Name = GetBytes(Deft2FileName);                        // convert filename to bytes
            if (DrivesLog != null) DrivesLog(""Encrypting DEFT2 Name"");
            byte[] ebdeft2Name = fse.Encrypt(bdeft2Name);                       // Encrypt
            if (DrivesLog != null) DrivesLog(""Getting Length of Encrypted DEFT2 Name"");
            long ebdeft2NameLength = ebdeft2Name.LongLength;                    // Get Length of the Encrypted Bytes as a long
            if (DrivesLog != null) DrivesLog(""Converting DEFT2 Name Length to String"");
            string sebdeft2NameLength = ebdeft2NameLength.ToString() + ""!"";     // Convert Length to string Add Exclamation so we know when we have read the full length
            if (DrivesLog != null) DrivesLog(""Converting DEFT2 Name Length to Bytes"");
            byte[] bsebdeft2NameLength = GetBytes(sebdeft2NameLength);          // Convert length string to bytes
            if (DrivesLog != null) DrivesLog(""Encrypting DEFT2 Name Length"");
            byte[] ebsebdeft2NameLength = fse.Encrypt(bsebdeft2NameLength);     // Encrypt
            if (DrivesLog != null) DrivesLog(""Converting Encrypted DEFT2 Name Length to String"");
            deft2NameLength = GetString(ebsebdeft2NameLength);                  // Convert to string

            if (DrivesLog != null) DrivesLog(""Seeking to Correct Location"");
            long startPos = GenerateDEFT2LengthStartPosition();
            fs.Seek(startPos, SeekOrigin.Current);    // Seek to correct location
            if (DrivesLog != null) DrivesLog(""New Position "" + startPos.ToString(""N0""));
            if (DrivesLog != null) DrivesLog(""Writing Encrypted Name Length to New Position"");
            sw.Write(deft2NameLength);                                          // Write the Encrypted length
            fs.Flush();                                                         // Flush the buffer immediately
        }
</code></pre>

<p>I attempt to re-read in the encrypted data at that location using this method:</p>

<pre><code>private long ReadDEFT2Len(string DEFT, long lenPos, FileSystemEncryption fse)
        {
            if (DrivesLog != null) DrivesLog(""Reading DEFT2 Name Length"");
            StringBuilder sb = new StringBuilder();

            FileStream fs = null;
            StreamReader sr = null;

            try
            {
                fs = new FileStream(DEFT, FileMode.Open, FileAccess.Read, FileShare.Read);
                sr = new StreamReader(fs, Encoding.Unicode);

                char[] C = new char[101];
                fs.Seek(lenPos, SeekOrigin.Begin);
                sr.Read(C, 0, 100);

                string sC = new string(C);
                byte[] bsC = GetBytes(sC);

                byte[] dRes = fse.Decrypt(bsC);  // This is where the Exception is thrown.
                foreach(char ic in GetString(dRes))
                {
                    if (ic == '!') break;
                    sb.Append(ic.ToString());
                }

                sr.Close();
                fs.Close();

                if (DrivesLog != null) DrivesLog(""DEFT2 Name Length = "" + sb.ToString());
                return long.Parse(sb.ToString());
            }
            catch (Exception ex)
            {
                if (DrivesLog != null) DrivesLog(""ERROR Reading DEFT2 Name Length "" + ex.Message);
                if (sr != null) sr.Close();
                if (fs != null) fs.Close();
                return -1;
            }

        }
</code></pre>

<p>I have saved and loaded using Unicode Encoding so that is not the problem.. any ideas on why this exception is being thrown and how to resolve it?</p>
","<p>The Rijndael cipher only works on specific block sizes (16, 24, or 32 bytes).  You're getting an exception here because the length of data you're decrypting is not an exact multiple of the block size.</p>
","1351","<c#><encryption><unicode><filestream><rijndael>","0","1","1","2015-04-17 20:08:31","29708472","1","0","","","","2015-04-17 19:28:01",""
"7809566","C Libmcrypt cannot encrypt/decrypt successfully","<p>I am working with libmcrypt in c and attempting to implement a simple test of encryption and decryption using rijndael-256 as the algorithm of choice. I have mirrored this test implementation pretty closely to the man pages examples with rijndael as opposed to their chosen algorithms. When compiled with the string gcc -o encryption_test main.c -lmcrypt, the following source code produces output similar to:
The encrypted message buffer contains j��A��8   �qj��%`��jh���=ZЁ�j
The original string was ��m""�C��D�����Y�G�v6��s��zh�</p>

<p>Obviously, the decryption part is failing, but as it is just a single function call it leads me to believe the encryption scheme is not behaving correctly as well. I have several questions for the libmcrypt gurus out there if you could point me in the right direction.</p>

<p>First, what is causing this code to produce this broken output?</p>

<p>Second, when dealing with mandatory fixed-sizes such as the key size and block-size, for example a 256-bit key does the function expect 32-bytes of key + a trailing null byte, 31-bytes of key + a trailing null byte, or 32-bytes of key with the 33rd byte being irrelevant? The same question holds true for block-size as well.</p>

<p>Lastly, one of the examples I noted used mhash to generate a hash of the key-text to supply to the encryption call, this is of course preferable but it was commented out and linking in mhash seems to fail. What is the accepted way of handling this type of key-conversion when working with libmcrypt? I have chosen to leave any such complexities out as to prevent further complicating already broken code, but I would like to incorporate this into the final design. Below is the source code in question:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mcrypt.h&gt;

int main(int argc, char *argv[])
{
MCRYPT mfd;
char *key;
char *plaintext;
char *IV;
unsigned char *message, *buffered_message, *ptr;
int i, blocks, key_size = 32, block_size = 32;

message = ""Test Message"";

/** Buffer message for encryption */    
blocks              = (int) (strlen(message) / block_size) + 1;
buffered_message    = calloc(1, (blocks * block_size));

key = calloc(1, key_size);
strcpy(key, ""&amp;*GHLKPK7G1SD4CF%6HJ0(IV#X6f0(PK"");

mfd = mcrypt_module_open(MCRYPT_RIJNDAEL_256, NULL, ""cbc"", NULL);

if(mfd == MCRYPT_FAILED)
{
    printf(""Mcrypt module open failed.\n"");
    return 1;
}

/** Generate random IV */
srand(time(0));
IV = malloc(mcrypt_enc_get_iv_size(mfd));
for(i = 0; i &lt; mcrypt_enc_get_iv_size(mfd); i++)
{
    IV[i] = rand();
}

/** Initialize cipher with key and IV */
i = mcrypt_generic_init(mfd, key, key_size, IV);
if(i &lt; 0)
{
    mcrypt_perror(i);
    return 1;
}

strncpy(buffered_message, message, strlen(message));    
mcrypt_generic(mfd, buffered_message, block_size);
printf(""The encrypted message buffer contains %s\n"", buffered_message);
mdecrypt_generic(mfd, buffered_message, block_size);
printf(""The original string was %s\n"", buffered_message);
mcrypt_generic_deinit(mfd);
mcrypt_module_close(mfd);
return 0;
}
</code></pre>
","<p>You need to re-initialize the descriptor <code>mfd</code> for decryption, you cannot use the same descriptor for both encryption and decryption.</p>
","1329","<c><encryption><mcrypt><rijndael>","1","1","1","2011-10-18 15:44:22","7809684","0","","20270","","2011-10-18 15:44:22","2011-10-18 15:14:00",""
"29694238","What is the equivalent of this encryption and decryption code in Scala?","<pre><code>$KEY = ""Your KEY"";
$IV = ""Your IV"";

function addpadding($string, $blocksize = 32)
{
    $len = strlen($string);
    $pad = $blocksize - ($len % $blocksize);
    $string .= str_repeat(chr($pad), $pad);
    return $string;
}

function strippadding($string)
{
    $slast = ord(substr($string, -1));
    $slastc = chr($slast);
    $pcheck = substr($string, -$slast);
    if(preg_match(""/$slastc{"".$slast.""}/"", $string)){
        $string = substr($string, 0, strlen($string)-$slast);
        return $string;
    } else {
        return false;
    }
}

function encrypt($string = """")
{
    global $KEY,$IV;
    $key = base64_decode($KEY);
    $iv = base64_decode($IV);
    return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key,  addpadding($string), MCRYPT_MODE_CBC, $iv));
}

function decrypt($string = """")
{
    global $KEY,$IV;
    $key = base64_decode($KEY);
    $iv = base64_decode($IV);
    $string = base64_decode($string);
    return strippadding(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $string, MCRYPT_MODE_CBC, $iv));
}
</code></pre>

<p><strong>EDIT</strong></p>

<p>I'm looking for the exact implementation not just references to libraries so I posted the answer by myself. I'm coding in Scala but at first I asked for Java to increase the chance of getting an answer as quickly as possible, so the implementation is in Scala language.</p>
","<p>Thanks to the comments, here is the Scala implementation which works exactly the same as the above PHP code:</p>

<pre><code>import org.apache.commons.codec.binary.Base64
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher
import org.bouncycastle.crypto.modes.CBCBlockCipher
import org.bouncycastle.crypto.engines.RijndaelEngine
import org.bouncycastle.crypto.paddings.PKCS7Padding
import org.bouncycastle.crypto.params._

class EncryptionUtil(keyBase64: String, ivBase64: String) {
  private val keyBytes = Base64.decodeBase64(keyBase64)
  private val ivBytes = Base64.decodeBase64(ivBase64)

  def encrypt(message: String): String = {
    val cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new PKCS7Padding());
    val keySize = keyBytes.length;
    val ivAndKey = new ParametersWithIV(new KeyParameter(keyBytes, 0, keySize), ivBytes, 0, keySize);
    cipher.init(true, ivAndKey);
    val messageBytes = message.getBytes(""UTF-8"")
    val encrypted  = new Array[Byte](cipher.getOutputSize(messageBytes.length));
    val oLen = cipher.processBytes(messageBytes, 0, messageBytes.length, encrypted, 0);
    cipher.doFinal(encrypted, oLen);
    Base64.encodeBase64String(encrypted)
  }

  def decrypt(inputBase64: String): String = {
    val cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new PKCS7Padding());
    val keySize = keyBytes.length;
    val ivAndKey = new ParametersWithIV(new KeyParameter(keyBytes, 0, keySize), ivBytes, 0, keySize);
    cipher.init(false, ivAndKey);
    val messageBytes = Base64.decodeBase64(inputBase64)
    val decrypted  = new Array[Byte](cipher.getOutputSize(messageBytes.length));
    val oLen = cipher.processBytes(messageBytes, 0, messageBytes.length, decrypted, 0);
    cipher.doFinal(decrypted, oLen);

    val zeroTerminationIndex = decrypted.indexOf(0)
    new String(decrypted, 0, zeroTerminationIndex, ""UTF-8"")
  }
}

object EncryptionUtil {
  def apply(keyBase64: String, ivBase64: String) = new EncryptionUtil(keyBase64, ivBase64)
}
</code></pre>

<p>It uses bouncycastle which can be added to build.sbt:</p>

<pre><code>libraryDependencies += ""org.bouncycastle"" % ""bcprov-jdk15on"" % ""1.52""
</code></pre>
","1320","<java><php><scala><encryption><rijndael>","-2","1","1","2015-04-17 14:08:52","","5","","441889","","2015-04-17 14:08:52","2015-04-17 08:37:02",""
"17062511","Is the difference between binary and hex-string representations of my key the reason for unexpected output from DCPCrypt?","<p>I'm having trouble encrypting and decrypting some information with the DCP Crypt library. I'm using Delphi XE and the functions posted at <a href=""https://stackoverflow.com/questions/7052219/php-to-delphi-and-back-encryption-decryption-using-rijndael"">PHP to Delphi and back Encryption-Decryption using Rijndael</a>, but it doesn't work.</p>

<p>I think my problem is because the key I'm using is in hex mode instead of binary.</p>

<pre><code>var 
  Key, IV: ansiString;
  Data: ansiString;
begin
  Key := '09CB0785F13CD0D557C0940E72E0DCDC86CDC89769044E95DB51A782E7D996FFF3';
  Iv  := '09CB0785F13CD0D557C0940E72E0DCDC';

  Data := &lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;&lt;MyNode&gt;&lt;Head&gt;&lt;CustNo&gt;...';
</code></pre>

<p>When I use the <code>EncryptData</code> function, must I pass the public key in binary or in hex?</p>

<pre><code> asCryptBody := EncryptData(asXMLBody, Public_Key, Init_vector);
</code></pre>

<p>or </p>

<pre><code> asCryptBody := EncryptData(asXMLBody, HexToStrBin(Public_Key), HexToStrBin(Init_vector));
</code></pre>

<p>where</p>

<pre><code>function StrBinToHex(const s: AnsiString): AnsiString;
var
  i:integer;
begin
  result := '';
  for i := 1 to length(s) do
    result := result + inttohex(Ord(s[i]),1);
end;

function HexToStrBin(const s: AnsiString): AnsiString;
var
  i:integer;
begin
  result := '';
  for i := 1 to (length(s) div 2) do
    result := result + char( strtoint('$'+ copy(s,(i*2)-1,2)) );
end;
</code></pre>

<p>I've tried two ways, but the encryption still differs from PHP encryption.</p>

<p>Maybe the functions HexToStrBin and StrBinToHex are the problem?</p>
","<p>Many thanks to all for your answers.
Now is solved.
The problem was:
- My key and ini.vector is an string with hex values
- Then i must convert the key and the initialization vector from an ansistring with hex value of key to TByte with myself function: StrHexToTBytes
- Before crypt, do not add the padding. 
- Do not base64decode the crypted TBytes result and put it into a string with TEncoding.Default.GetString
- Then for my use i pass this string result to an string with hex values.</p>

<p>As i posted int the titlle, the Delphi version is XE.</p>

<pre><code>function StrHexToTBytes(const Hexstr: AnsiString): TBytes;
var
  i: Integer;
begin
  SetLength(Result, Length(Hexstr) div 2);
  for i:=0 to (Length(Hexstr) div 2 - 1) do
     Result[i]:= StrToInt('$' + Copy(Hexstr, (i * 2) + 1, 2));
end;

function EncryptData(const Data, AHexKey, AHexIv: AnsiString): Ansistring;
var
  cipher: TDCP_rijndael;
  key, iv, src, dest : TBytes;
  slen: integer;
begin

  /// La clau pública és una cadena de valors Hexadecimals, i s'ha de convertir a un array de Bytes.
  /// The Key and IV are an Hex ansistring, and must converted to TBytes
  key  := StrHexToTBytes(AHexKey);
  iv   := StrHexToTBytes(AHexIv);

  /// Les dades estan en una cadena de caracters i s'ha de passar directament a un array de bytes
  /// The Data is plain text in a string and must converted to TBytes
  src := TEncoding.UTF8.GetBytes(Data);

  cipher := TDCP_rijndael.Create(nil);
  try
    cipher.CipherMode := cmCBC;
    slen := Length(src);

    /// Ull No s'ha de fer cap padding del text rebut!!!
    /// Attention, the pading is not necessary!!!
{
    // Add padding.
    // Resize the Value array to make it a multiple of the block length.
    // If it's already an exact multiple then add a full block of padding.
    slen := Length(src);
    bsize := (cipher.BlockSize div 8);
    pad := bsize - (slen mod bsize);
    Inc(slen, pad);
    SetLength(src, slen);
    for index := pad downto 1 do
    begin
      src[slen - index] := pad;
    end;
}
    SetLength(dest, slen);
    cipher.Init(key[0], 256, @iv[0]); // DCP uses key size in BITS not BYTES
    cipher.Encrypt(src[0], dest[0], slen);

    /// El resultat no s'ha de codificar en base 64, es un binary que només s'ha de passar a Hexadecimal
    ///  The result does'nt must be converted to based 64, is a binary that must be puttd into a string.
//    b64 := Base64EncodeBytes(dest);
//    result := TEncoding.Default.GetString(b64);
    result := TEncoding.Default.GetString(dest);
  finally
    cipher.Free;
  end;
end;
</code></pre>

<p>Now i must adapt the DecryptData function.</p>
","1278","<delphi><binary><hex><delphi-xe><rijndael>","2","1","1","2013-06-13 10:50:27","","5","","-1","","2017-05-23 12:05:29","2013-06-12 09:52:16",""
"42834063","Decrypting byte array with SymmetricAlgorithm and CryptoStream","<p><strong>My encrypting and decrypting methods:</strong></p>

<pre><code>private static SymmetricAlgorithm GetAlgorithm(string password)
{
    using (Rijndael algorithm = Rijndael.Create())
    {
        using (Rfc2898DeriveBytes rdb = new Rfc2898DeriveBytes(password, new byte[]
        {
            0x53, 0x6f, 0x64, 0x69, 0x75, 0x6d, 0x20, 0x43, 0x68, 0x6c, 0x6f, 0x72, 0x69, 0x64, 0x65
        }))
        {
            algorithm.Padding = PaddingMode.ISO10126;
            algorithm.Key = rdb.GetBytes(32);
            algorithm.IV = rdb.GetBytes(16);
        }
        return algorithm;
    }
}

public static byte[] EncryptBytes(byte[] clearBytes, string password)
{
    ICryptoTransform encryptor;
    using (SymmetricAlgorithm algorithm = GetAlgorithm(password))
        encryptor = algorithm.CreateEncryptor();
    using (MemoryStream ms = new MemoryStream())
    using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
    {
        cs.Write(clearBytes, 0, clearBytes.Length);
        cs.FlushFinalBlock();
        return ms.ToArray();
    }
}

public static byte[] DecryptBytes(byte[] cipherBytes, string password)
{
    ICryptoTransform decryptor;
    using (SymmetricAlgorithm algorithm = GetAlgorithm(password))
        decryptor = algorithm.CreateDecryptor();
    using (MemoryStream ms = new MemoryStream())
    using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write))
    {
        cs.Write(cipherBytes, 0, cipherBytes.Length); //here is the exception thrown
        cs.FlushFinalBlock();
        return ms.ToArray();
    }
}
</code></pre>

<p><strong>How i call the methods:</strong></p>

<pre><code>byte[] prev = File.ReadAllBytes(path + sourcefile);
byte[] enc = Encryption.EncryptBytes(prev, password);
byte[] dec = Encryption.DecryptBytes(enc, password);

File.WriteAllBytes(path + targetfile, dec);
</code></pre>

<p>When i try to decrypt the byte array i get the following exception: </p>

<pre><code>System.Security.Cryptography.CryptographicException
Additional information: padding is invalid and cannot be removed
</code></pre>

<p>I already read some possible solutions but none of them solved my problem.
The Key and IV (InitialisationVector) are the same, when i encrypt and decrypt so that's definitely not the reason.</p>
","<p>Corrected methods:</p>

<p>ERROR: you were disposing the <code>Rijndael algorithm</code> in the <code>GetAlgorithm()</code>. This is wrong: it is the caller of <code>GetAlgorithm()</code> that must dispose the <code>algorithm</code> (as you were correctly doing)</p>

<pre><code>private static SymmetricAlgorithm GetAlgorithm(string password)
{
    Rijndael algorithm = Rijndael.Create();

    using (Rfc2898DeriveBytes rdb = new Rfc2898DeriveBytes(password, new byte[]
    {
        0x53, 0x6f, 0x64, 0x69, 0x75, 0x6d, 0x20, 0x43, 0x68, 0x6c, 0x6f, 0x72, 0x69, 0x64, 0x65
    }))
    {
        algorithm.Padding = PaddingMode.ISO10126;
        algorithm.Key = rdb.GetBytes(32);
        algorithm.IV = rdb.GetBytes(16);
    }

    return algorithm;
}
</code></pre>

<p>Small warnings here: you were not disposing the <code>ICryptoTransform</code>.</p>

<pre><code>public static byte[] EncryptBytes(byte[] clearBytes, string password)
{
    using (SymmetricAlgorithm algorithm = GetAlgorithm(password))
    using (ICryptoTransform encryptor = algorithm.CreateEncryptor())
    using (MemoryStream ms = new MemoryStream())
    using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
    {
        cs.Write(clearBytes, 0, clearBytes.Length);
        cs.FlushFinalBlock();
        return ms.ToArray();
    }
}

public static byte[] DecryptBytes(byte[] cipherBytes, string password)
{
    using (SymmetricAlgorithm algorithm = GetAlgorithm(password))
    using (ICryptoTransform decryptor = algorithm.CreateDecryptor())
    using (MemoryStream ms = new MemoryStream())
    using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write))
    {
        cs.Write(cipherBytes, 0, cipherBytes.Length); //here is the exception thrown
        cs.FlushFinalBlock();
        return ms.ToArray();
    }
}
</code></pre>
","1242","<c#><encryption><encryption-symmetric><rijndael>","1","2","1","2017-03-16 12:36:41","42834299","3","","","","","2017-03-16 12:25:33",""
"17876782","Decrypt string with Rijndael return ""System.SecureString"" (as a string) but not the string","<p>I'm using Rijndael Algorithm to encrypt strings (user passwords), but when I decrypt them, it returns me ""System.SecureString"", and not my decrypted password.</p>

<p>I'm using this basic code: </p>

<pre><code>public static string DecryptString(string cipherText, string password)
    {
        byte[] key, iv;
        Rfc2898DeriveBytes rfcDb = new Rfc2898DeriveBytes(password, Encoding.UTF8.GetBytes(password));
        key = rfcDb.GetBytes(16);
        iv = rfcDb.GetBytes(16);

        byte[] cipheredData = Convert.FromBase64String(cipherText);

        RijndaelManaged rijndael = new RijndaelManaged();
        rijndael.Mode = CipherMode.CBC;

        ICryptoTransform decryptor = rijndael.CreateDecryptor(key, iv);
        MemoryStream ms = new MemoryStream(cipheredData);
        CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);

        byte[] plainTextData = new byte[cipheredData.Length];

        int decryptedByteCount = cs.Read(plainTextData, 0, plainTextData.Length);

        ms.Close();
        cs.Close();

        return Encoding.UTF8.GetString(plainTextData, 0, decryptedByteCount);
    }
</code></pre>

<p>The real problem is that it's sending me back ""System.SecureString"", and I can't do anything.</p>

<p>I think it comes from the conversion at the end but I really don't know how to change that (it seems good btw)</p>

<pre><code>return Encoding.UTF8.GetString(plainTextData, 0, decryptedByteCount);
</code></pre>

<p>So if you have an idea or a working code sample, I'm interested.</p>

<p>Have a nice day</p>
","<p>I have implemented rijndael in the past, and here is my version if this is any help:</p>

<pre><code>private static string Encrypt(string plainText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize)
        {
            // Convert strings into byte arrays.
            // Let us assume that strings only contain ASCII codes.
            // If strings include Unicode characters, use Unicode, UTF7, or UTF8 
            // encoding.
            var initVectorBytes = Encoding.ASCII.GetBytes(initVector);
            var saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

            // Convert our plaintext into a byte array.
            // Let us assume that plaintext contains UTF8-encoded characters.
            var plainTextBytes = Encoding.UTF8.GetBytes(plainText);

            // First, we must create a password, from which the key will be derived.
            // This password will be generated from the specified passphrase and 
            // salt value. The password will be created using the specified hash 
            // algorithm. Password creation can be done in several iterations.
            var password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashAlgorithm, passwordIterations);

            // Use the password to generate pseudo-random bytes for the encryption
            // key. Specify the size of the key in bytes (instead of bits).
            var keyBytes = password.GetBytes(keySize / 8);

            // Create uninitialized Rijndael encryption object.

            // It is reasonable to set encryption mode to Cipher Block Chaining
            // (CBC). Use default options for other symmetric key parameters.
            var symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC };

            // Generate encryptor from the existing key bytes and initialization 
            // vector. Key size will be defined based on the number of the key 
            // bytes.
            var encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes);

            // Define memory stream which will be used to hold encrypted data.
            var memoryStream = new MemoryStream();

            // Define cryptographic stream (always use Write mode for encryption).
            var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);

            // Start encrypting.
            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

            // Finish encrypting.
            cryptoStream.FlushFinalBlock();

            // Convert our encrypted data from a memory stream into a byte array.
            var cipherTextBytes = memoryStream.ToArray();

            // Close both streams.
            memoryStream.Close();
            cryptoStream.Close();

            // Convert encrypted data into a base64-encoded string.
            var cipherText = Convert.ToBase64String(cipherTextBytes);

            // Return encrypted string.
            return cipherText;
        }


private static string Decrypt(string cipherText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize)
        {
            // Convert strings defining encryption key characteristics into byte
            // arrays. Let us assume that strings only contain ASCII codes.
            // If strings include Unicode characters, use Unicode, UTF7, or UTF8
            // encoding.
            var initVectorBytes = Encoding.ASCII.GetBytes(initVector);
            var saltValueBytes = Encoding.ASCII.GetBytes(saltValue);

            // Convert our ciphertext into a byte array.
            var cipherTextBytes = Convert.FromBase64String(cipherText);

            // First, we must create a password, from which the key will be 
            // derived. This password will be generated from the specified 
            // passphrase and salt value. The password will be created using
            // the specified hash algorithm. Password creation can be done in
            // several iterations.
            var password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashAlgorithm, passwordIterations);

            // Use the password to generate pseudo-random bytes for the encryption
            // key. Specify the size of the key in bytes (instead of bits).
            var keyBytes = password.GetBytes(keySize / 8);

            // Create uninitialized Rijndael encryption object.
            // It is reasonable to set encryption mode to Cipher Block Chaining
            // (CBC). Use default options for other symmetric key parameters.
            var symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC };

            // Generate decryptor from the existing key bytes and initialization 
            // vector. Key size will be defined based on the number of the key 
            // bytes.
            var decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);

            // Define memory stream which will be used to hold encrypted data.
            var memoryStream = new MemoryStream(cipherTextBytes);

            // Define cryptographic stream (always use Read mode for encryption).
            var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);

            // Since at this point we don't know what the size of decrypted data
            // will be, allocate the buffer long enough to hold ciphertext;
            // plaintext is never longer than ciphertext.
            var plainTextBytes = new byte[cipherTextBytes.Length];

            // Start decrypting.
            var decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);

            // Close both streams.
            memoryStream.Close();
            cryptoStream.Close();

            // Convert decrypted data into a string. 
            // Let us assume that the original plaintext string was UTF8-encoded.
            var plainText = Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);

            // Return decrypted string.   
            return plainText;
        }

public static string EncryptData(string encryptText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize)
{
    return Encrypt(encryptText, passPhrase, saltValue, hashAlgorithm, passwordIterations, initVector, keySize);
}

public static string DecryptData(string decryptText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize)
{
    return Decrypt(decryptText, passPhrase, saltValue, hashAlgorithm, passwordIterations, initVector, keySize);
}
</code></pre>

<p>I then had some public methods that call into the above methods...</p>

<pre><code>public static string EncryptData(string encryptText)
{
    return EncryptionHelper.EncryptData(encryptText, ConfigHelper.PassPhrase, ConfigHelper.SaltValue, ConfigHelper.HashAlgorithm, ConfigHelper.PasswordIterations, ConfigHelper.InitVector, ConfigHelper.KeySize);
}

public static string DecryptData(string decryptText)
{
    return EncryptionHelper.DecryptData(decryptText, ConfigHelper.PassPhrase, ConfigHelper.SaltValue, ConfigHelper.HashAlgorithm, ConfigHelper.PasswordIterations, ConfigHelper.InitVector, ConfigHelper.KeySize);
}
</code></pre>

<p>I then had these in a config file...</p>

<pre><code>&lt;add key=""passPhrase"" value=""""/&gt;
&lt;add key=""saltValue"" value=""""/&gt;
&lt;add key=""hashAlgorithm"" value=""SHA1""/&gt;
&lt;add key=""passwordIterations"" value=""5""/&gt;
&lt;add key=""initVector"" value=""""/&gt;
&lt;add key=""keySize"" value=""256""/&gt;
</code></pre>
","1239","<c#><encryption><rijndael><securestring>","0","1","1","2013-07-26 08:53:27","17877011","1","","1449181","","2013-07-26 08:51:14","2013-07-26 08:41:03",""
"14369235","Is this Rijndael secure enough for use in production systems?","<p>Found an example of how to implement Rijndael on <a href=""http://www.obviex.com/samples/Encryption.aspx"" rel=""nofollow"">http://www.obviex.com/samples/Encryption.aspx</a></p>

<p>Is this code secure enough for production systems?</p>

<pre><code>using System;
using System.IO;
using System.Text;
using System.Security.Cryptography;
</code></pre>

<p>
This class uses a symmetric key algorithm (Rijndael/AES) to encrypt and 
decrypt data. As long as encryption and decryption routines use the same
parameters to generate the keys, the keys are guaranteed to be the same.
The class uses static functions with duplicate code to make it easier to
demonstrate encryption and decryption logic. In a real-life application, 
this may not be the most efficient way of handling encryption, so - as
soon as you feel comfortable with it - you may want to redesign this class.
</p>

<pre><code>public class RijndaelSimple
{
    /// &lt;summary&gt;
    /// Encrypts specified plaintext using Rijndael symmetric key algorithm
    /// and returns a base64-encoded result.
    /// &lt;/summary&gt;
    /// &lt;param name=""plainText""&gt;
    /// Plaintext value to be encrypted.
    /// &lt;/param&gt;
    /// &lt;param name=""passPhrase""&gt;
    /// Passphrase from which a pseudo-random password will be derived. The
    /// derived password will be used to generate the encryption key.
    /// Passphrase can be any string. In this example we assume that this
    /// passphrase is an ASCII string.
    /// &lt;/param&gt;
    /// &lt;param name=""saltValue""&gt;
    /// Salt value used along with passphrase to generate password. Salt can
    /// be any string. In this example we assume that salt is an ASCII string.
    /// &lt;/param&gt;
    /// &lt;param name=""hashAlgorithm""&gt;
    /// Hash algorithm used to generate password. Allowed values are: ""MD5"" and
    /// ""SHA1"". SHA1 hashes are a bit slower, but more secure than MD5 hashes.
    /// &lt;/param&gt;
    /// &lt;param name=""passwordIterations""&gt;
    /// Number of iterations used to generate password. One or two iterations
    /// should be enough.
    /// &lt;/param&gt;
    /// &lt;param name=""initVector""&gt;
    /// Initialization vector (or IV). This value is required to encrypt the
    /// first block of plaintext data. For RijndaelManaged class IV must be 
    /// exactly 16 ASCII characters long.
    /// &lt;/param&gt;
    /// &lt;param name=""keySize""&gt;
    /// Size of encryption key in bits. Allowed values are: 128, 192, and 256. 
    /// Longer keys are more secure than shorter keys.
    /// &lt;/param&gt;
    /// &lt;returns&gt;
    /// Encrypted value formatted as a base64-encoded string.
    /// &lt;/returns&gt;
    public static string Encrypt(string   plainText,
                                 string   passPhrase,
                                 string   saltValue,
                                 string   hashAlgorithm,
                                 int      passwordIterations,
                                 string   initVector,
                                 int      keySize)
    {
        // Convert strings into byte arrays.
        // Let us assume that strings only contain ASCII codes.
        // If strings include Unicode characters, use Unicode, UTF7, or UTF8 
        // encoding.
        byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
        byte[] saltValueBytes  = Encoding.ASCII.GetBytes(saltValue);

        // Convert our plaintext into a byte array.
        // Let us assume that plaintext contains UTF8-encoded characters.
        byte[] plainTextBytes  = Encoding.UTF8.GetBytes(plainText);

        // First, we must create a password, from which the key will be derived.
        // This password will be generated from the specified passphrase and 
        // salt value. The password will be created using the specified hash 
        // algorithm. Password creation can be done in several iterations.
        PasswordDeriveBytes password = new PasswordDeriveBytes(
                                                        passPhrase, 
                                                        saltValueBytes, 
                                                        hashAlgorithm, 
                                                        passwordIterations);

        // Use the password to generate pseudo-random bytes for the encryption
        // key. Specify the size of the key in bytes (instead of bits).
        byte[] keyBytes = password.GetBytes(keySize / 8);

        // Create uninitialized Rijndael encryption object.
        RijndaelManaged symmetricKey = new RijndaelManaged();

        // It is reasonable to set encryption mode to Cipher Block Chaining
        // (CBC). Use default options for other symmetric key parameters.
        symmetricKey.Mode = CipherMode.CBC;        

        // Generate encryptor from the existing key bytes and initialization 
        // vector. Key size will be defined based on the number of the key 
        // bytes.
        ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                                                         keyBytes, 
                                                         initVectorBytes);

        // Define memory stream which will be used to hold encrypted data.
        MemoryStream memoryStream = new MemoryStream();        

        // Define cryptographic stream (always use Write mode for encryption).
        CryptoStream cryptoStream = new CryptoStream(memoryStream, 
                                                     encryptor,
                                                     CryptoStreamMode.Write);
        // Start encrypting.
        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

        // Finish encrypting.
        cryptoStream.FlushFinalBlock();

        // Convert our encrypted data from a memory stream into a byte array.
        byte[] cipherTextBytes = memoryStream.ToArray();

        // Close both streams.
        memoryStream.Close();
        cryptoStream.Close();

        // Convert encrypted data into a base64-encoded string.
        string cipherText = Convert.ToBase64String(cipherTextBytes);

        // Return encrypted string.
        return cipherText;
    }

    /// &lt;summary&gt;
    /// Decrypts specified ciphertext using Rijndael symmetric key algorithm.
    /// &lt;/summary&gt;
    /// &lt;param name=""cipherText""&gt;
    /// Base64-formatted ciphertext value.
    /// &lt;/param&gt;
    /// &lt;param name=""passPhrase""&gt;
    /// Passphrase from which a pseudo-random password will be derived. The
    /// derived password will be used to generate the encryption key.
    /// Passphrase can be any string. In this example we assume that this
    /// passphrase is an ASCII string.
    /// &lt;/param&gt;
    /// &lt;param name=""saltValue""&gt;
    /// Salt value used along with passphrase to generate password. Salt can
    /// be any string. In this example we assume that salt is an ASCII string.
    /// &lt;/param&gt;
    /// &lt;param name=""hashAlgorithm""&gt;
    /// Hash algorithm used to generate password. Allowed values are: ""MD5"" and
    /// ""SHA1"". SHA1 hashes are a bit slower, but more secure than MD5 hashes.
    /// &lt;/param&gt;
    /// &lt;param name=""passwordIterations""&gt;
    /// Number of iterations used to generate password. One or two iterations
    /// should be enough.
    /// &lt;/param&gt;
    /// &lt;param name=""initVector""&gt;
    /// Initialization vector (or IV). This value is required to encrypt the
    /// first block of plaintext data. For RijndaelManaged class IV must be
    /// exactly 16 ASCII characters long.
    /// &lt;/param&gt;
    /// &lt;param name=""keySize""&gt;
    /// Size of encryption key in bits. Allowed values are: 128, 192, and 256.
    /// Longer keys are more secure than shorter keys.
    /// &lt;/param&gt;
    /// &lt;returns&gt;
    /// Decrypted string value.
    /// &lt;/returns&gt;
    /// &lt;remarks&gt;
    /// Most of the logic in this function is similar to the Encrypt
    /// logic. In order for decryption to work, all parameters of this function
    /// - except cipherText value - must match the corresponding parameters of
    /// the Encrypt function which was called to generate the
    /// ciphertext.
    /// &lt;/remarks&gt;
    public static string Decrypt(string   cipherText,
                                 string   passPhrase,
                                 string   saltValue,
                                 string   hashAlgorithm,
                                 int      passwordIterations,
                                 string   initVector,
                                 int      keySize)
    {
        // Convert strings defining encryption key characteristics into byte
        // arrays. Let us assume that strings only contain ASCII codes.
        // If strings include Unicode characters, use Unicode, UTF7, or UTF8
        // encoding.
        byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
        byte[] saltValueBytes  = Encoding.ASCII.GetBytes(saltValue);

        // Convert our ciphertext into a byte array.
        byte[] cipherTextBytes = Convert.FromBase64String(cipherText);

        // First, we must create a password, from which the key will be 
        // derived. This password will be generated from the specified 
        // passphrase and salt value. The password will be created using
        // the specified hash algorithm. Password creation can be done in
        // several iterations.
        PasswordDeriveBytes password = new PasswordDeriveBytes(
                                                        passPhrase, 
                                                        saltValueBytes, 
                                                        hashAlgorithm, 
                                                        passwordIterations);

        // Use the password to generate pseudo-random bytes for the encryption
        // key. Specify the size of the key in bytes (instead of bits).
        byte[] keyBytes = password.GetBytes(keySize / 8);

        // Create uninitialized Rijndael encryption object.
        RijndaelManaged    symmetricKey = new RijndaelManaged();

        // It is reasonable to set encryption mode to Cipher Block Chaining
        // (CBC). Use default options for other symmetric key parameters.
        symmetricKey.Mode = CipherMode.CBC;

        // Generate decryptor from the existing key bytes and initialization 
        // vector. Key size will be defined based on the number of the key 
        // bytes.
        ICryptoTransform decryptor = symmetricKey.CreateDecryptor(
                                                         keyBytes, 
                                                         initVectorBytes);

        // Define memory stream which will be used to hold encrypted data.
        MemoryStream  memoryStream = new MemoryStream(cipherTextBytes);

        // Define cryptographic stream (always use Read mode for encryption).
        CryptoStream  cryptoStream = new CryptoStream(memoryStream, 
                                                      decryptor,
                                                      CryptoStreamMode.Read);

        // Since at this point we don't know what the size of decrypted data
        // will be, allocate the buffer long enough to hold ciphertext;
        // plaintext is never longer than ciphertext.
        byte[] plainTextBytes = new byte[cipherTextBytes.Length];

        // Start decrypting.
        int decryptedByteCount = cryptoStream.Read(plainTextBytes, 
                                                   0, 
                                                   plainTextBytes.Length);

        // Close both streams.
        memoryStream.Close();
        cryptoStream.Close();

        // Convert decrypted data into a string. 
        // Let us assume that the original plaintext string was UTF8-encoded.
        string plainText = Encoding.UTF8.GetString(plainTextBytes, 
                                                   0, 
                                                   decryptedByteCount);

        // Return decrypted string.   
        return plainText;
    }
}

/// &lt;summary&gt;
/// Illustrates the use of RijndaelSimple class to encrypt and decrypt data.
/// &lt;/summary&gt;
public class RijndaelSimpleTest
{
    /// &lt;summary&gt;
    /// The main entry point for the application.
    /// &lt;/summary&gt;
    [STAThread]
    static void Main(string[] args)
    {
        string   plainText          = ""Hello, World!"";    // original plaintext

        string   passPhrase         = ""Pas5pr@se"";        // can be any string
        string   saltValue          = ""s@1tValue"";        // can be any string
        string   hashAlgorithm      = ""SHA1"";             // can be ""MD5""
        int      passwordIterations = 2;                  // can be any number
        string   initVector         = ""@1B2c3D4e5F6g7H8""; // must be 16 bytes
        int      keySize            = 256;                // can be 192 or 128

        Console.WriteLine(String.Format(""Plaintext : {0}"", plainText));

        string  cipherText = RijndaelSimple.Encrypt(plainText,
                                                    passPhrase,
                                                    saltValue,
                                                    hashAlgorithm,
                                                    passwordIterations,
                                                    initVector,
                                                    keySize);

        Console.WriteLine(String.Format(""Encrypted : {0}"", cipherText));

        plainText          = RijndaelSimple.Decrypt(cipherText,
                                                    passPhrase,
                                                    saltValue,
                                                    hashAlgorithm,
                                                    passwordIterations,
                                                    initVector,
                                                    keySize);

        Console.WriteLine(String.Format(""Decrypted : {0}"", plainText));
    }
}
</code></pre>
","<p>Nope.</p>

<p>It makes the obvious mistake about not understanding the difference between character strings and octet strings. For the salt this may be excusable, but it should certainly not be the case for the IV.</p>

<p>Furthermore it uses a Microsoft proprietary extended PKCS#5 PBKDF1 implementation of <code>PasswordDeriveBytes</code> instead of PBKDF2 as defined in <code>Rfc2898DeriveBytes</code>. This implementation is not secure for any bytes over 20 bytes long (which is the SHA-1 output size, and the defined output size of PBKDF1) - to the point that it <em>may repeat bytes in the output</em>. Any output over 20 bytes won't be reproducible on other frameworks. Even Mono has designated this a ""won't fix"".</p>

<p>The initialization vector should be generated by a secure random number generator instead of being passed as a parameter.</p>

<p>CBC mode can be secure, but it does not provide integrity protection, so it is (generally) not secure when used over a transport protocol.</p>

<p>This list may not be exhaustive.</p>
","1238","<c#><encryption><production-environment><rijndael>","0","2","1","2013-01-17 00:16:23","14369930","2","","","","","2013-01-16 22:40:20","2013-01-17 00:02:11"
"32439092","C# RijndaelManaged to Python equivalent","<p>I have the following C# code (code is inherited and can't compile it). This is used to decrypt and unzip a saved file. </p>

<pre><code>using System.Security.Cryptography;
using System.Text;
using ICSharpCode.SharpZipLib.Zip;

//Not the real key but same amount of chars
private const string kEncyptionKey = ""01234567"";

public string DecryptAndDecompressText (string strFileName)
{
    // Decryption ///
    FileStream fin = null;
    try
    {
        fin = new FileStream(strFileName, FileMode.Open, FileAccess.Read);
    }
    catch (System.IO.FileNotFoundException)
    {
        return """";
    }

    MemoryStream    memoryToDecompress =  new MemoryStream();

    UnicodeEncoding UE       = new UnicodeEncoding();
    RijndaelManaged RMCrypto = new RijndaelManaged();

    // This is the encryption key for our file 
    byte[] key = UE.GetBytes(kEncyptionKey);

    // Decrypt the data to a stream
    CryptoStream cs = new CryptoStream( memoryToDecompress, 
                                        RMCrypto.CreateDecryptor(key, key),
                                        CryptoStreamMode.Write);
    byte [] fileBuffer = new byte[fin.Length];
    fin.Read(fileBuffer, 0, fileBuffer.Length);
    cs.Write(fileBuffer, 0, fileBuffer.Length);

    fin.Close();

    // Reset the index of the Memory Stream
    memoryToDecompress.Position = 0;

    // Let the GC clean this up, we still need the memory stream
    //cs.Close();   


    // Decompress the File
    ZipInputStream s;
    s = new ZipInputStream(memoryToDecompress);

    ZipEntry theEntry;
    try
    {
        theEntry = s.GetNextEntry();
    }
    catch (System.Exception)
    {
        // Could not open the file...
        return """";
    }
}
</code></pre>

<p>I'm trying to create a python program to do the same. This is what I've got:</p>

<pre><code>from Crypto.Cipher import AES

KEY = '01234567'.encode('utf-16be')

_f = open('&lt;file&gt;', 'r')

 _content = _f.read()

_cipher = AES.new(KEY, AES.MODE_CBC, KEY)

_dcontent = _cipher.decrypt(_content)

with open('extract.zip', 'w') as newfile:
    newfile.write(_dcontent)

_f.close()
</code></pre>

<p>I'm writing the result to the disk since I expect it to be a zip file (which contains one file). However I can't open the file with Archive Manager. </p>

<p>Any suggestions are welcome!</p>
","<p>You have to use the <strong>same key</strong>. <code>System.Text.UnicodeEncoding</code> is the UTF-16le encoding which also has an equivalent in python:</p>

<pre><code>KEY = '01234567'.encode('utf-16le')
</code></pre>

<p>You have to read and write the files in <strong>binary mode</strong> if you're on Windows:</p>

<pre><code>_f = open('&lt;file&gt;', 'rb')
...
open('extract.zip', 'wb')
</code></pre>
","1231","<c#><python><aes><rijndael>","3","2","2","2015-09-15 14:16:47","","0","1","4026132","","2015-09-11 09:00:46","2015-09-07 12:44:18",""
"32439092","C# RijndaelManaged to Python equivalent","<p>I have the following C# code (code is inherited and can't compile it). This is used to decrypt and unzip a saved file. </p>

<pre><code>using System.Security.Cryptography;
using System.Text;
using ICSharpCode.SharpZipLib.Zip;

//Not the real key but same amount of chars
private const string kEncyptionKey = ""01234567"";

public string DecryptAndDecompressText (string strFileName)
{
    // Decryption ///
    FileStream fin = null;
    try
    {
        fin = new FileStream(strFileName, FileMode.Open, FileAccess.Read);
    }
    catch (System.IO.FileNotFoundException)
    {
        return """";
    }

    MemoryStream    memoryToDecompress =  new MemoryStream();

    UnicodeEncoding UE       = new UnicodeEncoding();
    RijndaelManaged RMCrypto = new RijndaelManaged();

    // This is the encryption key for our file 
    byte[] key = UE.GetBytes(kEncyptionKey);

    // Decrypt the data to a stream
    CryptoStream cs = new CryptoStream( memoryToDecompress, 
                                        RMCrypto.CreateDecryptor(key, key),
                                        CryptoStreamMode.Write);
    byte [] fileBuffer = new byte[fin.Length];
    fin.Read(fileBuffer, 0, fileBuffer.Length);
    cs.Write(fileBuffer, 0, fileBuffer.Length);

    fin.Close();

    // Reset the index of the Memory Stream
    memoryToDecompress.Position = 0;

    // Let the GC clean this up, we still need the memory stream
    //cs.Close();   


    // Decompress the File
    ZipInputStream s;
    s = new ZipInputStream(memoryToDecompress);

    ZipEntry theEntry;
    try
    {
        theEntry = s.GetNextEntry();
    }
    catch (System.Exception)
    {
        // Could not open the file...
        return """";
    }
}
</code></pre>

<p>I'm trying to create a python program to do the same. This is what I've got:</p>

<pre><code>from Crypto.Cipher import AES

KEY = '01234567'.encode('utf-16be')

_f = open('&lt;file&gt;', 'r')

 _content = _f.read()

_cipher = AES.new(KEY, AES.MODE_CBC, KEY)

_dcontent = _cipher.decrypt(_content)

with open('extract.zip', 'w') as newfile:
    newfile.write(_dcontent)

_f.close()
</code></pre>

<p>I'm writing the result to the disk since I expect it to be a zip file (which contains one file). However I can't open the file with Archive Manager. </p>

<p>Any suggestions are welcome!</p>
","<p>You should use the <a href=""https://docs.python.org/2/library/zipfile.html"" rel=""nofollow"">proper zip file library</a>. I am guessing that is something format specific that is failing on your write statement. Using this library should avoid such drawbacks. The <code>open</code> function can take a password as optional in case it is protected.</p>
","1231","<c#><python><aes><rijndael>","3","1","2","2015-09-15 14:16:47","","0","1","4026132","","2015-09-11 09:00:46","2015-09-07 12:44:18",""
"26562421","JAVA a reliable equivalent for php's MCRYPT_RIJNDAEL_256","<p>I need to access some data that used PHP encryption. The PHP encryption is like this.</p>

<pre><code>base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($cipher), $text, MCRYPT_MODE_ECB));</code></pre>

<p>As value of $text they pass the time() function value which will be different each time that the method is called in.  I have implemented this in Java. Like this,</p>

<pre><code>public static String md5(String string) {
    byte[] hash;

    try {
        hash = MessageDigest.getInstance(""MD5"").digest(string.getBytes(""UTF-8""));
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(""Huh, MD5 should be supported?"", e);
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(""Huh, UTF-8 should be supported?"", e);
    }

    StringBuilder hex = new StringBuilder(hash.length * 2);

    for (byte b : hash) {
        int i = (b &amp; 0xFF);
        if (i &lt; 0x10) hex.append('0');
        hex.append(Integer.toHexString(i));
    }

    return hex.toString();
}

public static byte[] rijndael_256(String text, byte[] givenKey) throws DataLengthException, IllegalStateException, InvalidCipherTextException, IOException{
    final int keysize;

    if (givenKey.length &lt;= 192 / Byte.SIZE) {
        keysize = 192;
    } else {
        keysize = 256;
    }

    byte[] keyData = new byte[keysize / Byte.SIZE];
    System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
    KeyParameter key = new KeyParameter(keyData);
    BlockCipher rijndael = new RijndaelEngine(256);
    ZeroBytePadding c = new ZeroBytePadding();
    PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);
    pbbc.init(true, key);

    byte[] plaintext = text.getBytes(Charset.forName(""UTF8""));
    byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];
    int offset = 0;
    offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
    offset += pbbc.doFinal(ciphertext, offset);
    return ciphertext;
}


public static String encrypt(String text, String secretKey) throws Exception {


    byte[] givenKey = String.valueOf(md5(secretKey)).getBytes(Charset.forName(""ASCII""));

    byte[] encrypted = rijndael_256(text,givenKey);

    return new String(Base64.encodeBase64(encrypted));
}
</code></pre>

<p>I have referred this answer when creating MCRYPT_RIJNDAEL_256 method.""
<a href=""https://stackoverflow.com/questions/18101545/encryption-in-android-equivalent-to-phps-mcrypt-rijndael-256"">Encryption in Android equivalent to php&#39;s MCRYPT_RIJNDAEL_256</a>
""I have used apache codec for Base64.Here's how I call the encryption function,</p>

<pre><code>long time= System.currentTimeMillis()/1000;
String encryptedTime = EncryptionUtils.encrypt(String.valueOf(time), secretkey);</code></pre>

<p>The problem is sometimes the output is not similar to PHP but sometimes it works fine.
I think that my MCRYPT_RIJNDAEL_256 method is unreliable.
I want to know where I went wrong and find a reliable method so that I can always get similar encrypted string as to PHP.</p>
","<p>The problem is likely to be the <code>ZeroBytePadding</code>. The one of Bouncy always adds/removes at least one byte with value zero (a la PKCS5Padding, 1 to 16 bytes of padding) but the one of PHP only pads until the first block boundary is encountered (0 to 15 bytes of padding). I've discussed this with David of the legion of Bouncy Castle, but the PHP zero byte padding is an extremely ill fit for the way Bouncy does padding, so currently you'll have to do this yourself, and use the cipher without padding.</p>

<p>Of course, as a real solution, rewrite the PHP part to use AES (<code>MCRYPT_RIJNDAEL_128</code>), CBC mode encryption, HMAC authentication, a real Password Based Key Derivation Function (PBKDF, e.g. PBKDF2 or bcrypt) and PKCS#7 compatible padding instead of this insecure, incompatible code. Alternatively, go for OpenSSL compatibility or a known secure container format. </p>
","1210","<java><php><encryption><rijndael>","3","1","1","2014-10-26 13:07:02","26563318","0","","-1","","2017-05-23 11:45:58","2014-10-25 12:33:42",""
"10319984","rijndael 256 key","<p>How can I create a key and iv, so that encrypted string should only contain digits and characters.key string and iv string should contain 32 characters.purpose is encrypted string should not contain any special characters.block size is 256.
now I am using key and iv like this.after encryption using this, getting encrypted string with special characters.how can we avoid this.</p>

<p>AES_Key=PSVJQRk9QTEpNVU1DWUZCRVFGV1VVT0ZOV1RRU1NaWQ=</p>

<p>Aes_iv=YWlFLVEZZUFNaWlhPQ01ZT0lLWU5HTFJQVFNCRUJZVA=</p>
","<p>You need to Base64 encode the output. This will ensure it's only printable ASCII, and is rather standard for storing/transmitting encrypted data. </p>

<p>You want your keys and IV's to be completely random. Just because you don't have special characters in your keys, doesn't mean you won't get special characters in your output. There is absolutely no correlation. It looks like in your keys and IV's are base64 encoded there. Make sure you are using the raw keys and IV's. </p>

<p>Here's how to do it in C#. Assuming your AES output is a byte array:</p>

<pre><code>        string encoded = System.Convert.ToBase64String(aesOutput);
</code></pre>

<p>If it's a string:</p>

<pre><code>        byte[] encodedBytes = System.Text.Encoding.ASCII.GetBytes(aesOutput);
        string base64encoded = System.Convert.ToBase64String(encodedBytes);
</code></pre>

<p>You can use System.Convert.FromBase64String(encodedData) to convert back to it's original output. </p>
","1178","<c#><rijndael>","0","2","1","2012-04-25 16:49:58","","4","","","","","2012-04-25 16:36:14",""
"18492214","DCPCrypt (Delphi) + ZLib / ""data error"" when decompressing decrypted data","<p>I designed a system that stores blocks of data, sent compressed and encrypted by multiple clients. </p>

<p>When trying to fetch stored data blocks (that I need to decompress and decrypt) on a specific computer, a ZLib ""data error"" exception is raised during the data decompression. It seems clear that the stream has not been properly decrypted so the input stream is not a valid ZLib stream, leading to a such issue. </p>

<p>After some research I discovered that for an identical block of source data that is also stored, this problematic block contained totaly different data, so it's quite clear that there is an issue in the encryption or the compression algorithm. </p>

<p>However, the fact that I cannot easily reproduce the problem means that if there is an error it's something far from being obvious. So I'm posting the code here, hoping someone will spot something I didn't see.</p>

<p>First, the data block <code>AStream</code> is compressed :</p>

<pre><code>function CompressStream(AStream: TMemoryStream;
  ACompressionLevel:
  TCompressionLevel): Boolean;
var
  LTempStream: TMemoryStream;
  LCompressedStream: TCompressionStream;
begin
  LTempStream := TMemoryStream.create;
  try
    try
      AStream.Seek(0, soBeginning);
      LCompressedStream := TCompressionStream.Create(ACompressionLevel, LTempStream);
      try
        try
          LCompressedStream.CopyFrom(AStream, AStream.Size);
        finally
          LCompressedStream.free;
        end;
      finally
        AStream.Clear;
        AStream.CopyFrom(LTempStream, 0);
        AStream.Seek(0, soBeginning);
        Result := True;
      end;
    finally
      LTempStream.free;
    end;
  except
    Result := False;
  end;
end;
</code></pre>

<p>Then, it's encrypted :</p>

<pre><code>function EncryptStream(AStream: TMemoryStream; const AParameters: AnsiString): Boolean;
var
  LModifiedStream: TMemoryStream;
  LRijndaelCipher: TDCP_rijndael;
begin
   try
     LRijndaelCipher := TDCP_rijndael.Create(nil);
     LModifiedStream := TMemoryStream.Create;
     InitCipherWithKey(LRijndaelCipher, AParameters);
     try
        AStream.Seek(0, soBeginning);
        LRijndaelCipher.EncryptStream(AStream, LModifiedStream, AStream.Size);
        TMemoryStream(AStream).Clear;
        AStream.CopyFrom(LModifiedStream, 0);
        Result := True;
     finally
        LRijndaelCipher.Burn;
        LRijndaelCipher.Free;
        LModifiedStream.Free;
     end;
   except
     Result := False;
   end;
end;
</code></pre>

<p>...and stored somewhere.</p>

<p>When fetching a data block, it's first decrypted :</p>

<pre><code>function DecryptStream(AStream: TMemoryStream; const AParameters: AnsiString): Boolean;
var
  LModifiedStream: TMemoryStream;
  LRijndaelCipher: TDCP_rijndael;
begin
   try
     LRijndaelCipher := TDCP_rijndael.Create(nil);
     LModifiedStream := TMemoryStream.Create;
     InitCipherWithKey(LRijndaelCipher, AParameters);
     try
        AStream.Seek(0, soBeginning);
        LRijndaelCipher.DecryptStream(AStream, LModifiedStream, AStream.Size);
        TMemoryStream(AStream).Clear;
        AStream.CopyFrom(LModifiedStream, 0);
        Result := True;
     finally
        LRijndaelCipher.Burn;
        LRijndaelCipher.Free;
        LModifiedStream.Free;
     end;
   except
     Result := False;
   end;
end;
</code></pre>

<p>Then uncompressed :</p>

<pre><code>function DecompressStream(AStream: TMemoryStream): Boolean;
var
  LTempStream: TMemoryStream;
  LCompressedStream: TDecompressionStream;
begin
  LTempStream := TMemoryStream.create;
  try
    try
      AStream.Seek(0, soBeginning);
      LCompressedStream := TDecompressionStream.Create(AStream);
      try
        try
          LTempStream.CopyFrom(LCompressedStream, LCompressedStream.size);
        finally
          LCompressedStream.Free;
        end;
      finally
        AStream.Clear;
        AStream.CopyFrom(LTempStream, 0);
        AStream.Seek(0, soBeginning);
        Result := True;
      end;
    finally
      LTempStream.free;
    end;
  except
    Result := False;
  end;
end;
</code></pre>

<p>The cipher is initialized using the <code>InitCipherWithKey()</code> method. It is designed to convert a MD5 hash into it's binary representation, contained in the <code>LMD5Hash</code> variable (yes, the array is 64 bytes long but only the first 16 will be used by the cipher, since I call <code>Init()</code> with the 128 value (which means a 128-bit/16 bytes key length) : </p>

<pre><code>procedure InitCipherWithKey(ACipher: TDCP_cipher; const AKey: AnsiString);
var
  LMD5Hash: array [0..63] of Byte;
  S: AnsiString;
begin
  //We use a 128 bit key
  ZeroMemory(@LMD5Hash, SizeOf(LMD5Hash));
  S := AKey;
  HexToBin(PAnsiChar(S), LMD5Hash, Length(LMD5Hash) -1);
  ACipher.Init(LMD5Hash[0], 128, nil);
  ZeroMemory(@LMD5Hash, SizeOf(LMD5Hash));
end;
</code></pre>

<p>Thanks in advance.</p>
","<p>There is something going wrong when calculating/transporting the key. First you calculate the key from a password (incorrectly named <code>AKey</code>) using MD5. For some reason, you are using a buffer of 64 bytes for this, even though MD5 will always output exactly 16 bytes. This is already not secure, you should use a password based key derivation function such as PBKDF2 to derive keys from passwords.</p>

<p>Then however you seem to treat the binary output of MD5 as characters. I presume you take the output of <code>InitCipherWithKey</code> and put it in <code>AParameters</code>. Now suddenly the binary output of MD5 is treated as a string. Unfortunately, this means that bytes are interpreted as characters such as control characters (including the null-termination character value if the byte has value <code>00</code>).</p>

<p>So it is most likely that the decryption does not succeed because of loss of data from the key itself. This of course depends on the key value, making this scheme fail now and then. Please check your code base to see if you make errors regarding <a href=""/questions/tagged/character-encoding"" class=""post-tag"" title=""show questions tagged 'character-encoding'"" rel=""tag"">character-encoding</a> and <a href=""/questions/tagged/encoding"" class=""post-tag"" title=""show questions tagged 'encoding'"" rel=""tag"">encoding</a>.</p>
","1173","<delphi><encryption><zlib><rijndael>","1","1","1","2013-08-29 08:42:24","","0","","","","","2013-08-28 15:30:10",""
"18796206","Getting AES PHP & C# To Match","<p>I've seen a few posts about this, but yet I can't seem to get this to work, any ideas?</p>

<p>RESULTS:</p>

<pre><code>C# Encrypted string test = O6qzYiLPCpbXUf8PjMHpcg==
php Encrypted string test = SdS1dN1ugyAVYGFzHiTayg==
</code></pre>

<p>C# Code</p>

<pre><code>public static string EncryptString(string message, string KeyString, string IVString)
{
    byte[] Key = ASCIIEncoding.UTF8.GetBytes(KeyString);
    byte[] IV = ASCIIEncoding.UTF8.GetBytes(IVString);

    string encrypted = null;
    RijndaelManaged rj = new RijndaelManaged();
    rj.Key = Key;
    rj.IV = IV;
    rj.Mode = CipherMode.CBC;

    try
    {
        MemoryStream ms = new MemoryStream();

        using (CryptoStream cs = new CryptoStream(ms, rj.CreateEncryptor(Key, IV), CryptoStreamMode.Write))
        {
            using (StreamWriter sw = new StreamWriter(cs))
            {
                sw.Write(message);
                sw.Close();
            }
            cs.Close();
        }
        byte[] encoded = ms.ToArray();
        encrypted = Convert.ToBase64String(encoded);

        ms.Close();
    }
    catch (CryptographicException e)
    {
        Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message);
        return null;
    }
    catch (UnauthorizedAccessException e)
    {
        Console.WriteLine(""A file error occurred: {0}"", e.Message);
        return null;
    }
    catch (Exception e)
    {
        Console.WriteLine(""An error occurred: {0}"", e.Message);
    }
    finally
    {
        rj.Clear();
    }
    return encrypted;
}

string enctext = EncryptString(""test"", ""qwertyuiopasdfghjklzxcvbnmqwerty"", _""1234567890123456"");
</code></pre>

<p>PHP</p>

<pre><code>function aesenc($message, $keystring, $ivstring){
    $IV_UTF = mb_convert_encoding($ivstring, 'UTF-8');
    $KEY_UTF = mb_convert_encoding($keystring, 'UTF-8');

    return base64_encode( mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $KEY_UTF, $message, MCRYPT_MODE_CBC, $IV_UTF));
}

$enctext = aesenc(""test"", ""qwertyuiopasdfghjklzxcvbnmqwerty"", _""1234567890123456"");
</code></pre>
","<p>Found the answer, needed to add padding to the $message in php</p>

<pre><code>function aesenc($message, $keystring, $ivstring){
    $IV_UTF = mb_convert_encoding($ivstring, 'UTF-8');
    $KEY_UTF = $keystring;

    return base64_encode( mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $KEY_UTF, addpadding($message), MCRYPT_MODE_CBC, $IV_UTF));
}
function addpadding($string, $blocksize = 16)
{
    $len = strlen($string);
    $pad = $blocksize - ($len % $blocksize);
    $string .= str_repeat(chr($pad), $pad);
    return $string;
}
</code></pre>
","1166","<c#><php><encryption><aes><rijndael>","0","3","1","2013-09-13 22:38:53","18796278","4","1","","","","2013-09-13 22:29:31",""
"15260399","RijndaelManaged.CreateEncryptor key expansion","<p>There are two ways to specify a key and an IV for a <code>RijndaelManaged</code> object. One is by calling <code>CreateEncryptor</code>:</p>

<pre><code>var encryptor = rij.CreateEncryptor(Encoding.UTF8.GetBytes(key), Encoding.UTF8.GetBytes(iv)));
</code></pre>

<p>and another one by directly setting <code>Key</code> and <code>IV</code> properties:</p>

<pre><code>rij.Key = ""1111222233334444"";
rij.IV = ""1111222233334444"";
</code></pre>

<p>As long as the length of the <code>Key</code> and <code>IV</code> is 16 bytes, both methods produce the same result. But if your key is shorter than 16 bytes, the first method still allows you to encode the data and the second method fails with an exception.</p>

<p>Now this may sound like an absolutely abstract question, but I have to use <code>PHP</code> &amp; the key which is only 10 bytes long in order to send an encrypted message to a server which uses the first method.</p>

<p>So the question is: How does <code>CreateEncryptor</code> expand the key and is there a PHP implementation? I cannot alter the C# code so I'm forced to replicate this behaviour in PHP.</p>
","<p>I'm going to have to start with some assumptions. (TL;DR - The solution is about two-thirds of the way down but the journey is <em>way cooler</em>).</p>

<p>First, in your example you set IV and Key to strings. This can't be done. I'm therefore going to assume we call GetBytes() on the strings, which is a terrible idea by the way as there are less potential byte values in usable ASCII space than there are in all 256 values in a byte; that's what GenerateIV() and GenerateKey() are for. I'll get to this at the very end.</p>

<p>Next I'm going to assume you're using the default block, key and feedback size for RijndaelManaged: 128, 256 and 128 respectively.</p>

<p>Now we'll decompile the Rijndael CreateEncryptor() call. When it creates the Transform object it doesn't do much of anything with the key at all (except set m_Nk, which I'll come to later). Instead it goes straight to generating a key expansion from the bytes it is given.</p>

<p>Now it gets interesting:</p>

<pre><code>switch (this.m_blockSizeBits &gt; rgbKey.Length * 8 ? this.m_blockSizeBits : rgbKey.Length * 8)
</code></pre>

<p>So:</p>

<pre><code>128 &gt; len(k) x 8 = 128
128 &lt;= len(k) x 8 = len(k) x 8
</code></pre>

<p>128 / 8 = 16, so if len(k) is 16 we can expect to switch on len(k) x 8. If it's more, then it will switch on len(k) x 8 too. If it's less it will switch on the block size, 128.</p>

<p>Valid switch values are 128, 192 and 256. That means it will only fall to default (and throw an exception) if it's over 16 bytes in length and not a valid block (not key) length of some sort.</p>

<p>In other words, it never checks against the key length specified in the RijndaelManaged object. It goes straight in to the key expansion and starts operating at the block level, as long as the key length (in bits) is one of 128, 192, 256 or <em>less than 128</em>. This is actually a check against the block size, not the key size.</p>

<p>So what happens now that we've patently not checked the key length? The answer has to do with the nature of the key schedule. When you enter a key in to Rijndael, the key needs to be expanded before it can be used. In this case, it's going to be expanded to 176 bytes. In order to accomplish this, it uses an algorithm which is specifically designed to turn a short byte array in to much longer byte array.</p>

<p>Part of that involves checking the key length. A bit more decompilation fun and we find that this defined as m_Nk. Sounds familiar?</p>

<pre><code>this.m_Nk = rgbKey.Length / 4;
</code></pre>

<p>Nk is 4 for a 16-byte key, less when we enter shorter keys. That's 4 <em>words</em>, for anyone wondering where the magic number 4 came from. This causes a curious fork in the key scheduler, there's a specific path for Nk &lt;= 6.</p>

<p>Without going too deep in to the details, this actually happens to 'work' (ie. not crash in a fireball) with a key length less than 16 bytes... until it gets below 8 bytes.</p>

<p>Then the entire thing crashes spectacularly.</p>

<p>So what have we learned? When you use CreateEncryptor you are actually throwing a completely invalid key straight in to the key scheduler and it's serendipity that sometimes it doesn't outright crash on you (or a horrible contractual integrity breach, depending on your POV); probably an unintended side effect of the fact there's a specific fork for short key lengths.</p>

<p>For completeness sake we can now look at the other implementation where you set the Key and IV in the RijndaelManaged object. These are stored in the SymmetricAlgorithm base class, which has the following setter:</p>

<pre><code>if (!this.ValidKeySize(value.Length * 8))
    throw new CryptographicException(Environment.GetResourceString(""Cryptography_InvalidKeySize""));
</code></pre>

<p>Bingo. Contract properly enforced.</p>

<p>The obvious answer is that you cannot replicate this in another library unless that library happens to contain the same glaring issue, which I'm going to a call a bug in Microsoft's code because I really can't see any other option.</p>

<p>But that answer would be a cop out. By inspecting the key scheduler we can work out what's actually happening.</p>

<p>When the expanded key is initialised, it populates itself with 0x00s. It then writes to the first Nk words with our key (in our case Nk = 2, so it populates the first 2 words or 8 bytes). Then it enters a second stage of expanding upon that by populating the rest of the expanded key beyond that point.</p>

<p>So now we know it's essentially padding everything past 8 bytes with 0x00, we can pad it with 0x00s right? No; because this shifts the Nk up to Nk = 4. As a result, although our first 4 words (16 bytes) will be populated as we expect, the second stage will begin expanding at the 17th byte, not the 9th!</p>

<p>The solution then is utterly trivial. Rather than padding our initial key with 6 additional bytes, just chop off the last 2 bytes.</p>

<p>So your direct answer in PHP is:</p>

<pre><code>$key = substr($key, 0, -2);
</code></pre>

<p>Simple, right? :)</p>

<p>Now you can interop with this encryption function. But don't. It can be cracked.</p>

<p>Assuming your key uses lowercase, uppercase and digits you have an exhaustive search space of only 218 trillion keys.</p>

<p>62 bytes (26 + 26 + 10) is the search space of each byte because you're never using the other 194 (256 - 62) values. Since we have 8 bytes, there are 62^8 possible combinations. 218 trillion.</p>

<p>How fast can we try all the keys in that space? Let's ask openssl what my laptop (running lots of clutter) can do:</p>

<pre><code>Doing aes-256 cbc for 3s on 16 size blocks: 12484844 aes-256 cbc's in 3.00s
</code></pre>

<p>That's 4,161,615 passes/sec. 218,340,105,584,896 / 4,161,615 / 3600 / 24 = 607 days.</p>

<p>Okay, 607 days isn't bad. But I can always just fire up a bunch of Amazon servers and cut that down to ~1 day by asking 607 equivalent instances to calculate 1/607th of the search space. How much would that cost? Less than $1000, assuming that each instance was somehow only as efficient as my busy laptop. Cheaper and faster otherwise.</p>

<p>There is also an implementation that is twice the speed of openssl<a href=""http://cr.yp.to/aes-speed/aesspeed-20080926.pdf"" rel=""nofollow"">1</a>, so cut whatever figure we've ended up with in half.</p>

<p>Then we've got to consider that we'll almost certainly find the key before exhausting the entire search space. So for all we know it might be finished in an hour.</p>

<p>At this point we can assert if the data is worth encrypting, it's probably worth it to crack the key.</p>

<p>So there you go.</p>
","1092","<php><.net><encryption><rijndael>","2","3","1","2013-09-26 14:09:03","19016597","6","","474189","","2013-03-07 20:21:30","2013-03-06 23:44:07",""
"38131879","mcrypt_encrypt(): Key of size 29 not supported by this algorithm","<p>i have my old code back from 2011 which calculate hash</p>

<pre><code>private static $key = 'G@W351T35.cz#€2011GAMESITES';

/**
 * Computes salted password hash.
 * @param  string
 * @return string
 */
public static function calculateHash($password)
{
    $text = $password;
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
    $crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, self::$key, $text, MCRYPT_MODE_ECB, $iv);
    return base64_encode($crypttext);
}
</code></pre>

<p>When i try to run it now I get an error:</p>

<blockquote>
  <p>Warning: mcrypt_encrypt(): Key of size 29 not supported by this
  algorithm. Only  keys of sizes 16, 24 or 32 supported in ..\Hash.php
  on line 27</p>
</blockquote>

<p>I know it takes a long time from 2011 and there can be better ways to do it now, but I need to make it work from previous version for some historical issue. What i am doing wrong? 
I cant even see what size 29 does it mean.</p>

<p>Or alternativly is there a way how to break a hash if I still got a function?
with this i can potencialy start using new way of calculating hash.</p>

<p>Thanks for any advise</p>
","<p><code>$key</code>is the key and must be a supported size of 16, 24 or 32 bytes in length. You are passing a length of 29 bytes, you need to use a key of appropriate size.</p>

<p>The code is not calculating a hash, it is encrypting <code>$text</code>.</p>

<p>It is using ECB mode which is not considered secure. Note that ECB mode does not take an iv <code>$iv</code> so there is no point in creating one. CBC mode is better and does use an iv.</p>

<p>If you really want to create a hash use a hash function such as SHA-256. If you need a ""keyed"" or salted hash use a HMAC.</p>

<p>Even ""way back to 2011"" encryption was not used to create hashes, there really isn't anything new since then.</p>

<p>Iterate over an HMAC with a random salt for about a 100ms duration (the salt needs to be saved with the hash). Use functions such as password_hash, PBKDF2, Bcrypt and similar functions. The point is to make the attacker spend a lot of time finding passwords by brute force.</p>

<p>See OWASP (Open Web Application Security Project) <a href=""https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Leverage_an_adaptive_one-way_function"" rel=""nofollow noreferrer"">Password Storage Cheat Sheet</a>.</p>

<p>See <a href=""https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords/31846#31846"">How to securely hash passwords, The Theory</a> on Security Stackexchange.</p>
","1072","<php><mcrypt><rijndael>","-1","0","2","2016-07-01 12:04:01","38144972","2","","","user824425","2016-07-01 11:53:33","2016-06-30 19:39:51",""
"38131879","mcrypt_encrypt(): Key of size 29 not supported by this algorithm","<p>i have my old code back from 2011 which calculate hash</p>

<pre><code>private static $key = 'G@W351T35.cz#€2011GAMESITES';

/**
 * Computes salted password hash.
 * @param  string
 * @return string
 */
public static function calculateHash($password)
{
    $text = $password;
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
    $crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, self::$key, $text, MCRYPT_MODE_ECB, $iv);
    return base64_encode($crypttext);
}
</code></pre>

<p>When i try to run it now I get an error:</p>

<blockquote>
  <p>Warning: mcrypt_encrypt(): Key of size 29 not supported by this
  algorithm. Only  keys of sizes 16, 24 or 32 supported in ..\Hash.php
  on line 27</p>
</blockquote>

<p>I know it takes a long time from 2011 and there can be better ways to do it now, but I need to make it work from previous version for some historical issue. What i am doing wrong? 
I cant even see what size 29 does it mean.</p>

<p>Or alternativly is there a way how to break a hash if I still got a function?
with this i can potencialy start using new way of calculating hash.</p>

<p>Thanks for any advise</p>
","<p>If you consult the changelog in <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">the documentation for <code>mcrypt_encrypt</code></a>, you should see that since PHP 5.6.0...</p>

<blockquote>
  <p>Invalid <strong><code>key</code></strong> and <strong><code>iv</code></strong> sizes are no longer accepted. <strong><code>mcrypt_encrypt()</code></strong> will now throw a warning and return <strong><code>FALSE</code></strong> if the inputs are invalid. Previously keys and IVs were padded with <em><code>'\0'</code></em> bytes to the next valid size.</p>
</blockquote>

<p>The solution is therefore to replace your key by one that is padded with null characters to 32 bytes.</p>

<p>Unfortunately, there is a non-ASCII character in there (the euro sign), so there are multiple possibilities how that is supposed to be encoded. It's probably best to manually encode this character. In Unicode, the euro sign has codepoint U+20AC, which would translate to '\xE2\x82\xAC' (which explains why mcrypt counts 29 bytes instead of 27), making your new key</p>

<pre><code>private static $key = 'G@W351T35.cz#\xE2\x82\xAC2011GAMESITES\0\0\0';
</code></pre>

<p>Note that we have to assume some character encoding for your code; I have assumed UTF-8. It's unlikely but possible that, in 2011, it was supposed to be encoded in another character encoding (e.g. ISO-8859-1), which results in a very different encoding for the euro sign.</p>
","1072","<php><mcrypt><rijndael>","-1","1","2","2016-07-01 12:04:01","38144972","2","","","user824425","2016-07-01 11:53:33","2016-06-30 19:39:51",""
"7296146","Is that OK to use static IV value in Rijndael encryption for many files?","<p>I have a question about <strong>IV</strong> in <strong>Rijndael encryption</strong>.</p>

<p>My current approach of using Rijndael is to use a pair of <strong>static</strong> <code>Key</code> and <code>Iv</code> for all encryption operations (I mean I use this pair of Key and Iv for all protected files in my computer).</p>

<p>I heard that IV must be <code>unique</code> for each Rijndael encryption. Is that true? What is the problem (if any) for my current approach of using <code>single static Key and Iv pair</code>?</p>
","<p>If you encrypt the same message twice, you'll get the same results - by varying <em>either</em> the key <em>or</em> the IV, that won't be the case. (Varying the IV is simpler as you can transmit that in plain text; it doesn't involve any sort of secret exchange.)</p>

<p>That means if you reuse the same IV, that can give information to an attacker: if they know the contents of one message, and they see the same encrypted data again, they'll know it's the same message.</p>

<p>So yes, I would vary the IV each time. (And try to avoid using the same key everywhere, ideally... it's like using the same password for multiple web sites: it means if you're compromised in one place, you've lost security everywhere.)</p>
","1060","<.net><vb.net><encryption-symmetric><rijndael>","3","4","2","2011-10-03 22:09:32","7296186","1","2","774411","","2011-10-03 22:09:32","2011-09-03 22:07:37",""
"7296146","Is that OK to use static IV value in Rijndael encryption for many files?","<p>I have a question about <strong>IV</strong> in <strong>Rijndael encryption</strong>.</p>

<p>My current approach of using Rijndael is to use a pair of <strong>static</strong> <code>Key</code> and <code>Iv</code> for all encryption operations (I mean I use this pair of Key and Iv for all protected files in my computer).</p>

<p>I heard that IV must be <code>unique</code> for each Rijndael encryption. Is that true? What is the problem (if any) for my current approach of using <code>single static Key and Iv pair</code>?</p>
","<p>The initialization vector initializes the AES engine to a specific state.
The main goal of using a dynamic IV is that two consecutive encryptions of the same file won't result in the same encrypted value.
To decrypt the file, you also need to initialize the AES engine with this same IV. As a consequence, the IV has to be stored with your encrypted file.</p>

<p>I don't think that the initialization vector will offer much additional security in your use case. It's nice to have it when you're encrypting data that can be subject to dictionnary attacks (passwords on the wire, card numbers, PIN code). For files, it will hardly be possible..</p>
","1060","<.net><vb.net><encryption-symmetric><rijndael>","3","2","2","2011-10-03 22:09:32","7296186","1","2","774411","","2011-10-03 22:09:32","2011-09-03 22:07:37",""
"30395377","Base64_to_stream Turbo power Lockbox 3.6.2 Delphi Xe7 | E2010 Incompatible types: 'System.TArray<System.Byte>' and 'string'","<p>i am trying to make program to encrypt on delphi XE7 and Decrypt on PHP side</p>

<p>i use Lock box 3.6.2 using AES 256 Encryption CBC mode  .</p>

<p>the Delphi XE7 Code : </p>

<p><strong>Main.pas</strong></p>

<pre><code>unit Main;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes,
  System.Variants,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,
  TPLB3.CryptographicLibrary, TPLB3.BaseNonVisualComponent, TPLB3.Codec,
  FMX.StdCtrls, FMX.Controls.Presentation, FMX.Edit, System.Actions,
  FMX.ActnList, FMX.Menus, FMX.ExtCtrls, FMX.Layouts, FMX.Memo;

type
  TForm2 = class(TForm)
    codecAES: TCodec;
    cryptoMain: TCryptographicLibrary;
    btnEncrypt: TButton;
    actlstMain: TActionList;
    edtSeed: TEdit;
    edtPassword: TEdit;

    rgCipher: TPopupBox;
    rgChainMode: TPopupBox;
    rgTestVectors: TPopupBox;
    btnRandomize: TButton;
    memoOutput: TMemo;
    memoPlaintext: TMemo;
    Action1: TAction;
    Action2: TAction;
    procedure actEncryptUpdate(Sender: TObject);
    procedure actEncryptExecute(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure rgTestVectorsClick(Sender: TObject);
    procedure rgChainModeClick(Sender: TObject);
    procedure actRandomizeUpdate(Sender: TObject);
    procedure actRandomizeExecute(Sender: TObject);

  private
    procedure LogFmt(const sLine: string; const Args: array of const);
    function SpaceOut(const sCompacted: string): string;
  public
    { Public declarations }
  end;

var
  Form2: TForm2;

implementation

uses uTPLb_Random, uTPLb_StreamUtils, uTPLb_Constants;

{$R *.fmx}



function StreamToHex(Data: TStream): string;
var
  b: byte;
  sByte: string;
begin
  Data.Position := 0;
  result := '';
  while Data.Read(b, 1) = 1 do
  begin
    sByte := Format('%x', [b]);
    if Odd(Length(sByte)) then
      sByte := '0' + sByte;
    result := result + sByte
  end
end;

procedure TForm2.actEncryptExecute(Sender: TObject);
const
  TestCaseNames: array [0 .. 2] of string = ('Test Vector 1', 'Test Vector 2',
    'Custom');
var
  usPlaintext: String;
  aCiphertext: string;
  OriginalSeed: int64;
  stmCipher: TStream;
  FEncoding : TEncoding;
  sHex: string;

begin
  memoOutput.Lines.Clear;
  case rgCipher.ItemIndex of
    0:
      codecAES.BlockCipherId := Format(AES_ProgId, [128]);
  end;
  case rgChainMode.ItemIndex of
    0:
      codecAES.ChainModeId := CFB_ProgId;
    1:
      codecAES.ChainModeId := CBC_ProgId;
    2:
      codecAES.ChainModeId := ECB_ProgId;
  end;

  codecAES.UTF8Password := edtPassword.Text;
  usPlaintext := memoPlaintext.Lines.Text;
  OriginalSeed := StrToInt64(edtSeed.Text);
  TRandomStream.Instance.Seed := OriginalSeed;
  codecAES.EncryptString(usPlaintext, aCiphertext, FEncoding.UTF8);
  // NextSeed := TRandomStream.Instance.Seed;
  LogFmt('Test case = %s', [TestCaseNames[rgTestVectors.ItemIndex]]);
  LogFmt('Cipher = %s', [codecAES.Cipher]);
  LogFmt('Chain mode = %s', [codecAES.ChainMode]);
  LogFmt('PRNG seed = %d', [OriginalSeed]);
  LogFmt('Passord (UTF-8) = ''%s''', [codecAES.UTF8Password]);

  LogFmt('------------', []);
  stmCipher := TMemoryStream.Create;
  codecAES.Key.SaveToStream(stmCipher);
  sHex := StreamToHex(stmCipher);
  stmCipher.Free;
  LogFmt('key as hex = %s', [sHex]);
  LogFmt('Plaintext (UTF-8)', []);
  LogFmt('''%s''', [usPlaintext]);
  LogFmt('------------', []);
  LogFmt('ciphertext (base64) [Includes prepended IV and block quantisation] =',
    []);
  LogFmt(' ''%s''', [SpaceOut(aCiphertext)]);
  LogFmt('------------', []);
  stmCipher := TMemoryStream.Create;
  Base64_to_stream(aCiphertext, stmCipher);
  sHex := StreamToHex(stmCipher);
  stmCipher.Free;
  LogFmt('ciphertext (hex) [Includes prepended IV and block quantisation] =', []
    );
  LogFmt(' ''%s''', [SpaceOut(sHex)]);
  LogFmt('------------', []);
end;

procedure TForm2.actEncryptUpdate(Sender: TObject);
begin
  //
end;

procedure TForm2.actRandomizeExecute(Sender: TObject);
begin
  TRandomStream.Instance.Randomize;
  edtSeed.Text := IntToStr(TRandomStream.Instance.Seed)
end;

procedure TForm2.actRandomizeUpdate(Sender: TObject);
begin
  (Sender as TAction).Enabled := rgTestVectors.ItemIndex = 2
end;

procedure TForm2.FormCreate(Sender: TObject);
begin
  memoOutput.Lines.Clear;
  LogFmt('Select test case and chain mode.', []);
  LogFmt('Enter password and plaintext message and then press the ''Encrypt'' button.',
    []);
end;

procedure TForm2.LogFmt(const sLine: string; const Args: array of const);
begin
  memoOutput.Lines.Add(Format(sLine, Args))
end;

procedure TForm2.rgChainModeClick(Sender: TObject);
begin
  //
end;

procedure TForm2.rgTestVectorsClick(Sender: TObject);
var
  isCustom: boolean;
begin
  case rgTestVectors.ItemIndex of
    0:
      begin
        edtPassword.Text := 'Your lips are smoother than vasoline.';
        memoPlaintext.Lines.Text := 'Leeeeeeeeeroy Jenkins!';
        // Above is constrained to:
        // More than 16 and not a whole multiple of 16 bytes as UTF-8.
        edtSeed.Text := '1';
        rgChainMode.ItemIndex := 0;
        rgCipher.ItemIndex := 0;
      end;
    1:
      begin
        edtPassword.Text := 'ORATIO IN L. CATILINAM PRIMA';
        memoPlaintext.Lines.Text := 'Quo usque tandem abutere, Catili';
        // Above is constrained to:
        // A whole multiple of 16 bytes as UTF-8, excluding the empty case.
        edtSeed.Text := '333';
        rgChainMode.ItemIndex := 0;
        rgCipher.ItemIndex := 0
      end;
    2:
      ;
  end;
  isCustom := rgTestVectors.ItemIndex = 2;
  edtPassword.ReadOnly := not isCustom;
  memoPlaintext.ReadOnly := not isCustom;
  edtSeed.ReadOnly := not isCustom;
  rgChainMode.Enabled := isCustom;
  rgCipher.Enabled := isCustom
end;

function TForm2.SpaceOut(const sCompacted: string): string;
const
  NewLineSpacing = 70;
  BunchSpacing = 6;
var
  i, j: integer;
begin
  SetLength(result, 2 * Length(sCompacted));
  i := 1;
  for j := 1 to Length(sCompacted) do
  begin
    if ((j mod NewLineSpacing) = 1) and (j &lt;&gt; 1) then
    begin
      result[i] := #13;
      Inc(i);
      result[i] := #10;
      Inc(i)
    end
    else if ((j mod BunchSpacing) = 1) and (j &lt;&gt; 1) then
    begin
      result[i] := ' ';
      Inc(i)
    end;
    result[i] := sCompacted[j];
    Inc(i)
  end;
  SetLength(result, i - 1)
end;

end.
</code></pre>

<p>and it can't compile give the fallowing error :</p>

<pre><code>[dcc32 Error] Main.pas(125): E2010 Incompatible types: 'System.TArray&lt;System.Byte&gt;' and 'string'
</code></pre>

<p><strong>and the PHP side :</strong> </p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
 &lt;head&gt;
    &lt;META HTTP-EQUIV=""CONTENT-TYPE"" CONTENT=""text/html; charset=UTF-8""&gt;
    &lt;META NAME=""ROBOTS"" CONTENT=""NOINDEX,NOFOLLOW,NOARCHIVE"" /&gt;
    &lt;META NAME=""DESCRIPTION"" CONTENT=""Tutorial and demostration page for Delphi (TurboPower LockBox3) to PHP symetric cryptography."" /&gt;
    &lt;META NAME=""AUTHOR"" CONTENT=""Sean B. Durkin""&gt;
    &lt;META HTTP-EQUIV=""CACHE-CONTROL"" CONTENT=""NO-CACHE""&gt;
    &lt;META NAME=""KEYWORDS"" CONTENT=""cryptography,delphi,php,turbopower,lockbox,lockbox3""&gt;
    &lt;title&gt;Delphi-to-PHP Cryptography Tutorial&lt;/title&gt;
    &lt;link rel=""stylesheet"" media=""screen and (min-device-width:  721px)"" href=""tut.css"" /&gt;&lt;!-- &lt;== Desktop. --&gt;     
    &lt;link rel=""stylesheet"" media=""screen and (max-device-width:  720px)"" href=""tut-phone.css"" / --&gt;&lt;!-- &lt;== Phone and tablet. --&gt;  
 &lt;head&gt;

&lt;body&gt;
&lt;?php
error_reporting(E_ALL | E_COMPILE_ERROR);
$password = $_GET[""password""];
$ciphertext_trans = $_GET[""ciphertext-trans""];
$rawInputCiphertext = $_GET[""ciphertext""];
$chain = $_GET[""chain""];
$cipherIn = $_GET[""cipherIn""];

function radioChecked($param,$value,$isDefault)
{
  $echo = (($param == $value) or ($isDefault and ($param == ''))) ? ' checked=""checked"" ' : '';
  echo $echo;
  return $echo != '';  
}
?&gt;

&lt;nav&gt;
  &lt;div class=""nav-bg""&gt;&lt;/div&gt;
  &lt;div class=""nav-content""&gt;
    &lt;h1&gt;&lt;a href=""http://lockbox.seanbdurkin.id.au/tiki-index.php?page=Delphi-to-PHP+Tutorial+project+home"" title=""Go to The Delphi-to-PHP project home""&gt;&lt;span class=""hidden""&gt;Project home&lt;/span&gt;&lt;/a&gt;&lt;/h1&gt;
    &lt;dl&gt;
      &lt;dt&gt;Date created&lt;/dt&gt;
      &lt;dd&gt;&lt;time datetime=""2012-11-29""&gt;29-Nov-2012&lt;/time&gt;&lt;/dd&gt;
    &lt;/dl&gt;
    &lt;dl&gt;
      &lt;dt&gt;Date last modified&lt;/dt&gt;
      &lt;dd&gt;&lt;time datetime=""2012-12-02""&gt;2-Dec-2012&lt;/time&gt;&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/div&gt;    
&lt;/nav&gt;

&lt;h1&gt;Decrypt with PHP from Delphi (TurboPower LockBox3)&lt;/h1&gt;
&lt;form id=""plainForm"" class=""floatbox"" action=""""&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Crypto data&lt;/legend&gt;
    &lt;label class=""first"" for=""password""&gt;Password (UTF-8)
      &lt;input id=""password"" name=""password"" type=""text"" placeholder=""Enter TCodec password"" value=""&lt;?php echo htmlspecialchars($password) ?&gt;"" /&gt;
    &lt;/label&gt;            
    &lt;fieldset class=""radio""&gt;
      &lt;legend&gt;Transport encoding&lt;/legend&gt;
        &lt;label for=""ciphertext-trans-base64""&gt;
          &lt;input id=""ciphertext-trans-base64"" name=""ciphertext-trans"" type=""radio"" value=""base64"" 
          &lt;?php radioChecked($ciphertext_trans,'base64',True); ?&gt; /&gt;base64
        &lt;/label&gt;
        &lt;label for=""ciphertext-trans-hex""&gt;
          &lt;input id=""ciphertext-trans-hex"" name=""ciphertext-trans"" type=""radio"" value=""hex"" 
          &lt;?php radioChecked($ciphertext_trans,'hex',False); ?&gt; /&gt;hex
        &lt;/label&gt;
    &lt;/fieldset&gt;             
    &lt;label for=""ciphertext""&gt;Ciphertext (transport encoded)
      &lt;input id=""ciphertext"" name=""ciphertext"" type=""text"" placeholder=""Paste ciphertext here"" value=""&lt;?php echo htmlspecialchars($rawInputCiphertext) ?&gt;"" /&gt;
    &lt;/label&gt;            
  &lt;/fieldset&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Options&lt;/legend&gt;
    &lt;fieldset class=""radio""&gt;
      &lt;legend&gt;Chaining mode&lt;/legend&gt;
        &lt;label for=""chain-cfb""&gt;
          &lt;input id=""chain-cfb"" name=""chain"" type=""radio"" 
            value=""CFB"" &lt;?php radioChecked($chain,'CFB',True); ?&gt; /&gt;CFB
        &lt;/label&gt;
        &lt;label for=""chain-cbc""&gt;
          &lt;input id=""chain-cbc"" name=""chain"" type=""radio""
            value=""CBC"" &lt;?php radioChecked($chain,'CBC',False); ?&gt; /&gt;CBC
        &lt;/label&gt;
        &lt;label for=""chain-ecb""&gt;
          &lt;input id=""chain-ecb"" name=""chain"" type=""radio""
            value=""ECB"" &lt;?php radioChecked($chain,'ECB',False); ?&gt; /&gt;ECB
        &lt;/label&gt;
    &lt;/fieldset&gt;             

    &lt;fieldset class=""radio""&gt;
      &lt;legend&gt;Cipher&lt;/legend&gt;
        &lt;label for=""aes-128""&gt;
          &lt;input id=""aes-128"" name=""cipherIn"" type=""radio"" 
            value=""AES-128"" &lt;?php radioChecked($cipherIn,'AES-128',True); ?&gt; /&gt;AES-128
        &lt;/label&gt;
        &lt;!-- Extend here with more ciphers as required. Note: PHP does not support AES-256. --&gt;
    &lt;/fieldset&gt;             

    &lt;/fieldset&gt;             
  &lt;input class=""submit"" type=""submit"" value=""Decrypt"" /&gt;
&lt;/form&gt;
&lt;?php if ($chain) { ?&gt;
&lt;?php
function purgeWhiteSpace($sparseHex)
{
    return preg_replace('/\s+/', '', $sparseHex);
}
function expandWithWhiteSpace($compactHex)
{
// TODO: Insert white space for visual benefit. Bunch the brown spaces
//  into words of 6 characters, and then separate words with a single space.
//  Between every 10th word and 11th word, use a new-line ($0D) instead of space.
//  Assume that $compactHex ONLY consists of characters 0..9 and A..F .
    return $compactHex;
}
function displayableMultiline($str)
{
// TODO: Assume $str ONLY consists of characters whose code-points are below
//  137. Insert '&lt;br /&gt;' before each $0D character.
    return $str;
}
function hexToStr($hex)
{
    $hex2 = purgeWhiteSpace( $hex);
    $str='';
    for ($i=0; $i &lt; strlen($hex2)-1; $i+=2)
    {
        $str .= chr(hexdec($hex2[$i].$hex2[$i+1]));
    }
    return $str;
}   
function strToHex($str)
{
    $hex='';
    for ($i=0; $i &lt; strlen($str); $i++)
    {       
        $addend = dechex(ord($str[$i]));
        if (strlen($addend) &lt; 2)
          $addend = '0' . $addend;
        $hex .= $addend;
    }
    return $hex;
}

$normalisedRawCiphertext = purgeWhiteSpace( $rawInputCiphertext);
if ($ciphertext_trans == 'base64')
{ 
  $ciphertext = base64_decode( $normalisedRawCiphertext);
}
else
{
  $ciphertext = hexToStr( $normalisedRawCiphertext);
}

if ($cipherIn == 'AES-128')
{
  $cipher = MCRYPT_RIJNDAEL_128;
  $cipherName = 'AES-128';
}
else
{
  // Extend here with more ciphers as required. Note: PHP does not support AES-256.
  $cipher = MCRYPT_RIJNDAEL_128; // Example only.
  $cipherName = '???';           // Example only.
}

if ($chain == 'CFB')
    $mode = 'ncfb';  // Proper block-mode CFB. There is no constant for this.
  else if ($chain == 'CBC') 
    $mode = MCRYPT_MODE_CBC;
  else  
    $mode = MCRYPT_MODE_ECB;

$blockSize = mcrypt_get_block_size( $cipher, $mode);
$keySize = mcrypt_get_key_size( $cipher, $mode);

// Work-around PHP bugs.
if (($cipher == MCRYPT_RIJNDAEL_128) and ($keySize == 32))
  { $keySize = 16; }   // AES-128 key size is 16 bytes.
if (($cipher == MCRYPT_RIJNDAEL_256) and ($blockSize == 32))
  { $blockSize = 16; } // AES-256 block size is 16 bytes.

$ivSize = $blockSize; // Always. mcrypt_get_iv_size() is pointless.

if ($chain == 'ECB')
{
    $iv = str_pad( 'NOT USED', 16, chr(0));
    // $ciphertext unchanged.
}
else
{
    $iv = substr( $ciphertext, 0, 8);
    $iv = str_pad( $iv, $ivSize, chr(0));
    $ciphertext = substr( $ciphertext, 8);
}

$ciphertextLen = strlen( $ciphertext);
if  (($ciphertextLen &gt; 0) &amp;&amp; ($ciphertextLen &lt; $blockSize) &amp;&amp; ($chain == 'CBC'))
 { $mode = MCRYPT_MODE_CFB; } // CFB 8-bit. This is NOT the same as CFB.

if (strlen($password)==$keySize)
  {
    $key = $password;
  }
else
  {
    $shaPassword = sha1( $password, True);
    for ($key = ''; strlen( $key) &lt; $keySize; $key .= $shaPassword) {}
    $key = substr( $key, 0, $keySize);
  }  

$countBlocks = $ciphertextLen / $blockSize;
$countWholeBlocks = floor( $countBlocks); 
$isRound = $countBlocks == $countWholeBlocks; 
if ($isRound)
    {
    $lastBlockSize = 0;
    }
  else
    {
    $countBlocks = $countWholeBlocks + 1;
    $lastBlockSize = $ciphertextLen - ($countWholeBlocks * $blockSize);
    }     
$isCipherStealing = ($mode == MCRYPT_MODE_CBC) &amp;&amp; ($countWholeBlocks &gt;= 1) &amp;&amp; !$isRound;
if ($isCipherStealing)
    { // Reverse ciphertext stealing.
/* 
Ciphertext stealing algorithm - Encryption:
  Mix     := Enc( CV[N-2], X[N-2]);
  Steal   := Last( B-b, Mix);
  Recycle := X[N-1] + Steal;
  Y[N-2]  := Enc( CV[N-2], Recycle);
  Y[N-1]  := Head( b, Mix);

Ciphertext stealing algorithm - Decryption:
  Recycle := Dec( CV[N-2], Y[N-2]);
  Steal   := Last( B-b, Recycle);
  Mix     := Y[N-1] + Steal;
  X[N-2]  := Dec( CV[N-2], Mix);
  X[N-1]  := Head( b, Recycle);  
*/  
    // 1. Recycle := Dec( CV[N-2], Y[N-2]);
    $Recycle = mcrypt_decrypt ( $cipher, $key, substr( $ciphertext, 0, $countWholeBlocks * $blockSize), $mode, $iv);
    $reconUpToX_N_3 = substr( $Recycle, 0, ($countWholeBlocks - 1) * $blockSize); // X[0]..X{N-3]
    $Recycle = substr( $Recycle, ($countWholeBlocks - 1) * $blockSize, $blockSize);

    // 2. Steal := Last( B-b, Recycle);
    $Steal = substr( $Recycle, $lastBlockSize, $blockSize - $lastBlockSize);

    // 3. Mix := Y[N-1] + Steal;
    $Y_N1 = substr( $ciphertext, $countWholeBlocks * $blockSize, $lastBlockSize);
    $Mix = $Y_N1 . $Steal;

    // 4. X[N-2]  := Dec( CV[N-2], Mix);
    $reconUpToX_N_2 = mcrypt_decrypt ( $cipher, $key, substr( $ciphertext, 0, ($countWholeBlocks - 1) * $blockSize) . $Mix, $mode, $iv);

    // 5. X[N-1] := Head( b, Recycle);
    $reconX_N_1 = substr( $Recycle, 0, $lastBlockSize);

    // Putting it alltogether.
    $recon = $reconUpToX_N_2 . $reconX_N_1;
    }
  else
    { // Normal decyrption.
    $recon = mcrypt_decrypt ( $cipher, $key, $ciphertext, $mode, $iv);
    }
if (($chain == 'ECB') and ($recon != ''))
  { // Trim ECB padding.
  $last = strlen($recon);
  for ($l = strlen($recon); ($l &gt;= 0) and (ord($recon[$l])==0); $l--)
    {$last = $l;}
  $recon = substr( $recon, 0, $last-1);
  }
?&gt;
&lt;hr /&gt;
&lt;h2&gt;Output&lt;/h2&gt;
&lt;h3&gt;Summary2&lt;/h3&gt;
&lt;p&gt;Cipher is &lt;em&gt;&lt;?php echo $cipherName; ?&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Block size is &lt;?php echo $blockSize; ?&gt; bytes&lt;/p&gt;
&lt;?php if ($isRound) { ?&gt;
  &lt;p&gt;Given ciphertext was a round &lt;?php echo $countBlocks; ?&gt; blocks long.&lt;/p&gt;
&lt;?php } else { ?&gt;
  &lt;p&gt;Given ciphertext was a &lt;?php echo $countWholeBlocks; ?&gt; whole blocks long and &lt;?php echo $lastBlockSize; ?&gt; bytes in an odd block.&lt;/p&gt;
&lt;?php } ?&gt;
&lt;p&gt;Key size is &lt;?php echo $keySize; ?&gt; bytes&lt;/p&gt;
&lt;p&gt;Given chain mode was &lt;em&gt;&lt;?php echo $chain; ?&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Given password was &lt;em&gt;&amp;apos;&lt;?php echo htmlspecialchars($password); ?&gt;&amp;apos;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ciphertext as hex is...&lt;/p&gt;
&lt;code&gt;&lt;?php echo '[' . $ciphertextLen . '] ' . displayableMultiline( expandWithWhiteSpace( strToHex( $ciphertext))); ?&gt;&lt;/code&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Reconstructed plaintext message is &lt;em&gt;&amp;apos;&lt;?php echo htmlspecialchars( $recon); ?&gt;&amp;apos;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h2&gt;Debug&lt;/h2&gt;
&lt;p&gt;Key as hex is...&lt;/p&gt;
&lt;code&gt;&lt;?php echo '[' . strlen($key) . '] ' . expandWithWhiteSpace( strToHex( $key)); ?&gt;&lt;/code&gt;
&lt;p&gt;IV as hex is...&lt;/p&gt;
&lt;code&gt;&lt;?php echo '[' . strlen($iv) . '] ' . expandWithWhiteSpace( strToHex( $iv)); ?&gt;&lt;/code&gt;
&lt;p&gt;$countBlocks = &lt;code&gt;&lt;?php echo $countBlocks; ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$countWholeBlocks = &lt;code&gt;&lt;?php echo $countWholeBlocks; ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$isRound = &lt;code&gt;&lt;?php echo $isRound ? 'True' : 'False'; ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$isCipherStealing = &lt;code&gt;&lt;?php echo $isCipherStealing ? 'True' : 'False'; ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$lastBlockSize = &lt;code&gt;&lt;?php echo $lastBlockSize; ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$Recycle = &lt;code&gt;&lt;?php echo '[' . strlen($Recycle) . '] ' . strToHex( $Recycle); ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$recon X[0..N-3] = &lt;code&gt;&lt;?php echo '[' . strlen($reconUpToX_N_3) . '] ' . strToHex( $reconUpToX_N_3); ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$Steal = &lt;code&gt;&lt;?php echo '[' . strlen($Steal) . '] ' . strToHex( $Steal); ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$Mix = &lt;code&gt;&lt;?php echo '[' . strlen($Mix) . '] ' . strToHex( $Mix); ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$recon X[0..N-2] = &lt;code&gt;&lt;?php echo '[' . strlen($reconUpToX_N_2) . '] ' . strToHex( $reconUpToX_N_2); ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$recon X[N-1] = &lt;code&gt;&lt;?php echo '[' . strlen($reconX_N_1) . '] ' . strToHex( $reconX_N_1); ?&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Reconstructed plaintext as hex is...&lt;/p&gt;
&lt;code&gt;&lt;?php echo '[' . strlen($recon) . '] ' . expandWithWhiteSpace( strToHex( $recon)); ?&gt;&lt;/code&gt;
&lt;?php } ?&gt;
&lt;/body&gt; 
&lt;/html&gt;
</code></pre>

<p>i don't have any problem on it till now but i have one question in case of 256 AES i shall use <strong>MCRYPT_RIJNDAEL_128</strong> or <strong>MCRYPT_RIJNDAEL_256</strong></p>

<p>thanks you in advance for helping !</p>
","<p>This line fails:</p>

<pre><code>Base64_to_stream(aCiphertext, stmCipher);
</code></pre>

<p>Now, <code>Base64_to_stream</code> is declared in <code>TPLB3.StreamUtils</code> like this:</p>

<pre><code>procedure Base64_to_stream(const Base64: string; Destin: TStream);
</code></pre>

<p>If you were attempting to call that <code>Base64_to_stream</code> then you would not see a compilation error. Since you don't include <code>TPLB3.StreamUtils</code> in your uses clause, one can only assume that one of your units defines an different <code>Base64_to_stream</code> that accepts <code>TArray&lt;Byte&gt;</code> as its first argument.</p>

<p><strong>Update</strong></p>

<p>Judging by your unit names, and the link supplied by @TOndrej, it very much looks like you are mixing and matching LockBox implementations. These units, <code>uTPLb_Random</code>, <code>uTPLb_StreamUtils</code> and <code>uTPLb_Constants</code> would all appear to be from a different LockBox implementation. </p>

<p>I suggest that you take a look at where you are getting these different LockBox implementations from. You should be using exactly one LockBox implementation. And perhaps you should consider not using search paths and instead explicitly adding the units to your project. That way you won't accidentally be able to use units that you don't want to use.</p>
","1039","<delphi><encryption><base64><rijndael><lockbox-3>","1","2","1","2015-05-22 12:09:33","30395643","2","","","","","2015-05-22 11:20:30",""
"5814361","Rijndael encryption. First characters are weird","<p>Code i'm using (XE):</p>

<pre><code>// Encrypt a string and return the Base64 encoded result
function Encrypt(DataToEncrypt: ansistring):ansistring;
const Key: Ansistring = 'keykey';
  KeySize = 32; // 32 bytes = 256 bits
  BlockSize = 16; // 16 bytes = 128 bits
var
  Cipher : TDCP_rijndael;
  Data: ansistring;
  IV: array[0..15] of byte;      // the initialization vector
  i:Integer;
begin
  // Pad Key, IV and Data with zeros as appropriate
  FillChar(IV,Sizeof(IV),0);            // make the IV all zeros

  Data := PadWithZeros(DataToEncrypt,BlockSize);

  for i := 0 to (Length(IV) - 1) do   //just random values for the IV
    IV[i] := Random(256);

  Cipher := TDCP_rijndael.Create(nil);

  if Length(Key) &lt;= 16 then
    Cipher.Init(Key[1],128,@IV[1])
  else if Length(Key) &lt;= 24 then
    Cipher.Init(Key[1],192,@IV[1])
  else
    Cipher.Init(Key[1],256,@IV[1]);
  // Encrypt the data
  Cipher.EncryptCBC(Data[1],Data[1],Length(Data));
  // Free the cipher and clear sensitive information
  Cipher.Free;

  SetString(InitializationVector,PAnsiChar(@IV[1]),Length(IV));  //Save IV
  InitializationVector := Base64EncodeStr(InitializationVector);

  //Base64 encoded result
  Result := Base64EncodeStr(Data);
end;

function Decrypt(IV,Cryptogram:ansistring):ansistring;
const Key: Ansistring = 'keykey';
  KeySize = 32; // 32 bytes = 256 bits
  BlockSize = 16; // 16 bytes = 128 bits
var
  Cipher : TDCP_rijndael;
begin
  if IV='' then
    IV := InitializationVector;

  Cryptogram := Base64DecodeStr(cryptogram);
  // Create the cipher and initialise according to the key length
  cipher := tdcp_rijndael.Create(nil);
  if Length(Key) &lt;= 16 then
    Cipher.Init(Key[1],128,@IV[1])
  else if Length(Key) &lt;= 24 then
    Cipher.Init(Key[1],192,@IV[1])
  else
    Cipher.Init(Key[1],256,@IV[1]);
  // Decrypt the data
  Cipher.DecryptCBC(cryptogram[1],cryptogram[1],Length(cryptogram));
  // Free the cipher and clear sensitive information
  Cipher.Free;
  // Display the result
  Result := cryptogram;
end;
</code></pre>

<p>It works pretty well, except when i try to decrypt the string, i get:</p>

<h1>$C#$C'Ç'#$B'ÛW'#$1F'Ø‹™Ç'#$8D'Ž'#$8D'!‘mydata</h1>

<p>so first few letters get very weird characters. rest of it is decrypted just fine!
Found similar problem <a href=""http://www.experts-exchange.com/Programming/Languages/Pascal/Delphi/Q_26402183.html"" rel=""nofollow"">here</a>, but no solution.
Thanks in advance!</p>
","<p>The first thing that stands out to me is that you are reading/writing past the end of IV. You declare it as [0..15] but access everything from element 1(!) onwards, both in Cipher.Init and SetString.</p>
","1031","<delphi><encryption><delphi-xe><rijndael>","0","5","1","2012-08-11 20:39:09","5822731","0","","576719","","2012-08-11 20:39:09","2011-04-28 06:10:45",""
"5154837","How do I determine that the key or vector are incorrect using Rijndael to decrypt a file?","<p>When I use the wrong key, I am getting a ""decrypted"" garbage file and an exception from mscorlib.dll, ""Specified block size is not valid for this algorithm.""  What I would like instead is for the decryption to fail entirely without throwing an exception.</p>

<p>Here's my current code (adapted from a vb.net example I found on the internet, so better solution would be appreciated if out there)</p>

<pre><code>    public static bool EncryptOrDecryptFile(string strInputFile,
        string strOutputFile, string pKey, string pIv, CryptoAction Direction)
    {
        Byte[] bytKey = CreateKey(pKey);
        Byte[] bytIV = CreateIV(pIv);
        bool pRet = false;
        if (!File.Exists(strInputFile))
            return false;

        try
        {
            using (FileStream fsInput = new FileStream(strInputFile, FileMode.Open, FileAccess.Read))
            {
                using (FileStream fsOutput = new FileStream(strOutputFile, FileMode.OpenOrCreate, FileAccess.Write))
                {
                    fsOutput.SetLength(0);
                    byte[] bytBuffer = new byte[4097];
                    long lngBytesProcessed = 0;
                    long lngFileLength = fsInput.Length;
                    int intBytesInCurrentBlock = 0;
                    CryptoStream csCryptoStream = null;
                    RijndaelManaged cspRijndael = new RijndaelManaged();
                    cspRijndael.BlockSize = 4096;
                    switch (Direction)
                    {
                        case CryptoAction.ActionEncrypt:
                            csCryptoStream = new CryptoStream(fsOutput, cspRijndael.CreateEncryptor(bytKey, bytIV),
                                                              CryptoStreamMode.Write);
                            break;
                        case CryptoAction.ActionDecrypt:
                            csCryptoStream = new CryptoStream(fsOutput, cspRijndael.CreateDecryptor(bytKey, bytIV),
                                                              CryptoStreamMode.Write);
                            break;
                    }
                    while (lngBytesProcessed &lt; lngFileLength)
                    {
                        intBytesInCurrentBlock = fsInput.Read(bytBuffer, 0, 4096);
                        csCryptoStream.Write(bytBuffer, 0, intBytesInCurrentBlock);
                        lngBytesProcessed = lngBytesProcessed + Convert.ToInt64(intBytesInCurrentBlock);
                    }
                    csCryptoStream.Close();
                }
            }
            pRet = true;
        }
        catch (Exception ex)
        {
            pRet = false;
        }
        return pRet;
    }
    #endregion
}
</code></pre>
","<p>Given that any combination of bits of the right length could be a valid key, and the same is true for the IV, there's no way for the crypto stream to determine that either is incorrect until it tries to decrypt the final block of cypher text - at which point it detects that the padding is wrong and throws an exception. Also, you can't use any block size you want - there are certain block sizes that are valid for particular crypto providers - for Rijndael, I think valid block sizes are 128, 192 and 256.</p>

<p>The only way to avoid the ""garbage"" file would be to perform all of the decryption in memory, or write to a temporary file rather than the final output file. There's no way to avoid the exception, but it should be an unusual occurrence anyway.</p>

<hr>

<p>I'd also get rid of all of the buffer management in your code, and length checks, etc, and just use <a href=""http://msdn.microsoft.com/en-us/library/system.io.stream.copyto.aspx"" rel=""nofollow"">Stream.CopyTo</a> between your input stream and the crypto stream. E.g.:</p>

<pre><code>using (FileStream fsInput = new FileStream(strInputFile, FileMode.Open, FileAccess.Read))
{
    using (FileStream fsOutput = new FileStream(strOutputFile, FileMode.OpenOrCreate, FileAccess.Write))
    {
        CryptoStream csCryptoStream = null;
        RijndaelManaged cspRijndael = new RijndaelManaged();
        cspRijndael.BlockSize = 256;
        switch (Direction)
        {
            case CryptoAction.ActionEncrypt:
                csCryptoStream = new CryptoStream(fsOutput, cspRijndael.CreateEncryptor(bytKey, bytIV),
                                                  CryptoStreamMode.Write);
                break;
            case CryptoAction.ActionDecrypt:
                csCryptoStream = new CryptoStream(fsOutput, cspRijndael.CreateDecryptor(bytKey, bytIV),
                                                  CryptoStreamMode.Write);
                break;
        }
        fsInput.CopyTo(csCryptoStream);
        csCryptoStream.Close();
    }
}
pRet = true;
</code></pre>
","1012","<c#><.net><encryption><rijndael>","1","1","2","2011-03-01 13:42:13","5154972","0","","","","","2011-03-01 13:02:12",""
"5154837","How do I determine that the key or vector are incorrect using Rijndael to decrypt a file?","<p>When I use the wrong key, I am getting a ""decrypted"" garbage file and an exception from mscorlib.dll, ""Specified block size is not valid for this algorithm.""  What I would like instead is for the decryption to fail entirely without throwing an exception.</p>

<p>Here's my current code (adapted from a vb.net example I found on the internet, so better solution would be appreciated if out there)</p>

<pre><code>    public static bool EncryptOrDecryptFile(string strInputFile,
        string strOutputFile, string pKey, string pIv, CryptoAction Direction)
    {
        Byte[] bytKey = CreateKey(pKey);
        Byte[] bytIV = CreateIV(pIv);
        bool pRet = false;
        if (!File.Exists(strInputFile))
            return false;

        try
        {
            using (FileStream fsInput = new FileStream(strInputFile, FileMode.Open, FileAccess.Read))
            {
                using (FileStream fsOutput = new FileStream(strOutputFile, FileMode.OpenOrCreate, FileAccess.Write))
                {
                    fsOutput.SetLength(0);
                    byte[] bytBuffer = new byte[4097];
                    long lngBytesProcessed = 0;
                    long lngFileLength = fsInput.Length;
                    int intBytesInCurrentBlock = 0;
                    CryptoStream csCryptoStream = null;
                    RijndaelManaged cspRijndael = new RijndaelManaged();
                    cspRijndael.BlockSize = 4096;
                    switch (Direction)
                    {
                        case CryptoAction.ActionEncrypt:
                            csCryptoStream = new CryptoStream(fsOutput, cspRijndael.CreateEncryptor(bytKey, bytIV),
                                                              CryptoStreamMode.Write);
                            break;
                        case CryptoAction.ActionDecrypt:
                            csCryptoStream = new CryptoStream(fsOutput, cspRijndael.CreateDecryptor(bytKey, bytIV),
                                                              CryptoStreamMode.Write);
                            break;
                    }
                    while (lngBytesProcessed &lt; lngFileLength)
                    {
                        intBytesInCurrentBlock = fsInput.Read(bytBuffer, 0, 4096);
                        csCryptoStream.Write(bytBuffer, 0, intBytesInCurrentBlock);
                        lngBytesProcessed = lngBytesProcessed + Convert.ToInt64(intBytesInCurrentBlock);
                    }
                    csCryptoStream.Close();
                }
            }
            pRet = true;
        }
        catch (Exception ex)
        {
            pRet = false;
        }
        return pRet;
    }
    #endregion
}
</code></pre>
","<p>None of the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.ciphermode.aspx"" rel=""nofollow"">modes of operation</a> available for <code>RijndaelManaged</code> provide integrity protection or authentication. Relying on checking the validity of the padding is not a substitute, as you can easily get an incorrect message with valid padding.</p>

<p>Instead, you should apply a <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.hmacsha256.aspx"" rel=""nofollow"">HMAC</a> to the encrypted message.</p>
","1012","<c#><.net><encryption><rijndael>","1","1","2","2011-03-01 13:42:13","5154972","0","","","","","2011-03-01 13:02:12",""
"18728270","Using Rijndael/AES Encryption in TSQL","<p>What are some possible and reliable ways to encrypt using Rijndael/AES in T-SQL? 
Or is using and embedded assembly in order to use c# or vb.net in your SQL Project the only way?</p>
","<p>Look into embedding assemblies in sql server. It is possible but you have to install the assemblies housing your code and use the proper syntax to mold the function wrappers.</p>
","1012","<sql-server><tsql><aes><sqlclr><rijndael>","2","1","1","2013-09-19 15:34:38","18731085","0","","1409090","","2013-09-19 15:34:38","2013-09-10 20:33:57",""
"5857171","C# RijndaelEnhanced decrypt with php mcrypt","<p>i have a C# .net app with i decompiled. Tis app uses for login password cryption:
<a href=""http://www.obviex.com/samples/Sample.aspx?Source=EncryptionWithSaltCS&amp;Title=Encryption%20With%20Salt&amp;Lang=C%23"" rel=""nofollow"">http://www.obviex.com/samples/Sample.aspx?Source=EncryptionWithSaltCS&amp;Title=Encryption%20With%20Salt&amp;Lang=C%23</a></p>

<p>C# Code</p>

<pre><code>rijndaelKey = new Krypto.RijndaelEnhanced(passPhrase, initVector);
PlainPassword = DiverseVariablen.rijndaelKey.Decrypt(Conversions.ToString(row[""ProjectKennwort""])))
</code></pre>

<p>I have pass and iv.</p>

<p>How can i decrypt the passwords in php?
I tryted allready several variants of mcrypt_decrypt().</p>

<p>Didt somene have a idea?</p>

<p>Friendly regards and big thanks.</p>
","<p>It looks like they're using a <a href=""http://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow"">password-based key derivation function</a>.  mycrypt gives you set the key directly and null pads it if appropriate.  The C# library you've linked to derives a password from the key.  A Google search for PBKDF2 PHP reveals the following:</p>

<p>htt&shy;p://www.itnewb.com/v/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard</p>

<p>So I'd try that.  Also, I'd, personally, recommend using <a href=""http://phpseclib.sourceforge.net/"" rel=""nofollow"">phpseclib, a pure PHP AES implementation</a>, for portability.  That PHP is installed on a server doesn't mean that mcrypt is.</p>
","1008","<c#><php><rijndael>","0","1","1","2011-05-03 14:05:43","","0","","734436","","2011-05-02 12:47:13","2011-05-02 12:34:06",""
"27234575","DeflateStream / GZipStream to CryptoStream and vice versa","<p>I want to to compress and encrypt a file in one go by using this simple code:</p>

<pre><code>public void compress(FileInfo fi, Byte[] pKey, Byte[] pIV)
{
    // Get the stream of the source file.
    using (FileStream inFile = fi.OpenRead())
    {                
        // Create the compressed encrypted file.
        using (FileStream outFile = File.Create(fi.FullName + "".pebf""))
        {
            using (CryptoStream encrypt = new CryptoStream(outFile, Rijndael.Create().CreateEncryptor(pKey, pIV), CryptoStreamMode.Write))
            {
                using (DeflateStream cmprss = new DeflateStream(encrypt, CompressionLevel.Optimal))
                {
                    // Copy the source file into the compression stream.
                    inFile.CopyTo(cmprss);
                    Console.WriteLine(""Compressed {0} from {1} to {2} bytes."", fi.Name, fi.Length.ToString(), outFile.Length.ToString());
                }
            }
        }
    }
}
</code></pre>

<p>The following lines will restore the encrypted and compressed file back to the original:</p>

<pre><code>public void decompress(FileInfo fi, Byte[] pKey, Byte[] pIV)
{
    // Get the stream of the source file.
    using (FileStream inFile = fi.OpenRead())
    {
        // Get original file extension, for example ""doc"" from report.doc.gz.
        String curFile = fi.FullName;
        String origName = curFile.Remove(curFile.Length - fi.Extension.Length);

        // Create the decompressed file.
        using (FileStream outFile = File.Create(origName))
        {
            using (CryptoStream decrypt = new CryptoStream(inFile, Rijndael.Create().CreateDecryptor(pKey, pIV), CryptoStreamMode.Read))
            {
                using (DeflateStream dcmprss = new DeflateStream(decrypt, CompressionMode.Decompress))
                {                    
                    // Copy the uncompressed file into the output stream.
                    dcmprss.CopyTo(outFile);
                    Console.WriteLine(""Decompressed: {0}"", fi.Name);
                }
            }
        }
    }
}
</code></pre>

<p>This works also with GZipStream.</p>
","<p>A decompressing stream is expected to be <a href=""http://referencesource.microsoft.com/#System/sys/System/IO/compression/DeflateStream.cs,61"" rel=""nofollow"">read from</a>, not written to.  (unlike a <code>CryptoStream</code>, which supports all four combinations of read/write and encrypt/decrypt)</p>

<p>You should create the <code>DeflateStream</code> around a <code>CryptoStreamMode.Read</code> stream around the input file, then copy from that directly to the output stream.</p>
","1007","<c#><rijndael><gzipstream><deflatestream><cryptostream>","1","1","1","2014-12-01 22:54:52","27234780","4","2","1422215","","2014-12-01 22:54:52","2014-12-01 18:12:55",""
"47073004","Sql Server Rijndael encryption and decryption","<p>Is there any way to perform encryption and decryption using Rijndael in Sql Server ? i have searched internet but out of help</p>
","<p>Yes, it is possible,
You need to create an CLR Assembly in SQL Server</p>

<p>There is a full tutorial in codeProject here doing the trick:</p>

<p><a href=""https://www.codeproject.com/Articles/15296/SQL-Encryption-and-Decryption-Library-Using-Rijnda"" rel=""nofollow noreferrer"">https://www.codeproject.com/Articles/15296/SQL-Encryption-and-Decryption-Library-Using-Rijnda</a></p>

<p>But if you want to make a new one, Just check how to create a CLR Assembly in SQL Server and code yours using Rijndael.</p>

<p>Useful links:</p>

<p><a href=""https://blog.sqlauthority.com/2008/10/19/sql-server-introduction-to-clr-simple-example-of-clr-stored-procedure/"" rel=""nofollow noreferrer"">https://blog.sqlauthority.com/2008/10/19/sql-server-introduction-to-clr-simple-example-of-clr-stored-procedure/</a></p>

<p><a href=""https://msdn.microsoft.com/en-us/library/w2kae45k(v=vs.100).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/w2kae45k(v=vs.100).aspx</a></p>
","1007","<sql-server><encryption><rijndael>","2","1","2","2017-11-02 10:39:26","","1","","3706016","","2017-11-02 10:31:00","2017-11-02 10:29:55",""
"47073004","Sql Server Rijndael encryption and decryption","<p>Is there any way to perform encryption and decryption using Rijndael in Sql Server ? i have searched internet but out of help</p>
","<p>Check out this <a href=""https://www.codeproject.com/Articles/15296/SQL-Encryption-and-Decryption-Library-Using-Rijnda"" rel=""nofollow noreferrer"">link</a></p>

<p>Or if you use C# or any other programming language in accessing the DB you can apply <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndael(v=vs.110).aspx"" rel=""nofollow noreferrer"">Rijndael</a> in it and store already encrypted value in DB. Also when comparing use algorithm in programming language and compare with DB value.</p>
","1007","<sql-server><encryption><rijndael>","2","1","2","2017-11-02 10:39:26","","1","","3706016","","2017-11-02 10:31:00","2017-11-02 10:29:55",""
"11229169","Should I generate a key from a hash for encryption?","<p>I am currently currently using Rijndael 256-bit in CBC mode to encrypt some data which needs to be sent elsewhere. In order to enhance security, I'm taking a randomly generated SHA-256 hash and using a formula to chop off different parts it to use the encryption key and initialization vector (of course, the hash is sent with the data). The formula to generate the key and IV is fairly basic, and because the code is written in PHP, it's coded into a user-accessible page. What I'm wondering is: is this more or less safe than having one constant key and/or IV?</p>
","<p>This is probably NOT the way you wish to go.  In essence, it will take a good hacker not to long to figure out your mathematical formula for manipulating the HASH to generate your key and IV.  Thus you are essentially sending the keys to the kingdom along with the kingdom itself.</p>

<p>Generally the way this type of operation is done, is to generate a session key (could be the same way you are doing it now), but use a public key encryption method to encrypt that session key.  Then you use the public key encryption method to send the session key to the location your data is to be sent.  The receiver has the public key and can encrypt the comm. channel session key.</p>

<p>Now both sides have the comm. channel session key and your REAL data can be encrypted using this key as the session key has not been sent in the clear.</p>

<p>Rijindael is an example of a symmetric crypto algorithm, where public key crypto algorithms are asymmetric.  Examples of public key crypto algorithms are RSA, ECDSA (Crypto), etc....</p>
","999","<encryption><rijndael>","2","2","2","2012-06-27 22:06:19","11229403","3","1","","","","2012-06-27 14:58:41",""
"11229169","Should I generate a key from a hash for encryption?","<p>I am currently currently using Rijndael 256-bit in CBC mode to encrypt some data which needs to be sent elsewhere. In order to enhance security, I'm taking a randomly generated SHA-256 hash and using a formula to chop off different parts it to use the encryption key and initialization vector (of course, the hash is sent with the data). The formula to generate the key and IV is fairly basic, and because the code is written in PHP, it's coded into a user-accessible page. What I'm wondering is: is this more or less safe than having one constant key and/or IV?</p>
","<p>On generating short-use keys.  Have a long term key.  Agree a date format with the receiver.  Each day concatenate your long term key with the day's date and hash it with SHA-256 to generate a day key for use on that date only:</p>

<pre><code>dayKey &lt;- SHA256(""my very secret long term key"" + ""2012-06-27"")
</code></pre>

<p>The receiver will have all the information they need to generate exactly the same key at their end.  Any attacker will know the date, but will not know the long term key.</p>

<p>You will need to agree protocols for around midnight and a few other details.</p>

<p>Change the long term key every month or two, depending on the amount of encrypted data you are passing.  The more data you pass, the more often you need to change the long term key.</p>
","999","<encryption><rijndael>","2","0","2","2012-06-27 22:06:19","11229403","3","1","","","","2012-06-27 14:58:41",""
"20995487","Encrypting using C# AES encryption & decryption from these PHP codes","<p>I am facing some issues in AES encryption using PHP and decode the same using C #. My reference <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""nofollow"">site</a>. </p>

<p>Here is the PHP code:</p>

<pre><code>function encrypt_string($input, $key)
   {
       $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND);
       return preg_replace('/=/', """", base64_encode($iv . mcrypt_encrypt(MCRYPT_RIJNDAEL_128, hash(""sha256"", $key, true), $input, MCRYPT_MODE_CBC, $iv)));
   }

function decrypt_string($input, $key)
   {
       $input .= ""="";
       $data = base64_decode($input);
       $iv = substr($data, 0, mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC));
       return rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128,hash('sha256', $key, true),substr($data, mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC)),MCRYPT_MODE_CBC,$iv),""\0"");
   }
</code></pre>

<p>Here is C# code that I tried:</p>

<pre><code>private static byte[] sha256_data(string input)
{
    SHA256 hash = SHA256Managed.Create();
    Encoding encode = Encoding.UTF8;
    return hash.ComputeHash(encode.GetBytes(input));
}

private string encode_data(string data, string key)
{
    byte[] buff;

    RijndaelManaged rij = new RijndaelManaged();

    rij.BlockSize = 256;
    rij.KeySize = 256;

    rij.GenerateIV();
    rij.Key = sha256_data(key);

    rij.Mode = CipherMode.CBC;
    ICryptoTransform encoder = rij.CreateEncryptor(rij.Key, rij.IV);
    using (MemoryStream mem = new MemoryStream())
    {
        using (CryptoStream crypt = new CryptoStream(mem, encoder, CryptoStreamMode.Write))
        {
            byte[] temp = Encoding.UTF8.GetBytes(data);
            crypt.Write(temp, 0, temp.Length);

        }
        buff = mem.ToArray();
    }
    return Convert.ToBase64String(result);
} 

private string decode_data(string input, string key)
{
    RijndaelManaged rij = new RijndaelManaged();

    rij.KeySize = 256;
    rij.BlockSize = 256;

    rij.Key = sha256_data(key);
    rij.GenerateIV();

    rij.Mode = CipherMode.CBC;
    rij.Padding = PaddingMode.PKCS7;

    ICryptoTransform decrypter = rij.CreateDecryptor();

    byte[] buff;
    using (MemoryStream mem = new MemoryStream())
    {
        using (CryptoStream cstream = new CryptoStream(mem, decrypter, CryptoStreamMode.Write))
        {
            byte[] data = Convert.FromBase64String(input);
            cstream.Write(data, 0, data.Length);
        }
        buff = mem.ToArray();
    }
    return Encoding.UTF8.GetString(buff);
}
</code></pre>

<p>What am i doing wrong?</p>
","<p>when you decode you must parse the IV that was used for encoding not generate a new one.</p>
","975","<c#><php><encryption><aes><rijndael>","1","0","1","2014-01-08 12:36:04","","0","","1685894","","2014-01-08 12:24:46","2014-01-08 12:19:31",""
"16991496","Converting Encoded byte[] to a printable string","<p>I am encoding strings using C#'s Rijndael AES encryption. I generate a key and an IV, and use them to encode strings and values that I can then save to disk (I am using Unity3D's playerprefs).</p>

<p>The problem I am facing is that the PlayerPrefs keys and values need to be valid character sequences, and the encoded bytes are not necessarily valid.</p>

<p>So, after encoding my string with my key and IV, I get a byte array that I can enode in Unicode, but (sometimes) when I try to save it, I get an error message:</p>

<pre><code>byte[] encryptedBytes = Encode(""someText"", encryptionKey, initVector);
string encodedString = Encoding.Unicode.GetString(encryptedBytes);
PlayerPrefs.SetString(""SecretData"",encodedString);
PlayerPrefs.Save();
</code></pre>

<p>Error:</p>

<blockquote>
  <p>invalid utf-16 sequence at -1073752512 (missing surrogate tail)</p>
</blockquote>

<p>Any way to make sure the string is in a valid format?</p>
","<p>The bytes returned by the encrypt function are indistinguishable from random and may not contain valid character encoding. To convert the result into a string (if required) you may use base 64.</p>
","973","<encryption><encoding><unity3d><aes><rijndael>","0","2","1","2013-06-07 19:36:30","16991723","2","","","","","2013-06-07 19:22:17",""
"16218026","AES encrypt C# decrypt Java?","<p>I'm trying to decrypt C# encrypted data in Java without success. I'm using 128 bit key&amp;block size with PKCS7 padding. Here's C# code:</p>

<pre><code>    public byte[] Encrypt(byte[] data, byte[] key)
    {
        using (var ms = new MemoryStream())
        {
            using (var aes = RijndaelManaged.Create())
            {
                aes.Key = key;
                aes.IV = key;
                var stream = new CryptoStream(ms, aes.CreateEncryptor(aes.Key, aes.IV), CryptoStreamMode.Write);
                stream.Write(data, 0, data.Length);
                stream.FlushFinalBlock();
                return ms.ToArray();
            }
        }
    }
</code></pre>

<p>and this is java code:</p>

<pre><code>private static Key generateKey() throws Exception {

    Key key = new SecretKeySpec(Files.readAllBytes(Paths.get(""D:/Temp/cr.key"")), ""AES"");

    return key;
}

public static byte[] decrypt(byte[] encryptedData) throws Exception {
    Key key = generateKey();

    Cipher c = Cipher.getInstance(""AES/CBC/PKCS7Padding"", ""BC"");

    IvParameterSpec ivSpec = new IvParameterSpec(key.getEncoded());
    c.init(Cipher.DECRYPT_MODE, key, ivSpec);

    System.out.println(c.getBlockSize());


    c.update(encryptedData);
    byte[] decValue = c.doFinal();
    return decValue;
}

public static void main(String[] args) throws Exception {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

    byte[] bb = decrypt(Files.readAllBytes(Paths.get(""d:\\Temp\\cr~\\OEBPS\\Chapter001.html"")));
           //decompressFile(bb, new File(""D:\\Temp\\enc.html""));
}
</code></pre>

<p>Any idea what could be wrong?</p>

<p>THanks</p>

<p>UPDATE</p>

<hr>

<p>Sorry, how dumb of me, I forgot to write actual error message. Here it is:</p>

<blockquote>
  <p>Exception in thread ""main"" javax.crypto.BadPaddingException: pad block
  corrupted     at
  org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher.engineDoFinal(Unknown
  Source)   at javax.crypto.Cipher.doFinal(Cipher.java:1970)</p>
</blockquote>

<p>Thanks</p>
","<p>You are forgetting that <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#update%28byte%5b%5d%29"" rel=""nofollow""><code>Cipher.update(byte[]): byte[]</code></a> will return data whenever a full block of ciphertext has been processed.</p>

<p>NOTE: Apparently not an answer to this question, as the exception points to another error. But a bug in the above code none-the-less.</p>
","970","<c#><java><encryption><aes><rijndael>","3","1","1","2013-05-05 09:22:16","","3","4","379079","","2013-04-25 22:16:29","2013-04-25 14:51:01",""
"8527105","Why kohana 3 Encrypt class encode() method returns different string each time?","<p>I'm doing a <code>encode()</code> from the Encrypt class and each time it returns a different string for the same input string.
My <code>application/config/encrypt.php</code>:</p>

<pre><code>return array(
    'default' =&gt; array(
        /**
         * The following options must be set:
         *
         * string   key     secret passphrase
         * integer  mode    encryption mode, one of MCRYPT_MODE_*
         * integer  cipher  encryption cipher, one of the Mcrpyt cipher constants
         */
        'cipher' =&gt; MCRYPT_RIJNDAEL_128,
        'key'    =&gt; 'df58e28f',
        'mode'   =&gt; MCRYPT_MODE_NOFB,
    ),
);
</code></pre>

<p>Use:</p>

<pre><code>$str = Encrypt::instance()-&gt;encode('test');
</code></pre>

<p><code>$str</code> has always a different value. Is that an error or it's supposed to work that way? Why?</p>

<p>Also I must add that I can always <code>decode()</code> that value and get the <code>test</code> string each time.</p>

<p><strong>UPDATE:</strong> Here is a sample output: <code>0vahDa/2Qu3XQWObkjwLPoL73g==</code></p>

<p>Thank you very much.</p>
","<p>Actually this is intentional behaviour. </p>

<p>IMHO this way the encryption is more secure. Most pseudo hackers would think different encrypted values mean different actual values. </p>

<p>The important thing is that you always get the same value upon decryption.</p>

<p>You have to be careful with that: when you want to use the same encrypted string twice you should store it separately, because encrypting again would not produce the same thing.</p>
","953","<php><encryption><kohana><mcrypt><rijndael>","3","1","2","2019-04-12 10:04:51","8765511","3","","382177","","2019-04-12 10:04:51","2011-12-15 21:49:45",""
"8527105","Why kohana 3 Encrypt class encode() method returns different string each time?","<p>I'm doing a <code>encode()</code> from the Encrypt class and each time it returns a different string for the same input string.
My <code>application/config/encrypt.php</code>:</p>

<pre><code>return array(
    'default' =&gt; array(
        /**
         * The following options must be set:
         *
         * string   key     secret passphrase
         * integer  mode    encryption mode, one of MCRYPT_MODE_*
         * integer  cipher  encryption cipher, one of the Mcrpyt cipher constants
         */
        'cipher' =&gt; MCRYPT_RIJNDAEL_128,
        'key'    =&gt; 'df58e28f',
        'mode'   =&gt; MCRYPT_MODE_NOFB,
    ),
);
</code></pre>

<p>Use:</p>

<pre><code>$str = Encrypt::instance()-&gt;encode('test');
</code></pre>

<p><code>$str</code> has always a different value. Is that an error or it's supposed to work that way? Why?</p>

<p>Also I must add that I can always <code>decode()</code> that value and get the <code>test</code> string each time.</p>

<p><strong>UPDATE:</strong> Here is a sample output: <code>0vahDa/2Qu3XQWObkjwLPoL73g==</code></p>

<p>Thank you very much.</p>
","<p>The reason it's different each time is that when <code>encode()</code> is called a new random IV is used to encrypt the data. Here's the line that does it:</p>

<pre><code>// Create a random initialization vector of the proper size for the current cipher
$iv = mcrypt_create_iv($this-&gt;_iv_size, Encrypt::$_rand);
</code></pre>

<p>It then ultimately returns a base 64 encoded string consisting of the encrypted data <em>and</em> IV.</p>

<pre><code>// Use base64 encoding to convert to a string
return base64_encode($iv.$data);
</code></pre>

<p>It's intentional behaviour, and not a bad thing. As you noted, you always get the same unencrypted data back - so it's doing its job.</p>
","953","<php><encryption><kohana><mcrypt><rijndael>","3","2","2","2019-04-12 10:04:51","8765511","3","","382177","","2019-04-12 10:04:51","2011-12-15 21:49:45",""
"3273672","how to call RijndaelAlg.CreateEncryptor in C# correctly when saving lots of independent files","<p>In my situation I have a number of files that will be stored on a server.  Each of these files  is created by a C# application that I am writing.</p>

<p><strong>background:</strong>
For this application, the amount of time needed to encrypt isnt important,  the files tend to be small and we've got plenty of CPU cycles to spare (the client is the only computer that encrypts or decrypts the data).</p>

<p>Each file is unrelated and I need the content to be protected from snooping by the sysadmin or anyone who gets a hold of the hard disk (assume a bad guy)</p>

<p>my understanding is RijndaelAlg is a solid algorithm for this sort of operation? assuming this is information is correct how to I correctly use the RijndaelAlg.CreateEncryptor function?</p>

<p>the usability I want is for my user to type in a password,  assume the password is a good password.</p>

<p><strong>my questions are</strong></p>

<ol>
<li><p>how best to convert a user inputed string (C# 'string) into a byte[]?  I'm assuming I should hash to get around the problem of having 0's on every other character?  what is the best way to do this conversion? </p></li>
<li><p>what do I use for the IV?  it's my understanding this is a value that should be populated (even though MSDN says its okay to pass 'null').  what do I use for this value?  keep in mind for my situation I've got a bunch of independent files that need to be decrypted independently.</p>

<p>what if the IV is well known,  is this a problem?  (could i use a hash of the filename since it's a unique value)</p></li>
<li><p>is there a better algorithm than RijndaelAlg for encrypting many independent files using the same password?</p></li>
</ol>
","<p>Q1. I usually use the GetBytes() method of the UTF8 class to convert strings to byte arrays.</p>

<pre><code>Encoding.UTF8.GetBytes(myString)
</code></pre>

<p>Q2. Each time you create an instance of the RijndaelManaged class, an IV is randomly generated for you (accessible using the IV property). You can randomize this again by calling the GenerateIV() method. </p>

<p>As you need this IV to decrypt data, you may be better off storing this IV somewhere instead of having a unique IV per file. If you encrypt all your files using a static IV, make sure to set the IV when you're creating a new instance of the RijndaelManaged class any time you decrypt a file.</p>

<p>Q3. RijndaelManaged/AES is the most secure algorithm out there, I wouldn't use anything els.</p>
","948","<c#><encryption><rijndaelmanaged><rijndael>","0","3","1","2010-07-17 23:46:21","3273704","0","","","","","2010-07-17 23:33:16",""
"6787851","rijndael encryptor valid byte sizes","<p>I have the following code:</p>

<pre><code>var symmetricKey = Rijndael.Create().CreateEncryptor(key, iv);
</code></pre>

<p>key and iv are the same length, and they are byte arrays of length 32.
In runtime, this snippet fails, saying the length isn't supported.
I also tried with 16. doesn't work either.</p>

<p>Am I using this wrong? what gives?</p>
","<p>It should work correctly if you set the IV to 16 bytes, matching Rijndael's default block size.</p>

<p>(Either that or change the <code>BlockSize</code> itself to be compatible with the size of your IV.)</p>
","944","<c#><byte><rijndael>","0","1","2","2013-12-06 22:05:33","6788058","0","","168868","","2013-12-06 22:05:33","2011-07-22 09:08:18",""
"6787851","rijndael encryptor valid byte sizes","<p>I have the following code:</p>

<pre><code>var symmetricKey = Rijndael.Create().CreateEncryptor(key, iv);
</code></pre>

<p>key and iv are the same length, and they are byte arrays of length 32.
In runtime, this snippet fails, saying the length isn't supported.
I also tried with 16. doesn't work either.</p>

<p>Am I using this wrong? what gives?</p>
","<p>This code should work as an example:</p>

<pre><code>        byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
        byte[] iv = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

        byte[] data = { 1, 2, 3, 4, 5 };   

        using (var symmetrickey = Rijndael.Create().CreateEncryptor(key, iv))
        {
            using (Stream f = File.Create(""anencryptedfile.bin""))
            {
                using (Stream c = new CryptoStream(f, symmetrickey, CryptoStreamMode.Write))
                {
                    c.Write(data, 0, data.Length);
                }
            }
        }
</code></pre>
","944","<c#><byte><rijndael>","0","0","2","2013-12-06 22:05:33","6788058","0","","168868","","2013-12-06 22:05:33","2011-07-22 09:08:18",""
"28477947","C mcrypt works / decrypt not using rijndael 128 (aes)","<p>I'm trying to use a small function to encode a ""secret word"" into a binary ciphered ""string"" and then convert this into base64 send it over the internet and decrypt it on the other side.</p>

<p>This is my code:</p>

<p>Encode Function:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include ""base64.h""


#include &lt;math.h&gt;

int encrypt(
    void* buffer,
    int buffer_len, /* Because the plaintext could include null bytes*/
    char* IV,
    char* key,
    int key_len
){
  MCRYPT td = mcrypt_module_open(""rijndael-128"", NULL, ""cbc"", NULL);
  int blocksize = mcrypt_enc_get_block_size(td);
  if( buffer_len % blocksize != 0 ){return 1;}

  mcrypt_generic_init(td, key, key_len, IV);
  mcrypt_generic(td, buffer, buffer_len);
  mcrypt_generic_deinit (td);
  mcrypt_module_close(td);

  return 0;
}

void display(char* ciphertext, int len){
  int v;
  for (v=0; v&lt;len; v++){
    printf(""%d"", ciphertext[v]);
  }
  printf(""\n"");
}

int main()
{
  MCRYPT td, td2;
  char * plaintext = ""CA7D22F5D7BBB3291487D3EFD935E"";
  char* IV = ""AAAAAAAAAAAAABBB"";
  char *key = ""0123456789abcdef"";
  int keysize = 32; /* 256 bits */
  char* buffer;
  int buffer_len = 32;
  int* ret;

  buffer = calloc(1, buffer_len);
  strncpy(buffer, plaintext, buffer_len);

  printf(""plain:   %s\n"", plaintext);

  encrypt(buffer, buffer_len, IV, key, keysize);
  char * mybase64 = base64(buffer, buffer_len, ret);
  printf(""b64   : %s\n"", mybase64);
  printf(""cipher: ""); display(buffer , buffer_len);
  printf(""buffer: %s\n"", buffer);

  return 0;
}
</code></pre>

<p>Decode Function:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include ""base64.h""

#include &lt;mcrypt.h&gt;

#include &lt;math.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int decrypt(
    void* buffer,
    int buffer_len,
    char* IV,
    char* key,
    int keysize
){
  MCRYPT td = mcrypt_module_open(""rijndael-128"", NULL, ""cbc"", NULL);
  int blocksize = mcrypt_enc_get_block_size(td);
  if( buffer_len % blocksize != 0 ){return 1;}

  mcrypt_generic_init(td, key, keysize, IV);
  mdecrypt_generic(td, buffer, buffer_len);
  mcrypt_generic_deinit (td);
  mcrypt_module_close(td);

  return 0;
}

void display(char* ciphertext, int len){
  int v;
  for (v=0; v&lt;len; v++){
    printf(""%d"", ciphertext[v]);
  }
  printf(""\n"");
}

int main()
{
//  MCRYPT td;
  char* IV = ""AAAAAAAAAAAAABBB"";
  char *key = ""0123456789abcdef"";
  int keysize = 32; /* 256 bits */
  int buffer_len = 32;
  int* ret;


  char * mybase64 = ""0DMkJ3UozhLfYjNav5Ih6rLd+aJua5KNTPHs/m2flLo="";

  char * buffer = unbase64(mybase64, (int)strlen(mybase64)+1, ret);


  printf(""cipher: ""); display(buffer , buffer_len);
  printf(""buffer: %s\n"", buffer);
  decrypt(buffer, buffer_len, IV, key, keysize);

  printf(""plain: %s\n"", buffer);

  return 0;
}
</code></pre>

<p>My used base64 functions:
<a href=""https://github.com/superwills/NibbleAndAHalf/blob/master/NibbleAndAHalf/base64.h"" rel=""nofollow"">https://github.com/superwills/NibbleAndAHalf/blob/master/NibbleAndAHalf/base64.h</a></p>

<p>The strange thing is, the encoded binary data ""looks"" the same on the console, also in hex, but it does not get decoded correctly, its just weird characters.</p>

<p>Anyone got an idea ? </p>

<p>EDIT: This is the result when running a test of the program:.</p>

<p>Encode:</p>

<pre><code>user@0F5NV:~/aes$ ./aes 
plain:   CA7D22F5D7BBB3291487D3EFD935E
b64   : EWQ2NxzOGCB1XGARxdfC7kLMGzAGJZ8/sEQf6dThxfk=
cipher: 17100545528-502432117929617-59-41-62-1866-522748637-9763-806831-23-44-31-59-7
buffer: d67? u\`????B?%???D?????
</code></pre>

<p>Decode:</p>

<pre><code>user@0F5NV:~/aes$ ./unaes
b64   : EWQ2NxzOGCB1XGARxdfC7kLMGzAGJZ8/sEQf6dThxfk=
cipher: 17100545528-502432117929617-59-41-62-1866-522748637-9763-806831-23-44-31-59-7
buffer: d67? u\`????B?%???D?????
plain: ?Q?X?P??Qa?t?@???wi ?qa?Z
</code></pre>

<p>As you see the cipher and buffer are the same in Encoding and Decoding but not the plaintext... Why ?!</p>
","","935","<c><encryption><aes><mcrypt><rijndael>","0","","0","2015-02-12 14:49:14","","6","","3849035","","2015-02-12 14:49:14","2015-02-12 12:50:10",""
"21139935","Aes|Rijndael-128 Hashed Text Decode in Delphi XE2","<p>We have php code:</p>

<pre><code>   define('myaesKey', 'znwoq8fq0jf2qjve8laper9f');  // 192 bits and 25 ch.  
   function encode($CodeTo) { 
      $Type = 'rijndael-128';
      $Mode = 'ecb';
      $IV = ""1234567890123450"";
      $Object = mcrypt_module_open($Type, '', $Mode, '');
      mcrypt_generic_init($Object , myaesKey, $IV);
      $Enc2Code = mcrypt_generic($Object , $CodeTo);
      mcrypt_generic_deinit($Object);
      mcrypt_module_close($Object);
      return bin2hex($secEncCode);
    }
</code></pre>

<p>Length of $CodeTo is 5, CodeTo is readable symbols of English Alphabet, function send somethind like this
1e49651ba23801907e1d67c5a7c18e06
aefdc02bbcb8ed8e8209a935aa62be53</p>

<p>I tried to decode by diff. ways, one of this :</p>

<pre><code>  const

  KeySize = 24; // 32 bytes = 256 bits     24 - 192
  BlockSize = 16; // 16 bytes = 128 bits

function Decrypt(AText:AnsiString):String;
var
  Cipher : TDCP_rijndael;   i:Integer;
  Data, Key, IV,NewStr : ansistring;
begin
  // Pad Key and IV with zeros as appropriate
  Key := PadWithZeros(ansistring('znwoq8fq0jf2qjve8laper9f'),KeySize);
  IV := PadWithZeros(ansistring('1234567890123450'),BlockSize);
  // Decode the Base64 encoded string


  NewStr:='';
  for i:=1 to (Length(AText) div 2) do
  NewStr:=NewStr+chr(byte(StrToInt('$'+Copy(AText,(i-1)*2+1,2))));
  Data := NewStr;

  // Create the cipher and initialise according to the key length
  Cipher := TDCP_rijndael.Create(nil);
  if Length(ansistring('znwoq8fq0jf2qjve8laper9f')) &lt;= 16 then
    Cipher.Init(Key[1],128,@IV[1])
  else if Length(ansistring('znwoq8fq0jf2qjve8laper9f')) &lt;= 24 then
    Cipher.Init(Key[1],192,@IV[1])
  else
    Cipher.Init(Key[1],256,@IV[1]);
  // Decrypt the data
 // Cipher.DecryptCBC(Data[1],Data[1],Length(Data));
  Cipher.DecryptECB(Data[1],Data[1]);
  // Free the cipher and clear sensitive information
  Cipher.Free;
  FillChar(Key[1],Length(Key),0);
  // Display the result
  result:= Data;
end;
</code></pre>

<p>but the decoded text is wrong </p>

<p>6d309aab9887deed8da964cca8818eb4
µ€ц‰ъиTDHQ  ЮB№еП</p>

<p>Why?
Can someone help? Easy to decode it by <a href=""http://www.tools4noobs.com/online_tools/decrypt/"" rel=""nofollow"">http://www.tools4noobs.com/online_tools/decrypt/</a> withot IV ... </p>
","<p>Try to use this</p>

<pre><code>function AESDecrypt(AData, AKey: String): string;
var
    KeyByte,Data,Dest:TBytes;
    KeyBlock:integer;
    Cipher:TDCP_rijndael;

begin
  KeyByte:=TEncoding.UTF8.GetBytes(AKey);
  while (Length(KeyByte) mod 16 &lt;&gt; 0) do begin
    SetLength(KeyByte,Length(KeyByte)+1);
    KeyByte[Length(KeyByte)-1]:=0;
  end;

  SetLength(Data,Length(AData) div 2);
  SetLEngth(Dest,Length(AData) div 2);

  Data:=GetBytesFromHex(AData);

  Cipher:= TDCP_rijndael.Create(nil);

  KeyBlock:=192; //by PHP code comment

  Cipher.Init(KeyByte[0],KeyBlock,nil); //for ECB method IV is optional

  try
    for i := 1 to (Length(AData) div 16) do
    begin
      Cipher.DecryptECB(Data[(i-1)*16],Dest[(i-1)*16]);
    end;
  finally
    Cipher.Burn;
  end;
  AData:=TEncoding.UTF8.GetString(Dest);
  Result:=AData;
end;
</code></pre>
","925","<php><delphi><encryption><delphi-xe2><rijndael>","2","1","1","2014-08-04 13:47:40","21142436","5","","91299","","2014-01-17 14:18:18","2014-01-15 14:24:13",""
"2300146","SlowAES cannot decrypt properly without original size","<p>First time poster here. Awesome community here. After endless hours of searching, I'm unable to figure out the answer to this problem I""m facing. </p>

<p>First and foremost, I'm no guru when it comes to encryption/decryption, cryptology, etc. I only want to go so far in this realm without getting lost. The primary framework I code on is .NET and I was asked to create an AES CBC implementation for C#, that can work on JavaScript and ActionScript 3. I've been successful with both but with JavaScript, I've ran into an issue.</p>

<p>I decided to use SlowAES AES implementation because it seems to be the most popular with the best interop.</p>

<p>Please see the following links regarding my issue... </p>

<p>Issue #9: <a href=""http://code.google.com/p/slowaes/issues/detail?id=9"" rel=""nofollow noreferrer"">http://code.google.com/p/slowaes/issues/detail?id=9</a></p>

<p>Basically my issue with SlowAES is, I cannot decrypt something correctly without knowing the length of the original, unencrypted text. This defeats the purpose right? I should be able to decrypt an encrypted string without needing to know the original string.</p>

<p>If I'm missing something, I would be grateful if pointed in the right direction. Thankfully, I'm okay because .NET AES implementation I've put together can decrypt what SlowAES encrypts, same with ActionScript 3's implementation.</p>

<p>At this point I would just like to have SlowAES decrypt correctly.</p>

<p><strong>Updated</strong></p>

<p>After following the help of Remus, I've determine that SlowAES is using PKCS5/7 padding scheme but does not remove it properly. Now my problem seems to be with C#, understanding Byte Arrays, etc.</p>

<p>I can see the last character in my decrypted text is '5' which is preceded by a '0'. This pattern continues 5 times. Now from what Remus said below, I'm supposed to subtract the decrypted string length by this number. But the pattern is '05', does that mean I double 5 making 10 then subtract 10 from my decrypted string length? </p>

<p>Also, what would be the easiest way of obtaining the number I need to subtract? I'm using the following to obtain the number currently:</p>

<p><code>Byte[] decryptedBytes = System.Text.Encoding.ASCII.GetBytes(decrypted);<br>
Byte padLengthByte = decryptedBytes[decryptedBytes.Length - 1];<br>
Char padLengthChar = Convert.ToChar(padLengthByte);<br>
String padLengthString = padLengthChar.ToString();<br>
Int32 padLength = Int32.Parse(padLengthString);</code>  </p>

<p>I'm sure I'm doing this wrong. Again any help is always appreciated it.  </p>

<p>Another question I have is, how do you know if padding was applied in the first place in order to remove it? If '\07' represents 7 bytes of padding, what if the last byte was '\01\'?</p>
","<p>That is because apparently SlowAES doesn't implement the commonly used padding schemes, like PKCS: <a href=""http://code.google.com/p/slowaes/issues/detail?id=4"" rel=""nofollow noreferrer"">Issue 4:  Implement PKCS7 padding</a>. Even if the library doesn't implement it, it's really trivial for you do implement it: once you get the decrypted (padded) text, just analyze the last  block and deduct the original length from the padding info. The PKCS7 padding is described in <a href=""http://tools.ietf.org/html/rfc2315"" rel=""nofollow noreferrer"">RFC2315</a> if I'm not mistaken.</p>

<p><strong>Updated</strong></p>

<p>If text is padded with PKCS7 the very last byte in the decrypted text will contain the length of the padding. So you decrypt and then remove as many characters from the end of the decrypted text as the value on the last byte. Eg. </p>

<ol>
<li>the original text is 'This is the original text'. It has length 25.</li>
<li>the encryption will padd the length to 32 (next block of 16 size), so it will encrypt the block 'This is the original text\07\07\07\07\07\07\07'.</li>
<li>the padded block gets encrypted into 32 length crypt text</li>
<li>you decrypt the 32 length crypt and get back the padded text from 2)</li>
<li>last byte of the decrypted block is '\07', so you substract 7 bytes from the decrypted block. The result is the original text, of length 25: 'This is the original text'</li>
</ol>

<p>PS: I would add the JavaScript code, but my JavaScript coding skill is rather rusty.</p>
","917","<encryption><javascript><rijndael><aes>","2","5","2","2010-02-22 17:37:59","","0","0","","user277397","2010-02-22 17:37:59","2010-02-19 22:44:49",""
"2300146","SlowAES cannot decrypt properly without original size","<p>First time poster here. Awesome community here. After endless hours of searching, I'm unable to figure out the answer to this problem I""m facing. </p>

<p>First and foremost, I'm no guru when it comes to encryption/decryption, cryptology, etc. I only want to go so far in this realm without getting lost. The primary framework I code on is .NET and I was asked to create an AES CBC implementation for C#, that can work on JavaScript and ActionScript 3. I've been successful with both but with JavaScript, I've ran into an issue.</p>

<p>I decided to use SlowAES AES implementation because it seems to be the most popular with the best interop.</p>

<p>Please see the following links regarding my issue... </p>

<p>Issue #9: <a href=""http://code.google.com/p/slowaes/issues/detail?id=9"" rel=""nofollow noreferrer"">http://code.google.com/p/slowaes/issues/detail?id=9</a></p>

<p>Basically my issue with SlowAES is, I cannot decrypt something correctly without knowing the length of the original, unencrypted text. This defeats the purpose right? I should be able to decrypt an encrypted string without needing to know the original string.</p>

<p>If I'm missing something, I would be grateful if pointed in the right direction. Thankfully, I'm okay because .NET AES implementation I've put together can decrypt what SlowAES encrypts, same with ActionScript 3's implementation.</p>

<p>At this point I would just like to have SlowAES decrypt correctly.</p>

<p><strong>Updated</strong></p>

<p>After following the help of Remus, I've determine that SlowAES is using PKCS5/7 padding scheme but does not remove it properly. Now my problem seems to be with C#, understanding Byte Arrays, etc.</p>

<p>I can see the last character in my decrypted text is '5' which is preceded by a '0'. This pattern continues 5 times. Now from what Remus said below, I'm supposed to subtract the decrypted string length by this number. But the pattern is '05', does that mean I double 5 making 10 then subtract 10 from my decrypted string length? </p>

<p>Also, what would be the easiest way of obtaining the number I need to subtract? I'm using the following to obtain the number currently:</p>

<p><code>Byte[] decryptedBytes = System.Text.Encoding.ASCII.GetBytes(decrypted);<br>
Byte padLengthByte = decryptedBytes[decryptedBytes.Length - 1];<br>
Char padLengthChar = Convert.ToChar(padLengthByte);<br>
String padLengthString = padLengthChar.ToString();<br>
Int32 padLength = Int32.Parse(padLengthString);</code>  </p>

<p>I'm sure I'm doing this wrong. Again any help is always appreciated it.  </p>

<p>Another question I have is, how do you know if padding was applied in the first place in order to remove it? If '\07' represents 7 bytes of padding, what if the last byte was '\01\'?</p>
","<p>One thing you can do is pad your data to round out to a complete 128-bit block size. that way you don't have to worry about PKCS#7 padding, because you just did it yourself. hardly optimal, but at least you're up and running :)</p>
","917","<encryption><javascript><rijndael><aes>","2","0","2","2010-02-22 17:37:59","","0","0","","user277397","2010-02-22 17:37:59","2010-02-19 22:44:49",""
"11910673","cipher rijndael delphi 2010 dcp","<p>I have an IV (initialization vector) and key, i need to cypher a string this is the code:</p>

<pre><code>function TForm1.CipherAES (key: AnsiString; Vector: AnsiString;
  InStream: TMemoryStream) : TMemoryStream;
var
  cipher: TDCP_rijndael;
  i: integer;
  toEnc, toSnd : array of byte;
  outStream, AStream :TMemoryStream;
  StreamR, Stream2 : AnsiString;
begin
  outStream := TMemoryStream.Create;
  SetLength(toEnc, InStream.Size);

  cipher := TDCP_rijndael.Create(nil);
  cipher.Init(key[1], 128, nil);
  cipher.SetIV(vector[1]);
  cipher.BlockSize := 16;
  InStream.Position := 0;

  for I := 0 to InStream.Size-1 do
    InStream.Read(ToEnc[i], 1);

  for I := 0 to inStream.size-1 do
    StreamR := StreamR + ByteToHex(toEnc[i]) + ' ';
  Memo1.Lines.Add(StreamR);
  inStream.Position := 0;

  cipher.CipherMode := cmCBC;
  cipher.EncryptStream(inStream, outStream, InStream.Size);
  Base64Encode(outStream.Memory, @StreamR[1], outStream.Size);

  Stream2 := Copy(StreamR, 1, outStream.Size + 8);
  Memo1.Lines.Add(Stream2);
  Memo1.Lines.Add(StreamR);

  outStream.Position := 0;

  SetLength(toSnd, outStream.Size);
  for I := 0 to outStream.Size-1 do
    outStream.Read(toSnd[i], 1);

  StreamR := '';
  for I := 0 to outStream.size-1 do
    StreamR := StreamR + ByteToHex(toSnd[i]) + ' ';
  Memo1.Lines.Add(StreamR);

  cipher.burn;
  cipher.free;

  Result := outStream;
end;
</code></pre>

<p>when i pass the stream to base64 gives me the next answer:</p>

<pre><code>ub/JkCsCZwbAnyqjo+miIw==
</code></pre>

<p>but it should be:</p>

<pre><code>ub/JkCsCZwbAnyqjo+miI2XNZwNrJo31YBNTwQuHkq0=
</code></pre>

<p>somebody can help me? why is something like this happening?</p>

<p>thanks in advance
Vauli</p>
","<p>If you base64 decode these two values you will get:</p>

<p>ub/JkCsCZwbAnyqjo+miIw== decodes to:</p>

<pre><code>B9 BF C9 90 2B 02 67 06-C0 9F 2A A3 A3 E9 A2 23 (in hex) 
</code></pre>

<p>=> 16 bytes</p>

<p>ub/JkCsCZwbAnyqjo+miI2XNZwNrJo31YBNTwQuHkq0= decodes to:</p>

<pre><code>B9 BF C9 90 2B 02 67 06-C0 9F 2A A3 A3 E9 A2 23
65 CD 67 03 6B 26 8D F5-60 13 53 C1 0B 87 92 AD (in hex) 
</code></pre>

<p>=> 32 bytes</p>

<p>This makes me think you are passing only 16 bytes to TForm1.CipherAES(). 
I'm saying that, because after calling cipher.EncryptStream, outStream.size should be equal to inStream.size</p>

<p>Please clarify what is the value for InStream.Size when you test using breakpoints.</p>

<p><strong>Some notes on your code:</strong></p>

<ol>
<li><p>Base64Encode returns the number of bytes that output buffer contain.
You never use this value to set the size of StreamR.</p>

<p>Your call to base64encode should be something like:</p>

<pre><code>// Allocate buffer for base64 decoded data
setLength(StreamR, ((inStrem.size + 2) div 3) * 4); 
size := Base64Encode(outStream.Memory, @StreamR[1], outStream.Size);
setLength(StreamR, size);
</code></pre></li>
<li><p>I really do not get the meaning of this: </p>

<p>Stream2 := Copy(StreamR, 1,
    outStream.Size + 8);</p>

<p>Why outStream.Size + 8? You are copying something from StreamR,
based on a size of other buffer, disregarding the real size of your
StreamR? Also ""Copy()"" will get only at most LENGTH(StreamR) chars.</p></li>
<li><p>Instead of filling ToEnc byte by byte consider using:</p>

<p>InStream.ReadBuffer(ToEnc[0], InStream.size);</p>

<p>The same for toSnd (but .writeBuffer())</p></li>
</ol>

<hr>

<p><strong>Note about encrypting strings</strong> (because I don't know how you feed InStream): </p>

<p>Ensure you're encrypting Unicode version of the text (UTF16-LE or UTF-8). Converting string to ansiString goes via OS system locale and can result in data loss (the famous '????')</p>
","915","<delphi><delphi-2010><rijndael>","1","1","1","2012-08-11 15:12:04","11915810","0","","576719","","2012-08-11 11:38:47","2012-08-10 23:56:05",""
"11614766","Problems with conversion from Int to Byte (Java)","<p>I am developing an app for Android. In this app, you must use the algorithm for encryption / decryption Rijndael.</p>

<p>To use this algorithm, I need to mount the IVs. In the case is an array of bytes. So far so good.</p>

<p>The problem is that I have to use the same IVs from a Web Service written in C #.</p>

<p>C # is thus:</p>

<pre><code>byte[] bytIV = { 121, 241, 10, 1, 132, 74, 11, 39, 255, 91, 45, 78, 14, 211, 22, 62 };
</code></pre>

<p>When I try to do the same in Java, an error occurs and I suggested adding a cast a few numbers. What makes the code this way:</p>

<pre><code>byte[] bytIV = { 121, (byte) 241, 10, 1, (byte) 132, 74, 11, 39, (byte) 255, 91, 45, 78, 14, (byte) 211, 22, 62 };
</code></pre>

<p>Still did not work.</p>

<p>Does anyone have a suggestion of what I do?</p>

<p>Thanks!</p>

<hr>

<p>In the example that I spent here, I used (cast) instead of (byte). Example corrected. Note: There was (cast) in my code. In the code was (byte).</p>
","<p>byte is 8 bit signed. You are setting on the array values larger than that. 241 for example. That's why you need to add the cast, and the result making a simple test is: </p>

<pre><code>byte b2 = (byte) 241;           
System.out.println("""" + b2);
</code></pre>

<p>output = -15</p>

<p>hence your problems </p>
","902","<android><arrays><int><byte><rijndael>","0","0","3","2012-07-23 14:56:59","","1","","1408986","","2012-07-23 14:56:59","2012-07-23 14:40:17",""
"11614766","Problems with conversion from Int to Byte (Java)","<p>I am developing an app for Android. In this app, you must use the algorithm for encryption / decryption Rijndael.</p>

<p>To use this algorithm, I need to mount the IVs. In the case is an array of bytes. So far so good.</p>

<p>The problem is that I have to use the same IVs from a Web Service written in C #.</p>

<p>C # is thus:</p>

<pre><code>byte[] bytIV = { 121, 241, 10, 1, 132, 74, 11, 39, 255, 91, 45, 78, 14, 211, 22, 62 };
</code></pre>

<p>When I try to do the same in Java, an error occurs and I suggested adding a cast a few numbers. What makes the code this way:</p>

<pre><code>byte[] bytIV = { 121, (byte) 241, 10, 1, (byte) 132, 74, 11, 39, (byte) 255, 91, 45, 78, 14, (byte) 211, 22, 62 };
</code></pre>

<p>Still did not work.</p>

<p>Does anyone have a suggestion of what I do?</p>

<p>Thanks!</p>

<hr>

<p>In the example that I spent here, I used (cast) instead of (byte). Example corrected. Note: There was (cast) in my code. In the code was (byte).</p>
","<p>Byte is 8-bit signed, from -128 to 127. So casting 241 will give -15, which are the same bits as 241 for an unsigned byte in C#. I don't see the problem.
But casting to byte is with <code>(byte)241</code>, not <code>(cast)241</code>.</p>
","902","<android><arrays><int><byte><rijndael>","0","0","3","2012-07-23 14:56:59","","1","","1408986","","2012-07-23 14:56:59","2012-07-23 14:40:17",""
"11614766","Problems with conversion from Int to Byte (Java)","<p>I am developing an app for Android. In this app, you must use the algorithm for encryption / decryption Rijndael.</p>

<p>To use this algorithm, I need to mount the IVs. In the case is an array of bytes. So far so good.</p>

<p>The problem is that I have to use the same IVs from a Web Service written in C #.</p>

<p>C # is thus:</p>

<pre><code>byte[] bytIV = { 121, 241, 10, 1, 132, 74, 11, 39, 255, 91, 45, 78, 14, 211, 22, 62 };
</code></pre>

<p>When I try to do the same in Java, an error occurs and I suggested adding a cast a few numbers. What makes the code this way:</p>

<pre><code>byte[] bytIV = { 121, (byte) 241, 10, 1, (byte) 132, 74, 11, 39, (byte) 255, 91, 45, 78, 14, (byte) 211, 22, 62 };
</code></pre>

<p>Still did not work.</p>

<p>Does anyone have a suggestion of what I do?</p>

<p>Thanks!</p>

<hr>

<p>In the example that I spent here, I used (cast) instead of (byte). Example corrected. Note: There was (cast) in my code. In the code was (byte).</p>
","<p>In Java a byte has a range that it can hold between -128 to 127. Any number larger than 128 or lower than -127 cant fit into the byte which is why its asking for a cast. In Java you add a cast like this (int) or (double) will cast the number to either an int or a double respectively. To fix your problem you have to change the array to a short or int array instead of a byte array. Then remove the casts that are in the declaration. Either of these below should work for you.</p>

<pre><code>int[] bytIV = { 121, 241, 10, 1, 132, 74, 11, 39, 255, 
                             91, 45, 78, 14, 211, 22, 62 };
</code></pre>

<p>or</p>

<pre><code>short[] bytIV = { 121, 241, 10, 1, 132, 74, 11, 39, 255, 
                             91, 45, 78, 14, 211, 22, 62 };
</code></pre>
","902","<android><arrays><int><byte><rijndael>","0","0","3","2012-07-23 14:56:59","","1","","1408986","","2012-07-23 14:56:59","2012-07-23 14:40:17",""
"17069324","PHP MYCRYPT - RIJNDAEL_128 with Mcrypt CBC gives the different encryption string everytime","<p>I am back again with a PHP+RIJNDAEl_128+CBC.</p>

<p>I am successful in encryption and decryption to the raw string.</p>

<p>But the only problem I am facing is I get the DIFFERENT ENCRYPTION string every time.</p>

<p>Which I believe should be same every time ideally.</p>

<p>Below is the code:</p>

<pre><code>class Encypt{

const ENCRYPTION_KEY = '3aa22e01c04c7059778c54d122b0273689fba00f4a166a66d15f7ba6a8ba8743';


function createQueryString(){
$str = ""1844427316My Name Is Dave1336407610774000000000000"";
$encStr = $this-&gt;encrypt($str);

return $encStr;
}

function encrypt($strValue){
$iv =mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128,MCRYPT_MODE_CBC),MCRYPT_RAND);
$encData = trim(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128,self::ENCRYPTION_KEY, $strValue,MCRYPT_MODE_CBC,$iv)));
            $data['iv'] = $iv;
            $data['encdata'] = $encData;

            return $data;
}
 /**
     *  Function to decrypt data using AES Encryption Symmetric Algorithm 128 bytes
     */
    function decrypt($strValue, $iv){
            return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128,ENCRYPTION_KEY,base64_decode($strValue),MCRYPT_MODE_CBC,$iv));
    }

}    
$enc_obj = new Encypt();

$encstr = $enc_obj-&gt;createQueryString();

echo ""Encrypted Str:--&gt;"".$encstr['encdata'].""&lt;br&gt;"";
$deCrypt = $enc_obj-&gt;decrypt($encstr['encdata'], $encstr['iv']);
echo ""Decrypted Str:--&gt;"".$deCrypt;
</code></pre>
","<p>The different values you receive each time for the encrypted text is normal regarding the different IVs in every run. This is actually part of the algorithm, and makes it more secure.</p>
","901","<php><mcrypt><encryption-symmetric><rijndael><cbc-mode>","1","2","2","2015-01-28 14:02:58","","4","","","","","2013-06-12 15:23:58",""
"17069324","PHP MYCRYPT - RIJNDAEL_128 with Mcrypt CBC gives the different encryption string everytime","<p>I am back again with a PHP+RIJNDAEl_128+CBC.</p>

<p>I am successful in encryption and decryption to the raw string.</p>

<p>But the only problem I am facing is I get the DIFFERENT ENCRYPTION string every time.</p>

<p>Which I believe should be same every time ideally.</p>

<p>Below is the code:</p>

<pre><code>class Encypt{

const ENCRYPTION_KEY = '3aa22e01c04c7059778c54d122b0273689fba00f4a166a66d15f7ba6a8ba8743';


function createQueryString(){
$str = ""1844427316My Name Is Dave1336407610774000000000000"";
$encStr = $this-&gt;encrypt($str);

return $encStr;
}

function encrypt($strValue){
$iv =mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128,MCRYPT_MODE_CBC),MCRYPT_RAND);
$encData = trim(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128,self::ENCRYPTION_KEY, $strValue,MCRYPT_MODE_CBC,$iv)));
            $data['iv'] = $iv;
            $data['encdata'] = $encData;

            return $data;
}
 /**
     *  Function to decrypt data using AES Encryption Symmetric Algorithm 128 bytes
     */
    function decrypt($strValue, $iv){
            return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128,ENCRYPTION_KEY,base64_decode($strValue),MCRYPT_MODE_CBC,$iv));
    }

}    
$enc_obj = new Encypt();

$encstr = $enc_obj-&gt;createQueryString();

echo ""Encrypted Str:--&gt;"".$encstr['encdata'].""&lt;br&gt;"";
$deCrypt = $enc_obj-&gt;decrypt($encstr['encdata'], $encstr['iv']);
echo ""Decrypted Str:--&gt;"".$deCrypt;
</code></pre>
","<p>Your encrypt function has a call to 
<code>mcrypt_create_iv(&lt;&lt;iv_size&gt;&gt;, MCRYPT_RAND);</code></p>

<p>Since the call has <code>MCRYPT_RAND</code>(system random number generator) as the source, a new Initialization Vector created every-time will be different from previous ones. </p>

<p>This will result in different encrypted string every-time. You can decrypt the cypher-text using the same Initialization Vector as used in encryption process.</p>
","901","<php><mcrypt><encryption-symmetric><rijndael><cbc-mode>","1","1","2","2015-01-28 14:02:58","","4","","","","","2013-06-12 15:23:58",""
"12998848","Proper C# Rijndael IV Usage/Storage","<p>Afternoon, </p>

<p>So I'm fairly new to all these encryption methods and usages. I've just started building an Encryption Implementation. Now My method of encryption and decryption seems to be working fine.. Till I read I failed horribly for using a Hardcoded IV in the RijndaelManaged class.</p>

<p>I'm reading everywhere that It's better(and safer) to have each encrypted file's IV be uniquely generated at ""Encryption time"" and saved at the front/beginning of the File where as the rest of encrypted bytes are saved directly after this.
(If I understand this correctly)</p>

<p>I've been having a real hard time figuring out my problem, because each time I Encrypt a file, I write the IV to the first 16 bytes(As the class, MSDN, Google and some folk on this forum suggested) of the file and directly after that I write the rest of the Encrypted bytes to the filestream. (The IV is saved in plaintext..Or well unencrypted bytes &lt; Also is this okey?)</p>

<p><em>My problem is when I try to decrypt the file using precisely the same Key it fails: Before I start reading chunks of the file for decryption(Buffering) I try to read the File's first 16bytes for the plaintexted IV and use it in the RijndaelManaged Class instance.</em></p>

<p>This seems to fail. I checked, I think I may be making some schoolboy error somewhere: Because I can't seem to read the same 16 bytes from the Encrypted file once I wish to decrypt it.</p>

<p>This is the Code I use to do the File handling PRIOR to Encryption(Not the encryption it self)</p>

<hr>

<pre><code>using (RijndaelManaged RM = new RijndaelManaged())
using (FileStream StreamIN = new FileStream(FileIN, FileMode.Open, FileAccess.Read))
using (FileStream StreamOUT = new FileStream(FileOUT, FileMode.Append, FileAccess.Write))
{
    //Setup Variable ChunkSize and The Total bytes Read into the streams
    int ChunkSize = 1024 * 1024 * 32; 

    RM.GenerateIV();

    foreach (var item in RM.IV)
    {
        Console.Write(""[ "" + item + ""] "");
    }

    StreamOUT.Seek(0, SeekOrigin.Begin);
    StreamOUT.Write(RM.IV, 0, RM.IV.Length);
    StreamOUT.Seek(RM.IV.Length, SeekOrigin.Begin);

    int TotalBytesRead = 0;                       

    //File Buffer Implementation
    for (long i = 0; i &lt; StreamIN.Length; i += ChunkSize)
    {
        //ChunkData byte array determined by ChunkSize
        byte[] ChunkData = new byte[ChunkSize];
        //Current Bytes Read from the IN Stream
        int BytesRead = 0;
        while ((BytesRead = StreamIN.Read(ChunkData, 0, ChunkSize)) &gt; 0)
        {
            //Call Encryption from local Class

            Console.WriteLine(""Bytes Read: {0}"", TotalBytesRead += BytesRead);

            ChunkData = Crypt.Encrypt(ChunkData, KeyBytes, RM.IV);

            //Write byte array to File
            StreamOUT.Write(ChunkData, 0, BytesRead);
        }
    }
}
</code></pre>

<p>And this is my code for File handling PRIOR to Decryption(Not Decryption itself)</p>

<pre><code>using (RijndaelManaged RM = new RijndaelManaged())
using (FileStream StreamIN = new FileStream(FileIN, FileMode.Open, FileAccess.Read))
using (FileStream StreamOUT = new FileStream(FileOUT, FileMode.Append, FileAccess.Write))
{
    //Setup Variable ChunkSize and The Total bytes Read into the streams
    int ChunkSize = 1024 * 1024 * 32; 


    StreamIN.Seek(0, SeekOrigin.Begin);
    int Read = StreamIN.Read(RM.IV, 0, 16);
    StreamIN.Seek(RM.IV.Length, SeekOrigin.Begin);

    int TotalBytesRead = 0;

    foreach (var item in RM.IV)
    {
        Console.Write(""[ "" + item + ""] "");
    }

    //File Buffer Implementation
    for (long i = 0; i &lt; StreamIN.Length; i += ChunkSize)
    {
        //ChunkData byte array determined by ChunkSize
        byte[] ChunkData = new byte[ChunkSize];
        //Current Bytes Read from the IN Stream
        int BytesRead = 0;

        while ((BytesRead = StreamIN.Read(ChunkData, 0, ChunkSize)) &gt; 0)
        {

            Console.WriteLine(""Bytes Read: {0}"", TotalBytesRead += BytesRead);                                

            //Call Decryption from local Class
            ChunkData = Crypt.Decrypt(ChunkData, KeyBytes, RM.IV);

            //Write byte Array to file
            StreamOUT.Write(ChunkData, 0, BytesRead);
        }
    }
}
</code></pre>

<p>I think that's all of it? Also, the ""Console"" and other useless calls are only made to help me check and figure out the problem thusfar.
I'm using Visual Studios 2010, and trying to implement the RijndaelManaged class.</p>

<p>The Encryption/Decryption Methods are passed the FileChunks(byte array) with my Key and the IV and these return a byte array(Crypted) which is saved to the stream.</p>

<p>I Hope my question is clear? If not Ill try to explain better,
I've read everywhere looking for help on this particular problem but most other questions posted here are outside of my scope. </p>

<p>I really would appreciate any help, I'm sure I'm making a clown mistake somewhere..</p>

<p>Thank you!!</p>
","<p>As per long-standing <a href=""http://msdn.microsoft.com/en-us/library/k2604h5s%28v=vs.100.aspx%29"" rel=""nofollow"">Framework guidelines</a>, it looks like <code>SymmetricAlgorithm.IV</code> has been written not to return an internal array. This means that it's handing you back a copy, so subsequent changes to it aren't reflected in the <code>RijndaelManaged</code> instance.</p>

<pre><code>// Effectively reading the persisted value into a temporary array
// and throwing away the temporary.
int Read = StreamIN.Read(RM.IV, 0, 16);
</code></pre>

<p>In order to make the change stick and set the IV to the persisted value, you need to actually set the <code>IV</code> property explicitly, rather than just modifying the value it returned previously.</p>

<pre><code>byte[] persistedIv = new byte[16];
StreamIN.Read(persistedIv, 0, persistedIv.Length);
RM.IV = persistedIv;
</code></pre>
","877","<c#><bytearray><rijndael><initialization-vector>","2","1","1","2012-10-21 20:22:34","13001826","6","1","445517","","2012-10-21 14:47:34","2012-10-21 14:40:15",""
"25404795","Encrypting/decrypting some file types with Rijndael 256 (CakePHP Security library) garbles contents","<p>I am using CakePHP's <code>Security::rijndael()</code> function to encrypt and decrypt text and files.  I previously wrote some code using <code>mcrypt</code> directly, which worked in the same way, but then I found <code>Security::rijndael</code> and realised I had reinvented the wheel.  So the problem I have happens either way.</p>

<p>If I encrypt a string, or a text file, or a PDF document, the code below works perfectly and I get the correct decrypted string/file.  However, if I try encrypting a .doc, .docx or an image file, the decrypted file is garbled.</p>

<p>Here's the code that does the encrypting/decrypting</p>

<pre><code>public static function encrypt($plainText, $key) {
    $plainText = base64_encode($plainText);

    //Hash key to ensure it is long enough
    $hashedKey = Security::hash($key);
    $cipherText = Security::rijndael($plainText, $hashedKey, 'encrypt');
    return base64_encode($cipherText);
}

public static function decrypt($cipherText, $key) {
    $cipherText = base64_decode($cipherText);

    $hashedKey = Security::hash($key);
    $plainText = Security::rijndael($cipherText, $hashedKey, 'decrypt');
    return base64_decode($plainText);
}
</code></pre>

<p>...and this code actually presents the file to the user (I've edited the code to keep it simple):</p>

<pre><code>public function download($id){
    App::uses('File', 'Utility');
    $key = $this-&gt;User-&gt;getDocumentKey($id);
    $file = new File('my_encrypted_file.docx');
    $encrypted = $file-&gt;read();
    $decrypted = Encrypt::decrypt($encrypted, $key);

    header('Cache-Control: no-store, no-cache, must-revalidate');
    header('Content-Disposition: attachment; filename=""my_decrypted_file.docx""');
    echo $decrypted;
    die();
}
</code></pre>

<p><strong>Update</strong> - it appears that the encryption is a red herring, as the file is garbled even without encrypting and decrypting it!  The following produces exactly the same broken file:</p>

<pre><code>        header('Content-Disposition: attachment; filename=""test.docx""');
        $file = new File($this-&gt;data['Model']['file']['tmp_name']);
        echo $file-&gt;read();
        die();
</code></pre>
","<p>I think I know the reason for that problem now, it is <a href=""http://www.phpkode.com/source/p/cakephp/cakephp-2.3.0-beta/lib/Cake/Utility/Security.php"" rel=""nofollow"">line <code>208</code> in <code>Security.php</code></a>:</p>

<pre><code>$out .= rtrim(mcrypt_decrypt($algorithm, $cryptKey, $text, $mode, $iv), ""\0"");
</code></pre>

<p>Since PHP's <code>mycrypt()</code> uses <code>ZeroBytePadding</code> this line removes the padding afterwards.</p>

<p>The problem is that a <code>.docx</code>-File (as far as I could check it) terminates with a few <code>Null</code>-characters. If you only remove a single one of them, <em>Word</em> fails to open the file.<br>
So what happens is that <code>rtrim()</code> also deletes these bytes even though they are not part of the padding.</p>

<p>To fix this, you can add a termination character (for example <code>X</code>) at the end of your files before encrypting and remove it after decrypting. This will prevent cutting off the tailing zero-bytes from the <code>.docx</code>-files:</p>

<pre><code>public static function encrypt($plainText, $key) {
    $plainText = base64_encode($plainText . ""X""); // `X` terminates the file
    /* do encryption */
}

public static function decrypt($cipherText, $key) {
    /* do decrytion */
    return rtrim(base64_decode($plainText), ""X""); // cut off the termination `X`
}
</code></pre>
","871","<security><cakephp><encryption><encoding><rijndael>","0","0","2","2014-08-20 17:01:02","25410478","4","","550026","","2014-08-20 16:52:16","2014-08-20 12:31:19",""
"25404795","Encrypting/decrypting some file types with Rijndael 256 (CakePHP Security library) garbles contents","<p>I am using CakePHP's <code>Security::rijndael()</code> function to encrypt and decrypt text and files.  I previously wrote some code using <code>mcrypt</code> directly, which worked in the same way, but then I found <code>Security::rijndael</code> and realised I had reinvented the wheel.  So the problem I have happens either way.</p>

<p>If I encrypt a string, or a text file, or a PDF document, the code below works perfectly and I get the correct decrypted string/file.  However, if I try encrypting a .doc, .docx or an image file, the decrypted file is garbled.</p>

<p>Here's the code that does the encrypting/decrypting</p>

<pre><code>public static function encrypt($plainText, $key) {
    $plainText = base64_encode($plainText);

    //Hash key to ensure it is long enough
    $hashedKey = Security::hash($key);
    $cipherText = Security::rijndael($plainText, $hashedKey, 'encrypt');
    return base64_encode($cipherText);
}

public static function decrypt($cipherText, $key) {
    $cipherText = base64_decode($cipherText);

    $hashedKey = Security::hash($key);
    $plainText = Security::rijndael($cipherText, $hashedKey, 'decrypt');
    return base64_decode($plainText);
}
</code></pre>

<p>...and this code actually presents the file to the user (I've edited the code to keep it simple):</p>

<pre><code>public function download($id){
    App::uses('File', 'Utility');
    $key = $this-&gt;User-&gt;getDocumentKey($id);
    $file = new File('my_encrypted_file.docx');
    $encrypted = $file-&gt;read();
    $decrypted = Encrypt::decrypt($encrypted, $key);

    header('Cache-Control: no-store, no-cache, must-revalidate');
    header('Content-Disposition: attachment; filename=""my_decrypted_file.docx""');
    echo $decrypted;
    die();
}
</code></pre>

<p><strong>Update</strong> - it appears that the encryption is a red herring, as the file is garbled even without encrypting and decrypting it!  The following produces exactly the same broken file:</p>

<pre><code>        header('Content-Disposition: attachment; filename=""test.docx""');
        $file = new File($this-&gt;data['Model']['file']['tmp_name']);
        echo $file-&gt;read();
        die();
</code></pre>
","<p>Well, I was barking up the wrong tree.</p>

<p>For whatever reason (whitespace at the start of some PHP file maybe?), adding <code>ob_clean();</code> immediately after sending the headers, has fixed the problem.</p>
","871","<security><cakephp><encryption><encoding><rijndael>","0","0","2","2014-08-20 17:01:02","25410478","4","","550026","","2014-08-20 16:52:16","2014-08-20 12:31:19",""
"29931600","Prestashop : Invalid security key (AND, can I delete _RIJNDAEL_KEY_ ?)","<p>I'm migrating a 2008 old prestashop install (which has been upgraded to 1.6) towards an all new clean prestashop install on a new server.</p>

<p>The possibilities of import/export didn't seem to work so well, I especially didn't know how to transfer users and their crypted passwords (missing in the export file). So I eventually decided to use the same database used in the original website to absolutely preserve everything perfectly.</p>

<p>From there, two questions (I'm open to any recommandations of course) :</p>

<ul>
<li><p>I replaced the COOKIE_KEY for the former key in the configuration file, so that the passwords keep working. But when I do that, and try to go to a new page in the Back-Office, I have an error message saying <strong>""Invalid security Key""</strong>
How can I fix that ?</p></li>
<li><p>My second point is potentially linked :
The config file of my former website didn't contain a _RIJNDAEL_KEY_ and _RIJNDAEL_IV_ key even though it had been upgraded to Prestashop 1.6.
So I totally <strong>deleted these two lines</strong> from the config file of my new clean install, and don't have the ""Invalid security key"" error message aforementioned anymore.
How can I fix this in a cleaner way ?
Is it a problem to not have the _RIJNDAEL_KEY_ and _RIJNDAEL_IV_ in my config file, can I do without them ? (everything seems to work)</p></li>
</ul>

<p>Hoping it's clear enough, I stay at disposal !
Thanks in advance for your help !</p>
","","867","<prestashop><prestashop-1.6><rijndael>","1","","0","2015-04-28 23:18:21","","0","","","","","2015-04-28 23:18:21",""
"30917990","Padding is invalid and cannot be removed with Rijndael","<p>when i use this code to encrypt and decrypt i got an error said </p>

<p>Padding is invalid and cannot be removed.</p>

<p>any idea </p>

<pre><code>public static class Crypto
{

    private static readonly byte[] initVectorBytes = Encoding.ASCII.GetBytes(""tu89geji340t89u2"");

    // This constant is used to determine the keysize of the encryption algorithm.
    private const int keysize = 256;

    public static string Encrypt(string plainText, string passPhrase)
    {
        byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);
        using (PasswordDeriveBytes password = new PasswordDeriveBytes(passPhrase, null))
        {
            byte[] keyBytes = password.GetBytes(keysize / 8);
            using (RijndaelManaged symmetricKey = new RijndaelManaged())
            {
                symmetricKey.Mode = CipherMode.CBC;
                using (ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes))
                {
                    using (MemoryStream memoryStream = new MemoryStream())
                    {
                        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
                        {
                            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
                            cryptoStream.FlushFinalBlock();
                            byte[] cipherTextBytes = memoryStream.ToArray();
                            return Convert.ToBase64String(cipherTextBytes);
                        }
                    }
                }
            }
        }
    }

    public static string Decrypt(string cipherText, string passPhrase)
    {
        byte[] cipherTextBytes = Convert.FromBase64String(cipherText);
        using (PasswordDeriveBytes password = new PasswordDeriveBytes(passPhrase, null))
        {
            byte[] keyBytes = password.GetBytes(keysize / 8);
            using (RijndaelManaged symmetricKey = new RijndaelManaged())
            {
                symmetricKey.Mode = CipherMode.CBC;
                using (ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes))
                {
                    using (MemoryStream memoryStream = new MemoryStream(cipherTextBytes))
                    {
                        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read))
                        {
                            byte[] plainTextBytes = new byte[cipherTextBytes.Length];
                            int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
                            return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
","<p>I tried the following using your methods and it worked fine:</p>

<pre><code>var passPhrase = ""123456"";
var e = Encrypt(""testtesttesttest"", passPhrase);
Console.WriteLine(e); // YEtSJshcn686ZO+JlEQ48ap/odhuvIGalbAT1XhinqQ=
var d = Decrypt(e, passPhrase);
Console.WriteLine(d); // testtesttesttest
</code></pre>

<p>This suggests that you're either passing a different <code>passPhrase</code> to <code>Decrypt()</code> to the one you passed to <code>Encrypt()</code>, or that you are somehow corrupting the ciphertext prior to decryption. (Are you perhaps calling <code>Decrypt</code> with the ciphertext and passphrase parameters reversed?)</p>

<p>It's also worth noting that essentially everything in the comments at the top of your code is wrong:</p>

<ul>
<li>You're <em>not</em> passing any salt to <code>PasswordDeriveBytes</code>.</li>
<li>The size of the IV must be equal to the <em>block size</em> (16 bytes), it is unrelated to the key size used.</li>
<li>Passing a 16 character string through <code>Encoding.ASCII.GetBytes()</code> results in a 16 byte output, <em>not</em> 32 bytes. (This rather coincidentally means that your <code>initVectorBytes</code> is in fact the correct length for the IV).</li>
</ul>

<p>Furthermore, <code>PasswordDeriveBytes</code> is deprecated and should not be used. You should be using <code>Rfc2898DeriveBytes</code> instead, and you should be using a proper salt value. The IV should also not be a static value, and definitely not one derived from an ASCII string!</p>
","853","<c#><encryption><rijndael>","1","1","1","2015-06-18 17:30:35","","6","","554019","","2015-06-18 17:30:35","2015-06-18 14:20:15",""
"12769186","PHP: decrypting AES in Counter mode with mcrypt","<p>I have a string encrypted with AES in Counter mode, it wasn't done with PHP and I can't make mcrypt to decode it :( there's a class that works as expected: <a href=""http://www.movable-type.co.uk/scripts/aes.html"" rel=""nofollow"">http://www.movable-type.co.uk/scripts/aes.html</a> (see bottom of the page), but it's slow so I want to decrypt with mcrypt.</p>

<p>According to classes <code>decrypt</code> method I did following:</p>

<pre><code> $key = $_POST['key'];

 $length = strlen($key);
 if($length &gt; 32)
   $key = substr($key, 0, 32);

 $cyphered = base64_decode($_POST['cyphered']);
 /// make initialization vector with first 8 bytes treated as integers
 $f8b = array_map('ord', str_split(substr($cyphered, 0, 8)));
 array_unshift($f8b, 'I8');
 $iv = call_user_func_array('pack', $f8b);

 print mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, substr($cyphered, 8), 'ctr', $iv);
</code></pre>

<p>And result is garbage on output :( I don't understand what am I doing wrong. Could somebody please sched some light on this problem?</p>
","<p><a href=""http://phpseclib.sourceforge.net/"" rel=""nofollow"">phpseclib's pure PHP AES implementation</a> is almost 4x as fast as movable type's AES implementation:</p>

<p><a href=""http://phpseclib.sourceforge.net/crypt/examples.html"" rel=""nofollow"">http://phpseclib.sourceforge.net/crypt/examples.html</a></p>

<p>And that's when mcrypt isn't available.  When mcrypt is available it'll use that and be even faster.</p>

<p>That said, if you are insistent on using mcrypt...  try MCRYPT_RIJNDAEL_128.  MCRYPT_RIJNDAEL_256 has a block size of 256 bits, which works for Rijndael (Rijndael has a variable block size) but not AES.</p>
","832","<php><aes><mcrypt><rijndael>","0","0","1","2012-10-09 12:07:35","","1","","184491","","2012-10-07 13:25:12","2012-10-07 13:19:18",""
"33770528","Inverse MixColumns AES Rijndael algorithm","<p>I am currently writing a AES implementation in c and I am having issues computing the inverse of the MixColumn. My function is recursive as that's what made the most sense when figuring out how to do the multiplication and addition for 09, 0E, 0D and 0B mod x^4 + 1.</p>

<pre><code>unsigned char multiplyByte(unsigned char c, unsigned char f){
    unsigned char result = 0;
    if(f==1){
        return c;
    }else if(f==2){
        return = c &lt;&lt; 1;
    }else if(f &amp; 1){
        return multiplyByte(((c &lt;&lt; 1) ^ c) ^ ((c &amp; 0x80) &gt;&gt; 7 ? 0x1b : 0x00), f/2);
    }else{
        return multiplyByte((c &lt;&lt; 1) ^ ((c &amp; 0x80) &gt;&gt; 7 ? 0x1b : 0x00), f/2);
    }
    return result;
}
</code></pre>

<p>c is the byte being multiplied and f is the factor. </p>

<p>I am trying to get this to make sense on paper with the values 0x47 for c and 0x0E for f. Using the answer <a href=""https://crypto.stackexchange.com/questions/2569/how-does-one-implement-the-inverse-of-aes-mixcolumns"">here</a> and the tables <a href=""https://en.wikipedia.org/wiki/Rijndael_mix_columns"" rel=""nofollow noreferrer"">here</a>. If I work this answer out on paper I get...</p>

<p>0x47 x 0x0E:</p>

<p>(((((X x 2) + X) x 2) + X) x 2)</p>

<p>Where addition is simply XOR, then this should be equivalent to..</p>

<p>0x47 x 0x03 = (0x47 &lt;&lt; 1 XOR 47) = 0xC9</p>

<p>So,</p>

<p>(((0xC9 x 2) + 0xC9) x 2) = 0x47 x 0x0E = </p>

<p>(0x40) x 2 = 0x80.</p>

<p>However, I am expecting 0x87 as per the tables in the second link.</p>
","","828","<c><algorithm><recursion><encryption><rijndael>","0","","0","2015-11-18 01:59:13","","3","","-1","","2017-04-13 12:48:18","2015-11-18 01:59:13",""
"21057933","Rijndael Encryption Keys","<p>I'm trying to understand why the code directly below does not require you to generate a IV key as well?? Code is from: </p>

<p><a href=""http://msdn.microsoft.com/en-us/library/sb7w85t6(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/sb7w85t6(v=vs.85).aspx</a></p>

<pre><code>Dim key As RijndaelManaged = Nothing

Try
    ' Create a new Rijndael key.
    key = New RijndaelManaged()
</code></pre>

<p>I see this sample code but requires you to generate both keys manaually?</p>

<p>Code is from:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/System.Security.Cryptography.RijndaelManaged(v=vs.110).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/System.Security.Cryptography.RijndaelManaged(v=vs.110).aspx</a></p>

<pre><code>  Class RijndaelExample

    Public Shared Sub Main()
        Try 

            Dim original As String = ""Here is some data to encrypt!"" 

            ' Create a new instance of the RijndaelManaged 
            ' class.  This generates a new key and initialization  
            ' vector (IV). 
            Using myRijndael As New RijndaelManaged()

                myRijndael.GenerateKey()
                myRijndael.GenerateIV()
</code></pre>

<p>Also I plan to hardcode the key into the source(I know it's not the most secure)... how do I actually store these.. it looks like it will generate a new key everytime the application is open.</p>
","<p>You're right, in that it will create a new key and IV every time you run. Instead, you should be creating a hash yourself (which is used to encrypt the data, and is derived from your password and a ""salt"" - see <a href=""http://en.wikipedia.org/wiki/Salt_(cryptography)"" rel=""nofollow"">http://en.wikipedia.org/wiki/Salt_(cryptography)</a>)</p>

<p>For example, </p>

<pre><code>    SymmetricAlgorithm m_encryption;
    RSACryptoServiceProvider m_rsa;
    Rfc2898DeriveBytes m_hash;

    string password = ""Pa55w0rd"";
    string salt = ""this is my salt. There are many like it, but this one is mine."";

    public void SetupEncryption()
    {


        m_encryption = new RijndaelManaged();
        m_hash = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes(salt));

        m_encryption.Key = m_hash.GetBytes(m_encryption.KeySize / 8);
        m_encryption.IV = m_hash.GetBytes(m_encryption.BlockSize / 8);

    }
</code></pre>

<p>As you've noted though, storing your salt and your password are very bad form! This is just an example to show how to get started. Take a good look through wikipedia and other articles until you fully understand the principles!</p>
","812","<vb.net><key><store><rijndael>","-1","0","1","2014-03-18 13:27:35","","0","","321731","","2014-01-12 03:14:44","2014-01-11 02:44:23",""
"21254680","Decrypting using rijndael and C# issue","<p>I am encrypting some text and converting it to base64 and upon decryption I appear to have some odd characters as it blocks the rest of the output...</p>

<p>For example, I want to encrypt 10,2013-12-16 10:22:24,1387189344 which converts to MaEA8gd7Xyg8tNBrtVBlb75U/a0J9x5x7UryI81gy3R+ZvL01p05uzDtzdBWL5Pg (base64) and then when I decrypt I try to print the output as ""["" + decrypted + ""]"" but the second bracket doesn't come out.....</p>

<p>Here's my code. Thanks in advance.</p>

<pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using DataSync;
using System.IO;
using System.Security.Cryptography;

namespace EncryptionTest
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        // encrypt
        private void button1_Click(object sender, EventArgs e)
        {
            txtOutput.Text = Encrypt(txtData.Text, txtCIV.Text, txtSecret.Text);

        }

        // decrypt
        private void button2_Click(object sender, EventArgs e)
        {
            txtOutput.Text = ""["" + Decrypt(txtData.Text, txtCIV.Text, txtSecret.Text) + ""\r\n"" + ""]"";
        }



        public string GenerateIV()
        {
            RijndaelManaged RM = new RijndaelManaged();
            RM.KeySize = 128;
            RM.BlockSize = 128;
            RM.Mode = CipherMode.CBC;
            RM.Padding = PaddingMode.Zeros;

            RM.GenerateIV();

            return Convert.ToBase64String(RM.IV);
        }

        public string Decrypt(string Encrypted, string IV, string SecretKey)
        {
            byte[] DecryptThis = Convert.FromBase64String(Encrypted);
            byte[] DecryptIV = Convert.FromBase64String(IV);
            byte[] Key = Encoding.UTF8.GetBytes(SecretKey);

            SHA256 SHA256Obj = SHA256.Create();
            byte[] PrivateKeyHash = SHA256Obj.ComputeHash(Key, 0, Key.Length);

            RijndaelManaged RM = new RijndaelManaged();
            RM.Mode = CipherMode.CBC;
            RM.Padding = PaddingMode.Zeros;

            MemoryStream ms = new MemoryStream();
            CryptoStream cs = new CryptoStream(ms, RM.CreateDecryptor(PrivateKeyHash, DecryptIV), CryptoStreamMode.Write);

            cs.Write(DecryptThis, 0, DecryptThis.Length);
            cs.FlushFinalBlock();
            cs.Close();          

            // Strip null (padding) characters
            int Position = -1;
            foreach (byte Char in ms.ToArray())
            {
                ++Position;
                if (Char == 0)
                {
                break;
                }
            }

            string Temp = Encoding.UTF8.GetString(ms.ToArray());

            return Temp.Substring(0, Position+1).Trim();              
        }

        public string Encrypt(string ToBeEncrypted, string IV, string SecretKey)
        {
            byte[] EncryptThis = Encoding.UTF8.GetBytes(ToBeEncrypted);
            byte[] EncryptIV = Convert.FromBase64String(IV);
            byte[] Key = Encoding.UTF8.GetBytes(SecretKey);

            SHA256 SHA256Obj = SHA256.Create();
            byte[] PrivateKeyHash = SHA256Obj.ComputeHash(Key, 0, Key.Length);

            RijndaelManaged RM = new RijndaelManaged();
            RM.Mode = CipherMode.CBC;
            RM.Padding = PaddingMode.Zeros;

            MemoryStream ms = new MemoryStream();
            CryptoStream cs = new CryptoStream(ms, RM.CreateEncryptor(PrivateKeyHash, EncryptIV), CryptoStreamMode.Write);

            cs.Write(EncryptThis, 0, EncryptThis.Length);
            cs.FlushFinalBlock();
            cs.Close();

            return Convert.ToBase64String(ms.ToArray());
        }
    }
}
</code></pre>
","<p>You have a line break in your code here:</p>

<pre><code>txtOutput.Text = ""["" + Decrypt(txtData.Text, txtCIV.Text, txtSecret.Text) + ""\r\n"" + ""]"";
                                                                              ^^^
</code></pre>

<p>You have to place the line break <strong>after</strong> the bracket:</p>

<pre><code>txtOutput.Text = ""["" + Decrypt(txtData.Text, txtCIV.Text, txtSecret.Text) + ""]"" + ""\r\n"";
</code></pre>

<p>Also I am not sure if you even need the line break. Are you using a multiline textbox?</p>
","808","<c#><encryption><rijndael>","0","0","2","2014-01-21 15:47:59","","3","","80274","","2014-01-21 15:47:59","2014-01-21 09:55:13",""
"21254680","Decrypting using rijndael and C# issue","<p>I am encrypting some text and converting it to base64 and upon decryption I appear to have some odd characters as it blocks the rest of the output...</p>

<p>For example, I want to encrypt 10,2013-12-16 10:22:24,1387189344 which converts to MaEA8gd7Xyg8tNBrtVBlb75U/a0J9x5x7UryI81gy3R+ZvL01p05uzDtzdBWL5Pg (base64) and then when I decrypt I try to print the output as ""["" + decrypted + ""]"" but the second bracket doesn't come out.....</p>

<p>Here's my code. Thanks in advance.</p>

<pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using DataSync;
using System.IO;
using System.Security.Cryptography;

namespace EncryptionTest
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        // encrypt
        private void button1_Click(object sender, EventArgs e)
        {
            txtOutput.Text = Encrypt(txtData.Text, txtCIV.Text, txtSecret.Text);

        }

        // decrypt
        private void button2_Click(object sender, EventArgs e)
        {
            txtOutput.Text = ""["" + Decrypt(txtData.Text, txtCIV.Text, txtSecret.Text) + ""\r\n"" + ""]"";
        }



        public string GenerateIV()
        {
            RijndaelManaged RM = new RijndaelManaged();
            RM.KeySize = 128;
            RM.BlockSize = 128;
            RM.Mode = CipherMode.CBC;
            RM.Padding = PaddingMode.Zeros;

            RM.GenerateIV();

            return Convert.ToBase64String(RM.IV);
        }

        public string Decrypt(string Encrypted, string IV, string SecretKey)
        {
            byte[] DecryptThis = Convert.FromBase64String(Encrypted);
            byte[] DecryptIV = Convert.FromBase64String(IV);
            byte[] Key = Encoding.UTF8.GetBytes(SecretKey);

            SHA256 SHA256Obj = SHA256.Create();
            byte[] PrivateKeyHash = SHA256Obj.ComputeHash(Key, 0, Key.Length);

            RijndaelManaged RM = new RijndaelManaged();
            RM.Mode = CipherMode.CBC;
            RM.Padding = PaddingMode.Zeros;

            MemoryStream ms = new MemoryStream();
            CryptoStream cs = new CryptoStream(ms, RM.CreateDecryptor(PrivateKeyHash, DecryptIV), CryptoStreamMode.Write);

            cs.Write(DecryptThis, 0, DecryptThis.Length);
            cs.FlushFinalBlock();
            cs.Close();          

            // Strip null (padding) characters
            int Position = -1;
            foreach (byte Char in ms.ToArray())
            {
                ++Position;
                if (Char == 0)
                {
                break;
                }
            }

            string Temp = Encoding.UTF8.GetString(ms.ToArray());

            return Temp.Substring(0, Position+1).Trim();              
        }

        public string Encrypt(string ToBeEncrypted, string IV, string SecretKey)
        {
            byte[] EncryptThis = Encoding.UTF8.GetBytes(ToBeEncrypted);
            byte[] EncryptIV = Convert.FromBase64String(IV);
            byte[] Key = Encoding.UTF8.GetBytes(SecretKey);

            SHA256 SHA256Obj = SHA256.Create();
            byte[] PrivateKeyHash = SHA256Obj.ComputeHash(Key, 0, Key.Length);

            RijndaelManaged RM = new RijndaelManaged();
            RM.Mode = CipherMode.CBC;
            RM.Padding = PaddingMode.Zeros;

            MemoryStream ms = new MemoryStream();
            CryptoStream cs = new CryptoStream(ms, RM.CreateEncryptor(PrivateKeyHash, EncryptIV), CryptoStreamMode.Write);

            cs.Write(EncryptThis, 0, EncryptThis.Length);
            cs.FlushFinalBlock();
            cs.Close();

            return Convert.ToBase64String(ms.ToArray());
        }
    }
}
</code></pre>
","<p>You are not removing all the ""\0"" in your <code>Decrypt()</code> method.
at line 82, replace</p>

<pre><code>return Temp.Substring(0, Position + 1).Trim();
</code></pre>

<p>by</p>

<pre><code>return Temp.Substring(0, Position).Trim();
</code></pre>
","808","<c#><encryption><rijndael>","0","0","2","2014-01-21 15:47:59","","3","","80274","","2014-01-21 15:47:59","2014-01-21 09:55:13",""
"41045433","How secure is to use Rijndael symmetric encryption algorithm","<p>Please let us know how secure is Rijndael symmetric encryption algorithm.
The key is stored in web config file.</p>
","<p>The Rijndael algorithm, in conjunction with safe configuration values (i.e. <code>AES</code>), is <a href=""https://security.stackexchange.com/a/43427/16485"">very robust and secure</a>. The only true measure of an encryption algorithm's security is its consistent and long-lived exposure to cryptanalysis and attempts to defeat it by many cryptographers. AES has thus far been successful at that task. </p>

<p>Storing the symmetric encryption key in source code is a <a href=""https://www.asp.net/identity/overview/features-api/best-practices-for-deploying-passwords-and-other-sensitive-data-to-aspnet-and-azure"" rel=""nofollow noreferrer"">much bigger concern</a>, and orders of magnitude more likely to be the cause of a data leak than Rijndael. </p>
","803","<algorithm><encryption><rijndael><symmetric>","-4","1","1","2016-12-08 17:49:50","","3","","","","","2016-12-08 17:32:12",""
"8959481","How to store the encryption keys securely in php code file","<p>I have a website that users submit sensitive data to it then a php script encrypts these sensitive data using rijndael 256 and store it in mysql database</p>

<p>the problem is that I want to store the key in a secure place that can be accessed only by the php script and not to be seen by any other one</p>
","<p>Depends on how high a security you need for the data. You could consider having a different security key for each user, by possibly encrypting the data that identifies that particular customer and attaching it onto the 256-bit encrypted key. But better still would be split the key up and insert that encrypted data throughout the key. Makes it more complex to decipher. This would mean if a programmer has access to the key the programmer can't simply decrypt everyones data without having access to the customer encrypted data as well which would be different for every user.</p>

<p>And yes it is true that the programmer can still echo the key out to the screen but they would ALSO need the customer encrypted data for each customer they want to decrypt the data of.</p>

<p>You could also consider Public and Private Key Encryption instead if applicable. The customer/user could generate their own keys. Customer places the public key into a form on the website which gets stored in the database, then the customer/user would have the private key to decrypt the data. You use the public key to encrypt the data. This would mean each user/customer would have their own set of keys. The Private key could possibly be even placed on a keycard and hooked to the computer to verify access.</p>

<p>More information @ <a href=""http://en.wikipedia.org/wiki/Public-key_cryptography"" rel=""nofollow"">http://en.wikipedia.org/wiki/Public-key_cryptography</a></p>
","787","<php><security><rijndael>","2","2","3","2018-06-26 13:58:37","","11","1","1033581","","2018-06-26 13:58:37","2012-01-22 06:33:21",""
"8959481","How to store the encryption keys securely in php code file","<p>I have a website that users submit sensitive data to it then a php script encrypts these sensitive data using rijndael 256 and store it in mysql database</p>

<p>the problem is that I want to store the key in a secure place that can be accessed only by the php script and not to be seen by any other one</p>
","<p>One alternative would be to have the PHP script call an external script (doesn't necessarily have to be another PHP script; it could be anything) that would have access to the key.  As long as no one has write access to the external script, or read access to it if you hard-code the key into it, then it should be relatively secure.  If you store the key in a separate file, that file needs to be readable/writable only by the owner of the external script.</p>
","787","<php><security><rijndael>","2","0","3","2018-06-26 13:58:37","","11","1","1033581","","2018-06-26 13:58:37","2012-01-22 06:33:21",""
"8959481","How to store the encryption keys securely in php code file","<p>I have a website that users submit sensitive data to it then a php script encrypts these sensitive data using rijndael 256 and store it in mysql database</p>

<p>the problem is that I want to store the key in a secure place that can be accessed only by the php script and not to be seen by any other one</p>
","<p>You could encrypt/decrypt with certificates and have the server request a password for the certificate upon bootup. </p>

<p>The good thing is that your key is only in memory and can be different for every installation/server.</p>

<p>However, this method is quite a pain and generally only works when you have your own system administrators/are not dependent on a third-party hosting provider.</p>

<hr>

<p>The intermediate solution to generate an encryption key per section/user/client in your database and encrypt the sensitive data with this per client key. These per-client keys are encrypted with a master key and stored in your database, while the master-key is stored somewhere in on disk with  minimal priviliges.<br>
This will not safe you when your server gets fully compromised, but does limit the risk in case of -for example- a data-leak/partial compromise.</p>

<p><sub>If the problem is you don't trust a) the programmer or b) the system administrator, you are out of luck.</sub></p>
","787","<php><security><rijndael>","2","0","3","2018-06-26 13:58:37","","11","1","1033581","","2018-06-26 13:58:37","2012-01-22 06:33:21",""
"10314886","Rijndael-256 Encryption Decryption in PHP","<p>I have a situation where I have to encrypt and decrypt SOAP xml in PHP. I am trying to encrypt the Envelope of a soap xml. Encryption is working, but decryption is not. For encryption and decryption I use the code specified in this article:</p>

<p><a href=""http://blog.djekldevelopments.co.uk/?p=334"" rel=""nofollow"">http://blog.djekldevelopments.co.uk/?p=334</a></p>

<p>If the input string contains any special characters(eg:'&lt;>'), then decryption is not working. How can I solve this?</p>

<pre><code>function decrypt($string = """")
  {
$keyfile = ""./AES.keyz"";
$keyfile = file($keyfile);
    $key = base64_decode($keyfile[0]);
    $iv = base64_decode($keyfile[1]);
$string = base64_decode($string);
return strippadding(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $string,MCRYPT_MODE_CBC, $iv));
   }
</code></pre>
","<p>MCRYPT_RIJNDAEL_256 ia not AES with 256 bit key , its RIJNDAEL with a 256 bit block size.</p>

<p>To decrypt  256 bit AES , you need to use MCRYPT_RIJNDAEL_128 with a 256 bit key.</p>
","785","<php><drupal><mcrypt><rijndael><rijndaelmanaged>","0","0","1","2012-05-03 03:14:49","","1","","922834","","2012-04-25 12:45:36","2012-04-25 11:43:37",""
"23740259","How to calculate output length for PHP Mcrypt Rijndael 256 CBC","<p>I want to use a plug-in for cakephp to store encrypted data in the database. But I want to calculate how much length is necessary for database fields. </p>

<p>Here is the encryption code of the plugin:</p>

<pre><code>return base64_encode(
     mcrypt_encrypt(
          MCRYPT_RIJNDAEL_256, md5($settings['key']
     ), $value, MCRYPT_MODE_CBC, md5(md5($settings['key']
))));
</code></pre>

<p>For instance how much field length is necessary for 2000 lengthed raw string input? VARCHAR(?)</p>

<p>If you need more details here is the 
All Plug-in Code:</p>

<p><a href=""https://github.com/jmillerdesign/Cipher-Behavior-for-CakePHP/blob/master/Model/Behavior/CipherBehavior.php"" rel=""nofollow"">https://github.com/jmillerdesign/Cipher-Behavior-for-CakePHP/blob/master/Model/Behavior/CipherBehavior.php</a></p>
","<p>I think the estimated answer is, source string length + <code>35%</code> (of source str length).</p>

<p>I did a test like this to find the answer:</p>

<pre><code>$key = 'really long key hello world';

// Source String
$str = '';
for ($i = 1; $i &lt;= 2000; $i++) {
    $str .=  'x';
}
$slength = strlen($str);
echo 'source str length = '. $slength.""&lt;br&gt;"";
$encrypted = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $str, MCRYPT_MODE_ECB));

$elength = strlen($encrypted);
echo 'encrypted str length = '. $elength.""&lt;br&gt;"";

echo 'diff = '. (($elength - $slength)/$slength) * 100 .'%';
</code></pre>

<hr>

<p>Outputs:</p>

<pre><code>source str length = 2000
encrypted str length = 2688
diff = 34.4%


source str length = 20000
encrypted str length = 26668
diff = 33.34%
</code></pre>

<hr>

<p>Instead of using a fixed <code>varchar</code>, why don't you use the field type <code>text</code>?</p>
","773","<php><cakephp><mcrypt><rijndael><cbc-mode>","1","1","2","2014-05-21 22:54:40","23740592","0","","634120","","2014-05-19 14:25:19","2014-05-19 14:23:40",""
"23740259","How to calculate output length for PHP Mcrypt Rijndael 256 CBC","<p>I want to use a plug-in for cakephp to store encrypted data in the database. But I want to calculate how much length is necessary for database fields. </p>

<p>Here is the encryption code of the plugin:</p>

<pre><code>return base64_encode(
     mcrypt_encrypt(
          MCRYPT_RIJNDAEL_256, md5($settings['key']
     ), $value, MCRYPT_MODE_CBC, md5(md5($settings['key']
))));
</code></pre>

<p>For instance how much field length is necessary for 2000 lengthed raw string input? VARCHAR(?)</p>

<p>If you need more details here is the 
All Plug-in Code:</p>

<p><a href=""https://github.com/jmillerdesign/Cipher-Behavior-for-CakePHP/blob/master/Model/Behavior/CipherBehavior.php"" rel=""nofollow"">https://github.com/jmillerdesign/Cipher-Behavior-for-CakePHP/blob/master/Model/Behavior/CipherBehavior.php</a></p>
","<p>Use CakePHP's Security::encrypt() method instead, as it is using Rijndael-256 out of the box. Rijndael ciphers are a variable length depending on the key used, so a VarChar will not work. The ciphertext is binary data and there's no need to encode it, so you would use a BLOB field instead. </p>
","773","<php><cakephp><mcrypt><rijndael><cbc-mode>","1","0","2","2014-05-21 22:54:40","23740592","0","","634120","","2014-05-19 14:25:19","2014-05-19 14:23:40",""
"11972829","How to call use .NET RijndaelManaged from native COM?","<p>Can anyone give example usage for using <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx"" rel=""nofollow noreferrer""><code>System.Security.Cryptography.RijndaelManaged</code></a> from native Win32 using COM?</p>

<hr>

<p>Here is a functional example of how to use .NET's <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.sha256managed.aspx"" rel=""nofollow noreferrer""><code>System.Security.Cryptography.SHA256Managed</code></a> </p>

<blockquote>
  <p><strong>Note</strong>: This is an example of how to call SHA256Managed, and <strong>not</strong> RijndaelManaged**. i show this code to introduce some of the tricky concepts of calling COM objects with early and late-binding, and to show that calling .NET objects with COM Callable Wrappers <em>is</em> possible. Some people might throw up that hands when hearing i want to mix .NET and Win32 COM.</p>
</blockquote>

<p><strong>Note:</strong> The language is Delphi (which is what i wrote and tested it in), but transcoded to make it look slightly more like C# or Java, so the question is more accessible to a wider audience:</p>

<pre><code>public static string HashStr256(String szPlaintext)
{
   OleVariant sha = CreateOleObject('System.Security.Cryptography.SHA256Managed');

   OleVariant inputBuffer = VarByteArrayOf(szPlaintext);

   Integer l = VarArrayLowBound(inputBuffer, 1);
   Integer h = VarArrayHighBound(inputBuffer, 1);

   ICryptoTransform crypto = IDispatch(sha) as ICryptoTransform;
   crypto.TransformFinalBlock(
         PSafeArray(TVarData(inputBuffer).VArray), //inputArray,
         l,  //input array offset
         h-l+1); //input array count

   OleVariant digest := sha.Hash;

   Result := ToBase64String(BytesOfVarByteArray(digest));
end;
</code></pre>

<p>With the helper function:</p>

<pre><code>function VarByteArrayOf(const s: string): OleVariant;
var
    Data: Pointer;
begin
    //Create variant byte array to hold the bytes
    Result := VarArrayCreate([0, Length(s)-1], varByte);

    //Copy from Delphi array to Variant Array
    if Length(s) &gt; 0 then
    begin
        Data := VarArrayLock(Result);
        try
            System.Move(s[1], Data^, Length(s));
        finally
            VarArrayUnlock(Result);
        end;
    end;
end;
</code></pre>

<p>The real reason i show code calling <code>SHA256Managed</code> is to demonstrate the difficulties i'm encountering when passing <code>arrays</code> to COM in Delphi. For example, if you simply relied on <code>IDispatch</code> late binding:</p>

<pre><code>sha: OleVariant;
inputBuffer: OleVariant;
...
sha.TransformFinalBlock(inputBuffer, i, count);
</code></pre>

<p>Then at runtime you get <em>The parameter is incorrect</em>; something about <code>IDispatch</code> late binding doesn't support passing an <code>OleVariant</code> that is an array of bytes.</p>

<p>That's why i have to instead pass the <code>safearray</code> that is inside the <code>OleVariant</code>. As we all know a <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms221627(v=vs.85).aspx"" rel=""nofollow noreferrer""><strong>Variant</strong></a> is just a <a href=""http://docwiki.embarcadero.com/Libraries/en/System.TVarData"" rel=""nofollow noreferrer"">union structure</a>, where we care about the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms221482%28v=vs.85%29.aspx"" rel=""nofollow noreferrer""><code>SAFEARRAY</code></a> member:</p>

<pre><code>data: PSafeArray;

data := PSafeArray(TVarData(inputBuffer).VArray);
sha.TransformFinalBlock(data, i, count);
</code></pre>

<p>Except trying to pass a <code>PSafeArray</code> using <code>IDispatch</code> late-binding causes Delphi to throw-up:</p>

<blockquote>
  <p>Type not allowed in OLE Automation call</p>
</blockquote>

<p>Which is why we're forced to partially abandon <code>IDispatch</code> late binding for <code>ICryptoTransform</code> early binding:</p>

<pre><code>ICryptoTransform_Native = interface(IDispatch)
   ['{8ABAD867-F515-3CF6-BB62-5F0C88B3BB11}']
   ...
   function TransformFinalBlock(inputBuffer: PSafeArray; inputOffset: Integer; inputCount: Integer): PSafeArray; safecall;
   ...
end;
</code></pre>

<p>with</p>

<pre><code>crypto: ICryptoTransform;
sha: OleVariant;
inputBuffer: OleVariant;

crypto = IDispatch(sha) as ICryptoTransform;
crypto.TransformFinalBlock(
         PSafeArray(TVarData(inputBuffer).VArray), //inputArray,
         i, n);
</code></pre>

<p>So that should be it, right? We've solved how to pass arrays to COM .NET objects? i should be all set to use <code>Rijndael</code> now; use early-binding with <code>PSafeArray</code>. </p>

<p>This is what we want to try with late-binding:</p>

<pre><code>OleVariant aes := CreateOleObject('System.Security.Cryptography.RijndaelManaged');

OleVariant keyBytes = VarByteArrayOf(Key);
aes.Key := key;
</code></pre>

<p>that fails for the same reason above - you cannot passed <code>OleVariant</code> arrays to COM objects (The parameter is incorrect). </p>

<p>So we we should just use the early binding of <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.key.aspx"" rel=""nofollow noreferrer""><code>SymmetricAlgorithm.Key</code></a> and pass the <code>Key</code> as a <code>PSafeArray</code>:</p>

<pre><code>var
   symmetric: ISymmetricAlgorithm;
   aes: OleVariant;
   keyBytes: OleVariant;
begin
   aes := CreateOleObject('System.Security.Cryptography.RijndaelManaged');

   symmetric:= (IDispatch(aes) as ISymmetricAlgorithm;
   symmetric.Key := PSafeArray(TVarData(inputBuffer).VArray);
   ...
end;
</code></pre>

<p>Except there is no <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.isymmetricalgorithm.aspx"" rel=""nofollow noreferrer""><code>ISymmetricAlgorithm</code></a> interface; i made it up.</p>

<p>If you import the type library from <code>mscorelib.tlb</code>, which contains <code>ICryptoTransform</code>, there is no early binding <code>ISymmetricAlgorithm</code>. There <em>is</em> a <em>late-bound</em> <code>ISymmetricAlgorithm</code>:</p>

<pre><code>IID__SymmetricAlgorithm: TGUID = '{05BC0E38-7136-3825-9E34-26C1CF2142C9}';
CLASS_SymmetricAlgorithm: TGUID = '{5B67EA6B-D85D-3F48-86D2-8581DB230C43}';
_SymmetricAlgorithm = interface;
SymmetricAlgorithm = _SymmetricAlgorithm;

_SymmetricAlgorithm = interface(IDispatch)
   ['{05BC0E38-7136-3825-9E34-26C1CF2142C9}']
end;
_SymmetricAlgorithmDisp = dispinterface
   ['{05BC0E38-7136-3825-9E34-26C1CF2142C9}']
end;
</code></pre>

<p>So how can i set the <strong>RijndaelManaged</strong> <code>Key</code> and <code>IV</code> from native Win32 COM? What late-binding syntax can i use?</p>

<p>How to call use .NET RijndaelManaged from native COM?</p>

<h2>Further Attempts</h2>

<p>Since there is no early-bound <code>interface</code> i can use, i have to focus on how to pass a byte array through <code>IDispatch</code>. The secret is what should be in the <code>Variant</code> that i pass to the COM object.</p>

<p>Since the early-bound version used <code>safearrays</code>, i'll start with that. First of all i will <em>manually</em> set <code>OleVariant</code> structure myself. </p>

<p>For each of the following attempts the following is true:</p>

<pre><code>key: OleVariant;
data: PSafeArray;

data := PSafeArray(TVarData(keyBytes).VArray);
</code></pre>

<p>setting the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms221170.aspx"" rel=""nofollow noreferrer"">variant enum myself</a>.</p>

<ul>
<li><p><strong>Attempt 1</strong>: <code>VT_ARRAY</code> <em>A SAFEARRAY pointer.</em></p>

<pre><code>TVarData(key).VType := VT_ARRAY;
TVarData(key).VArray := data;
</code></pre></li>
<li><p><strong>Attempt 2</strong>: <code>VT_ARRAY</code> <em>A SAFEARRAY pointer.</em></p>

<pre><code>TVarData(key).VType := VT_ARRAY or VT_I1;
TVarData(key).VArray := data;
</code></pre></li>
<li><p><strong>Attempt 3</strong>: <code>VT_SAFEARRAY</code> <em>A safe array. Use VT_ARRAY in VARIANT.</em></p>

<pre><code>TVarData(key).VType := VT_SAFEARRAY or VT_I1;
TVarData(key).VArray := data;
</code></pre></li>
<li><p><strong>Attempt 4</strong>: <code>VT_SAFEARRAY</code> <em>A safe array. Use VT_ARRAY in VARIANT.</em></p>

<pre><code>TVarData(key).VType := VT_SAFEARRAY;
TVarData(key).VArray := data;
</code></pre></li>
</ul>

<p>All of them fail with a <code>The parameter is incorrect</code> error.</p>

<p>Get i get the sense that <code>VT_ARRAY</code> (a safearray) and <code>VT_SAFEARRAY</code> (a safearray) are just not what the COM Callable wrapper IDispatch interface is prepared to accept. Perhaps it needs to be <code>VT_CARRAY</code>.</p>

<p>Or maybe not. Maybe someone smarter than me can figure it out.</p>

<h2>Bonus Reading</h2>

<p>This is, essentially, a re-phrasing of a question i asked in 2008 on the Borland Newsgroups</p>

<blockquote>
  <p><a href=""http://www.delphigroups.info/2/10/1029333.html"" rel=""nofollow noreferrer"">Delphi compiler has built-in knowledge of COM SafeArrays?</a></p>
</blockquote>

<ul>
<li><a href=""https://stackoverflow.com/questions/489048/net-mshtml-how-to-pass-a-bstr-safearray"">.NET mshtml: How to pass a BSTR SAFEARRAY?</a></li>
</ul>
","","760","<.net><winapi><com><rijndael>","2","","0","2012-08-15 19:34:01","","13","1","-1","","2017-05-23 12:04:44","2012-08-15 16:02:16",""
"45442114","RIJNDAEL 256 CBC encryption with IV in java","<p>I have a reference of PHP code that does Rijndael encryption. I want convert it to java code, I tried few examples but none of them worked for me.
<strong>Here is the php code:</strong></p>

<pre><code>$initialisationVector = hash(""sha256"", utf8_encode($myiv), TRUE);
$key = hash(""sha256"", utf8_encode($mykey), TRUE);
$encryptedValue = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256,$encryptKey, utf8_encode($mydata), MCRYPT_MODE_CBC, $initialisationVector));
</code></pre>

<p><strong>Here is my java code that throws: Key length not 128/160/192/224/256 bits</strong></p>

<pre><code>public static String encrypt() throws Exception{
    String myiv = ""somevalue"";
    String mykey = ""somevalue"";
    String mydata = ""somevalue"";
    String new_text = """";

    RijndaelEngine rijndael = new RijndaelEngine(256);
    CBCBlockCipher cbc_rijndael = new CBCBlockCipher(rijndael);
    ZeroBytePadding c = new ZeroBytePadding();
    PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(cbc_rijndael, c);

    byte[] iv_byte = sha256(myiv);

    byte[] givenKey = sha256(mykey);

    CipherParameters keyWithIV = new ParametersWithIV(new KeyParameter(givenKey), iv_byte);

    pbbc.init(true, keyWithIV);
    byte[] plaintext = mydata.getBytes(Charset.forName(""UTF-8""));
    byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];
    int offset = 0;
    offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
    offset += pbbc.doFinal(ciphertext, offset);
    new_text = new String(new Base64().encode(ciphertext), Charset.forName(""UTF-8""));
    System.out.println(new_text);
    return new_text;
}

public static byte[] sha256(String input) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance(""SHA-256"");
    byte[] messageDigest = md.digest(input.getBytes(Charset.forName(""UTF-8"")));
    return messageDigest;
}
</code></pre>

<p>I am not really good with cryptography. Thanks in advance!</p>
","<p>The error message is clear: ""initialisation vector must be the same length as block size"". You are specifiying a 256-bit (32-byte) block size, verify that <code>iv_byte</code> is 32-bytes.</p>

<p>There are a few problems:</p>

<ol>
<li><p>For the IV get the bytes from the hash, pass the bytes to the encryption function, <code>BigInteger</code> has no place in that.</p></li>
<li><p><code>sha256(appId)</code> provides a 256-bit key, just use it.</p></li>
</ol>

<p>The following are not needed, the result of <code>sha256</code> is 256-bits:</p>

<pre><code>final int keysize = 256;
byte[] keyData = new byte[keysize];
System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
</code></pre>

<ol start=""3"">
<li><code>sha256(appId)</code> provides a 256-bit key, just use it.</li>
</ol>

<p>The following are not needed:</p>

<pre><code>final int keysize = 256; 
byte[] keyData = new byte[keysize];
System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
</code></pre>

<ol start=""4"">
<li><p><code>mcrypt</code> ""MCRYPT_RIJNDAEL_256"" is specifying a 256-bit block size which means it is not AES, ""MCRYPT_RIJNDAEL_128"" is AES which should be used.</p></li>
<li><p><code>mcrypt</code>  uses non-standard null padding, that needs to be accommodated.</p></li>
<li><p>Using a SHA-256 hash is not sufficiently secure, use a password derivation function such as PBKDF2.</p></li>
</ol>
","737","<java><encryption><bouncycastle><rijndael>","0","3","1","2017-08-01 17:33:01","","6","","8291740","","2017-08-01 17:09:45","2017-08-01 15:38:19",""
"31007475","What is the corresponding Powershell module for the PHP encryption library using MCRYPT_RIJNDAEL_256?","<p>PHP code: </p>

<p><code>mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $to_encrypt, MCRYPT_MODE_ECB);</code></p>

<p>I need the corresponding powershell code which can produce the same result.</p>

<p>I have already tried ConvertTo-SecureString/ ConvertFrom-SecureString.</p>

<p>Powershell Code (Not producing correct encryption): </p>

<pre><code>$api_code = ""214e3854a1ec5433ae986d1e5d40c436""
$params = @{""controller"" = $controller; ""action""= $action;  ""all""= $TRUE; }
[Byte[]] $key = $api_code[0..$api_code.length]
$param_object = $params | ConvertTo-SecureString -AsPlainText -Force
$param_aes = $param_object | ConvertFrom-SecureString -key $key
</code></pre>

<p>The encrypted string is coming out different. Is there a parameter that I am missing? Or Is there another module?</p>
","<p>As pointed out in the comments, <code>SecureString</code>s have nothing to do with the Rijndael specification, and <code>MCRYPT_RIJNDAEL_256</code> is <em>not</em> the same as AES256 (which refer Rijndael-128 with a 256-bit key)</p>

<p>So, to solve your problem, we just need a function to encrypt a plaintext in ECB cipher mode using Rijndael with a block size of 256.</p>

<p>For this, the obvious choice is the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>RijndaelManaged</code></a> class. Fortunately, the MSDN documentation provides a basic but fully functional example of how to use the <code>RijndaelManaged</code> class and a <a href=""https://msdn.microsoft.com/en-us/library/System.Security.Cryptography.CryptoStream(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>CryptoStream</code></a> to encrypt and decrypt strings - all we need to do is rewrite it in PowerShell and change the block size and cipher mode:</p>



<pre class=""lang-psh prettyprint-override""><code>function Encrypt-Rijndael256ECB {
    param(
        [byte[]]$Key,
        [string]$Plaintext
    )

    $RijndaelProvider = New-Object -TypeName System.Security.Cryptography.RijndaelManaged

    # Set block size to 256 to imitate MCRYPT_RIJNDAEL_256
    $RijndaelProvider.BlockSize = 256
    # Make sure we use ECB mode, or the generated IV will fuck up the first block upon decryption
    $RijndaelProvider.Mode      = [System.Security.Cryptography.CipherMode]::ECB
    $RijndaelProvider.Key       = $key

    # This object will take care of the actual cryptographic transformation
    $Encryptor = $RijndaelProvider.CreateEncryptor()

    # Set up a memorystream that we can write encrypted data back to
    $EncMemoryStream = New-Object System.IO.MemoryStream
    $EncCryptoStream = New-Object System.Security.Cryptography.CryptoStream -ArgumentList $EncMemoryStream,$Encryptor,""Write""
    $EncStreamWriter = New-Object System.IO.StreamWriter -ArgumentList $EncCryptoStream

    # When we write data back to the CryptoStream, it'll get encrypted and written back to the MemoryStream
    $EncStreamWriter.Write($Plaintext)

    # Close the writer
    $EncStreamWriter.Close()
    # Close the CryptoStream (pads and flushes any data still left in the buffer)
    $EncCryptoStream.Close()
    $EncMemoryStream.Close()

    # Read the encrypted message from the memory stream
    $Cipher     = $EncMemoryStream.ToArray() -as [byte[]]
    $CipherText = [convert]::ToBase64String($Cipher)

    # return base64 encoded encrypted string
    return $CipherText
}
</code></pre>

<p>The decryption process is almost the same, although this time we'll need to reverse it and read the cipher text back through the CryptoStream from the MemoryStream:</p>

<pre class=""lang-psh prettyprint-override""><code>function Decrypt-Rijndael256ECB {
    param(
        [byte[]]$Key,
        [string]$CipherText
    )

    $RijndaelProvider = New-Object -TypeName System.Security.Cryptography.RijndaelManaged

    $RijndaelProvider.BlockSize = 256
    $RijndaelProvider.Mode      = [System.Security.Cryptography.CipherMode]::ECB
    $RijndaelProvider.Key       = $key

    $Decryptor = $RijndaelProvider.CreateDecryptor()

    # Reverse process: Base64Decode first, then populate memory stream with ciphertext and lastly read decrypted data through cryptostream
    $Cipher = [convert]::FromBase64String($CipherText) -as [byte[]]

    $DecMemoryStream = New-Object System.IO.MemoryStream -ArgumentList @(,$Cipher)
    $DecCryptoStream = New-Object System.Security.Cryptography.CryptoStream -ArgumentList $DecMemoryStream,$Decryptor,$([System.Security.Cryptography.CryptoStreamMode]::Read)
    $DecStreamWriter = New-Object System.IO.StreamReader -ArgumentList $DecCryptoStream

    $NewPlainText = $DecStreamWriter.ReadToEnd()

    $DecStreamWriter.Close()
    $DecCryptoStream.Close()
    $DecMemoryStream.Close()

    return $NewPlainText
}
</code></pre>

<p><img src=""https://i.stack.imgur.com/AzBpq.png"" alt=""Rijndael256 in action""></p>
","734","<php><powershell><encryption><mcrypt><rijndael>","2","3","1","2015-06-23 20:28:05","31012868","8","","","","","2015-06-23 15:45:54",""
"31243524","Convert this php encryption function to python","<p>I have been trying to change this php function to python but to no avail.</p>

<pre><code>public static function encode($text, $KEY) {
    $pkcs5text= self::pkcs5_pad($text,16);
    $size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
    $iv = mcrypt_create_iv($size, MCRYPT_RAND);
    $bin = pack('H*', bin2hex($pkcs5text) );
    $encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $KEY, $bin, MCRYPT_MODE_ECB, $iv);
    return base64_encode($encrypted);
}
</code></pre>

<p>My Python script is as below</p>

<pre><code>import rijndael
import base64

KEY_SIZE = 16
BLOCK_SIZE = 32

def encrypt(key, plaintext):
    padded_key = key.ljust(KEY_SIZE, '\0')
    padded_text = plaintext + (BLOCK_SIZE - len(plaintext) % BLOCK_SIZE) * '\0'

    # could also be one of
    #if len(plaintext) % BLOCK_SIZE != 0:
    #    padded_text = plaintext.ljust((len(plaintext) / BLOCK_SIZE) + 1 * BLOCKSIZE), '\0')
    # -OR-
    #padded_text = plaintext.ljust((len(plaintext) + (BLOCK_SIZE - len(plaintext) % BLOCK_SIZE)), '\0')

    r = rijndael.rijndael(padded_key, BLOCK_SIZE)

    ciphertext = ''
    for start in range(0, len(padded_text), BLOCK_SIZE):
        ciphertext += r.encrypt(padded_text[start:start+BLOCK_SIZE])

    encoded = base64.b64encode(ciphertext)

    return encoded
</code></pre>

<p>Both scripts generate encoded text from the same message that is different from each other. I am not sure where do I go wrong. How do I implement mcrypt into python on top of rijndael 128?</p>
","<p>Given your initialization vector is being randomly created in the first example, it's no surprise that the output looks different encrypted and Base 64 encoded. What's important is that you can decode and dycrypt reliably.</p>

<p>Also, your python code doesn't look like it's using an initialization vector at all (unless the libraries do it by default, which in this case, they're not). This means you won't be using cypher block chaining and thus less secure than the PHP example.</p>

<p>The first few bytes of your unencoded output are traditionally the initialization vector, which the receiver knows the length of and then uses to initialize the decryption process.</p>

<p>It looks like the Python 2.x libraries aren't particularly useful, see <a href=""https://stackoverflow.com/questions/8356689/python-equivalent-of-phps-mcrypt-rijndael-256-cbc"">this example here</a>. Python 3 seems to have what you require <a href=""https://stackoverflow.com/questions/27334093/decrypt-mcrypt-rijndael-256-with-32-byte-initialization-vectors-with-pycrypto"">here</a>.</p>

<p>Also, for block size, use 16 as it's the AES standard (see <a href=""http://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">here</a>), 32 won't work.</p>
","719","<php><python><aes><mcrypt><rijndael>","0","1","2","2015-07-06 10:47:08","31243750","1","0","","","","2015-07-06 10:29:15",""
"31243524","Convert this php encryption function to python","<p>I have been trying to change this php function to python but to no avail.</p>

<pre><code>public static function encode($text, $KEY) {
    $pkcs5text= self::pkcs5_pad($text,16);
    $size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
    $iv = mcrypt_create_iv($size, MCRYPT_RAND);
    $bin = pack('H*', bin2hex($pkcs5text) );
    $encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $KEY, $bin, MCRYPT_MODE_ECB, $iv);
    return base64_encode($encrypted);
}
</code></pre>

<p>My Python script is as below</p>

<pre><code>import rijndael
import base64

KEY_SIZE = 16
BLOCK_SIZE = 32

def encrypt(key, plaintext):
    padded_key = key.ljust(KEY_SIZE, '\0')
    padded_text = plaintext + (BLOCK_SIZE - len(plaintext) % BLOCK_SIZE) * '\0'

    # could also be one of
    #if len(plaintext) % BLOCK_SIZE != 0:
    #    padded_text = plaintext.ljust((len(plaintext) / BLOCK_SIZE) + 1 * BLOCKSIZE), '\0')
    # -OR-
    #padded_text = plaintext.ljust((len(plaintext) + (BLOCK_SIZE - len(plaintext) % BLOCK_SIZE)), '\0')

    r = rijndael.rijndael(padded_key, BLOCK_SIZE)

    ciphertext = ''
    for start in range(0, len(padded_text), BLOCK_SIZE):
        ciphertext += r.encrypt(padded_text[start:start+BLOCK_SIZE])

    encoded = base64.b64encode(ciphertext)

    return encoded
</code></pre>

<p>Both scripts generate encoded text from the same message that is different from each other. I am not sure where do I go wrong. How do I implement mcrypt into python on top of rijndael 128?</p>
","<p>You have to use the same:</p>

<ul>
<li><p>block size (Rijndael supports different block sizes and the same has to be used to be compatible)</p>

<pre><code>BLOCK_SIZE = 16
</code></pre></li>
<li><p>padding (PKCS#7 padding pads with bytes that represent the number of padding bytes)</p>

<pre><code>padbyte = BLOCK_SIZE - len(plaintext) % BLOCK_SIZE
padded_text = plaintext + padbyte * chr(padbyte)
</code></pre></li>
</ul>

<hr>

<p><strong>Security considerations:</strong></p>

<p>Never use ECB mode. It's very insecure. Use at the very least CBC mode with a random IV. The IV doesn't have to be secret, so you can prepend it to the ciphertext and slice it off before decryption.</p>

<p>Authenticate your ciphertexts: Use an encrypt-then-MAC scheme to protect from (malicious) modifications of your ciphertexts with a strong MAC such as HMAC-SHA256 or use an authenticated mode like GCM.</p>
","719","<php><python><aes><mcrypt><rijndael>","0","1","2","2015-07-06 10:47:08","31243750","1","0","","","","2015-07-06 10:29:15",""
"7619593","Why Rijndael encryption code is not working for large file?","<p>I use the following Rijndael code to do encryption without fail for many times. But why it can not encrypt an ISO file with 4.2 GB? In fact my computer has 16GB memory and it should not be a memory problem. I use Windows 7 Ultimate. The code is compiled as winform (.Net 4) using Visual Studio 2010 (a VB.NET project).</p>

<p>I have checked that the ISO file is OK and can be mounted as virtual drive and even can be burnt to DVD rom. So it is not the ISO file problem.</p>

<p>My question: Why the following code cannot encrypt an ISO file with size of 4.2GB? Is that caused by the limitation of Windows/.NET 4 implementation?</p>

<pre><code>Private Sub DecryptData(inName As String, outName As String, rijnKey() As Byte, rijnIV() As Byte)

    'Create the file streams to handle the input and output files.
    Dim fin As New IO.FileStream(inName, System.IO.FileMode.Open, System.IO.FileAccess.Read)
    Dim fout As New IO.FileStream(outName, System.IO.FileMode.OpenOrCreate,
       System.IO.FileAccess.Write)
    fout.SetLength(0)

    'Create variables to help with read and write.
    Dim bin(100) As Byte 'This is intermediate storage for the encryption.
    Dim rdlen As Long = 0 'This is the total number of bytes written.
    Dim totlen As Long = fin.Length 'Total length of the input file.
    Dim len As Integer 'This is the number of bytes to be written at a time.

    'Creates the default implementation, which is RijndaelManaged.
    Dim rijn As New Security.Cryptography.RijndaelManaged
    Dim encStream As New Security.Cryptography.CryptoStream(fout,
       rijn.CreateDecryptor(rijnKey, rijnIV), Security.Cryptography.CryptoStreamMode.Write)

    'Read from the input file, then encrypt and write to the output file.
    While rdlen &lt; totlen
        len = fin.Read(bin, 0, 100)
        encStream.Write(bin, 0, len)
        rdlen = Convert.ToInt32(rdlen + len)
    End While

    encStream.Close()
    fout.Close()
    fin.Close()
End Sub
</code></pre>
","<pre><code>rdlen = Convert.ToInt32(rdlen + len)
</code></pre>

<p><a href=""http://msdn.microsoft.com/en-us/library/system.int32.aspx"" rel=""noreferrer"">Int32</a> can represent signed integers with values that range from negative 2,147,483,648 to positive 2,147,483,647 and since 4.2GB is about twice that I guess <code>rdlen</code> never will get bigger than <code>totlen</code> and thus you got yourself a never ending loop.</p>

<p>If VB.NET works anything like C# (and I suspect it does) you simply remove the convert</p>

<pre><code>rdlen = rdlen + len
</code></pre>

<p>The result of a Long+Int will be a Long. Where Long is a 64 bit signed integer and Int a 32 bit signed integer.</p>
","709","<.net><vb.net><rijndael>","3","9","2","2011-10-01 11:16:49","7619784","9","1","","","","2011-10-01 10:15:15",""
"7619593","Why Rijndael encryption code is not working for large file?","<p>I use the following Rijndael code to do encryption without fail for many times. But why it can not encrypt an ISO file with 4.2 GB? In fact my computer has 16GB memory and it should not be a memory problem. I use Windows 7 Ultimate. The code is compiled as winform (.Net 4) using Visual Studio 2010 (a VB.NET project).</p>

<p>I have checked that the ISO file is OK and can be mounted as virtual drive and even can be burnt to DVD rom. So it is not the ISO file problem.</p>

<p>My question: Why the following code cannot encrypt an ISO file with size of 4.2GB? Is that caused by the limitation of Windows/.NET 4 implementation?</p>

<pre><code>Private Sub DecryptData(inName As String, outName As String, rijnKey() As Byte, rijnIV() As Byte)

    'Create the file streams to handle the input and output files.
    Dim fin As New IO.FileStream(inName, System.IO.FileMode.Open, System.IO.FileAccess.Read)
    Dim fout As New IO.FileStream(outName, System.IO.FileMode.OpenOrCreate,
       System.IO.FileAccess.Write)
    fout.SetLength(0)

    'Create variables to help with read and write.
    Dim bin(100) As Byte 'This is intermediate storage for the encryption.
    Dim rdlen As Long = 0 'This is the total number of bytes written.
    Dim totlen As Long = fin.Length 'Total length of the input file.
    Dim len As Integer 'This is the number of bytes to be written at a time.

    'Creates the default implementation, which is RijndaelManaged.
    Dim rijn As New Security.Cryptography.RijndaelManaged
    Dim encStream As New Security.Cryptography.CryptoStream(fout,
       rijn.CreateDecryptor(rijnKey, rijnIV), Security.Cryptography.CryptoStreamMode.Write)

    'Read from the input file, then encrypt and write to the output file.
    While rdlen &lt; totlen
        len = fin.Read(bin, 0, 100)
        encStream.Write(bin, 0, len)
        rdlen = Convert.ToInt32(rdlen + len)
    End While

    encStream.Close()
    fout.Close()
    fin.Close()
End Sub
</code></pre>
","<p>Try to change from this:</p>

<pre><code>rdlen = Convert.ToInt32(rdlen + len)
</code></pre>

<p>to this:</p>

<pre><code>rdlen = Convert.ToInt64(rdlen + len)
</code></pre>
","709","<.net><vb.net><rijndael>","3","2","2","2011-10-01 11:16:49","7619784","9","1","","","","2011-10-01 10:15:15",""
"6140384",".NET System.Security.Cryptography Key Derivation Question (AES/Rijndael)","<p>When using the methods GenerateKey(), CreateEncryptor(Byte[], Byte[]), or CreateEncryptor() found in System.Security.Cryptography.Rijndael or System.Security.Cryptography.Aes class, how are the the keys generated?</p>

<ol>
<li>Does it follow the methods used in <a href=""http://www.ietf.org/rfc/rfc2898.txt"" rel=""nofollow"">RFC-2898</a>? I can only make an assumption that it does follow RFC-2898 since Rfc2898DeriveBytes is also a class in the System.Security.Cryptography namespace.</li>
</ol>
","<p>Both the GenerateIV Method and the GenerateKey Method just generate a sequence of random bytes of the required length. They do not use a KDF.</p>
","697","<c#><.net><aes><rijndael>","2","2","1","2011-05-26 15:02:35","6140750","0","1","","","","2011-05-26 14:38:09",""
"14874836","Can't decrypt video using C# and Rijndael","<p>I can't decrypt a video file that I encrypted it using Rijndael. Have a look at my encryption routine:</p>

<pre><code>  using (FileStream _streamInput = new FileStream(inputPath,FileMode.Open,FileAccess.Read)) {
            using (FileStream _streamOutput = new FileStream(outputPath,FileMode.Create,FileAccess.Write)) {
                RijndaelManaged _cryptoRM = new RijndaelManaged();
                UnicodeEncoding _encodingUnicode = new UnicodeEncoding();
                byte[] _key = _encodingUnicode.GetBytes(String.IsNullOrEmpty(customPassword)?_mediaPass:customPassword);
                using (CryptoStream _streamCrypto = new CryptoStream(_streamOutput,
                                                                     _cryptoRM.CreateEncryptor(_key,_key),
                                                                     CryptoStreamMode.Write)) {
                    long _bufferLength = _streamInput.Length;

                    if (_bufferLength&gt;_encryptedBlock) {
                        byte[] _encryptedBuffer        = new byte[_encryptedBlock];
                        byte[] _unencryptedBufferBlock = new byte[_encryptedBlock];

                        // encrypted block
                        _streamInput.Read(_encryptedBuffer,0,(int)_encryptedBlock);
                        _streamCrypto.Write(_encryptedBuffer,0,(int)_encryptedBlock);

                        // rest
                        int _readBytesCount = 0;
                        while ((_readBytesCount=_streamInput.Read(_unencryptedBufferBlock,0,_encryptedBlock))!=0) {
                            _streamOutput.Write(_unencryptedBufferBlock,0,(int)_readBytesCount);
                        }
                    }
                    _streamCrypto.Dispose();
                }
                _cryptoRM.Dispose();
                _streamOutput.Dispose();
            }
            _streamInput.Dispose();
        }
</code></pre>

<p>And this is my decryption routine:</p>

<pre><code>        using (FileStream _streamInput = new FileStream(inputPath, FileMode.Open, FileAccess.Read))
        {
            using (FileStream _streamOutput = new FileStream(outputPath, FileMode.Create, FileAccess.Write))
            {
                 RijndaelManaged _cryptoRM = new RijndaelManaged();
                 UnicodeEncoding _encodingUnicode = new UnicodeEncoding();
                 byte[] _key = _encodingUnicode.GetBytes(PrepareEncryptionKey(String.IsNullOrEmpty(customPassword)?_mediaPass:customPassword,""""));


                try
                {

                        using (CryptoStream _streamCrypto = new CryptoStream(_streamInput, _cryptoRM.CreateDecryptor(_key, _key), CryptoStreamMode.Read))
                        {
                            try
                            {
                                int _readBytesCount = 0;


                                //encrypted block
                                byte[] _buffer = new byte[_encryptedBlock];
                                byte[] _bufferUnencrypted = new byte[_encryptedBlock];

                                int decrypt_length = _streamCrypto.Read(_buffer, 0, _encryptedBlock);                                   
                                _streamOutput.Write(_buffer, 0, decrypt_length);

                                // rest
                                while ((_readBytesCount = _streamInput.Read(_bufferUnencrypted, 0, _encryptedBlock)) != 0)
                                {
                                    _streamOutput.Write(_bufferUnencrypted, 0, _readBytesCount);
                                }
                            }
                            catch { }
                            _streamCrypto.Dispose();
                        }

                }
                catch { }
                _cryptoRM.Dispose();
                _streamOutput.Dispose();
            }
            _streamInput.Dispose();
        }
</code></pre>

<p>Other points: 
- No error is being thrown but the video is simply not playing. 
- The size of the decrypted file is the same of the encrypted file. </p>

<p><strong>EDIT</strong>: </p>

<pre><code> private static string PrepareEncryptionKey(string key, string part)
    {
        if (part == """")
        {
            if (key.Length != 8)
            {
                return key.PadRight(8, '~');
            }
            else
            {
                return key;
            }
        }
        else
        {
            if (key.Length != (8 - part.Length))
            {
                if (key.Length &gt; (8 - part.Length))
                {
                    return key.Substring(0, (8 - part.Length)) + part;
                }
                else
                {
                    return key.PadRight((8 - part.Length), '~') + part;
                }
            }
            else
            {
                return key + part;
            }
        }
    }
</code></pre>
","<p>It seems your both methods needs fixes:</p>

<p>1/ encrypt part - you cannot write output data directly to _streamOutput but to _streamCrypto. Otherwise you will write exactly what you have taken from input file. As per your original code, you would encrypt just first block of data.</p>

<pre><code>while ((_readBytesCount = _streamInput.Read(_unencryptedBufferBlock, 0, encryptedBlockSize)) != 0)
{
    _streamCrypto.Write(_unencryptedBufferBlock, 0, (int)_readBytesCount);
}
</code></pre>

<p>2/ decrypt part - you cannot read from input stream directly but from _streamCrypto</p>

<pre><code>while ((_readBytesCount = _streamCrypto.Read(_bufferUnencrypted, 0, encryptedBlockSize)) != 0)
{
    _streamOutput.Write(_bufferUnencrypted, 0, _readBytesCount);
}
</code></pre>

<p>3/ PrepareEncryptionKey method should be used in both encryption and decryption method. This will ensure you have it same in both methods.</p>
","696","<c#><video><encryption><rijndael><rijndaelmanaged>","1","1","1","2013-02-14 17:16:55","","17","","2022280","","2013-02-14 15:31:22","2013-02-14 12:25:33",""
"6474058","Rijndael PHP encode FLASH decode","<p>I am trying to pass some encrypted data to a flash , but I got stuck somewhere in the middle.</p>

<p>Im using RIJNDAEL algorithm to encode the data in PHP :</p>

<pre><code>function encrypt($text){
    $key = ""53cded30ff7ba54d65b939fd594e3d63"";
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC); //get vector size on CBC mode 
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND); //Creating the vector
    $cryptedtext = mcrypt_encrypt (MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC, $iv); //Encrypting using MCRYPT_RIJNDAEL_256 algorithm 
    return $cryptedtext;
}
</code></pre>

<p>And im using the AS3CRYPT library to decrypt the value in flash.</p>

<p>The problem is that if I try to decode the value in flash or even in the demo of AS3CRYPT, it doesnt work.</p>

<p>I also tried to return the data from PHP encoded with base64_encode but still not working.</p>

<p>The output from PHP is something like : <code>flashvar=Á žJcV—µg)7¾1´‘5{Ò&lt;¶Ù$þS„§”</code></p>

<p>Probably I did something wrong in the PHP ...</p>
","<p>PHP doesn't add any padding, which is likely needed.</p>

<p>You'll have to pad it manually, <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php#102428"" rel=""nofollow"">take a look at this post on PHP.net</a> which explains one method of achieving PKCS7 padding compatibility.</p>

<p>Beyond that, make sure you're setting the matching confidentiality mode (<code>CBC</code>) and cipher within ""AS3CRYPTO"".</p>
","691","<php><security><rijndael>","0","1","1","2011-06-24 22:36:59","6474452","1","","339535","","2011-06-24 21:49:47","2011-06-24 21:41:44",""
"15644948","VB.Net equivalent for Java Rijndael decryption method","<p>I have a working java decryption function displayed below.  The java source code for the RijndaelAlgorithm is the standard code you see all over the internet - for example: </p>

<p><a href=""http://www.opensymphony.com/oscore/api/com/opensymphony/module/random/Rijndael_Algorithm.html"" rel=""nofollow"">http://www.opensymphony.com/oscore/api/com/opensymphony/module/random/Rijndael_Algorithm.html</a></p>

<p>I am trying to reproduce this function using VB.Net.  I know .Net has support for Rijndael, but I haven't found a combination that produces the same decrypted password as my java code below.   Seems like such a simple task but I have already spent days researching this.</p>

<p>Can anyone show me or direct me to sample code in VB.Net that would produce a function equivalent to the java function?</p>

<p>here are my arguments:</p>

<pre><code>t = f8d44...cf22f8a     32 total characters 
keyArray = [113,64,51,102,120...98,98,108,115]  32 total bytes
keySize = 32
blockSize = 16
</code></pre>

<p>Here is my working java function:</p>

<pre><code>public static String decrypt(String t, byte[] keyArray, int keySize, int blockSize)  
{
        StringBuffer plain = new StringBuffer(t.length());
        byte[] textBytes = RijndaelAlgorithm.getBytes(t);
        int cipherLen = textBytes.length;

        Object key = RijndaelAlgorithm.makeKey(setKeyLength(keyArray, keySize), keySize);

        for (int offset = 0; offset &lt; cipherLen; offset += blockSize)
        {
              byte[] plainBytes = RijndaelAlgorithm.blockDecrypt(textBytes, offset, key, blockSize);

              plain.append(new String(plainBytes));
        }
        return plain.toString();
}
</code></pre>
","<p>You may get some hints from the source code here:  <a href=""http://www.tamirgal.com/blog/page/SharpSSH.aspx"" rel=""nofollow"">http://www.tamirgal.com/blog/page/SharpSSH.aspx</a></p>
","687","<java><vb.net><rijndael>","0","0","2","2013-03-26 18:56:09","","0","","","","","2013-03-26 18:42:06",""
"15644948","VB.Net equivalent for Java Rijndael decryption method","<p>I have a working java decryption function displayed below.  The java source code for the RijndaelAlgorithm is the standard code you see all over the internet - for example: </p>

<p><a href=""http://www.opensymphony.com/oscore/api/com/opensymphony/module/random/Rijndael_Algorithm.html"" rel=""nofollow"">http://www.opensymphony.com/oscore/api/com/opensymphony/module/random/Rijndael_Algorithm.html</a></p>

<p>I am trying to reproduce this function using VB.Net.  I know .Net has support for Rijndael, but I haven't found a combination that produces the same decrypted password as my java code below.   Seems like such a simple task but I have already spent days researching this.</p>

<p>Can anyone show me or direct me to sample code in VB.Net that would produce a function equivalent to the java function?</p>

<p>here are my arguments:</p>

<pre><code>t = f8d44...cf22f8a     32 total characters 
keyArray = [113,64,51,102,120...98,98,108,115]  32 total bytes
keySize = 32
blockSize = 16
</code></pre>

<p>Here is my working java function:</p>

<pre><code>public static String decrypt(String t, byte[] keyArray, int keySize, int blockSize)  
{
        StringBuffer plain = new StringBuffer(t.length());
        byte[] textBytes = RijndaelAlgorithm.getBytes(t);
        int cipherLen = textBytes.length;

        Object key = RijndaelAlgorithm.makeKey(setKeyLength(keyArray, keySize), keySize);

        for (int offset = 0; offset &lt; cipherLen; offset += blockSize)
        {
              byte[] plainBytes = RijndaelAlgorithm.blockDecrypt(textBytes, offset, key, blockSize);

              plain.append(new String(plainBytes));
        }
        return plain.toString();
}
</code></pre>
","<p>I use these two functions in VB.NET, hope this helps</p>

<p>This is how I consume these functions</p>

<pre><code>_ConnectionString = RijndaelSimple.Decrypt(_ConnectionString, RijndaelPhrase, CurrentSession.ApplicationSession.Application.ApplicationGuid.ToString.ToLower, ""SHA1"", 2, RijndaelVector, 128)





Imports System.Text.RegularExpressions
Imports System.Data.SqlClient
Imports System.Security.Cryptography
Imports System.Text
Imports System.IO

' &lt;summary&gt;
' This class uses a symmetric key algorithm (Rijndael/AES) to encrypt and 
' decrypt data. As long as encryption and decryption routines use the same 
' parameters to generate the keys, the keys are guaranteed to be the same.
' The class uses static functions with duplicate code to make it easier to 
' demonstrate encryption and decryption logic. In a real-life application, 
' this may not be the most efficient way of handling encryption, so - as 
' soon as you feel comfortable with it - you may want to redesign this class.
' &lt;/summary&gt;

Public Class RijndaelSimple

' &lt;summary&gt;
' Encrypts specified plaintext using Rijndael symmetric key algorithm
' and returns a base64-encoded result.
' &lt;/summary&gt;
' &lt;param name=""plainText""&gt;
' Plaintext value to be encrypted.
' &lt;/param&gt;
' &lt;param name=""passPhrase""&gt;
' Passphrase from which a pseudo-random password will be derived. The 
' derived password will be used to generate the encryption key. 
' Passphrase can be any string. In this example we assume that this 
' passphrase is an ASCII string.
' &lt;/param&gt;
' &lt;param name=""saltValue""&gt;
' Salt value used along with passphrase to generate password. Salt can 
' be any string. In this example we assume that salt is an ASCII string.
' &lt;/param&gt;
' &lt;param name=""hashAlgorithm""&gt;
' Hash algorithm used to generate password. Allowed values are: ""MD5"" and
' ""SHA1"". SHA1 hashes are a bit slower, but more secure than MD5 hashes.
' &lt;/param&gt;
' &lt;param name=""passwordIterations""&gt;
' Number of iterations used to generate password. One or two iterations
' should be enough.
' &lt;/param&gt;
' &lt;param name=""initVector""&gt;
' Initialization vector (or IV). This value is required to encrypt the 
' first block of plaintext data. For RijndaelManaged class IV must be 
' exactly 16 ASCII characters long.
' &lt;/param&gt;
' &lt;param name=""keySize""&gt;
' Size of encryption key in bits. Allowed values are: 128, 192, and 256. 
' Longer keys are more secure than shorter keys.
' &lt;/param&gt;
' &lt;returns&gt;
' Encrypted value formatted as a base64-encoded string.
' &lt;/returns&gt;
Public Shared Function Encrypt(ByVal plainText As String, _
                               ByVal passPhrase As String, _
                               ByVal saltValue As String, _
                               ByVal hashAlgorithm As String, _
                               ByVal passwordIterations As Integer, _
                               ByVal initVector As String, _
                               ByVal keySize As Integer) _
                       As String

    ' Convert strings into byte arrays.
    ' Let us assume that strings only contain ASCII codes.
    ' If strings include Unicode characters, use Unicode, UTF7, or UTF8 
    ' encoding.
    Dim initVectorBytes As Byte()
    initVectorBytes = Encoding.ASCII.GetBytes(initVector)

    Dim saltValueBytes As Byte()
    saltValueBytes = Encoding.ASCII.GetBytes(saltValue)

    ' Convert our plaintext into a byte array.
    ' Let us assume that plaintext contains UTF8-encoded characters.
    Dim plainTextBytes As Byte()
    plainTextBytes = Encoding.UTF8.GetBytes(plainText)

    ' First, we must create a password, from which the key will be derived.
    ' This password will be generated from the specified passphrase and 
    ' salt value. The password will be created using the specified hash 
    ' algorithm. Password creation can be done in several iterations.
    Dim password As PasswordDeriveBytes
    password = New PasswordDeriveBytes(passPhrase, _
                                       saltValueBytes, _
                                       hashAlgorithm, _
                                       passwordIterations)

    ' Use the password to generate pseudo-random bytes for the encryption
    ' key. Specify the size of the key in bytes (instead of bits).
    Dim keyBytes As Byte()
    keyBytes = password.GetBytes(keySize / 8)

    'Dim keyBytes2 As Byte()
    'keyBytes2 = password.Rfc2898DeriveBytes

    ' Create uninitialized Rijndael encryption object.
    Dim symmetricKey As RijndaelManaged
    symmetricKey = New RijndaelManaged()

    ' It is reasonable to set encryption mode to Cipher Block Chaining
    ' (CBC). Use default options for other symmetric key parameters.
    symmetricKey.Mode = CipherMode.CBC

    ' Generate encryptor from the existing key bytes and initialization 
    ' vector. Key size will be defined based on the number of the key 
    ' bytes.
    Dim encryptor As ICryptoTransform
    encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes)

    ' Define memory stream which will be used to hold encrypted data.
    Dim memoryStream As MemoryStream
    memoryStream = New MemoryStream()

    ' Define cryptographic stream (always use Write mode for encryption).
    Dim cryptoStream As CryptoStream
    cryptoStream = New CryptoStream(memoryStream, _
                                    encryptor, _
                                    CryptoStreamMode.Write)
    ' Start encrypting.
    cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length)

    ' Finish encrypting.
    cryptoStream.FlushFinalBlock()

    ' Convert our encrypted data from a memory stream into a byte array.
    Dim cipherTextBytes As Byte()
    cipherTextBytes = memoryStream.ToArray()

    ' Close both streams.
    memoryStream.Close()
    cryptoStream.Close()

    ' Convert encrypted data into a base64-encoded string.
    Dim cipherText As String
    cipherText = Convert.ToBase64String(cipherTextBytes)

    ' Return encrypted string.
    Encrypt = cipherText
End Function

' &lt;summary&gt;
' Decrypts specified ciphertext using Rijndael symmetric key algorithm.
' &lt;/summary&gt;
' &lt;param name=""cipherText""&gt;
' Base64-formatted ciphertext value.
' &lt;/param&gt;
' &lt;param name=""passPhrase""&gt;
' Passphrase from which a pseudo-random password will be derived. The 
' derived password will be used to generate the encryption key. 
' Passphrase can be any string. In this example we assume that this 
' passphrase is an ASCII string.
' &lt;/param&gt;
' &lt;param name=""saltValue""&gt;
' Salt value used along with passphrase to generate password. Salt can 
' be any string. In this example we assume that salt is an ASCII string.
' &lt;/param&gt;
' &lt;param name=""hashAlgorithm""&gt;
' Hash algorithm used to generate password. Allowed values are: ""MD5"" and
' ""SHA1"". SHA1 hashes are a bit slower, but more secure than MD5 hashes.
' &lt;/param&gt;
' &lt;param name=""passwordIterations""&gt;
' Number of iterations used to generate password. One or two iterations
' should be enough.
' &lt;/param&gt;
' &lt;param name=""initVector""&gt;
' Initialization vector (or IV). This value is required to encrypt the 
' first block of plaintext data. For RijndaelManaged class IV must be 
' exactly 16 ASCII characters long.
' &lt;/param&gt;
' &lt;param name=""keySize""&gt;
' Size of encryption key in bits. Allowed values are: 128, 192, and 256. 
' Longer keys are more secure than shorter keys.
' &lt;/param&gt;
' &lt;returns&gt;
' Decrypted string value.
' &lt;/returns&gt;
' &lt;remarks&gt;
' Most of the logic in this function is similar to the Encrypt 
' logic. In order for decryption to work, all parameters of this function
' - except cipherText value - must match the corresponding parameters of 
' the Encrypt function which was called to generate the 
' ciphertext.
' &lt;/remarks&gt;
Public Shared Function Decrypt(ByVal cipherText As String, _
                               ByVal passPhrase As String, _
                               ByVal saltValue As String, _
                               ByVal hashAlgorithm As String, _
                               ByVal passwordIterations As Integer, _
                               ByVal initVector As String, _
                               ByVal keySize As Integer) _
                       As String

    ' Convert strings defining encryption key characteristics into byte
    ' arrays. Let us assume that strings only contain ASCII codes.
    ' If strings include Unicode characters, use Unicode, UTF7, or UTF8
    ' encoding.
    Dim initVectorBytes As Byte()
    initVectorBytes = Encoding.ASCII.GetBytes(initVector)

    Dim saltValueBytes As Byte()
    saltValueBytes = Encoding.ASCII.GetBytes(saltValue)

    ' Convert our ciphertext into a byte array.
    Dim cipherTextBytes As Byte()
    cipherTextBytes = Convert.FromBase64String(cipherText)

    ' First, we must create a password, from which the key will be 
    ' derived. This password will be generated from the specified 
    ' passphrase and salt value. The password will be created using
    ' the specified hash algorithm. Password creation can be done in
    ' several iterations.
    Dim password As PasswordDeriveBytes
    password = New PasswordDeriveBytes(passPhrase, _
                                       saltValueBytes, _
                                       hashAlgorithm, _
                                       passwordIterations)

    ' Use the password to generate pseudo-random bytes for the encryption
    ' key. Specify the size of the key in bytes (instead of bits).
    Dim keyBytes As Byte()
    keyBytes = password.GetBytes(keySize / 8)

    ' Create uninitialized Rijndael encryption object.
    Dim symmetricKey As RijndaelManaged
    symmetricKey = New RijndaelManaged()

    ' It is reasonable to set encryption mode to Cipher Block Chaining
    ' (CBC). Use default options for other symmetric key parameters.
    symmetricKey.Mode = CipherMode.CBC

    ' Generate decryptor from the existing key bytes and initialization 
    ' vector. Key size will be defined based on the number of the key 
    ' bytes.
    Dim decryptor As ICryptoTransform
    decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes)

    ' Define memory stream which will be used to hold encrypted data.
    Dim memoryStream As MemoryStream
    memoryStream = New MemoryStream(cipherTextBytes)

    ' Define memory stream which will be used to hold encrypted data.
    Dim cryptoStream As CryptoStream
    cryptoStream = New CryptoStream(memoryStream, _
                                    decryptor, _
                                    CryptoStreamMode.Read)

    ' Since at this point we don't know what the size of decrypted data
    ' will be, allocate the buffer long enough to hold ciphertext;
    ' plaintext is never longer than ciphertext.
    Dim plainTextBytes As Byte()
    ReDim plainTextBytes(cipherTextBytes.Length)

    ' Start decrypting.
    Dim decryptedByteCount As Integer
    decryptedByteCount = cryptoStream.Read(plainTextBytes, _
                                           0, _
                                           plainTextBytes.Length)

    ' Close both streams.
    memoryStream.Close()
    cryptoStream.Close()

    ' Convert decrypted data into a string. 
    ' Let us assume that the original plaintext string was UTF8-encoded.
    Dim plainText As String
    plainText = Encoding.UTF8.GetString(plainTextBytes, _
                                        0, _
                                        decryptedByteCount)

    ' Return decrypted string.
    Decrypt = plainText
End Function
</code></pre>

<p>End Class</p>
","687","<java><vb.net><rijndael>","0","0","2","2013-03-26 18:56:09","","0","","","","","2013-03-26 18:42:06",""
"51619643","Rijndael encryption in python","<p>I wanna use Rijndael encryption with key and block 256bit size in python and padding should be PKCS7. either with utf-8 encode.
I have searched a lot and finally wrote this code, I don't know this is a good way but that's all I know. when run the code I got this Error:</p>

<pre><code>Traceback (most recent call last):
File ""testForRijndael.py"", line 1, in &lt;module&gt;
  from rijndael.cipher import crypt
File ""/opt/odoo/odoo11-venv/lib/python3.6/site- 
  packages/rijndael/cipher/crypt.py"", line 1, in &lt;module&gt;
  from rijndael.cipher.blockcipher import *
File ""/opt/odoo/odoo11-venv/lib/python3.6/site- 
  packages/rijndael/cipher/blockcipher.py"", line 64
    raise Exception,""the IV length should be %i bytes""%self.blocksize
               ^
SyntaxError: invalid syntax
</code></pre>

<p>If anybody can help me, I'll be appreciate him/her</p>

<p>This is my code:</p>

<pre><code>from rijndael.cipher import crypt
from rijndael.cipher.blockcipher import MODE_CBC
from pkcs7 import PKCS7Encoder


class Rijndael():
    def __init__(self, key, iv):
       self.KEY = key
       self.IV = iv
       self.BLOCKSIZE = 32

   def encrypt(self, plain_text):
        rjn = crypt.new(self.KEY, MODE_CBC , self.IV, 
blocksize=self.BLOCKSIZE)
        pad_text = PKCS7Encoder.encode(plain_text)
        return rjn.encrypt(pad_text).encode()

   def decrypt(self, cipher_text):
       rjn = crypt.new(self.KEY, MODE_CBC , self.IV, 
                       blocksize=self.BLOCKSIZE)
       cipher_text = cipher_text.decode()
       return rjn.decrypt(cipher_text)


  r = Rijndael('abcdefghijklmnopqrstuvwxyz123456', 
  'abcdefghijklmnopqrstuvwxyzgh3456')
  test_text = ""this is a test :)""
  encrypt = r.encrypt(test_text)
  decrypt = r.decrypt(encrypt)
  print(test_text)
  print(encrypt)
  print(decrypt)
</code></pre>
","<p>The <code>rijndael</code> library you're importing from is written for python 2, but you're running it with python 3. See below for the syntax that works in python 2, but not python 3.</p>

<pre><code>$ cat raise.py
  raise Exception,""text""
$ python2 raise.py
Traceback (most recent call last):
  File ""raise.py"", line 1, in &lt;module&gt;
    raise Exception,""text""
Exception: text
$ python3 raise.py
  File ""raise.py"", line 1
    raise Exception,""text""
                   ^
SyntaxError: invalid syntax
</code></pre>

<p>You can try to migrate it yourself, using the <code>2to3</code> tool, see if someone has written a port, or write and execute your program with python 2.</p>

<p>Try <code>pip2 install rijndael</code> and then <code>python2 testForRijndael.py</code>.</p>

<p>To run <code>2to3</code> on the local code (not really recommended but it might work), run <code>2to3 -w /opt/odoo/odoo11-venv/lib/python3.6/site-packages/rijndael/**/*.py</code></p>
","682","<python><encryption><aes><rijndael>","2","1","1","2018-07-31 18:51:02","","0","","","","","2018-07-31 18:13:32",""
"38035220","Rijndael CBC encryption decryption in Perl","<p>I have perl code for encrypting/decrypting below. The encryption seams to be working. The decryption isn't restoring the original. Original: 4111111111111111 Encrypted: IW7K95q8p1Wa89CQ2DoIxQ== Decrypted: §À@ŽŒ¦õúbp 
I need the decrytion to match the original. Any ideas? Any additional suggestions?</p>

<pre><code>use strict;
use warnings;
use feature qw( say );

use Crypt::CBC   qw( );
use MIME::Base64 qw( encode_base64 decode_base64 );

sub decrypt {
my $my_string=@_;
my $cipher = Crypt::CBC-&gt;new(
{
    'key'         =&gt; 'length16length16',
    'cipher'      =&gt; 'Rijndael',
    'iv'          =&gt; '1234567890abcdef',
    'literal_key' =&gt; 1,
    'padding'     =&gt; 'null',
    'header'      =&gt; 'none',
    keysize       =&gt; 128 / 8
}
);
my $return = $cipher-&gt;decrypt($my_string);
return $return;
}

sub encrypt {
my $my_string=@_;
my $cipher = Crypt::CBC-&gt;new(
{
    'key'         =&gt; 'length16length16',
    'cipher'      =&gt; 'Rijndael',
    'iv'          =&gt; '1234567890abcdef',
    'literal_key' =&gt; 1,
    'padding'     =&gt; 'null',
    'header'      =&gt; 'none',
    keysize       =&gt; 128 / 8
}
);
my $return = encode_base64($cipher-&gt;encrypt($my_string));
return $return;
}

my $cc = '4111111111111111';
my $coded = encrypt($cc);
say $coded;
my $decoded = decrypt($coded);
say $decoded;
</code></pre>
","<h2>Error 1</h2>

<p>The following assigns the number of elements in <code>@_</code> (<code>1</code>) to <code>$mystring</code>:</p>

<pre><code>my $my_string=@_;
</code></pre>

<p>You want:</p>

<pre><code>my ($my_string) = @_;
</code></pre>

<h2>Error 2</h2>

<p>You encoded the data using base64 during encryption, but you don't have a corresponding <code>decode_base64</code> during decryption.</p>

<h2>Error 3</h2>

<p>WHAT YOU HAVE IS VERY INSECURE!</p>

<p>You're defying a number of security mechanisms by using <code>literal_key</code> with a text password and by using a constant <code>iv</code>.</p>

<p>Note that padding with <code>null</code> only works if the plaintext can't contain NUL characters. It's not a very appropriate padding method.</p>

<p>I don't know what are the implications of using a 16-byte key instead of the default 32-byte key.</p>

<h2>Error 4</h2>

<p><code>encode_base64</code> is being misused, since you don't want a newlines in the encoded string. Replace <code>encode_base64($s)</code> with <code>encode_base64($s, '')</code>.</p>

<h2>Error 5</h2>

<p>Your indenting sucks.</p>

<h2>Solution</h2>

<pre><code>#!/usr/bin/perl    
use strict;
use warnings;
use feature qw( say );

use Crypt::CBC   qw( );
use MIME::Base64 qw( encode_base64 decode_base64 );

my $key = 'length16length16';

my $cipher = Crypt::CBC-&gt;new({
    cipher =&gt; 'Rijndael',
    key    =&gt; $key,
});

sub decrypt {
    my ($my_string) = @_;
    return $cipher-&gt;decrypt(decode_base64($my_string));
}

sub encrypt {
    my ($my_string) = @_;
    return encode_base64($cipher-&gt;encrypt($my_string), '');
}

{
    my $cc = '4111111111111111';
    my $coded = encrypt($cc);
    say $coded;
    my $decoded = decrypt($coded);
    say $decoded;
}
</code></pre>

<p>Output:</p>

<pre><code>U2FsdGVkX1/QYQrNSEadlko4jtKdjM+yNaW0ZnCAmhyHHz0NyDL+id6BsM2kVPGw
4111111111111111
</code></pre>
","676","<perl><encryption><base64><rijndael>","2","3","1","2016-06-27 17:04:51","38035513","0","1","1816580","","2016-06-27 17:04:51","2016-06-26 04:33:56",""
"1998684","AES encryption problem in Debug and Release mode","<p>I am using AES encryption algorithm (Rijndael implementation). I am using MS Visual Studio 2008 IDE for my development work. I could see a strange problem in my Debug and Release mode. When I encrypt a string in Debug mode it generates  different bytes than Release mode. But fortunately decrypting will result same string. I have tried in Mac, it generates one more byte sequence but able to decrypt all byte sequences correctly.</p>

<p>Is this problem related to encryption algorithm or Debug/Release settings? 
Is there any solution to avoid this?</p>

<p>Regards
Devara Gudda</p>
","<p>You should verify the difference between your ""release"" and ""debug"" settings, the most problems occour at ""Configuration Properties -> C/C++ -> Code Generation"" and also the ""Character Set"" under ""Configuration Properties -> General"".</p>

<p>I have my implementation of AES and it compiles fine under both default configurations of VC2008.</p>
","668","<c++><visual-studio-2008><encryption><aes><rijndael>","1","0","3","2010-01-05 19:13:29","","2","","42078","","2010-01-05 04:35:46","2010-01-04 10:29:48",""
"1998684","AES encryption problem in Debug and Release mode","<p>I am using AES encryption algorithm (Rijndael implementation). I am using MS Visual Studio 2008 IDE for my development work. I could see a strange problem in my Debug and Release mode. When I encrypt a string in Debug mode it generates  different bytes than Release mode. But fortunately decrypting will result same string. I have tried in Mac, it generates one more byte sequence but able to decrypt all byte sequences correctly.</p>

<p>Is this problem related to encryption algorithm or Debug/Release settings? 
Is there any solution to avoid this?</p>

<p>Regards
Devara Gudda</p>
","<p>You might want to verify how you're specifying buffer sizes for the plain text/cipher text. In debug builds the compiler usually initializes buffers to a known value (to detect overflow errors typically).  In VC++ 2008 Express for instance, I find that char buffers are initialized to <code>0xCD</code> in debug builds.  In release builds of course, no such thing is done.  I am not saying this is the cause for what you are observing - just something you might want to check out.</p>
","668","<c++><visual-studio-2008><encryption><aes><rijndael>","1","0","3","2010-01-05 19:13:29","","2","","42078","","2010-01-05 04:35:46","2010-01-04 10:29:48",""
"1998684","AES encryption problem in Debug and Release mode","<p>I am using AES encryption algorithm (Rijndael implementation). I am using MS Visual Studio 2008 IDE for my development work. I could see a strange problem in my Debug and Release mode. When I encrypt a string in Debug mode it generates  different bytes than Release mode. But fortunately decrypting will result same string. I have tried in Mac, it generates one more byte sequence but able to decrypt all byte sequences correctly.</p>

<p>Is this problem related to encryption algorithm or Debug/Release settings? 
Is there any solution to avoid this?</p>

<p>Regards
Devara Gudda</p>
","<p>AES is a <em>block</em> cipher. You can encrypt and decrypt blocks of a fixed size of 128 bits with it. To encrypt and decrypt longer sequences you typically use a certain ""mode of operation"" and a certain ""padding scheme"" which both might involve some randonmess via the IV (initialization vector) and padding. In those cases the cipher text will be a bit longer and different each time due to the ""randomness"" that is involved. Actually, it's not a bad property that the same message encrypts to different cipher texts. You even need this to protect yourself from certain attacks.</p>
","668","<c++><visual-studio-2008><encryption><aes><rijndael>","1","2","3","2010-01-05 19:13:29","","2","","42078","","2010-01-05 04:35:46","2010-01-04 10:29:48",""
"21785153","Creating custom length password in Rijndael Cryptography Algorithm","<p>I'm using c# for implementing Rijndael algorithm to encrypt/decrypt files. Below is my code:</p>

<pre><code>private void EncryptFile(string inputFile, string outputFile, string password)
        {

            try
            {

                UnicodeEncoding UE = new UnicodeEncoding();
                byte[] key = UE.GetBytes(password.ToString());

                string cryptFile = outputFile;
                FileStream fsCrypt = new FileStream(cryptFile, FileMode.Create);

                RijndaelManaged RMCrypto = new RijndaelManaged();

                CryptoStream cs = new CryptoStream(fsCrypt,
                    RMCrypto.CreateEncryptor(key, key),
                    CryptoStreamMode.Write);

                FileStream fsIn = new FileStream(inputFile, FileMode.Open);

                int data;
                while ((data = fsIn.ReadByte()) != -1)
                    cs.WriteByte((byte)data);


                fsIn.Close();
                cs.Close();
                fsCrypt.Close();
            }
            catch
            {

            }
        }
</code></pre>

<p>Now, the thing is that, the function works only if password length is a multiple of 8. that is, if the password length is 8,16,32, etc., then it works else not.</p>
","<p>Pseudo Code => </p>

<pre><code> string passwordFlagLength(string password)
 {
    int count = 1
    for (int i = 0 to 31)
    {

        if (password.length == count) return password;
        if (password.length &lt; count) return password + new string(""x"", count - password.length);
        count = count * 2
    }
 }
</code></pre>

<p>This takes a password and makes it length 1, 2, 4, 8, etc...   up to a 31 bit value.(int w/out negative)</p>

<p>if the value is already a proper flag size number, it uses it, otherwise it fills in the rest with ""x""</p>

<p>--> Note: I agree with everyone elses comments regarding better was to do security/issues, I just posted this, because the immediate issue posted was due to a string size not being a base 2 bit value.  I also just applied the count which I forgot in my original code</p>
","667","<c#><rijndael>","0","0","2","2014-02-14 17:32:42","","5","","809009","","2014-02-14 17:32:42","2014-02-14 16:57:10",""
"21785153","Creating custom length password in Rijndael Cryptography Algorithm","<p>I'm using c# for implementing Rijndael algorithm to encrypt/decrypt files. Below is my code:</p>

<pre><code>private void EncryptFile(string inputFile, string outputFile, string password)
        {

            try
            {

                UnicodeEncoding UE = new UnicodeEncoding();
                byte[] key = UE.GetBytes(password.ToString());

                string cryptFile = outputFile;
                FileStream fsCrypt = new FileStream(cryptFile, FileMode.Create);

                RijndaelManaged RMCrypto = new RijndaelManaged();

                CryptoStream cs = new CryptoStream(fsCrypt,
                    RMCrypto.CreateEncryptor(key, key),
                    CryptoStreamMode.Write);

                FileStream fsIn = new FileStream(inputFile, FileMode.Open);

                int data;
                while ((data = fsIn.ReadByte()) != -1)
                    cs.WriteByte((byte)data);


                fsIn.Close();
                cs.Close();
                fsCrypt.Close();
            }
            catch
            {

            }
        }
</code></pre>

<p>Now, the thing is that, the function works only if password length is a multiple of 8. that is, if the password length is 8,16,32, etc., then it works else not.</p>
","<p>Simply taking the password and getting its Unicode representation in bytes makes pretty terrible key. Please don't do that! The correct way to go is to use a salted hash as a key -- that is, take a salt, a password, and mix them together with a hash function.</p>

<p>To derive a key from a variable-length password, use PBKDF2. PBKDF2 is designed to make brute forcing slower when the attacker has fast access to the data.</p>

<pre><code>string password = ...;
byte[] salt = ...;
int keyLength = 32;

byte[] key;

using(var pbkdf = new Rfc2898DeriveBytes(password, salt))
{
    key = pbkdf.GetBytes(keyLength);
}
</code></pre>

<p>If you need something which uses less CPU, HMAC will work but also be faster to brute force:</p>

<pre><code>using(var hmac = new HMACSHA256())
{
    hmac.Key = salt;
    key = hmac.ComputeHash(Encoding.UTF8.GetBytes(password));
}
</code></pre>

<p>Note that there exists hardware now which can very effectively attack PBKDF2 so this won't do much to help against a determined attacker with resources. If this is important to you, branching out of the .NET base classes and using a more modern algorithm like <a href=""https://en.wikipedia.org/wiki/Scrypt"" rel=""nofollow"">scrypt</a> might be preferred.</p>
","667","<c#><rijndael>","0","2","2","2014-02-14 17:32:42","","5","","809009","","2014-02-14 17:32:42","2014-02-14 16:57:10",""
"29576379","Cross platform (php to C# .NET) encryption/decryption with Rijndael Part 2","<p>&lt;<a href=""https://stackoverflow.com/questions/4329260/cross-platform-php-to-c-sharp-net-encryption-decryption-with-rijndael"">Original Code From Here></a></p>

<p>I came across this thread while googling. However after trying it out and making adjustments, I've come across a hurdle, hopefully someone can help me out a bit.</p>

<ol>
<li><p>The code above is fine but since the algorithm isn't really useful without making the IV change everytime, I tried using following code to generate iv but it kept saying ""Specified key is not a valid size for this algorithm."" in my C# debugger. </p></li>
<li><p>I also tried outputting IV from the C# code, after decoding base 64 string the string length varies from 30 31 2X ==> basically just fluctuates for some reason.</p></li>
<li><p>I also would like to change the KEY as well but couldn't due to similar reasons as the IV issue, so hopefully someone can help me out with that?</p></li>
</ol>

<p>(I've tried the following from <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow noreferrer"">http://php.net/manual/en/function.mcrypt-encrypt.php</a>, couldn't get it to work in harmony with C#, maybe once I fix the IV issue I'll be able to fix this as well? </p>

<pre><code>  $key = pack('H*', ""bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3""); )
</code></pre>

<p>PHP========================</p>

<pre><code>&lt;?php
  $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);
  $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
  //$iv = ""45287112549354892144548565456541"";
  $key = ""anjueolkdiwpoida"";

  $text = ""This is my encrypted message"";
  $crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC, $iv);
  $crypttext = urlencode($crypttext);
  $crypttext64=base64_encode($crypttext);
  print($crypttext64) . ""\n&lt;br/&gt;"";
  print(base64encode($iv)) . ""\n&lt;br/&gt;"";
?&gt;
</code></pre>

<p>C#========================</p>

<pre><code>string iv = Encoding.UTF8.GetString(Convert.FromBase64String(""SOME IV STRING I COPY FROM BROSWER WITH ABOVE PHP LOADED""));
string kyy = ""anjueolkdiwpoida"";
//ciphertext is also SOME TXT STRING I COPIED FROM BROWSER WITH ABOVE PHP LOADED
string plainText = ValidationControls.DecryptRJ256(cipherText, kyy, iv);



public byte[] Decode(string str)
    {
        var decbuff = Convert.FromBase64String(str);
        return decbuff;
    }

    static public String DecryptRJ256(byte[] cypher, string KeyString, string IVString)
    {
        var sRet = """";

        var encoding = new UTF8Encoding();
        var Key = encoding.GetBytes(KeyString);
        var IV = encoding.GetBytes(IVString);

        using (var rj = new RijndaelManaged())
        {
            try
            {
                rj.Padding = PaddingMode.PKCS7;
                rj.Mode = CipherMode.CBC;
                rj.KeySize = 256;
                rj.BlockSize = 256;
                rj.Key = Key;
                rj.IV = IV;
                var ms = new MemoryStream(cypher);

                using (var cs = new CryptoStream(ms, rj.CreateDecryptor(Key, IV), CryptoStreamMode.Read))
                {
                    using (var sr = new StreamReader(cs))
                    {
                        sRet = sr.ReadLine();
                    }
                }
            }
            catch (Exception exc) { Console.WriteLine(exc.Message); App.Current.Shutdown(); }
            finally
            {
                rj.Clear();
            }
        }

        return sRet;
    }
</code></pre>
","<ol>
<li><p>I realized that .NET decoding for Base 64 string is really weird. When I called DecryptRJ256() I was sending in the Key and IV that I received from the php code by a series of conversion base64_string -> byte -> utf8_string before sending both into the function. The solution to this is to just send in the byte array directly and let DecryptRJ256() deal with it directly.</p></li>
<li><p>After doing the above, the problem with automated Key and IV generation becomes apparent and no longer is a problem.</p></li>
</ol>

<p>Code Modified From Question:</p>

<p>PHP</p>

<pre><code>$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
$key = pack('H*', ""bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3"");
$text = ""This is my encrypted message"";

$crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC, $iv);

$crypttext = base64_encode($crypttext);
$key= base64_encode($key);
$iv = base64_encode($iv);
</code></pre>

<p>C#</p>

<pre><code>string plainText = ValidationControls.DecryptRJ256(Convert.FromBase64String(""/*$CRYPTTEXT STRING FROM PHP*/""), Convert.FromBase64String(""/*$KEY STRING FROM PHP*/""), Convert.FromBase64String(""/*$ STRING FROM PHP*/""));

static public String DecryptRJ256(byte[] cypher, byte[] KeyString, byte[] IVString)
    {
        ...
        var Key = KeyString;
        //var Key = encoding.GetBytes(KeyString);
        var IV = IVString;
        //var IV = encoding.GetBytes(IVString);
        ...
    }
</code></pre>
","666","<c#><php><encryption><rijndael><rijndaelmanaged>","1","0","1","2015-04-11 15:54:09","29579866","1","","-1","","2017-05-23 12:14:25","2015-04-11 09:42:55",""
"2548218","AES/Rijndael implementation for SQL Server 2000?","<p>Do you know any function implementation I could use for decrypting data encrypted by AES/Rijndael in SQL Server 2000?</p>
","<p><a href=""http://www.xpcrypt.com/products.html"" rel=""nofollow noreferrer"">xp_crypt</a> might do it</p>

<p>Without the CLR and other whizzy stuff in SQL Server 2005+ it will be difficult in the raw SQL available in SQL Server 2000.</p>
","665","<sql-server-2000><aes><rijndael>","0","0","1","2010-03-30 20:36:28","2548236","0","","13302","","2010-03-30 20:36:28","2010-03-30 19:52:41",""
"37331041","SymmetricAlgorithm Key and initialization vector (IV) implementation","<p>I have a Web Site which takes userId and encrypts it with <strong>RijndaelManaged</strong> provider.</p>

<p>After it encrypts this data, it will put into a queue. As my understanding every data should be encrypted with different IV value and this can be public.  </p>

<blockquote>
  <p>To decrypt data that was encrypted using one of the SymmetricAlgorithm classes, you must set the Key property and the IV property to the same values that were used for encryption. For a symmetric algorithm to be useful, the secret key must be known only to the sender and the receiver.</p>
</blockquote>

<p>Additionally there is a Windows Service reads from this queue and tries to decrypt data. But since every value in the queue is encrypted with different IV, how would Windows Service know which IV to use? </p>

<p>Should I store it along side with encrypted data like;</p>

<pre><code>MRibePnbXiN578TUAZcITw== - MyIVValueIsHere
</code></pre>

<p>Or is there a known approach needs to be taken?</p>
","<p>Yes that is exactly what you should do if you use AES-CBC. You should generate the IV randomly for each message (with a cryptographically secure random generator such as RNGCryptoServiceProvider). Then send the IV along with the encrypted message.</p>

<p>Consider also using the AESCryptoServiceProvider, since AES is a standard. AES is the same as Rijndael but with some fixed standardised parameters.</p>
","647","<c#><encryption><rijndael><rijndaelmanaged>","0","2","2","2016-05-19 21:54:14","37332222","0","","","","","2016-05-19 18:09:48",""
"37331041","SymmetricAlgorithm Key and initialization vector (IV) implementation","<p>I have a Web Site which takes userId and encrypts it with <strong>RijndaelManaged</strong> provider.</p>

<p>After it encrypts this data, it will put into a queue. As my understanding every data should be encrypted with different IV value and this can be public.  </p>

<blockquote>
  <p>To decrypt data that was encrypted using one of the SymmetricAlgorithm classes, you must set the Key property and the IV property to the same values that were used for encryption. For a symmetric algorithm to be useful, the secret key must be known only to the sender and the receiver.</p>
</blockquote>

<p>Additionally there is a Windows Service reads from this queue and tries to decrypt data. But since every value in the queue is encrypted with different IV, how would Windows Service know which IV to use? </p>

<p>Should I store it along side with encrypted data like;</p>

<pre><code>MRibePnbXiN578TUAZcITw== - MyIVValueIsHere
</code></pre>

<p>Or is there a known approach needs to be taken?</p>
","<p>It is common practice to prepend the IV to the encrypted data so it is available for decryption.</p>
","647","<c#><encryption><rijndael><rijndaelmanaged>","0","1","2","2016-05-19 21:54:14","37332222","0","","","","","2016-05-19 18:09:48",""
"38766511","How to decrypt text encrypted in PHP in Java (mcrypt_rijndael_256)","<p>I am having some problems decrypting some text sent from PHP in Java. I have already written code that does this for a windows version of the program in C# but I am unfamiliar with Java so this might be more simple than I am making it.</p>

<p>The encryption code in PHP:</p>

<pre><code>function encryptString($plain)
{
   $iv = ""12347112549354892543218565456541"";
   $ftpSalt = ""hjjuoelkdploida"";

   $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);  

   $padding = $block - (strlen($plain) % $block);
   $plain .= str_repeat(chr($padding), $padding);
   $crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $ftpSalt, $plain, MCRYPT_MODE_CBC, $iv);
   $crypttext64 = base64_encode($crypttext);

   return $crypttext64;
}
</code></pre>

<p>The C# function that decrypts:</p>

<pre><code>static public String doDecryptRJ256(string cypher)
{
    var sRet = """";
    var cypherByte = Decode(cypher);

    var encoding = new UTF8Encoding();
    var Key = encoding.GetBytes(mKey);
    var IV = encoding.GetBytes(mIv);

    using (var rj = new RijndaelManaged())
    {
        try
        {
            rj.Padding = PaddingMode.PKCS7;
            rj.Mode = CipherMode.CBC;
            rj.KeySize = 256;
            rj.BlockSize = 256;
            rj.Key = Key;
            rj.IV = IV;
            var ms = new MemoryStream(cypherByte);

            using (var cs = new CryptoStream(ms, rj.CreateDecryptor(Key, IV), CryptoStreamMode.Read))
            {
                using (var sr = new StreamReader(cs))
                {
                    sRet = sr.ReadLine();
                }
            }
        }
        finally
        {
                rj.Clear();
        }
    }

    return sRet;
 }
</code></pre>

<p>}</p>

<p>I have tried various suggestions from the internet but not found any that actually work. THe latest suggestion I tried to another answer was:</p>

<pre><code>            byte[] cipherText = encryptedText.getBytes(""UTF-8"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            SecretKeySpec key = new SecretKeySpec(KEY.getBytes(""UTF-8""), ""AES"");
            cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(IV.getBytes(""UTF-8"")));
            return new String(cipher.doFinal(cipherText),""UTF-8"");
</code></pre>

<p>I know similar questions have been asked previously but the solutions (possibly due to my own ignorance) haven't helped me to get this working. I haven't done any encryption work before so there is probably something that I am just not getting.</p>

<p>The code to encrypt and decrypt are within my control so if someone wants to suggest an alternative method for all three languages I am open to changing the encryption method.</p>
","","643","<java><encryption><aes><rijndael>","0","","0","2016-08-04 11:47:59","","3","3","","","","2016-08-04 11:47:59",""
"28090825","c# calling function with correct byte array","<p>I've got this function I need to call to encrypt my byte array.
The function needs the byte array to be encryptet, a byte array as password and another byte array as initialization vector.
The function itself:</p>

<pre><code>public static byte[] Encrypt(byte[] clearData, byte[] Key, byte[] IV) 
{ 

    MemoryStream ms = new MemoryStream(); 


    Rijndael alg = Rijndael.Create(); 


    alg.Key = Key; 
    alg.IV = IV; 


    CryptoStream cs = new CryptoStream(ms, 
       alg.CreateEncryptor(), CryptoStreamMode.Write); 


    cs.Write(clearData, 0, clearData.Length); 


    cs.Close(); 


    byte[] encryptedData = ms.ToArray();

    return encryptedData; 
}
</code></pre>

<p>It may sound strange but I don't get a correct call to use this function. My problem is in using a correct byte array for the password/IV.
I tried using:</p>

<pre><code>Encrypt(read, new byte[] { 0x49, 0x49, 0x49, 0x49, 0x4, 0x4, 0x4, 0x4 }, new byte[] { 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61 });
</code></pre>

<p>I just don't get the trick how to call this function. What's the correct version of a byte array to call this function (password and IV)?</p>
","<p>you can generate your Keys with </p>

<pre><code>RijndaelManaged myRijndael = new RijndaelManaged();
myRijndael.GenerateKey();
myRijndael.GenerateIV();
</code></pre>

<p>then store them somewhere save to use them to encrypt and decrypt your messages</p>

<pre><code>byte[] key = myRijindael.Key
byte[] iv = myRijindael.Iv
</code></pre>

<p>EDIT:
just noticed you are using the Rijindael Class not RijindaelManaged. In the <a href=""https://msdn.microsoft.com/de-de/library/system.security.cryptography.rijndael(v=vs.110).aspx"" rel=""nofollow"">msdn Example</a> they say ""Create a new instance of the Rijndael class.  This generates a new key and initialization vector (IV).""</p>

<p>So after you created the instance once  </p>

<pre><code>Rijndael myRijndael = Rijndael.Create()
</code></pre>

<p>just store the keys.</p>
","642","<c#><arrays><encryption><rijndael>","0","4","1","2015-01-22 14:33:08","28091145","7","1","","","","2015-01-22 14:10:33",""
"41703167","Rijndael, Mixcolumns algorithm for numbers less than 0x1B, wikipedia C program wrong?","<p>I am starting to implement AES 128 bit algorithm in FPGA and gathering information I found a C algorithm in wiki and wanted to check how the mixcolumns step works but I think it is not calculating the mod operation in the right way. The program below performs the <code>b[c] ^= 0x1b &amp; h;</code> and for the variable <code>h</code> if it has the MSB set it makes it 0xFF otherwise 0x00 which I have not been able to understand <strong>why?, for any number higher that 0x7F will go through the XOR and the rest will be left as is</strong>, I assume because the MOD operation will give the same number as the divisor is higher than the dividend but I could say that it should not be less 0x7F but less than or equal 0x8A. Thanks in advance for your insight here.</p>

<p>Wikipedia <a href=""https://en.wikipedia.org/wiki/Rijndael_mix_columns"" rel=""nofollow noreferrer"">Link</a>.</p>

<pre><code> void mixCol(uint8_t * r)
 {
 uint8_t a[4];
 uint8_t b[4];
 uint8_t h;

 for(int c=0;c&lt;4;c++)
 {
    a[c] = r[c];
    /* h is 0xff if the high bit of r[c] is set, 0 otherwise */
    h = (uint8_t)((int8_t)r[c] &gt;&gt; 7); /* arithmetic right shift, thus shifting in either zeros or ones */
    b[c] = r[c] &lt;&lt; 1; /* implicitly removes high bit because b[c] is an 8-bit char, so we xor by 0x1b and not 0x11b in the next line */
    b[c] ^= 0x1B &amp; h; /* Rijndael's Galois field, The xor is not applied when is less than 0x80 */
 }

    r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1]; /* 2 * a0 + a3 + a2 + 3 * a1 */
    r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2]; /* 2 * a1 + a0 + a3 + 3 * a2 */
    r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3]; /* 2 * a2 + a1 + a0 + 3 * a3 */
    r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0]; /* 2 * a3 + a2 + a1 + 3 * a0 */

    printf(""%X  %X\n"",b[0],h);
 }

int main()
{
uint8_t col1[4] = {0x80,0xbf,0x5d,0x80};
mixCol(col1);
return 0;
}
</code></pre>
","<p>Rewritten for clarity (and correcting the modulo operation). Short answer:</p>

<blockquote>
  <p>Why does the modulo operation only examine one bit (bit 8, 0x80)?</p>
</blockquote>

<p>The operation in question implements a GF(2<sup>8</sup>) multiplication by <code>2</code> with respect to reducing polynomial <code>0x11B</code>.</p>

<p>Because the multiplicand has only the second bit set (bit 1; 2 = 2<sup>1</sup>), the multiplication step reduces to a left shift by one bit. Because the other multiplicand is an 8-bit value, it is restricted to range 0..255 (0x00 to 0xFF), so the product is restricted to even values in range 0..510 (0x00 to 0x1FE).</p>

<p>The size of the divisor <code>0x11B</code> is 9 bits, and the product of the multiplication has at most 9 bits, too.  This means the modulo step reduces to a single bit check, too. Logically, the check is whether the value, after shifting left one bit, has the ninth bit set. (The reason why the test is <code>&amp; 0x100</code> after the bit shift, and not <code>≥ 0x11B</code> after the bit shift, is because of the differences in the modulo operation in GF(2<sup><i>N</i></sup>) and in normal arithmetic. If modulo operated in the same way as in normal arithmetic, then <code>≥</code> would indeed be used. But it does not.) </p>

<p>Instead of operating on larger than 8-bit variables, implementations check the eighth bit, prior to the shift, instead. Because the result is also limited to eight bits, the operation reduces to</p>

<pre><code>result = (byte &amp; 0x80) ? (byte &lt;&lt; 1) ^ 0x1B : (byte &lt;&lt; 1);
</code></pre>

<p>Remember, in GF(2<sup><i>N</i></sup>) <strike>no-one can hear you scream</strike> arithmetic operations like multiplication, addition, subtraction, division, and modulus are different to what we are used to.</p>

<hr>

<p>In GF(2<sup><i>N</i></sup>) arithmetic, each value <i>v</i> (a nonnegative integer) represents a <i>polynomial</i>. If we label the binary digits of <i>v</i> as <i>b</i><sub><i>k</i></sub>, then</p>

<p>&nbsp; &nbsp; <i>v</i> = 2<sup><i>N</i>-1</sup><i>b</i><sub><i>N</i>-1</sub> + 2<sup><i>N</i>-1</sup><i>b</i><sub><i>N</i>-1</sub> + .. + 2<sup>1</sup><i>b</i><sub>1</sub> + 2<sup>0</sup><i>b</i><sub>0</sub></p>

<p>representing polynomial</p>

<p>&nbsp; &nbsp; <i>b</i><sub><i>N</i>-1</sub> <i>x</i><sup><i>N</i>-1</sup> + <i>b</i><sub><i>N</i>-2</sub> <i>x</i><sup><i>N</i>-2</sup> + ... + <i>b</i><sub>1</sub> <i>x</i><sup>1</sup> + <i>b</i><sub>0</sub> <i>x</i><sup>0</sup> </p>

<p>Because the coefficients <i>b</i><sub><i>k</i></sub> can only be 0 or 1, this is a characteristic 2 finite field with 2<sup><i>N</i></sup> elements, also called a Galois field GF(2<sup><i>N</i></sup>).</p>

<p>The key thing to understand is that we do not care what value <i>x</i> has; we do not even care what type <i>x</i> is, other than that <i>x</i><sup>0</sup> = 1. We really do operate on the polynomials represented by the nonnegative integer values <i>v</i>, and therefore our basic arithmetic operations -- addition (and subtraction), multiplication, and division (and therefore also modulo operation) -- work differently on <i>v</i> than they do in regular arithmetic.</p>

<p>Because the polynomial coefficients <i>b</i><sub><i>k</i></sub> are binary, we have</p>

<p>&nbsp; &nbsp; <i>x</i><sup><i>k</i></sup> + <i>x</i><sup><i>k</i></sup> = 0</p>

<p>and not 2<i>x</i><sup><i>k</i></sup> nor <i>x</i><sup><i>k</i>+1</sup>. Our basic arithmetic operations do not ""carry"" to the next higher coefficient (binary digit). (I will refer to this as <i>""no-carry""</i> below.)</p>

<p>&nbsp;<br><strong>Addition and subtraction</strong> (<code>+</code> and <code>-</code>):</p>

<p>In GF(2<sup><i>N</i></sup>), these are done using the <strong>exclusive-or</strong> operation on <i>v</i>. (When there are multiple terms, the result is essentially the <a href=""https://en.wikipedia.org/wiki/Even_parity"" rel=""nofollow noreferrer"">even parity</a> of the inputs; <code>0</code> if there are an even number of <code>1</code> binary digits, and <code>1</code> if odd.)</p>

<pre><code>unsigned long gf2n_add(const unsigned long a, const unsigned long b)
{
    return a ^ b;
}

unsigned long gf2n_sub(const unsigned long a, const unsigned long b)
{
    return a ^ b;
}
</code></pre>

<p>&nbsp;<br><strong>Multiplication</strong> (<code>⋅</code>):</p>

<p>Because of polynomial multiplication rules, we can describe GF(2<sup><i>N</i></sup>) multiplication in terms of <a href=""https://en.wikipedia.org/wiki/Multiplication_algorithm#Long_multiplication"" rel=""nofollow noreferrer"">long multiplication</a>, except that instead of addition, we perform an exclusive-or operation.</p>

<pre><code>/* Note: we ignore overflow, and instead assume that a and b
         are small enough for the result to not overflow. */
unsigned long gf2n_mul(unsigned long a, const unsigned long b)
{
    unsigned long  result = 0UL;

    while (b) {

        if (b &amp; 1)
            result ^= a;

        a &lt;&lt;= 1;
        b &gt;&gt;= 1;
    }

    return result;
}
</code></pre>

<p>&nbsp;<br><strong>Division and modulus</strong> (<code>/</code> and <code>%</code>):</p>

<p>For readability, I shall use <code>∅</code> for GF(2<sup><i>N</i></sup>) modulo operation in this answer. (You probably won't see the null set character used that way anywhere else; I just didn't think of anything that would work better.)</p>

<p>Division in GF(2<sup><i>N</i></sup>) is implemented as multiplication by the inverse, and is quite complicated; fortunately, we do not need it here. However, it does affect the modulo operation, which we do need.</p>

<p>The Wikipedia article on <a href=""https://en.wikipedia.org/wiki/Finite_field_arithmetic"" rel=""nofollow noreferrer"">finite field arithmetic</a> shows an example of <a href=""https://en.wikipedia.org/wiki/Finite_field_arithmetic#Rijndael.27s_finite_field"" rel=""nofollow noreferrer"">modulo operation in GF(2<sup><i>N</i></sup>)</a>. It is very similar to <a href=""https://en.wikipedia.org/wiki/Long_division"" rel=""nofollow noreferrer"">long division</a>.</p>

<p>We start with the original dividend copied to the result. As long as the result has at least as many binary digits as the divisor, we exclusive-OR the result with the divisor shifted left so that its highest bit set is aligned to the highest bit set in the result.</p>

<p>Note that because of <i>no-carry</i>, we do not use the comparison operator (≥) here, but only look at the highest bit set in the result.</p>

<p>Because the exclusive-OR operation affects the bits that we check, we must check the bits in decreasing order. Rather than repeatedly shift the divisor left, it is easier to use a temporary value that we shift left once, and then have a loop that shifts the temporary value right by one bit, and tests one bit per loop:</p>

<pre><code>/* ceil(log2(v+1)) */
int bits(unsigned long v)
{
    int result = 0;

    while (v) {
        v &gt;&gt;= 1;
        result++;
    }
}

unsigned long mod(unsigned long v, unsigned long m)
{
    /* mod(v,0) is undefined; we'll just return 0. */
    if (!m)
        return v;

    if (v &gt; m) {
        const int      v_size = bits(v);
        const int      m_size = bits(m);

        /* High has only the highest bit in v set. */
        unsigned long  high = 1UL &lt;&lt; (v_size - 1);

        /* Mask is m shifted left so that its highest
           bit matches the value of high. */
        unsigned long  mask = m &lt;&lt; (v_size - m_size);

        /* Number of bits we need to examine. */
        int            i = v_size - m_size + 1;

        /* As an example, if
               v = 110101  in binary
               m = 101     in binary
           then at this point,
               v_size = 6
               m_size = 3
               high = 100000  in binary
               mask = 101000
               i = 4.

           For i steps:
               If v has the bit corresponding to high set,
               i.e. (v &amp; high) is nonzero, then:
                   v = v exclusive-or mask
               shift high right
               shift mask right
           Return v
        */

        while (i--) {
            if (high &amp; v)
                v ^= mask;
            high &gt;&gt;= 1;
            mask &gt;&gt;= 1;
        }

        return v;
    }

    if (v &lt; m)
        return v;

    /* v == m */
    return 0UL;
}
</code></pre>

<p>An example surely clarifies the idea. Let's calculate (in binary) 1010001 ∅ 1001 (in decimal, this is 81 ∅ 9). Note that the highest bit set in the (intermediate) result determines whether an exclusive-or is done; the values they represent are <i>not</i> compared:</p>

<pre><code>      1010001
    ^ 1001
    ──┴───────
      0011001
    ^   1001
    ────┴─────
        01011
    ^    1001
    ─────┴────
         0010  (2 digits; less than 4), so
    ══════════
           10
</code></pre>

<p>Therefore, 1010001 ∅ 1001 = 10 (in binary); in decimal, 81 ∅ 9 = 2. (By normal arithmetic rules, 81 % 9 = 0.)</p>

<p>It is important to notice that this is done from high bits down to the low bits, and the check involves only the most significant bit left; we do not compare the values using <code>&gt;</code> or <code>≥</code>. There are <i>(the number of binary digits in dividend) - (the number of binary digits in divisor) + 1</i> bits checked, and as many  (and up to as many exclusive-or<code>^</code> operations are opeexclusive-OR operations done, overall.</p>

<p>&nbsp;<br><strong>Multiplication</strong> (<code>×</code>) with respect to an irreducible polynomial represented by <i>c</i>:</p>

<p>In Rijndael, multiplication is done with respect to an irreducible polynomial with respect to polynomial <i>x</i><sup>8</sup> + <i>x</i><sup>4</sup> + <i>x</i><sup>3</sup> + <i>x</i><sup>1</sup> + <i>x</i><sup>0</sup>, represented by value 283 (in decimal, 0x11B in hexadecimal).</p>

<p>In essence, <i>a</i> × <i>b</i> (with respect to <i>c</i>) is just</p>

<p>&nbsp; &nbsp; (<i>a</i> ⋅ <i>b</i>) ∅ <i>c</i></p>

<p>using the definitions above for GF(2<sup><i>N</i></sup>) arithmetic.</p>

<hr>

<p>For clarification:
<br> &nbsp; <code>*</code> and <code>^</code> denote the normal arithmetic operations,
<br> &nbsp; <code>&lt;&lt;</code> is bit shift left (corresponds to arithmetic multiplication by 2), and <code>&gt;&gt;</code> is bit shift right,
<br> &nbsp; <code>⋅</code> is still used for GF(2<sup><i>N</i></sup>) multiplication,
<br> &nbsp; <code>×</code> for GF(2<sup><i>N</i></sup>) multiplication with respect to some reducing polynomial, 
<br> &nbsp; <code>∅</code> for GF(2<sup><i>N</i></sup>) modulo operation, and
<br> &nbsp; <code>+</code> and <code>-</code> refer to normal arithmetic addition and subtraction.</p>

<p>Let's look at the function the OP is trying to implement, and its definition at the <a href=""https://en.wikipedia.org/wiki/Rijndael_mix_columns#MixColumns"" rel=""nofollow noreferrer"">Rijndael mix columns</a> operation.</p>

<p>We can see that we only ever multiply (with respect to Rijndael polynomial represented by 0x11B) each value by 1 (representing polynomial <i>x</i><sup>0</sup>), 2 (representing polynomial <i>x</i><sup>1</sup>), or 3 (representing polynomial <i>x</i><sup>1</sup> + <i>x</i><sup>0</sup>):</p>

<pre><code>⎡ r0 ⎤   ⎡ 2 3 1 1 ⎤ ⎡ a0 ⎤
⎢ r1 ⎥ = ⎢ 1 2 3 1 ⎥ ⎢ a1 ⎥ 
⎢ r2 ⎥   ⎢ 1 1 2 3 ⎥ ⎢ a2 ⎥ 
⎣ r3 ⎦   ⎣ 3 1 1 2 ⎦ ⎣ a3 ⎦
</code></pre>

<p>Expanding the operation above according to GF(2<sup><i>N</i></sup>) arithmetic rules, we have</p>

<pre><code>r0 = (a0 × 2)  ^  (a1 × 3)  ^  (a2 × 1)  ^  (a3 × 1)
r1 = (a0 × 1)  ^  (a1 × 2)  ^  (a2 × 3)  ^  (a3 × 1)
r2 = (a0 × 1)  ^  (a1 × 1)  ^  (a2 × 2)  ^  (a3 × 3)
r3 = (a0 × 3)  ^  (a1 × 1)  ^  (a2 × 1)  ^  (a3 × 2)
</code></pre>

<p>Note that in GF(2<sup><i>N</i></sup>) for <i>N</i> ≥ 2, <code>3 = 1 ^ 2</code>, which means <code>a3 × 3 = a3 ^ (a3 × 2) = (a3 × 2) ^ a3</code>. If we use temporary variable <code>b0</code> to represent <code>a0 × 2</code>, we can use</p>

<pre><code>a0 × 1 = a0
a0 × 2 = b0
a0 × 3 = b0 ^ a0
</code></pre>

<p>and similarly for <code>a1</code>, <code>a2</code>, and <code>a3</code>. The function then simplifies to</p>

<pre><code>b0 = a0 × 2
b1 = a1 × 2
b2 = a2 × 2
b3 = a3 × 2

r0 = (      b0 ) ^ ( a1 ^ b1 ) ^ ( a2      ) ^ ( a3      )
r1 = ( a0      ) ^ (      b1 ) ^ ( a2 ^ b2 ) ^ ( a3      )
r2 = ( a0      ) ^ ( a1      ) ^ (      b2 ) ^ ( a3 ^ b3 )
r3 = ( a0 ^ b0 ) ^ ( a1      ) ^ ( a2      ) ^ (      b3 )
</code></pre>

<p>and since <code>^</code> is commutative (order does not matter), we can rewrite the result as</p>

<pre><code>r0 = a1 ^ a2 ^ a3 ^ b0 ^ b1
r1 = a0 ^ a2 ^ a3 ^ b1 ^ b2
r2 = a0 ^ a1 ^ a3 ^ b2 ^ b3
r3 = a0 ^ a1 ^ a2 ^ b3 ^ b0
</code></pre>

<p>Let's look at how to compute <code>a0 × 2</code>, <code>a1 × 2</code>, <code>a2 × 2</code>, and <code>a3 × 2</code>, with respect to reducing polynomial <code>0x11b</code>. Remember, by the definition of <code>×</code>, these are equivalent to <code>(a0 ⋅ 2) ∅ 0x11b</code>, <code>(a1 ⋅ 2) ∅ 0x11b</code>, <code>(a2 ⋅ 2) ∅ 0x11b</code>, and <code>(a3 ⋅ 2) ∅ 0x11b</code>, respectively.</p>

<p>The <code>⋅ 2</code> part is simple, as it effectively just shifts the value one binary digit left. Because <code>a0</code>..<code>a3</code> are 8-bit values, within <code>0x00</code> and <code>0xFF</code>, inclusive, the maximum value after the shift is <code>0x1FE</code> (or 111111110 in binary).</p>

<p>Now, remember how the modulo operation is implemented in GF(2<sup><i>N</i></sup>). Here, the dividend has either the same number of binary digits as the reducing polynomial, or fewer; thus, the loop reduces to a single bit test:</p>

<pre><code>b0 = a0 &lt;&lt; 1;
b1 = a1 &lt;&lt; 1;
b2 = a2 &lt;&lt; 1;
b3 = a3 &lt;&lt; 1;
if (b0 &amp; 0x100) b0 ^= 0x11B;
if (b1 &amp; 0x100) b1 ^= 0x11B;
if (b2 &amp; 0x100) b2 ^= 0x11B;
if (b3 &amp; 0x100) b3 ^= 0x11B;
</code></pre>

<p>except that since <code>b0</code> .. <code>b3</code> are only 8 bits in size, the above won't work. The solution is, of course, to do the bit test prior to the shift. Since the ninth bit (0x100) will be dropped anyway, exclusive-oring with <code>0x11B</code> is equivalent to <code>0x1B</code>:</p>

<pre><code>if (a0 &amp; 0x80)
    b0 = (a0 &lt;&lt; 1) ^ 0x1B;
else
    b0 = (a0 &lt;&lt; 1);
</code></pre>

<p>and similarly for <code>b1</code>, <code>b2</code>, and <code>b3</code>.</p>

<p>Unfortunately, <code>if</code> clauses are relatively slow on most common hardware. To speed the operation up, we can use an expression that yields <code>0x1B</code> if bit 7 is set in the argument, and zero otherwise:</p>

<pre><code>#define F(v) ((v &amp; 0x80) ? 0x1B : 0x00)
</code></pre>

<p>then</p>

<pre><code>b0 = (a0 &lt;&lt; 1) ^ F(a0);
b1 = (a1 &lt;&lt; 1) ^ F(a1);
b2 = (a2 &lt;&lt; 1) ^ F(a2);
b3 = (a3 &lt;&lt; 1) ^ F(a3);
</code></pre>

<p>On architectures where negative integers are represented using <a href=""https://en.wikipedia.org/wiki/Two&#39;s_complement"" rel=""nofollow noreferrer"">two's complement</a>, we can avoid the ternary operator (an <code>if</code> in disguise, really), because casting the value to a signed 8-bit type, dividing it by 128 (which all sane C compilers will implement as a right shift by 7 bits; the result of a signed binary right shifts in C is implementation-dependent), and casting back to unsigned 8-bit integer type, yields <code>0xFF</code> if the high bit was set, and <code>0x00</code> otherwise. Fortunately, if a C compiler supports the <code>int8_t</code> type, the standard says it must use two's complement!</p>

<pre><code>#define NMASK(v) ((uint8_t)((int8_t)(v) / 128))

b0 = (a0 &lt;&lt; 1) ^ (NMASK(a0) &amp; 0x1B);
b1 = (a1 &lt;&lt; 1) ^ (NMASK(a1) &amp; 0x1B);
b2 = (a2 &lt;&lt; 1) ^ (NMASK(a2) &amp; 0x1B);
b3 = (a3 &lt;&lt; 1) ^ (NMASK(a3) &amp; 0x1B);
</code></pre>

<p>(Note that if implemented in hardware, <code>(NMASK(v) &amp; 0x1B)</code> == <code>(NMASK(v &amp; 0x80) &amp; 0x1B)</code>, i.e. only examines one input bit, and produces five bits, all either zero or one. </p>

<p>The Wikipedia <a href=""https://en.wikipedia.org/wiki/Rijndael_mix_columns#Implementation_example"" rel=""nofollow noreferrer"">implementation example</a>, and the OP, do exactly this. Essentially:</p>

<pre><code>a0 = input_byte_0
a1 = input_byte_1
a2 = input_byte_2
a3 = input_byte_3

b0 = (a0 &lt;&lt; 1) ^ (0x1B &amp; (uint8_t)( (int8_t)a0 / 128 ))
b1 = (a1 &lt;&lt; 1) ^ (0x1B &amp; (uint8_t)( (int8_t)a1 / 128 ))
b2 = (a2 &lt;&lt; 1) ^ (0x1B &amp; (uint8_t)( (int8_t)a2 / 128 ))
b3 = (a3 &lt;&lt; 1) ^ (0x1B &amp; (uint8_t)( (int8_t)a3 / 128 ))

output_byte_0 = a1 ^ a2 ^ a3 ^ b0 ^ b1
output_byte_1 = a0 ^ a2 ^ a3 ^ b1 ^ b2
output_byte_2 = a0 ^ a1 ^ a3 ^ b2 ^ b3
output_byte_3 = a0 ^ a1 ^ a2 ^ b3 ^ b0
</code></pre>

<p>When expanding the bytes to individual bits in an FPGA implementation, I am not sure whether one should expand the expression for each individual output bit (this should be straightforward; I'd personally write an awk script or something to do the hard work for me), or whether to use intermediate states to reduce the size of the look-up tables. I haven't had the opportunity to play with FPGA's yet, myself.</p>
","635","<c><aes><rijndael>","1","4","1","2017-01-19 04:44:34","41709588","2","1","","","","2017-01-17 17:15:35",""
"41263677","How Can/Should I Test The AES Algorithm","<p>I am doing an extended essay in computer science and i am stuck on what to do. I am interested in the topic of the AES algorithm or any encryption algorithms. However as computer science is a science subject i must conduct an experiment. However i am unsure as to how i should test it. </p>

<p>I thought about encrypting different types of files eg. videos, photos and word files ect, and testing the data transmission speeds or encryption speeds compared to other encryption algorithms. I wondered if any of you could tell me how to do this or recommend a different experiment. It cannot be too difficult that i cannot do nor too easy that it is not worthy of a good grade. Thanks. P.S. I a 17 (Year 12)</p>
","<p>Certainly there is a wealth of opportunity for research here. Good for you for being curious about this and looking into it. You will likely want to control for a few variables and test along the following lines:</p>

<ul>
<li>symmetric vs. asymmetric encryption (i.e. AES vs. RSA)</li>
<li>different symmetric algorithms (i.e. Rijndael (current AES algorithm) vs. Blowfish, DES, TDES, etc.)</li>
<li>different block cipher modes of operation (i.e. CTR vs. CBC vs. GCM, etc.)</li>
<li>different data sizes (i.e. does it scale linearly? Does it take exactly 1000x as long to encrypt 16 bytes vs. 16_000 vs. 16_000_000?)</li>
</ul>

<p>You'll want to run these experiments on the same hardware, under the same load, in the same language, many times in order to get decent data. Especially considering that modern CPUs have the AES-NI instruction set, and custom registers for encryption data, remember to seed your experiments, or subsequent runs could have different performance profiles. </p>

<p>If you do not have previous coding experience, Java, Ruby, and Python all have very popular cryptography libraries and a broad community which is happy to support you if/when you run into challenges. If you're already familiar with one or more specific languages, I'd suggest using one of those, as it will be tricky enough to learn the cryptographic-specific instructions; learning a new language is probably an unnecessary burden to add on at this time. </p>

<p>I think this is sufficiently vague that you will still have to do the research and investigation for your paper, but should provide a starting point. Feel free to follow up with specific questions if you need. </p>
","609","<encryption><aes><rijndael>","1","1","1","2016-12-28 22:54:29","","2","","","","","2016-12-21 13:16:25",""
"24488053","C# RIJNDAEL decrypt","<p>I try to decrypt request params for JDownloader CNL Feature.</p>

<p><a href=""http://jdownloader.org/knowledge/wiki/glossary/cnl2"" rel=""nofollow"">http://jdownloader.org/knowledge/wiki/glossary/cnl2</a></p>

<p>In this sample the iv and the key is '31323334353637383930393837363534' and i try to decrypt this value 'DRurBGEf2ntP7Z0WDkMP8e1ZeK7PswJGeBHCg4zEYXZSE3Qqxsbi5EF1KosgkKQ9SL8qOOUAI'
The php code in sample to encrypt is the following</p>

<p>I know i need to decode the key from hex to string, that means the correct key is 1234567890987654</p>

<pre><code>function base16Encode($arg){
$ret="""";
for($i=0;$i&lt;strlen($arg);$i++){
    $tmp=ord(substr($arg,$i,1));    
    $ret.=dechex($tmp); 
    }
   return $ret;
}

$key=""1234567890987654"";
$transmitKey=base16Encode($key);
$link=""http://rapidshare.com/files/285626259/jDownloader.dmg\r\nhttp://rapidshare.com/files/285622259/jDownloader2.dmg"";
$cp = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', 'cbc', '');
@mcrypt_generic_init($cp, $key,$key);
$enc = mcrypt_generic($cp, $link);   
mcrypt_generic_deinit($cp); 
mcrypt_module_close($cp);
$crypted=base64_encode($enc);

echo $crypted;
</code></pre>

<p>My last try to decrypt is the following c# code but i have some troble with lenght of input. </p>

<pre><code>public static String DecryptRJ(string input, string iv, string key )
    {
        key = key.DecodeBase16(); // Extension method
        byte[] initVectorBytes = Encoding.UTF8.GetBytes(iv);
        byte[] cipherTextBytes = Encoding.UTF8.GetBytes(input);
        byte[] keyBytes = Encoding.UTF8.GetBytes(key);

        RijndaelManaged symmetricKey = new RijndaelManaged();
        symmetricKey.Mode = CipherMode.CBC;
        symmetricKey.BlockSize = 256;
        symmetricKey.KeySize = 256;
        ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);

        MemoryStream memoryStream = new MemoryStream(cipherTextBytes);
        CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);

        byte[] plainTextBytes = new byte[cipherTextBytes.Length];
        int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
        memoryStream.Close();
        cryptoStream.Close();

        return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
    }
</code></pre>

<p>One more Information this PHP Code works fine and can decode and decrypt correct.</p>

<pre><code>function decrypt($data, $_key){
echo '&lt;br&gt;&lt;hr&gt;&lt;br&gt;';
out($data);
$plain=base64_decode($data);
out($plain);
echo 'init';
//$e = mcrypt_decrypt ( $_cp , $_key , $plain , 'cbc' );
$e = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $_key, $plain, 'cbc', $_key);  
out($e);
echo 'end';
</code></pre>

<p>}</p>
","<p>Ok now i can decrypt the encrypted sample data (see php code or <a href=""http://jdownloader.org/knowledge/wiki/glossary/cnl2"" rel=""nofollow"">http://jdownloader.org/knowledge/wiki/glossary/cnl2</a>) Code C# is this</p>

<pre><code>public static string DecryptDLCData(string data, string _key, Encoding encoding = null)
    {
        if (encoding == null)
            encoding = Encoding.Default;
        data = data.DecodeBase64(encoding);
        RijndaelManaged rijndaelCipher = new RijndaelManaged();
        rijndaelCipher.Mode = CipherMode.CBC;
        rijndaelCipher.Padding = PaddingMode.Zeros;
        rijndaelCipher.KeySize = 256;
        rijndaelCipher.BlockSize = 128;

        byte[] pwdBytes = Encoding.Default.GetBytes(_key);

        byte[] keyBytes = new byte[16];

        int len = pwdBytes.Length;
        if (len &gt; keyBytes.Length) len = keyBytes.Length;

        Array.Copy(pwdBytes, keyBytes, len);

        rijndaelCipher.Key = keyBytes;
        rijndaelCipher.IV = keyBytes;

        var transform = rijndaelCipher.CreateDecryptor();

        byte[] plainText = Encoding.Default.GetBytes(data);

        byte[] cipherBytes = transform.TransformFinalBlock(plainText, 0, plainText.Length);
        return Encoding.UTF8.GetString(cipherBytes);
    }
</code></pre>
","607","<c#><php><encryption><rijndael>","-1","0","1","2014-07-02 06:31:44","","6","","2965487","","2014-07-01 14:58:38","2014-06-30 10:29:06",""
"2606578","How can I retain carriage returns when I'm encrypting data?","<p>I have this following setup, a textarea named with some data in it that may have carriage returns and another textarea that has <code>style='display:none'</code> in order to make it hidden as follows:</p>

<pre><code>&lt;textarea id=""myTextarea"" onBlur=""encryptMyData()""&gt;&lt;/textarea&gt;
&lt;textarea name=""encryptedText"" style='display:none'&gt;&lt;/textarea&gt;
</code></pre>

<p>the user enters data in the first textarea and when that text area loses focus the 'encryptMyData()' javascript function is calling an ajax call to take whatever the user entered in the first textfield, encrypt it using rijndael, and paste it in the encryptedText textarea so that it is stored in the database later.</p>

<p>Now what I need to do is this, find a way to convert the carriage returns before encryption to a tag like so <code>[cr]</code> so that when I retrieve the data, all formatting is retained. Any idea how I do this? I'm using asp.net and c# to perform the encryption.</p>
","<p>You can use the <a href=""http://www.w3schools.com/jsref/jsref_escape.asp"" rel=""nofollow noreferrer"">JavaScript <code>escape()</code> method</a> to take care of the carriage returns and spaces. Server-side you need to unescape the sequence again, but there is no default unescape method present in C#. You could try using the <a href=""http://kseesharp.blogspot.com/2008/01/c-equivalent-of-javascript-escape.html"" rel=""nofollow noreferrer"">unescape method in the <code>Microsoft.JScript.GlobalObject</code> namespace</a>.</p>
","599","<c#><asp.net><javascript><forms><rijndael>","0","1","3","2010-04-09 15:53:34","2606642","2","","","","","2010-04-09 10:20:04",""
"2606578","How can I retain carriage returns when I'm encrypting data?","<p>I have this following setup, a textarea named with some data in it that may have carriage returns and another textarea that has <code>style='display:none'</code> in order to make it hidden as follows:</p>

<pre><code>&lt;textarea id=""myTextarea"" onBlur=""encryptMyData()""&gt;&lt;/textarea&gt;
&lt;textarea name=""encryptedText"" style='display:none'&gt;&lt;/textarea&gt;
</code></pre>

<p>the user enters data in the first textarea and when that text area loses focus the 'encryptMyData()' javascript function is calling an ajax call to take whatever the user entered in the first textfield, encrypt it using rijndael, and paste it in the encryptedText textarea so that it is stored in the database later.</p>

<p>Now what I need to do is this, find a way to convert the carriage returns before encryption to a tag like so <code>[cr]</code> so that when I retrieve the data, all formatting is retained. Any idea how I do this? I'm using asp.net and c# to perform the encryption.</p>
","<p>Your newline characters are likely still present in the encrypted data.</p>

<p>If you absolutely do want to ""display"" the encrypted data with newlines retained, you likely need to do a <code>stringData.Split(Environment.NewLine)</code>, encrypt each resulting string separately, then <code>String.Join(Environment.NewLine, arrayOfEncryptedDataLines)</code> the strings back together before returning to the webpage.</p>

<p>-edit-</p>

<p>You might be better off not going by the server, though. Have a look at <a href=""http://www.hanewin.net/encrypt/aes/aes.htm"" rel=""nofollow noreferrer"">http://www.hanewin.net/encrypt/aes/aes.htm</a> </p>
","599","<c#><asp.net><javascript><forms><rijndael>","0","2","3","2010-04-09 15:53:34","2606642","2","","","","","2010-04-09 10:20:04",""
"2606578","How can I retain carriage returns when I'm encrypting data?","<p>I have this following setup, a textarea named with some data in it that may have carriage returns and another textarea that has <code>style='display:none'</code> in order to make it hidden as follows:</p>

<pre><code>&lt;textarea id=""myTextarea"" onBlur=""encryptMyData()""&gt;&lt;/textarea&gt;
&lt;textarea name=""encryptedText"" style='display:none'&gt;&lt;/textarea&gt;
</code></pre>

<p>the user enters data in the first textarea and when that text area loses focus the 'encryptMyData()' javascript function is calling an ajax call to take whatever the user entered in the first textfield, encrypt it using rijndael, and paste it in the encryptedText textarea so that it is stored in the database later.</p>

<p>Now what I need to do is this, find a way to convert the carriage returns before encryption to a tag like so <code>[cr]</code> so that when I retrieve the data, all formatting is retained. Any idea how I do this? I'm using asp.net and c# to perform the encryption.</p>
","<p>Basically the AJAX call to your service is probably stripping out the new lines, so you'll need to do the conversion <em>before</em> you call the web service.</p>

<p>In your <code>encryptMyData</code> function perform a replace before you send it the server:</p>

<pre><code>// assuming sometext contains the contents of myTextarea
// Perform a global replace for all occurrences of a new line with [CR]:
sometext = sometext.replace(/\n/g, ""[CR]"");
</code></pre>

<p>Then pass sometext to the ajax call, rather than the straight value of the textarea.</p>
","599","<c#><asp.net><javascript><forms><rijndael>","0","0","3","2010-04-09 15:53:34","2606642","2","","","","","2010-04-09 10:20:04",""
"2446267","I need to encrypt the names of my http form elements","<p>I have a form with certain elements, input boxes, check boxes etc. I need to encrypt the names of these input boxes and check boxes. I'm currently using a Rijndael encryption/decryption method through c# however this is making the encrypted names too long to be passed in a post. Is there a better way to get decent encrypted names? my purpose is to have the names encrypted before the post happens so if someone views the code behind the names are already encrypted.</p>
","<p>You might be better of mapping the names to random values on them server-side.</p>

<pre><code>[lkjgh] = 'username';
[hjsaf] = 'email';
</code></pre>

<p>If you remap on every request, looking at the code will not reveal anything of value.</p>

<p>Still makes me wonder, why this requirement? Usually, SSL prevents eavesdropping just fine.</p>
","594","<c#><asp.net><http><encryption><rijndael>","-1","0","3","2010-03-15 10:59:17","2446558","5","","","","","2010-03-15 10:06:19",""
"2446267","I need to encrypt the names of my http form elements","<p>I have a form with certain elements, input boxes, check boxes etc. I need to encrypt the names of these input boxes and check boxes. I'm currently using a Rijndael encryption/decryption method through c# however this is making the encrypted names too long to be passed in a post. Is there a better way to get decent encrypted names? my purpose is to have the names encrypted before the post happens so if someone views the code behind the names are already encrypted.</p>
","<p>If you worry about the possibility that someone relates the input name with what the value it carries is, why not just use guids instead of meaningful variable names?</p>
","594","<c#><asp.net><http><encryption><rijndael>","-1","0","3","2010-03-15 10:59:17","2446558","5","","","","","2010-03-15 10:06:19",""
"2446267","I need to encrypt the names of my http form elements","<p>I have a form with certain elements, input boxes, check boxes etc. I need to encrypt the names of these input boxes and check boxes. I'm currently using a Rijndael encryption/decryption method through c# however this is making the encrypted names too long to be passed in a post. Is there a better way to get decent encrypted names? my purpose is to have the names encrypted before the post happens so if someone views the code behind the names are already encrypted.</p>
","<p>Just what do you intend to accomplish by doing this?</p>

<ul>
<li><p>It's not going to stop anyone from analyzing the form or submitting spoofed data.  If they look at the page source and see <code>&lt;p&gt;Email: &lt;input type='text' name='skhge,f'&gt;&lt;/p&gt;</code>, then it's going to be quite clear to them that ""skhge,f"" is the name of the email field, so they can just submit spoofed data under that name instead of ""email"".</p></li>
<li><p>One of your responses to comments on    the question seems to imply that    you're concerned about the form being    intercepted as it is sent to the    user.  If so, use SSL.  It encrypts    traffic in both directions, so you're    covered against any interception that    way, while just hiding the field    names would provide no protection at    all.  (My first point applies equally    to an eavesdropper as to the final    intended recipient of the data.)</p></li>
<li><p>The only possible scenario I can    think of where this might be of any    benefit is if you're worried about    someone building a bot to submit    forms to you, but, even then, it's    the wrong approach - if you're    encrypting the field names, then    they'll remain the same every time    you send the form, so the bot will    just be written to submit ""skhge,f""    every time instead of ""email"".</p>

<p>To foil a bot in this way, you'd need to submit random field names with every form, not encrypted names, and your responses to the suggestion of using a GUID indicate that you don't want to maintain a 'field name -> meaning' map for every form sent out.  Maintaining such a map is the only thing that would slow down a bot writer and, well, even that wouldn't slow them down much.  Unless you take exceptional measures to obfuscate your form layout and text content (such as those used by spammers in their attempts to slip HTML mail through spam filters), it would be easy for me, as a bot writer, to request a blank form prior to submission and correlate the textual labels presented to the user (e.g., the user-visible text ""Email:"") with the corresponding input field and obtain the correct field name (""skhge,f"") that way.</p></li>
</ul>

<p>So I'm not quite sure what your intended purpose is, but I <em>am</em> 99% certain that encrypting field names will not be the best way to do it - if it would even work at all.</p>
","594","<c#><asp.net><http><encryption><rijndael>","-1","4","3","2010-03-15 10:59:17","2446558","5","","","","","2010-03-15 10:06:19",""
"19734678","Rijndael AES, addRoundKey, xor hex strings and store them as bytes","<pre><code>/*keyArray contains a line of cipherkey, and inputArray contains a text that is being encrypted.*/
public static void addRoundKey() {
        String keyEle = """";
        String inputEle = """";
        String result = """";
        for(int col=0; col&lt;4; col++) {
            for(int row = 0; row&lt;4; row++) {                
                keyEle = Integer.toHexString(keyArray[row][col] &amp; 0xff);
                inputEle = Integer.toHexString(inputArray[row][col] &amp; 0xff);
                if(keyEle.equals(""0"")) {
                    keyEle = ""00"";
                }
                if(inputEle.equals(""0"")) {
                    inputEle = ""00"";
                }
                BigInteger keyNum = new BigInteger(keyEle,16);
                BigInteger inputNum = new BigInteger(inputEle, 16);
                result = keyNum.xor(inputNum).toString();
                System.out.println(""result = "" + result);
                keyArray[row][col] = Byte.valueOf(result, 16); 
                //The above line causes Exception in thread ""main"" java.lang.NumberFormatException: Value out of range. Value:""99"" Radix:16`

                //keyArray[row][col]  = (byte) (Integer.parseInt(result) &amp; 0xff);           
            }
        }
    }
</code></pre>

<p>I think addRoundKey step takes a column from each of cipher key and text that I am trying to encrypt, and then xor them, right?</p>

<p>So, that's my implementation, I understand why ""value out of range"" error occurs, it's because byte takes numbers that range from -128 to 127, right?</p>

<p>But I am not so sure how to fix it. I can't change the type of keyArray, which is Byte. </p>
","<p>Change line </p>

<pre><code>keyArray[row][col] = Byte.valueOf(result, 16);
</code></pre>

<p>to </p>

<pre><code>keyArray[row][col] = (byte) Integer.valueOf(result, 16).intValue();
</code></pre>

<p><strong>edit</strong> <br>
or even shorter, as correctly stated in Bohemian's answer :</p>

<pre><code>keyArray[row][col] = (byte) Integer.parseInt(result, 16);
</code></pre>
","590","<java><byte><aes><rijndael>","0","1","2","2013-11-02 21:33:42","19735255","2","","1658855","","2013-11-01 20:19:06","2013-11-01 20:14:04",""
"19734678","Rijndael AES, addRoundKey, xor hex strings and store them as bytes","<pre><code>/*keyArray contains a line of cipherkey, and inputArray contains a text that is being encrypted.*/
public static void addRoundKey() {
        String keyEle = """";
        String inputEle = """";
        String result = """";
        for(int col=0; col&lt;4; col++) {
            for(int row = 0; row&lt;4; row++) {                
                keyEle = Integer.toHexString(keyArray[row][col] &amp; 0xff);
                inputEle = Integer.toHexString(inputArray[row][col] &amp; 0xff);
                if(keyEle.equals(""0"")) {
                    keyEle = ""00"";
                }
                if(inputEle.equals(""0"")) {
                    inputEle = ""00"";
                }
                BigInteger keyNum = new BigInteger(keyEle,16);
                BigInteger inputNum = new BigInteger(inputEle, 16);
                result = keyNum.xor(inputNum).toString();
                System.out.println(""result = "" + result);
                keyArray[row][col] = Byte.valueOf(result, 16); 
                //The above line causes Exception in thread ""main"" java.lang.NumberFormatException: Value out of range. Value:""99"" Radix:16`

                //keyArray[row][col]  = (byte) (Integer.parseInt(result) &amp; 0xff);           
            }
        }
    }
</code></pre>

<p>I think addRoundKey step takes a column from each of cipher key and text that I am trying to encrypt, and then xor them, right?</p>

<p>So, that's my implementation, I understand why ""value out of range"" error occurs, it's because byte takes numbers that range from -128 to 127, right?</p>

<p>But I am not so sure how to fix it. I can't change the type of keyArray, which is Byte. </p>
","<p>You are getting an error parsing ""99"" as a <code>byte</code> using base 16, which may be paraphrased as:</p>

<pre><code>byte b = Byte.valueOf(""99"", 16);
</code></pre>

<p>because <code>byte</code> is <em>signed</em>, with valid range -128 to 127, but you are </p>

<p>First parse it as an Integer, using Integer.parseInt(), then convert it to a signed byte, eg:</p>

<pre><code>keyArray[row][col] = (byte)Integer.parseInt(result, 16);
</code></pre>
","590","<java><byte><aes><rijndael>","0","1","2","2013-11-02 21:33:42","19735255","2","","1658855","","2013-11-01 20:19:06","2013-11-01 20:14:04",""
"35926565","Why is this AES encryption code always returning a different cipher text?","<blockquote>
  <h3>Note:</h3>
  
  <p>The following code sample is for demonstration purposes only and implements an insecure scheme. If you are looking for a secure scheme have a look at <a href=""https://stackoverflow.com/a/10177020/40347"">https://stackoverflow.com/a/10177020/40347</a> </p>
</blockquote>

<p>I am using the AESCryptoServiceProvider class for testing some encryption concepts. So far in all the examples and articles out there they generate a random key to use for encryption and then immediately for decryption. Sure, it works fine because you are using the key right there, but if you encrypt, save the text and at a later time you want to decrypt it you will need the SAME key. And for that purpose also the same IV.</p>

<p>Now, in this code I am using the same key and IV on multiple passes, every time I run the batch that batch gives the same result (as expected). But then I close the test application and rerun the same code without change and the resulting (Base64-encoded) cypher text is different for the same input parameters, why?</p>

<p>I ""saved"" one of the B64-encoded cyphers from a previous run and fed it to the TestDecrypt method and as expected, it threw a cryptographic exception mentioning something about padding though I am sure it has to do with the fact that somehow for the same Key,IV, plain text and parameters it gives a different result on every separate run of the application.</p>

<p>For encrypting I have this:</p>

<pre><code>    public string Test(string password, Guid guid, string text)
    {
        const int SaltSize = 16;

        string b64Cryptogram;
        MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();
        Rfc2898DeriveBytes pwbytes = new Rfc2898DeriveBytes(password, SaltSize);

        // Block 128-bits Key 128/192/256 bits (16/24/32 bytes)
        using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())
        {
            aes.Padding = PaddingMode.PKCS7;
            aes.Mode = CipherMode.CBC;
            //aes.IV = pwbytes.GetBytes(aes.BlockSize / 8);
            aes.IV = md5.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password));
            aes.Key = guid.ToByteArray();

            ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {

                        //Write all data to the stream.
                        swEncrypt.Write(text);
                    }
                    b64Cryptogram = Convert.ToBase64String(msEncrypt.ToArray());
                }
            }
            Console.WriteLine(""E: {0}"", b64Cryptogram);
            aes.Clear();
        }
        return b64Cryptogram;
    }
</code></pre>

<p>Notice I am not using the RFC2898DeriveBytes because it will randomly derive something I will no longer remember :) The idea of encrypting it is precisely that I KNOW what I used to encrypt it.</p>

<p>The decryption method looks like this:</p>

<pre><code>    public void TestDecrypt(string password, Guid guid, string ciphertextB64)
    {
        const int SaltSize = 16;

        byte[] cipher = Convert.FromBase64String(ciphertextB64);
        string plaintext;

        MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();
        Rfc2898DeriveBytes pwbytes = new Rfc2898DeriveBytes(password, SaltSize);

        // Block 128-bits Key 128/192/256 bits (16/24/32 bytes)
        using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())
        {
            aes.Padding = PaddingMode.PKCS7;
            aes.Mode = CipherMode.CBC;
            //aes.IV = pwbytes.GetBytes(aes.BlockSize / 8);
            aes.IV = md5.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password));
            aes.Key = guid.ToByteArray();

            ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
            using (MemoryStream msEncrypt = new MemoryStream(cipher))
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader swEncrypt = new StreamReader(csEncrypt))
                    {
                        plaintext = swEncrypt.ReadToEnd();
                    }
                }
            }
            Console.WriteLine(""D: {0}"", plaintext);
            aes.Clear();
        }
    }
</code></pre>

<p>Now, just put that in a console application and run it. Then exit and run it again and you will see that for the same Mode, Padding, IV, Key and plain text data, the output cipher will not be the same on every application run. They will be the same provided you run the method repeatedly in the same run of the application.</p>

<p>In case it was not obvious, here is the console code I used to test:</p>

<pre><code>        Guid guid = Guid.NewGuid();
        string plain = ""Text to be encrypted 123458970"";
        string password = ""This is a test of the emergency broadcast system"";

        TestDecrypt(password, guid, Test(password, guid, plain));
        TestDecrypt(password, guid, Test(password, guid, plain));
        Test(password, guid, plain);
        Test(password, guid, plain);
        Test(plain, guid, password);
        TestDecrypt(password, guid, ""W4Oi0DrKnRpxFwtE0xVbYJwWgcA05/Alk6LrJ5XIPl8="");
    }    
</code></pre>
","<p>The solution here is to pull in from a stored or constant <code>Guid</code>. Calling </p>

<pre><code>Guid.NewGuid();
</code></pre>

<p>will return a different result every time. From the docs:</p>

<blockquote>
  <blockquote>
    <p><sup>This is a convenient static method that you can call to get a new Guid. The method wraps a call to the Windows CoCreateGuid function. The returned Guid is guaranteed to not equal Guid.Empty.</sup></p>
  </blockquote>
</blockquote>

<p>Alternatively when testing you can use Guid.Empty which will return all zeroes.</p>

<p>Or, you can store it as such using its string constructor overload:</p>

<pre><code>var guid = new Guid(""0f8fad5b-d9cb-469f-a165-70867728950e"");
</code></pre>
","584","<c#><encryption><aes><encryption-symmetric><rijndael>","0","2","1","2016-03-14 12:08:52","","13","","-1","","2017-05-23 12:23:48","2016-03-10 20:25:59",""
"16703247","encrypt ASP(Rijndael), Descrypt in php","<p>I have a code in ASP, but I dont know encrypt in php and compare the password encrypted.</p>

<p>My library is:</p>

<pre><code>   using System.Security.Cryptography;

    // Encrypt a string into a string using a password 

    //    Uses Encrypt(byte[], byte[], byte[]) 

    public string Encrypt(string clearText, string Password)
    {

        // First we need to turn the input string into a byte array. 

        byte[] clearBytes = System.Text.Encoding.Unicode.GetBytes(clearText);



        // Then, we need to turn the password into Key and IV 

        // We are using salt to make it harder to guess our key using a dictionary attack - 

        // trying to guess a password by enumerating all possible words. 

        PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,

                    new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });



        // Now get the key/IV and do the encryption using the function that accepts byte arrays. 

        // Using PasswordDeriveBytes object we are first getting 32 bytes for the Key 

        // (the default Rijndael key length is 256bit = 32bytes) and then 16 bytes for the IV. 

        // IV should always be the block size, which is by default 16 bytes (128 bit) for Rijndael. 

        // If you are using DES/TripleDES/RC2 the block size is 8 bytes and so should be the IV size. 

        // You can also read KeySize/BlockSize properties off the algorithm to find out the sizes. 

        byte[] encryptedData = Encrypt(clearBytes, pdb.GetBytes(32), pdb.GetBytes(16));



        // Now we need to turn the resulting byte array into a string. 

        // A common mistake would be to use an Encoding class for that. It does not work 

        // because not all byte values can be represented by characters. 

        // We are going to be using Base64 encoding that is designed exactly for what we are 

        // trying to do. 

        return Convert.ToBase64String(encryptedData);

    }
</code></pre>

<p>and php code is:</p>

<pre><code>function fnEncrypt($Word, $key){

    $iv = mcrypt_create_iv( mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND );

    if (strlen($iv_base64 = rtrim(base64_encode($iv), '=')) != 22) return false;

    $encrypted = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $Word . md5($Word), MCRYPT_MODE_CBC, $iv));

    return $iv_base64 . $encrypted;
}
</code></pre>

<p>or I tried use this code in php: </p>

<pre><code>function Encrypt($pass, $salt){

    $derived = PBKDF1($pass, $salt, 100, 32);
    $key = bin2hex(substr($derived, 0, 32));
    $iv = bin2hex(substr($derived, 32, 16));
    return mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $pass, MCRYPT_MODE_CBC, $iv);
}
function PBKDF1($pass, $salt, $count, $dklen)
{
     $t = sha1($pass.$salt);
    for($i=1; $i &lt;= $count; $i++)
    {
        $t = sha1($t);
    }
    $t = substr($t,0,$dklen-1);
    return $t;
}
</code></pre>

<p>but not working, I hope I can help.</p>

<p>Excuse me for my bad english</p>
","","582","<encryption><rijndael>","1","","0","2013-05-22 23:31:26","","13","","","","","2013-05-22 23:31:26",""
"34256183","How to properly encrypt string in C# using rijndael and password","<p>Ok, so I've done some research and I think that I've found an answer:</p>

<ul>
<li>Use password and salt to create fitting key.</li>
<li>Generate random IV</li>
<li>Use RijndaelManaged class to encrypt a string</li>
<li>set first 16 bytes of output to IV in plaintext followed by the actual encrypted data</li>
</ul>

<p>the whole thing is in this class:</p>

<pre><code>public class AesEncrypt : IDisposable
    {
        /// &lt;summary&gt;
        /// Lenght of &lt;see cref=""RijndaelManaged.IV""/&gt;. Bytes of this lenght are
        /// prepended to every encryped string and contain IV itself
        /// &lt;/summary&gt;
        private int IVSize =&gt; _rijndael.BlockSize / 8;

        /// &lt;summary&gt;
        /// Instantialzes new &lt;see cref=""AesEncrypt""/&gt; class
        /// &lt;/summary&gt;
        /// &lt;param name=""key""&gt;password protecting the string&lt;/param&gt;
        /// &lt;param name=""salt""&gt;salt which is used to hash password&lt;/param&gt;
        public AesEncrypt(string key, byte[] salt)
        {
            if (key == null) throw new ArgumentNullException(nameof(key));
            if (salt == null) throw new ArgumentNullException(nameof(salt));
            if (salt.Length == 0) throw new ArgumentException(""Argument is empty collection"", nameof(salt));

            Salt = salt;
            _rijndael = new RijndaelManaged { Key = GetKey(key) };
        }

        /// &lt;summary&gt;
        /// Salt used to hash password to generate &lt;see cref=""RijndaelManaged.Key""/&gt; to be used
        /// &lt;/summary&gt;
        public byte[] Salt { get; }

        private readonly RijndaelManaged _rijndael;

        /// &lt;summary&gt;
        /// Generates key from password of any lenght and hash. Key is 256bit long.
        /// &lt;/summary&gt;
        /// &lt;param name=""password""&gt;Any password&lt;/param&gt;
        /// &lt;returns&gt;Key of fixed size 256bit&lt;/returns&gt;
        protected byte[] GetKey(string password)
        {
            int keyLength = 32;//

            using (var pbkdf = new Rfc2898DeriveBytes(password, Salt))
            {
                return pbkdf.GetBytes(keyLength);
            }
        }
        protected ICryptoTransform GetEncryptor()
        {
            return _rijndael.CreateEncryptor();
        }
        protected ICryptoTransform GetDecryptor()
        {
            return _rijndael.CreateDecryptor(_rijndael.Key, _rijndael.IV);
        }

        /// &lt;summary&gt;
        /// Encrypts string to bytes using 256bit Rijndael. IV of size &lt;see cref=""IVSize""/&gt; occupies first bytes.
        /// &lt;/summary&gt;
        /// &lt;param name=""plainText""&gt;Text to be encoded&lt;/param&gt;
        /// &lt;returns&gt;Cipher in bytes&lt;/returns&gt;
        public byte[] Encrypt(string plainText)
        {
            if (plainText == null) throw new ArgumentNullException(nameof(plainText));

            _rijndael.GenerateIV();
            var encryptor = GetEncryptor();

            // Create the streams used for encryption.
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(plainText);
                    }
                    //result without prepended IV
                    byte[] encBytes = msEncrypt.ToArray();

                    #region prepend IV to the beginning of bytes
                    byte[] result = new byte[encBytes.Length + IVSize];
                    for (int i = 0; i &lt; IVSize; i++)
                    {
                        //write IV to the beginning
                        result[i] = _rijndael.IV[i];
                    }
                    #endregion

                    for (int i = 0; i &lt; encBytes.Length; i++)
                    {
                        //index to be written to
                        int index = i + IVSize;
                        result[index] = encBytes[i];
                    }

                    return result;
                }
            }
        }
        /// &lt;summary&gt;
        /// Decrypt a cipher made by &lt;see cref=""Encrypt""/&gt; with known &lt;see cref=""Salt""/&gt; and password.
        /// &lt;/summary&gt;
        /// &lt;param name=""cipher""&gt;Cipher to be decrypted.&lt;/param&gt;
        /// &lt;returns&gt;Decrypted string&lt;/returns&gt;
        public string Decrypt(byte[] cipher)
        {
            if (cipher == null) throw new ArgumentNullException(nameof(cipher));
            if (cipher.Length &lt; IVSize + 1) throw new ArgumentException($""Argument must be {IVSize + 1} bytes long at least!"", nameof(cipher));

            #region read first IVSize bytes which are IV
            byte[] iv = new byte[IVSize];
            for (int i = 0; i &lt; IVSize; i++)
            {
                iv[i] = cipher[i];
            }
            _rijndael.IV = iv;
            #endregion

            //actual bytes to be decrypted
            byte[] encBytes = new byte[cipher.Length - IVSize];
            for (int i = 0; i &lt; encBytes.Length; i++)
            {
                //index to be read from
                int index = i + IVSize;
                encBytes[i] = cipher[index];
            }

            // Create a decrytor to perform the stream transform.
            var decryptor = GetDecryptor();

            // Create the streams used for decryption.
            using (MemoryStream msDecrypt = new MemoryStream(encBytes))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {
                        // Read the decrypted bytes from the decrypting stream
                        // and place them in a string.
                        return srDecrypt.ReadToEnd();
                    }
                }
            }
        }

        public void Dispose()
        {
            _rijndael?.Dispose();
        }
    }
</code></pre>

<p>It works, but I just want to ask this:</p>

<ul>
<li>is it safe?</li>
<li>How do I identify an incorrect password? </li>
</ul>

<p>Concerning wrong password detection I thought of writing the hash of original string after the IV, but which algorithm use then for hashing?</p>
","","578","<c#><encryption><passwords><rijndael>","0","","0","2015-12-13 20:51:03","","2","","","","","2015-12-13 20:51:03",""
"23876585","Breaking Rfc2898DeriveBytes key with input password but without salt","<p>I am using C# RijndaelManaged class for AES encryption. The key and IV are generated from input password and salt using Rfc2898DeriveBytes class. My question is, how difficult would it be to break encryption if someone obtained input password but not the salt?</p>
","<p>It would be close to impossible to retrieve the key and IV. Actually, sometimes a static, secret salt stored in source code is used <em>in addition</em> to the public random salt. In that way an attacker is required to get the source or runtime code in addition to the database with the salts and password hashes.</p>

<p>This kind of scheme <em>does</em> require a large enough (secret) salt, say 128 bytes. It would be best to use concatenation to create the combined public and secret salt.</p>

<p>Of course, it is always possible to mess up the encryption otherwise, e.g. by being vulnerable to padding oracle attacks, forgetting an authentication tag (HMAC) in addition to encryption, etc. etc. etc.</p>
","569","<.net><aes><rijndael><rijndaelmanaged><rfc2898>","0","0","1","2014-05-27 00:21:49","","3","","1442776","","2014-05-26 20:29:03","2014-05-26 19:28:29",""
"23795601","Encoding is producing different hashes each time","<p>I have the following structure which I am using for my <code>Encrypt</code> function. I'm possibly missing something from the structure in my code as I'm a PHP guy rather than a C#.</p>

<p>What's happening is that each time in my log the hash changes, which it shouldn't and should only equal one specific hash for the input. This ties in with this next issue..</p>

<p>What also happens is when I use my test passphrase, which is ""MysecretPassPhrase"", I have a byte length issue. <em>I don't want to change this passphrase as it is the exact length of my true passphrase</em> so is there anything I can do code-wise to fix the issue?</p>

<p>When I used a longer passphrase such as ""MysecretPassPhrase123456"" with ""David"" as the input, it will output the different hashes each time: CJ+mgAeL9x+qMLId+nHvXw==, Ladj1D+LJgZCrwPatsQsEQ==, etc.</p>

<p><strong>Structure required</strong></p>

<ul>
<li>Cipher Rijndael (AES) </li>
<li>Block Size 128 bits (16 bytes) </li>
<li>Mode CBC (Cipher Block Chaining) </li>
<li>Key MD5 hash passphrase</li>
<li>IV Same as the key </li>
<li>Data Encoding Base64 </li>
<li>Character UTF-8 Encoding</li>
</ul>

<p><strong>Error</strong></p>

<p><code>CryptographicException: Key size not supported by algorithm
System.Security.Cryptography.SymmetricAlgorithm.set_Key (System.Byte[] value) (at /Users/builduser/buildslave/monoAndRuntimeClassLibs/build/mcs/class/corlib/System.Security.Cryptography/SymmetricAlgorithm.cs:176)
APIConnector.Encrypt (System.String toEncrypt) (at Assets/APIConnector.cs:59)</code></p>

<p><strong>Code</strong></p>

<pre><code>using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using System.Xml;
using System.IO;

void submit() {
  Debug.Log (""first name is: "" + firstName + "" encrypted is: "" + Encrypt(firstName));
}


public static string Encrypt (string toEncrypt) {
  byte[] keyArray = UTF8Encoding.UTF8.GetBytes (""MysecretPassPhrase"");
  // 256-AES key
  int numBytes = System.Text.Encoding.UTF8.GetBytes(toEncrypt).Length;
  Debug.Log (""Bytes: "" + numBytes);
  byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes (toEncrypt);
  RijndaelManaged rDel = new RijndaelManaged ();
  rDel.Key = keyArray;
  rDel.BlockSize = 128;
  rDel.Mode = CipherMode.CBC;
  // http://msdn.microsoft.com/en-us/library/system.security.cryptography.ciphermode.aspx
  rDel.Padding = PaddingMode.PKCS7;
  // better lang support
  ICryptoTransform cTransform = rDel.CreateEncryptor ();
  byte[] resultArray = cTransform.TransformFinalBlock (toEncryptArray, 0, toEncryptArray.Length);
  return Convert.ToBase64String (resultArray, 0, resultArray.Length);
}
</code></pre>
","<p>The error given above is ""Key size not supported by algorithm"".  Your key array is 18 bytes (UTF8) which is 144 bits, not 128 bits as indicated by your BlockSize. </p>

<p>You must change the key to a valid size.  <a href=""https://stackoverflow.com/questions/2919228/specified-key-is-not-a-valid-size-for-this-algorithm"">See this article for more information.</a>  </p>
","562","<c#><rijndael><rijndaelmanaged>","1","0","1","2014-05-21 23:55:05","23795702","7","","2454353","","2014-05-21 23:50:43","2014-05-21 23:41:35",""
"12088602",".NET Rijndael encryption key too large?","<p>I have received a SQL server database with passwords. This database is coming from a .NET website. I am rebuilding the website to PHP, so I would like to use my own encryption algorithm for the passwords. To do so, I tried to decrypt the passwords from the source database, but have not succeeeded so far.</p>

<p>According to the original developer it uses Rijndael encryption. The keys were as blob fields in the database. I exported them and tried to use PHP to decrypt the passwords. I have not succeeded but read somewhere on Stack overflow that there are difference in the way PHP and .NET implements it. This can only be fixed by changing the way of encrypting in .NET, but that's not an option.</p>

<p>So next thing I tried is to create a small .NET web form to decode the passwords. For a test I use this code:</p>

<pre><code>var iv = Encoding.UTF8.GetBytes(""5F38D2742EFC59486F6CBDDAB3E46EC5"");
var key = Encoding.UTF8.GetBytes(""F88640BE83A6911472BA4AF9B9C37E2C2B3E78BCFECF4BC6ADE1E928441F6AD7"");

var rijndael = new RijndaelManaged
{
    BlockSize = 256,
    IV = iv,
    KeySize = 256,
    Key = key
};
rijndael.Padding = PaddingMode.None;
var buffer = Convert.FromBase64String(""D1jo49HH6cL4kZVVeIDyDbJGtO4+f2N9YIonOqRg6hM="");
var transform = rijndael.CreateDecryptor();
string decrypted;
using (var ms = new MemoryStream())
{
    using (var cs = new CryptoStream(ms, transform, CryptoStreamMode.Write))
    {
        cs.Write(buffer, 0, buffer.Length);
        cs.FlushFinalBlock();
        decrypted = Encoding.UTF8.GetString(ms.ToArray());
        cs.Close();
    }
    ms.Close();
}
Label1.Text = decrypted;
</code></pre>

<p>I have altered the keys by the way, but the number of characters are still the same. Apperantly the key is 512bits in size instead of 256bits. But that is not supported by Rijndael. When I take away half of the key it doesn't generate any errors, but of course, doesn't give me the correct password.</p>

<p>Now I noticed the key is in hexadecimal characters. I tried to convert it using a web tool like <a href=""http://www.string-functions.com/hex-string.aspx"" rel=""nofollow"">http://www.string-functions.com/hex-string.aspx</a>, but that does not give me a valid string (just some strange characters. So I'm not sure if this has anything to do with it, but if so, how to convert it?</p>
","<p>The error is in these two lines:</p>

<pre><code>var iv = Encoding.UTF8.GetBytes(""5F38D2742EFC59486F6CBDDAB3E46EC5"");
var key = Encoding.UTF8.GetBytes(""F88640BE83A6911472BA4AF9B9C37E2C2B3E78BCFECF4BC6ADE1E928441F6AD7"");
</code></pre>

<p>What you have in your string literals appears to be hex strings. These should be decoded by taking each pair of characters in turn and converting those into a <code>byte</code>. Unfortunately, there's no built in function in the .NET framework to do this, but the question <a href=""https://stackoverflow.com/questions/311165/how-do-you-convert-byte-array-to-hexadecimal-string-and-vice-versa-in-c"">How do you convert Byte Array to Hexadecimal String, and vice versa, in C#</a> should contain some useful hints to achieving this.</p>

<p>Your current code, instead, will take each character, in turn, and compute one or more (okay, in this case, always one) <code>byte</code> values that is the UTF8 value for that character.</p>

<p>These are two very different operations, but the difference in how the characters are/should be consumed is why you are getting double the number of bytes compared to what you were expecting to receive.</p>
","558","<.net><encryption><webforms><key><rijndael>","0","1","1","2012-08-24 06:24:09","12104156","4","","","","","2012-08-23 09:25:45",""
"8862456","Output is invalid","<p>I have a PHP program that encrypts a PDF file into .xxx file this output is being read by a C# program that decrypts this .xxx file back into PDF file.</p>

<p>My problem is that when I open the file decrypted by C# , the PDF reader tells me that the file is corrupted .. when I encrypt plain text in PHP and decrypt on C# I got the file I encrypted .. so the problem is appearing only in PDF files or in other words it appears in <strong>BINARY</strong> files </p>

<p>any suggestions ?!</p>

<p>Notes:</p>

<ol>
<li>In PHP I use mcrypt extension Rijndael algorithm CBC PKCS7 padding (padding is done manually)</li>
<li>In C# I use RijndaelManaged class to encrypt and decrypt data</li>
</ol>

<p><strong>Edit</strong>:</p>

<p>Here is encryption method that I use in PHP:</p>

<pre><code>    function encrypt($key, $iv, $text) {
        ini_set ( 'memory_limit', '-1' );
        $mcrypt_cipher = MCRYPT_RIJNDAEL_256;
        $mcrypt_mode = MCRYPT_MODE_CBC;
        $text=addpadding($text,mcrypt_get_block_size($mcrypt_cipher,'cbc'));
        $encrypted = rtrim ( mcrypt_encrypt ( $mcrypt_cipher, $key, $text, $mcrypt_mode, $iv ), ""\0"" );
        $encrypted = base64_encode ( $encrypted );
        return $encrypted;
    }
</code></pre>

<p>And here is the decryption method in C#:</p>

<pre><code>    public static string DecryptString(string message, string KeyString, string IVString)
    {
        byte[] Key = Encoding.UTF8.GetBytes(KeyString);
        byte[] IV = Encoding.UTF8.GetBytes(IVString);

        string decrypted = null;
        RijndaelManaged rj = new RijndaelManaged();
        rj.BlockSize = 256;
        rj.Key = Key;
        rj.IV = IV;
        rj.Mode = CipherMode.CBC;
        rj.Padding = PaddingMode.PKCS7;
        try
        {
            MemoryStream ms = new MemoryStream();
            //Encoding enc = new UTF8Encoding();
            byte[] messageBytes = Convert.FromBase64String(message);
            using (CryptoStream cs = new CryptoStream(ms, rj.CreateDecryptor(Key, IV), CryptoStreamMode.Write))
            {
                //byte[] messageBytes = enc.GetBytes(message);

                cs.Write(messageBytes, 0, messageBytes.Length);
                cs.Close();
            }
            byte[] encoded = ms.ToArray();
            decrypted = Encoding.UTF8.GetString(encoded);

            ms.Close();
        }
        catch (Exception e)
        {
            MessageBox.Show(""An error occurred:""+ e.Message);
        }
        finally
        {
            rj.Clear();
        }

        return decrypted;
    }
</code></pre>

<p>and here is how I call the decrypt in C# and how I write output:</p>

<pre><code>                string Key = cryptography.MD5(""X-Ware"" + cryptography.MD5(""123""));
                string IV = cryptography.MD5(""XWare"");
                string decrypted = cryptography.DecryptString(contents, Key, IV);
                string outputFilename = cryptography.MD5(OFD.FileName) + "".tmp"";

                StreamWriter sw = new StreamWriter(""C:\\Windows\\Temp\\"" + outputFilename, false, Encoding.UTF8);
                BinaryWriter bw = new BinaryWriter(sw.BaseStream, Encoding.UTF8);
                //sw.Write(decrypted);
                bw.Write(decrypted);
                sw.Close();
                bw.Close();
</code></pre>
","<p>I think the problem is that you treat the binary PDF data as text on both the PHP and the C# side. </p>

<pre><code> decrypted = Encoding.UTF8.GetString(encoded);
</code></pre>

<p>makes no sense if <code>encoded</code> represents binary data. You should probably skip this step and define your <code>DecryptString()</code> as returning <code>byte[]</code>. And then rename it too. </p>

<p>If you do want it as a string you might have better luck with ASCII or ANSI encoding:</p>

<pre><code> decrypted = Encoding.ASCII.GetString(encoded);
</code></pre>

<p>but the error may already be happening on the PHP side, I can't tell. </p>

<p>Additional, I just noted:</p>

<pre><code>    StreamWriter sw = new StreamWriter(""C:\\Windows\\Temp\\"" + outputFilename,  
           false, Encoding.UTF8);
    BinaryWriter bw = new BinaryWriter(sw.BaseStream, Encoding.UTF8);
</code></pre>

<p>This is a very over-complicated way to create a BinaryWriter. The Encoding will not be used. And</p>

<pre><code> bw.Write(decrypted);
</code></pre>

<p>This will write the string with a length-prefix, that certainly will make your PDF invalid. </p>

<p>When you keep the return of Decrypt as <code>string</code>, use</p>

<pre><code>  File.WriteAllText(""C:\\Windows\\Temp\\"" + outputFilename, decrypted);
</code></pre>

<p>And when you return it as <code>byte[]</code> (recommended), use</p>

<pre><code> File.WriteAllBytes(""C:\\Windows\\Temp\\"" + outputFilename, decrypted);
</code></pre>
","546","<c#><php><encryption><rijndaelmanaged><rijndael>","2","5","1","2012-01-14 14:10:58","8862663","11","","896244","","2012-01-14 13:43:17","2012-01-14 13:19:23",""
"32462675","Can you encrypt a string in Swift that is exactly like PHP's mcrypt_rijndael_256?","<p>Need to communicate with PHP code that decrypts in <code>MCRYPT_RIJNDAEL_256</code>. Is there any way I can use something exactly like <code>MCRYPT_RIJNDAEL_256</code> in Swift?</p>

<p>Update: It's worth adding that I have been using AES256, because I was under the impression that AES256 and <code>MCRYPT_RIJNDAEL_256</code> were the same thing (I understand now that this is not the case)</p>
","<p>No you cannot, not without using 3rd party libraries. Rijndael 256 is a block cipher with 256 bit block size. Last time I checked the API doesn't contain Rijndael 256 or any other block cipher with that block size, and you cannot force any AES functionality to use a larger block size.</p>
","536","<php><swift><encryption><rijndael>","-1","1","1","2015-09-08 17:20:33","","10","","589259","","2015-09-08 17:10:45","2015-09-08 16:18:06",""
"22645784","CakePHP rijndael cipher puts an empty string in the database","<p>I have a string I want to save into my DB in an encrypted format. I am using the security utility provided by cake so this is the code I use to encrypt my sensitive data:</p>

<pre><code>// get my encryption key
$encrypt_key = Configure::read('Secret.encrypt_key');

// encrpyt this string to be stored in the database
$this-&gt;request-&gt;data['User']['message'] = Security::rijndael($this-&gt;request-&gt;data['User']['message'], $encrypt_key, 'encrypt');

// save this user data
$user_saved = $this-&gt;User-&gt;save( $this-&gt;request-&gt;data[ 'User' ] );
</code></pre>

<p>This looks like ever guide I have seen for how to do this, but in my case all of the other fields will save and I will get an empty field for <code>message</code> </p>

<p>My question is why is this blank database save happening and how do I fix it. Thank you.</p>
","<p>The problem ended up being that the rjindeal function returns a raw binary string <code>010100100010100101111101010010101</code> that my database cannot handle. By simply converting the result to hex code via <code>bin2hex($encrypted_message)</code> the data is transformed into a form that my database can handle.</p>
","531","<php><cakephp><encryption><cakephp-2.3><rijndael>","-1","2","1","2014-03-26 13:50:14","22663026","3","","","","","2014-03-25 20:41:12",""
"14457565","How is it possible that Rijndael returns different result from string and byte[]?","<p>Here is my code, first with string:</p>

<pre><code>byte[] concatBytes = Encoding.ASCII.GetBytes(key);
byte[] keyBytes = Encoding.ASCII.GetBytes(key);
for (int i = 0; i &lt; 3; i++)
{
         concatBytes = Encrypt(Encoding.ASCII.GetString(concatBytes), keyBytes);
         //Console.WriteLine(Transform.Hexa(concatBytes));
} 

public byte[] Encrypt(string plainText, byte[] key)
    {
        byte[] encrypted;
        using (var rijndael = new RijndaelManaged())
        {
            rijndael.Mode = CipherMode.ECB;
            rijndael.KeySize = 128;
            rijndael.BlockSize = 128;
            rijndael.Padding = PaddingMode.Zeros;
            rijndael.Key = key;
            //rijndael.IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

            ICryptoTransform transform = rijndael.CreateEncryptor(rijndael.Key, rijndael.IV);

            using (var memoryStream = new MemoryStream())
            {
                using (var cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Write))
                {
                    using (var streamWriter = new StreamWriter(cryptoStream))
                    {
                        streamWriter.Write(plainText);
                    }
                    encrypted = memoryStream.ToArray();
                }
            }
        }
        return encrypted;
    }
</code></pre>

<p>If i change my method parameter <code>plainText</code> to <code>byte[]</code> than my results are completely different. What am i missing here? Also, we have different results using <code>OpenSSL</code> and <code>Rijndael AES</code> encryption. Any suggestions how i could fix this?</p>
","<p><a href=""http://msdn.microsoft.com/en-us/library/wtbhzte9.aspx"" rel=""nofollow""><code>StreamWriter(Stream)</code></a>: </p>

<blockquote>
  <p>Initializes a new instance of the <a href=""http://msdn.microsoft.com/en-us/library/system.io.streamwriter.aspx"" rel=""nofollow""><code>StreamWriter</code></a> class for the specified stream by using UTF-8 encoding and the default buffer size.</p>
</blockquote>

<p>Since you're using a different encoding (UTF-8 rather than ASCII), it's not surprising that you get different results.</p>
","528","<c#><.net><aes><rijndael><rijndaelmanaged>","0","1","1","2013-01-22 11:37:03","","1","","563088","","2013-01-22 11:37:03","2013-01-22 11:31:37",""
"35757417","Irreducible polynomial in AES and GNU Octave","<p>In the <a href=""http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf"" rel=""nofollow"">Rijndael AES proposal</a> in section 2.1.2 they have chosen m(x) = x^8 + x^4 + x^3 + x + 1 and said it is an irreducible polynomial. This polynomial corresponds to integer 283. </p>

<p>Further in section 4.2.3, they have defined the value of M, the matrix used in <code>MixColumn</code> operation. I was trying to find its multiplicative inverse M⁻¹ in octave. I used the command</p>

<pre><code>y = gf(M, 8, 283)
</code></pre>

<p>And octave gave me the following error:</p>

<blockquote>
  <p>error: <code>gf</code>: primitive polynomial (283) of Galois Field must be irreducible</p>
</blockquote>

<p>Can anyone please help me in explaining why I am getting this error? I have very little knowledge of fields, groups and similar abstract concepts.</p>
","","522","<aes><octave><rijndael><finite-field>","1","","0","2016-03-02 20:28:33","","11","","445517","","2016-03-02 20:28:33","2016-03-02 13:27:28",""
"37182584","How to implement Rijndael (AES) algorithm to encrypt C# Windows Form C# app.config","<p>I'm thinking if it's possible to implement Rijndael algorithm so that it can encrypt the connection string in the app.config file.</p>

<p>For example if I will run the program at first it will automatically change the connection string to an encrypted string.</p>
","<p>Rather than doing this yourself, you could use <a href=""https://msdn.microsoft.com/en-us/library/53tyfkaw%28v=vs.110%29.aspx"" rel=""nofollow"">""Protected Configuration""</a> to encrypt your configuration file.</p>

<p>Although this is primarily designed for use with ASP.Net, you can also use it for Windows Forms (and other) applications.</p>

<p><a href=""http://www.codeproject.com/Articles/15392/Implementing-Protected-Configuration-With-Windows"" rel=""nofollow"">Here's a (fairly old) article about using Protected Configuration with a Windows Forms application on Code Project.</a></p>

<p><a href=""http://www.codeproject.com/Tips/598863/EncryptionplusDecryptionplusConnectionplusStringpl?msg=5179670#xx5179670xx"" rel=""nofollow"">And here's a more recent article.</a></p>
","517","<c#><winforms><encryption><rijndael>","0","2","1","2016-05-12 09:40:45","","11","1","266143","","2016-05-12 09:33:43","2016-05-12 09:22:08",""
"38764431","How to get data after decoding from its encoded value?","<p>I am doing a test of how to get actual data from encoded data using PHP-encoding functions. I can't get the original data once I encoded it. Instead I am getting some special <a href=""http://en.wikipedia.org/wiki/Unicode"" rel=""nofollow"">Unicode</a> characters...</p>

<p>My code is as follows.</p>

<pre><code>$key = '28e336ac6c9423d946ba02d19c6a2632'; // Randomly generated key
$request_params = array(
    'controller' =&gt; 'mylist',
    'action'     =&gt; 'read',
    'username'   =&gt; 'test',
    'password'   =&gt; '12345'
));
$enc_request = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, json_encode($request_params), MCRYPT_MODE_ECB));
//echo $enc_request;exit; // Here I am getting the encoded string.

$paramas = base64_decode(trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, json_decode($enc_request), MCRYPT_MODE_ECB)));
print_r($paramas); // Here I am getting like ... ºÇ
echo $paramas-&gt;controller; // Got nothing.
</code></pre>

<p>What I am doing wrong?</p>
","<p>I think the problem is with the order of operations you do. If you look closer at your code you are first JSON encoding, then encrypting and last <a href=""http://en.wikipedia.org/wiki/Base64"" rel=""nofollow"">Base64</a> encoding. So to get back the original value you need to do it in the opposite order. First Base64 decode, then decrypt and last JSON decode. Try something like</p>

<pre><code>$paramas = json_decode(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, base64_decode($enc_request), MCRYPT_MODE_ECB));
</code></pre>

<p>Also ECB mode should only be used for testing. Go for CBC if you are going to use this.</p>

<p>Also, mcrypt is depricated. You should check out openssl_ecrypt/openssl_decrypt instead. I don't have mcrypt installed, but this works using <a href=""http://en.wikipedia.org/wiki/OpenSSL"" rel=""nofollow"">OpenSSL</a>:</p>

<pre><code>$key = '28e336ac6c9423d946ba02d19c6a2632'; // Randomly generated key
$request_params = array(
    'controller' =&gt; 'mylist',
    'action'     =&gt; 'read',
    'username'   =&gt; 'test',
    'password'   =&gt; '12345'
);
$enc_request = base64_encode(openssl_encrypt(json_encode($request_params), 'AES-256-ECB', $key));
//echo $enc_request;exit; // Here I am getting the encoded string.

$paramas = json_decode(openssl_decrypt(base64_decode($enc_request), 'AES-256-ECB', $key));
print_r($paramas); // Here I am getting like ... ºÇ
echo $paramas-&gt;controller;
</code></pre>
","513","<php><json><base64><mcrypt><rijndael>","0","1","2","2016-08-21 16:37:51","38765095","3","","63550","","2016-08-21 16:34:37","2016-08-04 10:09:41",""
"38764431","How to get data after decoding from its encoded value?","<p>I am doing a test of how to get actual data from encoded data using PHP-encoding functions. I can't get the original data once I encoded it. Instead I am getting some special <a href=""http://en.wikipedia.org/wiki/Unicode"" rel=""nofollow"">Unicode</a> characters...</p>

<p>My code is as follows.</p>

<pre><code>$key = '28e336ac6c9423d946ba02d19c6a2632'; // Randomly generated key
$request_params = array(
    'controller' =&gt; 'mylist',
    'action'     =&gt; 'read',
    'username'   =&gt; 'test',
    'password'   =&gt; '12345'
));
$enc_request = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, json_encode($request_params), MCRYPT_MODE_ECB));
//echo $enc_request;exit; // Here I am getting the encoded string.

$paramas = base64_decode(trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, json_decode($enc_request), MCRYPT_MODE_ECB)));
print_r($paramas); // Here I am getting like ... ºÇ
echo $paramas-&gt;controller; // Got nothing.
</code></pre>

<p>What I am doing wrong?</p>
","<p>When you do thing in the correct order it works.</p>

<p>This code I have tested and it does work</p>

<pre><code>&lt;?php

$key = '28e336ac6c9423d946ba02d19c6a2632';//randomly generated key
$request_params = array(
    'controller' =&gt; 'mylist',
    'action'     =&gt; 'read',
    'username'   =&gt; 'test',
    'password'   =&gt; '12345'
);
$js = json_encode($request_params);
$encd = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $js, MCRYPT_MODE_ECB);

$enc_request = base64_encode($encd);
echo $enc_request . PHP_EOL;

// now reverse process in correct order
$one   = base64_decode($enc_request);
$two   = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $one, MCRYPT_MODE_ECB);
$twoa  = trim($two);
echo $twoa . PHP_EOL;

$three = json_decode($twoa);

print_r($three);
echo $three-&gt;controller . PHP_EOL;
</code></pre>

<p>It also works with the <code>openssl</code> functions suggested by @rypskar</p>

<pre><code>&lt;?php

$key = '28e336ac6c9423d946ba02d19c6a2632';//randomly generated key
$request_params = array(
    'controller' =&gt; 'mylist',
    'action'     =&gt; 'read',
    'username'   =&gt; 'test',
    'password'   =&gt; '12345'
);
$js = json_encode($request_params);
//$encd = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $js, MCRYPT_MODE_CBC);
$encd = openssl_encrypt($js, 'AES-256-ECB', $key);

$enc_request = base64_encode($encd);
echo $enc_request . PHP_EOL;

// now reverse process in correct order
$one   = base64_decode($enc_request);
//$two   = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $one, MCRYPT_MODE_CBC);
$two   = openssl_decrypt($one, 'AES-256-ECB', $key);
$twoa  = trim($two);
echo $twoa . PHP_EOL;
$three = json_decode($twoa);

print_r($three);
echo $three-&gt;controller . PHP_EOL;
</code></pre>
","513","<php><json><base64><mcrypt><rijndael>","0","2","2","2016-08-21 16:37:51","38765095","3","","63550","","2016-08-21 16:34:37","2016-08-04 10:09:41",""
"17183699","Generate 256bits Key Rijndael in PHP","<p>The below code will successfully generate KEY for encryption. How can I recreate this in PHP using the same salt and passkey to generate a KEY in order to decrypt the message?</p>

<pre><code>public static string GenerateKey(string passkey)
{
    var myAlg = new RijndaelManaged()
    {
         Padding = PaddingMode.PKCS7,
         Mode = CipherMode.CBC,
         KeySize = 256,
         BlockSize = 256,
    };
    byte[] salt = Encoding.ASCII.GetBytes(""Some salt value"");
    Rfc2898DeriveBytes keys = new Rfc2898DeriveBytes(passkey, salt);
    myAlg.Key = keys.GetBytes(myAlg.KeySize / 8);
    return (Encoding.ASCII.GetString(myAlg.Key));
}
</code></pre>
","<p>Check this: <a href=""http://www.php.net/manual/en/book.mcrypt.php"" rel=""nofollow"">http://www.php.net/manual/en/book.mcrypt.php</a></p>

<p>Mcrypt supports Rijndael-256</p>
","510","<c#><php><rijndael><rijndaelmanaged>","-1","-2","1","2013-06-19 06:37:01","","0","","447156","","2013-06-19 05:47:09","2013-06-19 05:46:19",""
"24953171","vb.net rijndael limit to 64 character","<p>i have problem while encrypt and decrypt using rijndael in vb.net.</p>

<p>it cannot work on string more than 64 character.
here is my code:</p>

<pre><code> Private Function prepareRijn() As Rijndael
    Dim KEY As String = Left(_KEY, 32)
    Dim IV As String = Right(_KEY, 32)
    Dim enc As New System.Text.UTF8Encoding
    Dim byteKEY() As Byte = enc.GetBytes(KEY)
    Dim byteIV() As Byte = enc.GetBytes(IV)
    Dim alg As Rijndael = Rijndael.Create
    alg.BlockSize = 256
    alg.KeySize = 256
    alg.Padding = PaddingMode.Zeros
    alg.Mode = CipherMode.CBC
    alg.Key = byteKEY
    alg.IV = byteIV
    Return alg
End Function
Function decrypt(ByVal encrypted As String) As String
    encrypted = encrypted.Replace(""Q2FrZQ==."", """")
    Dim enc As New System.Text.UTF8Encoding
    Dim alg As Rijndael = prepareRijn()
    Dim ms As New MemoryStream
    Dim cs As CryptoStream = New CryptoStream(ms, alg.CreateDecryptor, CryptoStreamMode.Write)
    Dim data() As Byte = Convert.FromBase64String(encrypted)
    cs.Write(data, 0, data.Length)
    'ms.SetLength(data.Length)
    Dim decrypted() As Byte
    decrypted = ms.ToArray
    cs.Close()

    Return enc.GetString(decrypted)
End Function
Function encrypt(ByVal decrypt As String) As String
    decrypt = decrypt + ""                ""
    Dim alg As Rijndael = prepareRijn()
    Dim ms As New MemoryStream()
    Dim cs As CryptoStream = New CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write)
    Dim data() As Byte = System.Text.Encoding.UTF8.GetBytes(decrypt)
    cs.Write(data, 0, data.Length)
    'ms.SetLength(data.Length)
    Dim encrypted() As Byte = ms.ToArray()
    cs.Close()
    Return Convert.ToBase64String(encrypted)
End Function
</code></pre>

<p>is there anything i miss during my rijndael configuration ?</p>
","<p>I wrote complete Encryption Class for you. It works perfectly. It can be used for Both Strings and ByteArrays. This Class returns Encrypted Data in Base64, if you dont want Base64, just remove Conversion.</p>

<pre><code>Imports System.Text
Imports System.Security.Cryptography
Imports System.IO
Imports System

Public Class Encryption

    ' Fields
    Private Shared sIV As String = ""Your IV Key Placed Here 32-Bytes""
    Private Shared sKey As String = ""Your SecKey Placed Here 32-Bytes""

    ' Methods
    Public Shared Function DecryptRJ256(ByVal prm_text_to_decrypt As String) As String
        Dim s As String = prm_text_to_decrypt
        Dim managed As New RijndaelManaged With { _
            .Padding = PaddingMode.Zeros, _
            .Mode = CipherMode.ECB, _
            .KeySize = &amp;H100, _
            .BlockSize = &amp;H100 _
        }
        Dim rgbKey As Byte() = Nothing
        Dim rgbIV As Byte() = Nothing
        s = s.Replace(""-"", ""+"").Replace(""_"", ""/"").Replace(""|"", ""="")
        rgbKey = Encoding.ASCII.GetBytes(Encryption.sKey)
        rgbIV = Encoding.ASCII.GetBytes(Encryption.sIV)
        Dim transform As ICryptoTransform = managed.CreateDecryptor(rgbKey, rgbIV)
        Dim buffer As Byte() = Convert.FromBase64String(s)
        Dim buffer4 As Byte() = New Byte((buffer.Length + 1) - 1) {}
        Dim stream As New MemoryStream(buffer)
        Dim stream2 As New CryptoStream(stream, transform, CryptoStreamMode.Read)
        stream2.Read(buffer4, 0, buffer4.Length)
        Return Encoding.ASCII.GetString(buffer4)
    End Function

    Public Shared Function EncryptRJ256(ByVal prm_text_to_encrypt As String) As String
        Dim s As String = prm_text_to_encrypt
        Dim managed As New RijndaelManaged With { _
            .Padding = PaddingMode.Zeros, _
            .Mode = CipherMode.ECB, _
            .KeySize = &amp;H100, _
            .BlockSize = &amp;H100 _
        }
        Dim buffer As Byte() = Nothing
        Dim rgbKey As Byte() = Nothing
        Dim rgbIV As Byte() = Nothing
        rgbKey = Encoding.ASCII.GetBytes(Encryption.sKey)
        rgbIV = Encoding.ASCII.GetBytes(Encryption.sIV)
        Dim transform As ICryptoTransform = managed.CreateEncryptor(rgbKey, rgbIV)
        Dim stream As New MemoryStream
        Dim stream2 As New CryptoStream(stream, transform, CryptoStreamMode.Write)
        buffer = Encoding.ASCII.GetBytes(s)
        stream2.Write(buffer, 0, buffer.Length)
        stream2.FlushFinalBlock()
        Return Convert.ToBase64String(stream.ToArray).Replace(""+"", ""-"").Replace(""/"", ""_"").Replace(""="", ""|"")
    End Function

    Public Shared Function EncryptRJ256(ByVal ArrayByte As Byte()) As String

        Dim managed As New RijndaelManaged With { _
            .Padding = PaddingMode.Zeros, _
            .Mode = CipherMode.ECB, _
            .KeySize = &amp;H100, _
            .BlockSize = &amp;H100 _
        }

        Dim rgbKey As Byte() = Nothing
        Dim rgbIV As Byte() = Nothing
        rgbKey = Encoding.ASCII.GetBytes(Encryption.sKey)
        rgbIV = Encoding.ASCII.GetBytes(Encryption.sIV)
        Dim transform As ICryptoTransform = managed.CreateEncryptor(rgbKey, rgbIV)
        Dim stream As New MemoryStream
        Dim stream2 As New CryptoStream(stream, transform, CryptoStreamMode.Write)

        stream2.Write(ArrayByte, 0, ArrayByte.Length)
        stream2.FlushFinalBlock()
        Return Convert.ToBase64String(stream.ToArray).Replace(""+"", ""-"").Replace(""/"", ""_"").Replace(""="", ""|"")

    End Function

    Public Shared Function getMD5Hash(ByVal input As String) As String
        Dim md As MD5 = MD5.Create
        Dim bytes As Byte() = Encoding.ASCII.GetBytes(input)
        Dim buffer2 As Byte() = md.ComputeHash(bytes)
        Dim builder As New StringBuilder
        Dim i As Integer
        For i = 0 To buffer2.Length - 1
            builder.Append(buffer2(i).ToString(""X2""))
        Next i
        Return builder.ToString
    End Function

    Public Shared Function FromBase64String(ByVal prm_text_to_decrypt As String) As String

        Dim s As String = prm_text_to_decrypt

        s = s.Replace(""-"", ""+"").Replace(""_"", ""/"").Replace(""|"", ""="")


        Dim buffer As Byte() = Convert.FromBase64String(s)
        Return Encoding.ASCII.GetString(buffer)

    End Function

End Class
</code></pre>
","508","<vb.net><rijndael>","1","0","1","2014-07-25 12:20:03","24955699","0","","","","","2014-07-25 10:05:40",""
"23269981","How to adapt rijndael (php) algorithm to aes (java)","<p>I have a php code that encrypts a plain text using rijndael algorithm in the EBC mode, and a 17-charachter key length.
I'm looking to use an equivalent AES algorithm with Java</p>

<p>This is my php code:</p>

<pre><code>&lt;?php 
  $key="" 4288f0b8060ca1b ""; 
  $mcryptAlgo= MCRYPT_RIJNDAEL_128 ; 
  $mcryptMode= MCRYPT_MODE_ECB ; 
  $data = ""text_to_crypt_with_aes"" ;

  $mcryptedData = mcrypt_encrypt ($mcryptAlgo, $key, $data, $mcryptMode); 
  $parametres_chiffres = urlencode( base64_encode ($mcryptedData)); 
  echo($parametres_chiffres);
?&gt; 
</code></pre>

<p>It returns as a result the encrypted message: 4LepwOstJA0R2bg5FrdQXeoxesxmKV4pkf514F3VDqU%3D</p>

<p>However, the following Java code that I've built doesn't return the same message:</p>

<pre><code>public static void main(String[] args) {

        StringBuilder sb = new StringBuilder();
        sb.append(""text_to_crypt_with_aes"");
        String clearText = sb.toString();
        StringBuilder sbKey = new StringBuilder("" 4288f0b8060ca1b "");
        for (int i = 0; i &lt; 7; i++) {
            sbKey.append(""\0"");
        }

        try {

            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");

            Key key = new SecretKeySpec(sbKey.toString().getBytes(""UTF-8""),
                    ""AES"");

            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedMessageInBytes = cipher.doFinal(clearText
                    .getBytes(""UTF-8""));
            byte[] b64 = Base64.encodeBase64(encryptedMessageInBytes);
            String scrambled_text = new String(b64, Charset.forName(""US-ASCII""));
            System.out.println(scrambled_text);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
</code></pre>

<p>It returns actually: 
4LepwOstJA0R2bg5FrdQXRutIOZlJi06f0D8NnnIG5Q=</p>

<p>How can I adapt my Java code to return exactly the same as in php ?</p>
","<p>The first 16 bytes are the same in both decryptions.  The differences are in the last 16 bytes:</p>

<pre><code>4LepwOstJA0R2bg5FrdQX eoxesxmKV4pkf514F3VDqU %3D
4LepwOstJA0R2bg5FrdQX RutIOZlJi06f0D8NnnIG5Q =
</code></pre>

<p>Since you are using ECB mode (don't, it is insecure) that tells me that you are encrypting the first block correctly and the second block is different.  Your Java code specifies PKCS5 padding.  PHP however uses zero padding to fill up the last block. <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php#47973"" rel=""nofollow noreferrer"">The comments of <code>mcrypt_encrypt</code></a> contain examples to perform PKCS#7 padding, <a href=""https://crypto.stackexchange.com/q/9043/1172"">which is identical to PKCS#5 padding</a>.</p>
","504","<java><php><encryption><aes><rijndael>","2","3","1","2014-04-24 16:12:57","","1","2","","","","2014-04-24 13:12:44",""
"17893164","Encrypt a string twice... Good, Bad or Ugly?","<p>I'm working on an encryption class that is using Rijndael algorithm (C#, ASP.Net 4.5), and out of curiosity I was wondering how beneficial would it be to encrypt the string twice. I mean Encrypt the string with a key and then Encrypt the resulting encryption with another key?</p>

<p>Does this make it that much more secure (I know nothing is ever secure and there could be other holes in my software that could be used to exploit)? Is it worth the CPU overhead (not sure how heavy this is but I can't imagine it would light)?</p>

<p>I was looking for some suggestions online but was not able to find any. Any thoughts? </p>
","<p>Have a couple of questions that may be of use to you:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/771315/is-there-any-benefit-to-encrypting-twice-using-pgp"">Is there any benefit to encrypting twice using pgp?</a></li>
<li><a href=""https://stackoverflow.com/questions/9345068/is-encrypting-twice-good-or-bad"">Is encrypting twice good or bad?</a></li>
<li><a href=""https://crypto.stackexchange.com/questions/779/hashing-or-encrypting-twice-to-increase-security"">https://crypto.stackexchange.com/questions/779/hashing-or-encrypting-twice-to-increase-security</a></li>
<li><a href=""https://crypto.stackexchange.com/questions/5382/is-it-safer-to-encrypt-twice-with-rsa"">https://crypto.stackexchange.com/questions/5382/is-it-safer-to-encrypt-twice-with-rsa</a></li>
<li><a href=""https://crypto.stackexchange.com/questions/2314/does-encrypting-twice-using-the-same-block-cipher-produce-a-security-weakness"">https://crypto.stackexchange.com/questions/2314/does-encrypting-twice-using-the-same-block-cipher-produce-a-security-weakness</a></li>
</ul>

<p>General idea seems to be this point:</p>

<blockquote>
  <p>Well, think about it this way. If breaking one encryption with brute
  force will take longer than the lifetime of the universe, are you any
  safer with an encryption scheme that will take twice the lifetime of
  the universe? No. The first encryption cannot be broken. Adding a
  second encryption just adds computation overhead with no real benefit. - mikeazo</p>
</blockquote>

<p>I would advise asking this question in <a href=""https://crypto.stackexchange.com/"">https://crypto.stackexchange.com/</a>, they may give you more detailed information on the topic.</p>
","465","<c#><encryption><rijndael>","1","4","2","2013-07-27 02:47:17","17893252","4","","","","","2013-07-27 00:49:47",""
"17893164","Encrypt a string twice... Good, Bad or Ugly?","<p>I'm working on an encryption class that is using Rijndael algorithm (C#, ASP.Net 4.5), and out of curiosity I was wondering how beneficial would it be to encrypt the string twice. I mean Encrypt the string with a key and then Encrypt the resulting encryption with another key?</p>

<p>Does this make it that much more secure (I know nothing is ever secure and there could be other holes in my software that could be used to exploit)? Is it worth the CPU overhead (not sure how heavy this is but I can't imagine it would light)?</p>

<p>I was looking for some suggestions online but was not able to find any. Any thoughts? </p>
","<p>There's a simple rule in cryptography.  All the security should be in the key.  Based on that there should be no additional security in encrypting twice because all your security should be in the choice and storage of your key.</p>

<p>Now that being said... you could get some additional security if you make wrong choices.  For example say you encrypt the first time with ECB mode (Electronic Code book), because of the way that mode works (by encrypting each block of your plaintext separately), you could get extra security by encrypting a second time in a more secure mode (CBC or CTR).  But... you could just as well encrypt in CBC mode the first time around.  </p>

<p>You could encrypt the first time with an insecure algorithm (such as DES) and encrypt a second time with a much better algorithm (such as AES).</p>

<p>But these situations are hypothetical and would require you to intentionally make mistakes or be extremely negligent.  If you use AES (Rijandael) twice in a secure mode like CTR or CBC then you will not get any additional security from encrypting twice so long as your key is stored securly and selected in a secure manner.</p>
","465","<c#><encryption><rijndael>","1","1","2","2013-07-27 02:47:17","17893252","4","","","","","2013-07-27 00:49:47",""
"1905047","C# rijndael stream writer issue","<p>Just got some errors in code, which says the file is being used.
What I need to achieve is add first part of encrypted data in file and then add second part of of evcrypted data in the same file. This file need to be decrypted later. I am pretty new to this field. Many thanks.</p>

<pre><code>    Class3 cs3;
    StreamWriter sWriter;

    private void Add_text_Part_One()
    {
        Rijndael RijndaelAlg = Rijndael.Create();
        // Create a string to encrypt.
        string sData = ""Here is some data to encrypt."";
        string FileName = @""C:\CText.txt"";

        cs3 = new Class3(sData, FileName, RijndaelAlg.Key, RijndaelAlg.IV);
        sWriter = new StreamWriter(cs3.getCS());
        sWriter.WriteLine(sData);
        sWriter.Close();
    }

    private void Add_text_Part_Two()
    {
        string sData = ""Here is some more data to encrypt."";
        sWriter.WriteLine(sData);
        sWriter.Close();
    }
class Class3
{
    FileStream fStream;
    Rijndael RijndaelAlg;
    CryptoStream cStream;
    public Class3(String Data, String FileName, byte[] Key, byte[] IV)
    {
        fStream = File.Open(FileName, FileMode.Append);
        RijndaelAlg = Rijndael.Create();
        cStream = new CryptoStream(fStream, RijndaelAlg.CreateEncryptor(Key, IV), CryptoStreamMode.Write); 
    }
    public CryptoStream getCS()
    {
        return cStream;
    }

    public string getRes()
    {
        StreamReader sReader = new StreamReader(cStream);
        string val = null;
        val = sReader.ReadLine();
        return val;
    }     
</code></pre>
","<p>in the constructor of Class3 you call File.Open() and assign the resulting FileStream to fstream. This fstream object is never closed, so the file remains open. You are going to have to close the fstream (prefereably implement IDisposable and use Class3 within a using block)</p>

<p><strong>Edit: Sorry, I think I'm kind of losing it here. I don't believe the above is right, however, you are closing the StreamWriter, and then trying to write to it again in part II, when it is closed, might want to take a look at that.</strong></p>
","462","<c#><rijndael>","0","2","1","2009-12-15 04:04:39","1905072","0","","","","","2009-12-15 03:48:09",""
"318095","Strange Error in .net Application. - RijndaelManaged","<p>During a recent load test, I've been getting some strange ""Index Out of Range Exception"" </p>

<p>Stack trace:   </p>

<pre><code> at System.Security.Cryptography.RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode paddingMode, Boolean fLast)
   at System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount)
   at System.Security.Cryptography.CryptoStream.FlushFinalBlock()
   at System.Web.Configuration.MachineKeySection.EncryptOrDecryptData(Boolean fEncrypt, Byte[] buf, Byte[] modifier, Int32 start, Int32 length, Boolean useValidationSymAlgo)
   at System.Web.UI.Page.DecryptString(String s)
   at System.Web.UI.Page.ProcessRequestMain(Boolean includeStagesBeforeAsyncPoint, Boolean includeStagesAfterAsyncPoint)
</code></pre>

<p>We are not using a farm or cluster, and I am not using any cryptography in the app.</p>

<p>It appears that this is happening in the behind the scenes .Net classes.</p>

<p>I figure this has something to do with viewstate, but I can't find out why this is being thrown.</p>

<p>Any Ideas?</p>
","<p>Just a guess:  have you disabled EventValidation on the site?  Sounds like something is trying to create a manual postback or otherwise insert data directly into the http request's post data, and isn't calculated the correct value for the viewstate field.  This in turn causes the decryption to fail spectacularly.  </p>

<p>With EventValidation turned on you'll get an exception even if they calculate everything correctly, but at least it's a meaningful exception.</p>
","458","<.net><asp.net><viewstate><rijndaelmanaged><rijndael>","0","0","2","2009-08-05 17:43:39","339453","0","","95573","Joel Coehoorn","2009-08-05 17:43:39","2008-11-25 16:55:06",""
"318095","Strange Error in .net Application. - RijndaelManaged","<p>During a recent load test, I've been getting some strange ""Index Out of Range Exception"" </p>

<p>Stack trace:   </p>

<pre><code> at System.Security.Cryptography.RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode paddingMode, Boolean fLast)
   at System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount)
   at System.Security.Cryptography.CryptoStream.FlushFinalBlock()
   at System.Web.Configuration.MachineKeySection.EncryptOrDecryptData(Boolean fEncrypt, Byte[] buf, Byte[] modifier, Int32 start, Int32 length, Boolean useValidationSymAlgo)
   at System.Web.UI.Page.DecryptString(String s)
   at System.Web.UI.Page.ProcessRequestMain(Boolean includeStagesBeforeAsyncPoint, Boolean includeStagesAfterAsyncPoint)
</code></pre>

<p>We are not using a farm or cluster, and I am not using any cryptography in the app.</p>

<p>It appears that this is happening in the behind the scenes .Net classes.</p>

<p>I figure this has something to do with viewstate, but I can't find out why this is being thrown.</p>

<p>Any Ideas?</p>
","<p>If someone initiates a post, the application starts sending the post with all 500KBs of viewstate.  Half way through postback, the user gets bored and clicks something else.  The browser cuts off the postback with just part of the viewstate.  The server throws an error that says the viewstate is borked.  I would guess this is a 2.0 application with the viewstate encryption feature turned on.  The solution is to manage viewstate size more aggressively.</p>

<p>Event validation exceptions are more likely to happen when a malicious user is crafting a custom postback response, so I don't think event validation is involved here.</p>
","458","<.net><asp.net><viewstate><rijndaelmanaged><rijndael>","0","1","2","2009-08-05 17:43:39","339453","0","","95573","Joel Coehoorn","2009-08-05 17:43:39","2008-11-25 16:55:06",""
"30094325","MachineKey - Is it strongly secured to use Machinekey.Protect?","<ul>
<li>Is MachineKey.Protect strongly secured? or I should find other encryption algorythms like Rijndael? </li>
<li>What are MachineKey.Protect disadventages?</li>
</ul>

<p>I want to use encryption for email verification link and it must be strongly secured</p>
","<p>It uses whatever is set in <a href=""https://msdn.microsoft.com/en-us/library/system.web.configuration.machinekeysection.validationalgorithm(v=vs.110).aspx"" rel=""nofollow""><code>MachineKeySection.ValidationAlgorithm</code></a> in the appropriate config file.</p>
","458","<c#><security><encryption><rijndael><machinekey>","1","1","1","2015-05-08 09:18:59","30120179","0","","2413470","","2015-05-07 07:36:00","2015-05-07 07:18:29",""
"28383077","SagePay Form - Classic ASP - Currency Field is missing using rijndael.asp","<p>I am trying to add the Form Intergration SagePay payment gateway in Classic ASP. I have a working PHP version that I sourced from SO. I have translated it into VBSCRIPT, everything seems to be working fine but the encryption. </p>

<p>I am using all the same inputs as the PHP script so that the Cryptstring is exactly the same as the PHP Cryptstring before it is encrypted. </p>

<p>I've downloaded and using the Rijndael.asp &amp; includes.asp files found here: <a href=""https://stackoverflow.com/questions/25025330/encrypting-crypt-field-using-classic-asp-for-sagepay-form-integration"">Encrypting Crypt field using Classic ASP for SagePay Form Integration</a></p>

<p>But I continue to receive the following error:</p>

<pre>
Status: MALFORMED
Status Detail:  3045 : The Currency field is missing.

Cryptstring: VendorTxCode=542534345&ReferrerID=&Amount=200.00&Currency=GBP
&Description=Lorem ipsum&SuccessURL=http://www.testserver.co.uk/sagepaytest/success.php
&FailureURL=https://www.yoururl.org/fail.php&CustomerName=&CustomerEMail=&VendorEMail=
&SendEMail=&eMailMessage=&BillingSurname=Mustermann&BillingFirstnames=Max
&BillingAddress1=Bahnhofstr. 1&BillingAddress2=&BillingCity=Cologne&BillingPostCode=50650
&BillingCountry=DE&BillingState=&BillingPhone=&DeliverySurname=Mustermann
&DeliveryFirstnames=Max&DeliveryAddress1=Bahnhofstr. 1&DeliveryAddress2=
&DeliveryCity=Cologne&DeliveryPostCode=50650&DeliveryCountry=DE&DeliveryState=
&DeliveryPhone=&Basket=&AllowGiftAid=&ApplyAVSCV2=&Apply3DSecure=&BillingAgreement=
&BasketXML=&CustomerXML=&SurchargeXML=&VendorData=&ReferrerID=&Language=&Website=
</pre>

<p>I've tried manually adding certain fields into the crypt string, I've tried GET to anther page without the encryption to view the full output. </p>

<p>My encryption password is correct, I've double and triple checked it. Its entered in the includes.php file. </p>

<hr>

<p>index.asp</p>

<pre><code>&lt;%@LANGUAGE=""VBSCRIPT"" CODEPAGE=""1252""%&gt;

&lt;!-- #include file=""classes/includes.asp"" --&gt;

&lt;!-- #include file=""classes/sagepay.asp"" --&gt;

&lt;% Set objSagePay=new SagePay %&gt;

&lt;% objSagePay.setCurrency(""GBP"") %&gt;
&lt;% objSagePay.setAmount(200) %&gt;
&lt;% objSagePay.setDescription(""Lorem ipsum"") %&gt;
&lt;% objSagePay.setBillingSurname(""Mustermann"") %&gt;
&lt;% objSagePay.setBillingFirstnames(""Max"") %&gt;
&lt;% objSagePay.setBillingCity(""Cologne"") %&gt;
&lt;% objSagePay.setBillingPostCode(""50650"") %&gt;
&lt;% objSagePay.setBillingAddress1(""Bahnhofstr. 1"") %&gt;
&lt;% objSagePay.setBillingCountry(""de"") %&gt;
&lt;% objSagePay.setDeliverySameAsBilling() %&gt;

&lt;% objSagePay.setSuccessURL(""http://www.testserver.co.uk/sagepaytest/success.php"") %&gt;
&lt;% objSagePay.setFailureURL(""https://www.yoururl.org/fail.php"") %&gt;

&lt;% Crypt=objSagePay.getCrypt() %&gt;
&lt;%= Crypt %&gt;

&lt;div id=""content""&gt;
  &lt;form method=""POST"" id=""SagePayForm"" action=""https://test.sagepay.com/gateway/service/vspform-register.vsp""&gt;
  &lt;input type=""hidden"" name=""VPSProtocol"" value= ""3.00""&gt;
  &lt;input type=""hidden"" name=""TxType"" value= ""PAYMENT""&gt;
  &lt;input type=""hidden"" name=""Vendor"" value= ""vendorname""&gt;
  &lt;input type=""hidden"" name=""Crypt"" value= ""&lt;%= objSagePay.getCrypt() %&gt;""&gt;
  &lt;input type=""submit"" value=""continue to SagePay""&gt;
&lt;/form&gt;
</code></pre>

<hr>

<p>Any guidance would be appreciated.</p>
","<p>I'm in the same boat. I can encrypt and decrypt perfectly with exactly the same results but when it is passed to Sagepay I get the error - Currency field is missing. </p>

<p>Update: I have managed to solve this error.  Make sure in the 'includes.asp' that you change the existing line:</p>

<pre><code>strEncryptionPassword=""mcAX65PTadrrsKQ3""
</code></pre>

<p>to include the password that is in your original Sagepay 'includes.asp' file.  Do not use the default password that comes with the download link in your post.</p>
","457","<encryption><vbscript><asp-classic><sagepay><rijndael>","2","4","1","2015-08-10 15:33:23","","1","1","-1","","2017-05-23 12:14:37","2015-02-07 14:07:13",""
"33543434","Migrating AES from lockbox2 to lockbox3 delphi","<p>I'd like to migrate my old crypto functions from lockbox2 to lockbox3 on delphi XE6.
Before to do that I've made a <a href=""https://github.com/graguirre/DelphiDecoratorSample"" rel=""nofollow"">code</a> (CipherComp.dpr) to compare the output, since the setup have changed. </p>

<p>I'm using AES-ECB (to avoid IV) 256 bits, key: '1234567890', text: 'a secret word'</p>

<p>Using <strong>TPLB2</strong> I initialize like</p>

<pre><code>  FAES : TLbRijndael;

  FAES := TLbRijndael.Create(nil);
  FAES.CipherMode := cmECB;   // cmECB (default), cmCBC
  FAES.KeySize := ks256;      // ks128, ks192
  FAES.SetKey('1234567890');  // set the password here
</code></pre>

<p>and encrypt using:</p>

<pre><code>  Result := FAES.EncryptString(pString);
</code></pre>

<p>on the other hand on <strong>TPLB3</strong> changes like this</p>

<pre><code>  FCodec: TCodec;
  FCryptoLib: TCryptographicLibrary;

  FCodec := TCodec.Create(nil);
  FCryptoLib := TCryptographicLibrary.Create(nil);

  FCodec.CryptoLibrary := FCryptoLib;
  FCodec.StreamCipherId := uTPLb_Constants.BlockCipher_ProgId;
  FCodec.BlockCipherId  := 'native.AES-256';
  FCodec.ChainModeId    := uTPLb_Constants.ECB_ProgId;
  FCodec.Password := '1234567890';
</code></pre>

<p>and encrypt</p>

<pre><code>  FCodec.EncryptAnsiString(pString, Result);
</code></pre>

<p>but the output mismatch when cipher the same text. </p>

<pre><code>a secret word qD9+fF1EqdQH8C3TrEaLQg==
a secret word 1bUXLgXwob1cL6O27HMViw==
</code></pre>

<p>I'm doing something wrong but I can figure out what. </p>

<p>Any hint?</p>

<p>Thanks in advance.</p>
","","449","<delphi><aes><rijndael><lockbox-3><lockbox-2>","2","","0","2015-11-05 11:29:17","","3","1","","","","2015-11-05 11:29:17",""
"46036071","Decrypting a Text File Using Rjindael","<p>I have used <a href=""https://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael"" rel=""nofollow noreferrer"">this guide</a> to encrypt the value of <code>txtCode.Text</code> into a text file, which is then hidden - The value of the encrypted data is going to be used as the password for the database, so I need to read this value, decrypt it, then pass it into the connection string.</p>

<p>However, in this guide, the decryption is done by typing in a value, creating a <code>bytKey</code> and <code>bytIV</code> and then comparing the result of encryption of the newl typed string with the value in the text file. Obviously I can't ask the user to enter the password every time the database needs to be opened, so how can I achieve decryption using this code?</p>

<p>The code which decrypts and encrypts the data is </p>

<pre><code>Public Sub EncryptOrDecryptFile(ByVal strInputFile As String, ByVal strOutputFile As String, _
ByVal bytKey() As Byte, ByVal bytIV() As Byte, ByVal Direction As CryptoAction)

    Try
        fsInput = New System.IO.FileStream(strInputFile, FileMode.Open, FileAccess.Read)
        fsOutput = New System.IO.FileStream(strOutputFile, FileMode.OpenOrCreate, FileAccess.Write)
        fsOutput.SetLength(0)

        Dim bytBuffer(4096) As Byte
        Dim lngBytesProcessed As Long = 0
        Dim lngFileLength As Long = fsInput.Length
        Dim intBytesInCurrentBlock As Integer
        Dim csCryptoStream As CryptoStream

        Dim cspRijndael As New System.Security.Cryptography.RijndaelManaged

        Select Case Direction
            Case CryptoAction.ActionEncrypt
                csCryptoStream = New CryptoStream(fsOutput, _
                cspRijndael.CreateEncryptor(bytKey, bytIV), _
                CryptoStreamMode.Write)

            Case CryptoAction.ActionDecrypt
                csCryptoStream = New CryptoStream(fsOutput, _
                cspRijndael.CreateDecryptor(bytKey, bytIV), _
                CryptoStreamMode.Write)
        End Select

        While lngBytesProcessed &lt; lngFileLength
            intBytesInCurrentBlock = fsInput.Read(bytBuffer, 0, 4096)

            csCryptoStream.Write(bytBuffer, 0, intBytesInCurrentBlock)

            lngBytesProcessed = lngBytesProcessed + _
                                    CLng(intBytesInCurrentBlock)
        End While

        csCryptoStream.Close()
        fsInput.Close()
        fsOutput.Close()

    Catch ex As Exception
        errorLog(ex)

    End Try
End Sub
</code></pre>

<p>I need to use this, or another, subroutine to read the file, decrypt the data and then store it in a variable to pass into the connection string - Can this be done? If so, how?</p>
","<p>After numerous attempts with that code of yours I decided to ditch it - it is simply old, ineffective and unsafe (as <a href=""https://stackoverflow.com/questions/46036071/decrypting-a-text-file-using-rjindael/46039488#comment79039555_46039488"">noted by Plutonix</a>).</p>

<p>Here's a much more efficient piece of code where I've modified and improved an old class of mine - called <code>Aes256Stream</code>. It is derived from the <code>CryptoStream</code> and will handle the IV automatically for you.</p>

<pre><code>'+---------------------------------------------------------------------------------+'
'|                               === Aes256Stream ===                              |'
'|                                                                                 |'
'|                  Created by Vincent ""Visual Vincent"" Bengtsson                  |'
'|                      Website: https://www.mydoomsite.com/                       |'
'|                                                                                 |'
'|                                                                                 |'
'|                            === COPYRIGHT LICENSE ===                            |'
'|                                                                                 |'
'| Copyright (c) 2016-2017, Vincent Bengtsson                                      |'
'| All rights reserved.                                                            |'
'|                                                                                 |'
'| Redistribution and use in source and binary forms, with or without              |'
'| modification, are permitted provided that the following conditions are met:     |'
'|                                                                                 |'
'| 1. Redistributions of source code must retain the above copyright notice, this  |'
'|    list of conditions and the following disclaimer.                             |'
'| 2. Redistributions in binary form must reproduce the above copyright notice,    |'
'|    this list of conditions and the following disclaimer in the documentation    |'
'|    and/or other materials provided with the distribution.                       |'
'|                                                                                 |'
'| THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" AND |'
'| ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED   |'
'| WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          |'
'| DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR |'
'| ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  |'
'| (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;    |'
'| LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND     |'
'| ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT      |'
'| (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   |'
'| SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                    |'
'+---------------------------------------------------------------------------------+'

Imports System.IO
Imports System.Security.Cryptography
Imports System.Runtime.InteropServices

Public Class Aes256Stream
    Inherits CryptoStream

#Region ""Fields""
    Private _underlyingStream As Stream
    Private AES As RijndaelManaged
    Private Transform As ICryptoTransform
#End Region

#Region ""Properties""
    ''' &lt;summary&gt;
    ''' Gets the block size, in bits, used by the stream's AES algorithm.
    ''' &lt;/summary&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    Public ReadOnly Property BlockSize As Integer
        Get
            Return AES.BlockSize
        End Get
    End Property

    ''' &lt;summary&gt;
    ''' Gets the key size, in bits, used by the stream's AES algorithm.
    ''' &lt;/summary&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    Public ReadOnly Property KeySize As Integer
        Get
            Return AES.KeySize
        End Get
    End Property

    ''' &lt;summary&gt;
    ''' Gets the length in bytes of the underlying stream.
    ''' &lt;/summary&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    Public Overrides ReadOnly Property Length As Long
        Get
            Return _underlyingStream.Length
        End Get
    End Property

    ''' &lt;summary&gt;
    ''' Gets or sets the position within the underlying stream.
    ''' &lt;/summary&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    Public Overrides Property Position As Long
        Get
            If _underlyingStream.CanSeek = False Then Throw New NotSupportedException(""The underlying stream doesn't support seeking!"")
            Return _underlyingStream.Position
        End Get
        Set(value As Long)
            If _underlyingStream.CanSeek = False Then Throw New NotSupportedException(""The underlying stream doesn't support seeking!"")
            _underlyingStream.Position = value
        End Set
    End Property

    ''' &lt;summary&gt;
    ''' Gets the underlying stream.
    ''' &lt;/summary&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    Public ReadOnly Property UnderlyingStream As Stream
        Get
            Return _underlyingStream
        End Get
    End Property
#End Region

#Region ""Constructors""
    Private Sub New(ByVal UnderlyingStream As Stream, _
                    ByVal AES As RijndaelManaged, _
                    ByVal CryptoTransform As ICryptoTransform, _
                    ByVal Mode As CryptoStreamMode)
        MyBase.New(UnderlyingStream, CryptoTransform, Mode)
        Me._underlyingStream = UnderlyingStream
        Me.AES = AES
        Me.Transform = CryptoTransform
    End Sub
#End Region

#Region ""Methods""

#Region ""Instance""
    ''' &lt;summary&gt;
    ''' Sets the length of the underlying stream.
    ''' &lt;/summary&gt;
    ''' &lt;param name=""value""&gt;The desired length of  underlying stream in bytes.&lt;/param&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;the
    Public Overrides Sub SetLength(value As Long)
        _underlyingStream.SetLength(value)
    End Sub
#End Region

#Region ""Shared""
    ''' &lt;summary&gt;
    ''' Creates an AES-256 encryption stream.
    ''' &lt;/summary&gt;
    ''' &lt;param name=""UnderlyingStream""&gt;The underlying stream to write the encrypted data to.&lt;/param&gt;
    ''' &lt;param name=""Key""&gt;The encryption key to use when encrypting the data (automatically padded or truncated to KeySize/8 bytes).&lt;/param&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    Public Shared Function CreateEncryptionStream(ByVal UnderlyingStream As Stream, ByVal Key As Byte()) As Aes256Stream
        Dim AES As New RijndaelManaged
        AES.KeySize = 256
        AES.BlockSize = 128

        AES.Key = Aes256Stream.PadOrTruncate(Key, AES.KeySize / 8)
        AES.GenerateIV()

        AES.Mode = CipherMode.CBC
        AES.Padding = PaddingMode.PKCS7

        'Write the IV to the underlying stream.
        If UnderlyingStream.CanWrite = True Then
            Dim LengthIV As Byte() = BitConverter.GetBytes(AES.IV.Length) 'Convert the IV.Length Integer to a byte array.
            UnderlyingStream.Write(LengthIV, 0, LengthIV.Length) 'Write the length of the IV.
            UnderlyingStream.Write(AES.IV, 0, AES.IV.Length) 'Write the IV.
        Else
            Throw New IOException(""Underlying stream is not writable!"")
        End If

        Return New Aes256Stream(UnderlyingStream, AES, AES.CreateEncryptor(), CryptoStreamMode.Write)
    End Function

    ''' &lt;summary&gt;
    ''' Creates an AES-256 decryption stream.
    ''' &lt;/summary&gt;
    ''' &lt;param name=""UnderlyingStream""&gt;The underlying stream to decrypt the data from.&lt;/param&gt;
    ''' &lt;param name=""Key""&gt;The encryption key to use when encrypting the data (automatically padded or truncated to KeySize/8 bytes).&lt;/param&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    Public Shared Function CreateDecryptionStream(ByVal UnderlyingStream As Stream, ByVal Key As Byte()) As Aes256Stream
        Dim AES As New RijndaelManaged
        AES.KeySize = 256
        AES.BlockSize = 128

        AES.Key = Aes256Stream.PadOrTruncate(Key, AES.KeySize / 8)

        'Read the IV from the underlying stream.
        If UnderlyingStream.CanRead = True Then
            Dim BytesReadIV As Integer = 0
            Dim BufferIV As Byte() = New Byte(Marshal.SizeOf(GetType(Integer)) - 1) {}
            Dim LengthIV As Integer

            'Read the IV's length.
            While BytesReadIV &lt; BufferIV.Length
                Dim BytesRead As Integer = UnderlyingStream.Read(BufferIV, BytesReadIV, BufferIV.Length - BytesReadIV)
                BytesReadIV += BytesRead

                If BytesRead = 0 AndAlso BytesReadIV &lt; BufferIV.Length Then _
                    Throw New IOException(""End of stream reached before IV could be parsed!"")
            End While

            'Convert the bytes to an Integer.
            LengthIV = BitConverter.ToInt32(BufferIV, 0)

            'Reset the variables.
            BytesReadIV = 0
            BufferIV = New Byte(LengthIV - 1) {}

            'Read the IV.
            While BytesReadIV &lt; BufferIV.Length
                Dim BytesRead As Integer = UnderlyingStream.Read(BufferIV, BytesReadIV, BufferIV.Length - BytesReadIV)
                BytesReadIV += BytesRead

                If BytesRead = 0 AndAlso BytesReadIV &lt; BufferIV.Length Then _
                    Throw New IOException(""End of stream reached before IV could be parsed!"")
            End While

            'Set the IV.
            AES.IV = BufferIV
        Else
            Throw New IOException(""Underlying stream is not readable!"")
        End If

        AES.Mode = CipherMode.CBC
        AES.Padding = PaddingMode.PKCS7

        Return New Aes256Stream(UnderlyingStream, AES, AES.CreateDecryptor(), CryptoStreamMode.Read)
    End Function

    Private Shared Function PadOrTruncate(ByVal Input As Byte(), ByVal PreferredLength As Integer) As Byte()
        If Input.Length &lt; PreferredLength Then 'Pad with zeros.
            Dim PreviousLength As Integer = Input.Length

            Array.Resize(Input, Input.Length + (PreferredLength - Input.Length))
            For i = PreviousLength To Input.Length - 1
                Input(i) = 0
            Next

            Return Input

        ElseIf Input.Length &gt; PreferredLength Then 'Truncate.
            Array.Resize(Input, PreferredLength)
            Return Input

        End If

        Return Input 'Do nothing.
    End Function
#End Region

#End Region

#Region ""Dispose()""
    Protected Overrides Sub Dispose(disposing As Boolean)
        MyBase.Dispose(disposing)
        If disposing Then
            Try
                If Transform IsNot Nothing Then
                    Transform.Dispose()
                    Transform = Nothing
                End If
            Catch
            End Try

            Try
                If AES IsNot Nothing Then
                    AES.Dispose()
                    AES = Nothing
                End If
            Catch
            End Try
        End If
    End Sub
#End Region

End Class
</code></pre>

<p>The two main things to remember are:</p>

<ul>
<li><p><code>CreateEncryptionStream()</code> creates a <strong>write only</strong> stream for performing encryption.</p></li>
<li><p><code>CreateDecryptionStream()</code> creates a <strong>read only</strong> stream for performing decryption.</p></li>
</ul>

<p><br/></p>

<h1>Performing encryption</h1>

<p>The simplest example of performing encryption only requires you to create a new <code>Aes256Stream</code> and write to it:</p>

<pre><code>Using AesStream As Aes256Stream = Aes256Stream.CreateEncryptionStream(&lt;output stream&gt;, &lt;encryption key&gt;)
    AesStream.Write(&lt;buffer&gt;, &lt;offset&gt;, &lt;length&gt;)
End Using
</code></pre>

<p><strong>Notes:</strong></p>

<ul>
<li><p><code>&lt;output stream&gt;</code> is the stream to encrypt the data <strong>to</strong> (for instance a <code>FileStream</code>).</p></li>
<li><p><code>&lt;encryption key&gt;</code> is the key (as a byte array) to use when encrypting the data.</p></li>
<li><p><code>&lt;buffer&gt;</code>, <code>&lt;offset&gt;</code> and <code>&lt;length&gt;</code> behave just like when you <a href=""https://msdn.microsoft.com/en-us/library/system.io.stream.write(v=vs.110).aspx"" rel=""nofollow noreferrer"">write to a regular stream</a>.</p></li>
</ul>

<p><br/></p>

<h1>Performing decryption</h1>

<p>Likewise the most simple example of performing decryption only requires you to create a new <code>Aes256Stream</code> and read from it:</p>

<pre><code>Using AesStream As Aes256Stream = Aes256Stream.CreateDecryptionStream(&lt;input stream&gt;, &lt;decryption key&gt;)

    Dim DecryptedData As Byte() = New Byte(AesStream.Length - 1) {}
    AesStream.Read(DecryptedData, 0, DecryptedData.Length)

End Using
</code></pre>

<p><strong>Notes:</strong></p>

<ul>
<li><p><code>&lt;input stream&gt;</code> is the stream to decrypt data <strong>from</strong> (for instance a <code>FileStream</code>).</p></li>
<li><p><code>&lt;decryption key&gt;</code> (same as <code>&lt;encryption key&gt;</code> above).</p></li>
<li><p><code>AesStream.Length</code> is equal to calling <code>&lt;input stream&gt;.Length</code> (same goes for <code>AesStream.Position</code> and <code>&lt;input stream&gt;.Position</code>).</p></li>
</ul>

<p><br/></p>

<h1>For your use</h1>

<p>Here's how you can adapt your code to work with it...</p>

<p>Methods:</p>

<pre><code>''' &lt;summary&gt;
''' Encrypts data to a file.
''' &lt;/summary&gt;
''' &lt;param name=""File""&gt;The file to encrypt data to.&lt;/param&gt;
''' &lt;param name=""Data""&gt;The data to encrypt.&lt;/param&gt;
''' &lt;param name=""Key""&gt;The key to use to perform the encryption.&lt;/param&gt;
''' &lt;remarks&gt;&lt;/remarks&gt;
Public Sub EncryptFile(ByVal File As String, ByVal Data As Byte(), ByVal Key As Byte())
    Using OutputStream As New FileStream(File, FileMode.Create, FileAccess.Write, FileShare.None)
        Using AesStream As Aes256Stream = Aes256Stream.CreateEncryptionStream(OutputStream, Key)
            AesStream.Write(Data, 0, Data.Length)
        End Using
    End Using
End Sub

''' &lt;summary&gt;
''' Decrypts a file and returns the decrypted data.
''' &lt;/summary&gt;
''' &lt;param name=""File""&gt;The file to decrypt.&lt;/param&gt;
''' &lt;param name=""Key""&gt;The key to use to perform the decryption.&lt;/param&gt;
''' &lt;remarks&gt;&lt;/remarks&gt;
Public Function DecryptFile(ByVal File As String, ByVal Key As Byte()) As Byte()
    Using InputStream As New FileStream(File, FileMode.Open, FileAccess.Read, FileShare.Read)
        Using DecryptedStream As New MemoryStream
            Using AesStream As Aes256Stream = Aes256Stream.CreateDecryptionStream(InputStream, Key)

                Dim Buffer As Byte() = New Byte(4096 - 1) {}
                While AesStream.Position &lt; AesStream.Length
                    Dim BytesRead As Integer = AesStream.Read(Buffer, 0, Buffer.Length)
                    DecryptedStream.Write(Buffer, 0, BytesRead)
                End While

                Return DecryptedStream.ToArray()

            End Using
        End Using
    End Using
End Function
</code></pre>

<p>Usage example:</p>

<pre><code>Dim Key As Byte() = System.Text.Encoding.UTF8.GetBytes(""verysecretpassword"") 'If you actually use a password here do hash it first!

Dim TextToEncrypt As String = ""Hello World! How are you?""
Dim DataToEncrypt As Byte() = System.Text.Encoding.UTF8.GetBytes(TextToEncrypt)

EncryptFile(""encrypted.txt"", DataToEncrypt, Key)

Dim DecryptedData As Byte() = DecryptFile(""encrypted.txt"", Key)
Dim DecryptedText As String = System.Text.Encoding.UTF8.GetString(DecryptedData)
</code></pre>

<p><br/></p>

<h1>Online test</h1>

<p>An online testable version of this code can be found here: <a href=""https://dotnetfiddle.net/PXaJF8"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/PXaJF8</a></p>
","446","<vb.net><encryption><rijndael>","-1","2","1","2017-09-04 23:05:19","46039488","6","","","","","2017-09-04 11:29:43",""
"25548907","rijndael_128 ruby without mcrypt","<p>Hello I have next implementation of rijdael_128 encyption/decription in ruby</p>

<pre><code>require 'mcrypt'
class Crypt

  attr_accessor :key, :iv

  def initialize(key, iv = nil)
    self.key = key
    self.iv = iv

    @enc = Mcrypt.new(:rijndael_128, :cbc, normalize_key, self.iv, :pkcs)
  end

  def encrypt(data)
    @enc.encrypt(data)
  end

  def decrypt(data)
    @enc.decrypt(data).gsub(/[^0-9#,]/, '') # clean up last \a symbols
  end

  protected
  def normalize_key

    return self.key if [16, 24, 32].include?(self.key.length)

    if self.key.length &lt; 16
      self.key.split.pack('a16')
    elsif self.key.length &lt; 24
      self.key.split.pack('a24')
    elsif self.key.length &lt; 32
      self.key.split.pack('a32')
    elsif self.key.length &gt; 32
      self.key[0..31]
    end
  end

end
</code></pre>

<p>Is there a way to implement this without mcrypt ? 
 want to use Cipher, however I have different results when key length > 16</p>

<pre><code>class Crypt2

  attr_accessor :key, :iv

  def initialize(key, iv = nil)
    self.key = key
    self.iv = iv
  end

   def encrypt(data)
        cipher = OpenSSL::Cipher.new('AES-128-CBC')
        cipher.encrypt
        cipher
        cipher.key = normalize_key
        cipher.iv = self.iv
        enc =  cipher.update(data)
        enc  &lt;&lt; cipher.final
    end

    protected
    def normalize_key

      return self.key if [16, 24, 32].include?(self.key.length)

      if self.key.length &lt; 16
        self.key.split.pack('a16')
      elsif self.key.length &lt; 24
        self.key.split.pack('a24')
      elsif self.key.length &lt; 32
        self.key.split.pack('a32')
      elsif self.key.length &gt; 32
        self.key[0..31]
      end
    end

end
</code></pre>

<p>Same results with key = ""1234567890""</p>

<pre><code>1.9.3-p547 :498 &gt; key = ""1234567890""
     =&gt; ""1234567890"" 
    1.9.3-p547 :499 &gt; iv 
     =&gt; ""0000001409228008"" 
    1.9.3-p547 :500 &gt; data
     =&gt; ""1409227523#143620#16502300493"" 
    1.9.3-p547 :501 &gt; Crypt.new(key,iv).encrypt(data)
     =&gt; ""\xFB\x16\a\xFF\x9ED\xA8\xD7\x1F=k\x8E\xFFH\xB0\x17\x84:\x1Fa\xB8s\x14\x97%S\xF3\x1E_\xDF\xBB\x19"" 
    1.9.3-p547 :502 &gt; Crypt2.new(key,iv).encrypt(data)
     =&gt; ""\xFB\x16\a\xFF\x9ED\xA8\xD7\x1F=k\x8E\xFFH\xB0\x17\x84:\x1Fa\xB8s\x14\x97%S\xF3\x1E_\xDF\xBB\x19"" 
</code></pre>

<p>Different results with larger key</p>

<pre><code>1.9.3-p547 :503 &gt; key = key * 2
         =&gt; ""12345678901234567890"" 
        1.9.3-p547 :504 &gt; Crypt.new(key,iv).encrypt(data)
         =&gt; ""\x1A\xE61\xD7\xC8;\xE0M\xFA\xD4~[\xBA7N\xD9\xB9\xE2\x94\x8C\xA89\x99\xD9}\x82,9\xFE\xF5\xFA\x00"" 
        1.9.3-p547 :505 &gt; Crypt2.new(key,iv).encrypt(data)
         =&gt; ""10X.\""\xF3\xC3RO`\t\x17\xB43\""r\x87s\xCF\xEA\x93Y4z\xCC\xC9\xAFA\xA1\x80\xC9\xF7"" 
</code></pre>
","<p>As I commented before, you are explicitly initializing <code>Cipher</code>/<code>mcrypt</code> with <code>AES-128</code>/<code>rijndael-128</code>. That means the encryption function expects a <em>key</em> with length <code>128 bit</code>/<code>16 bytes</code>.</p>

<p>It's behavior is undefined when you pass a larger <em>key</em>. (It could throw an error, could shrink the key, could do encryption with the larger key, or could do something else.)</p>

<p>It seems that <code>Cipher</code> and <code>mcrypt</code> handle this case differently and hence give different outputs.</p>

<hr>

<p><strong>Tests:</strong></p>

<p>I could not find any statement on that case in either of the docs and so did some research on my own.
For reference, this is the test-code I used:</p>

<pre><code>require ""rubygems""
require ""openssl""
require ""mcrypt""

def encryptOpenSSL(iv, key, data, key_length)
    cipher = OpenSSL::Cipher.new(""AES-"" + key_length.to_s + ""-CBC"")
    cipher.encrypt
    cipher.key = key
    cipher.iv = iv

    return (cipher.update(data) + cipher.final).unpack(""H*"").join()
end

def encryptMcrypt(iv, key, data)
    cipher = Mcrypt.new(:rijndael_128, :cbc, key, iv, :pkcs)

    return cipher.encrypt(data).unpack(""H*"").join()
end

# test parameters
data =   ""This is my test-data!""
key128 = ""1234567890123456""
key256 = ""1234567890123456abcdefghijklmnop""
iv  =    ""0987654321098765""

# tests
puts ""OpenSSL AES(128) key=128bit: "" + encryptOpenSSL(iv, key128, data, 128)
puts ""OpenSSL AES(128) key=256bit: "" + encryptOpenSSL(iv, key256, data, 128)
puts ""Mcrypt  AES(128) key=128bit: "" +  encryptMcrypt(iv, key128, data)
puts ""Mcrypt  AES(128) key=256bit: "" +  encryptMcrypt(iv, key256, data)
puts ""OpenSSL AES(256) key=256bit: "" + encryptOpenSSL(iv, key256, data, 256)
</code></pre>

<p>Which outputs for me (on <code>ruby 1.9.1</code>):</p>

<pre><code>""OpenSSL AES(128) key=128bit: adffaed8c94ede8aa61138b3fe500e30a0 ...""
""OpenSSL AES(128) key=256bit: adffaed8c94ede8aa61138b3fe500e30a0 ...""
""Mcrypt  AES(128) key=128bit: adffaed8c94ede8aa61138b3fe500e30a0 ...""
""Mcrypt  AES(128) key=256bit: b07776231d1bfbd2dfe3f8a62affdc4223 ...""
""OpenSSL AES(256) key=256bit: b07776231d1bfbd2dfe3f8a62affdc4223 ...""
</code></pre>

<p><strong>Conclusion:</strong></p>

<p>Looking at the test results, you can easily see that <code>Cipher</code> still uses only the first <code>128 bits</code> when you pass a larger <em>key</em> than expected.</p>

<p>Whereas <code>mcrypt()</code> performs <code>rijndael-256</code> encryption when you pass a <code>256 bit</code> <em>key</em> (even though you have set <code>rijndael-128</code> before).</p>

<hr>

<p><strong>Solution:</strong></p>

<p>Assuming you want <code>Cipher</code> to encrypt with <code>AES-256</code> when you pass a <code>256 bit</code> <em>key</em>, you could dynamically set the <code>key_size</code> depending on your input <code>key.length</code>. Like this:</p>

<pre><code># `* 8` to convert from `bytes` to `bits`
cipher = OpenSSL::Cipher.new('AES-' + (normalize_key.length * 8).to_s + '-CBC')
</code></pre>
","442","<ruby><encryption><jruby><mcrypt><rijndael>","1","3","1","2014-09-07 21:00:25","25603623","1","","","","","2014-08-28 12:30:42",""
"5565305","Several questions about rijndael in .net","<p>I need to consume a webservice exposed by another company.</p>

<p>They tell me to use Rijndael in OFB mode to encrypt the data I send them, but apparently, .Net (3.5) does not supports OFB for Rijndael. It tells me : <code>System.Security.Cryptography.CryptographicException: the (crypting?) mode is not valid for this algorithm</code> (approximate on-the-fly translation).</p>

<p>They gave me an IV that is 32 alphanumeric characters. I can't use it (using <code>System.Text.Encoding.ASCII.GetBytes(k)</code>), it tells me : <code>System.Security.Cryptography.CryptographicException: the specified initialization vector (IV) does not match the block size for this algorithm</code> (approximate on-the-fly translation). The key is the same length as the IV, and it works.</p>

<p>What can I do to make it work ?</p>

<p>Thanks</p>
","<p>You can use CBC mode to generate an OFB output by feeding your CBC method all 0s as plaintext input. Then manually xor the received keystream with your true plaintext. Actually, the diagrams on Wikipedia show quite nicely how this works, look <a href=""http://en.wikipedia.org/wiki/Output_feedback#Output_feedback_.28OFB.29"" rel=""nofollow"">here</a>.</p>
","441","<.net><encryption><rijndael>","1","3","1","2011-04-06 12:57:36","","6","0","6776","","2011-04-06 12:52:40","2011-04-06 11:05:35",""
"17025461","PHP MYCRYPT - RIJNDAEL_128 with Mcrypt CBC is giving incorrect output","<p>I am using a text</p>

<pre><code>const ENCRYPTION_KEY = '3aa22e01c04c7059778c54d122b0273689fba00f4a166a66d15f7ba6a8ba8743';
$str = ""1844427316My Name Is Dave1336407610774000000000000"";

function  encrypt($str){
trim(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128,ENCRYPTION_KEY, $str,MCRYPT_MODE_CBC,mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128,MCRYPT_MODE_CBC),MCRYPT_RAND))));
}

function decrypt($encryptedtext){
return trim(
        mcrypt_decrypt(
            MCRYPT_RIJNDAEL_128, 
            ENCRYPTION_KEY, 
            base64_decode($encryptedtext), 
            MCRYPT_MODE_CBC,
            mcrypt_create_iv(
                mcrypt_get_iv_size(
                    MCRYPT_RIJNDAEL_128,
                    MCRYPT_MODE_CBC
                ), 
                MCRYPT_RAND
            )
        )
        );
}
</code></pre>

<p>But whenever I refresh the page calling these function with values mentioned above, I get different values encryption, but in decryption, the initial decrypted value changes everytime but rest gets decrypted correctly like wise:</p>

<blockquote>
  <p>F7…Ÿ{4©eŠQ9­t¤e Is Dave1336407610774000000000000</p>
</blockquote>

<p>I have also refered the <a href=""https://stackoverflow.com/questions/6110627/php-mcrypt-cbc-mode-encryption-decryption-problem"">SIMILAR QUESTION</a> and used the ""iv"" function in decryption as well as answered in it</p>

<p>Could some one guide me whats getting wrong in here?</p>
","<p>It was thoughtful But I found the Solution:</p>

<p>While decrypting, I used the same IV and key as when encrypting.</p>

<p>My encrypt function needs to return the IV as well as the encrypted data. That IV is sent to the decrypt function with the data and the key.</p>

<p>See the below  Change in Code with complete code:</p>

<pre><code>class Encypt{

const ENCRYPTION_KEY = '3aa22e01c04c7059778c54d122b0273689fba00f4a166a66d15f7ba6a8ba8743';


function createQueryString(){
$str = ""1844427316My Name Is Dave1336407610774000000000000"";
$encStr = $this-&gt;encrypt($str);

return $encStr;
}

function encrypt($strValue){
$iv =mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128,MCRYPT_MODE_CBC),MCRYPT_RAND);
$encData = trim(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128,self::ENCRYPTION_KEY, $strValue,MCRYPT_MODE_CBC,$iv)));
            $data['iv'] = $iv;
            $data['encdata'] = $encData;

            return $data;
}
 /**
     *  Function to decrypt data using AES Encryption Symmetric Algorithm 128 bytes
     */
    function decrypt($strValue, $iv){
            return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128,ENCRYPTION_KEY,base64_decode($strValue),MCRYPT_MODE_CBC,$iv));
    }

}    
$enc_obj = new Encypt();

$encstr = $enc_obj-&gt;createQueryString();

echo ""Encrypted Str:--&gt;"".$encstr['encdata'].""&lt;br&gt;"";
$deCrypt = $enc_obj-&gt;decrypt($encstr['encdata'], $encstr['iv']);
echo ""Decrypted Str:--&gt;"".$deCrypt;
</code></pre>
","428","<php><mcrypt><rijndael><cbc-mode>","2","2","1","2013-10-11 16:12:58","17027311","5","1","-1","","2017-05-23 11:43:17","2013-06-10 13:48:22",""
"42138800","C# Encryption using RijndaelManaged - Save file in base64 format","<p><strong>Scenario</strong> - I have multiple files on my server and as per policy we can keep only encrypted files. We are doing some data migration, for this we have to move these files on to cloud and as per documentations Base64 is the best way to transfer encrypted data over network. I am new in encryption and stuck between this. Let me know if this help you.</p>

<p>How to save file in base64 format?</p>

<p>================================================================</p>

<p>I am new in Encryption and got below code from net and trying to encrypting files using <code>RijndaelManaged</code> and the following code is working fine</p>

<pre><code>public static void EncryptFile(string inputFile, string outputFile)
{

        try
        {
            string password = @""myKey123""; // Your Key Here
            UnicodeEncoding UE = new UnicodeEncoding();
            byte[] key = UE.GetBytes(password);

            string cryptFile = outputFile;
            FileStream fsCrypt = new FileStream(cryptFile, FileMode.Create);

            RijndaelManaged RMCrypto = new RijndaelManaged();

            CryptoStream cs = new CryptoStream(fsCrypt,
                RMCrypto.CreateEncryptor(key, key),
                CryptoStreamMode.Write);

            FileStream fsIn = new FileStream(inputFile, FileMode.Open);

            int data;
            while ((data = fsIn.ReadByte()) != -1)
                cs.WriteByte((byte)data);


            fsIn.Close();
            cs.Close();
            fsCrypt.Close();
        }
        catch
        {
        }
    }
</code></pre>

<p>When I try to decrypt using <code>Convert.FromBase64String</code>, it returns an error</p>

<pre><code>public static string DecryptFile(string inputFile)
        {
            var myRijndael = new RijndaelManaged { Key = _key, IV = _key, Padding = PaddingMode.PKCS7 };
            _decryptor = myRijndael.CreateDecryptor(myRijndael.Key, myRijndael.IV);

            // Create the streams used for decryption.
            using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(inputFile)))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, _decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {
                        return srDecrypt.ReadToEnd();
                    }
                }
            }
        }
</code></pre>

<p>Please help me to solve this issue</p>
","","424","<c#><encryption><rijndael><rijndaelmanaged>","1","","0","2017-02-10 19:15:14","","18","","2596475","","2017-02-10 19:05:06","2017-02-09 14:05:56",""
"54649894","Rijndael 256 CBC PKCS7 Encryption/Decryption in NodeJS","<p>I am building a NodeJS client for a service that encrypts data using 256 bits block Rijndael CBC with PKCS7 padding.</p>

<p>I have looked at a couple of Rijndael implementations in NodeJS but none seems to offer a combination that I am looking for.</p>

<p>Any recommendations how this can be achieved in NodeJS?</p>
","<p>I am posting the solution here that I was able to find in case someone comes across the same issue in the future.</p>

<p>It is actually pretty easy to encrypt/decrypt using Rijndael 256 block size with PKCS7 padding by combining two modules <code>rijndael-js</code> and <code>pkcs7-padding</code> that available from NPM registry.</p>

<p><code>rijndael-js</code> module allows you to encrypt/decrypt using various block sizes: 128, 256 and 192 block sizes - however, it only support zero padding. No PKCS7 padding support is provided. So you will either need to rely on another module for PKCS7 padding, or do it yourself (at it is not that difficult either).</p>

<p><code>rijndael-js</code> will only zero pad the plaintext (data to be encrypted) if its length is not the multiple of the block size. To prevent it from zero-padding your data, must first pad the plaintext before encrypting it. In the example below, I use <code>pkcs7-padding</code> module from npm for that.</p>

<p><code>nmp install rijndael-js pkcs7-padding --save</code></p>

<p><strong>This is how you encrypt data</strong></p>

<pre><code>const Rijndael = require('rijndael');
const padder = require('pkcs7-padding');
const crypto = require('crypto');

const plainText = Buffer.from('Here is my plain text', 'utf8');
//Pad plaintext before encryption
const padded = padder.pad(plainText, 32); //Use 32 = 256 bits block sizes

const key = crypto.randomBytes(32); //32 bytes key length
const iv = crypto.randomBytes(32); //32 bytes IV

const cipher = new Rijndael(key, 'cbc'); //CBC mode
const encrypted = cipher.encrypt(padded, 256, iv);
</code></pre>

<p><strong>This is how to decrypt data</strong></p>

<pre><code>const encrypted = ... //holds our encrypted data
const key = ... // holds our 32 bytes key
const iv = ... //holds our 32 bytes iv

const decipher = new Rijndael(key, 'cbc');
const decryptedPadded = decipher.decrypt(encrypted, 256, iv);
//Remember to un-pad result
const decrypted = padder.unpad(decryptedPadded, 32);
const clearText = decrypted.toString('utf8');

console.log(clearText); //-&gt; Here is my plain text
</code></pre>
","419","<node.js><rijndael>","0","1","1","2019-02-16 10:22:30","","0","","3834694","","2019-02-16 09:54:50","2019-02-12 12:13:15",""
"37137536","C# Encryption System.Security.Cryptography.CryptographicException at CryptoStream.close()","<p>im trying to write an En-/Decrypter in C#. As the title suggests I get a System.Security.Cryptography.CryptographicException at CryptoStream.close(). I haven't find a solution yet. Hope anyone can help.</p>

<pre><code>public static string viaRijndael(byte[] input, string key, string iV)
    {
        Rijndael RijCrypt = Rijndael.Create();

        RijCrypt.Key = System.Text.Encoding.UTF8.GetBytes(Tools.GetMD5Hash(Tools.GetMD5Hash(key))); 

        RijCrypt.IV = System.Text.Encoding.UTF8.GetBytes(Tools.GetMD5Hash(Tools.GetMD5Hash(key)).Substring(0, 16));

        MemoryStream ms = new MemoryStream();
        CryptoStream cs = new CryptoStream(ms, RijCrypt.CreateDecryptor(), CryptoStreamMode.Write); 

        cs.Write(input, 0, input.Length); 
        cs.Close(); // System.Security.Cryptography.CryptographicException

        byte[] DecryptedBytes = ms.ToArray();

        return System.Text.Encoding.UTF8.GetString(DecryptedBytes);
    }
</code></pre>
","<p>MSDN <a href=""https://msdn.microsoft.com/en-us/library/system.io.stream.close(v=vs.110).aspx"" rel=""nofollow"">Stream.Close</a> documentation says:</p>

<blockquote>
  <p>""This method calls Dispose, specifying true to release all resources. You do not have to specifically call the Close method. Instead, ensure that every Stream object is properly disposed. You can declare Stream objects within a using block (or Using block in Visual Basic) to ensure that the stream and all of its resources are disposed, or you can explicitly call the Dispose method.""  </p>
</blockquote>

<p>As such I would suggest trying something like the following to handle the disposal of your streams:</p>

<pre><code>public static string viaRijndael(byte[] input, string key, string iV)
{
    byte[] decryptedBytes;

    using (Rijndael rijCrypt = Rijndael.Create())
    {
        rijCrypt.Key = System.Text.Encoding.UTF8.GetBytes(Tools.GetMD5Hash(Tools.GetMD5Hash(key))); 

        rijCrypt.IV = System.Text.Encoding.UTF8.GetBytes(Tools.GetMD5Hash(Tools.GetMD5Hash(key)).Substring(0, 16));

        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, rijCrypt.CreateDecryptor(), CryptoStreamMode.Write))
            {
                cs.Write(input, 0, input.Length); 
            }

            decrpytedBytes = ms.ToArray();
        }
    }

    return System.Text.Encoding.UTF8.GetString(decryptedBytes);
}
</code></pre>

<p>All of this and more is explained in good detail on MSDN for the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.cryptostream(v=vs.110).aspx"" rel=""nofollow"">CryptoStream</a> class. </p>
","410","<c#><exception><encryption><rijndael>","1","0","1","2016-05-10 16:30:49","37144196","3","","","","","2016-05-10 11:43:15",""
"5775504","Rijndael AES encryption algorithm doesn't work on BlackBerry","<p>I am using Rijndael AES encryption algorithm in my RhoMobile Development for
Android and BlackBerry.</p>

<p>It is working on Android, but for BlackBerry I can't get the exact encrypted text.</p>
","","401","<blackberry><encryption><java-me><aes><rijndael>","1","","0","2011-07-13 09:29:57","","2","","75204","","2011-04-25 18:09:20","2011-04-25 05:30:43",""
"9210153","How to code a decryption method for the encryption method here in c#","<p>I was able to put together a encryption sample like below but during decryption i get invalid data(Exception). How am i supposed to decrypt </p>

<h3>Encryption Method</h3>

<pre><code>public static string EncryptWithAes(string plainText, byte[] key, byte[] initiationVector)
        {

            byte[] cryptoBytes = Encoding.UTF8.GetBytes(plainText);

            using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
            {
                aesAlgorithm.Key = key;
                aesAlgorithm.IV = initiationVector;
                aesAlgorithm.Mode = CipherMode.ECB;
                using (ICryptoTransform encryptoTransform = aesAlgorithm.CreateEncryptor(aesAlgorithm.Key, aesAlgorithm.IV))
                {
                    cryptoBytes = encryptoTransform.TransformFinalBlock(cryptoBytes, 0, cryptoBytes.Length);
                }
            }
            return Convert.ToBase64String(cryptoBytes);
        }
</code></pre>

<h3>Decryption Method</h3>

<pre><code> public static string DecryptAesCryptoString(string cipherText, byte[] key, byte[] initiationVector)
        {
            byte[] decryptedByte;
            using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
            {
                aesAlgorithm.Key = key;
                aesAlgorithm.IV = initiationVector;
                aesAlgorithm.Mode = CipherMode.ECB;

                using (ICryptoTransform decryptoTransform = aesAlgorithm.CreateDecryptor(aesAlgorithm.Key, aesAlgorithm.IV))
                {
                    byte[] cipherBytes = Convert.FromBase64String(cipherText);
                    decryptedByte = decryptoTransform.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);

                }
            }
            return Encoding.UTF8.GetString(decryptedByte);
        }
</code></pre>

<p>i think the problem is with all the encoding that are going inside these methods</p>

<h3>Sample Data</h3>

<p>plainText = stackoverflow</p>

<p><code>base64encoded Key = B8Y/6doxwqU870C6jzYWhsr3hKSLokAOkkLCDiy+TS4=</code>
(should be easy to convert to bytes ain't it)</p>

<p><code>base64encoded IV = NZIpD60eBmdsOFFhA2bfvw==</code></p>

<p><code>encryptedValue = 77+977+977+977+977+9Ce+/ve+/vQ3vv70F77+9UzHvv73vv70=</code></p>

<p>I provide same encrypted value , IV and Key to decrypt to Stackoverflow</p>
","<p>Why you don't give a try by removing the Encoding ?
<a href=""http://www.obviex.com/samples/Encryption.aspx"" rel=""nofollow"">Here's a simple implementation</a> : </p>

<pre><code>public class RijndaelSimpleTest
{
    /// &lt;summary&gt;
    /// The main entry point for the application.
    /// &lt;/summary&gt;
    [STAThread]
    static void Main(string[] args)
    {
        string   plainText          = ""Hello, World!"";    // original plaintext

        string   passPhrase         = ""Pas5pr@se"";        // can be any string
        string   saltValue          = ""s@1tValue"";        // can be any string
        string   hashAlgorithm      = ""SHA1"";             // can be ""MD5""
        int      passwordIterations = 2;                  // can be any number
        string   initVector         = ""@1B2c3D4e5F6g7H8""; // must be 16 bytes
        int      keySize            = 256;                // can be 192 or 128

        Console.WriteLine(String.Format(""Plaintext : {0}"", plainText));

        string  cipherText = RijndaelSimple.Encrypt(plainText,
                                                    passPhrase,
                                                    saltValue,
                                                    hashAlgorithm,
                                                    passwordIterations,
                                                    initVector,
                                                    keySize);

        Console.WriteLine(String.Format(""Encrypted : {0}"", cipherText));

        plainText          = RijndaelSimple.Decrypt(cipherText,
                                                    passPhrase,
                                                    saltValue,
                                                    hashAlgorithm,
                                                    passwordIterations,
                                                    initVector,
                                                    keySize);

        Console.WriteLine(String.Format(""Decrypted : {0}"", plainText));
    }
}
</code></pre>
","397","<c#><.net><aes><sample><rijndael>","-1","0","3","2012-02-09 12:33:10","9210706","3","","571507","","2012-02-09 11:53:14","2012-02-09 11:35:40",""
"9210153","How to code a decryption method for the encryption method here in c#","<p>I was able to put together a encryption sample like below but during decryption i get invalid data(Exception). How am i supposed to decrypt </p>

<h3>Encryption Method</h3>

<pre><code>public static string EncryptWithAes(string plainText, byte[] key, byte[] initiationVector)
        {

            byte[] cryptoBytes = Encoding.UTF8.GetBytes(plainText);

            using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
            {
                aesAlgorithm.Key = key;
                aesAlgorithm.IV = initiationVector;
                aesAlgorithm.Mode = CipherMode.ECB;
                using (ICryptoTransform encryptoTransform = aesAlgorithm.CreateEncryptor(aesAlgorithm.Key, aesAlgorithm.IV))
                {
                    cryptoBytes = encryptoTransform.TransformFinalBlock(cryptoBytes, 0, cryptoBytes.Length);
                }
            }
            return Convert.ToBase64String(cryptoBytes);
        }
</code></pre>

<h3>Decryption Method</h3>

<pre><code> public static string DecryptAesCryptoString(string cipherText, byte[] key, byte[] initiationVector)
        {
            byte[] decryptedByte;
            using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
            {
                aesAlgorithm.Key = key;
                aesAlgorithm.IV = initiationVector;
                aesAlgorithm.Mode = CipherMode.ECB;

                using (ICryptoTransform decryptoTransform = aesAlgorithm.CreateDecryptor(aesAlgorithm.Key, aesAlgorithm.IV))
                {
                    byte[] cipherBytes = Convert.FromBase64String(cipherText);
                    decryptedByte = decryptoTransform.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);

                }
            }
            return Encoding.UTF8.GetString(decryptedByte);
        }
</code></pre>

<p>i think the problem is with all the encoding that are going inside these methods</p>

<h3>Sample Data</h3>

<p>plainText = stackoverflow</p>

<p><code>base64encoded Key = B8Y/6doxwqU870C6jzYWhsr3hKSLokAOkkLCDiy+TS4=</code>
(should be easy to convert to bytes ain't it)</p>

<p><code>base64encoded IV = NZIpD60eBmdsOFFhA2bfvw==</code></p>

<p><code>encryptedValue = 77+977+977+977+977+9Ce+/ve+/vQ3vv70F77+9UzHvv73vv70=</code></p>

<p>I provide same encrypted value , IV and Key to decrypt to Stackoverflow</p>
","<p>I think your problem is the length of your IV and maybe the key. The IV should be 16 bytes long as i recall, the key has different options, you should look that up.</p>

<p>//TEST:</p>

<pre><code>        RijndaelManaged alg = new RijndaelManaged();

        alg.GenerateKey();
        alg.GenerateIV();

        byte[] key = alg.Key;
        byte[] iv = alg.IV;

        string text = ""teststring"";

        string encrypted = EncryptWithAes(text, key, iv);

        MessageBox.Show(encrypted);

        String result = DecryptAesCryptoString(encrypted, key, iv);

        MessageBox.Show(result);
</code></pre>
","397","<c#><.net><aes><sample><rijndael>","-1","1","3","2012-02-09 12:33:10","9210706","3","","571507","","2012-02-09 11:53:14","2012-02-09 11:35:40",""
"9210153","How to code a decryption method for the encryption method here in c#","<p>I was able to put together a encryption sample like below but during decryption i get invalid data(Exception). How am i supposed to decrypt </p>

<h3>Encryption Method</h3>

<pre><code>public static string EncryptWithAes(string plainText, byte[] key, byte[] initiationVector)
        {

            byte[] cryptoBytes = Encoding.UTF8.GetBytes(plainText);

            using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
            {
                aesAlgorithm.Key = key;
                aesAlgorithm.IV = initiationVector;
                aesAlgorithm.Mode = CipherMode.ECB;
                using (ICryptoTransform encryptoTransform = aesAlgorithm.CreateEncryptor(aesAlgorithm.Key, aesAlgorithm.IV))
                {
                    cryptoBytes = encryptoTransform.TransformFinalBlock(cryptoBytes, 0, cryptoBytes.Length);
                }
            }
            return Convert.ToBase64String(cryptoBytes);
        }
</code></pre>

<h3>Decryption Method</h3>

<pre><code> public static string DecryptAesCryptoString(string cipherText, byte[] key, byte[] initiationVector)
        {
            byte[] decryptedByte;
            using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
            {
                aesAlgorithm.Key = key;
                aesAlgorithm.IV = initiationVector;
                aesAlgorithm.Mode = CipherMode.ECB;

                using (ICryptoTransform decryptoTransform = aesAlgorithm.CreateDecryptor(aesAlgorithm.Key, aesAlgorithm.IV))
                {
                    byte[] cipherBytes = Convert.FromBase64String(cipherText);
                    decryptedByte = decryptoTransform.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);

                }
            }
            return Encoding.UTF8.GetString(decryptedByte);
        }
</code></pre>

<p>i think the problem is with all the encoding that are going inside these methods</p>

<h3>Sample Data</h3>

<p>plainText = stackoverflow</p>

<p><code>base64encoded Key = B8Y/6doxwqU870C6jzYWhsr3hKSLokAOkkLCDiy+TS4=</code>
(should be easy to convert to bytes ain't it)</p>

<p><code>base64encoded IV = NZIpD60eBmdsOFFhA2bfvw==</code></p>

<p><code>encryptedValue = 77+977+977+977+977+9Ce+/ve+/vQ3vv70F77+9UzHvv73vv70=</code></p>

<p>I provide same encrypted value , IV and Key to decrypt to Stackoverflow</p>
","<p>and sadly this was certainly due to the Encoding problem. Now solved it like below</p>

<h3>Encryption</h3>

<pre><code>public static string EncryptWithAes(string plainText, byte[] key, byte[] initiationVector)
        {
            byte[] cryptoBytes = Convert.FromBase64String(plainText);
            using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
            {
                aesAlgorithm.Key = key;
                aesAlgorithm.IV = initiationVector;
                aesAlgorithm.Mode = CipherMode.ECB;
                using (ICryptoTransform encryptoTransform = aesAlgorithm.CreateEncryptor(aesAlgorithm.Key, aesAlgorithm.IV))
                {
                    cryptoBytes = encryptoTransform.TransformFinalBlock(cryptoBytes, 0, cryptoBytes.Length);
                }
            }
            return Convert.ToBase64String(cryptoBytes);
        }
</code></pre>

<h3>Decryption</h3>

<pre><code>public static string DecryptAesCryptoString(string cipherText, byte[] key, byte[] initiationVector)
{

    byte[] decryptedByte;
    using (RijndaelManaged aesAlgorithm = new RijndaelManaged())
    {
        aesAlgorithm.Key = key;
        aesAlgorithm.IV = initiationVector;
        aesAlgorithm.Mode = CipherMode.ECB;
        using (ICryptoTransform decryptoTransform = aesAlgorithm.CreateDecryptor(aesAlgorithm.Key, aesAlgorithm.IV))
        {
            byte[] cipherBytes = Convert.FromBase64String(cipherText);
            decryptedByte = decryptoTransform.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);

        }
    }
    return Convert.ToBase64String(decryptedByte);
}
</code></pre>
","397","<c#><.net><aes><sample><rijndael>","-1","1","3","2012-02-09 12:33:10","9210706","3","","571507","","2012-02-09 11:53:14","2012-02-09 11:35:40",""
"3107540","C# Public Key verify Perl Private key and use as AES key ? Possible and/or viable?","<p>i was thinking if it is possible and/or viable for obfuscation and security to do as the follow:</p>

<ul>
<li>Client start session with Server (which means a valid login and password was sent and accepted)</li>
<li>Server encrypt a random password with it is Private Key that will then be used into a data encryption using Rijndael's method and send both back to the client (The password which is the encrypted random password and the Rijndael's encrypt data which is what we want for the client to work)</li>
<li>Client will receive both, verify the password to see wether it was encrypt with our pair of keys or not if so it will be used to decrypt the data.</li>
</ul>

<p>From what i see, Rijndael has some restrictions as of the password size, so would this be even possible (considering the output of the encrypted random password) ??</p>

<p>Is there antoher approuch that would be close to what i was thinking or trying to describe here ?</p>

<p>Is this even worthed ?</p>

<p>The reason i wanted something like this is mostly to make it harder for anyone trying to reproduce what our server communicates with the client, aside from that we use Smart Assembly. I would like you guys to focus on the questions above and forget about packing my code etc. Think of this as a client / server communication security messure if possible.</p>

<p>Best regards.</p>
","<p>I can address the first part. If the server encrypts a key with their private key, ANYONE with their public key will be able to decrypt it. This leaves a gaping hole open for a man-in-the-middle attack. In other words, if I intercept the same token you do, I now know the same key that you know. This means that I can see all the traffic that is going back and forth.</p>

<p>The crux of security has always been this initial key-exchange problem. You may want to employ an industry-standard approach, like Diffie-Helman for the actual key exchange. Hope that helps</p>
","396","<c#><perl><encryption><rsa><rijndael>","1","1","1","2010-06-24 06:14:15","3107596","0","","","","","2010-06-24 05:59:50",""
"13469089","PHP Decryption of Rijndael 256 from .NET","<p>I am getting a base64 encoded Token from a .NET Website and wish to decode it in PHP. I received the Key and the IV from the programmer but I can't get the decryption to work. I read a lot about problems with padding but none of the suggested solutions seemed to work for my problem - I just can't get the text decrypted.</p>

<pre><code>function decryptToken($decoded, $key, $iv){

    $decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $decoded,
            MCRYPT_MODE_CBC, $iv);

    return $decrypted;
}
</code></pre>

<p>The parameters are the base64_decode($token) and the decoded Key and IV. </p>

<p>Any suggestions?</p>
","","385","<php><encryption><rijndael>","1","","0","2012-11-20 08:21:36","","7","","","","","2012-11-20 08:21:36",""
"37135829","Encrypt from Java and decrypt in PHP (RIJNDAEL)","<p>I have to connect from a Java Desktop application and Android app to a Webservice. I need to send the login encrypted with RIJNDAEL but I am experiencing problems.</p>

<p>Code in Java:</p>

<pre><code>public static String getEncryptedLogin(String loginID, String encryptionKey) {
    byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""RIJNDAEL"");

    AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);
    byte[] result = cipher.doFinal(loginID.getBytes(""UTF-8""));
    return Base64.getEncoder().encodeToString(result);
}
</code></pre>

<p>And called this way.</p>

<pre><code>String dataToSend = ""login=""+Testencrypted.getEncryptedLogin(LOGIN,WS_ENCKEY)+""&amp;language=en"";
</code></pre>

<p>On WS_ENCKEY is a String with key (32chars) for encryption.</p>

<p>When I execute the Java code I get an Exception error ""Illegal Key Size"", so after reading in others post in this website, RIJNDAEL needs a 128 bit key, so I change the way I call encryption method to</p>

<pre><code>String dataToSend = ""login=""+Testencrypted.getEncryptedLogin(LOGIN,WS_ENCKEY.substring(0,16))+""&amp;language=en"";
</code></pre>

<p>On Server side I have this PHP code to decrypt:</p>

<pre><code>&lt;?php
class Encrypter {
    public static function encrypt($text,$key) {
        $textenc = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $text, MCRYPT_MODE_ECB);
        return base64_encode($textenc);
    }
    public static function decrypt($text,$key) {
        return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, base64_decode($text), MCRYPT_MODE_ECB));
    }
}
</code></pre>

<p>In server I receive the correct data, but when I try to decrypt the login, the output is not the same.</p>

<p>I can't change the code on server side, can you help me?</p>
","<p>PHP mcrypt does not support PKCS5 padding, only null padding. You will have to select no padding in Java and null pad the input data on encryption to a multiple of the block size and remove the nulls on decryption in Java.</p>

<p>The PHP mcrypt server code is using ECB mode which is insecure, to be compatible  Java will also need to specify ECB mode, not CBC mode. ECB mode does not use an IV.</p>
","380","<java><php><rijndael>","-1","0","1","2016-05-10 13:25:49","","1","2","2835286","","2016-05-10 11:43:40","2016-05-10 10:27:44",""
"28296275","How to encrypt Rijndael encoded data in a socket programming?","<p>I am researching and studying about encryption and decryption in <code>rijndael</code> and <code>AES</code>. I have a question.how should we decrypt data in <code>socket programming</code> ? how should we send and use <code>KEY</code> and <code>IV</code> in a client and server program. I`ve read these codes in MSDN but in this example all codes are are run on one file and Key and IV is generated in the same place but I don't know how should we transmit a KEY and IV to server in a safe and secure manner...thanks a lot.</p>

<p>here is also MSDN example :</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;

namespace RijndaelManaged_Example
{
    class RijndaelExample
    {
        public static void Main()
        {
            try
            {



            string original = ""Here is some data to encrypt!"";

            // Create a new instance of the RijndaelManaged 
            // class.  This generates a new key and initialization  
            // vector (IV). 
            using (RijndaelManaged myRijndael = new RijndaelManaged())
            {

                myRijndael.GenerateKey();
                myRijndael.GenerateIV();
                // Encrypt the string to an array of bytes. 
                byte[] encrypted = EncryptStringToBytes(original, myRijndael.Key, myRijndael.IV);

                // Decrypt the bytes to a string. 
                string roundtrip = DecryptStringFromBytes(encrypted, myRijndael.Key, myRijndael.IV);

                //Display the original data and the decrypted data.
                Console.WriteLine(""Original:   {0}"", original);
                Console.WriteLine(""Round Trip: {0}"", roundtrip);
            }

        }
        catch (Exception e)
        {
            Console.WriteLine(""Error: {0}"", e.Message);
        }
    }
    static byte[] EncryptStringToBytes(string plainText, byte[] Key, byte[] IV)
    {
        // Check arguments. 
        if (plainText == null || plainText.Length &lt;= 0)
            throw new ArgumentNullException(""plainText"");
        if (Key == null || Key.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        if (IV == null || IV.Length &lt;= 0)
            throw new ArgumentNullException(""IV"");
        byte[] encrypted;
        // Create an RijndaelManaged object 
        // with the specified key and IV. 
        using (RijndaelManaged rijAlg = new RijndaelManaged())
        {
            rijAlg.Key = Key;
            rijAlg.IV = IV;

            // Create a decrytor to perform the stream transform.
            ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

            // Create the streams used for encryption. 
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {

                        //Write all data to the stream.
                        swEncrypt.Write(plainText);
                    }
                    encrypted = msEncrypt.ToArray();
                }
            }
        }


        // Return the encrypted bytes from the memory stream. 
        return encrypted;

    }

    static string DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV)
    {
        // Check arguments. 
        if (cipherText == null || cipherText.Length &lt;= 0)
            throw new ArgumentNullException(""cipherText"");
        if (Key == null || Key.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        if (IV == null || IV.Length &lt;= 0)
            throw new ArgumentNullException(""IV"");

        // Declare the string used to hold 
        // the decrypted text. 
        string plaintext = null;

        // Create an RijndaelManaged object 
        // with the specified key and IV. 
        using (RijndaelManaged rijAlg = new RijndaelManaged())
        {
            rijAlg.Key = Key;
            rijAlg.IV = IV;

            // Create a decrytor to perform the stream transform.
            ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

            // Create the streams used for decryption. 
            using (MemoryStream msDecrypt = new MemoryStream(cipherText))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {

                        // Read the decrypted bytes from the decrypting stream 
                        // and place them in a string.
                        plaintext = srDecrypt.ReadToEnd();
                    }
                }
            }

        }

        return plaintext;

    }
}
</code></pre>

<p>}</p>
","","380","<c#><sockets><rijndael>","0","","0","2015-02-03 10:11:48","","9","","","","","2015-02-03 10:11:48",""
"25614899","Decryption of base64 encoded data objective-C","<p>I have been working on this for a while, but can not find a way to tackle the problem. Hopefully one of you can tell me what I am missing.  </p>

<p>I am using NSURLConnection to download base64 encoded data containing AES128 encrypted data. What I have is the key, see code, and the knowledge that the first 16 characters of the encrypted data is the IV. What I want is to decode the data and then decrypt it using the key and iv extracted. This is what I have so far:</p>

<pre><code>    - (void) connectionDidFinishLoading:(NSURLConnection *) connection {
        NSLog(@""Succeeded! Downloaded %d bytes of data"", downloadData.length);
        NSData *decoded_EncryptedData = [downloadData base64EncodedDataWithOptions:0];
        NSString *decoded_EncryptedString = [[NSString alloc] initWithData: decoded_EncryptedData encoding:NSUTF8StringEncoding];
        const void *key = @""0000000000000000000000000000000""; // key of length 32 char -&gt; i know standard format for AES128 encryption is 16, maybe this requires 256 AES decryption
        const void *iv = (__bridge const void *)([decoded_EncryptedString substringWithRange:NSMakeRange(0,16)]);
        NSString *encryptedString = [decoded_EncryptedString substringWithRange:NSMakeRange(16, decoded_EncryptedString.length-16)];

        // Now I have no idea what needs to happen, but from online research I found it should be something like this:
        NSData encryptedData = [encryptedString dataUsingEncoding:NSUTF8StringEncoding]; // Writing it back into a data file
        // Find size of returned data
        size_t Size = encryptedData.length + kCCBlockSizeAES128;
        // Initialise returned data
        NSMutableData *decryptedData = [NSMutableData dataWithLength:Size];
        // allocate variable to numBytesDecrypted
        size_t numBytesDecrypted;

        CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, 0, KCCKeySizeAES128, iv,
                    [encryptedData bytes], [encryptedData length], [decryptedData bytes], [decryptedData length],
                    &amp;numBytesDecrypted);

        // Now I test whether the decryption process was successful:
        if (cryptStatus == kCCSuccess) {
                NSLog(@""Successfully decrypted);
                NSString *decryptedString = [[NSString alloc] initWithData:decryptedData encoding: NSUTF8StringEncoding]; 
        }

    }
</code></pre>

<p>The above code does display Successfully decrypted, however the string return null and size 0. Could someone please help me solve this? I would be so grateful.</p>

<p>Kind regards,
Lennaert</p>
","<p>You have many problems.</p>

<ol>
<li><p>You really need to know if the encryption is AES128 or AES256.</p></li>
<li><p>Encryption is data based, not string based. The conversion to a string <code>decoded_EncryptedString</code> is incorrect not should not be done.</p></li>
<li><p>The key is an issue, using a string is generally a bad idea, it is expected to be data bytes. Possibly the key is specified in hex so 32 hex characters would be 128 bits. If so conversion to data will be required.</p></li>
<li><p>'iv' and <code>encryptedString</code> are strings but they should be data, this a result of 2 above.</p></li>
<li><p>The key is not passed to <code>CCCrypt</code>.</p></li>
<li><p>Padding is generally used since the data is rarely exactly a block size in length, you probably need to specify <code>PKCS7</code> padding to <code>CCCrypt</code>. You need to know if padding was used and if so was it <code>PKCS7</code>, php for example uses non-standard padding.</p></li>
<li><p>If PKCS7 padding is used the result must be trimmed to the length based on the variable <code>numBytesDecrypted</code>. If some other padding is used that must be trimmed.</p></li>
</ol>

<p>If you want more help please supply test data and the result.</p>

<p>Finally, try and check back more frequently.</p>
","372","<objective-c><encryption><base64><rijndael>","-1","0","1","2014-09-02 11:56:14","","1","","","","","2014-09-02 02:08:42",""
"9219192","Inconsitent behaviour with RijndaelManaged encryption","<p>I am experiencing a strange problem with RijndaelManaged. Basically I have a new instance of it where I set up the CipherMode, Padding, IV and Key. Then I create another instance and assign the same values of the following properties from the original instance to the 2nd instance: Mode, Padding, KeySize, FeedbackSize, BlockSize, IV and Key.</p>

<p>So, having copied ALL property values from instance 1 to instance 2 I should get the same results, right? WRONG! the GetHashCode() of both instances differ somehow, but if I dump their properties (named above) then they are all the same.</p>

<p>If I encrypt a string of text with a length equal to the block size (16 bytes, 128 bits) then both produce the same result, if the input is less than BlockSize then the encryption results are NOT the same.</p>

<p>I have this to create the initial Rijndael instance.</p>

<pre><code>    public static RijndaelManaged CreateSymmetricKey(string passphrase)
    {
        RijndaelManaged symCrypto = new RijndaelManaged();
        symCrypto.Mode = CipherMode.CBC;               
        symCrypto.Padding = PaddingMode.PKCS7;
        byte[] salt = Encoding.UTF8.GetBytes(""dummy dummy dummy dummy test"");
        Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(passphrase, salt);
        symCrypto.Key = key.GetBytes(symCrypto.KeySize / 8);
        symCrypto.IV = key.GetBytes(symCrypto.BlockSize / 8);

        return symCrypto;
    }
</code></pre>

<p>To encrypt the string for the sake of an example:</p>

<pre><code>private string Encrypt(RijndaelManaged rm, string text)
    {
        byte[] encrypted;
        // Create a decrytor to perform the stream transform.
            ICryptoTransform encryptor = rm.CreateEncryptor(rm.Key, rm.IV);
        using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(text);
                    }
                    encrypted = msEncrypt.ToArray();
                }
            }
        return BitConverter.ToString(encrypted);
    }
</code></pre>

<p>So then do this</p>

<pre><code>RijndaelManaged rm1 = CreateSymmetricKey(""there is something weird happening"");
RijndaelManaged rm2 = new RijndaelManaged();
// copy ALL public properties to the new instance so that it has the same parameters
rm2.BlockSize = rm1.BlockSize; // 128
rm2.FeedbackSize = rm1.FeedbackSize; // 128
rm2.KeySize = rm1.KeySize; // 256
rm2.Mode = rm1.Mode; // CBC
rm2.Padding = rm1.Padding; // PKCS7
rm2.IV = rm1.IV;
rm2.Key = rm1.Key;
// Encryption
string cypher1 = Encrypt(rm1, ""this is a test 6"");  // length equal to BlockSize
string cypher2 = Encrypt(rm2, ""this is a test 6"");  // length equal to BlockSize
string cypher11 = Encrypt(rm1, ""this is a test"");  // length less than BlockSize
string cypher21 = Encrypt(rm2, ""this is a test"");  // length less than BlockSize
</code></pre>

<p>I am getting that cyper1 == cypher2 and cypher11 != cypher21 also rm1.GetHashCode() != rm2.GetHashCode() yet all public parameters are the same!</p>

<p>I also dumped all the public properties of both instances to see if I was missing something but not, all values are the same.</p>
","<p>You should not use <code>GetHashCode()</code> in this way. For classes that did not override the base <code>object.GetHashCode()</code> implementation, it will return the integer handler of this specific instance.<br>
Since the handle for two different instances will always be different this will never match.</p>

<p>Also <code>GetHashCode()</code> never actually guarantees uniqueness, it's merely meant to be used as a light weight pre check, before the actual equality is tested.<br>
This is heavily used in any kind of Hashing data structure like Dictionary etc.</p>

<p>For more info on this topic:<br>
<a href=""http://msdn.microsoft.com/en-us/library/system.object.gethashcode.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/system.object.gethashcode.aspx</a></p>

<p>I also executed your code and for me the following was the case:</p>

<pre><code>cyper1 == cypher2 and cypher11 == cypher21
</code></pre>

<p>I'm pretty sure the issue was the comparison of <code>GetHashCode()</code>.</p>
","372","<c#><encryption><rijndael><encryption-symmetric>","3","0","1","2012-03-16 17:03:25","","6","1","","","","2012-02-09 21:36:42",""
"26013285","Encrypting information to a hidden field in an MVC application","<p>I am working on an MVC project. I need to encrypt some information and store it in a hidden field. The solution is being deployed in an intranet scenario and the information is private but probably not critical but encrypting it would be best practice. We are using Windows Authentication.</p>

<p>To prevent the user from seeing these values I am using the Rijndael Encryption method to create an encrypted string then converting the encrypted value to hex string and placing in a hidden field.</p>

<p>I am currently hard-coding values for the Key and IV (storing them in a web.config - and encrypting). I have read that the IV should be different in every encryption. However I do not really want to have to start storing each IV server side and retrieving it on the post back unless I have to. </p>

<p>How critical is it to generate a new IV key with every request?</p>

<p>Would there be a more suitable encryption algorithm that would not require generated values?</p>
","<p>You can store your Key and IV values in database for each user. It prevent generating them on each request, but make unique for each employee accesed your web application</p>

<p>Regeneration could be make each midnight by using windows service or sql job. </p>
","365","<asp.net-mvc><encryption><rijndael>","0","0","1","2015-11-17 00:01:10","26014390","3","","126273","","2015-11-17 00:01:10","2014-09-24 09:26:43",""
"20275907","Should encrypted data base64 encoded to store it in a database?","<p>Should I first encode my encrypted text with base64 to store it in a database? It will be larger when I encode it but is better or faster to decrypt it?
(Especially for Rijndael and RSA encrypted data.)</p>
","<p>No, you don't need to encode your ciphertext using base64 encoding. You should encode your ciphertext only if your field just accepts text values. Speed is normally not an issue as cryptographic algorithms are much slower than the conversion from or to base64.</p>
","354","<security><encryption><base64><rsa><rijndael>","1","3","2","2018-04-09 12:31:39","20275945","0","","1033581","","2018-04-09 12:31:39","2013-11-28 22:56:23",""
"20275907","Should encrypted data base64 encoded to store it in a database?","<p>Should I first encode my encrypted text with base64 to store it in a database? It will be larger when I encode it but is better or faster to decrypt it?
(Especially for Rijndael and RSA encrypted data.)</p>
","<p>If I understood you correctly than you do not need to encode with base64 before storing it in the database. If you use a proper database than you can just store the raw bytes. Base64 is good for transferring binary data over text-only media but, it also enlarges data by roughly 33%. It would not make it faster because you actually need to do two steps now: decode and than decrypt, instead of decrypting it immediately.</p>
","354","<security><encryption><base64><rsa><rijndael>","1","0","2","2018-04-09 12:31:39","20275945","0","","1033581","","2018-04-09 12:31:39","2013-11-28 22:56:23",""
"26401645","Symmetric encryption which returns specific character set and specific length","<p>I use this code below to encrypt and decrypt a string, but it returns a value including special characters and length of returned value is not specific.</p>

<p>I want to use this to generate a serial key, so is it possible to turn result to specific length and specific character set like A-Z,0-9 ?</p>

<pre><code>static readonly string PasswordHash = ""P@@Sw0rd"";
static readonly string SaltKey = ""S@LT&amp;KEY"";
static readonly string VIKey = ""@1B2c3D4e5F6g7H8"";


public static string Encrypt(string plainText)
{
    byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);

    byte[] keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
    var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.Zeros };
    var encryptor = symmetricKey.CreateEncryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));

    byte[] cipherTextBytes;

    using (var memoryStream = new MemoryStream())
    {
        using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
        {
            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
            cryptoStream.FlushFinalBlock();
            cipherTextBytes = memoryStream.ToArray();
            cryptoStream.Close();
        }
        memoryStream.Close();
    }
    return Convert.ToBase64String(cipherTextBytes);
}

public static string Decrypt(string encryptedText)
{
    byte[] cipherTextBytes = Convert.FromBase64String(encryptedText);
    byte[] keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
    var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.None };

    var decryptor = symmetricKey.CreateDecryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));
    var memoryStream = new MemoryStream(cipherTextBytes);
    var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
    byte[] plainTextBytes = new byte[cipherTextBytes.Length];

    int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
    memoryStream.Close();
    cryptoStream.Close();
    return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount).TrimEnd(""\0"".ToCharArray());
}
</code></pre>
","<p>The two padding modes do not match. Especially <code>PaddingMode.None</code> does not make sense if your data is not block-aligned.</p>

<p><code>PaddingMode.Zeros</code> also does not make sense because it causes the padding to be not removable.</p>

<p>It seems you have fiddled with settings until it seemed to work. That is very dangerous with cryptography. It is also an unsound development practice in general.</p>
","353","<c#><encryption><rijndael>","0","2","1","2014-10-16 15:57:56","","1","1","589259","","2014-10-16 15:57:56","2014-10-16 10:07:29",""
"36403278","How can i decrypt file in ios that was encrypted in c# using Rijndael","<p>I have an application in C# that encrypt my files with AES algorithm with this method:</p>

<pre><code>private static void encryptFile(string inputFile, string outputFile, string strKey)
{
  try
  {
    using (RijndaelManaged aes = new RijndaelManaged())
    {
      byte[] key = Encoding.UTF8.GetBytes(strKey);
      byte[] IV = Encoding.UTF8.GetBytes(strKey);

      using (FileStream fsCrypt = new FileStream(outputFile, FileMode.Create))
      {
        using (ICryptoTransform encryptor = aes.CreateEncryptor(key, IV))
        {
          using (CryptoStream cs = new CryptoStream(fsCrypt, encryptor, CryptoStreamMode.Write))
          {
            using (FileStream fsIn = new FileStream(inputFile, FileMode.Open))
            {
              int data;
              while ((data = fsIn.ReadByte()) != -1)
              {
                cs.WriteByte((byte)data);
              }
            }
          }
        }
      }
    }
  }
  catch (Exception ex)
  {
    Debug.WriteLine(ex.Message);
  }
}
</code></pre>

<p>The file is encrypted without an issue.</p>

<p>Then I want to decrypt the encrypted file with my Android (2.2) application. So I do this:</p>

<pre><code>private void decriptFile() throws NoSuchPaddingException, NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidKeyException, IOException {
        //byte[] docBytes = serialize(myDoc);
        byte[] b = new byte[0];
        try {
            Resources res = getResources();
            InputStream in_s = res.openRawResource(R.raw.output27);

            b = new byte[in_s.available()];
            in_s.read(b);
            //txtHelp.setText(new String(b));
        } catch (Exception e) {
            // e.printStackTrace();
            //txtHelp.setText(""Error: can't show help."");
        }

        //byte[] dataBytes = FileUtils.readFileToByteArray(File file);
        byte[] key = new byte[0];
        try {
           // key = (""HR$2pIjHR$2pIj12"").getBytes(""UTF-8"");
            key = (""HR$2pIjHR$2pIj12"").getBytes(""UTF-8"");
            Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKeySpec k = new SecretKeySpec(key, ""AES"");
            IvParameterSpec iv = new IvParameterSpec(key);
            c.init(Cipher.DECRYPT_MODE, k, iv);

            // IllegalBlockSizeException Occurred

            //File folder = new File(Environment.getExternalStorageDirectory(),
                    //""test"");
            File folder = new File(""/sdcard"",
                    ""test"");
            if (!folder.exists()) {
                folder.mkdir();
            }

            byte[] decryptedDocBytes = c.doFinal(b);
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(folder.getPath()+""/test.epub""));
            bos.write(decryptedDocBytes);
            bos.flush();
            bos.close();
            //DocumentsContract.Document decryptedDoc = (DocumentsContract.Document)deserialize(decryptedDocBytes);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        //IvParameterSpec iv = new IvParameterSpec(key);



        //And my serialize/deserialize methods:
    }
</code></pre>

<p>This time decryption works fine.For decrypting same file in Objective C
I am using the following method:</p>

<pre><code>- (NSData *)decrypt:(NSData *)plainText key:(NSData *)aSymmetricKey padding:(CCOptions *)pkcs7
{
    //return [self doCipher:plainText key:aSymmetricKey context:kCCDecrypt padding:pkcs7];
    return [self doCipher2:plainText iv:[self generateRandomIV:128] key:aSymmetricKey context:kCCDecrypt error:nil];
}

- (NSData *)doCipher2:(NSData *)dataIn
                  iv:(NSData *)iv
                 key:(NSData *)symmetricKey
             context:(CCOperation)encryptOrDecrypt // kCCEncrypt or kCCDecrypt
               error:(NSError **)error
{
    CCCryptorStatus ccStatus   = kCCSuccess;
    size_t          cryptBytes = 0;
    NSMutableData  *dataOut    = [NSMutableData dataWithLength:dataIn.length + kCCBlockSizeAES128];

    ccStatus = CCCrypt( encryptOrDecrypt,
                       kCCAlgorithmAES128,
                       0, //kCCOptionPKCS7Padding,
                       symmetricKey.bytes,
                       kCCKeySizeAES128,
                       iv.bytes,
                       dataIn.bytes,
                       dataIn.length,
                       dataOut.mutableBytes,
                       dataOut.length,
                       &amp;cryptBytes);

    if (ccStatus == kCCSuccess) {
        dataOut.length = cryptBytes;
    }
    else {
        if (error) {
            *error = [NSError errorWithDomain:@""kEncryptionError""
                                         code:ccStatus
                                     userInfo:nil];
        }
        dataOut = nil;
    }

    return dataOut;
}
</code></pre>

<p>This time no luck.What might  be the problem??
Any help would be appreciated.</p>
","<p>In the Android version you specify <code>PKCS5Padding</code> but no padding it the iOS version. Note that <code>PKCS5Padding</code> and<code>PKCS7Padding</code> amount to the same thing, there is just a definition difference. </p>

<p>Change:</p>

<pre><code>0, //kCCOptionPKCS7Padding,
</code></pre>

<p>to</p>

<pre><code>kCCOptionPKCS7Padding,
</code></pre>
","344","<c#><ios><xcode><rijndael>","0","0","1","2016-04-09 11:42:53","36481910","4","3","5113680","","2016-04-05 04:07:17","2016-04-04 12:54:12",""
"39446951","Decryption Error : Length of the data to decrypt is invalid","<p>I used this code to decrypt my file, but I have receive this error:</p>

<blockquote>
  <p>Decryption Error : Length of the data to decrypt is invalid </p>
</blockquote>

<p>My code:</p>

<pre><code>private void DecryptFile(string inputFile, string outputFile)
{
    //try
    //{
    string password = @""myKey123""; // Your Key Here

    UnicodeEncoding UE = new UnicodeEncoding();
    byte[] key = UE.GetBytes(password);

    FileStream fsCrypt = new FileStream(inputFile, FileMode.Open);

    RijndaelManaged RMCrypto = new RijndaelManaged();

    CryptoStream cs = new CryptoStream(fsCrypt,
        RMCrypto.CreateDecryptor(key, key),
        CryptoStreamMode.Read);

    FileStream fsOut = new FileStream(outputFile, FileMode.Create);

    int data;
    while ((data = cs.ReadByte()) != -1)
        fsOut.WriteByte((byte)data);

    fsOut.Close();
    cs.Close();
    fsCrypt.Close();

    //}
    //catch
    //{
    //    Label12.Text = ""Decryption failed!"";
    //}
}
</code></pre>

<p>It works good in c# application but I have error in asp.net pages!</p>
","","333","<c#><asp.net><rijndael>","0","","0","2016-09-15 09:18:38","","7","","3215948","","2016-09-15 09:10:31","2016-09-12 09:15:55",""
"35693196","Read a key file extension into bytes using c# and pass it to encryption algorithm","<p>I am using a binary reader to read my .key file. output i am getting is 37 byte array. But my specified algorithm need to have only 16 bytes.I am getting ""specified key size is not valid for this algorithm"" error when I pass parameter to encryption algorithm(Rijindael managed class used for encryption). The Key file and algorithm suggested by client. </p>

<p>Code for converting .key file to bytes is </p>

<pre><code>public static byte[] ConvertFileToByteArray(string fileName)
{
    byte[] returnValue = null;
    using (FileStream fr = new FileStream(fileName, FileMode.Open))
    {
        using (BinaryReader br = new BinaryReader(fr))
        {
            returnValue = br.ReadBytes((int)fr.Length);

        }
    }       
    return returnValue;
}
</code></pre>

<p>Encryption algorithm is (the block and keysize mentioned below is equal to 16 bytes or 128 bits)</p>

<pre><code>'  static byte[] EncryptStringToBytes(string plainText, byte[] Key, byte[] IV)
{      
    if (plainText == null || plainText.Length &lt;= 0)
        throw new ArgumentNullException(""plainText"");
    if (Key == null || Key.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");
    if (IV == null || IV.Length &lt;= 0)
        throw new ArgumentNullException(""IV"");
    byte[] encrypted;       
    using (RijndaelManaged rijAlg = new RijndaelManaged())
    {
        rijAlg.BlockSize = 0x80;
        rijAlg.KeySize = 0x80;
        rijAlg.Key = Key;
        rijAlg.GenerateIV();
        rijAlg.Mode = CipherMode.CBC;
        rijAlg.Padding = PaddingMode.PKCS7;

        // Create a decrytor to perform the stream transform.
        ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);         
        using (MemoryStream msEncrypt = new MemoryStream())
        {
            using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
            {
                using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                {                        
                    swEncrypt.Write(plainText);
                }
                encrypted = msEncrypt.ToArray();
            }
        }
    }       
    return encrypted;
}
</code></pre>

<p>'</p>
","<p>you need to write the length in the msEncrypt as follows:</p>

<pre><code>    using (MemoryStream msEncrypt = new MemoryStream())
    {
        // prepend the IV
        msEncrypt.Write(BitConverter.GetBytes(aesAlg.IV.Length), 0, sizeof(int));
        msEncrypt.Write(aesAlg.IV, 0, aesAlg.IV.Length);
        using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
        {
            using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
            {
                //Write all data to the stream.
                swEncrypt.Write(plainText);
            }
        }
        outStr = Convert.ToBase64String(msEncrypt.ToArray());
    }
</code></pre>

<p>if it is still doesn't work, it's probably due to a faulty initialization of your ""rijAlg"" element.
try to take a look at:
<a href=""https://stackoverflow.com/q/24048306/1447518"">decrpyt .Net Encrypted string in iOS</a>
which has a working encryption which had worked for me.</p>
","320","<c#><rijndael>","1","0","1","2016-02-29 07:49:56","","1","","1560697","","2016-02-29 06:39:18","2016-02-29 06:27:30",""
"23048962","Why does decryption not return the expected value?","<p>When using c# rijndael to decrypt a string that was previously encrypted and saved in sql server ce, I get nothing back from decryption. I can tell from debugging and checking the database that the decrypted string appears to be saved as expected with different sets of nonsense for different input strings so I assume that the problem is in the decryption code. I also confirmed that cipherText input parameter got the correct number of bytes after being retrieved from the db and re-made into a byte array. I used the example found at:
 <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndael%28v=vs.110%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndael%28v=vs.110%29.aspx</a> to do this, with some modifications.</p>

<pre><code>static string DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV)
    {
        // Check arguments. 
        if (cipherText == null || cipherText.Length &lt;= 0)
            throw new ArgumentNullException(""cipherText"");
        if (Key == null || Key.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        if (IV == null || IV.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");

        // Declare the string used to hold 
        // the decrypted text. 
        string plainText = null;

        // Create an Rijndael object 
        // with the specified key and IV. 
        using (Rijndael rijAlg = Rijndael.Create())
        {
            rijAlg.Key = Key;
            rijAlg.IV = IV;
            rijAlg.Padding = PaddingMode.PKCS7;

            // Create a decrytor to perform the stream transform.
            ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);
            var plainBytes = new byte[cipherText.Length];
            int plainByteCount;

            // Create the streams used for decryption. 
            using (MemoryStream msDecrypt = new MemoryStream(cipherText))
            {

                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {

                    plainByteCount = csDecrypt.Read(plainBytes, 0, plainBytes.Length);

                    using (StreamReader srDecrypt = new StreamReader(csDecrypt, System.Text.Encoding.Unicode))
                    {
                        // Read the decrypted bytes from the decrypting stream 
                        // and place them in a string.
                        plainText = srDecrypt.ReadToEnd();

                    }

                }
            }
        plainText = Encoding.Unicode.GetString(plainBytes, 0, plainBytes.Length);

        }

        return plainText;

    }
</code></pre>

<p>At</p>

<pre><code> plainText = srDecrypt.ReadToEnd();
</code></pre>

<p>plainText gets the value of """" where I would expect it to be the decrypted word. </p>

<p>Finally, at</p>

<pre><code>   plainText = Encoding.Unicode.GetString(plainBytes, 0, plainBytes.Length);
</code></pre>

<p>plainText becomes:  ""\0\0\0\0\0\0\0\0""</p>

<p>I have tried various padding options, both at the encryption and decryption stages, and can see that doing so has an effect but it doesn't solve the problem. Without setting padding 0 bytes get encrypted in the first place, where it should be 16  bytes. I also tried different ways of calling flush and flushfinalblock. I am storing the key/iv in plain text files (I am aware that may not be best practice for security,  my goal for now is only to learn more about this topic).</p>

<p>Please help me find what I am doing wrong here. </p>
","<p>I have encountered the similar problem in VB.NET and discovered that the variables to be used in both encryption and decryption process should be the same. Giving the encryption and decryption functions their own local variables would definitely cause the decryption function return a wrong value. Try making the key and the iv a global variable instead of a local variable.</p>
","318","<c#><encryption><rijndael><cryptostream>","0","0","1","2014-04-16 01:30:31","","3","","","","","2014-04-13 22:01:31",""
"53840263","mcrypt_decrypt(): Received initialization vector of size","<p>Faced with the problem associated with encryption. Or rather decrypt. Some of my users get the following error:</p>

<blockquote>
  <p>mod_fcgid: stderr: PHP Warning:  mcrypt_decrypt(): Received initialization vector of size 10, but size 16 is required for this encryption mode in...</p>
</blockquote>

<p>or</p>

<blockquote>
  <p>mod_fcgid: stderr: PHP Warning:  mcrypt_decrypt(): Received
  initialization vector of size 30, but size 16 is required for this
  encryption mode in...</p>
</blockquote>

<p>Who has this error - can not enter.</p>

<p>One out of a hundred people get this error. I just can not figure out what it is connected with. I read in the open spaces of Stackoverflow that this is due to the fact that there is not enough <strong><em>""\0""</em></strong>.
All the tips did not help me, unfortunately. How to be? I do not want to change the encryption method. It completely suits me, not counting this error.</p>

<p>Decrypt code:</p>

<pre><code>function decrypt($text, $pkey)
{
    $key = $pkey;   
    $text = base64_decode($text); 
    $IV = substr($text, strrpos($text, ""-[--IV-[-"") + 9);
    $text = str_replace(""-[--IV-[-"".$IV, """", $text);

    return rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $text, MCRYPT_MODE_CBC, $IV), ""\0"");
}
</code></pre>

<p>Try this (did not help unfortunately):</p>

<pre><code>function pad_key($key){
    if(strlen($key) &gt; 32) return false;
    $sizes = array(16,24,32);
    foreach($sizes as $s){
        while(strlen($key) &lt; $s) $key = $key.""\0"";
        if(strlen($key) == $s) break; // finish if the key matches a size
    }
    return $key;
}
</code></pre>

<p>PHP ver: 5.6</p>

<p>Added (Encrypt method C#):</p>

<pre><code>public static string EncryptMessage(byte[] text, string key)
{
    RijndaelManaged aes = new RijndaelManaged();
    aes.KeySize = 128;
    aes.BlockSize = 128;
    aes.Padding = PaddingMode.Zeros;
    aes.Mode = CipherMode.CBC;

    aes.Key = Encoding.Default.GetBytes(key);
    aes.GenerateIV();

    string IV = (""-[--IV-[-"" + Encoding.Default.GetString(aes.IV));

    ICryptoTransform AESEncrypt = aes.CreateEncryptor(aes.Key, aes.IV);
    byte[] buffer = text;

    return Convert.ToBase64String(Encoding.Default.GetBytes(Encoding.Default.GetString(AESEncrypt.TransformFinalBlock(buffer, 0, buffer.Length)) + IV));
}
</code></pre>
","<p>Most likely the error was related to the Default encoding in my Encrypt Code.
<a href=""https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding.default?redirectedfrom=MSDN&amp;view=netframework-4.7.2#System_Text_Encoding_Default"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding.default?redirectedfrom=MSDN&amp;view=netframework-4.7.2#System_Text_Encoding_Default</a>
(Warning Message).</p>
","315","<c#><php><encryption><mcrypt><rijndael>","0","-1","1","2018-12-18 22:07:41","","5","","10442660","","2018-12-18 22:07:41","2018-12-18 20:05:12",""
"29979705","How to perform Galois field multiplication?","<p>I'm implementing AES encryption. During the mix column/inverse mix columns procedures, I need to do Galois field multiplication. I'm using the look-up tables in the following document(Section 5.4.2)
<a href=""https://www.ime.usp.br/~rt/cranalysis/AESSimplified.pdf"" rel=""nofollow"">https://www.ime.usp.br/~rt/cranalysis/AESSimplified.pdf</a></p>

<p>If you go to the section specified above, the (0,0) column in the L table is empty. So what do I return when say I need to look up L(0,0). I tried to return 0, but that's giving me the wrong encryption.</p>
","","297","<ocaml><aes><rijndael><galois-field>","3","","0","2015-05-05 09:12:12","","1","","1816580","","2015-05-01 08:26:59","2015-04-30 23:55:50",""
"18164908","After decrypting with RIJNDAEL, strings not equal","<p>I'm using RIJNDAEL to encrypt/decrypt passwords and some other strings, but it doesn't work.</p>

<p>This is my encrypt/decrypt function:</p>

<pre><code>function secreto($accion,$clave,$palabra) {
//SETEO DATA EN 0 PORSIACA
$data = 0;
//INICIALIZO EL VECTOR
$iv = md5($clave);
//SI TENGO QUE ENCRIPTAR
if($accion == 'encripta') {
    $data = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $clave, $palabra, MCRYPT_MODE_CBC, $iv);
    $data = base64_encode($data);
} elseif($accion == 'decripta') {
    $data = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $clave, base64_decode($palabra), MCRYPT_MODE_CBC, $iv);
    $data = rtrim($data, """");
}
return $data;
}
</code></pre>

<p>Here is the relevant part I'm using to log in a user:</p>

<pre><code>session_start();
if(isset($_SESSION['usuario']) &amp;&amp; isset($_SESSION['domadmin']) &amp;&amp; isset($_SESSION['superadmin'])) {
    $usuario = $_SESSION['usuario'];
    $tipoadmin = $_SESSION['tipoadmin'];
    if(isset($_GET['p'])) { $p = $_GET['p']; } else {  $p = ""resumen""; }
    echo TPcabecera();
    echo TPmenu($p);
    echo TPcentral($p);
    echo TPpie();
} else {
    if(isset($_POST['usuario']) &amp;&amp; isset($_POST['password'])) {
        $post_usr = mysqli_real_escape_string(sqls(""mail""), $_POST['usuario']);
        $post_pwd = mysqli_real_escape_string(sqls(""mail""), $_POST['password']);
        $data = sql(""mail"", ""SELECT email,superadmin,domadmin,syspass FROM users WHERE email = '"".$post_usr.""'"");
        if(mysqli_num_rows($data) == 0) {
            echo TPlogin();
        } else {
            $row = mysqli_fetch_assoc($data);
            $pass = secreto('decripta',$passsalt,$row['syspass']);
            if($post_pwd == $pass) {
                $usuario = $row['email'];
                if($row['superadmin'] == '1') { $tipoadmin = 'superadmin'; } elseif($_SESSION['domadmin'] != '0') { $tipoadmin = $_SESSION['domadmin']; } else { $tipoadmin = '0'; }
                if(isset($_GET['p'])) { $p = $_GET['p']; } else {  $p = ""resumen""; }
                echo TPcabecera();
                echo TPmenu($p);
                echo TPcentral($p);
                echo TPpie();
            } else {
                echo TPlogin();
            }
        }
    } else {
        echo TPlogin();
    }
}
</code></pre>

<p>If I echo <code>$pass</code> and <code>$post_pwd</code>, they are exactly the same, yet the <code>if($post_pwd == $pass)</code> doesn't validate... am I using encryption in the wrong way?</p>
","<p>Your <code>secreto</code> function should ""work"". With your login code I don't see where you initialize <code>$passsalt</code>. So either there is a part of your code that you aren't showing, or <code>$passsalt</code> isn't actually set.</p>

<p>Your encryption is insecure though:</p>

<ol>
<li><p>You shouldn't be using a password as your encryption key. Human passwords typically don't have enough <a href=""https://en.wikipedia.org/wiki/Entropy"" rel=""nofollow noreferrer"">entropy</a>.</p></li>
<li><p>You are somewhat exposing your key by using a hashed version of it as your IV.</p></li>
<li><p>An IV is meant to protect your key by ""randomizing"" the first encrypted block. This ensures that even when you encrypt the same text with the same key, the output will be different. Because you use a constant IV, you are not getting any benefit from it.</p></li>
</ol>

<p>If possible your key should be random, using a character range of 0 - 255. Your IV must always be different when you encrypt. The IV can be public, so you can even store it with the encrypted text.</p>

<p>You should also avoid storing the encryption key in the database along with the encrypted data.</p>

<p>If you are encrypting passwords, I would use a one-way hash designed for passwords instead, like <a href=""https://stackoverflow.com/questions/10149554/are-there-any-php-implementations-of-scrypt"">scrypt</a> or <a href=""http://www.php.net/manual/en/function.password-hash.php"" rel=""nofollow noreferrer"">bcrypt</a>.</p>
","297","<php><rijndael>","0","2","2","2019-08-05 04:39:35","18165807","2","","10607772","","2019-08-05 04:39:35","2013-08-10 18:11:06",""
"18164908","After decrypting with RIJNDAEL, strings not equal","<p>I'm using RIJNDAEL to encrypt/decrypt passwords and some other strings, but it doesn't work.</p>

<p>This is my encrypt/decrypt function:</p>

<pre><code>function secreto($accion,$clave,$palabra) {
//SETEO DATA EN 0 PORSIACA
$data = 0;
//INICIALIZO EL VECTOR
$iv = md5($clave);
//SI TENGO QUE ENCRIPTAR
if($accion == 'encripta') {
    $data = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $clave, $palabra, MCRYPT_MODE_CBC, $iv);
    $data = base64_encode($data);
} elseif($accion == 'decripta') {
    $data = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $clave, base64_decode($palabra), MCRYPT_MODE_CBC, $iv);
    $data = rtrim($data, """");
}
return $data;
}
</code></pre>

<p>Here is the relevant part I'm using to log in a user:</p>

<pre><code>session_start();
if(isset($_SESSION['usuario']) &amp;&amp; isset($_SESSION['domadmin']) &amp;&amp; isset($_SESSION['superadmin'])) {
    $usuario = $_SESSION['usuario'];
    $tipoadmin = $_SESSION['tipoadmin'];
    if(isset($_GET['p'])) { $p = $_GET['p']; } else {  $p = ""resumen""; }
    echo TPcabecera();
    echo TPmenu($p);
    echo TPcentral($p);
    echo TPpie();
} else {
    if(isset($_POST['usuario']) &amp;&amp; isset($_POST['password'])) {
        $post_usr = mysqli_real_escape_string(sqls(""mail""), $_POST['usuario']);
        $post_pwd = mysqli_real_escape_string(sqls(""mail""), $_POST['password']);
        $data = sql(""mail"", ""SELECT email,superadmin,domadmin,syspass FROM users WHERE email = '"".$post_usr.""'"");
        if(mysqli_num_rows($data) == 0) {
            echo TPlogin();
        } else {
            $row = mysqli_fetch_assoc($data);
            $pass = secreto('decripta',$passsalt,$row['syspass']);
            if($post_pwd == $pass) {
                $usuario = $row['email'];
                if($row['superadmin'] == '1') { $tipoadmin = 'superadmin'; } elseif($_SESSION['domadmin'] != '0') { $tipoadmin = $_SESSION['domadmin']; } else { $tipoadmin = '0'; }
                if(isset($_GET['p'])) { $p = $_GET['p']; } else {  $p = ""resumen""; }
                echo TPcabecera();
                echo TPmenu($p);
                echo TPcentral($p);
                echo TPpie();
            } else {
                echo TPlogin();
            }
        }
    } else {
        echo TPlogin();
    }
}
</code></pre>

<p>If I echo <code>$pass</code> and <code>$post_pwd</code>, they are exactly the same, yet the <code>if($post_pwd == $pass)</code> doesn't validate... am I using encryption in the wrong way?</p>
","<h2>This is something I want to add:</h2>

<p>Organize you code with <a href=""http://en.wikipedia.org/wiki/Separation_of_concerns"" rel=""nofollow"">Separation of concerns</a> in mind, so perform each task in small separate steps. This will help you write clearer code and keep it <a href=""http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"" rel=""nofollow"">DRY</a>.</p>

<p>I recommend putting the encode / decode parts into separate functions. For example:</p>

<pre><code>&lt;?php
// Encrypt function
function mc_encrypt($encrypt, $mc_key)
{
    $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND);
    $passcrypt = trim(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $mc_key, trim($encrypt), MCRYPT_MODE_ECB, $iv));
    $encode = base64_encode($passcrypt);
    return $encode;
}

// Decrypt function
function mc_decrypt($decrypt, $mc_key)
{
    $decoded = base64_decode($decrypt);
    $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND);
    $decrypted = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $mc_key, trim($decoded), MCRYPT_MODE_ECB, $iv));
    return $decrypted;
}
</code></pre>

<p>This way you can call them directly.</p>

<p>For the authentication, have a look at this:<br>
<a href=""http://ulogin.sourceforge.net/"" rel=""nofollow"">http://ulogin.sourceforge.net/</a></p>

<p>Also check this out:<br>
<a href=""http://www.warpconduit.net/2013/04/14/highly-secure-data-encryption-decryption-made-easy-with-php-mcrypt-rijndael-256-and-cbc/"" rel=""nofollow"">Highly Secure Data Encryption &amp; Decryption Made Easy with PHP, MCrypt, Rijndael-256, and CBC</a></p>

<p>Good luck.</p>
","297","<php><rijndael>","0","0","2","2019-08-05 04:39:35","18165807","2","","10607772","","2019-08-05 04:39:35","2013-08-10 18:11:06",""
"50441959","How can I do for Rijndael-256 with BouncyCastle API?","<p>An ancient PHP guy wrote encryption code for <code>Rijndael-256 (!AES256) / ECB / NoPadding</code>.</p>

<p>I tried this.</p>

<pre><code>PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(
        new RijndaelEngine(256), new ZeroBytePadding());
cipher.init(encrypt, new KeyParameter(Arrays.copyOf(KEY.getBytes(UTF_8), 16)));
byte[] source = supplier.get();
byte[] target = new byte[cipher.getOutputSize(source.length)];
int offset = cipher.processBytes(source, 0, source.length, target, 0);
cipher.doFinal(target, offset);
</code></pre>

<p>But encryption always adds paddings. Yes I know I used <code>ZeroBytePadding</code>.</p>

<p>How can I solve this? I failed to find any good references.</p>
","<p>If the encryption really didn't add padding, then just initialise the cipher as:</p>

<pre><code>new BufferedBlockCipher(new RijndaelEngine(256))
</code></pre>

<p>Be aware that the <code>doFinal</code> call will throw a <code>DataLengthException</code> if the data you are trying to decrypt is not actually block-aligned.</p>

<p>BTW, it's also a good habit to check the return value of <code>doFinal</code> (how many bytes were output), since <code>getOutputSize</code> is allowed to be an overestimate.</p>
","296","<java><bouncycastle><rijndael>","0","2","2","2018-05-24 11:51:49","50472189","1","","330457","","2018-05-24 01:52:41","2018-05-21 04:20:32",""
"50441959","How can I do for Rijndael-256 with BouncyCastle API?","<p>An ancient PHP guy wrote encryption code for <code>Rijndael-256 (!AES256) / ECB / NoPadding</code>.</p>

<p>I tried this.</p>

<pre><code>PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(
        new RijndaelEngine(256), new ZeroBytePadding());
cipher.init(encrypt, new KeyParameter(Arrays.copyOf(KEY.getBytes(UTF_8), 16)));
byte[] source = supplier.get();
byte[] target = new byte[cipher.getOutputSize(source.length)];
int offset = cipher.processBytes(source, 0, source.length, target, 0);
cipher.doFinal(target, offset);
</code></pre>

<p>But encryption always adds paddings. Yes I know I used <code>ZeroBytePadding</code>.</p>

<p>How can I solve this? I failed to find any good references.</p>
","<p>I'm sharing my (possible) solution based on the accepted answer.</p>

<pre><code>BufferedBlockCipher cipher =
    new BufferedBlockCipher(new RijndaelEngine(256));
cipher.init(encrypt, new KeyParameter(Arrays.copyOf(KEY.getBytes(UTF_8), 16)));
byte[] source = supplier.get();
byte[] target = new byte[cipher.getOutputSize(source.length)];
int offset = cipher.processBytes(source, 0, source.length, target, 0);
try {
    offset += cipher.doFinal(target, offset);
} catch (InvalidCipherTextException icte) {
    // if padding is expected and not found
    //throw new RuntimeException(icte);
}
target = Arrays.copyOf(target, offset);
</code></pre>

<p>I'm not sure, though.</p>
","296","<java><bouncycastle><rijndael>","0","0","2","2018-05-24 11:51:49","50472189","1","","330457","","2018-05-24 01:52:41","2018-05-21 04:20:32",""
"34306804","Rijndael PHP vs C# - Invalid KeySize in C# but not in PHP","<p>I try to encrypt a string (json) with Rijndael in C# and come up with a string, which I can offer to a PHP web service. This web service in turn decodes the string using the IV and masterkey (known to them). I have to write the C# code that can talk to the PHP service, I do not control/own the PHP service.</p>

<p>The PHP code for encrypting is as follows:</p>

<pre><code>function encrypt($plaintext) {
    $masterkey = 'masterKeyOfLength29Characters';
    $td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
    $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
    mcrypt_generic_init($td, $masterkey, $iv);
    $crypttext = mcrypt_generic($td, $plaintext);
    mcrypt_generic_deinit($td);
    return base64_encode($iv.$crypttext);
}
$param = array(""key"" =&gt; ""value"");
$encryptedString = rawurlencode(encrypt(json_encode($param)))
</code></pre>

<p>The code above I'll have to convert to C#, so I can encrypt my JSON and offer it to the PHP web service.</p>

<p>There are two problems. The first was with the masterkey length, the second (might be related) is with the rawurlencode of the encrypted data (hard for me to test at this point).</p>

<pre><code>var masterkey = ""masterKeyOfLength29Characters"";
var data = EncryptData(json, masterkey);
// Some code to URL Encode the data, I haven't gotten as far to test this
// since I can't encrypt with the key used in PHP, so I can't call the service
// to test the encoded string from my C# code.
data = HttpUtility.UrlEncode(data);
data = data.Replace(""+"", ""%20"");

public static string EncryptData(string json, string encryptionKey) {
    Rijndael rj = Rijndael.Create();
    rj.Mode = CipherMode.CBC;
    rj.Padding = PaddingMode.PKCS7;
    rj.BlockSize = 256;
    rj.KeySize = 256;
    rj.Key = Encoding.UTF8.GetBytes(encryptionKey); // ERROR here
    rj.GenerateIV();
    var encryptedJSON = EncryptStringToBytes(json, rj.Key, rj.IV);
    var r1 = Convert.ToBase64String(rj.IV);
    var r2 = Convert.ToBase64String(encryptedJSON);
    return r1 + r2;
}
</code></pre>

<p>The EncryptStringToBytes does some checks and uses this code (plucked from the many examples on the internet):</p>

<pre><code>using (Rijndael rijAlg = Rijndael.Create()) {
    // Basically I do the same here as above, and I could also generate
    // the IV here, but then I'd had to return it too. I know I can clean this
    // code up quite a bit, but I'd rather focus on getting it to work first ;)
    rijAlg.Mode = CipherMode.CBC;
    rijAlg.Padding = PaddingMode.PKCS7;
    rijAlg.BlockSize = 256;
    rijAlg.KeySize = 256;
    rijAlg.Key = Key;
    rijAlg.IV = IV;
    ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
    using (MemoryStream msEncrypt = new MemoryStream()) {
        using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) {
            using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) {
                swEncrypt.Write(plainText);
            }
            encrypted = msEncrypt.ToArray();
        }
    }
}
</code></pre>

<p>The error I'll get:</p>

<pre><code>Specified key is not a valid size for this algorithm.
</code></pre>

<p>So, the problems in short:</p>

<p>1) How come the PHP code accepts the key of length 29 in the Rijndael 256 (CBC mode), and my C# doesn't? I've played around with the Mode, added the Padding later, set the KeySize (was 256 default already), and I just can't see what I'm doing wrong here.</p>

<p>2) When I use a key of length 32, this one is accepted and my code works. I can also decrypt it in C# (but can't test this in PHP). I would like to solve problem 1, and then continue on problem 2, but maybe someone can give me some understanding here. The encrypted string contains 1 '=' in the IV, and 2x '==' (at the end) in the encrypted json. I've read about padding and such, but I was wondering why no '=' signs are visible in the PHP examples I received. Again, maybe after fixing problem 1 this won't be an issue.</p>

<p>Many thanks for reading and I hope I'm not being too stupid here. After a day of trying yesterday I kind of get the feeling I've tried many different approaches and non seem to work.</p>
","<p>You're using an old version of PHP which happily accepts keys that have an invalid length. Rijndael supports key sizes of 16, 24 and 32 bytes and nothing inbetween. The mcrypt extension in PHP silently pads the key with 0x00 bytes up to the next valid key size which is 32 bytes. You will have to do the same thing in C#:</p>

<pre><code>byte[] key = new byte[32];
byte[] password = Encoding.UTF8.GetBytes(encryptionKey);
Array.Copy(password, key, password.Length);
rj.Key = key;
</code></pre>

<p>Keep in mind that in order to provide some security a key must have high entropy. A password is not a key and therefore doesn't provide much entropy, because of the limited character set and possible use words. Always derive a key from the password with available derivation functions such as Argon2, scrypt, bcrypt or PBKDF2 with a high cost factor/iteration count and a random salt.</p>

<p>You should also add authentication to your ciphertexts. Otherwise, an attacker might change the ciphertext without you knowing it. This either done by using an authenticated mode like GCM/EAX or running HMAC over the ciphertext to produce the authentication tag.</p>
","295","<c#><php><encryption><rijndael><initialization-vector>","1","1","2","2015-12-16 13:41:20","34311134","1","1","","","","2015-12-16 08:09:25",""
"34306804","Rijndael PHP vs C# - Invalid KeySize in C# but not in PHP","<p>I try to encrypt a string (json) with Rijndael in C# and come up with a string, which I can offer to a PHP web service. This web service in turn decodes the string using the IV and masterkey (known to them). I have to write the C# code that can talk to the PHP service, I do not control/own the PHP service.</p>

<p>The PHP code for encrypting is as follows:</p>

<pre><code>function encrypt($plaintext) {
    $masterkey = 'masterKeyOfLength29Characters';
    $td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
    $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
    mcrypt_generic_init($td, $masterkey, $iv);
    $crypttext = mcrypt_generic($td, $plaintext);
    mcrypt_generic_deinit($td);
    return base64_encode($iv.$crypttext);
}
$param = array(""key"" =&gt; ""value"");
$encryptedString = rawurlencode(encrypt(json_encode($param)))
</code></pre>

<p>The code above I'll have to convert to C#, so I can encrypt my JSON and offer it to the PHP web service.</p>

<p>There are two problems. The first was with the masterkey length, the second (might be related) is with the rawurlencode of the encrypted data (hard for me to test at this point).</p>

<pre><code>var masterkey = ""masterKeyOfLength29Characters"";
var data = EncryptData(json, masterkey);
// Some code to URL Encode the data, I haven't gotten as far to test this
// since I can't encrypt with the key used in PHP, so I can't call the service
// to test the encoded string from my C# code.
data = HttpUtility.UrlEncode(data);
data = data.Replace(""+"", ""%20"");

public static string EncryptData(string json, string encryptionKey) {
    Rijndael rj = Rijndael.Create();
    rj.Mode = CipherMode.CBC;
    rj.Padding = PaddingMode.PKCS7;
    rj.BlockSize = 256;
    rj.KeySize = 256;
    rj.Key = Encoding.UTF8.GetBytes(encryptionKey); // ERROR here
    rj.GenerateIV();
    var encryptedJSON = EncryptStringToBytes(json, rj.Key, rj.IV);
    var r1 = Convert.ToBase64String(rj.IV);
    var r2 = Convert.ToBase64String(encryptedJSON);
    return r1 + r2;
}
</code></pre>

<p>The EncryptStringToBytes does some checks and uses this code (plucked from the many examples on the internet):</p>

<pre><code>using (Rijndael rijAlg = Rijndael.Create()) {
    // Basically I do the same here as above, and I could also generate
    // the IV here, but then I'd had to return it too. I know I can clean this
    // code up quite a bit, but I'd rather focus on getting it to work first ;)
    rijAlg.Mode = CipherMode.CBC;
    rijAlg.Padding = PaddingMode.PKCS7;
    rijAlg.BlockSize = 256;
    rijAlg.KeySize = 256;
    rijAlg.Key = Key;
    rijAlg.IV = IV;
    ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
    using (MemoryStream msEncrypt = new MemoryStream()) {
        using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) {
            using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) {
                swEncrypt.Write(plainText);
            }
            encrypted = msEncrypt.ToArray();
        }
    }
}
</code></pre>

<p>The error I'll get:</p>

<pre><code>Specified key is not a valid size for this algorithm.
</code></pre>

<p>So, the problems in short:</p>

<p>1) How come the PHP code accepts the key of length 29 in the Rijndael 256 (CBC mode), and my C# doesn't? I've played around with the Mode, added the Padding later, set the KeySize (was 256 default already), and I just can't see what I'm doing wrong here.</p>

<p>2) When I use a key of length 32, this one is accepted and my code works. I can also decrypt it in C# (but can't test this in PHP). I would like to solve problem 1, and then continue on problem 2, but maybe someone can give me some understanding here. The encrypted string contains 1 '=' in the IV, and 2x '==' (at the end) in the encrypted json. I've read about padding and such, but I was wondering why no '=' signs are visible in the PHP examples I received. Again, maybe after fixing problem 1 this won't be an issue.</p>

<p>Many thanks for reading and I hope I'm not being too stupid here. After a day of trying yesterday I kind of get the feeling I've tried many different approaches and non seem to work.</p>
","<p>Just thought I'd add a tiny bit to what @artjom-b has said.</p>

<p>Firstly, it does work :-)  </p>

<p>But in addition you need to change your </p>

<pre><code>rj.Padding = PaddingMode.PKCS7
</code></pre>

<p>to use </p>

<pre><code>rj.Padding = PaddingMode.Zeros 
</code></pre>

<p>Also, technically, your two functions aren't returning the same thing. The PHP returns base 64 of two concatenated bits of binary data whereas the C# returns a concatenation of separate b64 strings. The result will be different in the second half of the returned string.</p>

<p>EDIT: The <em>rough and ready</em> decryption routine:</p>

<pre><code>public string DecryptRijndael(byte[] cipherText, string password, byte[] iv)
{
    var key = new byte[32];
    Encoding.UTF8.GetBytes(password).CopyTo(key, 0);

    var cipher = new RijndaelManaged();
    cipher.Mode = CipherMode.CBC;
    cipher.Padding = PaddingMode.None;
    cipher.KeySize = 256;
    cipher.BlockSize = 256;
    cipher.Key = key;
    cipher.IV = iv;

    byte[] plain;
    using (var decryptor = cipher.CreateDecryptor())
    {
        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write))
            {
                cs.Write(cipherText, 0, cipherText.Length);
                cs.FlushFinalBlock();
                plain = ms.ToArray();
            }
        }
    }
    return Encoding.UTF8.GetString(plain);
}
</code></pre>

<p>NB: All the caveats and warnings from Artjom B still apply. </p>
","295","<c#><php><encryption><rijndael><initialization-vector>","1","1","2","2015-12-16 13:41:20","34311134","1","1","","","","2015-12-16 08:09:25",""
"27964723","What does RijndaelManaged encryption do with invalid key sizes","<p>We are trying to integrate with a legacy c# application that uses RijndaelManaged for symmetric encryption.  However it appears that they have used a 13 byte string as an encryption key!</p>

<p>The code is basically:</p>

<pre><code>var initVectorBytes = Encoding.ASCII.GetBytes(""16-char string"");
var keyBytes = Encoding.ASCII.GetBytes(""13-char string"");
var symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC };
var decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);
var memoryStream = new System.IO.MemoryStream(encryptedbytes);
var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
....
</code></pre>

<p>In theory this shouldn't work - the <a href=""http://msdn.microsoft.com/en-us/library/2f5ff61x(v=vs.110).aspx"" rel=""nofollow"">docs</a> clearly say ""The key size must be 128, 192, or 256 bits"" and when we try this (on a Xamarin/Mono compiler - don't have easy access to .net at the moment) it throws an exception.</p>

<p>But it apparently works on the legacy system, and they have unit tests that also call CreateDecryptor with a 13 byte key; so presumably a real .net system does somehow do something with this code.  (I note that the docs for .net version 2.0 don't talk about key length restrictions - the code is compiled using .net 3.5 however)</p>

<p>Is it possible that it uses the Rijndael algorithm with a 104 byte key and block size? Or would it somehow pad the key or something?</p>
","","289","<c#><.net><encryption><rijndael><rijndaelmanaged>","0","","0","2015-01-15 13:45:28","","3","","196463","","2015-01-15 13:45:28","2015-01-15 13:38:13",""
"31413244","Converting C# cryptography to Java","<p>I have been tasked with converting a C# cryptography method to Java and am stuck. I know the C# codes works, but I am having trouble getting my Java code to work.</p>

<p>Here is the C# code:</p>

<pre><code>private const int Nb = 4; // Legal values:  4 = 128-bit blocks

public static void Decrypt(byte[] input, Stream output)
    { 
        var s1 = new MemoryStream(input);
        const int BufferSize = 1024;
        byte[] buffer = new byte[BufferSize];

        input.Read(buffer, 0, 4);
        int pad = buffer[3];

        RijndaelManaged rijndael = new RijndaelManaged();
        rijndael.BlockSize = Nb * 32;
        rijndael.KeySize = buffer[1] * 32;

        rijndael.Mode = CipherMode.ECB;
        rijndael.Padding = PaddingMode.None;

        byte[] key = GetKey(buffer[1]);
        ICryptoTransform decryptor = rijndael.CreateDecryptor(key, GetIV());

        int bytes;
        while ((bytes = input.Read(buffer, 0, BufferSize)) &gt; 0)
        {
            for (int i = 0; i &lt; bytes; i += rijndael.BlockSize)
            {
                decryptor.TransformBlock(buffer, i, rijndael.BlockSize, buffer, i);
            }
            output.Write(buffer, 0, bytes);
        }
        output.SetLength(output.Length - pad - 4);
    }
</code></pre>

<p>And here is my attempt in Java so far:</p>

<pre><code>public static String decrypt(byte[] input) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");
    byte[] key = getKey(input[1]);
    SecretKey secretKey = new SecretKeySpec(key, 0, key.length, ""AES/ECB/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(getIV()));
    // remove first 4 since C# code reads past those
    byte[] finalDecoded = Arrays.copyOfRange(input, 4, input.length);
    byte[] decryptedVal = cipher.doFinal(finalDecoded);
    return new String(decryptedVal);
}
</code></pre>

<p>Some More Information</p>

<ul>
<li><p>For <code>GetIV</code> and <code>GetKey</code>, I can guarantee that the results in java are the same (I have compared every byte), but I am not including those methods because I believe that is sensitive information. I can also guarantee that the input byte[] is identical and (redundantly) the same length. </p></li>
<li><p><strong>Debugging attempts:</strong> The current error in Java is <code>ECB mode cannot use IV</code>. </p>

<ul>
<li>When I remove this code : <code>new IvParameterSpec(getIV())</code> I get this error: <code>Wrong algorithm: AES or Rijndael required</code></li>
<li>If I change the algorithm to only <code>AES</code> or only <code>Rijndael</code> I get this error: <code>Input length must be multiple of 16 when decrypting with padded cipher</code>. The input length starting is <code>424</code> and <code>420</code> after reading past/removing the first 4 bytes. I have verified that the input bytes are the same for Java and C#.</li>
</ul></li>
</ul>

<p>Where am I going wrong in the Java code?</p>
","<p>You are getting the error <code>ECB mode cannot use IV</code> because ECB doesn't perform chaining, so IV is meaningless. The difference is Java throws an error whereas C# just ignores the IV. </p>

<blockquote>
  <p>When I remove this code : <code>new IvParameterSpec(getIV())</code> I get this error: <code>Wrong algorithm:</code><strong><code>AES or Rijndael</code></strong><code>required</code></p>
  
  <p>If I change the algorithm to only AES or only Rijndael I get this error: <code>Input length must be multiple of 16 when decrypting with</code><strong><code>padded cipher.</code></strong></p>
</blockquote>

<p>You had the right idea, but you went too far. This error is only to do with the <code>SecretKeySpec</code>, which doesn't care about the mode, but just the algorithm. <code>Cipher</code> is where you specify mode. Also, Rijndael and AES aren't quite the same thing.</p>

<p>So start by changing the first few lines to this:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""Rijndael/ECB/NoPadding"");
byte[] key = getKey(input[1]);
SecretKey secretKey = new SecretKeySpec(key, 0, key.length, ""Rijndael"");
cipher.init(Cipher.DECRYPT_MODE, secretKey);
</code></pre>

<p>Note that since you're using the entire <code>key</code> you don't need the offset and length arguments, so you can just do</p>

<pre><code>SecretKey secretKey = new SecretKeySpec(key, ""Rijndael"");
</code></pre>

<hr>

<p>The original C# code has some not-so-obvious behavior:</p>

<pre><code>while ((bytes = input.Read(buffer, 0, BufferSize)) &gt; 0)
{
    for (int i = 0; i &lt; bytes; i += rijndael.BlockSize)
    {
        decryptor.TransformBlock(buffer, i, rijndael.BlockSize, buffer, i);
    }
    output.Write(buffer, 0, bytes);
}
</code></pre>

<p>When the loop gets to the end of the <code>input</code>, it will copy however much is left of it into <code>buffer</code>. Unless the last <code>Read</code> was exactly 1024 bytes, there will be residue from the previous loop (or from initialization if it gets the whole <code>input</code> with one <code>Read</code> operation) after the end of the input. </p>

<p>The inner loop decrypts one 16-byte block at a time. In the case of your 420-byte example, the last block will consist of the remaining 4 bytes of input <strong>and 12 more bytes of garbage</strong>. But it's okay because the <code>output.Write</code> only writes <code>bytes</code> number of bytes to truncate the garbage. You will have to replicate this behavior in your Java code.</p>

<hr>

<p><em>Side note: do you absolutely have to use ECB? It's not very secure...</em></p>
","286","<java><c#><encryption><aes><rijndael>","4","6","1","2015-07-14 19:00:31","31414449","0","2","1646783","","2015-07-14 18:36:23","2015-07-14 17:18:13",""
"47583149","What is the best way to encrypt the contents of a SecureString using a Rijndael encryptor?","<p>I have a need to take sensitive information collected from a WPF <code>PasswordBox</code>.  After the user enters this data, it needs to be encrypted using a <code>System.Security.Cryptography.Rijendael</code> encryptor object.</p>

<p>Currently, this code that is being modified takes a ""plaintext"" string and encrypts it and using the following code:</p>

<pre><code>using (var rijAlg = Rijndael.Create())
{
    var salt = ... //Generated Salt
    rijAlg.KeySize = CryptographyHelper.ENCRYPTION_KEYSIZE;
    rijAlg.Key = encryptionKey; //This is an encryption key safely derived elsewhere.
    rijAlg.IV = salt;

    var encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
    using (var msEncrypt = new MemoryStream())
    {
        using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
        {
            using (var swEncrypt = new StreamWriter(csEncrypt))
            {
                swEncrypt.Write(plainText); //Plain Text value.
            }
            encrypted = msEncrypt.ToArray();
        }
    }
}
</code></pre>

<p>The value <code>plainText</code> above is actually a value that is passed into this encryption method.  At the end of the method, the <code>encrypted</code> value is passed into <code>Convert.ToBase64String(...)</code> and the data is converted to Base64 and return from the encryption method.</p>

<p>My question is, how can I modify the above code to take a <code>SecureString</code> object representing the value that needs to be encrypted, securely encrypt the associated value, clean up the associated data and return the encrypted data as a string, just as I am the <code>plainText</code> value?  Keep in mind, I'll need to derive a follow-up <code>Decrypt(...)</code> method which I hope can return a <code>SecureString</code> object, but figuring that out can be another question.</p>
","<p>I don't have the full code with me because I did this a long time ago. The only way I found to securely convert a <code>SecureString</code> to a hashed password was using a <code>Stream</code> by reading by one character at a time. Supposedly, by reading by one character you ensure that a memory dump wouldn't reveal the password.  </p>

<p>You can see <a href=""https://stackoverflow.com/a/28249560/2141621"">this answer</a> for a sample implementation of reading by one character. If I were you, I'd create a custom <code>Stream</code> class that performs the <code>Read</code> into the <code>Write</code> of the <code>CryptoStream</code>. You could also free the unmanaged pointer on the <code>Dispose</code> of the <code>Stream</code>.</p>
","285","<c#><security><encryption><rijndael><securestring>","0","0","1","2017-11-30 22:02:25","","3","1","","","","2017-11-30 21:46:58",""
"45271988","Decryption with Rijndael returns extra question mark C#","<p>I have an extra question mark(s) when it converts to string.<br>
Here is my code:</p>

<p><strong>My Encryption method:</strong></p>

<pre><code>    public static Stream EncryptStream(Stream inputStream)
            {
                string key = ""ThisIsMySuperSecureKey"";
                byte[] keyBytes = Encoding.UTF32.GetBytes(key);

                Rfc2898DeriveBytes derviedKey = new Rfc2898DeriveBytes(key, keyBytes);

                RijndaelManaged rijndaelCSP = new RijndaelManaged();
                rijndaelCSP.Key = derviedKey.GetBytes(rijndaelCSP.KeySize / 8);
                rijndaelCSP.IV = derviedKey.GetBytes(rijndaelCSP.BlockSize / 8);

                var encryptor = rijndaelCSP.CreateEncryptor();

                MemoryStream ms = new MemoryStream();
                CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write);

                //inputStream.Position = 0;
                byte[] toEncrypt = StreamToByteArray(inputStream);

                cs.Write(toEncrypt, 0, toEncrypt.Length);
                cs.FlushFinalBlock();

                MemoryStream output = new MemoryStream(ms.ToArray());
                ms.Close();
                return (Stream)output;

            }
</code></pre>

<p><strong>My method to Convert Stream to Byte Array:</strong>          </p>

<pre><code>       public static byte[] StreamToByteArray(Stream inputStream)
        {

            var ms = new MemoryStream();
            inputStream.Position = 0;
            inputStream.CopyTo(ms);
            return ms.ToArray();
        }
        public static Stream DecryptStream(Stream inputStream)
        {
            string key = ""ThisIsMySuperSecureKey"";
            byte[] keyBytes = Encoding.UTF32.GetBytes(key);

            Rfc2898DeriveBytes derviedKey = new Rfc2898DeriveBytes(key, keyBytes);

            RijndaelManaged rijndaelCSP = new RijndaelManaged();
            rijndaelCSP.Key = derviedKey.GetBytes(rijndaelCSP.KeySize / 8);
            rijndaelCSP.IV = derviedKey.GetBytes(rijndaelCSP.BlockSize / 8);

            var decryptor = rijndaelCSP.CreateDecryptor();

            byte[] arrayOfEncrypedStream = StreamToByteArray(inputStream);

            MemoryStream ms = new MemoryStream(arrayOfEncrypedStream);
            CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);


            cs.Read(arrayOfEncrypedStream, 0, arrayOfEncrypedStream.Length);
            MemoryStream output = new MemoryStream(ms.ToArray());

            ms.Close();
            return output;
         }
</code></pre>

<p><strong>My method to check if Stream is encrypted:</strong> </p>

<pre><code>public static string IsCryptedStream(Stream cryptedStream)
        {
            string result = """";
            byte[] convStremToBytes = Encryption.StreamToByteArray(cryptedStream);
            return result = Encoding.UTF32.GetString(convStremToBytes);
        }
</code></pre>

<p>I read similar article with this issue, but it didn't work out. Need help. Thank you!!!</p>

<p><strong>UPDATE:</strong></p>

<pre><code>    static void Main(string[] args)
    {
       byte[] streamBytes = Encoding.Unicode.GetBytes(""Hello people"");
       MemoryStream ms = new MemoryStream(streamBytes);
       var cryptedStream =  Encryption.EncryptStream(ms);
       var decryptStream = Encryption.DecryptStream(cryptedStream);
       string isCryptedStreamAfterDecryption = 
   Demo3.IsCryptedStream(decryptStream);
       Console.WriteLine($""After Decryption: {isCryptedStreamAfterDecryption}"");
    }
</code></pre>

<p><strong>Result</strong>: ""Hello people???""</p>
","","269","<c#><encryption><rijndael>","1","","0","2017-07-26 02:21:01","","3","","7655895","","2017-07-26 02:21:01","2017-07-24 03:01:38",""
"43539476","PHP mcrypt_decrypt in NodeJS","<p>I've been hunting the internet for the last 3 hours and I've finally decided to ask the question. Is is possible to decrypt a base64 text string in NodeJS that was encrypted through PHP.</p>

<p>I've tried many steps to break it down but nothing I do seems to work.</p>

<p>My Old PHP Methods That DOES work.</p>

<pre><code>class EncryptionSystem{
    private $iv;
    public $iv_size;
    public $key;

    public function __construct(){
        $this-&gt;iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
        $this-&gt;iv = mcrypt_create_iv($this-&gt;iv_size, MCRYPT_RAND);
        $this-&gt;key = ""SUPER SECURE STRING"";
    }

    public function crypt_data($data = null){
        $ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this-&gt;key, $data, MCRYPT_MODE_CBC, $this-&gt;iv);
        $ciphertext = $this-&gt;iv.$ciphertext;
        return $ciphertext;
    }

    public function decrypt_data($data){
        $ciphertext_dec = base64_decode($data);
        $iv_dec = substr($ciphertext_dec, 0, $this-&gt;iv_size);
        $ciphertext_dec = substr($ciphertext_dec, $this-&gt;iv_size);
        $plaintext_dec = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;key, $ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec);
        return array($iv_dec,$plaintext_dec);
    }
}
</code></pre>

<p>My Attempt at the NodeJS using Mcrypt (Does Not Work)</p>

<pre><code>var post64 = results[0].post;
var de64 = Buffer.from(post64, 'base64');
var desCBC = new MCrypt(""rijndael-128"",""cbc"");

var iv = de64.slice(0,desCBC.getIvSize());
var ciphered = de64.slice(desCBC.getIvSize());

console.log(""IV:"",iv);
console.log(iv.length);
console.log(""IV SIZE:"",desCBC.getIvSize());
desCBC.open(new Buffer(password.slice(0,desCBC.getIvSize(),""utf8"")),new Buffer(iv,""utf8""));

var plaintext = desCBC.decrypt(new Buffer(ciphered,""utf8""));
console.log(plaintext.toString());
</code></pre>

<p>Another attempt using Crypto (also doesn't work)</p>

<pre><code>console.log(""Base64"",post64);
console.log(""RAW"",de64.toString(""binary""));
var iv = de64.toString(""binary"").slice(0,16);
var ciphered = de64.toString(""binary"").slice(16);

console.log(""IV:"",iv);
console.log(iv.length);
console.log(""Ciphered:"",ciphered);

var decipher = crypto.createDecipheriv(algorithm,password,new Buffer(iv,'hex'));
</code></pre>
","<p>Try use module <code>crypto-js</code>. It work fine for me!</p>

<pre><code>aesDecryptDef(cipherData) {
    let CryptoJS = require(""crypto-js""),
        key = CryptoJS.enc.Utf8.parse(this.AES_KEY),
        iv = CryptoJS.enc.Utf8.parse(this.AES_IV),
        decrypted = CryptoJS.AES.decrypt(cipherData, key, {
            iv: iv
        });
    return decrypted.toString(CryptoJS.enc.Utf8);
};
</code></pre>
","260","<php><node.js><mcrypt><rijndael><node-crypto>","1","0","1","2017-04-21 10:35:23","","0","","","","","2017-04-21 09:50:29",""
"1912293","c# AES CBC using 2 methods to add 2 pieces of encrypted data into one file","<p>The key issue is if I use a new cryptostream it will add new IV to second piece of data. Then this wont be ablt to decrypted. So I need to make sure the stream will use the last block of 1st data to encrypt the first block of 2nd piece of data.</p>

<p>It comes up with the task of using same stream to encyprt 2 piece of data.
But I couldn't figure it out. Tried creating a new class and put all encryption settings inside the class. Then call StreamWriter from the main. But no luck.</p>

<p>Anything I miss or got wrong?</p>
","<p>Instead of letting the <code>AesCryptoServiceProvider</code> generate its own IV, set the <code>IV</code> property explicitly before encrypting the second portion. The value should be the last block of ciphertext from the previous segment. </p>

<p>You shouldn't need to create a new class. Just set the property correctly.</p>
","257","<c#><encryption><aes><rijndael>","0","2","1","2018-06-26 08:48:58","1912480","0","","1033581","","2018-06-26 08:48:58","2009-12-16 04:27:49",""
"14151924","Encrypt and decrypt the dataset","<p>I'm loading the data into dataset form SQL Server. Now I wanna this data to be write in XML file in encrypted form and save it somewhere in disk.</p>

<p>On reading this XML into dataset, I wanna dataset to be encrypt again.</p>

<p>I have used ""<strong>RijndaelSimple</strong> class to encrypt and decrypt dataset, but it takes much time to complete execution as it do it row by row in dataset.  I have around 50000 rows in dataset.</p>

<p>Is there any other option I have to encrypt and decrypt dataset on a go?</p>
","","252","<encryption><rijndael>","0","","0","2015-11-13 21:12:35","","3","1","126273","","2015-11-13 21:12:35","2013-01-04 06:03:15",""
"31028240","Decrypt RIJNDAEL-128 in Java","<p>I have encrypted text using Crypt function in Laravel. I am using cipher - MCRYPT_RIJNDAEL_128 and CBC. How can I decrypt in Java? Here is the code of decryption in Laravel/PHP</p>

<pre><code>$payload = json_encode(base64_decode($payload), true);
$value = base64_decode($payload['value']);
$iv = base64_decode($payload['iv']);
return unserialize($this-&gt;stripPadding($this-&gt;mcryptDecrypt($value, $iv)));

protected function mcryptDecrypt($value, $iv)
    {
        try
        {
            return mcrypt_decrypt($this-&gt;cipher, $this-&gt;key, $value, $this-&gt;mode, $iv);
        }
        catch (Exception $e)
        {
            throw new DecryptException($e-&gt;getMessage());
        }
    }
</code></pre>
","","250","<java><php><laravel><laravel-5><rijndael>","0","","0","2015-06-24 13:40:15","","3","","","","","2015-06-24 13:40:15",""
"31727356","PHP Encryption filter not working properly with rijndael","<p>I am having some issues with the encryption filters <a href=""http://php.net/manual/en/filters.encryption.php"" rel=""nofollow"">http://php.net/manual/en/filters.encryption.php</a></p>

<p>The code works fine with the tripledes algorithm, however, when changing to rijndael-256 or 128, it just produces garbled data upon read.</p>

<p>I thought it was a error with the IV or key system, so i tried with a hardcoded pair in both read and write, however, it still produces garbled data.</p>

<pre><code>public function writeEncrypt($path, $data){

    $key = ""1234567812345678"";
    $iv = ""1234567812345678"";
    $opts = array('iv'=&gt;$iv, 'key'=&gt;$key, 'mode'=&gt;'cbc');

    $fp = fopen($path, 'wb');
    stream_filter_append($fp, 'mcrypt.rijndael-128', STREAM_FILTER_WRITE, $opts);
    fwrite($fp, $data);
    fclose($fp);

    return true;
}

public function readDecrypt($path){

    $key = ""1234567812345678"";
    $iv = ""1234567812345678"";
    $opts = array('iv'=&gt;$iv, 'key'=&gt;$key, 'mode'=&gt;'cbc');

    $fp = fopen($path, 'rb');
    stream_filter_append($fp, 'mcrypt.rijndael-128', STREAM_FILTER_READ, $opts);
    $data = rtrim(stream_get_contents($fp));
    fclose($fp);

    header(""Content-Type: application/zip"");
    header(""Content-Length: "" . count($data));

    echo $data;
}
</code></pre>

<p>All data is input in binary form.
What am i doing wrong?
(No errors in the php log)</p>
","<p>You're passing 'mcrypt.rijndael-128' instead of 'm<strong>de</strong>crypt.rijndael-128' when trying to read the file.</p>

<p>Anyway, filters are really powerful and often convenient, but you shouldn't use this one in particular, as it doesn't provide authentication, which is very important in cryptography.</p>
","238","<php><encryption><stream><mcrypt><rijndael>","1","2","1","2015-07-31 12:05:41","31745781","0","","","","","2015-07-30 15:02:05",""
"7701609","Encryption/Hashing issues","<p>I'm working on a little script that will allow me to store relatively secure information in a cookie to validate a user login without the use of sessions. Part of the output is an encrypted salt to use when generating a hmac_hash with some of the information stored in the cookie, and some of the user information in the database.</p>

<p>However, after some testing, I've ran into a problem with the encryption/decryption of the strings and causing different hash results.</p>

<p>ie:</p>

<pre><code>$str = '123456abcdef';
$hash1 = sha1($str);

$v1 = do_encrypt($str);
$v2 = do_decrypt($v1);

$hash2 = sha1($v2);
</code></pre>

<p>and I end up with</p>

<pre><code>$hash1 - d4fbef92af33c1789d9130384a56737d181cc6df 
$hash2 - 0d6034f417c2cfe1d60d263101dc0f8354a1216f
</code></pre>

<p>but when I echo both strings, they are both 123456abcdef.</p>

<p>The do_encrypt function is as follows:</p>

<pre><code>function do_encrypt($value) {

    $salt = generate_salt();
    $td = mcrypt_module_open('rijndael-256', '', 'cbc', '');
    mcrypt_generic_init($td, $ek, $salt);
    $encrypted_data = mcrypt_generic($td, $value);

    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);
    return base64_encode($salt.$encrypted_data);    
}
</code></pre>

<p>The do_decrypt function:</p>

<pre><code>function do_decrypt($value) {

    $data = base64_decode($value);
    $salt = substr($data, 0, 32);
    $data = substr($data, 32, strlen($data));
    $td = mcrypt_module_open('rijndael-256', '', 'cbc', '');
    mcrypt_generic_init($td, $ek, $salt);
    $decrypted_data = mdecrypt_generic($td, $data);

    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);
    return $decrypted_data;
}
</code></pre>

<p>for both functions $ek is an encryption key pulled from another file.</p>

<p>I'm trying to understand why the characters that display are the same, but the actual variables are different (otherwise the hash results would be the same), and is there any way to ensure that both strings are identical for hashing purposes?</p>

<p>Thanks,
Ryan.</p>
","<p>As per comments, it looks like you are getting trailing nulls - It's likely that mcrypt has a block size of 32 bytes and that any encrypted/decrypted string must be a multiple of this many bytes.</p>

<p>Taken from the <a href=""http://au2.php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow""><code>mcrypt_encrypt</code></a>  documentation:</p>

<blockquote>
  <p>If the size of the data is not n * blocksize, the data will be padded with '\0'.</p>
</blockquote>
","234","<php><hash><sha1><mcrypt><rijndael>","2","2","1","2011-10-09 06:59:46","7701852","17","0","455255","","2011-10-09 05:52:26","2011-10-09 05:24:07",""
"22207176","Precalculating AES output length","<p>I am building a file transfer protocol that runs over TCP. I am encrypting data before sending it. Is it possible to calculate the size of the ciphertext before actually encrypting?</p>

<p>I want to send the filesize to the client so he knows when the datastream has ended, while pushing the ciphertext to the stream as soon as it is output.</p>

<p>To encrypt I am using the RijndaelManaged .NET class.</p>

<p>For example, a file of size 634 bytes is encrypting to 660 bytes.</p>

<p>Using the formula I found, and a block size of 16:</p>

<p>(inputSize / blockSize + 1) * blockSize</p>

<p>I am getting 650 bytes. Why is there the discrepancy?</p>

<p>Examples of input - output size pairs (in bytes):</p>

<p>Input: <strong>905296</strong> Output: <strong>905332</strong></p>

<p>Input: <strong>82320</strong>  Output: <strong>82356</strong></p>

<p>Input: <strong>308</strong>    Output: <strong>340</strong></p>
","<p>The formula you found is not completely correct.<br>
Given ECB or CBC (the only choices in this class):<br>
Calculate (Bytecount / Blocksize) and <strong>omit the decimal part</strong><br>
Then add 1 for padding, then multiply with Blocksize.  </p>

<p>634/16 = 39.625 => 40<br>
40 * 16 = 640  </p>

<p>The 10 other bytes...probably a header or something like that.<br>
MS is known to add own stuff everywhere.</p>
","234","<c#><encryption><aes><rijndael>","1","1","1","2014-03-05 19:43:14","","0","","3233089","","2014-03-05 19:43:14","2014-03-05 19:21:21",""
"39072347","convert Encryption Algo from C# to Java","<pre><code>public static string Encrypt(string KeyToEncrypt)
    {
        byte[] clearBytes = System.Text.Encoding.Unicode.GetBytes(KeyToEncrypt);
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(_Pwd, _Salt);
        //Calling another private method for Encryption
        byte[] encryptedData = Encrypt(clearBytes, pdb.GetBytes(32), pdb.GetBytes(16));
        return Convert.ToBase64String(encryptedData);
    }

    private static byte[] Encrypt(byte[] candelaData, byte[] Key, byte[] IV)
    {
        MemoryStream ms = new MemoryStream();
        CryptoStream cs = null;

            Rijndael alg = Rijndael.Create();
            alg.Key = Key;
            alg.IV = IV;
            cs = new CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write);
            cs.Write(candelaData, 0, candelaData.Length);
            cs.FlushFinalBlock();
            return ms.ToArray();
     }
</code></pre>

<p>I want to convert the following algo in java, I have searched for the libraries and couldn't get anything. Help Please. ?</p>
","<p>Darab , your best bet in Java has to be Bouncy Castle.  You have API's for crypt in salting as well as the AES Rijndael as i read from the code.</p>

<p>For the Rejndael part you can refer : <a href=""http://www.itcsolutions.eu/2011/08/24/how-to-encrypt-decrypt-files-in-java-with-aes-in-cbc-mode-using-bouncy-castle-api-and-netbeans-or-eclipse/"" rel=""nofollow"">http://www.itcsolutions.eu/2011/08/24/how-to-encrypt-decrypt-files-in-java-with-aes-in-cbc-mode-using-bouncy-castle-api-and-netbeans-or-eclipse/</a>. This gives you a fair idea of the AES part of the code and this question here <a href=""https://stackoverflow.com/questions/24405731/rfc2898derivebytes-in-java"">Rfc2898DeriveBytes in java</a> gives you a great idea of salting and Rfc2898 as well.</p>
","234","<java><rijndael><cryptostream>","0","0","1","2016-08-22 06:25:19","","0","","","","","2016-08-22 06:09:08",""
"26885460","Read Rijndael encrypted file in memory itself to decrypt","<p>I have a file which is encrypted using Rijndael encryption method. I want to decrypt in memory itself, instead of writing it to disk.</p>

<p>So I tried using <code>BinaryReader</code> to read the file. But how to use BinaryReader and read the binary file so that i can decrypt it. I tried using ReadString and and it gives <code>""Unable to read beyond the end of the stream.""</code> error .</p>

<p>So how to read the file so that I can decrypt file using Rijndael method in memory itself.</p>
","","228","<vb.net><encryption><rijndael><binaryreader>","0","","0","2014-11-12 18:43:10","","4","","589259","","2014-11-12 18:43:10","2014-11-12 11:06:27",""
"40602337","C# store user's sensitive credential data for 3rd party system","<p>In our application, I need to ask user to enter credentials such as login, apikey for a 3rd party system, so our application can make API call to that system using the credential. The 3rd party system is using SOAP with login/password, or Oauth using with APIKey to generate token etc.</p>

<p>What is the best practice to store user's sensitive credential data?</p>

<p>Currently I have two databases in different servers, one for storing unique salt value for each client, and another database for storing encrypted data, Rijndael Encryption which is computed with salt values. Every time I want to make API call to 3rd party system, I retrieve data from both databases and decrypted data into credentials to use.</p>

<p>From what I heard, this is not a good practice, password should be hashed not encrypted. but if I hash the credential, the information is lost and I can never restore it for calling 3rd party system. </p>
","","226","<c#><encryption><hash><sha256><rijndael>","1","","0","2016-11-15 05:17:30","","4","","","","","2016-11-15 04:57:37",""
"44202499","How to get the right KEY and IV in Rinjdael encryption equivalent in JAVA","<p>I have a code in VB.Net with a Rijndael encryption algorithm:</p>

<pre class=""lang-vb.net prettyprint-override""><code>Public Function DesencriptarCertificado(ByVal pCertificado As String, ByVal pClave As String) As Byte()
    Dim byteCertificadoDescencriptado As Byte() = Nothing
    Dim Algoritmo As SymmetricAlgorithm = New RijndaelManaged()
    Dim CertClaveDesencriptada As String = """"

    CertClaveDesencriptada = DesencriptarString(pClave, """")
    Transform(CertClaveDesencriptada, Algoritmo)


    Dim ICryptoTransform As ICryptoTransform = Algoritmo.CreateDecryptor()
        byteCertificadoDescencriptado = HexToByte(pCertificado)
        byteCertificadoDescencriptado = ICryptoTransform.TransformFinalBlock(byteCertificadoDescencriptado, 0, byteCertificadoDescencriptado.Length)
    Return byteCertificadoDescencriptado
End Function

Public Sub Transform(ByVal pClave As String, ByRef pAlgoritmo As SymmetricAlgorithm)

    Dim bytes As Byte() = New Byte(7) {}
    Dim BytesClave As Byte() = Encoding.ASCII.GetBytes(pClave)
    Dim length As Integer = Math.Min(BytesClave.Length, bytes.Length)

    For i As Integer = 0 To length - 1
        bytes(i) = BytesClave(i)
    Next

    Dim key As New Rfc2898DeriveBytes(pClave, bytes)
    //ASIGNO BYTES A KEY E IV
    pAlgoritmo.Key = key.GetBytes(pAlgoritmo.KeySize \ 8)
    pAlgoritmo.IV = key.GetBytes(pAlgoritmo.BlockSize \ 8)
End Sub
</code></pre>

<p>The problem is the IV and KEY in JAVA do not get the same bytes, so signature is not the same, it works perfectly if I initialize the KEY and IV manually with the same bytes that are generated in VB.Net, but it is not feasible of course because it would only work for a specific certificate, and the idea is that it works generically, after a search I tried some variants but without success, I could not get the KEY And IV, I would appreciate any help with the subject.</p>

<p>Java Code</p>

<pre class=""lang-java prettyprint-override""><code>public byte[] DesencriptarCertificado(String pCertificado, String pClave) throws NoSuchAlgorithmException, InvalidKeySpecException, UnsupportedEncodingException, NoSuchPaddingException, InvalidAlgorithmParameterException, NoSuchProviderException, ShortBufferException, IOException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    try {
        String CertClaveDesencriptada = DesencriptarString(pClave, """");

        ////////////Transform//////////////
        byte[] bytes = new byte[8];
        byte[] BytesClave = CertClaveDesencriptada.getBytes();
        int length = Math.min(BytesClave.length, bytes.length);

        for (int i = 0; i &lt; length; i++) {
            bytes[i] = BytesClave[i];
        }

        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec pbeKeySpec = new PBEKeySpec(CertClaveDesencriptada.toCharArray(), bytes, 12, 1000);
        Key secretKey = factory.generateSecret(pbeKeySpec);
        byte[] encoded = secretKey.getEncoded();

        byte[] KEY = new byte[32];
        byte[] IV = new byte[16];

        //ASIGNO BYTES A KEY E IV
        System.arraycopy(encoded, 0, KEY, 0, 32); 
        System.arraycopy(encoded, 32, IV, 0, 16);

        SecretKeySpec secret = new SecretKeySpec(key, ""Rijndael"");
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(IV);
        _cipherDecrypEncrypt = Cipher.getInstance(""AES/CBC/PKCS7Padding"", ""BC"");
        _cipherDecrypEncrypt.init(Cipher.DECRYPT_MODE, secret, ivSpec);


        ///////////////DESENCRIPTAR CERTIFICADO/////////////////////
        byte[] beforeEncrypt = HexToByte(pCertificado);
        byte[] byteCertificadoDescencriptado = _cipherDecrypEncrypt.doFinal(beforeEncrypt);

        return byteCertificadoDescencriptado;

    } catch (InvalidKeyException e) {
        throw new TAFACE2ApiEntidad.TAException(e.getMessage());
    } catch (IllegalBlockSizeException e) {
        System.out.println(e);
        throw new TAFACE2ApiEntidad.TAException(e.getMessage());
    } catch (BadPaddingException e) {
        System.out.println(e);
        throw new TAFACE2ApiEntidad.TAException(e.getMessage());
    }

}
</code></pre>
","<ol>
<li><p>If your salt is supposed to be 7 bytes long, as seen in your VB.NET code <code>Dim bytes As Byte() = New Byte(7) {}</code>, you should declare it as such:</p>

<pre><code>byte[] bytes = new byte[7];
</code></pre></li>
<li><p>The constructor for <code>PBEKeySpec</code> that you're trying to use is <a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/PBEKeySpec.html#PBEKeySpec(char[],%20byte[],%20int,%20int)"" rel=""nofollow noreferrer""><code>PBEKeySpec(char[] password, byte[] salt, int iterationCount, int keyLength)</code></a> where you use request 12 iterations for an output length of 1000.</p>

<p>You need to use </p>

<pre><code>new PBEKeySpec(CertClaveDesencriptada.toCharArray(), bytes, 1000, 384);
</code></pre>

<p>where 384 means 32 + 16 bytes in bits.</p></li>
</ol>
","216","<java><vb.net><encryption><rijndael>","1","1","1","2017-05-27 07:53:50","44209752","7","2","1816580","","2017-05-26 13:24:48","2017-05-26 13:10:09",""
"37242628","PHP cryption on server won't work ""mcrypt_get_iv_size"" function","<p>So I was writing a web application and for some uses I need to encrypt string and decrypt it later, and everything from my code works perfectly on localhost on Macbook on El Capitan 10.11.4 and XAMPP 5.6.15-1 but when I upload code on the server it just wont work. I found one problem (Also I tried on multiple servers). </p>

<p>So this is my code:</p>

<pre><code>&lt;?php
session_start();
header(""Content-Type: text/html;charset=UTF-8"");
if (isset($_POST[""file""])) {
    $filename = $_POST[""file""];
    //$filename = $_GET[""file""];
    $filename = substr($filename, 12);

    $username = $_SESSION[""username""];
    $key = $_SESSION[""key""];

    $filename = ""../users/$username/text/"" . $filename;

    $fileNumber = $_POST[""number""];

    ///Cloude/users/antonio/text/teext/file2.txt
    // Cloude/script

    $handle = fopen($filename, ""r"");
    $contents = fread($handle, filesize($filename));
    fclose($handle);
echo $contents;
    $decrypt = str_replace("" "", ""+"", $contents);

echo "" ------ 1 ------ "";

    $decrypt = explode('|', $decrypt.'|');
    $decoded = base64_decode($decrypt[0]);
    $iv = base64_decode($decrypt[1]);

echo "" ------ 2 ------"";

    if(strlen($iv)!==mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC)){ return false; }

echo "" ------ 3 ------"";

    $key = pack('H*', $key);
    $decrypted = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $decoded, MCRYPT_MODE_CBC, $iv));
    $mac = substr($decrypted, -64);
    $decrypted = substr($decrypted, 0, -64);
    $calcmac = hash_hmac('sha256', $decrypted, substr(bin2hex($key), -32));
    if($calcmac!==$mac){ return false; }
    $decrypted = unserialize($decrypted);

    echo json_encode($decrypted . ""qJB0rGtIn5UB1xG03efyCp55"");
}
</code></pre>

<p>and, this echoes are just for testing which line won't work. So when I try to run it all it will just print ""------ 1 ------ and ------ 2 ------"", the code after</p>

<pre><code>mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC)
</code></pre>

<p>just wont work on server, does anyone knows why?</p>

<p>EDIT: I found the bug, it was the hosting problem, they do some weird things, thanks anyway!</p>
","<p>You should not use the MCrypt functions anymore. Why? because <strong>MCrypt is considered abandonware</strong>. The library is no longer actively maintained and <a href=""http://sourceforge.net/p/mcrypt/bugs"" rel=""nofollow"">a long list of known bugs</a> are not fixed since a long time.</p>

<p>So, what would be the solution to your problem?
The quick, easy and safest option is to use a <a href=""https://github.com/Pixelfck/SymmetricEncryption"" rel=""nofollow"">drop in library</a>.</p>

<p>Example of doing strong crypto the easy way:</p>

<pre><code>// Assuming a PSR-4 compatible autoloader

use Driftwood\SymmetricEncryption;
$password = 'correct horse battery staple';

$crypto = new SymmetricEncryption(20);

$encrypted = $crypto-&gt;encrypt('Never roll your own crypto.', $password);
$decrypted = $crypto-&gt;decrypt($encrypted, $password);

echo $decrypted; // Never roll your own crypto.
</code></pre>

<p><br><br>
If you reaally want to create your own crypto library (you shouldn't) then the  recommended solution is to use PHP's <a href=""http://php.net/manual/en/book.openssl.php"" rel=""nofollow"">OpenSSL extension</a>.
But: crypto is hard, exceptionally hard. A good crypto wrapper requires multiple cryptographers and PHP specialists working together, checking each other and double checking each change in the code. Scrutinizing every decision.</p>
","214","<php><encryption><mcrypt><rijndael><cbc-mac>","-1","2","1","2016-05-15 20:52:23","37243473","7","1","4120475","","2016-05-15 19:50:07","2016-05-15 19:17:13",""
"27110513","CRijndael only encrpyting first 32 bytes of longer string","<p>I'm using CRijndael ( <a href=""http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr"" rel=""nofollow"">http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr</a> ) for encryption using a null based iv (I know that's an issue but for certain reasons I'm stuck with having to use that).</p>

<p>For strings that are longer (or contain a few ampersands) I'm only ever getting the first 32 bytes encrypted. Shorter strings are encrypted without any issues. Code is below, any ideas?</p>

<pre><code>    char dataIn[] = ""LONG STRING HERE"";
    string preInput = dataIn;


    CRijndael aRijndael;
    aRijndael.MakeKey(""32-BIT-KEY-HERE"", CRijndael::sm_chain0, 32, 16);



    while (preInput.length() % 16 != 0) {
        preInput += '\0';
    }
    const char *encInput = preInput.c_str();
    char szReq[1000];
    aRijndael.Encrypt(preInput.c_str(), szReq, preInput.size(), CRijndael::CBC);

    const std::string preBase64 = szReq;
    std::string encoded = base64_encode(reinterpret_cast&lt;const unsigned char*&gt;(preBase64.c_str()), preBase64.length());
</code></pre>
","","214","<visual-c++><aes><rijndael>","0","","0","2014-11-24 17:23:21","","7","","","","","2014-11-24 17:23:21",""
"12798710","The PHP decrypt function for this resolution (look at)","<p>After a long time searching for the best way to en/decrypt data between PHP and iOS, I'm now asking you for a function in PHP.</p>

<p>I'm using this framework (<a href=""https://gist.github.com/2507415"" rel=""nofollow"">https://gist.github.com/2507415</a>) in Objective-C and my code is:</p>

<pre><code>NSString *string= @""Affe"";
NSString *key = @""12345678901234567890123456789012"";
NSLog(%@,[string AES256EnryptWithKey:key];
</code></pre>

<p>Output: <strong>UUfn34iyNlSK40VaehloaQ==</strong></p>

<p>I've tried so much in PHP but nothing works. I hope somebody knows how to decrypt this server-side.</p>
","<p>Seem like PHP not support AES 256, <a href=""http://www.php.net/manual/en/function.hash-algos.php"" rel=""nofollow"">http://www.php.net/manual/en/function.hash-algos.php</a>. </p>

<p>I have found implementations using Rijndael-256 but I'm not sure if it works properly:</p>

<p><a href=""http://kix.in/2008/07/22/aes-256-using-php-mcrypt/"" rel=""nofollow"">http://kix.in/2008/07/22/aes-256-using-php-mcrypt/</a></p>

<p><a href=""http://snipperize.todayclose.com/snippet/php/Encrypt-and-Decrypt-AES-256--17234/"" rel=""nofollow"">http://snipperize.todayclose.com/snippet/php/Encrypt-and-Decrypt-AES-256--17234/</a></p>
","213","<php><ios><encryption><aes><rijndael>","-1","0","3","2012-10-09 12:15:24","12799097","3","","1415713","","2012-10-09 11:34:05","2012-10-09 11:06:42","2012-10-09 15:07:37"
"12798710","The PHP decrypt function for this resolution (look at)","<p>After a long time searching for the best way to en/decrypt data between PHP and iOS, I'm now asking you for a function in PHP.</p>

<p>I'm using this framework (<a href=""https://gist.github.com/2507415"" rel=""nofollow"">https://gist.github.com/2507415</a>) in Objective-C and my code is:</p>

<pre><code>NSString *string= @""Affe"";
NSString *key = @""12345678901234567890123456789012"";
NSLog(%@,[string AES256EnryptWithKey:key];
</code></pre>

<p>Output: <strong>UUfn34iyNlSK40VaehloaQ==</strong></p>

<p>I've tried so much in PHP but nothing works. I hope somebody knows how to decrypt this server-side.</p>
","<p>I dont know much about IOS, but I've implemented same logic recently between a PHP and Java API.
I needed to encrypt the communication between an android device and a PHP backend.</p>

<p>I wrote a small summary, maybe the PHP part may help you out.</p>

<p><a href=""http://blog.cwill-dev.com/2012/10/09/encryption-between-javaandroid-and-php/"" rel=""nofollow"">http://blog.cwill-dev.com/2012/10/09/encryption-between-javaandroid-and-php/</a>  </p>

<p>You should have a look at the <a href=""http://ch2.php.net/mcrypt"" rel=""nofollow"">mcrypt library</a>, as Louis already mentioned.</p>
","213","<php><ios><encryption><aes><rijndael>","-1","2","3","2012-10-09 12:15:24","12799097","3","","1415713","","2012-10-09 11:34:05","2012-10-09 11:06:42","2012-10-09 15:07:37"
"12798710","The PHP decrypt function for this resolution (look at)","<p>After a long time searching for the best way to en/decrypt data between PHP and iOS, I'm now asking you for a function in PHP.</p>

<p>I'm using this framework (<a href=""https://gist.github.com/2507415"" rel=""nofollow"">https://gist.github.com/2507415</a>) in Objective-C and my code is:</p>

<pre><code>NSString *string= @""Affe"";
NSString *key = @""12345678901234567890123456789012"";
NSLog(%@,[string AES256EnryptWithKey:key];
</code></pre>

<p>Output: <strong>UUfn34iyNlSK40VaehloaQ==</strong></p>

<p>I've tried so much in PHP but nothing works. I hope somebody knows how to decrypt this server-side.</p>
","<p>That seems to be using AES 128, with no IV in ECB mode and PKCS-7 compatible padding, try <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php#105173"" rel=""nofollow"">this</a>:</p>

<pre><code>function encrypt($str, $key)
{
    $block = mcrypt_get_block_size('rijndael-128', 'ecb');
    $pad = $block - (strlen($str) % $block);
    $str .= str_repeat(chr($pad), $pad);

    return base64_encode(mcrypt_encrypt('rijndael-128', $key, $str, 'ecb'));
}

function decrypt($str, $key)
{   
    $str = mcrypt_decrypt('rijndael-128', $key, base64_decode($str), 'ecb');

    $block = mcrypt_get_block_size('rijndael-128', 'ecb');
    $pad = ord($str[($len = strlen($str)) - 1]);
    return substr($str, 0, strlen($str) - $pad);
}
</code></pre>

<p><strong>PS: I had forgotten about the base64 encoding, it's fixed now.</strong></p>
","213","<php><ios><encryption><aes><rijndael>","-1","0","3","2012-10-09 12:15:24","12799097","3","","1415713","","2012-10-09 11:34:05","2012-10-09 11:06:42","2012-10-09 15:07:37"
"29854095","using Rijndael with MFC VS 2013","<p>I'm building an MFC application with VS 2013 for Encryption and Decryption using AES , and I'm using Rijndael c++ implementation .
the problem is After adding Rijndeal.cpp and .h to the project and make a compilation  i get this error</p>

<p>error C1083: Cannot open include file: 'rijndael.h': No such file or directory  </p>

<p>anyone have an idea how to solve that ?</p>
","","207","<c++><encryption><mfc><rijndael>","0","","0","2015-04-24 17:41:59","","3","","","","","2015-04-24 17:41:59",""
"15917291","PHP mcrypt same trailing characters","<p>When running this:</p>

<pre><code>var_dump(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, '12345', '1abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND))));
var_dump(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, '12345', '2abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND))));
var_dump(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, '12345', '3abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND))));
var_dump(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, '12345', '4abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND))));
var_dump(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, '12345', '5abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND))));
</code></pre>

<p>Its results in:</p>

<pre><code>string 'X9VFmBzVWwUSoKPtE0VoEYxGkAPwVkUDQfQwF0wPDAVxedrGWE4oMCPBAF7FRBMoQsSUFwHhpknj/fHQqgQVPw==' (length=88)
string 'T/yn6lkyB73cEs57K2pUVNhFk2tDX02CbnBIU2c2I2VxedrGWE4oMCPBAF7FRBMoQsSUFwHhpknj/fHQqgQVPw==' (length=88)
string 'WysJWSV2k5gyYoQ4+hF0Uh2JqMJ6pTC8lcrgs1jmSklxedrGWE4oMCPBAF7FRBMoQsSUFwHhpknj/fHQqgQVPw==' (length=88)
string 'fMsJByfrZBYoQIgL/g+3i6jOPiaHh2Jf0vV59g1w1ZVxedrGWE4oMCPBAF7FRBMoQsSUFwHhpknj/fHQqgQVPw==' (length=88)
string 'Mw0AlrcC5v3v6swEg+wT+uTHf8MNrxdprD9GCpOe/45xedrGWE4oMCPBAF7FRBMoQsSUFwHhpknj/fHQqgQVPw==' (length=88)
</code></pre>

<p>Notice how the string all end in the same set of characters?</p>

<p>Is this supposed to happen?</p>

<p>I would have thought that because the data is different and I am creating a new initialisation vector each time it would have resulted in a totally different output.</p>

<p>Is there another, good, algorithm that would create totally different output given a small change in the data?</p>

<p><a href=""http://codepad.viper-7.com/jVqpUU"" rel=""nofollow"">http://codepad.viper-7.com/jVqpUU</a></p>
","<p>The similar result is due to the <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29"" rel=""nofollow"">ECB cipher block mode</a> where each block is encrypted separately. Use a different mode like <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29"" rel=""nofollow"">CBC</a> instead and the result of previous blocks will also influence later block encryptions.</p>
","203","<php><encryption><aes><mcrypt><rijndael>","0","1","1","2013-04-10 05:10:55","15917420","1","","","","","2013-04-10 05:00:40",""
"25847662","Decrypt file with mcrypt strange char's on end of file","<p>I've got a very strange problem with a self made function decryptfile. 
I want to decrypt a mp3 file which is encrypted with our own Delphi program.<br>
After decrypting this songs with php the data is slightly different than decrypting it with Delphi. This results in difference in filesizes compared to Delphi and php. 
This is with every file we decrypt, so reading the last 578 bytes is not always the same.</p>

<p>An example of our result data:</p>

<pre><code>Taginfo:filename: 180519: size: 7342031 bytes (Delphi decrypted)

TAGStolen danceMilky ChanceLICHTDICHT RECORDS#$#$2013000000100001000000000000000000000000000000000000000000000, 840900000000000010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000


Taginfo:filename: 180519: size: 7342032 bytes (PHP decrypted)

AGStolen danceMilky ChanceLICHTDICHT RECORDS#$#$2013000000100001000000000000000000000000000000000000000000000, 8409000000000000101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000T�8߂�j#���#6&amp;

Difference in size: -1
</code></pre>

<p>You can see that the data is not equal and above that the PHP data is different on the end.</p>

<p>Here is my function:</p>

<pre><code>require_once('mp3file.class.php'); 

function decryptfile($str){
    //read salt
    $salt = substr($str, 0, 8); //salt ok
    $str_out = substr($str, 8);  //encrypted data

    //read key
    $k = '';
    $bytes = array(*, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *, *);        
    $string = """";
    foreach ($bytes as $chr) {
        $string .= chr($chr);
    }
    $key = $string;

    //fill hash
    $ctx = hash_init('sha512');
    hash_update($ctx, $salt);  
    hash_update($ctx, $key);
    $xkey = hash_final($ctx, true);

    //assing key
    $k = substr($xkey, 0, 32);

    //iv
    $iv = ''; 
    $size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $iv_array = array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    $string = """";
    foreach ($iv_array as $chr) {
        $iv .= chr($chr);
    }

    $str = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $k, $str_out, MCRYPT_MODE_CBC,$iv);

    //$pad = ord($str[($len = strlen($str)) - 1]);

    return rtrim($str, ""\0"");
    //return substr($str, 0, strlen($str)-$pad);
}


    $farray = scandir('/var/www/html/test/in/');

    foreach ($farray as $item) {
        if (($item != '.') &amp;&amp; ($item != '..')) {
            $filename = ""test/in/"".$item;
            $filename2 = ""test/out/"".$item;
            $filename2b = ""test/out/"".$item."".mp3"";

            $enc = file_get_contents($filename);

            $jak = decryptfile($enc);

            $dec = fopen($filename2b, ""w"");
            fwrite($dec, $jak);
            fclose($dec);
            $strfile1 = ""filename: "" . $item . ': size: ' . filesize($filename2) . ' bytes (Delphi decrypted)&lt;br&gt;';
            $strfile2 = ""filename: "" . $item . ': size: ' . filesize($filename2b) . ' bytes (PHP decrypted)&lt;br&gt;';
            $v1 = filesize($filename2);
            $v2 = filesize($filename2b); 
            $v1 = $v1-$v2; 
            echo '&lt;br&gt;Taginfo:'. $strfile1. '&lt;br&gt;';
            $dec = file_get_contents($filename2);
            $dec2 = file_get_contents($filename2b);
            echo substr($dec, -578);
            echo '&lt;br&gt;&lt;br&gt;';
            echo '&lt;br&gt;Taginfo:'. $strfile2. '&lt;br&gt;';
            echo substr($dec2, -578). '&lt;br&gt;';
            echo '&lt;br&gt;Difference in size: '.$v1 . '&lt;br&gt;';
            echo 'original header:&lt;br&gt;';
            $m = new mp3file($filename2);
            $a = $m-&gt;get_metadata();

            if ($a['Encoding']=='Unknown')
                $str = ""?"";
            else if ($a['Encoding']=='VBR')
                $str = print_r($a);
            else if ($a['Encoding']=='CBR')
                $str = print_r($a);
            unset($a);
            echo '&lt;br&gt;&lt;br&gt;';
            echo 'decrypted header:&lt;br&gt;';
            $m = new mp3file($filename2b);
            $a = $m-&gt;get_metadata();

            if ($a['Encoding']=='Unknown')
                $str = ""?"";
            else if ($a['Encoding']=='VBR')
                $str = print_r($a);
            else if ($a['Encoding']=='CBR')
                $str = print_r($a);
            unset($a);
            echo '&lt;br&gt;&lt;br&gt;';

        }
    }
exit; 
</code></pre>

<p>Can someone explain me what here is the problem?</p>
","","201","<php><delphi><delphi-xe3><mcrypt><rijndael>","0","","0","2014-09-15 12:03:20","","6","","","","","2014-09-15 12:03:20",""
"26830173","Issues with decrypting data with Rijndael after sending through System.Net.Socket","<p>I followed a tutorial from YouTube, <a href=""http://tinyurl.com/ljvzjqk"" rel=""nofollow"">http://tinyurl.com/ljvzjqk</a> and <a href=""http://tinyurl.com/os7vlgr"" rel=""nofollow"">http://tinyurl.com/os7vlgr</a>, and tried to implement this in a client/server-project I am working on.
I can encrypt and decrypt strings in the client program just fine, but when the data is received in the server it does not decrypt it correctly.</p>

<p>While debugging I could see that the byte[] carrying the data is exactly the same in both ends.</p>

<p>In both programs, this is declared in the class:</p>

<pre><code>static SymmetricAlgorithm rjnObj;
static byte[] Key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16 };
</code></pre>

<p>Server:</p>

<pre><code>static void Main(string[] args)
    {
        rjnObj = Rijndael.Create();
        rjnObj.Padding = PaddingMode.Zeros;
        rjnObj.Key = Key;

        Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPEndPoint localEP = new IPEndPoint(IPAddress.Parse(""127.0.0.1""), 1980);

        serverSocket.Bind(localEP);
        serverSocket.Listen(10);
        serverSocket = serverSocket.Accept();
        while(true)
        {
            byte[] dataReceived = new byte[1024];
            int lengthOfData = serverSocket.Receive(dataReceived);
            byte[] dataReceived2 = new byte[lengthOfData];
            for (int i = 0; i &lt; lengthOfData; i++)
            {
                dataReceived2[i] = dataReceived[i];
            }
            Console.WriteLine(""Received: {0}"", Encoding.UTF8.GetString(dataReceived2));
            Console.WriteLine(""Decrypted: {0}"", Decrypt(dataReceived2));
        }
    }
    public static string Decrypt(byte[] cipherbytes)
    {
        System.IO.MemoryStream ms = new System.IO.MemoryStream(cipherbytes);
        CryptoStream cs = new CryptoStream(ms, rjnObj.CreateDecryptor(), CryptoStreamMode.Read);

        cs.Read(cipherbytes, 0, cipherbytes.Length);
        byte[] plainBytes = ms.ToArray();
        cs.Close();
        ms.Close();

        return Encoding.UTF8.GetString(plainBytes);
    }
</code></pre>

<p>Client:</p>

<pre><code>static void Main(string[] args)
    {
        rjnObj = Rijndael.Create();
        rjnObj.Padding = PaddingMode.Zeros;
        rjnObj.Key = Key;

        Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPEndPoint serverEP = new IPEndPoint(IPAddress.Parse(""127.0.0.1""), 1980);

        try
        {
            clientSocket.Connect(serverEP);
            Console.WriteLine(""Connected to {0}."", clientSocket.RemoteEndPoint);

            while(true)
            {
                Console.Write(""String to send: "");
                byte[] dataToSend = Encrypt(Console.ReadLine());
                clientSocket.Send(dataToSend);

                Console.WriteLine(""Encrypted string: {0}"", Encoding.UTF8.GetString(dataToSend));
                Console.WriteLine(""Decrypted string: {0}"", Decrypt(dataToSend));
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(""Something went wrong..."");
            Console.WriteLine(e.ToString());
            Console.ReadKey();
        }
    }
    public static byte[] Encrypt(string s)
    {
        byte[] plainBytes = Encoding.UTF8.GetBytes(s);
        System.IO.MemoryStream ms = new System.IO.MemoryStream();
        CryptoStream cs = new CryptoStream(ms, rjnObj.CreateEncryptor(), CryptoStreamMode.Write);

        cs.Write(plainBytes, 0, plainBytes.Length);
        cs.Close();
        byte[] cipherbytes = ms.ToArray();
        ms.Close();

        return cipherbytes;
    }
    public static string Decrypt(byte[] cipherbytes)
    {
        System.IO.MemoryStream ms = new System.IO.MemoryStream(cipherbytes);
        CryptoStream cs = new CryptoStream(ms, rjnObj.CreateDecryptor(), CryptoStreamMode.Read);

        cs.Read(cipherbytes, 0, cipherbytes.Length);
        byte[] plainBytes = ms.ToArray();
        cs.Close();
        ms.Close();

        return Encoding.UTF8.GetString(plainBytes);
    }
</code></pre>

<p>Output from client-program:</p>

<pre><code>Connected to 127.0.0.1:1980.
String to send: Hello server!
Encrypted string: ?*?8?2?HfG▲z  ?K
Decrypted string: Hello server!
String to send:
</code></pre>

<p>Output from server-program:</p>

<pre><code>Received: ?*?8?2?HfG▲z  ?K
Decrypted: E??diQ♣?ZX??♂?z
</code></pre>

<p>As you can see, the encrypted string in the server is equal to the encrypted string in the client, so I guess it has something to do with rjnObj, and that this object is not identical in both ends.</p>

<p>The code given here is a new solution I created to ask this question.
I have used PaddingMode.Zeros, because when I tried PKCS7, I got an exception.</p>

<p>In the server-code I made another byte[] dataReceived2 to be the exact length of the received byte[].
I have found other examples of code that sends encrypted data over a network, but these examples use TcpClient and NetworkStream.
In the solution I am working on for a school project, I am using Sockets and I really don't want to rewrite the solution.</p>

<p>If sombody can help me with this, that would be great! Thanks!</p>
","<p>Your Decrypt method in the server doesn't make any sense at all. As you've done it now you should be reading <em>from</em> the cs Stream <em>into</em> the plaintext array. Or you can layer the streams differently and <em>write</em> the ciphertext into a cs Stream and retrieve the plaintext from the underlying memory stream. I think the latter method is cleaner and easier.</p>
","198","<c#><sockets><encryption><rijndael>","0","1","2","2014-11-09 20:13:04","26832462","0","","41071","","2014-11-09 20:13:04","2014-11-09 16:05:50",""
"26830173","Issues with decrypting data with Rijndael after sending through System.Net.Socket","<p>I followed a tutorial from YouTube, <a href=""http://tinyurl.com/ljvzjqk"" rel=""nofollow"">http://tinyurl.com/ljvzjqk</a> and <a href=""http://tinyurl.com/os7vlgr"" rel=""nofollow"">http://tinyurl.com/os7vlgr</a>, and tried to implement this in a client/server-project I am working on.
I can encrypt and decrypt strings in the client program just fine, but when the data is received in the server it does not decrypt it correctly.</p>

<p>While debugging I could see that the byte[] carrying the data is exactly the same in both ends.</p>

<p>In both programs, this is declared in the class:</p>

<pre><code>static SymmetricAlgorithm rjnObj;
static byte[] Key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16 };
</code></pre>

<p>Server:</p>

<pre><code>static void Main(string[] args)
    {
        rjnObj = Rijndael.Create();
        rjnObj.Padding = PaddingMode.Zeros;
        rjnObj.Key = Key;

        Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPEndPoint localEP = new IPEndPoint(IPAddress.Parse(""127.0.0.1""), 1980);

        serverSocket.Bind(localEP);
        serverSocket.Listen(10);
        serverSocket = serverSocket.Accept();
        while(true)
        {
            byte[] dataReceived = new byte[1024];
            int lengthOfData = serverSocket.Receive(dataReceived);
            byte[] dataReceived2 = new byte[lengthOfData];
            for (int i = 0; i &lt; lengthOfData; i++)
            {
                dataReceived2[i] = dataReceived[i];
            }
            Console.WriteLine(""Received: {0}"", Encoding.UTF8.GetString(dataReceived2));
            Console.WriteLine(""Decrypted: {0}"", Decrypt(dataReceived2));
        }
    }
    public static string Decrypt(byte[] cipherbytes)
    {
        System.IO.MemoryStream ms = new System.IO.MemoryStream(cipherbytes);
        CryptoStream cs = new CryptoStream(ms, rjnObj.CreateDecryptor(), CryptoStreamMode.Read);

        cs.Read(cipherbytes, 0, cipherbytes.Length);
        byte[] plainBytes = ms.ToArray();
        cs.Close();
        ms.Close();

        return Encoding.UTF8.GetString(plainBytes);
    }
</code></pre>

<p>Client:</p>

<pre><code>static void Main(string[] args)
    {
        rjnObj = Rijndael.Create();
        rjnObj.Padding = PaddingMode.Zeros;
        rjnObj.Key = Key;

        Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPEndPoint serverEP = new IPEndPoint(IPAddress.Parse(""127.0.0.1""), 1980);

        try
        {
            clientSocket.Connect(serverEP);
            Console.WriteLine(""Connected to {0}."", clientSocket.RemoteEndPoint);

            while(true)
            {
                Console.Write(""String to send: "");
                byte[] dataToSend = Encrypt(Console.ReadLine());
                clientSocket.Send(dataToSend);

                Console.WriteLine(""Encrypted string: {0}"", Encoding.UTF8.GetString(dataToSend));
                Console.WriteLine(""Decrypted string: {0}"", Decrypt(dataToSend));
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(""Something went wrong..."");
            Console.WriteLine(e.ToString());
            Console.ReadKey();
        }
    }
    public static byte[] Encrypt(string s)
    {
        byte[] plainBytes = Encoding.UTF8.GetBytes(s);
        System.IO.MemoryStream ms = new System.IO.MemoryStream();
        CryptoStream cs = new CryptoStream(ms, rjnObj.CreateEncryptor(), CryptoStreamMode.Write);

        cs.Write(plainBytes, 0, plainBytes.Length);
        cs.Close();
        byte[] cipherbytes = ms.ToArray();
        ms.Close();

        return cipherbytes;
    }
    public static string Decrypt(byte[] cipherbytes)
    {
        System.IO.MemoryStream ms = new System.IO.MemoryStream(cipherbytes);
        CryptoStream cs = new CryptoStream(ms, rjnObj.CreateDecryptor(), CryptoStreamMode.Read);

        cs.Read(cipherbytes, 0, cipherbytes.Length);
        byte[] plainBytes = ms.ToArray();
        cs.Close();
        ms.Close();

        return Encoding.UTF8.GetString(plainBytes);
    }
</code></pre>

<p>Output from client-program:</p>

<pre><code>Connected to 127.0.0.1:1980.
String to send: Hello server!
Encrypted string: ?*?8?2?HfG▲z  ?K
Decrypted string: Hello server!
String to send:
</code></pre>

<p>Output from server-program:</p>

<pre><code>Received: ?*?8?2?HfG▲z  ?K
Decrypted: E??diQ♣?ZX??♂?z
</code></pre>

<p>As you can see, the encrypted string in the server is equal to the encrypted string in the client, so I guess it has something to do with rjnObj, and that this object is not identical in both ends.</p>

<p>The code given here is a new solution I created to ask this question.
I have used PaddingMode.Zeros, because when I tried PKCS7, I got an exception.</p>

<p>In the server-code I made another byte[] dataReceived2 to be the exact length of the received byte[].
I have found other examples of code that sends encrypted data over a network, but these examples use TcpClient and NetworkStream.
In the solution I am working on for a school project, I am using Sockets and I really don't want to rewrite the solution.</p>

<p>If sombody can help me with this, that would be great! Thanks!</p>
","<p>Try to use the same IV. I believe that when you create a new instance of <code>Rijndael.Create()</code>, Key and IV will be randomly generated. You only set Key, but to make this work you also need to use the same IV.</p>

<p>On the client you use the same instance of <code>Rijndael</code> therefore encrypt and decrypt are working fine.</p>

<p>You might want to look at the documentation and example of <code>Rijndael</code> class usage <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndael(v=vs.110).aspx"" rel=""nofollow"">here</a>. What I like about it are using statements. It looks cleaner as the streams are closed as soon as they are not used anymore.</p>
","198","<c#><sockets><encryption><rijndael>","0","1","2","2014-11-09 20:13:04","26832462","0","","41071","","2014-11-09 20:13:04","2014-11-09 16:05:50",""
"15361613","mcrypt_crypt and decrypt does result does not match","<p>I've got these 2 methods for encryption and decryption but the input value does not match the output value of the decrypt function, can you please help me find the problem?</p>

<pre><code>private function encryptMd($md)
{
    $md = serialize($md);
    //encryption should happen here
    $md = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;secret, $md, MCRYPT_MODE_ECB);
    $md = gzcompress($md);
    $md = base64_encode($md);
    return $md;
}

private function decryptMd($md)
{
    $md = base64_decode($md);
    $md = gzuncompress($md);
    // decryption happen here
    $md = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $this-&gt;secret, $md, MCRYPT_MODE_ECB));
    $md = unserialize($md);
    return $md;
}
</code></pre>

<p>here are the results:</p>

<p>the first string:
orderid=1111264&amp;cardnumber=4012001037141112&amp;cardname=Test&amp;cardtype=VISA&amp;amount=100&amp;expdate=0214</p>

<p>the encrypted string:
eJwBgAB//4LFthFrKDuzX7v+90h2j24xrEnKHHxefzvh5si5yKxEJxtOAo8XG923Ako0eYP7JVH03yN9LPdb/V8JghJVi8tPvloqlEOFwDHUbwBoFGHBNvTRq0vgMRN/Wlpfk8e+UYQWV4TRYYNWNWxVLiwMFWWOk6bsESDgRBkMDQcp//OOFkg5cg==</p>

<p>the recieved string:
eJwBgAB//4LFthFrKDuzX7v+90h2j24xrEnKHHxefzvh5si5yKxEJxtOAo8XG923Ako0eYP7JVH03yN9LPdb/V8JghJVi8tPvloqlEOFwDHUbwBoFGHBNvTRq0vgMRN/Wlpfk8e+UYQWV4TRYYNWNWxVLiwMFWWOk6bsESDgRBkMDQcp//OOFkg5cg==</p>

<p>the decrypted result:
FALSE</p>
","<p>the problem was with $this->secret which was empty when decrypting. thanks anyway.</p>
","194","<php><encryption><mcrypt><rijndael>","1","0","1","2013-03-12 14:42:56","","7","","1432324","","2013-03-12 13:39:17","2013-03-12 12:46:17",""
"38956156","Rijndael File Encryption Issue","<p>Rijndael File Encryption Issue</p>

<p>I want to encrypt large files using Rijndael but I getting out of memory exception error. Any idea?
Here is my code</p>

<pre><code>     public void Rijndael_EncryptFile(string password, string filepath, int opt)
    {
        try
        {
            byte[] keyBytes;
            keyBytes = Encoding.Unicode.GetBytes(password);
            Rfc2898DeriveBytes derivedKey = new Rfc2898DeriveBytes(password, keyBytes);
            RijndaelManaged rijndaelCSP = new RijndaelManaged();
            rijndaelCSP.BlockSize = opt; //128 256
            rijndaelCSP.KeySize = opt;   //128 256
            rijndaelCSP.Key = derivedKey.GetBytes(rijndaelCSP.KeySize / 8);
            rijndaelCSP.IV = derivedKey.GetBytes(rijndaelCSP.BlockSize / 8);
            rijndaelCSP.Mode = CipherMode.CFB;
            rijndaelCSP.Padding = PaddingMode.Zeros;
            ICryptoTransform encryptor = rijndaelCSP.CreateEncryptor();
            FileStream inputFileStream = new FileStream(filepath, FileMode.Open, FileAccess.Read);
            byte[] inputFileData = new byte[(int)inputFileStream.Length];
            inputFileStream.Read(inputFileData, 0, (int)inputFileStream.Length);
            FileStream outputFileStream = new FileStream(filepath + "".enc"", FileMode.Create, FileAccess.Write);
            CryptoStream encryptStream = new CryptoStream(outputFileStream, encryptor, CryptoStreamMode.Write);
            encryptStream.Write(inputFileData, 0, (int)inputFileStream.Length);
            encryptStream.FlushFinalBlock();
            rijndaelCSP.Clear();
            encryptStream.Close();
            inputFileStream.Close();
            outputFileStream.Close();
        }
    }
</code></pre>
","<p>OK, first your actual problem.</p>

<p>Your reading the whole file in to memory, encrypting it, then writing it to disk. A large byte array may not fit in to memory (even if you have enough ""RAM"").</p>

<p>You should instead read a chunk of data at a time. This chunk size is probably going to be a multiple of 16 bytes (the size of the AES block), write it to the use the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.cryptostream(v=vs.110).aspx"" rel=""nofollow""><code>CryptoStream</code></a>, and when you reach the end of stream, close the <code>CryptoStream</code> so it applies any padding.</p>

<p>OK, other things.</p>

<p>First, don't use <code>RijndaelManaged</code>. Use <code>AesManaged</code>. Rijndael was the name of AES before it was standardized as AES. AES is identical to Rijndael, except that AES does not allow a block size other than 128, so don't change the block size. The only time Rijndael should be used is when you need a block size other than 128 bits for compatibility with an existing system.</p>

<p>Next, your initialization vector should be <em>unique</em> for CFB mode. An IV is not a secret, you can store it in plain text along with the cipher text. Don't derive it from a password. Crucially, an IV must never be re-used. It doesn't need to be random, either. It could be a simple incrementing counter. Note that for other modes of AES, like CBC, the IV should be random.</p>
","189","<c#><.net><encryption><rijndael><rijndaelmanaged>","0","2","2","2016-08-15 20:33:11","","1","","","","","2016-08-15 13:37:46",""
"38956156","Rijndael File Encryption Issue","<p>Rijndael File Encryption Issue</p>

<p>I want to encrypt large files using Rijndael but I getting out of memory exception error. Any idea?
Here is my code</p>

<pre><code>     public void Rijndael_EncryptFile(string password, string filepath, int opt)
    {
        try
        {
            byte[] keyBytes;
            keyBytes = Encoding.Unicode.GetBytes(password);
            Rfc2898DeriveBytes derivedKey = new Rfc2898DeriveBytes(password, keyBytes);
            RijndaelManaged rijndaelCSP = new RijndaelManaged();
            rijndaelCSP.BlockSize = opt; //128 256
            rijndaelCSP.KeySize = opt;   //128 256
            rijndaelCSP.Key = derivedKey.GetBytes(rijndaelCSP.KeySize / 8);
            rijndaelCSP.IV = derivedKey.GetBytes(rijndaelCSP.BlockSize / 8);
            rijndaelCSP.Mode = CipherMode.CFB;
            rijndaelCSP.Padding = PaddingMode.Zeros;
            ICryptoTransform encryptor = rijndaelCSP.CreateEncryptor();
            FileStream inputFileStream = new FileStream(filepath, FileMode.Open, FileAccess.Read);
            byte[] inputFileData = new byte[(int)inputFileStream.Length];
            inputFileStream.Read(inputFileData, 0, (int)inputFileStream.Length);
            FileStream outputFileStream = new FileStream(filepath + "".enc"", FileMode.Create, FileAccess.Write);
            CryptoStream encryptStream = new CryptoStream(outputFileStream, encryptor, CryptoStreamMode.Write);
            encryptStream.Write(inputFileData, 0, (int)inputFileStream.Length);
            encryptStream.FlushFinalBlock();
            rijndaelCSP.Clear();
            encryptStream.Close();
            inputFileStream.Close();
            outputFileStream.Close();
        }
    }
</code></pre>
","<p>You don't need to read the entire file into memory. The best approach is to read a chunk of data at a time from the input and write that chunk to the output. </p>

<p>Something like the following, although I haven't tested the below:</p>

<pre><code>byte[] keyBytes;
keyBytes = Encoding.Unicode.GetBytes(password);
Rfc2898DeriveBytes derivedKey = new Rfc2898DeriveBytes(password, keyBytes);
RijndaelManaged rijndaelCSP = new RijndaelManaged();
// setup key parameters, i.e. IV, etc
ICryptoTransform encryptor = rijndaelCSP.CreateEncryptor();
using (FileStream inputFileStream = new FileStream(filepath, FileMode.Open, FileAccess.Read))
using (FileStream outputFileStream = new FileStream(filepath + "".enc"", FileMode.Create, FileAccess.Write))
using (CryptoStream encryptStream = new CryptoStream(outputFileStream, encryptor, CryptoStreamMode.Write))
{ 
  byte[] buffer = new byte[bufSize];
  int readSize = 0;
  while ((readSize = inputFileStream.Read(buffer, 0, buffer.Length)) &gt; 0)
  {
      encryptStream.Write(buffer, 0, readSize);
  }
  encryptStream.FlushFinalBlock();
  rijndaelCSP.Clear();
}
</code></pre>

<p>UPDATE: Removed initialization code (copied from original question) as it isn't secure.</p>
","189","<c#><.net><encryption><rijndael><rijndaelmanaged>","0","2","2","2016-08-15 20:33:11","","1","","","","","2016-08-15 13:37:46",""
"47775841","Mcrypt encryption C# equivalent of PHP (Rijndael 128 with 32bit hexKey)","<p>I am sorry if this was asked/answered elsewhere but I was unable to find it.</p>

<p>I am currently trying to duplicate the result of PHP mcrypt in C#. PHP being the back-end server. I am using Rijndael 128 in ECB mode with a 256bit (32 char) hexKey. </p>

<p>Now I know that ECB is less secure then CBC and that mcrypt is depreciated but I am not the one who developed the back-end and have no choice to do in this manner (trust me I asked). </p>

<p>Test password: <strong>testPassword</strong></p>

<p>hexKey: <strong>2619eeaed2cb05f60f298b7af8e565e4f155dd76821865994d4e660d7c041281</strong></p>

<p>P.S. the hexKey is not the actualkey we are using ;)</p>

<p>Here is my code in PHP</p>

<pre><code>$key = $this-&gt;hexToStr([key]);
$text = $password;
$crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $text, MCRYPT_MODE_ECB);

private function hexToStr($hex) {
$string = '';
for ($i = 0; $i &lt; strlen($hex) - 1; $i+=2) {
    $string .= chr(hexdec($hex[$i] . $hex[$i + 1]));
}
return $string;
}
</code></pre>

<p>And my code in C#</p>

<pre><code>    public string EncryptStringRijndael(string value)
    {
        try
        {
            string cipherText;
            byte[] plainTextBytes = Encoding.UTF8.GetBytes(value);

            var rijndael = new RijndaelManaged
            {
                Key = Encoding.ASCII.GetBytes(HexStringToString(hexKey)),
                Mode = CipherMode.ECB,
                BlockSize = 128,
                KeySize = 256,
            };

            var encryptor = rijndael.CreateEncryptor(rijndael.Key, null);
            MemoryStream memoryStream = new MemoryStream();
            CryptoStream cryptoStream = new CryptoStream
            (
                memoryStream,
                encryptor,
                CryptoStreamMode.Write
            );
            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
            cryptoStream.FlushFinalBlock();
            byte[] cipherTextBytes = memoryStream.ToArray();

            cipherText = Encoding.ASCII.GetString(cipherTextBytes);
            //cipherText = StringToHexString(tempText);

            return cipherText;
        }
        catch (Exception ex)
        {
            return ex.Message;
        }
    }

    public static string HexStringToString(string hexString)
    {
        try
        {
            string ascii = string.Empty;

            for (int i = 0; i &lt; hexString.Length; i += 2)
            {
                String hs = string.Empty;

                hs = hexString.Substring(i, 2);
                uint decval = Convert.ToUInt32(hs, 16);
                char character = Convert.ToChar(decval);
                ascii += character;
            }
            return ascii;
        }
        catch (Exception ex)
        {
            return ex.Message;
        }
    }

    public static string StringToHexString(string originalString)
    {
        string outp = string.Empty;
        char[] value = originalString.ToCharArray();
        foreach (char L in value)
        {
            int V = Convert.ToInt32(L);
            outp += string.Format(""{0:x}"", V);
        }
        return outp;
    }
</code></pre>

<p>PHP result: G .�g��/D>�Y�5</p>

<p>C# result: ???u\0??9?`???</p>

<p>What am I doing wrong ?</p>

<p>Thanks for all the help :)</p>
","","188","<c#><php><encryption><mcrypt><rijndael>","0","","0","2017-12-12 15:13:44","","4","","","","","2017-12-12 15:13:44",""
"34355450","ccrypt will not decrypt ccrypt-j encrypted files","<p>I've been trying to fix <a href=""https://github.com/chrsoo/ccrypt-j"" rel=""nofollow""><code>ccrypt-j</code></a>, a pure-java implementation of the linux <a href=""http://ccrypt.sourceforge.net/"" rel=""nofollow""><code>ccrypt</code></a> command. I found there is some problem with the initialization vector (IV) which makes <code>ccrypt</code> not decrypt anything but its own output. </p>

<p>I modified both libraries so that the same nonce is always fed to both implementations of the Rijndael engine, however, the output IV is always different between implementations, i.e. both libraries always have the same result (because Rijndael is deterministic), but those results are always different.</p>

<p>I know the problem is only the way <code>ccrypt</code> generates the IV since: </p>

<ol>
<li>ccrypt-j-encrypted can be decrypted from <code>ccrypt-j</code></li>
<li>If I substitute the IV (first 32 bytes of the encrypted files) with that of a ccrypt-encrypted file, <code>ccrypt</code> will decrypt it just fine. </li>
</ol>

<p>Ccrypt uses its own implementation of Rijndael coded in C, while ccrypt-j uses Bouncy Castle's implementation. </p>

<p>EDIT: 04/01/2016</p>

<p>Because the IV is constructed before any data is encrypted (actually, any data is even read) I believe the problem has to be in the way Rjindael is initialized in both Bouncy Castle and <code>ccrypt</code>'s own implementation. I'll try to do the same sequence in both implementations and see what I get. </p>
","<p>One half-answer</p>

<p>if you look at the old ccrypt, there are some explanations about IV. if I resume, 4 bytes are fixed - magic number -, it si c051 for a while. Issues about securities are also discussed:</p>

<p>magic number : see that
<a href=""http://ccrypt.sourceforge.net/faq.html"" rel=""nofollow"">http://ccrypt.sourceforge.net/faq.html</a></p>

<p>ccrypt comes from emacs / jka-compr:</p>

<p><a href=""http://www.opensource.apple.com/source/emacs/emacs-51/emacs/lisp/jka-compr.el"" rel=""nofollow"">http://www.opensource.apple.com/source/emacs/emacs-51/emacs/lisp/jka-compr.el</a></p>

<blockquote>
  <p>In ccrypt, the seed is constructed as follows: first, a nonce is
  contructed by hashing a combination of the host name, current time,
  process id, and an internal counter into a 28-byte value, using a
  cryptographic hash function. The nonce is combined with a fixed
  four-byte ""magic number"", and the resulting 32-byte value is encrypted
  by one round of the Rijndael block cipher with the given key. This
  encrypted block is used as the seed and appended to the beginning of
  the ciphertext. The use of the magic number allows ccrypt to detect
  non-matching keys before decryption.</p>
</blockquote>

<p>magic number there: <a href=""http://ccrypt.sourcearchive.com/documentation/1.7-7/ccryptlib_8c-source.html"" rel=""nofollow"">http://ccrypt.sourcearchive.com/documentation/1.7-7/ccryptlib_8c-source.html</a></p>

<p>It seems magic number doesnt change (same from 1.1 to 1.10, before, I dont know).</p>

<p>So what ?</p>

<p>ccrypt is designed to be compatible with precedent versions (emacs , ...). It can crypt and decrypt, and is widely used.</p>

<p>Then problem come from ccrypt-j. </p>

<p>what one can see on sourceforge is 2 important things :</p>

<p><strong>1 compatibility</strong></p>

<blockquote>
  <p>Encrypting a file using ccrypt-j </p>
  
  <p>TODO </p>
  
  <p>Decrypting a file using ccrypt-j</p>
  
  <p>TODO</p>
</blockquote>

<p>so what works really ?</p>

<p>2 in fact, it uses bouncy castle, which is well used, and surely implements standards well.</p>

<p>So conclusion ? </p>

<p>you cant hope ccrypt will change. </p>

<p>then: you can decrypt ccrypt by ccrypt-j </p>

<p>but if you want to decrypt by ccrypt, you have to limit ccrypt-j</p>

<p>I doubt about your assertion, because it would be magical !</p>

<blockquote>
  <p>If I substitute the IV (first 32 bytes of the encrypted files) with
  that of a ccrypt-encrypted file, ccrypt will decrypt it just fine.</p>
</blockquote>

<p>But if it works, why not use that ? (ccrypt-j can also decrypt ?)</p>

<p>last advice: contact ccrypt-j support</p>

<p>hope it helps</p>
","183","<java><encryption><bouncycastle><rijndael>","1","0","1","2016-01-04 11:19:07","","5","0","2716011","","2016-01-04 11:19:07","2015-12-18 12:12:01",""
"29177364","Where do I get AES Key Schedule encryption key?","<p>I have implemented AES key schedule in Java but there is one thing I am confused about. In wikipedia (<a href=""http://en.wikipedia.org/wiki/Rijndael_key_schedule#Key_schedule_description"" rel=""nofollow"">http://en.wikipedia.org/wiki/Rijndael_key_schedule#Key_schedule_description</a>) it says:</p>

<blockquote>
  <p>The first n bytes of the expanded key are simply the encryption key.</p>
</blockquote>

<p>Where does this ""encryption key"" come from? Is it generated randomly and if so what constraints you should generate it with etc?</p>

<p>At the moment I have a method that just generates a random array of 16 bytes:</p>

<pre><code>public int[][] initvec() {
    int[][] key = new int[4][Nk];
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; Nk; j++) {
            key[i][j] = mrnd.nextInt(255) % (0xff + 1);
            int keyval = key[i][j];
            // System.out.printf(""%x,"",keyval);
        }
        // System.out.println("""");
    }
    return key;
}
</code></pre>

<p>I would also like to print this key out however as java only has signed bytes if I use a number larger than 127 (currently 255) I will get negative numbers which can't be represented in a string properly using something like this where outputbyte is byte[] and has the integers converted into bytes and stored inside it:</p>

<pre><code>String output = new String(outputbyte, StandardCharsets.UTF_8);
</code></pre>

<p>Is using 127 instead acceptable?</p>
","<blockquote>
  <p>Where does this ""encryption key"" come from?</p>
</blockquote>

<p>It's the key that the user supplies when something needs to be encrypted.</p>

<blockquote>
  <p>Is it generated randomly and if so what constraints you should generate it with etc?</p>
</blockquote>

<p>It may be generated randomly. Then the challenge is to make known to the other side. One could for example then send the key encrypted through public-key crypto. This is called <a href=""https://en.wikipedia.org/wiki/Hybrid_cryptosystem"" rel=""nofollow noreferrer"">hybrid encryption.</a></p>

<p>Often a key exchange protocol such as Diffie-Hellman is used to negotiate the secret without it being sent fully assembled over the wire. This achieves forward secrecy, because every party will calculate the secret key on their own.</p>

<blockquote>
  <p>Is using 127 instead acceptable?</p>
</blockquote>

<p>No, it isn't, because you're doing the whole thing wrong. Bytes 0x00 through 0x1F are not printable characters. So when you try to print those bytes even with a reduced byte domain of up to 127, you won't see the actual key. Also, by restricting the domain, you also help attackers, because now they don't need to brute-force the complete domain for every byte of the key.</p>

<p>You need to utilize the full capacity of the key byte when generating a random key. When you then want to see the key, you can encode it with <a href=""https://stackoverflow.com/questions/13109588/base64-encoding-in-java"">Base 64</a> or <a href=""https://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java"">Hex</a>.</p>
","179","<java><aes><schedule><rijndael><symmetric-key>","1","2","1","2015-03-21 09:15:48","29181055","1","","1816580","","2015-03-21 09:00:26","2015-03-20 23:28:39",""
"43140361","What will be the C# equivalent of this php code?","<p>Here is the PHP code that decrypts the content of $data:</p>

<pre><code>$data='DwRktl1y8st4k11pSxy2tE9kJMiNlIgV6Gu9ekY8ia2QtoGbdiaiemHeQJ+2MGTZmRKM0IGsiXQyqvXLx/t47FcXmwzZPayS3i6mmYD+qFibbcmA5lGI1uIjT7FSgLM9Xi9QBnTMjIwIEmv6tQaKGGTbhwvUuaP7hek57Xnlk+9CCarkkDlGLed5y+6GedXED0KgMcW1rqXLH7EQub+KzQ==';
$crypttext = base64_decode($data);
$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB);
$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
$decrypttext = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, 'AbcNtByIGI1BpgcsAG8GZl8pdwwxyz', $crypttext, MCRYPT_MODE_ECB, $iv);
</code></pre>

<p>I tried this is .net but it didn't work :</p>

<pre><code> string data = ""DwRktl1y8st4k11pSxy2tE9kJMiNlIgV6Gu9ekY8ia2QtoGbdiaiemHeQJ+2MGTZmRKM0IGsiXQyqvXLx/t47FcXmwzZPayS3i6mmYD+qFibbcmA5lGI1uIjT7FSgLM9Xi9QBnTMjIwIEmv6tQaKGGTbhwvUuaP7hek57Xnlk+9CCarkkDlGLed5y+6GedXED0KgMcW1rqXLH7EQub+KzQ=="";

  byte[] arrb = Convert.FromBase64String(data);
  string decodedString = Encoding.UTF8.GetString(arrb); 

   const string key = ""AbcNtByIGI1BpgcsAG8GZl8pdwwxyz"";

   RijndaelManaged aes = new RijndaelManaged();
   aes.KeySize = 256;
   aes.BlockSize = 256;
   aes.Padding = PaddingMode.None;
   aes.Mode = CipherMode.ECB;
   aes.GenerateIV();
   ICryptoTransform decryptor = aes.CreateDecryptor(Encoding.UTF8.GetBytes(key), aes.IV);
   MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(decodedString.Trim()));
   CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);

 StreamReader sr = new StreamReader(cs);
 user_data = sr.ReadToEnd();
</code></pre>

<p>I get the exception ""the length of the data to decrypt is invalid"".
Can anyone suggest where I might be going wrong ?</p>
","<p>Not a full solution, but you should get rid of decodedString.  data holds base64 encoded encrypted binary data.  arrb holds 160 bytes of encrypted binary data.  arrb is what you need to pass to your decryption, don't do the conversion from binary to string then string to binary, that loses information.</p>
","175","<c#><php><encryption><rijndael><rijndaelmanaged>","0","0","1","2017-03-31 13:14:42","","10","","5238345","","2017-03-31 13:06:24","2017-03-31 12:11:24",""
"52470673","Decrypting an mcrypt file in .Net (C#)","<p>I've been a C# hobbyist for some time now and would consider having intermediate development skills, but little to no encryption knowledge. As part of a side project I need to decrypt files that were encrypted using MCrypt. It doesn't seem any special arguments were passed into the command. For example, this is quite common (key &amp; filename changed) and the keys are of varying length, anywhere from 14-18 characters.
<br><code>mcrypt -a rijndael-256 fileToEncrypt.tar.gz -k 0123456789abcdef1</code></p>

<p>So far, I have taken two approaches to this task. The first is to use mcrypt.exe and start the process using <code>Process</code>. However, I feel that makes the code (and program flow) very clunky. The second is to try to directly decrypt the file from my within program and have zero external program dependencies; I'd like to go this route.</p>

<p>I'm a bit confused with the MCrypt format. I've reviewed the FORMAT doc in the source code (<a href=""https://github.com/Distrotech/mcrypt/blob/master/doc/FORMAT"" rel=""nofollow noreferrer"">here</a> to view online) and I believe I have the beginning portion of the header taken care of properly. I cannot, however, seem to decrypt the encrypted data within the file.</p>

<p>1) How large is the IV and how do I pass it into my decryptor?<br>
2) How large is the checksum at the end of the file and do I need it?<br>
3) Are the above static in length?<br>
4) What is keymode (mcrypt-sha1) and how is it used?<br>
5) I notice that when properly decrypting (using mcrypt.exe) that there is a 140 byte difference between the encrypted and decrypted file. What makes up these 140 bytes?<br></p>

<p>Code and the beginning of the encrypted file below; no doubt my code is wrong starting with the comment ""Get the data""
Any pointers in the right direction would be greatly appreciated.</p>

<p><a href=""https://i.stack.imgur.com/gVC57.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gVC57.png"" alt=""Sample mcrypt Rijndael-256 file""></a>
<p></p>

<pre><code>/// &lt;summary&gt;
/// Decrypt an mcrypt file using rijndael-256
/// &lt;/summary&gt;
/// &lt;param name=""inputFile""&gt;File to decrypt&lt;/param&gt;
/// &lt;param name=""encryptionKey""&gt;Password&lt;/param&gt;
/// &lt;param name=""purge""&gt;&lt;/param&gt;
public static bool Decrypt (string inputFile, string encryptionKey)
{
    var rv = false;
    if (File.Exists(inputFile) == true)
    {
        using (FileStream stream = new FileStream(inputFile, FileMode.Open))
        {
            var buffer = new byte[1024];

            // MCrypt header
            stream.Read(buffer, 0, 3);

            if (buffer[0] == 0x00 &amp;&amp; buffer[1] == 0x6D &amp;&amp; buffer[2] == 0x03)
            {
                // Flag
                // Bit 7 - Salt Used
                // Bit 8 - IV not used
                var flag = (byte)stream.ReadByte();

                byte[] saltVal = null;
                var saltUsed = Utils.GetBit(flag, 6);
                byte[] ivVal = new byte[16];
                var ivUsed = (Utils.GetBit(flag, 7) == false);

                var algorithmName = Utils.GetNullTerminatedString(stream);

                stream.Read(buffer, 0, 2);
                var keyLen = (buffer[1] &lt;&lt; 8) + buffer[0];

                var algorithModeName = Utils.GetNullTerminatedString(stream);

                var keygenName = Utils.GetNullTerminatedString(stream);

                if (saltUsed)
                {
                    var saltFlag = (byte)stream.ReadByte();
                    if (Utils.GetBit(saltFlag, 0))
                    {
                        // After clearing the first bit the salt flag is now the length
                        Utils.ClearBit (ref saltFlag, 0);
                        saltVal = new byte[saltFlag];
                        stream.Read(saltVal, 0, saltFlag);
                    }
                }

                var algorithmModeName = Utils.GetNullTerminatedString(stream);

                if (ivUsed)
                {
                    stream.Read(ivVal, 0, ivVal.Length);
                }

                // Get the data - how much to get???
                buffer = new byte[stream.Length - stream.Position + 1];
                var bytesRead = stream.Read(buffer, 0, buffer.Length);

                using (MemoryStream ms = new MemoryStream())
                {
                    using (RijndaelManaged rijndael = new RijndaelManaged())
                    {
                        rijndael.KeySize = 256;
                        rijndael.BlockSize = 128;

                        var key = new Rfc2898DeriveBytes(System.Text.Encoding.ASCII.GetBytes(encryptionKey), saltVal, 1000);
                        rijndael.Key = key.GetBytes(rijndael.KeySize / 8);
                        //AES.Key = System.Text.Encoding.ASCII.GetBytes(encryptionKey);
                        //AES.IV = key.GetBytes(AES.BlockSize / 8);
                        rijndael.IV = ivVal;

                        rijndael.Mode = CipherMode.CBC;
                        rijndael.Padding = PaddingMode.None;

                        using (var cs = new CryptoStream(ms, rijndael.CreateDecryptor(), CryptoStreamMode.Write))
                        {
                            cs.Write(buffer, 0, buffer.Length);
                            cs.Close();

                            using (FileStream fs = new FileStream(inputFile + Consts.FILE_EXT, FileMode.Create))
                            {
                                byte[] decryptedBytes = ms.ToArray();
                                fs.Write(decryptedBytes, 0, decryptedBytes.Length);
                                fs.Close();
                                rv = true;
                            }
                        }
                    }
                }
            }
        }
    }

    return rv;
}
</code></pre>

<p><strong>Edit</strong><br>
I receive the following when turning on its verbose mode and without specifying rijndael-256. When I do specify the algorithm it does reflect that in the verbose output; both decrypt the file properly. The plot thickens...
<p>
Algorithm: rijndael-128<br>
Keysize: 32<br>
Mode: cbc<br>
Keyword mode: mcrypt-sha1<br>
File format: mcrypt
<p>
Also, ""passwords"" used to encrypt in various parts of the software range from 12 to 28 characters.</p>
","<h2>MCrypt file format</h2>

<p>Observations were made using <a href=""https://sourceforge.net/projects/mcrypt/"" rel=""nofollow noreferrer"">mcrypt-2.6.7-win32</a>, encrypting the following file with the command <code>mcrpyt.exe --no-openpgp -V test_in.txt</code></p>

<p><code>test_in.txt</code> unencrypted is 25 bytes in length, and the above command encrypts as follows, resulting in the file <code>test_out.txt.nc</code> which is 125 bytes in length.</p>

<pre class=""lang-none prettyprint-override""><code>+-------------+----------------------+----------------+---------------------------------------------+
| ﻿File Offset | Field Length (bytes) | Field Content  | Description                                 |
+-------------+----------------------+----------------+---------------------------------------------+
| 0           | 1                    | 0x0            | Zero byte                                   |
+-------------+----------------------+----------------+---------------------------------------------+
| 1           | 1                    | 0x6d           | m                                           |
+-------------+----------------------+----------------+---------------------------------------------+
| 2           | 1                    | 0x3            | Version                                     |
+-------------+----------------------+----------------+---------------------------------------------+
| 3           | 1                    | 0x40           | Flags - bit 7 set = salt, bit 8 set = no IV |
+-------------+----------------------+----------------+---------------------------------------------+
| 4           | 13                   | rijndael-128   | Algorithm name                              |
+-------------+----------------------+----------------+---------------------------------------------+
| 17          | 2                    | 32             | Key Size                                    |
+-------------+----------------------+----------------+---------------------------------------------+
| 19          | 4                    | cbc            | Algorithm mode                              |
+-------------+----------------------+----------------+---------------------------------------------+
| 23          | 12                   | mcrypt-sha1    | Key generator algorithm                     |
+-------------+----------------------+----------------+---------------------------------------------+
| 35          | 1                    | 21             | Salt length + 1                             |
+-------------+----------------------+----------------+---------------------------------------------+
| 36          | 20                   | Salt data      | Salt                                        |
+-------------+----------------------+----------------+---------------------------------------------+
| 56          | 5                    | sha1           | Check sum algorithm                         |
+-------------+----------------------+----------------+---------------------------------------------+
| 61          | 16                   | IV data        | Initialisation vector                       |
+-------------+----------------------+----------------+---------------------------------------------+
| 77          | 48                   | Encrypted data | 25 original data + 20 check sum + 3 padding |
+-------------+----------------------+----------------+---------------------------------------------+
| TOTAL       | 125                  |                |                                             |
+-------------+----------------------+----------------+---------------------------------------------+
</code></pre>

<p>Observing the output in different scenarios, the following block/key/IV sizes are used:
</p>

<pre><code>+--------------+--------------------+------------+------------------+
| Algorithm    | Block Size (bytes) | IV (bytes) | Key Size (bytes) |
+--------------+--------------------+------------+------------------+
| rijndael-128 | 16                 | 16         | 32               |
+--------------+--------------------+------------+------------------+
| rijndael-256 | 32                 | 32         | 32               |
+--------------+--------------------+------------+------------------+
</code></pre>

<p>The check sum is done on the original data before encryption, and appended to the end of the original data. The default check sum algorithm used is SHA-1 which results in a 20 byte hash. So, the original data of 25 bytes becomes 45 bytes. With a block size of 128 bits (16 bytes), that results in 3 bytes of padding to reach the block size of 48 bytes. With a block size of 256 bits (32 bytes), there would be 19 bytes of padding to get to 64 bytes. Zero bytes are used for padding, which is significant during decryption as these are not automatically removed since the size of the original data is not known.</p>

<h2>Reading the header</h2>

<p>Here is a code sample of reading the header and encrypted data at the tail of the file. Not all helper functions are included for brevity.</p>

<pre><code>public void ReadHeader(Stream stream)
{
    byte[] buffer = new byte[512];
    stream.Read(buffer, 0, 3);
    if (buffer[0] != 0x0) throw new FormatException($""First byte is not 0x0, invalid MCrypt file"");
    if ((char)buffer[1] != 'm') throw new FormatException($""Second byte is not null, invalid MCrypt file"");
    if (buffer[2] != 0x3) throw new FormatException($""Third byte is not 0x3, invalid MCrypt file"");

    byte flags = (byte)stream.ReadByte();
    KeyGeneratorUsesSalt = (flags &amp; (1 &lt;&lt; 6)) != 0;
    HasInitialisationVector = (flags &amp; (1 &lt;&lt; 7)) != 1;
    AlgorithmName = ReadNullTerminatedString(stream);
    stream.Read(buffer, 0, 2);
    KeySize = BitConverter.ToUInt16(buffer, 0);
    BlockSize = GetBlockSize(AlgorithmName);

    var cipherModeAsString = ReadNullTerminatedString(stream);
    CipherMode cipherMode;
    if (Enum.TryParse&lt;CipherMode&gt;(cipherModeAsString, out cipherMode))
        CipherMode = cipherMode;

    KeyGeneratorName = ReadNullTerminatedString(stream);

    if (KeyGeneratorUsesSalt)
    {
        var saltSize = ((byte)stream.ReadByte()) - 1;
        Salt = new byte[saltSize];
        stream.Read(Salt, 0, saltSize);
    }

    CheckSumAlgorithmName = ReadNullTerminatedString(stream);

    if (HasInitialisationVector)
    {
        InitialisationVector = new byte[BlockSize / 8];
        stream.Read(InitialisationVector, 0, BlockSize / 8);
    }

    int read = 0;
    byte[] remainingData = null;
    using (MemoryStream mem = new MemoryStream())
    {
        while ((read = stream.Read(buffer, 0, buffer.Length)) != 0)
        {
            mem.Write(buffer, 0, read);
            remainingData = mem.ToArray();
        }
    }

    EncryptedData = remainingData;
}
</code></pre>

<h2>Key Generation</h2>

<p>The key generator algorithm is specified in the header and by default in MCrypt format is mcrypt-sha1. Looking into the mcrypt source, that key is generated using the mhash library. It combines the passphrase with the salt to produce a key of the required number of bytes for the algorithm (32 bytes in both the cases I looked at). I translated the function <code>_mhash_gen_key_mcrypt</code> from the mhash library into C# as below - perhaps it's already in the .NET framework somewhere, but if so I couldn't find it.</p>

<pre><code>public byte[] GenerateKeyMcryptSha1(string passPhrase, byte[] salt, int keySize)
{
    byte[] key = new byte[KeySize], digest = null;
    int hashSize = 20;
    byte[] password = Encoding.ASCII.GetBytes(passPhrase);
    int keyBytes = 0;

    while (true)
    {
        byte[] inputData = null;
        using (MemoryStream stream = new MemoryStream())
        {
            if (Salt != null)
                stream.Write(salt, 0, salt.Length);
            stream.Write(password, 0, password.Length);
            if (keyBytes &gt; 0)
                stream.Write(key, 0, keyBytes);
            inputData = stream.ToArray();
        }

        using (var sha1 = new SHA1Managed())
            digest = sha1.ComputeHash(inputData);

        if (keySize &gt; hashSize)
        {
            Buffer.BlockCopy(digest, 0, key, keyBytes, hashSize);
            keySize -= hashSize;
            keyBytes += hashSize;
        }
        else
        {
            Buffer.BlockCopy(digest, 0, key, keyBytes, keySize);
            break;
        }                
    }

    return key;
}
</code></pre>

<h2>Decryption</h2>

<p>We can use standard .NET crypto classes to do most of the decryption, passing in 32-byte key we generated by hashing the passphrase and salt and where we're using the 128-bit or 256-bit flavour based on the algorithm name from the header. We assign the initialisation vector (IV) we read from the header via <code>rijndael.IV = InitialisationVector;</code>.</p>

<pre><code>/// &lt;summary&gt;
/// Decrypt using Rijndael
/// &lt;/summary&gt;
/// &lt;param name=""key""&gt;Key to use for decryption that was generated from passphrase + salt&lt;/param&gt;
/// &lt;param name=""keySize""&gt;Algo key size, e.g. 128 bit, 256 bit&lt;/param&gt;
/// &lt;returns&gt;Unencrypted data&lt;/returns&gt;
private byte[] DecryptRijndael(byte[] key, int keySize)
{
    using (RijndaelManaged rijndael = GetRijndael(key, keySize))
    {
        rijndael.IV = InitialisationVector;
        using (MemoryStream unencryptedStream = new MemoryStream())
        using (MemoryStream encryptedStream = new MemoryStream(EncryptedData))
        {
            using (var cs = new CryptoStream(encryptedStream, rijndael.CreateDecryptor(), CryptoStreamMode.Read))
                cs.CopyTo(unencryptedStream);

            byte[] unencryptedData = RemovePaddingAndCheckSum(unencryptedStream.ToArray(), GetCheckSumLen());                    
            return unencryptedData;
        }
    }
}

/// &lt;summary&gt;
/// Set algorithm mode/settings
/// &lt;/summary&gt;
/// &lt;param name=""key""&gt;Key to use for decryption that was generated from passphrase + salt&lt;/param&gt;
/// &lt;param name=""keySize""&gt;Algo key size, e.g. 128 bit, 256 bit&lt;/param&gt;
/// &lt;returns&gt;Instance ready to decrypt&lt;/returns&gt;
private RijndaelManaged GetRijndael(byte[] key, int keySize)
{
    var rijndael = new RijndaelManaged()
    {
        Mode = CipherMode, // e.g. CBC
        KeySize = keySize, // e.g. 256 bits
        Key = key, // e.g. 32-byte sha-1 hash of passphrase + salt
        BlockSize = BlockSize, // e.g. 256 bits
        Padding = PaddingMode.Zeros
    };

    return rijndael;
}
</code></pre>

<p>Since the padding style is zero-bytes, these are not removed during decryption as we don't know the size of the original data at that point, so the decrypted data will always be a multiple of the block size no matter the size of the original data. It's also going to have the checksum appended to the end. We could simply remove all zero bytes from the tail of the decrypted block, but we'd risk corrupting the check sum and original data if that really ended on a zero byte.</p>

<p>So instead we could work backwards one byte at a time from the tail and use the check sum to validate when we have the correct original data.</p>

<pre><code>/// &lt;summary&gt;
/// Remove zero padding by starting at the end of the data block assuming
/// no padding, and using the check sum appended to the end of the data to
/// verify the original data, incrementing padding until we match the 
/// check sum or conclude data is corrupt
/// &lt;/summary&gt;
/// &lt;param name=""data""&gt;Decrypted data block, including zero padding and checksum at end&lt;/param&gt;
/// &lt;param name=""checkSumLen""&gt;Length of the checksum appended to the end of the data&lt;/param&gt;
/// &lt;returns&gt;Unencrypted original data without padding and without check sum&lt;/returns&gt;
private byte[] RemovePaddingAndCheckSum(byte[] data, int checkSumLen)
{
    byte[] checkSum = new byte[checkSumLen];
    int padding = 0;

    while ((data.Length - checkSumLen - padding) &gt; 0)
    {
        int checkSumStart = data.Length - checkSumLen - padding;
        Buffer.BlockCopy(data, checkSumStart, checkSum, 0, checkSumLen);
        int dataLength = data.Length - checkSumLen - padding;
        byte[] dataClean = new byte[dataLength];
        Buffer.BlockCopy(data, 0 , dataClean, 0, dataLength);

        if (VerifyCheckSum(dataClean, checkSum))
            return dataClean;

        padding++;
    }

    throw new InvalidDataException(""Unable to decrypt, check sum does not match"");
}
</code></pre>

<p>The SHA1 20 byte check sum can be validated against the data simply as follows:</p>

<pre><code>private bool VerifySha1Hash(byte[] data, byte[] checkSum)
{
    using (SHA1Managed sha1 = new SHA1Managed())
    {
        var checkSumRedone = sha1.ComputeHash(data);
        return checkSumRedone.SequenceEqual(checkSum);
    }
}
</code></pre>

<p>And that's it, with the 128-bit after 3 attempts we should get the right check sum and corresponding original data, which we then return to the caller as the unencrypted original data.</p>
","168","<c#><encryption><mcrypt><rijndael><rijndaelmanaged>","3","1","1","2018-09-26 20:33:40","52525666","7","1","890721","","2018-09-24 06:36:49","2018-09-23 22:08:19",""
"43854309","How to work around Haskell's Int shift argument in a fold using xor?","<p>I have some code (generating the Rijndael S-box, for fun) that looks like this:</p>

<pre><code>q0 = q  ⊕  shiftL q  1
q1 = q0 ⊕  shiftL q0 2
q2 = q1 ⊕  shiftL q1 4
</code></pre>

<p>It seems kind of silly - wouldn't it be the perfect situation for a fold? But I can't use a fold because <code>shiftL</code> requires an <code>Int</code> for the distance to shift, and of course <code>xor</code> requires <code>Bits</code>.</p>

<p>It seems awkward to me that a function meant to operate on <code>Bits</code> won't accept <code>Bits</code> for all its arguments. I'd be curious to hear the rational for that, but I'm more eager to know if there's any elegant way to achieve the fold I want.</p>
","<p><code>foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> iteratively applies a function starting with a <code>b</code> to a list of <code>a</code>s until the list is exhausted and then returns the result. In this case our <code>a</code>s can be the <em>shift lengths</em>. So <code>1</code>, <code>2</code>, <code>4</code>. We can construct such a list with <code>iterate :: (a -&gt; a) -&gt; a -&gt; [a]</code>. Indeed:</p>

<pre><code>powers2 = iterate (2*) 1
</code></pre>

<p>Now we can feed that list to <code>foldl</code>. The function <code>foldl</code> performs is <code>\qi s -&gt; xor qi (shiftL qi s)</code>. So the complete function would be:</p>

<pre><code>qn :: (Num a, Foldable t, Bits [a]) =&gt; Int -&gt; r -&gt; t Int -&gt; [a]
qn n q = foldl (\qi s -&gt; xor qi (shiftL qi s)) q $ take n $ iterate (2*) 1
</code></pre>

<p>So if we call <code>qn 3 q</code> we perform the function three times on <code>q</code> and thus obtain the <code>q2</code> in your example. For example:</p>

<pre><code>Prelude Data.Bits&gt; qn 3 15
1285
</code></pre>

<p>Since:</p>

<pre><code>q           = 0000 0000 1111
shiftL q  1 = 0000 0001 1110
              --------------
q0          = 0000 0001 0001
shiftL q0 2 = 0000 0100 0100
              --------------
q1          = 0000 0101 0101
shiftL q1 4 = 0101 0101 0000
              --------------
q2          = 0101 0000 0101
</code></pre>

<p>which is the binary equivalent of 1285.</p>
","149","<haskell><bit-shift><fold><rijndael><bitwise-xor>","1","3","2","2017-05-11 14:38:23","43918579","9","","67579","","2017-05-08 18:32:32","2017-05-08 17:56:42",""
"43854309","How to work around Haskell's Int shift argument in a fold using xor?","<p>I have some code (generating the Rijndael S-box, for fun) that looks like this:</p>

<pre><code>q0 = q  ⊕  shiftL q  1
q1 = q0 ⊕  shiftL q0 2
q2 = q1 ⊕  shiftL q1 4
</code></pre>

<p>It seems kind of silly - wouldn't it be the perfect situation for a fold? But I can't use a fold because <code>shiftL</code> requires an <code>Int</code> for the distance to shift, and of course <code>xor</code> requires <code>Bits</code>.</p>

<p>It seems awkward to me that a function meant to operate on <code>Bits</code> won't accept <code>Bits</code> for all its arguments. I'd be curious to hear the rational for that, but I'm more eager to know if there's any elegant way to achieve the fold I want.</p>
","<p>Jon Purdy inferred what I should have stated clearly - I wanted a point-free function to pass to fold, and he provided one: <code>liftA2 (.) xor shiftL</code>.</p>
","149","<haskell><bit-shift><fold><rijndael><bitwise-xor>","1","0","2","2017-05-11 14:38:23","43918579","9","","67579","","2017-05-08 18:32:32","2017-05-08 17:56:42",""
"39178928","How to decrypt a word which have more than 16 letters in Rijndael encryption","<p>I made a Encryption program using Rijndael in C# after watching a video in youtube.It's very simple.</p>

<p><a href=""http://i.stack.imgur.com/LDDfD.png"" rel=""nofollow"">Interface picture</a>
I can enter 64 bit and 128 bit keys. but 192 bit keys are not allowed (Why? ). </p>

<p>And if I use 64 bit key, when I encrypt a word and try to decrypt it back it only decrypts word with character count &lt;= 16. it the character count is more than 16 an error messages thrown saysing ""Padding is Invalid and cannot be removed"".</p>

<p>Same goes for a 128 bit key. Only word with character count &lt;=32 is decrypted back. otherwise same error message is displayed.</p>

<p>Here's a summery to take a clear view of the question</p>

<p><a href=""http://i.stack.imgur.com/1llur.png"" rel=""nofollow"">Problem Summery picture</a>
Here's the code for Encryption </p>

<pre><code>// need using System.Security.Cryptography;
// using System.IO;
public Form1()
{
    InitializeComponent();
    desObj = Rijndael.Create();
}

string cipherData;
byte[] chipherbytes;
byte[] plainbyte;
byte[] plainbyte2;
byte[] plainkey;                

SymmetricAlgorithm desObj;

private void button2_Click(object sender, EventArgs e)
{

    try
    {

        cipherData = textBox1.Text;
        plainbyte = Encoding.ASCII.GetBytes(cipherData);
        plainkey = Encoding.ASCII.GetBytes(textBox4.Text);
        desObj.Key = plainkey;
        //choose any method 
        desObj.Mode = CipherMode.CBC;
        desObj.Padding = PaddingMode.PKCS7;
        MemoryStream ms = new MemoryStream();
        CryptoStream cs = new CryptoStream(ms, desObj.CreateEncryptor(), CryptoStreamMode.Write);
        cs.Write(plainbyte, 0, plainbyte.Length);
        cs.Close();
        chipherbytes = ms.ToArray();
        ms.Close();
        textBox2.Text = Encoding.ASCII.GetString(chipherbytes);
    }
    catch(Exception ex)
    {
        MessageBox.Show(ex.Message);
    }
}
</code></pre>

<p>and the decyption code is</p>

<pre><code>private void button3_Click(object sender, EventArgs e)
{
    try
    {

        MemoryStream ms1 = new MemoryStream(chipherbytes);
        CryptoStream cs1 = new CryptoStream(ms1, desObj.CreateDecryptor(), CryptoStreamMode.Read);
        cs1.Read(chipherbytes, 0, chipherbytes.Length);
        plainbyte2 = ms1.ToArray();
        cs1.Close();
        ms1.Close();
        textBox3.Text = Encoding.ASCII.GetString(plainbyte2);       

    }
    catch(Exception ex)
    {
        MessageBox.Show(ex.Message);
    }
}
</code></pre>
","<p>Ciphertext consists of arbitrary bytes which do not have to make up a valid ASCII encoding. If there are some non-printable ASCII characters, they will not be printed when used in this way: <code>Encoding.ASCII.GetString(chipherbytes)</code>.  </p>

<p>You need to encode the ciphertext with something like Base64 or Hex which will make the encoded ciphertext larger, but is perfectly representable as a printed string.</p>

<hr>

<p>Other considerations:</p>

<ul>
<li><p>CBC mode needs an initialization vector (IV) and since you're not setting any IV, it will be generated for you. The problem is that you need the same IV during decryption. This code works, because you're using the same <code>desObj</code> for encryption and decryption and it contains the same IV, but that's not going to work when you start copying ciphertext around.<br>
The IV is not supposed to be secret. A common way is to pass it along with the ciphertext by writing the IV in front of it and slicing it off before decryption.</p></li>
<li><p>You're not having any integrity checking. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible and you can detect whether the ciphertext was (maliciously) tampered with or the key was typed in incorrectly. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p></li>
<li><p>Rijndael commonly supports key sizes of 128, 192 and 256 bit. A byte usually has 8 bits, so that amounts to 16, 24 and 32 byte keys.</p></li>
<li><p>Keys are not typed in by the user, because they usually need to be indistinguishable from random noise and of specific length. It is better to let users type in a password and derive the key from that with something like PBKDF2, bcrypt, scrypt or Argon2 using a high iteration count / cost factor.</p></li>
</ul>
","146","<c#><encryption><rijndael>","1","0","1","2016-08-27 11:49:39","","0","","1816580","","2016-08-27 11:49:39","2016-08-27 08:08:57",""
"56926812","Decrypt AES-CBC-256 Mcrypt_RIJNDAEL encrypted in PHP decrypt on GOLang","<p>I try to rewrite some old code made in php5.6 (CodeIgniter) in go, but I'm banging my head with decryption on go. I managed to decode MCRYPT_RIJNDAEL_128 from php to go, where the iv size is 16 characters, but I can't do it on 256 - iv is 32. I don't want to use go_mcrypt because that's strict on libcrypt headers, so I tried using go classic encrypt libs AES cipher with CBC mode, but on 256 it complains about IV length... The php IV has 32 characters not 16 as expected.. </p>

<p>The php part works well...</p>

<pre class=""lang-php prettyprint-override""><code>private $CIPHER_KEY = ""12345678901234567890123456789012"";

    private function Encrypt($toEncrypt=null){
        $iv_size = $this-&gt;ivSize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);
        $iv = $this-&gt;ivKey = mcrypt_create_iv($iv_size, MCRYPT_RAND);
        $this-&gt;B64IV = base64_encode($iv);
        return base64_encode($iv . mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;CIPHER_KEY, $toEncrypt, MCRYPT_MODE_CBC, $iv));
    }
</code></pre>

<p>this is the PHP result:</p>

<pre class=""lang-none prettyprint-override""><code>KEY: 12345678901234567890123456789012
IV: Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1w=
ENC: Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1yATFjg26/Nav7cWtlJJL3djhUCND6KV8r/JL7owboKFA==
IV Size: 32
</code></pre>

<p>IV is included in the encrypted text... (and has 32 chars)</p>

<pre class=""lang-php prettyprint-override""><code>mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC); return 32
</code></pre>

<pre class=""lang-golang prettyprint-override""><code>func main(){
   key := []byte(""12345678901234567890123456789012"")

   iv,_ := base64.StdEncoding.DecodeString(""Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1w="")
   encText,_  := base64.StdEncoding.DecodeString(""Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1yATFjg26/Nav7cWtlJJL3djhUCND6KV8r/JL7owboKFA=="")
//   iv := encText[:32] // also tried to get the iv from encoded string


   fmt.Printf(""Key Len: %d\nIV  Len: %d\nENC Len: %d\n"",len(key),len(iv),len(encText))

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    if len(encText) &lt; aes.BlockSize {
        panic(""cipherText too short"")
    }

    cipherText := encText[32:]
    if len(cipherText)%aes.BlockSize != 0 {
        panic(""cipherText is not a multiple of the block size"")
    }

    mode := cipher.NewCBCDecrypter(block, iv)
    mode.CryptBlocks(cipherText, cipherText)

    cipherText, _ = pkcs7.Unpad(cipherText, aes.BlockSize)

   fmt.Printf(""Dec: %s\n"",cipherText)

}
</code></pre>

<p>Key Len: 32
IV  Len: 32
ENC Len: 64
panic: cipher.NewCBCDecrypter: IV length must equal block size</p>

<p>goroutine 1 [running]:
crypto/cipher.NewCBCDecrypter(0x10e7c20, 0xc00009a030, 0xc00008a000, 0x20, 0x42, 0x0, 0x0)</p>

<p>IV size is 32 but the block size is 16.</p>
","<p>This works in Linux - for anyone courious how to decode with IV 32 characters</p>

<blockquote>
  <p>apt install libmcrypt-dev</p>
  
  <p>go get ""github.com/tblyler/go-mcrypt""</p>
</blockquote>

<pre class=""lang-go-lang prettyprint-override""><code>import (
  ""fmt""
  ""github.com/tblyler/go-mcrypt""
  ""encoding/base64""
)

const (
   KEY = ""12345678901234567890123456789012""
   ENC = ""Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1yATFjg26/Nav7cWtlJJL3djhUCND6KV8r/JL7owboKFA==""
)

func main(){
    encText, _ := base64.StdEncoding.DecodeString(ENC)

    iv := encText[:32]
    toDecrypt := encText[32:]

    fmt.Printf(""Key Len: %d\n"",len(KEY))
    fmt.Printf(""IV  Len: %d\n"",len(iv))

    decText, err := mcrypt.Decrypt([]byte(KEY),iv,[]byte(toDecrypt))
    if err != nil { panic(err) }

    fmt.Printf(""%s\n"",decText)
}
</code></pre>
","145","<php><go><aes><rijndael><cbc-mode>","0","0","3","2019-07-08 15:07:43","","1","","","","","2019-07-07 23:12:13",""
"56926812","Decrypt AES-CBC-256 Mcrypt_RIJNDAEL encrypted in PHP decrypt on GOLang","<p>I try to rewrite some old code made in php5.6 (CodeIgniter) in go, but I'm banging my head with decryption on go. I managed to decode MCRYPT_RIJNDAEL_128 from php to go, where the iv size is 16 characters, but I can't do it on 256 - iv is 32. I don't want to use go_mcrypt because that's strict on libcrypt headers, so I tried using go classic encrypt libs AES cipher with CBC mode, but on 256 it complains about IV length... The php IV has 32 characters not 16 as expected.. </p>

<p>The php part works well...</p>

<pre class=""lang-php prettyprint-override""><code>private $CIPHER_KEY = ""12345678901234567890123456789012"";

    private function Encrypt($toEncrypt=null){
        $iv_size = $this-&gt;ivSize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);
        $iv = $this-&gt;ivKey = mcrypt_create_iv($iv_size, MCRYPT_RAND);
        $this-&gt;B64IV = base64_encode($iv);
        return base64_encode($iv . mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;CIPHER_KEY, $toEncrypt, MCRYPT_MODE_CBC, $iv));
    }
</code></pre>

<p>this is the PHP result:</p>

<pre class=""lang-none prettyprint-override""><code>KEY: 12345678901234567890123456789012
IV: Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1w=
ENC: Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1yATFjg26/Nav7cWtlJJL3djhUCND6KV8r/JL7owboKFA==
IV Size: 32
</code></pre>

<p>IV is included in the encrypted text... (and has 32 chars)</p>

<pre class=""lang-php prettyprint-override""><code>mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC); return 32
</code></pre>

<pre class=""lang-golang prettyprint-override""><code>func main(){
   key := []byte(""12345678901234567890123456789012"")

   iv,_ := base64.StdEncoding.DecodeString(""Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1w="")
   encText,_  := base64.StdEncoding.DecodeString(""Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1yATFjg26/Nav7cWtlJJL3djhUCND6KV8r/JL7owboKFA=="")
//   iv := encText[:32] // also tried to get the iv from encoded string


   fmt.Printf(""Key Len: %d\nIV  Len: %d\nENC Len: %d\n"",len(key),len(iv),len(encText))

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    if len(encText) &lt; aes.BlockSize {
        panic(""cipherText too short"")
    }

    cipherText := encText[32:]
    if len(cipherText)%aes.BlockSize != 0 {
        panic(""cipherText is not a multiple of the block size"")
    }

    mode := cipher.NewCBCDecrypter(block, iv)
    mode.CryptBlocks(cipherText, cipherText)

    cipherText, _ = pkcs7.Unpad(cipherText, aes.BlockSize)

   fmt.Printf(""Dec: %s\n"",cipherText)

}
</code></pre>

<p>Key Len: 32
IV  Len: 32
ENC Len: 64
panic: cipher.NewCBCDecrypter: IV length must equal block size</p>

<p>goroutine 1 [running]:
crypto/cipher.NewCBCDecrypter(0x10e7c20, 0xc00009a030, 0xc00008a000, 0x20, 0x42, 0x0, 0x0)</p>

<p>IV size is 32 but the block size is 16.</p>
","<p>I've been playing with a similar issue, when transporting code from php 5.6 to php 7.3. The easiest and most reliable way I have found is just to decrypt all the values with php 5.6 and then recrypt with the new format that works well. It's a one time thing to do when moving over, but it saves a lot of headaches.</p>
","145","<php><go><aes><rijndael><cbc-mode>","0","0","3","2019-07-08 15:07:43","","1","","","","","2019-07-07 23:12:13",""
"56926812","Decrypt AES-CBC-256 Mcrypt_RIJNDAEL encrypted in PHP decrypt on GOLang","<p>I try to rewrite some old code made in php5.6 (CodeIgniter) in go, but I'm banging my head with decryption on go. I managed to decode MCRYPT_RIJNDAEL_128 from php to go, where the iv size is 16 characters, but I can't do it on 256 - iv is 32. I don't want to use go_mcrypt because that's strict on libcrypt headers, so I tried using go classic encrypt libs AES cipher with CBC mode, but on 256 it complains about IV length... The php IV has 32 characters not 16 as expected.. </p>

<p>The php part works well...</p>

<pre class=""lang-php prettyprint-override""><code>private $CIPHER_KEY = ""12345678901234567890123456789012"";

    private function Encrypt($toEncrypt=null){
        $iv_size = $this-&gt;ivSize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);
        $iv = $this-&gt;ivKey = mcrypt_create_iv($iv_size, MCRYPT_RAND);
        $this-&gt;B64IV = base64_encode($iv);
        return base64_encode($iv . mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;CIPHER_KEY, $toEncrypt, MCRYPT_MODE_CBC, $iv));
    }
</code></pre>

<p>this is the PHP result:</p>

<pre class=""lang-none prettyprint-override""><code>KEY: 12345678901234567890123456789012
IV: Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1w=
ENC: Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1yATFjg26/Nav7cWtlJJL3djhUCND6KV8r/JL7owboKFA==
IV Size: 32
</code></pre>

<p>IV is included in the encrypted text... (and has 32 chars)</p>

<pre class=""lang-php prettyprint-override""><code>mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC); return 32
</code></pre>

<pre class=""lang-golang prettyprint-override""><code>func main(){
   key := []byte(""12345678901234567890123456789012"")

   iv,_ := base64.StdEncoding.DecodeString(""Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1w="")
   encText,_  := base64.StdEncoding.DecodeString(""Egu4tSySXluBLi5dcMzHbZHVSOS7jdNwUKUFlZ8dL1yATFjg26/Nav7cWtlJJL3djhUCND6KV8r/JL7owboKFA=="")
//   iv := encText[:32] // also tried to get the iv from encoded string


   fmt.Printf(""Key Len: %d\nIV  Len: %d\nENC Len: %d\n"",len(key),len(iv),len(encText))

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    if len(encText) &lt; aes.BlockSize {
        panic(""cipherText too short"")
    }

    cipherText := encText[32:]
    if len(cipherText)%aes.BlockSize != 0 {
        panic(""cipherText is not a multiple of the block size"")
    }

    mode := cipher.NewCBCDecrypter(block, iv)
    mode.CryptBlocks(cipherText, cipherText)

    cipherText, _ = pkcs7.Unpad(cipherText, aes.BlockSize)

   fmt.Printf(""Dec: %s\n"",cipherText)

}
</code></pre>

<p>Key Len: 32
IV  Len: 32
ENC Len: 64
panic: cipher.NewCBCDecrypter: IV length must equal block size</p>

<p>goroutine 1 [running]:
crypto/cipher.NewCBCDecrypter(0x10e7c20, 0xc00009a030, 0xc00008a000, 0x20, 0x42, 0x0, 0x0)</p>

<p>IV size is 32 but the block size is 16.</p>
","<p>I just test it from my MacOS, the above code is working from Mohave 10.14.5.</p>

<p>I used MacPorts to install libmcrypt</p>

<blockquote>
  <p>sudo port install libmcrypt</p>
  
  <p>mkdir mcrypt
  curl -o mcrypt/mcrypt.go <a href=""https://raw.githubusercontent.com/tblyler/go-mcrypt/master/mcrypt.go"" rel=""nofollow noreferrer"">https://raw.githubusercontent.com/tblyler/go-mcrypt/master/mcrypt.go</a></p>
</blockquote>

<p><em>or copy it from your own src/github.com/tblyler/go-mcrypt to project mcrypt folder</em></p>

<p>now edit mcrypt.go and add the C flags:</p>

<pre class=""lang-go-lang prettyprint-override""><code>package mcrypt

/*
#cgo LDFLAGS: -L/opt/local/lib -lmcrypt
#cgo CFLAGS: -I/opt/local/include
#include &lt;stdlib.h&gt;
...
</code></pre>

<p>modify import from above example to import mcrypt version locally, and run it...</p>

<pre class=""lang-go prettyprint-override""><code>package main

import (
  ""fmt""
//""github.com/tblyler/go-mcrypt""
  ""./mcrypt""
  ""encoding/base64""
)
</code></pre>

<p>when running the code it adds a warning about linking </p>

<pre><code>ld: warning: building for macOS, but linking in object file (/var/folders/xz/7ng416ds5611ypt12c96g1_40000gn/T/go-link-754294955/go.o) built for
Key Len: 32
IV  Len: 32
Abra Cadabra
</code></pre>
","145","<php><go><aes><rijndael><cbc-mode>","0","0","3","2019-07-08 15:07:43","","1","","","","","2019-07-07 23:12:13",""
"13653771","Trying to reconcile elliptic curve error","<p>I am trying to do the following:</p>

<p>I have a piece of software which is using ECC to generate a standard Rijndael key (<em>NOT</em> AES... There is a difference: AES only supports key sizes of 128, 192, and 256 bits, while Rijndael  originally supported 160 and 224 bits.  This bit me at first when I was looking at the software.)  I have been able to determine that it does the following:</p>

<p>It has several modes, but in the weakest mode, it uses ECC secp160r1 to generate a 160 bit key (hence the Rijndael and <em>NOT</em> AES).  I have been able to take ""public"" values and use the private key in my own software, and, using openssl calls, have been able to generate the same keys and decrypt the data I need to decrypt.</p>

<p>In the best (strongest/hardest, what have you) mode, it pretty much does the same thing, however, it uses ECC sect571k1 to generate a key and takes only the first 32 bytes of the 72 it generates for a Rijndael 256 bit key (in this case, you could say AES256).</p>

<p>However, in another mode, it APPEARS to do the same thing, but when I attempt to do the same thing as I have done before, I DON'T get the same shared secret.</p>

<p>If you use the standard definitions for Alice and Bob:</p>

<pre><code>da = Alice's secret key
db = Bob's secret key
Qa = Alice's public key
Qb = Bob's public key
S  = Shared secret
</code></pre>

<p>I Have:</p>

<pre><code>daQb --&gt; The public value sent from Alice.
db   --&gt; My ""secret"" key.
Qb   --&gt; My ""public"" key.
Sc   --&gt; The ""correct"" shared secret as computed by above program
</code></pre>

<p>I have checked that my Qb and the daQb are on the sect283k1 curve.  If I use
sect283r1, things fail, and my points don't register on that curve using Openssl
EC_POINT, EC_KEY, EC_GROUP functions (I would post the code now, but I don't have
it in front of me.  As soon as I do, I'll try to post it here).  I have been able
to reproduce, as I said, two other modes, and it seems to work properly.  However,
in this mode, when I compute the key, I get Sw --> The ""wrong"" shared secret as computed
by MY program.</p>

<p>So, my question is this:  Do I have enough information to potentially determine if I may
be using the wrong db?  I don't think that I am, because in the other two cases, I can
get the db and it works fine.  Unfortunately, I don't have the source code for said program.  I am trying to create a tool that can work with the data generated by the original tool.</p>

<p>I thought of trying to invert Qb and multiply the data by daQb, but all that really does is
get me da, which, while interesting, doesn't lead me to a way I can use it on the shared secret I have to determine db, to check my work.</p>

<p>The other thing I thought of is that maybe a similar curve to sect283k1 was used, but NOT sect283k1 (i.e. maybe some different G?  I'm not sure if it is possible to use another generator on that curve, but I didn't think there was but 1 generator per curve, but maybe that is wrong, and maybe another generator would produce different results... i.e. the correct results).</p>

<p>At any rate, I've tried several things only to produce the same wrong key data using, presumably, the same data the other program is using.  Maybe someone with some far superior EC math knowledge (just about any would be better than my own, but I'm hoping for someone who can help me see what I'm missing) can show me a way I can reconcile what I get with what the other tool gets.</p>

<p>Unfortunately, I can stop just before the Rijndael key is set and see what it will be set to.  I can find that part of the key and see the original data that came from an ECDH_compute_key operation (which appears to essentially be an EC_POINT_mul between daQb and db (If I know enough about Diffie-Hellman key exchange... I've verified this much anyway using some openssl calls), and I know a few other things, but I can't locate the Bignum/EC code that would help me see what went into the operation.  So I'm looking for another way to skin the cat.</p>

<p>Thanks to anyone that can help.</p>
","","144","<encryption><rijndael><elliptic-curve>","2","","0","2012-11-30 21:55:59","","0","","","","","2012-11-30 21:55:59",""
"20081086","Must symmetric keys and initiliazation vectors always be 128, 192, or 256 bits?","<p>The following string contains 20 bytes (160 bits).  Do I have to make my keys and initialization vectors 128,192, or 256 or is there something I can do to make it 256 and keep the same key:</p>

<pre><code>    byte[] bbb = Encoding.ASCII.GetBytes(""abcdefghijklmnopqrst"");


  // Define other methods and classes here
  static string EncryptStringToBytes(string plainText, string Key, string IV)
    {
        // Check arguments. 
        if (plainText == null || plainText.Length &lt;= 0)
            throw new ArgumentNullException(""plainText"");
        if (Key == null || Key.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        if (IV == null || IV.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        string encrypted;
        // Create an RijndaelManaged object 
        // with the specified key and IV. 
        using (RijndaelManaged rijAlg = new RijndaelManaged())
        {
            rijAlg.Mode = CipherMode.CBC;
            rijAlg.BlockSize = 256;
            rijAlg.KeySize = 256;
            rijAlg.Key = Encoding.ASCII.GetBytes(Key);
            rijAlg.IV = Encoding.ASCII.GetBytes(IV);

            // Create a decrytor to perform the stream transform.
            ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

            // Create the streams used for encryption. 
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {

                        //Write all data to the stream.
                        swEncrypt.Write(plainText);
                    }
                    encrypted = Convert.ToBase64String(msEncrypt.ToArray());
                }
            }
        }


        // Return the encrypted bytes from the memory stream. 
        return encrypted;

    }

    static string DecryptStringFromBytes(string cipherText,string Key, string IV)
    {
        // Check arguments. 
        if (cipherText == null || cipherText.Length &lt;= 0)
            throw new ArgumentNullException(""cipherText"");
        if (Key == null || Key.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        if (IV == null || IV.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");

        // Declare the string used to hold 
        // the decrypted text.
        string plaintext = null;

        // Create an RijndaelManaged object 
        // with the specified key and IV. 
        using (RijndaelManaged rijAlg = new RijndaelManaged())
        {
            rijAlg.Mode = CipherMode.CBC;
            rijAlg.BlockSize = 256;
            rijAlg.KeySize = 256;
            rijAlg.Key = Encoding.ASCII.GetBytes(Key);
            rijAlg.IV = Encoding.ASCII.GetBytes(IV);

            // Create a decrytor to perform the stream transform.
            ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

            // Create the streams used for decryption. 
            using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText)))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {

                        // Read the decrypted bytes from the decrypting stream 
                        // and place them in a string.
                        plaintext = srDecrypt.ReadToEnd();

                    }
                }
            }

        }

        return plaintext;

    }
</code></pre>
","<p>It depends on which implementation of <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm%28v=vs.110%29.aspx"" rel=""nofollow""><code>System.Security.Cryptography.SymmetricAlgorithm</code></a> you're using. The legal key and block sizes are dependent upon the algorith. You can check the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.legalkeysizes%28v=vs.110%29.aspx"" rel=""nofollow""><code>LegalKeySizes</code></a> and <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.legalblocksizes%28v=vs.110%29.aspx"" rel=""nofollow""><code>LegalBlockSizes</code></a> property to check what sizes are supported by your particular algorithm. You can also use the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.validkeysize%28v=vs.110%29.aspx"" rel=""nofollow""><code>ValidKeySize()</code></a> method to check if a particular key size is valid for your algorithm.</p>

<p>IIRC, the IV needs to be sized the same size as the block size in use.</p>

<p>Also, normally, you'd gen up an instance of your particular algorithm and let it create a random key and IV, which you can then save for later use.</p>
","143","<c#><.net><encryption-symmetric><rijndael>","0","0","1","2013-11-19 20:23:36","","4","","33690","","2013-11-19 20:22:07","2013-11-19 20:11:16",""
"45526211","RijdaelManaged Encrypted byte[] different than Decrypted byte[] using same key/iv","<p>Ok so I am attempting to code a byte[] before transmission and decode it after. I start out with ""This is a super secret message"" converted to byte[] and then encrypted by using RijdaelManaged. It goes from byte[30] (unencrypted) to byte[16] when encrypted, but when I attempt to unencrypt it, it becomes byte[13] and renders only ""System.Byte[]"" when translated into string with a string builder.</p>

<p>Edit: I already triple checked that the keyIV.Key and keyIV.IV are both matching when encrypting/decrypting</p>

<p>Calling Method:</p>

<pre><code>    static void Main(string[] args)
    {
        KeyIV keyIV = Encryption.GenerateKeyIV();
        int keyLen = keyIV.Key.Length;
        int ivLen = keyIV.IV.Length;

        string plain = ""This is a super secret message"";

        byte[] plainArray = Encoding.ASCII.GetBytes(plain);

        byte[] encryptedArray = Encryption.EncryptBytes(ref plainArray, keyIV.Key, keyIV.IV);

        byte[] decryptedArray = Encryption.DecryptBytes(ref encryptedArray, keyIV.Key, keyIV.IV);

        Console.WriteLine(""Original Message: {0}\n"", plain);
        Console.WriteLine(""Byte[{0}] Converted Message: {1}\n"", plainArray.Length, BitConverter.ToString(plainArray));
        Console.WriteLine(""Byte[{0}] Encrypted Message: {1}\n"", encryptedArray.Length, BitConverter.ToString(encryptedArray));
        Console.WriteLine(""Byte[{0}] Decrypted Message: {1}\n"", decryptedArray.Length, BitConverter.ToString(decryptedArray));

        Console.ReadLine();
    }
</code></pre>

<p>Encrypt Method:</p>

<pre><code>        public static byte[] EncryptBytes(ref byte[] input, byte[] key, byte[] iv)
    {
        if (input.Length &gt; 0 &amp;&amp; key != null &amp;&amp; iv != null)
        {
            using (RijndaelManaged rm = new RijndaelManaged() { Key = key, IV = iv })
            {
                rm.Padding = PaddingMode.PKCS7;

                ICryptoTransform encryptor = rm.CreateEncryptor(rm.Key, rm.IV);

                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter sw = new StreamWriter(cs)) { sw.Write(input); }
                    }

                    return ms.ToArray();
                }
            }
        }

        return null;
    }
</code></pre>

<p>Decrypt Method:</p>

<pre><code>        public static byte[] DecryptBytes(ref byte[] input, byte[] key, byte[] iv)
    {
        if (input != null &amp;&amp; key != null &amp;&amp; iv != null)
        {
            using (RijndaelManaged rm = new RijndaelManaged() { Key = key, IV = iv })
            {
                ICryptoTransform decryptor = rm.CreateDecryptor(rm.Key, rm.IV);

                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write)) { cs.Write(input, 0, input.Length); }

                    return ms.ToArray();
                }
            }
        }

        return null;
    }
</code></pre>

<p>Resulting Output:</p>

<p>Original Message: This is a super secret message</p>

<p>Byte[30] Converted Message: 54-68-69-73-20-69-73-20-61-20-73-75-70-65-72-20-73-65-63-72-65-74-20-6D-65-73-73-61-67-65</p>

<p>Byte[16] Encrypted Message: DD-85-D4-1E-E6-40-AA-44-DB-1A-17-33-A7-73-70-34</p>

<p>Byte[13] Decrypted Message: 53-79-73-74-65-6D-2E-42-79-74-65-5B-5D</p>
","<p>The issue is that you are using a <code>StreamWriter</code> (which is a <code>TextWriter</code>) to write to your encryption stream. What that is doing is selecting the overload of <code>.Write</code> that takes an Object, and you are passing an array... When you do this, the <code>TextWriter</code> assumes that the object you are passing has some kind of smart <code>.ToString()</code> overload that's going to return the string value that you want to write to the target stream. In this case your array does not, so you are encrypting the value ""System.Byte[]"".</p>

<p>As it turns out, you don't really want a StreamWriter. You just want to write the bytes of the array that your encrypt method is given to the CryptoStream. Fortunately streams have a built in Write method for just that. Try this in the body of your encrypt method instead:</p>

<pre><code>                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                    {
                        cs.Write(input, 0, input.Length);
                        cs.Flush();
                    }

                    return ms.ToArray();
                }
</code></pre>

<p>I got a hint of what was going wrong when I compared the text output of your arrays, rather than the byte representations:</p>

<pre><code>        Console.WriteLine(""Original Message: {0}\n"", plain);
        Console.WriteLine(""Byte[{0}] Converted Message: {1}\n"", plainArray.Length, Encoding.ASCII.GetString(plainArray));
        Console.WriteLine(""Byte[{0}] Encrypted Message: {1}\n"", encryptedArray.Length, Encoding.ASCII.GetString(encryptedArray));
        Console.WriteLine(""Byte[{0}] Decrypted Message: {1}\n"", decryptedArray.Length, Encoding.ASCII.GetString(decryptedArray));
</code></pre>
","138","<c#><encryption><rijndael><rijndaelmanaged>","0","2","1","2017-08-06 02:18:25","45527978","5","","5687599","","2017-08-06 00:35:39","2017-08-05 20:37:41",""
"56519438","Rijndael encrypter: Getting empty byte[]. Not encrypting anything","<p>Good evening!</p>

<p>I'm trying to implement an encrypter using Rijndael algorithm and Rijndael class in c#. I tried to follow (not doing exactly the same code) the link bellow, but the problem is given a string to be encrypted I'm not getting any result. I'm no getting any error message too.</p>

<p><a href=""https://docs.microsoft.com/pt-br/dotnet/api/system.security.cryptography.rijndael?view=netframework-4.8"" rel=""nofollow noreferrer"">https://docs.microsoft.com/pt-br/dotnet/api/system.security.cryptography.rijndael?view=netframework-4.8</a></p>

<p>CryptDecrypt.cs</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace RijndaelAlgorithm {
    public class CryptDecrypt {
        private Byte[] iv;
        private Byte[] key; 

        public CryptDecrypt(String key) {
            iv = new Byte[] {21, 10, 21, 251, 132, 76, 121, 27, 210, 81, 215, 99, 14, 235, 11, 75};
            this.key = Encoding.ASCII.GetBytes(key);
        }

        public String encryptMsg(String originalMsg) {
            byte[] encryptedMsg;

            Rijndael rijAlg = Rijndael.Create();
            rijAlg.Key = formatKey();
            rijAlg.IV = iv;

            MemoryStream msEncrypt = new MemoryStream();
            ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
            CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);

            StreamWriter swEncrypt = new StreamWriter(csEncrypt);
            swEncrypt.Write(originalMsg);

            encryptedMsg = msEncrypt.ToArray();
            Console.WriteLine(""encryptedMsg.Length: "" + encryptedMsg.Length);

            return Convert.ToBase64String(encryptedMsg, 0, encryptedMsg.Length);
        }

        private Byte[] formatKey() {
            int len = key.Length;

            String strKey = System.Text.Encoding.UTF8.GetString(key);
            String fillKey = """";
            String strFormatedKey = """";

            Byte[] formatedKeyByte;

            if (len &lt; 16)
                fillKey = new String('X',(16 - len));

            strFormatedKey = String.Concat(strKey, fillKey);
            formatedKeyByte = Encoding.ASCII.GetBytes(strFormatedKey);

            return formatedKeyByte;
        }
    }
}
</code></pre>

<p>Menu.cs</p>

<pre><code>using System;

namespace RijndaelAlgorithm {
    public class Menu {
        private CryptDecrypt r;

        public Menu() {
            r = new CryptDecrypt(""123654"");
        }

        public void showMenu() {
            Console.WriteLine(""the encrypted message is: "" + r.encryptMsg(""isjustatest""));
        }
    }
}
</code></pre>
","<p>You seem to want to encrypt a message with your .NET application and want to get the same encrypted bytes as a particular online service that you mention in one of your comments.</p>

<p><strong>Parameter</strong></p>

<p>One parameter for an encryption is the initialization vector (IV). It should be random and used only once. So if two apps are correctly implemented (with different random IVs), the encrypted bytes are different.</p>

<p>This service returns a different result every time you press the key, even if you use the same input.</p>

<p>However, if you generally take the different encrypted results and decrypt them with the same key, you will get the original bytes back.</p>

<p>The next problem with testing with this specific service is, that they delivering always the same prefix base64 sequence 'U2FsdGVkX1'. This is not standard AES output (if you decode this base64 sequence you get 'Salted_P'). So it makes sense to use a different online service for tests.</p>

<p>So if two AES-256 encoding implementations are using the same parameters, we will get the same encoded result. We need for it:</p>

<ul>
<li>Key (32 bytes, not 16 for AES-256)</li>
<li>IV (16 bytes)</li>
</ul>

<p>Speaking of key length: As others mentioned in the comments, you should not simply add ""X"" or something similar, but use a standard cryptographic mechanism to derive a good key.</p>

<p>Convenient for tests are methods that convert hex strings to byte arrays and back, e.g. see StringToByteArray and ByteArrayToString methods in this cool answer:
<a href=""https://stackoverflow.com/a/311179"">https://stackoverflow.com/a/311179</a></p>

<p>Let's give it a try. If we take your message 'isjustatest' which has the hex string'69736a7573746174657374374', we need a 32-byte key for AES-256 and 16 bytes IV.</p>

<p>As others mentioned in the comments, you need to flush and close the stream (or better yet, use a 'using' statement).</p>

<p>Taking your code and change the key and iv assignment and output the encrypted message to the console:</p>

<pre><code>rijAlg.Key = StringToByteArray(""519C7C3402A943D8AF83746C1548E475319EBDA6A38046059F83B21709BD6A5B""); //32 bytes
rijAlg.IV =  StringToByteArray(""0D024CF947CE4C288880D0B34D29BFA5""); // 16 bytes
...
swEncrypt.Write(originalMsg);
swEncrypt.Flush();
swEncrypt.Close();
...
Console.WriteLine(""encrypted bytes: '"" + ByteArrayToString(encryptedMsg) + ""'"");
</code></pre>

<p>This results in the output of '419536f27da3406625b2d07f43833aab' in the debug console.</p>

<p>So now we can use an online service, e.g. <a href=""https://cryptii.com/pipes/aes-encryption"" rel=""nofollow noreferrer"">https://cryptii.com/pipes/aes-encryption</a> where we can enter input data, select the encryption algorithm, supply key and IV bytes and then we get the same result as in your program, see screenshot here:</p>

<p><a href=""https://i.stack.imgur.com/YVVkF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YVVkF.png"" alt=""enter image description here""></a></p>

<p>As mentioned above, don't forget to use different random IVs when using it in a real application. </p>
","137","<c#><encryption><aes><rijndael>","0","0","1","2019-06-12 11:01:48","","5","","9090967","","2019-06-10 01:14:40","2019-06-10 00:53:11",""
"11544475","Rijndael Encryption for different text generates same encrypted text?","<p>What are the chances that a Rijndael Encryption for two different texts could generate the same encrypted text.</p>

<p>Say I have a plain text  </p>

<p>""abc"" > encrypts to > ""defdefdef""</p>

<p>Can this happen?      </p>

<p>""hij""  > also encrypts to > ""defdefdef""</p>
","<p>For the same key, the chances are nil.  Different inputs map to different outputs with the same key.</p>

<p>For different keys, there is a minuscule probability that two different texts encrypted with two different keys happen to produce the same cipher text.  When I say minuscule, I mean negligible.  It is more likely that the Andromeda galaxy will park itself right next to the sun today.</p>
","135","<security><encryption><rijndael>","1","4","1","2012-07-18 15:12:52","11544538","2","","492405","","2012-07-18 15:12:52","2012-07-18 15:06:16",""
"29710159","c# decryption producing wrong result [Update 1]","<p>In my program the following happens.</p>

<ol>
<li><p>A random string is generated and encrypted
<strong>This is the Encryption Routine:</strong></p>

<pre><code>private static readonly byte[] SALT = new byte[] { 0x26, 0xdc, 0xff, 0x00, 0xad, 0xed, 0x7a, 0xee, 0xc5, 0xfe, 0x07, 0xaf, 0x4d, 0x08, 0x22, 0x3c };
    //TODO: The SALT needs to be derived and unique for each user!

    internal  byte[] Encrypt(byte[] plain)
    {
        string password = Properties.Settings.Default.PasswordOne;
        MemoryStream memoryStream;
        CryptoStream cryptoStream;
        Rijndael rijndael = Rijndael.Create();
        rijndael.Padding = PaddingMode.Zeros;
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, SALT);
        rijndael.Key = pdb.GetBytes(32);
        rijndael.IV = pdb.GetBytes(16);
        memoryStream = new MemoryStream();
        cryptoStream = new CryptoStream(memoryStream, rijndael.CreateEncryptor(), CryptoStreamMode.Write);
        cryptoStream.Write(plain, 0, plain.Length);
        cryptoStream.Close();
        return memoryStream.ToArray();
    }
</code></pre></li>
<li><p>This encrypted string is saved to a File called DEFT
<strong>This is the Save Routine:</strong></p>

<pre><code> private void CreateDeft2(FileSystemEncryption fse, string Deft2FileName, string drive)
{
    if (DrivesLog != null) DrivesLog(""Creating DEFT2"");
    FileStream fs = null;
    StreamWriter sw = null;
    string location = Path.Combine(drive, Deft2FileName);
    try
    {
        fs = new FileStream(location, FileMode.CreateNew, FileAccess.Write, FileShare.None);
        sw = new StreamWriter(fs, Encoding.Unicode);

        if (DrivesLog != null) DrivesLog(""Creating Random Contents"");
        string fakeContents = CreateRandomString(1024000);      // Create the fake contents
        if (DrivesLog != null) DrivesLog(""Converting Random Contents to Bytes"");
        byte[] bFakeContents = GetBytes(fakeContents);          // Convert to bytes
        if (DrivesLog != null) DrivesLog(""Encrypting Random Content Bytes"");
        byte[] ebFakeContents = fse.Encrypt(bFakeContents);     // Encrypt
        if (DrivesLog != null) DrivesLog(""Converting Encrypted Bytes to String"");
        string sedFakeContents = GetString(ebFakeContents);     // Convert to string

        if (DrivesLog != null) DrivesLog(""Writing DEFT2"");
        sw.Write(sedFakeContents);                              // Write it out
        fs.Flush();                                             // Flush the buffer

        sw.Close();
        fs.Close();
        if (DrivesLog != null) DrivesLog(""Successfully Created DEFT2"");
    }
    catch (Exception ex)
    {
        if (DrivesLog != null) DrivesLog(""Failed to Create DEFT2 "" + ex.Message);
        sw.Close();
        fs.Close();
    }
}
</code></pre></li>
<li><p>At a particular location within the DEFT file another string of 32 chars is created and saved
<strong>This is the code for that:</strong></p>

<pre><code>private void InsertDEFT2NameLength(FileSystemEncryption fse, FileStream fs, StreamWriter sw)
    {
        if (DrivesLog != null) DrivesLog(""Inserting DEFT2 Name"");
        string deft2NameLength = ""0"";                                       // init the length
        if (DrivesLog != null) DrivesLog(""Converting DEFT2 Name to Bytes"");
        if (fDEFT2Name.Length &lt; 32)
        {
            for (int idx = fDEFT2Name.Length; idx &lt; 32; idx++)
            {
                fDEFT2Name = fDEFT2Name + ""!"";
            }
        }
        byte[] bdeft2Name = GetBytes(fDEFT2Name);                        // convert filename to bytes
        if (DrivesLog != null) DrivesLog(""Encrypting DEFT2 Name"");
        byte[] ebdeft2Name = fse.Encrypt(bdeft2Name);                       // Encrypt
        if (DrivesLog != null) DrivesLog(""Getting Length of Encrypted DEFT2 Name"");
        long ebdeft2NameLength = ebdeft2Name.LongLength;                    // Get Length of the Encrypted Bytes as a long
        if (DrivesLog != null) DrivesLog(""Converting DEFT2 Name Length to String"");
        string sebdeft2NameLength = ebdeft2NameLength.ToString();     // Convert Length to string Add Shebang so we know when we have read the full length
        if (DrivesLog != null) DrivesLog(""Converting DEFT2 Name Length to Bytes"");
        byte[] bsebdeft2NameLength = GetBytes(sebdeft2NameLength);          // Convert length string to bytes
        if (DrivesLog != null) DrivesLog(""Encrypting DEFT2 Name Length"");
        byte[] ebsebdeft2NameLength = fse.Encrypt(bsebdeft2NameLength);     // Encrypt
        if (DrivesLog != null) DrivesLog(""Converting Encrypted DEFT2 Name Length to String"");
        deft2NameLength = GetString(ebsebdeft2NameLength);                  // Convert to string

        if (DrivesLog != null) DrivesLog(""Seeking to Correct Location"");
        long startPos = GenerateDEFT2LengthStartPosition();
        fs.Seek(startPos, SeekOrigin.Current);    // Seek to correct location
        if (DrivesLog != null) DrivesLog(""New Position "" + startPos.ToString(""N0""));
        if (DrivesLog != null) DrivesLog(""Writing Encrypted Name Length to New Position"");
        sw.Write(deft2NameLength);                                          // Write the Encrypted length
        fs.Flush();                                                         // Flush the buffer immediately
    }
</code></pre>

<ol start=""4"">
<li><p>I then try to decrypt that new string. <strong>This decrypts the string (or at least it should!)</strong></p>

<p>private long ReadDEFT2Len(string DEFT, long lenPos, FileSystemEncryption fse)
    {
        if (DrivesLog != null) DrivesLog(""Reading DEFT2 Name Length"");
        StringBuilder sb = new StringBuilder();</p>

<pre><code>    FileStream fs = null;
    StreamReader sr = null;

    try
    {
        fs = new FileStream(DEFT, FileMode.Open, FileAccess.Read, FileShare.Read);
        sr = new StreamReader(fs, Encoding.Unicode);

        char[] C = new char[32];
        fs.Seek(lenPos, SeekOrigin.Begin);
        sr.Read(C, 0, 32);

        string sC = new string(C);
        byte[] bsC = GetBytes(sC);

        byte[] dRes = fse.Decrypt(bsC);
        string sbdRes = GetString(dRes);
        foreach (char ic in sbdRes)
        {
            if (ic == '!') break;
            sb.Append(ic.ToString());
        }

        sr.Close();
        fs.Close();

        if (DrivesLog != null) DrivesLog(""DEFT2 Name Length = "" + sb.ToString());
        return long.Parse(sb.ToString());
    }
    catch (Exception ex)
    {
        if (DrivesLog != null) DrivesLog(""ERROR Reading DEFT2 Name Length "" + ex.Message);
        if (sr != null) sr.Close();
        if (fs != null) fs.Close();
        return -1;
    }

}
</code></pre></li>
</ol></li>
</ol>

<p>Excuse the formatting - it just won't play nice! </p>

<p>The decryption routine does not decrypt the original string - it simply returns incomprehensible text. <strong>The Decryption routing is here:</strong></p>

<pre><code>internal  byte[] Decrypt(byte[] cipher)
    {
        string password = Properties.Settings.Default.PasswordOne;
        MemoryStream memoryStream;
        CryptoStream cryptoStream;
        Rijndael rijndael = Rijndael.Create();
        rijndael.Padding = PaddingMode.Zeros;
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, SALT);
        rijndael.Key = pdb.GetBytes(32);
        rijndael.IV = pdb.GetBytes(16);
        memoryStream = new MemoryStream();
        cryptoStream = new CryptoStream(memoryStream, rijndael.CreateDecryptor(), CryptoStreamMode.Write);
        cryptoStream.Write(cipher, 0, cipher.Length);
        cryptoStream.FlushFinalBlock();
        cryptoStream.Close();
        return memoryStream.ToArray();
    }
</code></pre>

<p>It uses the same salt as the encryptor. The password is the same and the number of bytes read are the same and from the correct location within the file. So, any ideas why this is the case?</p>

<p><strong>UPDATE 1:</strong></p>

<p>This code provides me the location where I will Insert into the previously created encrypted DEFT file a new piece of information.</p>

<pre><code>private long GenerateDEFT2LengthStartPosition()
        {
            if (DrivesLog != null) DrivesLog(""Generating DEFT2 Length Start Position"");
            return long.Parse((Properties.Settings.Default.PasswordOne.Length * Properties.Settings.Default.PasswordOne.Length).ToString());
        }
</code></pre>

<p>As long as I use the same password which it will as it is saved (for testing purposes) it will return the same location to insert the newly encrypted text. In this case it is always 100 returned.</p>

<p>However, in the Hex editor using Decimals for offsets it shows that the newly encrypted text is stored at offset 418.</p>

<p>Why would saving the text like this:</p>

<pre><code>long startPos = GenerateDEFT2LengthStartPosition();
            fs.Seek(startPos, SeekOrigin.Current);    // Seek to correct location                
            sw.Write(deft2NameLength);                                          
</code></pre>

<p>and loading it like this:</p>

<pre><code>long lenPos = GenerateDEFT2LengthStartPosition();
 char[] C = new char[32];
                fs.Seek(lenPos, SeekOrigin.Begin);
                sr.Read(C, 0, 32);
</code></pre>

<p>place me in a totally different position within the file?</p>

<blockquote>
  <p>So the Question: Why is using the same value 100 to write and read the
  encrypted text within a file putting the text in a different place to
  where it is being read from?</p>
</blockquote>
","","130","<c#><encryption><rijndael>","0","","0","2015-04-17 23:13:17","","7","","1473616","","2015-04-17 23:13:17","2015-04-17 22:02:42",""
"40888693","I have the following code for encryption and decryption. I manage to encrypt the string but can not decrypt it back","<p>Here the code for encryption</p>

<p>Did I code it correctly? or I need to make a change? I am using visual studio 2013 and framework 4.5.</p>

<pre><code>            cipherData = textBox_Plain_text.Text;
            plainbytes = Encoding.Unicode.GetBytes(cipherData);
            plainKey = Encoding.Unicode.GetBytes(""0123456789abcded"");
            desObj.Key = plainKey;
            desObj.Mode = CipherMode.CBC;
            desObj.Padding = PaddingMode.PKCS7;

            System.IO.MemoryStream ms = new System.IO.MemoryStream();
            CryptoStream cs = new CryptoStream(ms, desObj.CreateEncryptor(), CryptoStreamMode.Write);
            cs.Write(plainbytes, 0, plainbytes.Length);
            cs.Close();
            cipherbytes = ms.ToArray();
            ms.Close();
            textBox_Encrypted_text.Text = Encoding.ASCII.GetString(cipherbytes);
</code></pre>

<p>Here the code for decryption. After I try to decrypt it, only first letter show up</p>

<pre><code>  System.IO.MemoryStream ms1 = new System.IO.MemoryStream(cipherbytes);
  CryptoStream cs1 = new CryptoStream(ms1, desObj.CreateDecryptor(), CryptoStreamMode.Read);

            cs1.Read(cipherbytes, 0, cipherbytes.Length);
            plainbytes2 = ms1.ToArray();
            cs1.Close();
            ms1.Close();
            textBox_Decrypted_text.Text = Encoding.ASCII.GetString(plainbytes2);
</code></pre>

<p>Here the result</p>

<p><img src=""https://i.stack.imgur.com/xC2Xs.png"" alt=""enter image description here""></p>
","","124","<c#><rijndael>","1","","0","2016-11-30 15:31:19","","4","","472495","","2016-11-30 15:31:19","2016-11-30 12:42:57",""
"17652327","How to depend length of Rijndael function output from input length?","<p>I have  function: </p>

<pre><code>function aes_encrypt($value, $key) {
    return base64_encode(Security::rijndael($value, $key, 'encrypt'));
}
</code></pre>

<p><code>Security::rijndael</code> from cakephp Security component, which implement Rijndael  256-bit key encryption.</p>

<p>I've store encrypted data in database, so I need to know how to depend the length of output from input.</p>
","","121","<php><aes><rijndael>","0","","0","2013-07-16 04:45:57","","2","","956675","","2013-07-16 04:45:57","2013-07-15 10:42:10",""
"27119821","Mobile rijndael algorithm implementation","<p>I have a mobile application generated by <strong>codename one</strong>, so it is going to work on all mobiles.
Its a Client-Server application. I have to store credit card info and some other private info.
I think for Encryption <strong>Rijndael</strong> would be the best.
i have used <strong>MD5</strong> before but now a days i think it is old</p>

<p>I don't know how to do that any help..??
How can i Encrypt the information on mobile app it self and then send that to server ..??
Or is there any other Encryption method better than <strong>Rijndael</strong> ..??</p>
","<p>There are lots of algorithms that are sometime better than <strong>Rijndael</strong> and sometimes worst, it is up to your need to decide <a href=""http://en.wikipedia.org/wiki/List_of_algorithms#Cryptography"" rel=""nofollow"">what encryption</a>  you need. </p>

<p>By the way as you asked about how to encrypt you can see this <a href=""http://www.efgh.com/software/rijndael.htm"" rel=""nofollow"">link</a> about how to implement algorithm, and you can it implement it in almost every languages like this :</p>

<p><a href=""https://www.google.com/search?espv=2&amp;q=rijndael%20java%20implementation&amp;oq=rijndael%20java&amp;gs_l=serp.3.1.0i67l2j0i20j0i67j0i22i30l6.170145.171178.0.173145.5.5.0.0.0.0.599.969.3-1j0j1.2.0....0...1c.1.58.serp..3.2.968.FNscyehM3N0"" rel=""nofollow"">Java</a></p>

<p><a href=""https://www.google.com/search?espv=2&amp;biw=1920&amp;bih=979&amp;q=rijndael+implementation+objective+c&amp;oq=rijndael+implementation+objective+c&amp;gs_l=serp.3...576.3811.0.4051.12.10.0.0.0.0.553.1390.3-1j1j1.3.0....0...1c.1.58.serp..11.1.553.a-2eDUfq9jw"" rel=""nofollow"">Objective C</a></p>

<p><a href=""https://www.google.com/search?espv=2&amp;biw=1920&amp;bih=979&amp;q=rijndael%20implementation%20C%2B%2B&amp;oq=rijndael%20implementation%20C%2B%2B&amp;gs_l=serp.3...25743.26533.0.27116.3.3.0.0.0.0.390.390.3-1.1.0....0...1c.1.58.serp..2.1.389.CX37IMoz17w"" rel=""nofollow"">C++</a></p>

<p>And almost any language that you want.</p>
","120","<java><algorithm><encryption><codenameone><rijndael>","-1","0","3","2014-11-25 07:53:57","","0","","","","","2014-11-25 06:05:53",""
"27119821","Mobile rijndael algorithm implementation","<p>I have a mobile application generated by <strong>codename one</strong>, so it is going to work on all mobiles.
Its a Client-Server application. I have to store credit card info and some other private info.
I think for Encryption <strong>Rijndael</strong> would be the best.
i have used <strong>MD5</strong> before but now a days i think it is old</p>

<p>I don't know how to do that any help..??
How can i Encrypt the information on mobile app it self and then send that to server ..??
Or is there any other Encryption method better than <strong>Rijndael</strong> ..??</p>
","<p><code>MD5</code> is not an encryption method, it's a hash function. Rijndael (a.k.a. <code>AES</code>) is supported out of the box in Java, although there might be some restrictions on the key size.</p>

<p>As a side note, I'm a bit worried that you would be handling credit card information, with a lacking knowledge about security.</p>
","120","<java><algorithm><encryption><codenameone><rijndael>","-1","1","3","2014-11-25 07:53:57","","0","","","","","2014-11-25 06:05:53",""
"27119821","Mobile rijndael algorithm implementation","<p>I have a mobile application generated by <strong>codename one</strong>, so it is going to work on all mobiles.
Its a Client-Server application. I have to store credit card info and some other private info.
I think for Encryption <strong>Rijndael</strong> would be the best.
i have used <strong>MD5</strong> before but now a days i think it is old</p>

<p>I don't know how to do that any help..??
How can i Encrypt the information on mobile app it self and then send that to server ..??
Or is there any other Encryption method better than <strong>Rijndael</strong> ..??</p>
","<p>To user cryptographic algorithms in Codename One (hashing, encryption etc.) you can use the bouncy castle cn1lib: <a href=""http://www.codenameone.com/blog/bouncy-castle-crypto-api"" rel=""nofollow"">http://www.codenameone.com/blog/bouncy-castle-crypto-api</a></p>

<p>See the full list of 3rd party libraries for Codename One <a href=""http://www.codenameone.com/cn1libs.html"" rel=""nofollow"">here</a>. </p>
","120","<java><algorithm><encryption><codenameone><rijndael>","-1","0","3","2014-11-25 07:53:57","","0","","","","","2014-11-25 06:05:53",""
"7601809","Where is the proper location to embed IV information for file encryption using Rijndael algorithm?","<p>I'm creating a Rijndael file encryption application. I will using a unique IV for each file encryption. </p>

<p>My question: Where is the proper place to embed the IV info?</p>

<p>My initial thought is to append it at the end of the file's content. Is that a good choice? Any other better option for me?</p>
","<p>At the beginning of the file makes more sense (the reader will need it before reading the rest).</p>

<p>But yes, you can safey add it to the output. The IV (and maybe a Salt) is not a secret. </p>
","119","<.net><vb.net><winforms><rijndael>","3","2","1","2011-09-29 20:07:11","7602809","0","","","","","2011-09-29 18:33:40",""
"56714284","Golang encrypting data using AES","<p>I'm not sure if this is the right place to ask this. But I have no experience with C# and have been tasked to convert a security piece of code to Golang</p>

<p>I was wondering if i'm missing out on something here. </p>

<p>The C# code uses a <code>Rijndael</code> class to encrypt a bit of data. The <code>key</code> value and <code>iv</code> value is written out in the byte code like this</p>

<pre><code>   public static byte[] Key = new byte[]{0xx, 0xx, 0xx, 0xx, 0xx,
                    0xx4, 0xxx, 0xxx, 0xxx, 0xxx, xxx, 0xxx,
                    0xxx, 0xxx, 0xxx, 0xxx};
</code></pre>

<p><code>public static byte[] IV = new byte[] // save structure as above with 16 in length</code></p>

<p>then theres a bit of code which does this</p>

<pre><code>Rijndael alg = Rijndael.Create();
                alg.Key = Key;
                alg.IV = IV;
                CryptoStream cs = new CryptoStream(ms,
                alg.CreateEncryptor(), CryptoStreamMode.Write);
                cs.Write(dataWithoutHeader, 0, dataWithoutHeader.Length);
                cs.Close();
</code></pre>

<p>the function sends out <code>byte[] data</code> as output</p>

<p>I'm trying to mimic this is <code>golang</code> like this</p>

<pre><code>func StartEncryption(message []byte) []byte {
    var key = []byte {// same as C# } 

    var iv = []byte{ // same as C# }

    var err error
    fmt.Printf(""\n length of key %+v \n, \n length of iv \n %+v \n"", len(key), len(iv))
    // Encrypt
    encrypted := make([]byte, len(message))
    err = EncryptAESCFB(encrypted, []byte(message), key, iv)
    if err != nil {
        panic(err)
    }
    return encrypted
}
</code></pre>

<p>The Encryption function</p>

<pre><code>func EncryptAESCFB(dst, src, key, iv []byte) error {
    aesBlockEncrypter, err := aes.NewCipher([]byte(key))
    if err != nil {
        return err
    }
    aesEncrypter := cipher.NewCFBEncrypter(aesBlockEncrypter, iv)
    aesEncrypter.XORKeyStream(dst, src)
    return nil
}
</code></pre>

<p>The output of this is sent over an API whose output needs to be decrypted. I'm using this below</p>

<pre><code>func decryptMessage(message []byte)error{
    var key = []byte{ // same as C# }

    var iv = []byte{ // same as C#  }

    // Remove the head part of the response (45 bytes)
    responseBody := message[45:]

    decrypted := make([]byte, len(responseBody))

    err := DecryptAESCFB(decrypted, responseBody, key, iv)

    if err != nil {
        fmt.Printf(""\n error : \n %+v \n"", err)
    }
    return nil
}

func DecryptAESCFB(dst, src, key, iv []byte) error {
    aesBlockDecrypter, err := aes.NewCipher([]byte(key))
    if err != nil {
        return nil
    }
    aesDecrypter := cipher.NewCFBDecrypter(aesBlockDecrypter, iv)
    aesDecrypter.XORKeyStream(dst, src)
    return nil
}
</code></pre>

<p>The decryptor gives me gibberish - Am i going wrong somewhere?</p>

<p>My question boils down to 2 questions</p>

<ol>
<li><p>Would the C# function using the <code>rijndael</code> class and the golang functiony yield the same output or should i be doing something more/less</p></li>
<li><p>Is the byte array the right data to store the key, IV in - i.e its not the same used in C# when copied to GO</p></li>
</ol>
","<p>There's a few problems with the code you posted.</p>

<ol>
<li>Don't store the key in a byte array, because that means that you are hard-coding it. Instead generate a random 256-bit key, encode it to a hex string, then store that <em>outside</em> of your program and read it in using a config library like <a href=""https://github.com/spf13/viper"" rel=""nofollow noreferrer"">viper</a>.</li>
<li>Don't hard-code the IV. You should be generating a new IV for every single message. Reusing the same IV weakens your encryption significantly. For every message that you encrypt, generate a random IV and prepend it to the message. When you attempt to decrypt it, read the IV off of the first n bytes and then decrypt.</li>
<li>You should use authenticated encryption as a measure of protection against chosen ciphertext attacks. GCM mode provides authentication for you.</li>
</ol>

<p>Here is an example. <a href=""https://play.golang.org/p/U_0pk7on1FV"" rel=""nofollow noreferrer"">Playground Link</a></p>

<pre class=""lang-golang prettyprint-override""><code>package main

import (
    ""crypto/aes""
    ""crypto/cipher""
    ""crypto/rand""
    ""encoding/hex""
    ""fmt""
    ""os""
)

var (
    key       = randBytes(256 / 8)
    gcm       cipher.AEAD
    nonceSize int
)

// Initilze GCM for both encrypting and decrypting on program start.
func init() {
    block, err := aes.NewCipher(key)
    if err != nil {
        fmt.Printf(""Error reading key: %s\n"", err.Error())
        os.Exit(1)
    }

    fmt.Printf(""Key: %s\n"", hex.EncodeToString(key))

    gcm, err = cipher.NewGCM(block)
    if err != nil {
        fmt.Printf(""Error initializing AEAD: %s\n"", err.Error())
        os.Exit(1)
    }

    nonceSize = gcm.NonceSize()
}

func randBytes(length int) []byte {
    b := make([]byte, length)
    rand.Read(b)
    return b
}

func encrypt(plaintext []byte) (ciphertext []byte) {
    nonce := randBytes(nonceSize)
    c := gcm.Seal(nil, nonce, plaintext, nil)
    return append(nonce, c...)
}

func decrypt(ciphertext []byte) (plaintext []byte, err error) {
    if len(ciphertext) &lt; nonceSize {
        return nil, fmt.Errorf(""Ciphertext too short."")
    }
    nonce := ciphertext[0:nonceSize]
    msg := ciphertext[nonceSize:]
    return gcm.Open(nil, nonce, msg, nil)
}

func main() {
    fmt.Println(""Encrypting..."")
    msg := []byte(""The quick brown fox jumped over the lazy dog."")
    ciphertext := encrypt(msg)
    fmt.Printf(""Encrypted message: %v\n"", ciphertext)

    fmt.Println(""Decrypting..."")
    plaintext, err := decrypt(ciphertext)
    if err != nil {
        // Don't display this message to the end-user, as it could potentially
        // give an attacker useful information. Just tell them something like ""Failed to decrypt.""
        fmt.Printf(""Error decryping message: %s\n"", err.Error())
        os.Exit(1)
    }
    fmt.Printf(""Decrypted message: %s\n"", string(plaintext))
}
</code></pre>
","116","<c#><go><aes><rijndael>","0","1","1","2019-07-06 21:21:11","56826199","5","","4763988","","2019-06-22 09:55:37","2019-06-22 09:29:04",""
"15938993","Is it safe to trim a decrypted string?","<p>I am encrypting and decrypting a string using:</p>

<pre><code>$key = 'my key';
$data = 'my string';
$ivSize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($ivSize, MCRYPT_DEV_URANDOM);
$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $data, MCRYPT_MODE_CBC, $iv);
$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $encrypted, MCRYPT_MODE_CBC, $iv);
$data = trim($decrypted, chr(0));
</code></pre>

<p><a href=""http://codepad.viper-7.com/1JgCRs"" rel=""nofollow"">http://codepad.viper-7.com/1JgCRs</a></p>

<p>Is it safe to just trim off the padding added by the encryption algorithm, or is it necessary to store the length of the data before encrypting? </p>
","<p>Padding is added on the right normally, so consider <code>rtrim()</code>:</p>

<pre><code>$data = rtrim($decrypted, chr(0));
</code></pre>

<p>However this is still not yet perfectly safe because in PHP strings can contain NUL-bytes. If for some reason the plain did had NUL-bytes at the end, the <code>rtrim</code> will remove the padding <em>and</em> those previous NUL-bytes.</p>
","116","<php><encryption><aes><rijndael><cbc-mode>","1","1","2","2013-04-11 05:53:19","15939071","2","","","","","2013-04-11 00:46:39",""
"15938993","Is it safe to trim a decrypted string?","<p>I am encrypting and decrypting a string using:</p>

<pre><code>$key = 'my key';
$data = 'my string';
$ivSize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($ivSize, MCRYPT_DEV_URANDOM);
$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $data, MCRYPT_MODE_CBC, $iv);
$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $encrypted, MCRYPT_MODE_CBC, $iv);
$data = trim($decrypted, chr(0));
</code></pre>

<p><a href=""http://codepad.viper-7.com/1JgCRs"" rel=""nofollow"">http://codepad.viper-7.com/1JgCRs</a></p>

<p>Is it safe to just trim off the padding added by the encryption algorithm, or is it necessary to store the length of the data before encrypting? </p>
","<p>You are trimming the value after you decrypt so you won't run into ay issues with the current code.</p>

<p>If you try to re-encrypt the different, trimmed data, you will get a different encrypted value.</p>
","116","<php><encryption><aes><rijndael><cbc-mode>","1","2","2","2013-04-11 05:53:19","15939071","2","","","","","2013-04-11 00:46:39",""
"49594553","Combining Symmetric and Asymmetric Encryption with Serializeable Object (.NET Basic)","<p>Wanna ask about my licensing algorithm, I create some code for encrypt a serialize object with symmetric key (Rijndael) and then encrypt the symmetric key with asymmetric key (RSA). Data is encrypt with Public-APP key but sign with Private-LS key. Then put RSA-encrypted key, RSA-encrypted IV, Rijndael-encrypted data, and signdata into an serialize object, serialize it and put to file. But when I load the data to verified it, it always failed to verified data (using verifydata). When I skip the verifying step to deserializing step, it always throw exception </p>

<blockquote>
  <p>System.Runtime.Serialization.SerializationException: 'End of Stream encountered before parsing was completed.'</p>
</blockquote>

<p>this is code for creating file</p>

<pre><code>Private Sub Button3_Click(sender As Object, e As EventArgs) Handles Button3.Click

    varLicense = New LicenseInfo With {
        ..LICENSE INFO..
    }

    sfd.ShowDialog()
    Dim FilePath As String = sfd.FileName

    'Convert License to Byte
    Dim ms As New MemoryStream
    Dim bf As New BinaryFormatter()
    bf.Serialize(ms, varLicense)
    Dim byteLicense As Byte() = ms.ToArray
    ms.Close()

    'Generate random symetricKey
    Dim validPassChar As String = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;*()-+=""
    Dim res As New StringBuilder()
    Dim rnd As New Random()
    Dim lPass As Integer = 50
    While (0 &lt; lPass)
        res.Append(validPassChar(rnd.Next(validPassChar.Length)))
        lPass = lPass - 1
    End While

    'Generate key
    Dim rmEnc As New RijndaelManaged()
    rmEnc.BlockSize = 256
    Dim pwdGen As New Rfc2898DeriveBytes(res.ToString, 1993)
    Dim key As Byte() = pwdGen.GetBytes(rmEnc.KeySize / 8)
    Dim IV As Byte() = pwdGen.GetBytes(rmEnc.BlockSize / 8)

    'Encrypt Data License with Symetric Key
    Dim varDataEnc As Byte() = symEncrypt(key, IV, byteLicense)

    'Encrypt Symetric Key with RSA Public APP Key
    Dim RSA = New RSACryptoServiceProvider()
    RSA.FromXmlString(Project1.My.Resources.public_key_APP)
    Dim keyCipher = RSA.Encrypt(key, True)
    Dim ivCipher = RSA.Encrypt(IV, True)

    'sign the hash with RSA Private LS Key
    RSA = New RSACryptoServiceProvider()
    RSA.FromXmlString(Project1.My.Resources.private_key_LS)
    Dim hash = RSA.SignData(byteLicense, New SHA512CryptoServiceProvider)


    'initialize final license
    Dim fnLicense As New FinalLicense
    fnLicense.secret_key = keyCipher
    fnLicense.secret_IV = ivCipher
    fnLicense.data = varDataEnc
    fnLicense.hash_sign = hash

    'save license to file
    Dim fs As New FileStream(FilePath, FileMode.OpenOrCreate)
    bf.Serialize(fs, fnLicense)
    fs.Close()


    MsgBox(""License Created!"", vbOKOnly)

End Sub
</code></pre>

<p>This is for reading file</p>

<pre><code>Public Function LoadLicense() As Boolean

    Dim fs As New FileStream(ofd.FileName, FileMode.Open)
    Dim bf As New BinaryFormatter()
    Dim fnlLicense As FinalLicense = bf.Deserialize(fs)
    fs.Close()

    'Decrypt Symetric Key with RSA
    Dim RSA = New RSACryptoServiceProvider()
    RSA.FromXmlString(Project1.My.Resources.private_key_APP)
    Dim symKey = RSA.Decrypt(fnlLicense.secret_key, True)
    Dim symIV = RSA.Decrypt(fnlLicense.secret_IV, True)


    'Decrypt data with sym key
    Dim data As Byte() = symDecrypt(symKey, symIV, fnlLicense.data)

    'SIGNATURE CHECK
    Dim RSAX = New RSACryptoServiceProvider()
    RSAX.FromXmlString(Project1.My.Resources.public_key_LS)
    If (RSAX.VerifyData(data, New SHA512CryptoServiceProvider, fnlLicense.hash_sign)) Then
        'decapsulation
        'tried jump here but throw 
        'System.Runtime.Serialization.SerializationException: 'End of Stream encountered before parsing was completed.'
        Dim ms As New MemoryStream(data)
        ms.Position = 0
        Dim varLicense As LicenseInfo = bf.Deserialize(ms)
        ms.Close()

        Me.LICENSE_INFO = varLicense
        Return True
    Else
        Return False
    End If

End Function
</code></pre>

<p>and this is what i use for symmetric encryption</p>

<pre><code>Public Function symEncrypt(key As Byte(), IV As Byte(), data As Byte()) As Byte()

    Dim rmEnc As New RijndaelManaged()

    rmEnc.BlockSize = 256

    rmEnc.Key = key
    rmEnc.IV = IV

    Dim ms As New MemoryStream
    Dim cs As New CryptoStream(ms, rmEnc.CreateEncryptor, CryptoStreamMode.Write)
    Dim output As Byte()

    cs.Write(data, 0, data.Length)
    output = ms.ToArray

    ms.Close()

    Return output
End Function

Private Function symDecrypt(key As Byte(), iv As Byte(), data As Byte()) As Byte()
    Dim rmEnc As New RijndaelManaged()

    rmEnc.BlockSize = 256
    rmEnc.Key = key
    rmEnc.IV = iv

    Dim ms As New MemoryStream
    Dim cs As New CryptoStream(ms, rmEnc.CreateDecryptor, CryptoStreamMode.Write)
    Dim output As Byte()

    cs.Write(data, 0, data.Length)
    output = ms.ToArray

    ms.Close()

    Return output
End Function
</code></pre>
","<p>Just solved it, I change how I encrypt and decrypt (symetric) by using AES and then adding .FlushFinalBlock after getting the data from stream. And for signature, rather than using  .signdata, I use SignHash.</p>
","114","<.net><vb.net><encryption><rsa><rijndael>","-1","0","1","2018-04-09 12:24:51","49630924","4","","1033581","","2018-04-09 12:24:51","2018-04-01 03:34:33",""
"19418896","Matching RijndaelManaged encryption from CSharp in php","<p>I know this question has been asked many times before, but I think my situation is unique, I have had many people attempt to help me from IRC already and still have no solution. Basically I am trying to match the encryption function from a .NET CS program <a href=""http://codepad.org/4SmP1Oek"" rel=""nofollow"">http://codepad.org/4SmP1Oek</a> , in a PHP script. So far I have come up with <a href=""http://codepad.viper-7.com/JsYFPK"" rel=""nofollow"">http://codepad.viper-7.com/JsYFPK</a> .</p>

<p>I have tried various different padding options, including not adding padding(leaving it to default) and yet every time I get a different value that does NOT match the C# output.</p>

<p>For example,</p>

<pre><code>csharp: gLbzWiVmpmDrmzfZgRaM9w==

php: vid7cv20FZ68tbkNLHv3RQ==

php with no padding added: Z+ELd8MNs2frjTBUiWYj5w==
</code></pre>

<p>As you can see in the csharp class the encryption values are left to default, and I am fairly certain that is CBC, with 32 byte key, 16 byte iv, and 16 byte input.</p>

<p>UPDATE: I have recreated the C# program and successfully gotten the same output, So I have tried changing the key to multiple different strings in the php and the cs to 16 and 32 bytes but with no luck, same problem. The code is the same as I linked above and the text is sent to the Encrypt function with no modification first, so I am starting to doubt it is a padding issue now.</p>

<p>UPDATE #2: I have figured out the issue, it turns out it IS because the csharp program is using a 9 byte key, however I must find out why it still works so I can match the padding in php, if I set the key to something 16 bytes in both cs and php it works fine.</p>
","<p>I found the problem(not the solution), it seems that in .net short keys are expanded in a weird way when using CreateEncryptor, causing this problem.</p>
","113","<c#><php><encryption><rijndael>","0","0","1","2013-10-17 22:08:39","","2","","2839464","","2013-10-17 19:31:07","2013-10-17 05:27:56",""
"54294938","Trying to Decrypt 256 blocksize string using BouncyCastle in .net core. Getting Invalid pad Count Error","<p>I'm trying to decrypt a 256 block size string using Bouncycastle in .net core which is encrypted in .net framework using Rijndael.</p>

<p>I followed <a href=""https://github.com/dotnet/corefx/issues/12064"" rel=""nofollow noreferrer"">https://github.com/dotnet/corefx/issues/12064</a> code to decrypt.</p>

<p>Encryption code</p>

<pre><code>public string Encrypt(string clearText, string key)
{
   var salt = GetRandomBytes(16);
   var plainTextBytes = Encoding.UTF8.GetBytes(clearText);

  using (var rijAlg = InitRijndael(key, salt))
  {
  using (var memoryStream = new MemoryStream())
  {
   using (var cryptoStream = new CryptoStream(memoryStream, rijAlg.CreateEncryptor(), CryptoStreamMode.Write))
   {

          cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
   }

              return Convert.ToBase64String(salt) + "":"" +                      
              Convert.ToBase64String(rijAlg.IV) + "":"" +
              Convert.ToBase64String(memoryStream.ToArray()) + 
              "":"" + HashPassword(clearText, salt, 11);
      }
 }
}   

private static Rijndael InitRijndael(string key, byte[] salt, byte[] iv = null)
    {
        //var salt = new byte[] { 226, 201, 66, 187, 1, 7, 255, 149, 161, 67 };
        var algorithm = Rijndael.Create();
        if (iv != null)
        {
                            //Decryption
            algorithm.BlockSize = iv.Length * 8;
            algorithm.IV = iv;
        }
        else
        {
                            //Encryption
            algorithm.BlockSize = 256; // 256-bit blocks
            algorithm.GenerateIV();
        }

        try
        {
            using (var rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, salt))
            {
                algorithm.Key = rfc2898DeriveBytes.GetBytes(32); // 256-bit

            }
        }
        catch
        {
            algorithm.Dispose();
            throw;
        }

        return algorithm;
    }
</code></pre>

<p>Decryption Code trying decrypt in .net core:</p>

<pre><code>public string Decrypt(string cipherText, string Key)
    {

        var tokens = cipherText.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);
        if (tokens.Length != 4)
        {
            throw new ArgumentException(""Invalid Cipher Text"", ""cipherText"");
        }

        var salt = Convert.FromBase64String(tokens[0]);
        var iv = Convert.FromBase64String(tokens[1]);
        var bytes = Convert.FromBase64String(tokens[2]);
        var bytesHash = tokens[3];

        using (var password = new Rfc2898DeriveBytes(Key, salt))
        {
            var keyBytes = password.GetBytes(Keysize / 8);
            var engine = new RijndaelEngine(256);
            var blockCipher = new CbcBlockCipher(engine);
            var cipher = new PaddedBufferedBlockCipher(blockCipher, new Pkcs7Padding());
            var keyParam = new KeyParameter(keyBytes);
            var keyParamWithIV = new ParametersWithIV(keyParam, iv, 0, 32);

            cipher.Init(false, keyParamWithIV);
            var comparisonBytes = new byte[cipher.GetOutputSize(bytes.Length)];
            var length = cipher.ProcessBytes(bytes, comparisonBytes, 0);
            var finalBytes = cipher.DoFinal(comparisonBytes, 0, length);
            var final = Encoding.UTF8.GetString(finalBytes);
        }
}
</code></pre>

<p>I'm getting invalid PadCount error at when executing code chipper.DoFinal.</p>
","","112","<encryption><.net-core><bouncycastle><rijndael><rijndaelmanaged>","0","","0","2019-01-21 17:21:17","","0","","","","","2019-01-21 17:21:17",""
"42933755","Convert PHP Encryption algorithm to C#","<p>I am trying to use a SSO solution in C#, where the documentation is only available in PHP.</p>

<p>I have this PHP Code:</p>

<pre><code>function encrypt ($message)
{
    $initialVector = ""1234567890123456"";

    $key = md5($this-&gt;apiPassword);
    $crypt = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $message, MCRYPT_MODE_CFB, $initialVector);

    return base64_encode($initialVector) ."":"" . base64_encode($crypt);
}
</code></pre>

<p>The C# Code I tried is the following:</p>

<pre><code>private string encrypt(string message)
{
  RijndaelManaged aes128 = new RijndaelManaged();
  aes128.BlockSize = 128;
  aes128.KeySize = 128;
  aes128.Mode = CipherMode.CFB;
  aes128.Padding = PaddingMode.None;
  aes128.IV = Encoding.ASCII.GetBytes(""1234567890123456"");
  aes128.Key = Encoding.ASCII.GetBytes(getMd5(key));

  byte[] plainTextBytes = Encoding.ASCII.GetBytes(json);

  ICryptoTransform encryptor = aes128.CreateEncryptor();
  MemoryStream ms = new MemoryStream();

  CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write);
  cs.Write(plainTextBytes, 0, plainTextBytes.Length);

  // convert our encrypted data from a memory stream into a byte array.
  byte[] cypherTextBytes = ms.ToArray();

  // close memory stream
  ms.Close();

  return Convert.ToBase64String(aes128.IV) + "":"" + Convert.ToBase64String(cypherTextBytes);
}
</code></pre>

<p><code>key</code> and <code>message</code> are identical. The IV part is returned correctly, only the encrypted parts are not equal. The md5 method is also working correctly.</p>

<p><strong>Edit:</strong> Changing the Padding also doesn't change anything.</p>
","","111","<c#><encryption><mcrypt><rijndael><rijndaelmanaged>","0","","0","2017-03-21 17:11:31","","2","","1085563","","2017-03-21 17:11:31","2017-03-21 17:04:08",""
"40885863","Decrypt Rijndael with Passphrase in PHP","<p>A customer is sending us a file encrypted with ""AES-256"". It arrives as a binary file (I normally get base64-encoded files, but this should be OK) and, in desperation, I have iterated through the PHP options using mcrypt_decrypt but cannot crack it. </p>

<pre><code>&lt;?php
$str = file_get_contents($argv[1]);
$key ='jimminny fred owns apple'; //not the actual one, but same length

$modes = array(
    MCRYPT_MODE_ECB,
    MCRYPT_MODE_CBC,
    MCRYPT_MODE_CFB,
    MCRYPT_MODE_OFB,
    MCRYPT_MODE_NOFB);

$cryps = array(
    MCRYPT_RIJNDAEL_128,
    MCRYPT_RIJNDAEL_256,
    MCRYPT_RIJNDAEL_192);

foreach($modes as $mode){
    foreach($cryps as $cryp){
        echo ""\n\n$cryp $mode\n\n"";
        echo mcrypt_decrypt($cryp, $key, $str, $mode);
    }
}
</code></pre>

<p>My understanding is that I should be receiving a 32-byte key, not a 24 char passphrase, but they are using a program called GlobalScape  and this is all it requires for its 'Rijndael' encryption. (See screenshot attached showing the dialog window that the customer completes at their end).<a href=""https://i.stack.imgur.com/pPCcQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pPCcQ.png"" alt=""enter image description here""></a></p>
","<p>I've checked the site and GlobalScape doesn't offer any details on how they encrypt. Not only do they not specify the <em>key derivation function (KDF)</em> that they use for ""Rijndael"" encryption. It's unlikely that they directly use the passphrase as a key - unless they are complete muppets - but the KDF could be anything. They do not specify the mode of operation for AES either</p>

<p>Simply do not use trash like that. Just use PGP or one of the standardized options for sending / receiving messages.</p>

<p>Going on a wild goose chase won't help you. Even if you program a solution then it may fail in the future because of any number of factors. Ask your client to clearly specify <em>a protocol</em> instead of giving you a screenshot.</p>
","110","<php><aes><rijndael>","0","0","1","2016-12-06 12:10:12","","1","","","","","2016-11-30 10:24:11",""
"46271106","Encryption Crypt - PHP and Perl mismatch for CFB Rijndael","<p>I'm trying to write perl code that matches the following php code snippet:</p>

<pre><code>&lt;?php

$key = 'dd7b47ad2d87b93013a89878fef3f6c5';
$str = 'Hello this is my sensative text string for testing';
$iv = '1234123412341234';

$ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $str, MCRYPT_MODE_CFB, $iv);
list(,$ciphertext_h) = unpack('H*', $ciphertext );
echo $ciphertext_h . ""\n"";

?&gt;
</code></pre>

<p>When I run this code I get the following cipher string:</p>

<blockquote>
  <p>67a15d847220b5417263724032e8981366fb92ae73db1a88edf16da54fe81ac056a2a4c7f9e1f335467d7bf16d6bafe49341</p>
</blockquote>

<p>I've tried using a half dozen different Perl Modules including Crypt::CFB, Crypt::GCrypt, and Crypt::Rijndael.  I'm sure the mismatch is happening because the options are not the same.  I'm struggling trying to set the options correctly.  What I've tried is this:</p>

<pre><code>use Crypt::CFB;

my $key = 'dd7b47ad2d87b93013a89878fef3f6c5';
my $iv = ""1234123412341234"";
my $str = ""Hello this is my sensative text string for testing"";

my $cipher = Crypt::CFB-&gt;new($key, 'Crypt::Rijndael', $iv);
my $cipherStr = $cipher-&gt;encrypt($str);
print(unpack( 'H*', $cipherStr ) . ""\n"" );
</code></pre>

<p>Which produces the following cipher text:</p>

<blockquote>
  <p>af129a803585990d2887307361d8ce451ec4fce94fb031b15e570d2ee818ab34b030189676171e7dd5fa74a517470fae08eb</p>
</blockquote>

<p>I can't seem to change any of the Crypt::CFB options.  When I try, I get instantiation errors...</p>

<p>I also gave Crypt::Rijndael a try:</p>

<pre><code>use Crypt::Rijndael;

my $key = 'dd7b47ad2d87b93013a89878fef3f6c5';
my $iv = ""1234123412341234"";
my $str = ""Hello this is my sensative text string for testing"";

# pad the $str to a multiple of 16 bytes:
if (my $distance = length($str) % 16) {
   $str .= ""\0"" x (16 - $distance);
}

my $crypt = Crypt::Rijndael-&gt;new($key, Crypt::Rijndael::MODE_CFB);
$crypt-&gt;set_iv($iv);
my $binary = $crypt-&gt;encrypt($str);
print(  unpack( 'H*', $binary ) . ""\n"" );
</code></pre>

<p>Which produces the following cipher text:</p>

<blockquote>
  <p>6746b5e4bdde2888f0b2da506176669e846c11a94ca425b4f8b92363030fac374cb9dd7d3a68a740d284530c025d17c0de06ff96563b40cda5deea0324d754a9</p>
</blockquote>

<p>The cipher text is longer because I had to pad the data.  I got an error if the data was not padded.  There is still no match with the PHP code.  I think I'm closer, but just missing something.  Does anyone have any ideas.  I sure would appreciate it!</p>
","","108","<php><perl><crypt><rijndael><cfb-mode>","0","","0","2017-09-18 04:43:12","","6","","589924","","2017-09-18 04:43:12","2017-09-18 03:15:24",""
"17000768","AES Cookie Data randomly not decryptable","<p>I'm having a problem when writing and parsing some DATA out of stored cookies.</p>

<p>Here are my crypt and decrypt functions (which I have found in another topic here).</p>

<pre><code>function decrypt($crypttext){   
        $crypttext = base64_decode($crypttext);
        $plaintext = '';
        $td        = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
        $ivsize    = mcrypt_enc_get_iv_size($td);
        $iv        = substr($crypttext, 0, $ivsize);
        $crypttext = substr($crypttext, $ivsize);
        if ($iv)
        {
            mcrypt_generic_init($td, CRYPTKEY, $iv);
            $plaintext = mdecrypt_generic($td, $crypttext);
        }
        return trim($plaintext);
}

function encrypt($plaintext){
        $td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
        $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
        mcrypt_generic_init($td, CRYPTKEY, $iv);
        $crypttext = mcrypt_generic($td, $plaintext);
        mcrypt_generic_deinit($td);
        return base64_encode($iv.$crypttext);
} 
</code></pre>

<p>My usage is fairly simple:</p>

<pre><code>//read, split if neccesarry, check if already in it, if not-&gt; add, crypt, write
if(isset($_COOKIE['DATA'])){

    $data = decrypt($_COOKIE['DATA']);

    $search = explode('#',$data);
    if(!in_array($lnk, $search)){
        $data.= ""#"".$lnk; // $lnk = additional data
        $err = setrawcookie(""DATA"", encrypt($data));
    }
    $err = true;
}
</code></pre>

<p>In most tries, it doesn't work adding a <code>$lnk</code>. The decryption of the cookie after I've wrote it, is wrong. undefined junk. (so something doesn't work well). </p>

<p>I haven't been able to find any errors in the code at all. My best guess is that the problem is caused by :</p>

<pre><code>  $ivsize    = mcrypt_enc_get_iv_size($td);
  $iv        = substr($crypttext, 0, $ivsize);
</code></pre>

<p>Specifically, that <code>$ciphertext</code> is smaller than <code>$ivsize</code>? </p>

<p>Any other ideas?</p>

<p>// to prevent questions about it:
the data which i store, are just php uniqueID()'s separeted by '#'. so maybe in future there will be 10 IDs stored (encrypted) in the cookie...i didin't know the max size of a cookie and the factor AES blow this up, but i thought a cookie should get it.</p>

<p>(if there is a easier synchronus way to encrypt (this should not be high security, but mostly safe) please feel free to tell me.</p>
","<p>Try using <code>bin2hex</code> instead of <code>base64_encode()</code>. I <a href=""https://stackoverflow.com/a/173764/17404"">previously answered</a> a similar question on SO.</p>
","106","<php><cookies><aes><rijndael>","0","0","1","2013-06-08 15:17:38","17000927","3","","1425696","","2013-06-08 15:14:17","2013-06-08 14:59:15",""
"36997738","Rijndeal algorithm decrypt data missing some character in c#","<p>I am using a Rijndeal algorithm to encrypt and decrypt a string value. This method works fine in most of the cases, but in same cases on one machine I'm missing characters after decryption.</p>

<p>Here is my sample code </p>

<pre><code>public static string Decrypt(string cipherText)
{
    try
    {                   


        string incoming = cipherText.Replace('_', '/').Replace('-', '+');
        switch (cipherText.Length % 4)
        {
            case 2: incoming += ""==""; break;
            case 3: incoming += ""=""; break;
        }
        byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
        byte[] cipherTextBytes = Convert.FromBase64String(incoming);
        PasswordDeriveBytes password = new PasswordDeriveBytes(passPhrase, null);
        byte[] keyBytes = password.GetBytes(keysize / 8);
        RijndaelManaged symmetricKey = new RijndaelManaged();
        symmetricKey.Mode = CipherMode.CBC;
        ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);
        MemoryStream memoryStream = new MemoryStream(cipherTextBytes);
        CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
        byte[] plainTextBytes = new byte[cipherTextBytes.Length];
        int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
        memoryStream.Close();
        cryptoStream.Close();
        return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
    }
    catch (Exception ex)
    {                  

          return ""Exception"";
    }
}
</code></pre>
","","103","<c#><rijndael>","0","","0","2016-05-03 08:13:35","","3","","3214843","","2016-05-03 08:13:35","2016-05-03 07:02:39",""
"48416064","PHP implementation of CCRYPT","<p>Under linux systems we have <strong>ccrypt</strong> console utility, which <strong>encypt / decrypt</strong> file with some key.</p>

<pre><code>ccrypt -e -K 'somekey' somefile // encrypt
ccrypt -d -K 'somekey' somefile // decrypt
</code></pre>

<p>I need PHP <strong>openssl_encrypt / openssl_decrypt</strong> imlemenatation of this.</p>

<p>On <a href=""http://ccrypt.sourceforge.net/ccrypt.html"" rel=""nofollow noreferrer"">CCRYPT man page</a> it said, that ccrypt implements a stream cipher by operating the <strong>Rijndael</strong> block cipher in <strong>CFB</strong> mode and has a block length of 32 bytes or <strong>256</strong> bits.</p>

<p>I was tried the following:</p>

<pre><code>$encrypted = file_get_contents('somefile');
$decrypted = openssl_decrypt($encrypted , 'AES-256-CFB', 'somekey', OPENSSL_RAW_DATA);
</code></pre>

<p>But PHP decryption result is not equal to CCRYPT decryption result.</p>

<p>I know it's posible, but i'm stumped. Please help me.</p>
","","103","<php><encryption><aes><rijndael>","0","","0","2018-01-24 06:25:29","","2","","","","","2018-01-24 06:25:29",""
"42508963","C# Rijndael Decryption doesn't work with jpgs","<p>When I tried to encrypt and decrypt a simple string, everything went perfectly fine.. </p>

<p>But when I encoded a jpg into a bytearray and did the exact same thing with that bytearray, the decryption didn't work anymore (the bytearray is completely different to the original one and cannot be displayed anymore)...</p>

<p>Is it because the bytearray is too big?</p>

<p>Or does someone have a solution for my problem?</p>

<pre><code>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace Encrypter2
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {

                Console.WriteLine();
                // Create a new instance of the Rijndael
                // class.  This generates a new key and initialization 
                // vector (IV).
                byte[] originalFile = File.ReadAllBytes(@""C:/Users/Elron/Documents/Visual Studio 2015/Projects/FileEncrypt/FileEncrypt/bin/Debug/harambe.jpg"");
                using (Rijndael myRijndael = Rijndael.Create())
                {
                //     Encrypt the string to an array of bytes
                //    Encrypted byte[]
                byte[] encrypted = EncryptStringToBytes(originalFile, myRijndael.Key, myRijndael.IV);
                    using (FileStream fs = File.Create(@""C:/Users/Elron/Documents/Visual Studio 2015/Projects/FileEncrypt/FileEncrypt/bin/Debug/harambeEncrypted.jpg""))
                    {
                        //Add some information to the file.
                        fs.Write(encrypted, 0, encrypted.Length);
                    }
                //     Decrypted byte[]
                byte[] roundtrip = DecryptStringFromBytes(encrypted, myRijndael.Key, myRijndael.IV);
                    using (FileStream fs = File.Create(@""C:/Users/Elron/Documents/Visual Studio 2015/Projects/FileEncrypt/FileEncrypt/bin/Debug/harambeDecrypted.jpg""))
                    {
                        //Add some information to the file.
                        fs.Write(roundtrip, 0, roundtrip.Length);
                    }
                //    Display the original data and the decrypted data.
                //    Encrypted string
                    Console.ReadKey();
            }

            }
            catch (Exception e)
            {
                Console.WriteLine(""Error: {0}"", e.Message);
            }
        }

        static byte[] EncryptStringToBytes(byte[] plainText, byte[] Key, byte[] IV)
        {
            // Check arguments.
            if (plainText == null || plainText.Length &lt;= 0)
                throw new ArgumentNullException(""plainText"");
            if (Key == null || Key.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length &lt;= 0)
                throw new ArgumentNullException(""IV"");
            byte[] encrypted;
            // Create an Rijndael object
            // with the specified key and IV.
            using (Rijndael rijAlg = Rijndael.Create())
            {
                rijAlg.Key = Key;
                rijAlg.IV = IV;

                // Create an encryptor to perform the stream transform.
                ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

                // Create the streams used for encryption.
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {

                            //Write all data to the stream.
                            string toEncrypt = Encoding.Default.GetString(plainText);
                            swEncrypt.Write(toEncrypt);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }
            }


            // Return the encrypted bytes from the memory stream.
            return encrypted;

        }

        static byte[] DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV)
        {
            // Check arguments.
            if (cipherText == null || cipherText.Length &lt;= 0)
                throw new ArgumentNullException(""cipherText"");
            if (Key == null || Key.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length &lt;= 0)
                throw new ArgumentNullException(""IV"");

            // Declare the string used to hold
            // the decrypted text.
            string plaintext = null;
            byte[] returnText;

            // Create an Rijndael object
            // with the specified key and IV.
            using (Rijndael rijAlg = Rijndael.Create())
            {
                rijAlg.Key = Key;
                rijAlg.IV = IV;

                // Create a decryptor to perform the stream transform.
                ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

                // Create the streams used for decryption.
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {
                            // Read the decrypted bytes from the decrypting stream
                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();


                            ASCIIEncoding asc = new ASCIIEncoding();
                            returnText = asc.GetBytes(plaintext);
                        }
                    }
                }
            }
            return returnText;
        }
    }
}
</code></pre>
","<p>I think you are using different Encodings in your encryption and decryption methods</p>

<pre><code>static byte[] DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV)
{
    ...
    ASCIIEncoding asc = new ASCIIEncoding();
    returnText = asc.GetBytes(plaintext);
    ...
}
</code></pre>

<p>And</p>

<pre><code>   static byte[] EncryptStringToBytes(byte[] plainText, byte[] Key, byte[] IV)
    {
        ...
        string toEncrypt = Encoding.Default.GetString(plainText);
        swEncrypt.Write(toEncrypt);
        ...
    }
</code></pre>
","102","<c#-4.0><encryption><jpeg><rijndael>","0","0","2","2017-03-01 02:58:48","42509077","2","0","5541055","","2017-02-28 17:25:17","2017-02-28 12:37:19",""
"42508963","C# Rijndael Decryption doesn't work with jpgs","<p>When I tried to encrypt and decrypt a simple string, everything went perfectly fine.. </p>

<p>But when I encoded a jpg into a bytearray and did the exact same thing with that bytearray, the decryption didn't work anymore (the bytearray is completely different to the original one and cannot be displayed anymore)...</p>

<p>Is it because the bytearray is too big?</p>

<p>Or does someone have a solution for my problem?</p>

<pre><code>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace Encrypter2
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {

                Console.WriteLine();
                // Create a new instance of the Rijndael
                // class.  This generates a new key and initialization 
                // vector (IV).
                byte[] originalFile = File.ReadAllBytes(@""C:/Users/Elron/Documents/Visual Studio 2015/Projects/FileEncrypt/FileEncrypt/bin/Debug/harambe.jpg"");
                using (Rijndael myRijndael = Rijndael.Create())
                {
                //     Encrypt the string to an array of bytes
                //    Encrypted byte[]
                byte[] encrypted = EncryptStringToBytes(originalFile, myRijndael.Key, myRijndael.IV);
                    using (FileStream fs = File.Create(@""C:/Users/Elron/Documents/Visual Studio 2015/Projects/FileEncrypt/FileEncrypt/bin/Debug/harambeEncrypted.jpg""))
                    {
                        //Add some information to the file.
                        fs.Write(encrypted, 0, encrypted.Length);
                    }
                //     Decrypted byte[]
                byte[] roundtrip = DecryptStringFromBytes(encrypted, myRijndael.Key, myRijndael.IV);
                    using (FileStream fs = File.Create(@""C:/Users/Elron/Documents/Visual Studio 2015/Projects/FileEncrypt/FileEncrypt/bin/Debug/harambeDecrypted.jpg""))
                    {
                        //Add some information to the file.
                        fs.Write(roundtrip, 0, roundtrip.Length);
                    }
                //    Display the original data and the decrypted data.
                //    Encrypted string
                    Console.ReadKey();
            }

            }
            catch (Exception e)
            {
                Console.WriteLine(""Error: {0}"", e.Message);
            }
        }

        static byte[] EncryptStringToBytes(byte[] plainText, byte[] Key, byte[] IV)
        {
            // Check arguments.
            if (plainText == null || plainText.Length &lt;= 0)
                throw new ArgumentNullException(""plainText"");
            if (Key == null || Key.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length &lt;= 0)
                throw new ArgumentNullException(""IV"");
            byte[] encrypted;
            // Create an Rijndael object
            // with the specified key and IV.
            using (Rijndael rijAlg = Rijndael.Create())
            {
                rijAlg.Key = Key;
                rijAlg.IV = IV;

                // Create an encryptor to perform the stream transform.
                ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

                // Create the streams used for encryption.
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {

                            //Write all data to the stream.
                            string toEncrypt = Encoding.Default.GetString(plainText);
                            swEncrypt.Write(toEncrypt);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }
            }


            // Return the encrypted bytes from the memory stream.
            return encrypted;

        }

        static byte[] DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV)
        {
            // Check arguments.
            if (cipherText == null || cipherText.Length &lt;= 0)
                throw new ArgumentNullException(""cipherText"");
            if (Key == null || Key.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length &lt;= 0)
                throw new ArgumentNullException(""IV"");

            // Declare the string used to hold
            // the decrypted text.
            string plaintext = null;
            byte[] returnText;

            // Create an Rijndael object
            // with the specified key and IV.
            using (Rijndael rijAlg = Rijndael.Create())
            {
                rijAlg.Key = Key;
                rijAlg.IV = IV;

                // Create a decryptor to perform the stream transform.
                ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

                // Create the streams used for decryption.
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {
                            // Read the decrypted bytes from the decrypting stream
                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();


                            ASCIIEncoding asc = new ASCIIEncoding();
                            returnText = asc.GetBytes(plaintext);
                        }
                    }
                }
            }
            return returnText;
        }
    }
}
</code></pre>
","<p>You can't treat an arbitrary array of bytes as a string. You're taking the bytes, converting them to a string, then writing the string into a StreamWriter, which converts the string back to bytes. This will be a lossy operation over a bunch of arbitrary bytes.</p>

<p>Your method <code>EncryptStringToBytes</code> is a mistaken concept. You should have a method <code>EncryptBytes</code> (and <code>DecryptBytes</code>) which don't concern themselves with strings. Then you can pass in a byte array and feed it directly into the <code>CryptoStream</code>. How those bytes are interpreted isn't the concern of an encryption algorithm.</p>

<p>So you could tweak your methods as follows:</p>

<pre><code>static byte[] EncryptBytes(byte[] bytes, byte[] Key, byte[] IV)
{
    // Check arguments.
    if (bytes == null || bytes.Length &lt;= 0)
        throw new ArgumentNullException(""bytes"");
    if (Key == null || Key.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");
    if (IV == null || IV.Length &lt;= 0)
        throw new ArgumentNullException(""IV"");
    // Create an Rijndael object
    // with the specified key and IV.
    using (Rijndael rijAlg = Rijndael.Create())
    {
        rijAlg.Key = Key;
        rijAlg.IV = IV;

        // Create an encryptor to perform the stream transform.
        ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);

        // Create the streams used for encryption.
        using (MemoryStream msEncrypt = new MemoryStream())
        {
            using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, 
                    CryptoStreamMode.Write))
            {
                csEncrypt.Write(bytes,0,bytes.Length);
                csEncrypt.FlushFinalBlock();
                return msEncrypt.ToArray();
            }
        }
    }
}
</code></pre>

<p>and</p>

<pre><code>static byte[] DecryptBytes(byte[] encryptedBytes, byte[] Key, byte[] IV)
{
    // Check arguments.
    if (encryptedBytes == null || encryptedBytes.Length &lt;= 0)
        throw new ArgumentNullException(""encryptedBytes"");
    if (Key == null || Key.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");
    if (IV == null || IV.Length &lt;= 0)
        throw new ArgumentNullException(""IV"");

    // Create an Rijndael object
    // with the specified key and IV.
    using (Rijndael rijAlg = Rijndael.Create())
    {
        rijAlg.Key = Key;
        rijAlg.IV = IV;

        // Create a decryptor to perform the stream transform.
        ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

        // Create the streams used for decryption.
        using (MemoryStream msDecrypt = new MemoryStream())
        {
            using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, 
                    CryptoStreamMode.Write))
            {
                csDecrypt.Write(encryptedBytes,0,encryptedBytes.Length);
                csDecrypt.FlushFinalBlock();
                return msDecrypt.ToArray();
            }
        }
    }

}
</code></pre>

<p>then test with a roundtrip:</p>

<pre><code>using(var rijndael = Rijndael.Create())
{
    var stringToEncrypt = ""foobar"";
    var bytesToEncrypt = Encoding.UTF8.GetBytes(stringToEncrypt);
    var encryptedBytes = EncryptBytes(bytesToEncrypt, rijndael.Key, rijndael.IV);
    var decryptedBytes = DecryptBytes(encryptedBytes, rijndael.Key, rijndael.IV);
    var originalString = Encoding.UTF8.GetString(decryptedBytes);
    Debug.Assert(string.Equals(stringToEncrypt, originalString, 
                                StringComparison.InvariantCulture));
}
</code></pre>

<p>hopefully, by this point, it's clear how we've disentangled the string encoding issues from the encryption and how you might now repurpose these methods for any kind of binary data.</p>
","102","<c#-4.0><encryption><jpeg><rijndael>","0","3","2","2017-03-01 02:58:48","42509077","2","0","5541055","","2017-02-28 17:25:17","2017-02-28 12:37:19",""
"30644697","AES-functions always reply with empty results","<p>today I've got a question about my current Visual Basic project I'm going for. My intention is to serve one or more encrypted Configuration-files for my program in the same directory where the executable is placed in. Because most likely the (en/de)cryption will be processed twice (username and password), I want to (en/de)crypt directly from String to String. I hope that this will reduce the hassles with temporary files and might be useful later on. </p>

<p>With the help of this great site and another tutorial I came as far, that at least the compiler doesn't complain anymore. :) So far, so good...</p>

<p>My code is the following:</p>

<pre><code>   Private Function produceKeyandIV(ByVal Password As String) As Object()
    Dim ByteArray(Password.Length) As Byte, Key(31) As Byte, IV(15) As Byte
    ByteArray = System.Text.Encoding.ASCII.GetBytes(Password)
    Dim SHA_FUNCTION As New System.Security.Cryptography.SHA512Managed
    Dim HashResult As Byte() = SHA_FUNCTION.ComputeHash(ByteArray)
    Array.Copy(HashResult, Key, 32)
    Array.Copy(HashResult, 32, IV, 0, 16)
    Dim obj(2) As Object
    obj(0) = Key
    obj(1) = IV
    Return obj
End Function
Private Function GenerateStreamFromString(ByVal myString As String) As Stream
    Dim ret_stream As MemoryStream = New MemoryStream()
    Dim stream_writer As StreamWriter = New StreamWriter(ret_stream, Encoding.Default)
    stream_writer.Write(myString)
    stream_writer.Flush()
    ret_stream.Position = 0
    Return ret_stream
End Function
Public Function DecryptStringReturnString(ByVal EncryptedString As String, ByVal Key As String) As String
    Dim CryptographyParameters As Object() = produceKeyandIV(Key)
    Try
        Dim byteBuffer(4096) As Byte
        Dim memoryStreamIn As Stream = GenerateStreamFromString(EncryptedString)
        Dim memoryStreamOut As MemoryStream = New MemoryStream()
        Dim positionInString As Long = 0
        Dim StringLength As Long = EncryptedString.Length()
        Dim bytesInBlockProcessed As Integer = 0
        Dim cryptServiceProvRijn As New System.Security.Cryptography.RijndaelManaged
        Using sCryptoStream = New CryptoStream(memoryStreamOut, _
                                              cryptServiceProvRijn.CreateDecryptor(CryptographyParameters(0), CryptographyParameters(1)), _
                                              CryptoStreamMode.Write)
            While positionInString &lt; StringLength
                bytesInBlockProcessed = memoryStreamIn.Read(byteBuffer, 0, 4096)
                sCryptoStream.Write(byteBuffer, 0, bytesInBlockProcessed)
                positionInString = positionInString + (bytesInBlockProcessed)
            End While
        End Using
        memoryStreamIn.Close()
        memoryStreamOut.Position = 0
        Dim stream_reader As StreamReader = New StreamReader(memoryStreamOut)
        Return stream_reader.ReadToEnd()
    Catch ex As Exception

    End Try
    Return Nothing
End Function
Public Function EncryptStringReturnString(ByVal DecryptedString As String, ByVal Key As String) As String
    Dim CryptographyParameters As Object() = produceKeyandIV(Key)
    Try
        Dim byteBuffer(4096) As Byte
        Dim memoryStreamIn As Stream = GenerateStreamFromString(DecryptedString)
        Dim memoryStreamOut As MemoryStream = New MemoryStream()
        Dim positionInString As Long = 0
        Dim StringLength As Long = DecryptedString.Length()
        Dim bytesInBlockProcessed As Integer = 0
        Dim cryptServiceProvRijn As New System.Security.Cryptography.RijndaelManaged
        Using sCryptoStream = New CryptoStream(memoryStreamOut, _
                                              cryptServiceProvRijn.CreateEncryptor(CryptographyParameters(0), CryptographyParameters(1)), _
                                              CryptoStreamMode.Write)
            While positionInString &lt; StringLength
                bytesInBlockProcessed = memoryStreamIn.Read(byteBuffer, 0, 4096)
                sCryptoStream.Write(byteBuffer, 0, bytesInBlockProcessed)
                positionInString = positionInString + (bytesInBlockProcessed)
            End While
            memoryStreamIn.Close()
            memoryStreamOut.Position = 0
            Dim stream_reader As StreamReader = New StreamReader(memoryStreamOut)
            Return stream_reader.ReadToEnd()
        End Using
    Catch ex As Exception

    End Try
    Return Nothing
End Function
</code></pre>

<p>The problem is if I call the function and let me Print give the results, they are always empty. Maybe somebody else got an idea why? :)</p>

<p><strong>Thanks in advance for your help...</strong></p>

<p>Useful resources:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/1879395/how-to-generate-a-stream-from-a-string"">how to generate a stream from a string?</a></li>
<li><a href=""http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael"" rel=""nofollow noreferrer"">http://www.codeproject.com/Articles/12092/Encrypt-Decrypt-Files-in-VB-NET-Using-Rijndael</a>
Those helped me a lot with this project.    </li>
</ul>
","<p>There was an instruction missing. According to <a href=""http://bytes.com/topic/net/answers/102758-cryptostream-memorystream-problems"" rel=""nofollow"">this website</a> <a href=""https://msdn.microsoft.com/de-de/library/system.security.cryptography.cryptostream.flushfinalblock%28v=vs.110%29.aspx"" rel=""nofollow"">FlushFinalBlock()</a> is needed, in order to finalize the changes made to the CryptoStream. People over there also recommend to actually store the data in Byte-Arrays instead of converted Strings. Which will I will do in the further developement, only in the end, if the configuration needs to be plain readable it will get converted back to ""readable"" text.</p>

<p>Heres my ""fixed"" version of my previous source code:</p>

<pre><code>Imports System.IO
Imports System.Security.Cryptography
Imports System.Text

Module sandbox
    Private Function produceKeyandIV(ByVal Password As String) As Object()
        Dim ByteArray(Password.Length) As Byte, Key(31) As Byte, IV(15) As Byte
        ByteArray = System.Text.Encoding.ASCII.GetBytes(Password)
        Dim SHA_FUNCTION As New System.Security.Cryptography.SHA512Managed
        Dim HashResult As Byte() = SHA_FUNCTION.ComputeHash(ByteArray)
        Array.Copy(HashResult, Key, 32)
        Array.Copy(HashResult, 32, IV, 0, 16)
        Dim obj(2) As Object
        obj(0) = Key
        obj(1) = IV
        Return obj
    End Function
    Private Function GenerateStreamFromString(ByVal myString As String) As Stream
        Dim ret_stream As MemoryStream = New MemoryStream()
        Dim stream_writer As StreamWriter = New StreamWriter(ret_stream, Encoding.Default)
        stream_writer.Write(myString)
        stream_writer.Flush()
        ret_stream.Position = 0
        Return ret_stream
    End Function
    Public Function DecryptByteArrayReturnByteArray(ByVal Encrypted As Byte(), ByVal Key As String) As Byte()
        Dim CryptographyParameters As Object() = produceKeyandIV(Key)
        Try
            Dim byteBuffer(4096) As Byte
            Dim memoryStreamIn As Stream = New MemoryStream(Encrypted)
            Dim memoryStreamOut As MemoryStream = New MemoryStream()
            Dim position As Long = 0
            Dim bytesInBlockProcessed As Integer = 0
            Dim cryptServiceProvRijn As New System.Security.Cryptography.RijndaelManaged
            Using sCryptoStream = New CryptoStream(memoryStreamOut, _
                                                  cryptServiceProvRijn.CreateDecryptor(CryptographyParameters(0), CryptographyParameters(1)), _
                                                  CryptoStreamMode.Write)
                While position &lt; Encrypted.Count()
                    bytesInBlockProcessed = memoryStreamIn.Read(byteBuffer, 0, 4096)
                    sCryptoStream.Write(byteBuffer, 0, bytesInBlockProcessed)
                    sCryptoStream.Flush()
                    position = position + (bytesInBlockProcessed)
                End While
                memoryStreamIn.Close()
                sCryptoStream.FlushFinalBlock() ' Needed to close the CryptoStream properly (a simple flush is not enough)
                Return memoryStreamOut.ToArray ' Independent from actual Streamposition
            End Using
        Catch ex As Exception

        End Try
        Return Nothing
    End Function
    Public Function EncryptByteArrayReturnByteArray(ByVal Decrypted As Byte(), ByVal Key As String) As Byte()
        Dim CryptographyParameters As Object() = produceKeyandIV(Key)
        Try
            Dim byteBuffer(4096) As Byte
            Dim memoryStreamIn As Stream = New MemoryStream(Decrypted)
            Dim memoryStreamOut As MemoryStream = New MemoryStream()
            Dim position As Long = 0
            Dim bytesInBlockProcessed As Integer = 0
            Dim cryptServiceProvRijn As New System.Security.Cryptography.RijndaelManaged
            Using sCryptoStream = New CryptoStream(memoryStreamOut, _
                                                  cryptServiceProvRijn.CreateEncryptor(CryptographyParameters(0), CryptographyParameters(1)), _
                                                  CryptoStreamMode.Write)
                While position &lt; Decrypted.Count()
                    bytesInBlockProcessed = memoryStreamIn.Read(byteBuffer, 0, 4096)
                    sCryptoStream.Write(byteBuffer, 0, bytesInBlockProcessed)
                    sCryptoStream.Flush()
                    position = position + (bytesInBlockProcessed)
                End While
                memoryStreamIn.Close()
                sCryptoStream.FlushFinalBlock() ' Needed to close the CryptoStream properly (a simple flush is not enough)
                Return memoryStreamOut.ToArray ' Independent from actual Streamposition
            End Using
        Catch ex As Exception

        End Try
        Return Nothing
    End Function
    Sub Main()
        Console.Write(""Passwort: "")
        Dim pwd = Console.ReadLine()
        Dim x As String = New String((System.Text.Encoding.Default.GetChars(DecryptByteArrayReturnByteArray(EncryptByteArrayReturnByteArray(System.Text.Encoding.Default.GetBytes(pwd), pwd), pwd))))
        Console.Write(x)
        Console.ReadLine()
    End Sub

End Module
</code></pre>

<p>If you think there are issues or flaws in the code, please point them out for me. I'd appreciate that very much. :)</p>
","101","<.net><vb.net><encryption><aes><rijndael>","1","0","1","2015-06-05 09:05:37","30662528","0","1","-1","","2017-05-23 12:05:58","2015-06-04 13:10:15",""
"53950491","Ruby OpenSSL changing the block-size","<p>Is it at all possible in OpenSSL to change the block size? I am using Ruby and from what I can tell there is no way to do this. </p>

<p>I just want to confirm this is true. Here is a link to the only method I can find related to block size which just returns what the block size is. <a href=""https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html#method-i-block_size"" rel=""nofollow noreferrer"">https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html#method-i-block_size</a> but other than that I don't see a way to do this. Is it possible? I know I can set the key size but not the block size. It seems it is stuck with a 128-bit block size?</p>

<p>Specifically I want to use AES which I understand is only a 128-bit block size. But Rijndael which is what AES is based on can be set up to a 256-bit block size so I was wondering if OpenSSL would allow me to set the block size.</p>
","<p>No, it's not possible.</p>

<ul>
<li><p><a href=""https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a>, as standardized by NIST, is a subset of the Rijndael cipher family.  While Rijndael supports several different block and key sizes, AES is only defined to use a block size of 128 bits and a key size of either 128, 192 or 256 bits.</p></li>
<li><p>The list of <a href=""https://github.com/openssl/openssl/tree/master/crypto"" rel=""nofollow noreferrer"">ciphers supported by OpenSSL</a> only includes AES, not Rijndael.</p></li>
<li><p>The OpenSSL AES implementation is <a href=""https://github.com/openssl/openssl/blob/48f4ad7718498577af52878b9e8b0924d8faf83f/include/openssl/aes.h#L28"" rel=""nofollow noreferrer"">hardcoded to use a block size of 16 bytes</a> (= 128 bits).</p></li>
</ul>

<p>Short of adding Rijndael <a href=""https://wiki.openssl.org/index.php/How_to_Integrate_a_Symmetric_Cipher"" rel=""nofollow noreferrer"">as a new cipher to OpenSSL</a> and rebuilding the library yourself, you will not be able to use OpenSSL to encrypt or decrypt data using any of the Rijndael variants other than those standardized as AES.</p>
","98","<ruby><openssl><rijndael>","1","1","1","2018-12-30 23:26:07","53982254","0","","9911698","","2018-12-27 21:16:17","2018-12-27 20:24:53",""
"12445312","Is ECB a safe option if you don't expect duplicate results?","<p>I want to encrypt long paragraphs of text using Rijndael-256 (the text has been compressed and converted to base64 before this).</p>

<p>It is very unlikely for the two to be the same. But if they happen to be, would adding a random key to the start or end of the text secure it (regardless of whether they're the same), just in case users write the same text?</p>

<p>If I make sure that no results are 100% the same, is ECB safe if you won't get duplicate results?</p>

<p>Or is it like this: (using base64... not accurate, just an example)</p>

<pre><code>_Hello world_ = ahjkIOn25o

_To echo ""Hello world,""_ = qw90klnN2_ahjkIOn25o_kL3

_Hello world is the_ = _ahjkIOn25o_hjAB27
</code></pre>

<p>So if someone has a phrase hidden inside their text, it would always output the same ECB for that piece, no matter what else is in the text, or the phrase's position in the text?</p>
","<p>I would recommend to use something like CBC. All you will have to do is to add IV. </p>

<blockquote>
  <p>So if someone has a phrase hidden inside their text, it would always output the same ECB for that piece, no matter what else is in the text, or the phrase's position in the text?</p>
</blockquote>

<p>Two exactly same plaintext block will become exactly same ciphertext blocks. </p>

<p>So, it depends on how long the hidden phrase is and how it's positioned inside of a block. Only if the whole content of the block is that same, the result will be the same.</p>

<p>I would say it's more applicable for two cases:</p>

<ul>
<li>You have a large amount of structured data (as example images or video)</li>
<li>You use the same key to encrypt multiple messages (which translates to large amount of data).</li>
</ul>

<p>Both this case may allow attacker to figure out something about your internal structures.</p>

<p>I recommend to take a look at this: <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29"" rel=""nofollow"">http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29</a>
It shows what the problem with ECB.</p>

<p>Generally speaking, it's easier to use another mode than to</p>

<ul>
<li>Work around ECB weaknesses</li>
<li>Worry whether you took into account all possible cases.</li>
</ul>
","98","<security><mcrypt><rijndael><ecb>","1","2","1","2013-07-18 12:40:59","","2","","","user1228","2013-07-18 12:40:59","2012-09-16 08:00:26",""
"31997851","Encrypted streams in C# are shrinking","<p>I am obviously doing something wrong here, but I don't understand why this is happening. I have been experianceing bugs in my encrypt stream function and added additional code to display to Visual studio's debugger what is going on in the function. To my discovery, the encrypted version of what ever data I send into it is shorter than the original stream, and attempts to decrypt the stream results in an even shorter stream. </p>

<pre><code>        public Stream encryptStream(Stream input)
    {
        MemoryStream output = new MemoryStream();
        RijndaelManaged alg = new RijndaelManaged();
        alg.Padding = PaddingMode.PKCS7;
        byte[] key = HashStringMD5(DefaultKey);
        alg.KeySize = key.Length * 8;
        alg.Key = key;
        alg.IV = key;


        CryptoStream crypt = new CryptoStream(output, alg.CreateEncryptor(), CryptoStreamMode.Write);



        output.Position = 0;
        input.CopyTo(crypt);
        byte[] EncryptedCopy = output.ToArray();
        byte[] InputCopy = new byte[input.Length];
        input.Position = 0;
        input.Read(InputCopy, 0, InputCopy.Length);
        output.Position = 0;
        MemoryStream test = new MemoryStream();
        crypt.Close();
        crypt = new CryptoStream(test, alg.CreateDecryptor(), CryptoStreamMode.Write);
        crypt.Write(EncryptedCopy, 0, EncryptedCopy.Length);
        test.Position = 0;
        byte[] DecryptionTest = test.ToArray();


        input.Position = 0;


        return output;
    }
</code></pre>

<p>not sure what is causing the data loss as shown below <a href=""https://i.stack.imgur.com/uXmLu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uXmLu.png"" alt=""enter image description here""></a></p>
","<p>You just need to flush to the containing stream at the right time. Also, you have quite a few resources which implement <code>IDisposable</code> and are disposed of most easily by employing the <code>using</code> construct. This should produce the results you are looking for as well as properly deterministically disposing of resources:</p>

<pre><code>public Stream encryptStream(Stream input)
{
    var output = new MemoryStream();

    using (var alg = new RijndaelManaged { Padding = PaddingMode.PKCS7 })
    {
        var key = HashStringMD5(DefaultKey);
        alg.KeySize = key.Length * 8;
        alg.Key = key;
        alg.IV = key;
        byte[] encryptedCopy;

        using (var enc = alg.CreateEncryptor())
        {
            var crypt = new CryptoStream(output, enc, CryptoStreamMode.Write);

            input.CopyTo(crypt);
            crypt.FlushFinalBlock();
            encryptedCopy = output.ToArray();
        }

        var inputCopy = new byte[input.Length];

        input.Position = 0;
        input.Read(inputCopy, 0, inputCopy.Length);
        using (var test = new MemoryStream())
        using (var dec = alg.CreateDecryptor())
        using (var crypt = new CryptoStream(test, dec, CryptoStreamMode.Write))
        {
            crypt.Write(encryptedCopy, 0, encryptedCopy.Length);
            crypt.FlushFinalBlock();

            var decryptionTest = test.ToArray();

            if (decryptionTest.Length != inputCopy.Length || decryptionTest.Where((t, i) =&gt; t != inputCopy[i]).Any())
            {
                throw new InvalidOperationException(""not orthogonal"");
            }
        }
    }

    input.Position = 0;
    output.Position = 0;
    return output;
}
</code></pre>

<p>Though I might split the testing code into a separate method as it adds noise to the simplicity of the encrypting code.</p>
","97","<c#><.net><encryption><stream><rijndael>","1","2","1","2015-08-13 21:30:38","31998629","1","","3908766","","2015-08-13 20:31:08","2015-08-13 20:30:19",""
"43944647","What's wrong with this Haskell AES key expansion?","<p>Following steps describing key expansion in <a href=""http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html"" rel=""nofollow noreferrer"">Jeff Moser's popular tutorial</a>, I've written this code for key expansion. Here is the entire file (which also computes the S-Box), so folks can compile and try it.</p>

<pre><code>{-# LANGUAGE NoMonomorphismRestriction #-}

import Control.Applicative (liftA2)
import Data.Bits (xor, shiftL, shiftR, (.|.), (.&amp;.))
import Data.List (transpose, sortBy)
import Data.Ord (comparing)
import Data.Word (Word8)
import Numeric (showHex)

keys = f 16 $ f 8 $ f 4 $ f 2 $ f 1 key
 where
  f w n = xpndC . xpndB . xpndA $ xpndD w n

xpndC   :: [[Word8]] -&gt; [[Word8]]
xpndC ws = transpose [head ws, b, zipWith xor b c, last ws]
 where
  (b,c) = (ws !! 1, ws !! 2)

xpndB   :: [[Word8]] -&gt; [[Word8]]
xpndB ws = a : zipWith xor a b : drop 2 ws
 where
  (a,b) = (head ws, ws !! 1)

xpndA   :: [[Word8]] -&gt; [[Word8]]
xpndA ws = zipWith xor a d : tail ws
 where
  (a,d) = (head ws, last ws)

xpndD rc ws = take 3 tW ++ [w']
 where
  w' = zipWith xor (map sub w) [rc, 0, 0, 0]
  tW = transpose ws
  w  = take 4 $ tail $ cycle $ last tW

--------------------------------------------------------------
sub w = get sbox (fromIntegral lo) $ fromIntegral hi
 where
  (hi, lo) = nibs w

get wss x y = (wss !! y) !! x

print' = print . w128 . concat . transpose
 where
  w128 = concatMap (f . (`showHex` """"))
  f w  = (length w &lt; 2) ? (' ':'0':w, ' ':w)

grid _ [] = []
grid n xs = take n xs : grid n (drop n xs)

nibs w    = (shiftR (w .&amp;. 0xF0) 4, w .&amp;. 0x0F)
(⊕)       = xor
p ? (a,b) = if p then a else b; infix 2 ?

---------------------------------------------------
sbox :: [[Word8]]
sbox = grid 16 $ map snd $ sortBy (comparing fst) $ sbx 1 1 []

sbx :: Word8 -&gt; Word8 -&gt; [(Word8, Word8)] -&gt; [(Word8, Word8)]
sbx p q ws
  | length ws == 255 = (0, 0x63) : ws
  | otherwise = sbx p' r $ (p', xf ⊕ 0x63) : ws
 where
  p' = p  ⊕  shiftL p  1 ⊕  ((p .&amp;. 0x80 /= 0) ? (0x1B, 0))
  q1 = foldl (liftA2 (.) xor shiftL) q [1, 2, 4]
  r  = q1 ⊕  ((q1 .&amp;. 0x80 /= 0) ? (0x09, 0))
  xf = r  ⊕  rotl8 r 1 ⊕  rotl8 r 2 ⊕  rotl8 r 3 ⊕  rotl8 r 4

rotl8 w n = (w `shiftL` n) .|. (w `shiftR` (8 - n))

key = [[0,0,0,0],
       [0,0,0,0],
       [0,0,0,0],
       [0,0,0,0]] :: [[Word8]]
</code></pre>

<p>When I test this code against the all-zero test key, it matches the published expectation up to the fourth iteration: <code>ee 06 da 7b 87 6a 15 81 75 9e 42 b2 7e 91 ee 2b</code>.</p>

<p>But when I try the next iteration: <code>keys = f 16 $ f 8 $ f 4 $ f 2 $ f 1</code>, 
the last 32 bits of the result are wrong: <code>7f 2e 2b 88 f8 44 3e 09 8d da 7c bb 91 28 f1 f3</code>.</p>

<p>The same behavior - last 32 bits wrong - happens when I use all 0xFF for the initial key. And in subsequent iterations, all the bits are wrong.</p>

<p>If I use the test vector <code>00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</code>, things go wrong much faster - I start getting wrong bits on the second iteration.</p>

<p>What's going on here? I notice Mr. Moser wrote in part <em>2b : 4</em> to <code>xor</code> with the first column of the <em>previous round key</em> - but there is no previous round for the initial key, so this confused me. Is this what I've done wrong?</p>

<p>For reference, <a href=""http://www.samiam.org/key-schedule.html"" rel=""nofollow noreferrer"">here are the test vectors.</a></p>
","<p>You're missing a step.</p>

<pre><code>xpndC ws = transpose [head ws, b, zipWith xor b c, last ws]
</code></pre>

<p>the fourth column should be the xor of the previous fourth column (which you've thrown away in the first pass) and the new third column.</p>

<p>The fact that <code>xor x x = 0</code> somehow contributed to this mistake being noticeable only at the fifth iteration.</p>

<hr>

<p>Minor stylistic comments</p>

<p>Pattern matching on a fixed structure is less awkward than <code>(!!)</code>.</p>

<pre><code>xpndC :: [[Word8]] -&gt; [[Word8]]
xpndC [a,b,c,d] = [a, b, zipWith xor b c, d]
</code></pre>

<p>Also note that steps <code>2b4</code> and <code>3</code> are actually a scan. Roughly, it ends up looking like this (with the name <code>schedule_core</code> borrowed from your last link):</p>

<pre><code>new = tail $ scanl (zipWith xor) (schedule_core (last old)) old
</code></pre>

<hr>

<h1>Edit: Fix</h1>

<p>The solution is essentially to <em>not</em> throw away the last column. You can, as a quick fix, inject it in an additional pass this way:</p>

<pre><code>keys = f 16 $ f 8 $ f 4 $ f 2 $ f 1 key
 where
  f w n = xpndE (transpose n) . xpndC . xpndB . xpndA $ xpndD w n

xpndE n [a,b,c,_] = transpose [a,b,c,zipWith xor c (last n)]

xpndC = (...) {- remove transpose here -}
</code></pre>

<p>The <code>xpnd*</code> functions may be a bit too fine-grained, once you realize that the list is quite small. I would also factor <code>transpose</code> out, if you want to keep it at all.</p>

<pre><code>keys = transpose $ f 16 $ f 8 $ f 4 $ f 2 $ f 1 $ transpose key
  where
    f rc [a, b, c, d] =
      let e = schedule rc d
          a' = zipWith xor a e
          b' = zipWith xor b a'
          c' = zipWith xor c b'
          d' = zipWith xor c c'
      in [a', b', c', d']  -- Here is where one may recognize `scanl` or a fold.
</code></pre>

<p>As for <code>schedule</code>, it's the function that takes the last column (<code>d</code> above, <code>last tW</code> below) and scrambles it (<code>e</code> above, <code>w'</code> below). You can extract it from your definition of <code>xpndD</code>:</p>

<pre><code>xpndD rc ws = take 3 tW ++ [w']
 where
  w' = zipWith xor (map sub w) [rc, 0, 0, 0]
  tW = transpose ws
  w  = take 4 $ tail $ cycle $ last tW
</code></pre>

<p>We get (modulo a purely cosmetic rewriting <code>take 4 $ tail $ cycle d = tail d ++ [head d]</code>):</p>

<pre><code>schedule rc d = zipWith xor (map sub $ tail d ++ [head d]) [rc, 0, 0, 0]
</code></pre>
","97","<haskell><aes><rijndael>","1","3","1","2017-05-12 22:31:01","43945863","2","","1241445","","2017-05-12 19:31:57","2017-05-12 18:48:28",""
"35473199","C# decrypt Rijndael encrypted string using CakePHP's Security::rijndael","<p>I'm trying to decrypt a string encrypted using the Security::rijndael() function of CakePHP. Here's my code:</p>

<pre><code>$enc = bin2hex( Security::rijndael( $field, Configure::read('Security.key'), 'encrypt' ) );
</code></pre>

<p>Please note that after encrypting, I'm using the bin2hex() function to convert it into a hex string that can be stored in the DB.</p>

<p>In CakePHP, I can easily decrypt this using:</p>

<pre><code>$dec = Security::rijndael( hex2bin( $field ), Configure::read( 'Security.key' ), 'decrypt' );
</code></pre>

<p>I'm trying to achieve the same kind of decryption using C#, by running hex2bin first. I tried using a hex2bin() sample I found on the net:</p>

<pre><code>private string hex2bin( string hexvalue ) {
    string binaryval = """";
    binaryval = Convert.ToString( Convert.ToInt64( hexvalue, 16 ), 2 );
    return binaryval;
}
</code></pre>

<p>...but this keeps returning an error: <strong>Value was either too large or too small for a UInt64</strong> and I cannot proceed beyond this point.</p>

<p>I'm looking for ideas on how to reverse the process in C#.</p>

<p>Thank you.</p>
","<p>You have to slice your string into a series of bytes that are decoded one at a time:</p>

<pre><code>private byte[] hex2bin( string hexvalue )
{
    byte [] result = new byte[hexvalue.Length / 2];;

    for (int pos = 0; pos &lt; hexvalue.Length; po+=2)
       byte[pos/2] =  Convert.Byte( hexvalue.SubString(pos, 2),  16 );

   return result;
}
</code></pre>

<p>And the result should be an array of bytes, not a string....</p>
","97","<c#><php><cakephp><encryption><rijndael>","0","0","1","2016-02-18 05:14:00","","2","1","","","","2016-02-18 05:00:07",""
"8801069","CriptographyException in Rijndael","<p>I have some problem with Rijndael! My problem is: If I use incсorect key in Decrypt method then Rijndael throw CriptograpfyException! How i can know that key inccorect? Why it throw Exception? I thought that decrypt method must be return a garbage! </p>
","<p>The only thing that can be incorrect regarding Rijndael is that the size of the key is not supported. For AES, the most used configuration of Rijndael, you have to supply keys of length 128, 192 or 256 bits (or 16, 24 or 32 bytes respectively).</p>
","96","<rijndael>","-1","0","1","2012-02-10 00:41:30","","0","","","","","2012-01-10 09:35:43",""
"38811978","C# Rijndael decrypt no longer works after changing code to generate a random iv","<p>This block of code used to have both the key and the iv set, taken from <a href=""https://stackoverflow.com/questions/11873878/c-sharp-encryption-to-php-decryption"">C# Encryption to PHP Decryption</a></p>

<p>I've attempted to change it to use a generated iv that is prepended to the resulting output. The encrypt works fine (testing decrypt is done via php and works great) however I can't get the same results with the C# decrypt function using the C# encrypted text. Can anyone point out what I'm overlooking?</p>

<p>The error I'm seeing is Bad PKCS7 padding. Invalid Length x where x varies.</p>

<pre><code>private static readonly byte[] Key = Convert.FromBase64String(""REMOVED"");
private const int IvBytes = 32;

public static string Encrypt(string prm_text_to_encrypt)
{
    var sToEncrypt = prm_text_to_encrypt;

    var rj = new RijndaelManaged()
    {
        Padding = PaddingMode.PKCS7,
        Mode = CipherMode.CBC,
        KeySize = 256,
        BlockSize = 256,
        Key = Key,
    };
    rj.GenerateIV ();

    var encryptor = rj.CreateEncryptor();

    var msEncrypt = new MemoryStream();
    var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);

    var toEncrypt = Encoding.ASCII.GetBytes(sToEncrypt);

    csEncrypt.Write(toEncrypt, 0, toEncrypt.Length);
    csEncrypt.FlushFinalBlock();

    var encrypted = msEncrypt.ToArray();

    return (Convert.ToBase64String(rj.IV.Concat(encrypted).ToArray()));
}

public static string Decrypt(string prm_text_to_decrypt)
{

    var sEncryptedString = prm_text_to_decrypt;

    var rj = new RijndaelManaged()
    {
        Padding = PaddingMode.PKCS7,
        Mode = CipherMode.CBC,
        KeySize = 256,
        BlockSize = 256,
        Key = Key
    };

    var decryptor = rj.CreateDecryptor();

    var tmp = Convert.FromBase64String(sEncryptedString);

    var fromEncrypt = new byte[tmp.Length];

    byte[] IV = tmp.Take(IvBytes).ToArray();
    byte[] sEncrypted = tmp.Skip(IvBytes).ToArray();
    rj.IV = IV;

    var msDecrypt = new MemoryStream(sEncrypted);
    var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);

    csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);

    return (Encoding.ASCII.GetString(fromEncrypt));
}
</code></pre>
","","94","<c#><php><encryption><rijndael>","1","","0","2016-08-07 07:35:04","","4","","-1","","2017-05-23 12:22:56","2016-08-07 07:35:04",""
"53153733","Length of the data to decrypt is invalid. Encrypted with Javascript and Decrypted with c#","<p>I have to Encrypt and Encode a URL using Javascript and then decrypt and decode using C#.</p>

<p>If I run the code in Debug using Visual Studio. It performs fine. But when I call the application using an URL from a form, it fails with a Error: ""Length of the data to decrypt is invalid.""</p>

<p>What am I doing wrong here? I've reviewed multiple tutorials but can't find and fix the issue.</p>

<p>Encryption Javascript Code:</p>

<pre><code>function Encrypt(value){
    var key = CryptoJS.enc.Utf8.parse(""1234567812345678"");
    var iv = CryptoJS.enc.Utf8.parse(""1234567812345678"");

    var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(value), key,
        {
            keySize: 128 / 8,
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });

    var encodedValue = window.btoa(encrypted);
    console.log(""encodedValue: "" + encodedValue);

    var decodedValue = window.atob(encodedValue);
    console.log(""decodedValue: "" + decodedValue);

    return encodedValue;
}

function openAws(event) {
    event.preventDefault()

    var lastname = document.getElementById(""lastname"").value;
    var firstname = document.getElementById(""firstname"").value;
    var email = document.getElementById(""email"").value;

    var time1 = new Date();

    var hour = time1.getUTCHours();
    if(hour &lt; 10)
        hour = ""0"" + hour;

    var min = time1.getUTCMinutes();
    if(min &lt; 10)
        min = ""0"" + min;

    var sec = time1.getUTCSeconds();
    if(sec &lt; 10)
        sec = ""0"" + sec;

    var timestamp = hour.toString() + min.toString() + sec.toString();

    var encryptedValues = encryptTestURL + ""?lastname="" + Encrypt(lastname) + ""&amp;firstname="" + Encrypt(firstname) + ""&amp;email="" + Encrypt(email) + ""&amp;timestamp="" + Encrypt(timestamp);
}
</code></pre>

<p>Decryption C# Code:</p>

<pre><code>public string DecryptParams(string param)
{
    var keyBytes = Encoding.UTF8.GetBytes(""1234567812345678"");
    var iv = Encoding.UTF8.GetBytes(""1234567812345678"");

    //Decrypt from CryptoJS
    var decodedParam = HttpUtility.UrlDecode(param);
    var encrypted = Convert.FromBase64String(decodedParam);
    var decriptedFromJavascript = DecryptedStringFromBytes(encrypted, keyBytes, iv);

    return decriptedFromJavascript;
}

public static string DecryptedStringFromBytes(byte[] cypherText, byte [] key, byte [] iv)
{
    if(cypherText == null || cypherText.Length &lt;= 0)
    {
        throw new ArgumentException(""cypherText"");
    }
    if(key == null || key.Length &lt;= 0)
    {
        throw new ArgumentException(""key"");
    }
    if(iv == null || iv.Length &lt;= 0)
    {
        throw new ArgumentException(""key"");
    }

    //Declare String to be used
    string plainText = null;

    // Create an RijndaelManaged object
    // with the specified key and IV.

    using (var rijAlg = new RijndaelManaged())
    {
        rijAlg.Mode = CipherMode.CBC;
        rijAlg.Padding = PaddingMode.None;
        rijAlg.FeedbackSize = 128;
        rijAlg.Key = key;
        rijAlg.IV = iv;

        var decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

        using (var msDecrypt = new MemoryStream(cypherText))
        {
            using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
            {
                using (var srDecrypt = new StreamReader(csDecrypt))
                {
                    //Read Decrypted bytes
                    plainText = srDecrypt.ReadToEnd();
                }
            }
        }
    }
    return plainText;
}
</code></pre>
","<p>I'll have a guess here that maybe your URL param parser might get confused with base64 decoding because of '=' padding characters. On top of that, input / output of AES functions must be block aligned. Seeing you use a 128 bit key / IV, you must make sure you supply the encryption / decryption functions with 16 byte aligned size (unless clearly stated otherwise by your framework).</p>
","92","<javascript><c#><encryption><rijndael>","0","0","1","2018-11-05 12:56:54","","1","","1220550","","2018-11-05 11:50:34","2018-11-05 11:43:32",""
"46123503","Rijndael to PHP contract?","<p>Ok I need some help with PHP.  I have an encryption class in c# and I need to create a similar one in PHP that will encrypt and decrypt the same way (they need to talk to each other).</p>

<p>I know there are several similar questions on SO and I think I have read most if not all of them.  I have tried to apply them to my code and I'm just not getting the correct result, PHP always encrypts to a different value than the c# version.  I've read up on it and tried different things as mentioned, but encryption is not one of my strong points and I'm just not getting it.  Can anyone help?  Here is the c# code:</p>

<pre><code>// Encrypt a string into a string using a password 
    public static string Encrypt(string clearText, string Password)
    {

        // First we need to turn the input string into a byte array. 
        byte[] clearBytes = Encoding.Unicode.GetBytes(clearText);

        // Then, we need to turn the password into Key and IV 
        // We are using salt to make it harder to guess our key using a dictionary attack - 
        // trying to guess a password by enumerating all possible words. 
        PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
            new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });

        // Now get the key/IV and do the encryption using the function that accepts byte arrays. 
        // Using PasswordDeriveBytes object we are first getting 32 bytes for the Key 
        // (the default Rijndael key length is 256bit = 32bytes) and then 16 bytes for the IV. 
        // IV should always be the block size, which is by default 16 bytes (128 bit) for Rijndael. 
        byte[] encryptedData = Encrypt(clearBytes, pdb.GetBytes(32), pdb.GetBytes(16));

        // Now we need to turn the resulting byte array into a string. 
        // A common mistake would be to use an Encoding class for that. It does not work 
        // because not all byte values can be represented by characters. 
        // We are going to be using Base64 encoding that is designed exactly for what we are 
        // trying to do. 
        return Convert.ToBase64String(encryptedData);
    }

    // Encrypt a byte array into a byte array using a key and an IV 
    static byte[] Encrypt(byte[] clearData, byte[] Key, byte[] IV)
    {
        MessageBox.Show(Encoding.Unicode.GetString(clearData) + ""\n"" + Convert.ToBase64String(Key) + ""\n"" +
                        Convert.ToBase64String(IV));
        // Create a MemoryStream that is going to accept the encrypted bytes 
        MemoryStream ms = new MemoryStream();

        // Create a symmetric algorithm. 
        // We are going to use Rijndael because it is strong and available on all platforms. 
        Rijndael alg = Rijndael.Create();

        // Now set the key and the IV. 
        // We need the IV (Initialization Vector) because the algorithm is operating in its default 
        // mode called CBC (Cipher Block Chaining). The IV is XORed with the first block (8 byte) 
        // of the data before it is encrypted, and then each encrypted block is XORed with the 
        // following block of plaintext. This is done to make encryption more secure. 
        // There is also a mode called ECB which does not need an IV, but it is much less secure. 
        alg.Key = Key;
        alg.IV = IV;

        // Create a CryptoStream through which we are going to be pumping our data. 
        // CryptoStreamMode.Write means that we are going to be writing data to the stream 
        // and the output will be written in the MemoryStream we have provided. 
        CryptoStream cs = new CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write);

        // Write the data and make it do the encryption 
        cs.Write(clearData, 0, clearData.Length);

        // Close the crypto stream (or do FlushFinalBlock). 
        // This will tell it that we have done our encryption and there is no more data coming in, 
        // and it is now a good time to apply the padding and finalize the encryption process. 
        cs.Close();

        // Now get the encrypted data from the MemoryStream. 
        // Some people make a mistake of using GetBuffer() here, which is not the right way. 
        byte[] encryptedData = ms.ToArray();

        return encryptedData;
    }

    // Decrypt a string into a string using a password 
    // Uses Decrypt(byte[], byte[], byte[]) 
    public static string Decrypt(string cipherText, string Password)
    {
        string strDecryptedKey = String.Empty;

        if ((cipherText == null) || (cipherText.Length == 0))
        {
            return strDecryptedKey;
        }

        try
        {
            // First we need to turn the input string into a byte array. 
            // We presume that Base64 encoding was used 
            byte[] cipherBytes = Convert.FromBase64String(cipherText);

            // Then, we need to turn the password into Key and IV 
            // We are using salt to make it harder to guess our key using a dictionary attack - 
            // trying to guess a password by enumerating all possible words. 
            PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
                new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });

            // Now get the key/IV and do the decryption using the function that accepts byte arrays. 
            // Using PasswordDeriveBytes object we are first getting 32 bytes for the Key 
            // (the default Rijndael key length is 256bit = 32bytes) and then 16 bytes for the IV. 
            // IV should always be the block size, which is by default 16 bytes (128 bit) for Rijndael. 
            byte[] decryptedData = Decrypt(cipherBytes, pdb.GetBytes(32), pdb.GetBytes(16));

            // Now we need to turn the resulting byte array into a string. 
            // A common mistake would be to use an Encoding class for that. It does not work 
            // because not all byte values can be represented by characters. 
            // We are going to be using Base64 encoding that is designed exactly for what we are 
            // trying to do. 
            strDecryptedKey = Encoding.Unicode.GetString(decryptedData);
        }
        catch (Exception ex)
        {
            throw ex;
        }
        return strDecryptedKey;
    }

    // Decrypt a byte array into a byte array using a key and an IV 
    static byte[] Decrypt(byte[] cipherData, byte[] Key, byte[] IV)
    {
        byte[] decryptedData = null;

        try
        {
            // Create a MemoryStream that is going to accept the decrypted bytes 
            MemoryStream ms = new MemoryStream();

            // Create a symmetric algorithm. 
            Rijndael alg = Rijndael.Create();

            // Now set the key and the IV. 
            // We need the IV (Initialization Vector) because the algorithm is operating in its default 
            // mode called CBC (Cipher Block Chaining). The IV is XORed with the first block (8 byte) 
            // of the data after it is decrypted, and then each decrypted block is XORed with the previous 
            // cipher block. This is done to make encryption more secure. 
            // There is also a mode called ECB which does not need an IV, but it is much less secure. 
            alg.Key = Key;
            alg.IV = IV;

            // Create a CryptoStream through which we are going to be pumping our data. 
            // CryptoStreamMode.Write means that we are going to be writing data to the stream 
            // and the output will be written in the MemoryStream we have provided. 
            CryptoStream cs = new CryptoStream(ms, alg.CreateDecryptor(), CryptoStreamMode.Write);

            // Write the data and make it do the decryption 
            cs.Write(cipherData, 0, cipherData.Length);

            // Close the crypto stream (or do FlushFinalBlock). 
            // This will tell it that we have done our decryption and there is no more data coming in, 
            // and it is now a good time to remove the padding and finalize the decryption process. 
            cs.Close();

            // Now get the decrypted data from the MemoryStream. 
            // Some people make a mistake of using GetBuffer() here, which is not the right way. 
            decryptedData = ms.ToArray();
        }
        catch (Exception ex)
        {
            throw ex;
        }

        return decryptedData;
    }
</code></pre>

<p>Here is my php code (with a few passwords that I currently have hard coded removed, I will change that before production, just trying to get proof of concept working):</p>

<pre><code>date_default_timezone_set('UTC');
$encText=""something"";

$baseVal=""**my password which is about 30 something characters if that matters**"";
$salt=""**my salt**"";

$pwHex=strToHex($baseVal);
$saltHex=strToHex($salt);
echo($baseVal.""/"".$salt.""&lt;br /&gt;"");
echo(""Hex= "".$pwHex).""&lt;br /&gt;"";
echo(""saltHex= "".$saltHex.""&lt;br /&gt;"");

$pwBin=pack(""H*"",$pwHex);
$saltBin=pack(""H*"",$saltHex);

$devKey=PBKDF1($pwBin,$saltBin,100,48);
echo(""Dev Key: "".base64_encode($devKey).""&lt;br /&gt;"");

$cryptKey=bin2hex(substr($devKey,0,16));
$cryptIv=bin2hex(substr($devKey,16,32));

echo(""Crypt Key: "".base64_encode($cryptKey).""&lt;br /&gt;"");
echo(""Crypt IV: "".base64_encode($cryptIv).""&lt;br /&gt;"");

echo(""size: "".mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256,MCRYPT_MODE_CBC).""&lt;br /&gt;"");

$enc=mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $cryptKey, $encText, MCRYPT_MODE_CBC, $cryptIv);

$enc_64=base64_encode($enc);

echo(""Cipher: "".$enc_64.""\n"");

$dec = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $cryptKey, $enc, MCRYPT_MODE_CBC, 
$cryptIv);
$dec64 = base64_encode($dec);
echo($dec64);

function PBKDF1($pass,$salt,$count,$dklen) {
$t = $pass.$salt;
//echo 'S||P: '.bin2hex($t).'&lt;br/&gt;';
$t = sha1($t, true);
//echo 'T1:' . bin2hex($t) . '&lt;br/&gt;';
for($i=2; $i &lt;= $count; $i++) { 
    $t = sha1($t, true); 
    //echo 'T'.$i.':' . bin2hex($t) . '&lt;br/&gt;';
} 
$t = substr($t,0,$dklen-1);
return $t;      
}
function strToHex($string){
$hex = '';
for ($i=0; $i&lt;strlen($string); $i++){
    $ord = ord($string[$i]);
    $hexCode = dechex($ord);
    $hex .= substr('0'.$hexCode, -2);
}
return strToUpper($hex);
}
</code></pre>

<p>Any help is greatly appreciated.</p>
","","88","<c#><php><encryption><rijndael>","0","","0","2017-09-08 19:37:29","","4","","","","","2017-09-08 19:37:29",""
"56405814","How to fix ""Padding is invalid and cannot be removed"" when encrypting and decrypting in the same process","<p>I am trying to encrypt and decrypt an xml file. The program trys to open, edit, and reencrypt the data, But I get the error ""System.Security.Cryptography.CryptographicException: Padding is invalid and cannot be removed."" When I encrypt, then decrypt running the program twice, It works just fine, but the program creates an error when doing them both.</p>

<p>This is a very common error, but also a very vague one, with many different ""scenarios"". I've searched for a while one ways to fix it, and I've tried all of the ""fixes"" online. None have worked yet.</p>

<pre class=""lang-cs prettyprint-override""><code>class Program
    {
        static void Main(string[] args)
        {
        }
        public static void encFile(string input, string password)
        {
            GCHandle gch = GCHandle.Alloc(password, GCHandleType.Pinned);

            FileEncrypt(input, password);

            ZeroMemory(gch.AddrOfPinnedObject(), password.Length * 2);
            gch.Free();
        }
        public static string output;
        public static void decFile(string input, string password)
        {
            GCHandle gch = GCHandle.Alloc(password, GCHandleType.Pinned);

            // Decrypt the file
            output = FileDecrypt(input, password);

        }

        [DllImport(""KERNEL32.DLL"", EntryPoint = ""RtlZeroMemory"")]
        public static extern bool ZeroMemory(IntPtr Destination, int Length);

        /// &lt;summary&gt;
        /// Encrypts a file from its path and a plain password.
        /// &lt;/summary&gt;
        /// &lt;param name=""inputFile""&gt;&lt;/param&gt;
        /// &lt;param name=""password""&gt;&lt;/param&gt;
        private static void FileEncrypt(string inputFile, string password)
        {
            File.WriteAllText(Path.GetDirectoryName(inputFile) + ""\\"" + Path.GetFileNameWithoutExtension(inputFile) + "".dat"", Crypto.EncryptStringAES(File.ReadAllText(inputFile), ""Password123!""));
        }

        /// &lt;summary&gt;
        /// Decrypts an encrypted file with the FileEncrypt method through its path and the plain password.
        /// &lt;/summary&gt;
        /// &lt;param name=""inputFile""&gt;&lt;/param&gt;
        /// &lt;param name=""outputFile""&gt;&lt;/param&gt;
        /// &lt;param name=""password""&gt;&lt;/param&gt;
        private static string FileDecrypt(string inputFile, string password)
        {
            return Crypto.DecryptStringAES(File.ReadAllText(inputFile), password);
        }
    }
    public class Crypto
    {

        //While an app specific salt is not the best practice for
        //password based encryption, it's probably safe enough as long as
        //it is truly uncommon. Also too much work to alter this answer otherwise.
        private static byte[] _salt = Encoding.ASCII.GetBytes(""rxONBa*&amp;e03!%76N9mBlbR#@Xl&amp;A&amp;w"");

        /// &lt;summary&gt;
        /// Encrypt the given string using AES.  The string can be decrypted using 
        /// DecryptStringAES().  The sharedSecret parameters must match.
        /// &lt;/summary&gt;
        /// &lt;param name=""plainText""&gt;The text to encrypt.&lt;/param&gt;
        /// &lt;param name=""sharedSecret""&gt;A password used to generate a key for encryption.&lt;/param&gt;
        public static string EncryptStringAES(string plainText, string sharedSecret)
        {
            if (string.IsNullOrEmpty(plainText))
                throw new ArgumentNullException(""plainText"");
            if (string.IsNullOrEmpty(sharedSecret))
                throw new ArgumentNullException(""sharedSecret"");

            string outStr = null;                       // Encrypted string to return
            RijndaelManaged aesAlg = null;              // RijndaelManaged object used to encrypt the data.

            try
            {
                // generate the key from the shared secret and the salt
                Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(sharedSecret, _salt);

                // Create a RijndaelManaged object
                aesAlg = new RijndaelManaged();
                aesAlg.Key = key.GetBytes(aesAlg.KeySize / 8);
                aesAlg.Padding = PaddingMode.PKCS7;
                // Create a decryptor to perform the stream transform.
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

                // Create the streams used for encryption.
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    // prepend the IV
                    msEncrypt.Write(BitConverter.GetBytes(aesAlg.IV.Length), 0, sizeof(int));
                    msEncrypt.Write(aesAlg.IV, 0, aesAlg.IV.Length);
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {
                            //Write all data to the stream.
                            swEncrypt.Write(plainText);
                        }
                    }
                    outStr = Convert.ToBase64String(msEncrypt.ToArray());
                }
            }
            finally
            {
                // Clear the RijndaelManaged object.
                if (aesAlg != null)
                    aesAlg.Clear();
            }

            // Return the encrypted bytes from the memory stream.
            return outStr;
        }

        /// &lt;summary&gt;
        /// Decrypt the given string.  Assumes the string was encrypted using 
        /// EncryptStringAES(), using an identical sharedSecret.
        /// &lt;/summary&gt;
        /// &lt;param name=""cipherText""&gt;The text to decrypt.&lt;/param&gt;
        /// &lt;param name=""sharedSecret""&gt;A password used to generate a key for decryption.&lt;/param&gt;
        public static string DecryptStringAES(string cipherText, string sharedSecret)
        {
            if (string.IsNullOrEmpty(cipherText))
                throw new ArgumentNullException(""cipherText"");
            if (string.IsNullOrEmpty(sharedSecret))
                throw new ArgumentNullException(""sharedSecret"");

            // Declare the RijndaelManaged object
            // used to decrypt the data.
            RijndaelManaged aesAlg = null;

            // Declare the string used to hold
            // the decrypted text.
            string plaintext = null;

            try
            {
                // generate the key from the shared secret and the salt
                Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(sharedSecret, _salt);

                // Create the streams used for decryption.                
                byte[] bytes = Convert.FromBase64String(cipherText);
                using (MemoryStream msDecrypt = new MemoryStream(bytes))
                {
                    // Create a RijndaelManaged object
                    // with the specified key and IV.
                    aesAlg = new RijndaelManaged();
                    aesAlg.Key = key.GetBytes(aesAlg.KeySize / 8);
                    // Get the initialization vector from the encrypted stream
                    aesAlg.IV = ReadByteArray(msDecrypt);
                    aesAlg.Padding = PaddingMode.PKCS7;
                    // Create a decrytor to perform the stream transform.
                    ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))

                            // Read the decrypted bytes from the decrypting stream
                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();
                    }
                }
            }
            finally
            {
                // Clear the RijndaelManaged object.
                if (aesAlg != null)
                    aesAlg.Clear();
            }

            return plaintext;
        }

        private static byte[] ReadByteArray(Stream s)
        {
            byte[] rawLength = new byte[sizeof(int)];
            if (s.Read(rawLength, 0, rawLength.Length) != rawLength.Length)
            {
                throw new SystemException(""Stream did not contain properly formatted byte array"");
            }

            byte[] buffer = new byte[BitConverter.ToInt32(rawLength, 0)];
            if (s.Read(buffer, 0, buffer.Length) != buffer.Length)
            {
                throw new SystemException(""Did not read byte array properly"");
            }

            return buffer;
        }
    }
</code></pre>

<p>Running the following code that encrypts then decrypts will produce the error:</p>

<pre class=""lang-cs prettyprint-override""><code>static void Main(string[] args)
        {
            string password = ""Password123!"";
            encFile(@""C:\KaliPatriot\test.xml"", password);
            decFile(@""C:\KaliPatriot\test.dat"", password);
            Console.WriteLine(output);
        }
</code></pre>

<p>But if you try first running this code that only encrypts the file:</p>

<pre class=""lang-cs prettyprint-override""><code>static void Main(string[] args)
        {
            string password = ""Password123!"";
            encFile(@""C:\KaliPatriot\test.xml"", password);
        }
</code></pre>

<p>and then decrypting the file in another process after the encryption:</p>

<pre class=""lang-cs prettyprint-override""><code>static void Main(string[] args)
        {
            string password = ""Password123!"";
            decFile(@""C:\KaliPatriot\test.dat"", password);
            Console.WriteLine(output);
        }
</code></pre>

<p>Then the program will output the contents correctly, without an error.</p>

<p>How can I encrypt and decrypt the file in one run, without any errors.</p>
","<p>The variable <code>password</code>, and the parameter with the same name, point to the same constant string. The first of your methods will zero that string out.  </p>

<pre><code>    static void Main(string[] args)
    {
        string password = ""Password123!"";

        encFile(@""C:\KaliPatriot\test.xml"", password);
        // password is now ""\0\0\0\0\0\0\0\0\0""            
        decFile(@""C:\KaliPatriot\test.dat"", password);
        Console.WriteLine(output);
    }
</code></pre>

<p>Using  a string like this is very dangerous. Strings are supposed (and assumed) to be immutable and .NET also uses interning for strings. </p>

<p>You have managed to get UB (Undefined Behaviour) in C#, not something to be proud of. </p>
","87","<c#><encryption><aes><rijndael>","1","1","1","2019-06-02 07:05:18","56406715","0","","60761","","2019-06-01 12:17:28","2019-06-01 10:18:15",""
"35517712","Program crashes when setting values in Rijndael class","<p>I currently have the following code.</p>

<p>I am generating a <code>byte array</code> from a hard coded random <code>string</code>.</p>

<p>Now I noticed that when setting up a <code>Rijndael</code> class the application crashes when setting the key value. Any suggestions on why it crashes when the key value is set.</p>

<pre><code>int olength = 18; 
string HKey = ""ABCDEFGHIJKL111100002222""; //Some random string 
byte[] key = Convert.FromBase64String(HardcodedKey); //key.length = 18
byte[] iv = Encryption.GenerateRandomBytes(olength);
CryptoStream cs = Encryption.AES128Stream(key, iv, Context.Response.Body);
</code></pre>

<p>Now the above method being called is give below</p>

<pre><code>public static CryptoStream AES128Stream(byte[] key, byte[] iv, Stream stream)
{
    try
    {
        Rijndael rijndael = Rijndael.Create();
        rijndael.Mode = CipherMode.CBC;
        rijndael.Padding = PaddingMode.PKCS7;
        rijndael.KeySize = 128;
        rijndael.BlockSize = 128;
        rijndael.Key = key;  ///----&gt;CRASHES HERE
        rijndael.IV = iv;

        ICryptoTransform rijndaelEncryptor = rijndael.CreateEncryptor();
        return new CryptoStream(stream, rijndaelEncryptor, CryptoStreamMode.Write);
    }
    catch (Exception e)
    {
        throw e;
    }
}
</code></pre>

<p>In additional information it states</p>

<blockquote>
  <p>Additional information: Specified key is not a valid size for this
  algorithm.</p>
</blockquote>

<p>In that case what string can I use that will work ? Why is this string not working ?</p>
","<p>Since you define the Rjindael to be having keysize of 128-bit, you have to give exactly 16 bytes to the class to work. Your key seems to be too long (or too short).</p>

<p>Also, since I cannot know your true key, I do not know if your <code>Convert.FromBase64String()</code> is correctly used or not. But, I suggest you can directly use <code>byte[]</code> to avoid that problem:</p>

<pre><code>//put 16 to be really sure.
byte[] key = new byte[16] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
</code></pre>
","87","<c#><rijndael><rijndaelmanaged><cryptostream>","0","3","1","2016-02-20 19:12:01","35517801","2","","5666987","","2016-02-20 19:12:01","2016-02-20 00:49:14",""
"32446034","ways to implement Rijndael-256 ECB in Java","<p>What are the ways to implement Rijndael-256 with ECB mode in Java?
I've found some variants of AES but I need exactly Rijndael-256. </p>

<p>If there is already an answer to it, I would appreciate someone referring me to it
,since I haven't found any.</p>
","","82","<java><encryption><aes><rijndael><ecb>","0","","0","2015-09-07 21:30:48","","3","","","","","2015-09-07 21:05:57","2015-09-08 01:10:22"
"27673123","what is wrong in my Rijndael that gives me this?","<p>I'm using the Rijndael classes from .net System.Security to Encrypt my RSA Keys</p>

<p>this is how I set it up:</p>

<pre><code>static Rijndael CreateRijndael (byte[] userID, string password, string pepper)
{
    if (userID == null)
        throw new ArgumentNullException (""userID"");
    if (password == null)
        throw new ArgumentNullException (""password"");
    if (pepper == null)
        throw new ArgumentNullException (""pepper"");
    string passpepper = password + pepper;
    Rijndael Rij = Rijndael.Create ();
    Rij.KeySize = 256;
    Rij.Padding = PaddingMode.ISO10126;
    Rij.Mode = CipherMode.CBC;
    Rfc2898DeriveBytes aesKey = new Rfc2898DeriveBytes (passpepper, userID, 65536);
    Rij.Key = aesKey.GetBytes (Rij.KeySize / 8);
    Rij.GenerateIV ();
    return Rij;
}
</code></pre>

<p>and this is what I get:</p>

<pre><code>逫⇾귏䜪춈票칔alue&gt;&lt;Modulus&gt;kgOu5EG6vbabnvq6xB+cRmxDL....
</code></pre>

<p>Instead of</p>

<pre><code>&lt;RSAKeyValue&gt;&lt;Modulus&gt;kgOu5EG6vbabnvq6xB+cRmxDL...
</code></pre>

<p>Is it the IV?<br>
If it is the IV shouldn't it jumble the whole text considering I've set the mode to CBC?  </p>
","<p>As you guessed, it is an initialization vector problem.</p>

<p>On encryption, you should use a random initialization vector, and send it (or store it, in your case) with the ciphertext. On decryption, you should use the same initialization vector as was used for encryption, <strong>not a random one</strong>.</p>

<p>With CBC mode, as you are using here, a wrong initialization vector causes just the first block (i.e. 16 bytes for AES) to be garbage, the rest of the content stays okay.  The reason is, that each block after the first one is XOR-ed with the previous' block's ciphertext after decryption (and before encryption), and that doesn't depend on the IV.</p>

<p>With other modes of operation, you could get a totally garbled plaintext.</p>
","81","<initialization-vector><rijndael>","1","5","1","2014-12-28 01:59:19","27673124","0","","","","","2014-12-27 16:09:43",""
"53469954","Converting Rijndael encryption from python 2 to 3","<p>I am trying to update some code from python2 to 3 and have some issues with a specific encryption function. This is the python 2 code:</p>

<pre><code>trans_raw = '6c9474469ddf7578f3e5ad8a4c703d99'
raw_prime = '583423bbbf900e9a211664861e28c9f347835017'

transkey = trans_raw.decode('hex')
prime = raw_prime.decode('hex')[:16]

r = rijndael.rijndael(transkey)
result = r.encrypt(prime).encode('hex')

print result

#result = fa016bdda2f884d9126fc746f5a00714
</code></pre>

<p>the rijndael used in this function was from this: <a href=""https://github.com/sectroyer/SmartCrypto/blob/master/PySmartCrypto/rijndael.py"" rel=""nofollow noreferrer"">https://github.com/sectroyer/SmartCrypto/blob/master/PySmartCrypto/rijndael.py</a></p>

<p>I have tried converting this to python3 but i dont feel like im coming anywhere close.
This is what i have tried</p>

<pre><code>trans_raw = '6c9474469ddf7578f3e5ad8a4c703d99'
raw_prime = '583423bbbf900e9a211664861e28c9f347835017'

transkey = binascii.unhexlify(trans_raw)
prime = binascii.unhexlify(raw_prime)[:16]

r = AES.new(transkey, AES.MODE_ECB)
ciphertext = r.encrypt(prime)
result = binascii.hexlify(ciphertext).decode('utf-8')
print(result)

#result = ba5a2b6bb7176dd321250e7d672b0a4a
</code></pre>

<p>i have tried using <a href=""https://gist.github.com/jeetsukumaran/1291836#gistcomment-901601"" rel=""nofollow noreferrer"">https://gist.github.com/jeetsukumaran/1291836#gistcomment-901601</a>
which someone in the comments said was updated for python 3. I have also tried using the built in python AES.new(transkey, AES.MODE_ECB) but neither of those options return anything close to what i am looking for. Does anyone know what i am missing?</p>
","","79","<python><python-3.x><encryption><rijndael>","0","","0","2018-11-25 18:02:17","","9","","4111447","","2018-11-25 18:02:17","2018-11-25 17:20:16",""
"15136900","Padding is invalid and cannot be removed aes","<p>I have searched solutions on this website but none solved my problem. Sometimes I recieve ""padding is invalid and cannot be removed"" exception. I don't know what to do. When I tried some solutions, there was empty decrypted text or it didn't work.
Here's my class</p>

<pre><code>static class Aes
{
    public static string bytesToHexString(byte[] key)
    {
        return BitConverter.ToString(key).Replace(""-"", String.Empty);
    }

    public static byte[] stringToBytes(string key)
    {
        return Enumerable.Range(0, key.Length)
                 .Where(x =&gt; x % 2 == 0)
                 .Select(x =&gt; Convert.ToByte(key.Substring(x, 2), 16))
                 .ToArray();
    }

    public static void generateKeyAndIv(out byte[] key, out byte[] IV)
    {
        using (AesCryptoServiceProvider aesAlg = new AesCryptoServiceProvider())
        {
            aesAlg.BlockSize = 128;
            aesAlg.KeySize = 256;
            aesAlg.Padding = PaddingMode.PKCS7;
            aesAlg.Mode = CipherMode.CBC;
            aesAlg.GenerateKey();
            aesAlg.GenerateIV();
            key = aesAlg.Key;
            IV = aesAlg.IV;
        }
    }
    public static string EncryptStringToString(string plainText, byte[] Key, byte[] IV)
    {
        byte[] bytes =EncryptStringToBytes_Aes(plainText, Key, IV);
        return Convert.ToBase64String(bytes);
        //return Encoding.UTF8.GetString(bytes, 0, bytes.Length);
    }

    public static string DecryptStringToString(string cipherText, byte[] Key, byte[] IV)
    {
        //byte[] bytes = Encoding.UTF8.GetBytes(cipherText);
        byte[] bytes = Convert.FromBase64String(cipherText);
        return DecryptStringFromBytes_Aes(bytes, Key, IV);
    }

    public static byte[] EncryptStringToBytes_Aes(string plainText, byte[] Key, byte[] IV)
    {
        // Check arguments. 
        if (plainText == null || plainText.Length &lt;= 0)
            throw new ArgumentNullException(""plainText"");
        if (Key == null || Key.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        if (IV == null || IV.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        byte[] encrypted;
        // Create an AesCryptoServiceProvider object 
        // with the specified key and IV. 
        using (AesCryptoServiceProvider aesAlg = new AesCryptoServiceProvider())
        {
            aesAlg.BlockSize = 128;
            aesAlg.KeySize = 256;
            aesAlg.Padding = PaddingMode.PKCS7;
            aesAlg.Mode = CipherMode.CBC;
            aesAlg.Key = Key;
            aesAlg.IV = IV;
            // Create a decrytor to perform the stream transform.
            ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);


            // Create the streams used for encryption. 
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(plainText);
                    }
                }

                encrypted = msEncrypt.ToArray();
            }
           /* using (var msEncrypt = new MemoryStream())
            using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
            using (var swEncrypt = new StreamWriter(csEncrypt))
            {
                swEncrypt.Write(plainText);
                csEncrypt.FlushFinalBlock();
                encrypted = msEncrypt.ToArray();
            }*/
        }


        // Return the encrypted bytes from the memory stream. 
        return encrypted;

    }

    public static string DecryptStringFromBytes_Aes(byte[] cipherText, byte[] Key, byte[] IV)
    {
        // Check arguments. 
        if (cipherText == null || cipherText.Length &lt;= 0)
            throw new ArgumentNullException(""cipherText"");
        if (Key == null || Key.Length &lt;= 0)
            throw new ArgumentNullException(""Key"");
        if (IV == null || IV.Length &lt;= 0)
            throw new ArgumentNullException(""IV"");

        // Declare the string used to hold 
        // the decrypted text. 
        string plaintext = null;

        // Create an AesCryptoServiceProvider object 
        // with the specified key and IV. 
        using (AesCryptoServiceProvider aesAlg = new AesCryptoServiceProvider())
        {
            aesAlg.BlockSize = 128;
            aesAlg.KeySize = 256;
            aesAlg.Padding = PaddingMode.PKCS7;
            aesAlg.Mode = CipherMode.CBC;
            aesAlg.Key = Key;
            aesAlg.IV = IV;
            // Create a decrytor to perform the stream transform.
            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

            // Create the streams used for decryption. 
            using (MemoryStream msDecrypt = new MemoryStream(cipherText))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {

                        // Read the decrypted bytes from the decrypting stream 
                        // and place them in a string.
                        plaintext = srDecrypt.ReadToEnd();
                    }
                }
            }

        }

        return plaintext;

    }
}
</code></pre>

<p>Please help because I'm exhausted by finding solution on my own</p>
","","77","<c#><.net><aes><encryption-symmetric><rijndael>","0","","0","2013-02-28 14:15:05","","8","","2119757","","2013-02-28 14:15:05","2013-02-28 13:34:48","2013-02-28 21:55:25"
"57965316","Rijndael 256 encryption with Java & Bouncy Castle","<p>I'm working on a project built in pure php, i'm doing a rework on the login, but the users in the database are cipher in Rijndael-256, i've tried a lot of things and nothing seems to work, and i feel i'm so close with this code, but it doesn't work, and i'm really lost</p>

<pre><code>private final String key = ""..."";

public String decrypt(String password, String cypherKey) {
    try {
        password = password.substring(0, password.lenght() - 1); // 1
        byte[] passwordBytes = password.getBytes(""UTF-8"");
        byte[] key = cypherKey.getBytes(""UTF-8"");

        RijndaelEngine rijndaelEngine = new RijndaelEngine(256);
        KeyParameter keyParam = new KeyParameter(key);
        rijndaelEngine.init(false, keyParam); // 2
        PaddedBufferedBlockCipher bufferedBlock = new PaddedBufferedBlockCipher(rijndaelEngine, new ZeroBytePadding());

        byte[] decryptedBytes = new byte[bufferedBlock.getOutputSize(passwordBytes.length)];
        int processed = bufferedBlock.processBytes(passwordBytes, 0, passwordBytes.length, decryptedBytes, 0);

        return String.valueOf(bufferedBlock.doFinal(decryptedBytes, processed));
    } catch (Exeption e) {
        e.printStackTrace();
    }

    return """"; // I know this is awful but i was trying something and left this like that
}
</code></pre>

<p>*1)  I don't know if this is right but all the encrypted passwords end with equals sign and i tested with an encryption tool and i don't think it's needed</p>

<p>2) False is decryption mode</p>

<p><strong>Stack trace</strong>: org.bouncycastle.crypto.DataLengthException: last block incomplete in decryption</p>

<p>I'm working on this decryption for two weeks now, i'm really desperate :(</p>

<p>PHP code: </p>

<pre><code>function fnEncrypt($sValue) 
{ 
    include(""constants.php"");

    return trim( 
        base64_encode( 
            mcrypt_encrypt( 

                MCRYPT_RIJNDAEL_256,
                $SecretKey, $sValue,
                MCRYPT_MODE_ECB,


                mcrypt_create_iv( 
                    mcrypt_get_iv_size( 
                        MCRYPT_RIJNDAEL_256,  
                        MCRYPT_MODE_ECB 
                    ),


                    MCRYPT_RAND) 
                ) 
            ) 
        ); 
} 

function fnDecrypt($sValue) 
{ 
    include(""constants.php"");

    return trim( 
        mcrypt_decrypt( 
            MCRYPT_RIJNDAEL_256,  
            $sSecretKey,  
            base64_decode($sValue),  
            MCRYPT_MODE_ECB, 

            mcrypt_create_iv(
                mcrypt_get_iv_size( 
                    MCRYPT_RIJNDAEL_256, 
                    MCRYPT_MODE_ECB 
                ),  
                MCRYPT_RAND 
            ) 
        ) 
    ); 
}
</code></pre>
","<p>In the <code>decrypt</code>-method, the ciphertext must first be Base64-decoded (1). In addition, the length of the decrypted text is not determined correctly (2a) and the length of the corresponding byte-array is not adjusted accordingly (2b). Finally, there is a problem in determining the UTF8-string from the byte-array (3). Modify the body of the <code>decrypt</code>-method as follows:</p>

<pre><code>//password = password.substring(0, password.lenght() - 1); // 1                             // Remove
//byte[] passwordBytes = password.getBytes(""UTF-8"");                                        // Remove
byte[] passwordBytes = Base64.getDecoder().decode(password);                                // Base64-decode the ciphertext (1)
byte[] key = cypherKey.getBytes(""UTF-8"");

RijndaelEngine rijndaelEngine = new RijndaelEngine(256);
KeyParameter keyParam = new KeyParameter(key);
rijndaelEngine.init(false, keyParam); // 2
PaddedBufferedBlockCipher bufferedBlock = new PaddedBufferedBlockCipher(rijndaelEngine, new ZeroBytePadding());

byte[] decryptedBytes = new byte[bufferedBlock.getOutputSize(passwordBytes.length)];
int processed = bufferedBlock.processBytes(passwordBytes, 0, passwordBytes.length, decryptedBytes, 0);
processed += bufferedBlock.doFinal(decryptedBytes, processed);                              // Refresh the parameter containing the length of the decrypted data (2a)
decryptedBytes = Arrays.copyOfRange(decryptedBytes, 0, processed);                          // Reduce the byte-array accordingly (2b)

//return String.valueOf(bufferedBlock.doFinal(decryptedBytes, processed));                  // Remove           
return new String(decryptedBytes, ""UTF-8"");                                                 // Create a UTF-8 string from the byte-array (3)
</code></pre>

<p>with the imports <code>java.util.Base64</code> and <code>org.bouncycastle.util.Arrays</code>.</p>

<p>Even though this is probably legacy code, two notes on security: Passwords should generally not be encrypted, but <a href=""https://www.darkreading.com/safely-storing-user-passwords-hashing-vs-encrypting/a/d-id/1269374"" rel=""nofollow noreferrer"">hashed</a>. In addition, <a href=""https://crypto.stackexchange.com/a/20946"">ECB</a> is insecure.  </p>
","74","<java><encryption><rijndael>","1","1","2","2019-09-18 14:59:24","","4","","12060266","","2019-09-17 14:01:17","2019-09-16 22:58:19",""
"57965316","Rijndael 256 encryption with Java & Bouncy Castle","<p>I'm working on a project built in pure php, i'm doing a rework on the login, but the users in the database are cipher in Rijndael-256, i've tried a lot of things and nothing seems to work, and i feel i'm so close with this code, but it doesn't work, and i'm really lost</p>

<pre><code>private final String key = ""..."";

public String decrypt(String password, String cypherKey) {
    try {
        password = password.substring(0, password.lenght() - 1); // 1
        byte[] passwordBytes = password.getBytes(""UTF-8"");
        byte[] key = cypherKey.getBytes(""UTF-8"");

        RijndaelEngine rijndaelEngine = new RijndaelEngine(256);
        KeyParameter keyParam = new KeyParameter(key);
        rijndaelEngine.init(false, keyParam); // 2
        PaddedBufferedBlockCipher bufferedBlock = new PaddedBufferedBlockCipher(rijndaelEngine, new ZeroBytePadding());

        byte[] decryptedBytes = new byte[bufferedBlock.getOutputSize(passwordBytes.length)];
        int processed = bufferedBlock.processBytes(passwordBytes, 0, passwordBytes.length, decryptedBytes, 0);

        return String.valueOf(bufferedBlock.doFinal(decryptedBytes, processed));
    } catch (Exeption e) {
        e.printStackTrace();
    }

    return """"; // I know this is awful but i was trying something and left this like that
}
</code></pre>

<p>*1)  I don't know if this is right but all the encrypted passwords end with equals sign and i tested with an encryption tool and i don't think it's needed</p>

<p>2) False is decryption mode</p>

<p><strong>Stack trace</strong>: org.bouncycastle.crypto.DataLengthException: last block incomplete in decryption</p>

<p>I'm working on this decryption for two weeks now, i'm really desperate :(</p>

<p>PHP code: </p>

<pre><code>function fnEncrypt($sValue) 
{ 
    include(""constants.php"");

    return trim( 
        base64_encode( 
            mcrypt_encrypt( 

                MCRYPT_RIJNDAEL_256,
                $SecretKey, $sValue,
                MCRYPT_MODE_ECB,


                mcrypt_create_iv( 
                    mcrypt_get_iv_size( 
                        MCRYPT_RIJNDAEL_256,  
                        MCRYPT_MODE_ECB 
                    ),


                    MCRYPT_RAND) 
                ) 
            ) 
        ); 
} 

function fnDecrypt($sValue) 
{ 
    include(""constants.php"");

    return trim( 
        mcrypt_decrypt( 
            MCRYPT_RIJNDAEL_256,  
            $sSecretKey,  
            base64_decode($sValue),  
            MCRYPT_MODE_ECB, 

            mcrypt_create_iv(
                mcrypt_get_iv_size( 
                    MCRYPT_RIJNDAEL_256, 
                    MCRYPT_MODE_ECB 
                ),  
                MCRYPT_RAND 
            ) 
        ) 
    ); 
}
</code></pre>
","<p>This was my solution:</p>

<pre><code>/**
     * Step 1: password and key are converted to bytes in order to be processed by the cypher.
     *
     * Step 2: a KeyParameter is created with the key bytes.
     *
     * Step 3: a PaddedBufferedBlockCipher statement is assigned with Rijndael 256 algorithm and ZeroBytePadding, this padder adds NULL byte padding to a block.
     *
     * Step 4: the bufferedBlockCipher is then initialized with parameters ""true"" meaning Encryption mode, and the KeyParameter.
     * This initialization prepares the bufferedBlock with the parameters needed for encryption.
     *
     * Step 5: a variable ""buffer"" stores the length in bytes the output should have
     *
     * Step 6: the processed bytes are calculated and stored, buffer now stores the value of the password
     *
     * Step 7: the encryption is finalized, the plus equals sign ensures that the output is multiple of 32
     *
     * Step 8: the buffer and processedBytes are converted into an array of bytes and then a String
     *
     * @param password
     *
     * @return
     */

    public String encrypt(String password) throws InvalidCipherTextException {
        byte[] data = password.getBytes();
        byte[] encryptionKey = key.getBytes();

        KeyParameter keyParameter = new KeyParameter(encryptionKey);

        PaddedBufferedBlockCipher bufferedBlockCipher = new PaddedBufferedBlockCipher(new RijndaelEngine(256), new ZeroBytePadding());
        bufferedBlockCipher.init(true, keyParameter);

        byte[] buffer = new byte[bufferedBlockCipher.getOutputSize(data.length)];
        int processedBytes = bufferedBlockCipher.processBytes(data, 0, data.length, buffer, 0);
        processedBytes += bufferedBlockCipher.doFinal(buffer, processedBytes);

        byte[] result = Arrays.copyOfRange(buffer, 0, processedBytes);
        String output = Base64.encodeBase64String(result);

        return output;
    }
</code></pre>
","74","<java><encryption><rijndael>","1","0","2","2019-09-18 14:59:24","","4","","12060266","","2019-09-17 14:01:17","2019-09-16 22:58:19",""
"58415430","AES Rijndael decryption C#","<p>I have to decrypt some data that are sent encrypted using AES256 Rijndael.
I have the encryption/decryption mechanism used by my partner, developed in JAVA, that I'm not very familiar with, but can't transpose it in C#.</p>

<p>The secret key that has been given to me is 10 chars long.</p>

<p>I think that below code is ok, excepted the IV calculation. 
You'll find first the java code, and then the C# : </p>

<pre class=""lang-java prettyprint-override""><code>import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
public class UtilsCrypto {

    /* Rijndael/CFB8/NoPadding is default cipher */
    final static String CHIPHER = ""Rijndael/CFB8/NoPadding"";

    public static final String  MESSAGE_DIGEST_ALGORITHM    = ""MD5"";
    public static final String  AES                         = ""AES"";
    public static final String  AES_ECB_NO_PADDING          = ""AES/ECB/NoPadding"";

    private static byte[] md5(final String input) throws NoSuchAlgorithmException {
        final MessageDigest md = MessageDigest.getInstance(MESSAGE_DIGEST_ALGORITHM);
        return md.digest(input.getBytes());
    }

    private Cipher initCipher(final int mode, final String secretKey) throws Exception {
        final byte[] key = md5(secretKey);
        final byte[] iv = md5(secretKey);

        final SecretKeySpec skeySpec = new SecretKeySpec(key, AES);

        /* This valid with other ciphers than Rijndael/CFB8/NoPadding */
        // final IvParameterSpec initialVector = new IvParameterSpec(iv);

        /* Use this with Rijndael/CFB8/NoPadding */
        final IvParameterSpec initialVector = new IvParameterSpec(getIvBytes(iv));

        final Cipher cipher = Cipher.getInstance(CHIPHER);
        cipher.init(mode, skeySpec, initialVector);

        return cipher;
    }

    public String encrypt(final String dataToEncrypt, final String secretKey) {
        if (Utils.isEmpty(secretKey))
            return dataToEncrypt;

        String encryptedData = null;
        try {
            final Cipher cipher = initCipher(Cipher.ENCRYPT_MODE, secretKey);
            final byte[] encryptedByteArray = cipher.doFinal(dataToEncrypt.getBytes(Charset.forName(""UTF8"")));
            final BASE64Encoder enc = new BASE64Encoder();
            encryptedData = enc.encode(encryptedByteArray);
            encryptedData = encryptedData.replace(""+"", ""-"");
            encryptedData = encryptedData.replace(""/"", ""_"");
        } catch (Exception e) {
            System.err.println(""Problem encrypting the data"");
            e.printStackTrace();
        }

        return encryptedData;
    }

    public String decrypt(final String encryptedData, final String secretKey) {
        String decryptedData = null;
        String inData = encryptedData;
        try {
            final Cipher cipher = initCipher(Cipher.DECRYPT_MODE, secretKey);
            final BASE64Decoder dec = new BASE64Decoder();
            inData = inData.replace(""-"", ""+"");
            inData = inData.replace(""_"", ""/"");
            final byte[] encryptedByteArray = dec.decodeBuffer(inData); // ok
            final byte[] decryptedByteArray = cipher.doFinal(encryptedByteArray);
            decryptedData = new String(decryptedByteArray, ""UTF8"");
        } catch (Exception e) {
            System.err.println(""Problem decrypting the data"");
            e.printStackTrace();
        }
        return decryptedData;
    }

    /**
     * This method is only for Rijndael/CFB8/NoPadding
     * 
     * @param hashedKey
     *            md5
     * @return byte array
     * @throws Exception
     *             If any exceptions.
     */
     // on passe en arg le hash de la clé
    protected byte[] getIvBytes(byte[] hashedKey) throws Exception {
        byte[] inputBytes = new byte[16]; // init son tableau a 16 bytes
        final SecretKey key = new SecretKeySpec(hashedKey, AES); // secretKey
        final Cipher cipher = Cipher.getInstance(AES_ECB_NO_PADDING); 
        cipher.init(Cipher.ENCRYPT_MODE, key); // chiffre sa clé en AES avec un IV
        return cipher.doFinal(inputBytes);
    }
}
</code></pre>

<p>now this is what I tried so far : </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Xml;
using System.Net;
using System.Web;
using System.Web.Services;
using Newtonsoft.Json;
using System.Security.Cryptography;
using System.Text;

namespace test
{
        public byte[] getIVBytes(byte[] hashedKey)
        {
            byte[] inputBytes = new byte[16];
            AesManaged tdes = new AesManaged();
            tdes.Key = hashedKey;
            tdes.Mode = CipherMode.ECB;
            tdes.BlockSize = 128;
            tdes.Padding = PaddingMode.None;
            ICryptoTransform crypt = tdes.CreateEncryptor();
            byte[] bla =  crypt.TransformFinalBlock(hashedKey, 0, inputBytes.Length);
            return bla;
        }

        [WebMethod]
        public string decrypt(String input, String key)
        {
            byte[] md5KeyHash;
            using (MD5 md5 = MD5.Create())
            {
                md5KeyHash = md5.ComputeHash(Encoding.UTF8.GetBytes(key));
            }
            input = input.Replace(""-"", ""+"");
            input = input.Replace(""_"", ""/"");
            input = input.Replace("" "", """");
            byte[] data = Convert.FromBase64String(input); // récupérer l'array de bytes du message chiffré encodé en b64
            String decrypted;
            using (RijndaelManaged rijAlg = new RijndaelManaged())
            {
                rijAlg.Mode = CipherMode.CFB;
                rijAlg.BlockSize = 128;
                rijAlg.Padding = PaddingMode.None;
                rijAlg.Key = md5KeyHash;
                rijAlg.IV = getIVBytes(md5KeyHash);

                ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, null);
                using (MemoryStream msDecrypt = new MemoryStream(data))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {
                            decrypted = srDecrypt.ReadToEnd();
                        }
                    }
                }
            }
            return decrypted;
}
</code></pre>

<p>Code seems to be ""correct"" because no errors are thrown except this : 
XML Error analysis : An Invalid character was found in text content.
At: <a href=""http://localhost:55175/WebService1.asmx/decrypt"" rel=""nofollow noreferrer"">http://localhost:55175/WebService1.asmx/decrypt</a>
line 2, col44 :�Me����&#x13;>m�H�ZԤ�af2ɾ`A�ٖ�H$�&amp;/</p>

<p>What am I missing ?</p>
","<p>There are some bugs in the C#-code:</p>

<ul>
<li><p>In the <code>getIVBytes</code>-method, replace line </p>

<pre><code>byte[] bla = crypt.TransformFinalBlock(hashedKey, 0, inputBytes.Length);
</code></pre>

<p>by </p>

<pre><code>byte[] bla = crypt.TransformFinalBlock(inputBytes, 0, inputBytes.Length); // encrypt inputBytes
</code></pre></li>
<li><p>In the <code>decrypt</code>-method, add before the <code>CreateDecryptor</code>-call</p>

<pre><code>rijAlg.FeedbackSize = 8; // Use CFB8
</code></pre>

<p>and replace line </p>

<pre><code>ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, null);
</code></pre>

<p>by</p>

<pre><code>ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV); // Consider the IV
</code></pre></li>
</ul>

<p>Then the posted ciphertext can be decrypted with the C#-code into the posted plaintext.</p>
","72","<java><c#><encryption><aes><rijndael>","1","1","1","2019-10-16 23:12:56","","6","","","","","2019-10-16 14:12:46",""
"56417217","Rijndael Padding in Python","<p>I know where the problem is but I don't know how to fix it. The problem is with the padding. I have absolutely no idea about it and how it works. I tried searching online but nothing seemed to help. I am trying to implement this function to work with my <a href=""https://hackhex.com/"" rel=""nofollow noreferrer"">website</a>. The python encrypts and sends the data and PHP decrypts it.</p>

<p>Here's the actual code of my python:</p>

<pre><code>from rijndael.cipher.crypt import new
from rijndael.cipher.blockcipher import MODE_CBC
import base64

PADDING = b'.'

def r_pad(payload, block_size=32):
    return payload + (block_size - len(payload) % block_size) * PADDING

KEY = 'lkirwf897+22#bbtrm8814z5qq=498j5'
IV = '741952hheeyy66#cs!9hjv887mxx7@8y'
plain_text = ""A padded string to BLOCKSIZE length.""

rjn = new(KEY, MODE_CBC, IV, blocksize=32)
encd = rjn.encrypt(r_pad(plain_text))
data = base64.b64encode(encd)
print(data)

rjn = new(KEY, MODE_CBC, IV, blocksize=32)
data = base64.b64decode(data)
decd = rjn.decrypt(r_pad(data))
print (decd)
</code></pre>

<p>This is the output:</p>

<blockquote>
  <p>Dv0Y/AFXdFMlDrcldFCu8v5o9zAlLNgyM+vO+PFeSrqWdzP1S1cumviFiEjNAjz5njnMMC9lfxsBl71x5y+xCw==</p>
  
  <p>A padded string to BLOCKSIZE length.............................Å¿:è°⌐┘n┤«╞Px╜:æC┬♣╬Q┤▼«U_♦â☻ìr</p>
</blockquote>

<p>I need the output of the encrypted string to be something like this:</p>

<blockquote>
  <p>Dv0Y/AFXdFMlDrcldFCu8v5o9zAlLNgyM+vO+PFeSrpO8Ve82mdUcc4rkzp9afDYc75NmkSd4mdflt38kceOdA==</p>
  
  <p>A padded string to BLOCKSIZE length</p>
</blockquote>

<p>I tried to make RIJNDAEL256 function out of this code:</p>

<pre><code>EncryptRJ256(""lkirwf897+22#bbtrm8814z5qq=498j5"", ""741952hheeyy66#cs!9hjv887mxx7@8y"", ""A padded string to BLOCKSIZE length."")

Public Function EncryptRJ256(ByVal prm_key As String, ByVal prm_iv As String, ByVal prm_text_to_encrypt As String) As String
    Dim s As String = prm_text_to_encrypt
    Dim managed2 As New RijndaelManaged With {
    .Padding = PaddingMode.Zeros,
    .Mode = CipherMode.CBC,
    .BlockSize = 256
}
    Dim stream As New MemoryStream
    Dim stream2 As New CryptoStream(stream, managed2.CreateEncryptor(Encoding.ASCII.GetBytes(prm_key), Encoding.ASCII.GetBytes(prm_iv)), CryptoStreamMode.Write)
    Dim bytes As Byte() = Encoding.ASCII.GetBytes(s)
    stream2.Write(bytes, 0, bytes.Length)
    stream2.FlushFinalBlock()
    Return Convert.ToBase64String(stream.ToArray)
End Function
</code></pre>

<p>Can anyone please help? I am lost at this point. :/</p>
","","70","<python><encryption><aes><padding><rijndael>","0","","0","2019-06-04 15:13:01","","3","","6748794","","2019-06-04 15:13:01","2019-06-02 17:12:24",""
"50866418","Binary operations in js","<p>I've been trying to figure out how to implement some stuff about rijndael algorithm in js. One particular step (mixColumns) requires to mess around with binary numbers. I decided to follow a guide and at a particular point it does this operation:</p>

<p>it has to multiply <code>d4 (hexadecimal)</code> by <code>2</code>. Now <code>d4</code> in binary is <code>1101 0100</code>, and it's turned into <code>1010 1000</code>. I guess this is because he left-shifted the number so the leftmost number goes away and a 0 is pushed in the right side. After that it does <code>1010 1000 XOR 0001 1011</code> and then the result is: <code>1011 0011</code>
I don't understand where those XOR and <code>0001 1011</code> come from.
I tried to do <code>10101000 ^ 00011011</code>, yet I didn't manage to get the same result.
Could anyone explain me why that? Please try to be as clear as you can, since I'm new with binaries and these operations.</p>

<p>(Also, sorry for my english or imperfections (it's my first question here));</p>

<p>By the way, I'm also trying to understand this one:</p>

<pre><code>{03} . {bf} = {10 XOR 01} . {1011 1111}
 = {1011 1111 . 10} XOR {1011 1111 . 01}
 = {1011 1111 . 10} XOR {1011 1111}
 = 0111 1110 XOR 0001 1011 XOR 1011 1111
 = 1101 1010 (ans)
</code></pre>

<p>It does more or less the same things, it converts the <code>bf</code> and the <code>3</code> in binary, then it becomes <code>10 XOR 01</code>..and then..I don't know..
still far away from the solution.</p>

<p>I also wonder if there is a simplest way to do what it does.<br>
Thanks</p>
","","66","<javascript><binary><aes><bitwise-operators><rijndael>","0","","0","2018-06-14 21:54:01","","2","","1491895","","2018-06-14 21:54:01","2018-06-14 21:50:18",""
"39851376","Implement jcryption in Objective C","<p>I need to implement <code>jcryption</code> in IOS. I have gone through the library it uses <strong>Rijndael encryption</strong> internally to encrypt the data.</p>

<p>I have tried <code>AES256EncryptWithKey</code> but it is not giving me expected encryption key.</p>

<p>Any help on this would be nice. Thanks</p>
","<p>Rijndael with a 128-bit block size is AES. Use Common Crypto on iOS, it uses the hardware encryption engine. There are several ObjC AES answers here on SO, see <a href=""https://stackoverflow.com/a/23641521/451475"">iOS AES Encryption</a>.</p>

<p>For a detailed answer you will need to provide your usage information on jCryption.</p>

<p>Also notice that jCryption has been discontinued. If you are trying to use jCryption in place of HTTPS the correct solution is to use HTTPS, see <a href=""http://www.jcryption.org"" rel=""nofollow noreferrer"">jCryption</a>.</p>
","65","<ios><objective-c><rijndael><jcryption>","1","0","1","2016-10-04 13:28:46","","0","","1850651","","2016-10-04 12:21:51","2016-10-04 11:41:28",""
"56561678","How to create RSA xmlstring using public and private key in c#","<p>How can i create RSA xml string as below if i know the private and public key (both in string format) in c#.Output should be in below format</p>

<pre><code> &lt;RSAKeyValue&gt;  
   &lt;Modulus&gt;…&lt;/Modulus&gt;  
   &lt;Exponent&gt;…&lt;/Exponent&gt;  
   &lt;P&gt;…&lt;/P&gt;  
   &lt;Q&gt;…&lt;/Q&gt;  
   &lt;DP&gt;…&lt;/DP&gt;  
   &lt;DQ&gt;…&lt;/DQ&gt;  
   &lt;InverseQ&gt;…&lt;/InverseQ&gt;  
   &lt;D&gt;…&lt;/D&gt;  
 &lt;/RSAKeyValue&gt; 
</code></pre>

<p><a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.toxmlstring?view=netframework-4.8"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.toxmlstring?view=netframework-4.8</a></p>
","","64","<c#><.net><encryption><rsa><rijndael>","0","","0","2019-06-12 11:55:47","","4","","","","","2019-06-12 11:55:47",""
"51309501","Decryption providing a padding error","<p>I'm trying to save a serialized object to an encrypted file. This isn't production quality and I am aware of the security risks with the way that I am doing this, but ignoring those I will have a key in a resource (data.Settings.key) that wont change and I have a salt that is also a constant. </p>

<p>My encryption seems to work, but decryption returns me an Exception saying that padding is invalid and cannot be closed when I try to close my CryptoStream.</p>

<pre><code>    private static byte[] decrypt(byte[] bytes)
    {
        var decryptor = algorithm.CreateDecryptor();
        using (var sMemoryStream = new MemoryStream())
        using (var sCryptoStream = new CryptoStream(sMemoryStream, decryptor, CryptoStreamMode.Write))
        {
            sCryptoStream.Write(bytes, 0, bytes.Length);
            sCryptoStream.Close();
            return sMemoryStream.ToArray();
        }
    }
</code></pre>

<p>The algorithm variable is the same one that the encrypt method uses and is built by this method which is called in the classes constructor:</p>

<pre><code>    private static SymmetricAlgorithm GetAlgorithm()
    {
        var algorithm = Rijndael.Create();

        // Create key from salt and password in config
        var rdb = new Rfc2898DeriveBytes(data.Settings.key, new byte[] {
            0x44,0x61,0x79,0x6e,0x65,0x44,0x6f,0x75,0x67,0x61,0x6e
        });
        algorithm.Padding = PaddingMode.PKCS7;

        // Set key and IV from rdb
        algorithm.Key = rdb.GetBytes(32);
        algorithm.IV = rdb.GetBytes(16);
        return algorithm;
    }
</code></pre>

<p>I've tried changing the padding mode in the algorithm but I can't understand why it's fine with this padding when encrypting, but now when decrypting.</p>

<p>If it helps here is the method that calls the decrypt method:</p>

<pre><code>    private static User OpenFile(String sUserName)
    {
        Console.WriteLine(""Opening file..."");
        using (Stream sFileStream = new FileStream(data.Settings.dir + ""data\\accounts\\"" + sUserName + "".dat"",
            FileMode.Open, FileAccess.Read, FileShare.None))
        using (Stream sMemoryStream = new MemoryStream())
        {
            // Read from File to memory stream
            sFileStream.CopyTo(sMemoryStream);

            // Decrypt data and store in new memory stream
            byte[] bytes = new byte[sMemoryStream.Length];
            Console.WriteLine(""\tb:"" + bytes.Length);
            bytes = decrypt(bytes);
            Console.WriteLine(""\ta:"" + bytes.Length);
            Stream stream = new MemoryStream(bytes);
            Console.WriteLine(""\ts:"" + bytes.Length);

            // Deserialise memory stream and return as User object
            User user = (User)bfFormatter.Deserialize(stream);
            stream.Close();
            return user;
        }
    }
</code></pre>
","","64","<c#><encryption><rijndael>","1","","0","2018-07-12 15:38:23","","1","","8402408","","2018-07-12 15:38:23","2018-07-12 15:29:43",""
"26149191","Decrypted string is sometimes not same as encrypted source","<pre><code>class Auth extends MySQLi {
public function aes_enc($encrypt, $mc_key, $iv) {
    $passcrypt = trim(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, substr($mc_key, 0, 32), trim($encrypt), MCRYPT_MODE_CBC, $iv));
    return $passcrypt;

}

public function aes_dec($decrypt, $mc_key, $iv) {

    $decrypted = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, substr($mc_key, 0, 32), trim($decrypt), MCRYPT_MODE_CBC, $iv));
    return $decrypted;

}

public function salt() {
return str_shuffle('abcdefghijklmnoprsquvzyx0123456789-.,;:_&lt;&gt;');
}

public function iv() {
return mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND);
}
}
</code></pre>

<p>And on test.php, following code:</p>

<pre><code>&lt;?
require('Auth.php');
$Auth = new Auth;

$str = ""verygudlongpassword"";

for ($i = 0; $i &lt; 1000; $i++) {
    $salt = sha1($Auth-&gt;salt());
    $iv = $Auth-&gt;iv();

    $enc = $Auth-&gt;aes_enc($str, $salt, $iv);
    $dec = $Auth-&gt;aes_dec($enc, $salt, $iv);

    if ($str != $dec) {
        echo $salt . ""&lt;br&gt;\n"";
    }
}
?&gt;
</code></pre>

<p>Sometimes, $dec != $str. Why is this happening? I am not even saving anything into DB atm, so it's not that. 
Thanks for help.</p>

<p>i dont really have anything more to say, but site isnt letting me post. (nvm that part)</p>
","<p>After reviewing your code and playing with it locally.  It would appear that your decryption leaves some whitespace on the decrypted text.  I removed the <code>trim()</code> function from all locations <em>except</em> the return value from <code>aes_dec()</code> and the code now encrypts/decrypts your string successfully 1000 times.</p>

<p>So it would seem trimming was the problem and the solution.</p>

<pre><code>class Auth extends MySQLi {
    public function aes_enc($encrypt, $mc_key, $iv)
    {
        $passcrypt = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, substr($mc_key, 0, 32), $encrypt, MCRYPT_MODE_CBC, $iv);
        return $passcrypt;
    }

    public function aes_dec($decrypt, $mc_key, $iv)
    {
        $decrypted = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, substr($mc_key, 0, 32), $decrypt, MCRYPT_MODE_CBC, $iv));
        return $decrypted;

    }

    public function salt()
    {
        return str_shuffle('abcdefghijklmnoprsquvzyx0123456789-.,;:_&lt;&gt;');
    }

    public function iv()
    {
        return mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND);
    }
}

$Auth = new Auth;

$str = ""verygudlongpassword"";

for ($i = 0; $i &lt; 1000; $i++) {
    $salt = sha1($Auth-&gt;salt());
    $iv = $Auth-&gt;iv();

    $enc = $Auth-&gt;aes_enc($str, $salt, $iv);
    $dec = $Auth-&gt;aes_dec($enc, $salt, $iv);

    if ($str != $dec) {
        echo ""Decryption failed!&lt;br&gt;\n"";
    } else {
        echo ""Decryption success! String: $dec&lt;br&gt;\n"";
    }
}
</code></pre>
","63","<php><encryption><aes><rijndael>","0","2","1","2014-10-01 19:59:46","26149562","2","","","","","2014-10-01 19:36:56",""
"49327489","What is the correct way to translate .NET Rijndael Managed AES decrypt function to Java","<p>Need help to convert the following example code from .NET VB code to java to include in a jsp page. I have looked at a number of questions that all seem to have partial answers.</p>

<pre><code>Public Function Decrypt(ByVal TokenKey As String, ByVal DataString As String) As String
        Dim ms As MemoryStream = Nothing
        Dim cs As CryptoStream = Nothing
        Try
            Using AES As New RijndaelManaged()
                AES.KeySize = 128
                AES.BlockSize = 128
                Dim EncryptedData As Byte() = System.Convert.FromBase64String(DataString)
                Dim SecretKey As New Rfc2898DeriveBytes(TokenKey, New Byte() {&lt;Your salt&gt;})
                Using Decryptor As ICryptoTransform = AES.CreateDecryptor(SecretKey.GetBytes(16), SecretKey.GetBytes(16))
                    ms = New MemoryStream(EncryptedData)
                    Using ms
                        cs = New CryptoStream(ms, Decryptor, CryptoStreamMode.Read)
                        Using cs
                            Dim PlainText As Byte() = New Byte(EncryptedData.Length - 1) {}
                            Return Encoding.Unicode.GetString(PlainText, 0, cs.Read(PlainText, 0, PlainText.Length))
                        End Using
                    End Using
                End Using

            End Using
        Catch ex As Exception
            Return ""Error - "" &amp; ex.Message
        Finally
            If ms IsNot Nothing Then
                ms.Close()
            End If
            If cs IsNot Nothing Then
                cs.Close()
            End If
        End Try
End Function
</code></pre>
","<p>There are multiple questions on stackoverflow that I had to lookup and each provided parts of the puzzle. Here is a working java solution for the above example. The key to the solution is the following:</p>

<p>Explanation as requested:</p>

<p>The .NET Rijendael implementation uses AES in CBC mode along with PKCS#7 padding for the underlying algorithm</p>

<p>RFC2898 Key derivation is the same as using java PBKFD2 for newer implementations</p>

<p>On windows the encoding for the cipher requires UTF-16LE</p>

<p>Final result for decryption requires a 'new String' rather than byte[] toString</p>

<p>Note: the solution uses AES with 128 bits but can be changed to 256 with the proper allocation of the subsequent key and modifying array copies accordingly, however, the blocksize of 128 cannot be changed.</p>

<pre><code>import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidKeySpecException;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;


/**
  * Hello world!
  *
  */
public class App 
{
private final String extCharEnc = ""UTF-8"";
private final String intCharEnc = ""UTF-16LE"";
private final String cipherTransformation = ""AES/CBC/PKCS5Padding"";
private final String aesEncryptionAlgorithm = ""AES"";
private final byte[] salt = {&lt;Your salt&gt;};

public  byte[] decryptInternal(byte[] cipherText, String sharedKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, InvalidKeySpecException, UnsupportedEncodingException
{
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1""); 
    //Please note that the last parameter in the following function is key size (128) + blocksize 128 = 256
    //If you do use an AES keysize of 256 then the last parameter will be 384 etc.
    PBEKeySpec pbeKeySpec = new PBEKeySpec(sharedKey.toCharArray(), salt, 1000, 256);
    Key secretKey = factory.generateSecret(pbeKeySpec);
    byte[] key = new byte[16];
    byte[] iv = new byte[16];
    System.arraycopy(secretKey.getEncoded(), 0, key, 0, 16);
    System.arraycopy(secretKey.getEncoded(), 16, iv, 0, 16);

    SecretKeySpec secret = new SecretKeySpec(key, aesEncryptionAlgorithm);
    AlgorithmParameterSpec ivSpec = new IvParameterSpec(iv);
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    cipher.init(Cipher.DECRYPT_MODE, secret, ivSpec);
    return(cipher.doFinal(cipherText));

}

public byte[] encryptInternal(String plaintext, String sharedKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, InvalidKeySpecException
{
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");   
    PBEKeySpec pbeKeySpec = new PBEKeySpec(sharedKey.toCharArray(), salt, 1000, 256);
    Key secretKey = factory.generateSecret(pbeKeySpec);
    byte[] key = new byte[16];
    byte[] iv = new byte[16];
    System.arraycopy(secretKey.getEncoded(), 0, key, 0, 16);
    System.arraycopy(secretKey.getEncoded(), 16, iv, 0, 16);

    SecretKeySpec secret = new SecretKeySpec(key, aesEncryptionAlgorithm);
    AlgorithmParameterSpec ivSpec = new IvParameterSpec(iv);
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    cipher.init(Cipher.ENCRYPT_MODE, secret, ivSpec);
    return(cipher.doFinal(plaintext.getBytes(intCharEnc)));

}

/// &lt;summary&gt;
/// Encrypts plaintext using AES 128bit key and a Chain Block Cipher and returns a base64 encoded string
/// &lt;/summary&gt;
/// &lt;param name=""plainText""&gt;Plain text to encrypt&lt;/param&gt;
/// &lt;param name=""key""&gt;Secret key&lt;/param&gt;
/// &lt;returns&gt;Base64 encoded string&lt;/returns&gt;
public String encrypt(String plainText, String key) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, InvalidKeySpecException{
    return URLEncoder.encode(Base64.encodeBase64String(encryptInternal(plainText, key)), extCharEnc);
}

/// &lt;summary&gt;
/// Decrypts a base64 encoded string using the given key (AES 128bit key and a Chain Block Cipher)
/// &lt;/summary&gt;
/// &lt;param name=""encryptedText""&gt;Base64 Encoded String&lt;/param&gt;
/// &lt;param name=""key""&gt;Secret Key&lt;/param&gt;
/// &lt;returns&gt;Decrypted String&lt;/returns&gt;
public String decrypt(String encryptedText, String sharedKey) throws KeyException, GeneralSecurityException, GeneralSecurityException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException{
   String cipheredBytes = URLDecoder.decode(encryptedText, extCharEnc);       
   return new String(decryptInternal(Base64.decodeBase64(cipheredBytes), sharedKey), intCharEnc);
}

public static void main( String[] args )
{ 
    App myApp = new App();
    String SharedKey = &lt;Your Shared Key&gt;;
    String InputStr =  &lt;Test string to encrypt and decrypt&gt;;

    String EncryptedStr = null;
    String DecryptedStr = null;

    try {
        EncryptedStr = myApp.encrypt(InputStr, SharedKey);
        DecryptedStr = myApp.decrypt(EncryptedStr, SharedKey);
        System.out.println( ""This is the Encrypted String: "" + EncryptedStr + "" \nThis is the Decrypted String: "" + DecryptedStr);
    } catch (KeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (BadPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (GeneralSecurityException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }


}
</code></pre>

<p>}</p>
","62","<java><vb.net><aes><rijndael>","0","0","1","2018-03-16 22:00:06","","0","","6173716","","2018-03-16 20:17:06","2018-03-16 18:34:52",""
"57306311","How to fix 'Org.BouncyCastle.Crypto.InvalidCipherTextException: 'pad block corrupted'' in Rijndael Decryption","<p>I have the same sittuation <a href=""https://stackoverflow.com/questions/53559476/decrypt-rijndael-256-block-size-with-bouncycastle"">Decrypt Rijndael 256 Block Size with BouncyCastle</a> </p>

<p>So I've fixed code from that post, and replaced my old code</p>

<pre><code>public static string Decrypt(string cipherText, string superSecretPassPhrase)
{
    if (cipherText == null)
    {
        throw new ArgumentNullException(nameof(cipherText));
    }
    // Get the complete stream of bytes that represent:
    // [32 bytes of Salt] + [32 bytes of IV] + [n bytes of CipherText]
    var cipherTextBytesWithSaltAndIv = Convert.FromBase64String(cipherText);
    // Get the saltbytes by extracting the first 32 bytes from the supplied cipherText bytes.
    var saltStringBytes = cipherTextBytesWithSaltAndIv.Take(Keysize / 8).ToArray();
    // Get the IV bytes by extracting the next 32 bytes from the supplied cipherText bytes.
    var ivStringBytes = cipherTextBytesWithSaltAndIv.Skip(Keysize / 8).Take(Keysize / 8).ToArray();
    // Get the actual cipher text bytes by removing the first 64 bytes from the cipherText string.
    var cipherTextBytes = cipherTextBytesWithSaltAndIv.Skip((Keysize / 8) * 2).Take(cipherTextBytesWithSaltAndIv.Length - ((Keysize / 8) * 2)).ToArray();

    using (var password = new Rfc2898DeriveBytes(superSecretPassPhrase, saltStringBytes, _iterations))
    {
        var keyBytes = password.GetBytes(Keysize / 8);
        using (var symmetricKey = new RijndaelManaged())
        {
            symmetricKey.BlockSize = 256;
            symmetricKey.Mode = CipherMode.CBC;
            symmetricKey.Padding = PaddingMode.PKCS7;
            using (var decryptor = symmetricKey.CreateDecryptor(keyBytes, ivStringBytes))
            {
                using (var memoryStream = new System.IO.MemoryStream(cipherTextBytes))
                {
                    using (var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read))
                    {
                        var plainTextBytes = new byte[cipherTextBytes.Length];
                        var decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
                        memoryStream.Close();
                        cryptoStream.Close();
                        return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
                    }
                }
            }
        }
    }
}
</code></pre>

<p>by new code</p>

<pre><code>public static string Decrypt(string cipherText, string superSecretPassPhrase)
{
    if (cipherText == null)
    {
        throw new ArgumentNullException(nameof(cipherText));
    }
    // Get the complete stream of bytes that represent:
    // [32 bytes of Salt] + [32 bytes of IV] + [n bytes of CipherText]
    var cipherTextBytesWithSaltAndIv =  Convert.FromBase64String(cipherText);
    // Get the saltbytes by extracting the first 32 bytes from the supplied cipherText bytes.
    var saltStringBytes = cipherTextBytesWithSaltAndIv.Take(Keysize / 8).ToArray();
    // Get the IV bytes by extracting the next 32 bytes from the supplied cipherText bytes.
    var ivStringBytes = cipherTextBytesWithSaltAndIv.Skip(Keysize / 8).Take(Keysize / 8).ToArray();
    // Get the actual cipher text bytes by removing the first 64 bytes from the cipherText string.
    var cipherTextBytes = cipherTextBytesWithSaltAndIv.Skip((Keysize / 8) * 2).Take(cipherTextBytesWithSaltAndIv.Length - ((Keysize / 8) * 2)).ToArray();

    using (var password = new Rfc2898DeriveBytes(superSecretPassPhrase, saltStringBytes, _iterations))
    {
        var keyBytes = password.GetBytes(Keysize / 8);
        var engine = new RijndaelEngine(256);
        var blockCipher = new CbcBlockCipher(engine);
        var cipher = new PaddedBufferedBlockCipher(blockCipher, new Pkcs7Padding());
        var keyParam = new KeyParameter(keyBytes);
        var keyParamWithIV = new ParametersWithIV(keyParam, ivStringBytes, 0, 32);
        cipher.Init(false, keyParamWithIV);
        var outputBytes = new byte[cipher.GetOutputSize(cipherTextBytes.Length)];
        var length = cipher.ProcessBytes(cipherTextBytes, outputBytes, 0);
        var finalBytes = cipher.DoFinal(outputBytes, 0, length);  //Exception HERE!!!
        var final = Encoding.UTF8.GetString(finalBytes);
        return final;
    }
}
</code></pre>

<p>I faced with isssue that some my cases (I'am not sure but seems like long <code>cipherText</code> leads to : <code>'pad block corrupted' Exception</code>).</p>

<p>For instance  </p>

<pre><code>static void Main(string[] args)
{
    var superSecretPassPhrase = ""Office"";
    var input = @""U3/7njQjVmcahG9/PtK9fhivCU1l128UACKeBvo6d+T5XwTx+A3qxkfKZCObhaMsOJQDkLrLpAUXCw6txSRrmh5vd4iYfAfTSHzrgdtlvff0gtKfwpmzYAXdvk8tJFiFnvM7xWQlxlmybNtTYVpk1c1UCvNOcyPR2YuooxJ3FV1otIzyRLMSBEOtasV0uyCnoe79mkh54/2XrGXCsLDGpQ=="";
    var result = OldStringDecryptor.Decrypt(input,superSecretPassPhrase); /*everything is ok as I expected ""DjSRsJ8i7RJEdZ8ooMH9RH1p2oBV7G1zPJg6hdceULIXzF9LhHJYeAb5MCOK9D9M""*/
    var result2=
        NewBouncyCastleDecryptor.Decrypt(input,superSecretPassPhrase);//throws pad block corrupted Exception
}
</code></pre>

<p>what else do I need to change in the new code?</p>
","<p>You are using the wrong override of <code>DoFinal</code> in your <code>Decrypt</code> method (examine the argument names). Also, the </p>

<p>Replace this:</p>

<pre><code>var outputBytes = new byte[cipher.GetOutputSize(cipherTextBytes.Length)];
var length = cipher.ProcessBytes(cipherTextBytes, outputBytes, 0);
var finalBytes = cipher.DoFinal(outputBytes, 0, length);
</code></pre>

<p>with:</p>

<pre><code>var finalBytes = cipher.DoFinal(cipherTextBytes);
</code></pre>
","62","<c#><encryption><bouncycastle><rijndael>","0","1","1","2019-08-22 09:10:09","57605811","0","","10958092","","2019-08-01 11:20:58","2019-08-01 09:50:23",""
"57564956","Encrypting a file into Base64 format using AES/Rijndael","<p>In DevGlan, at <a href=""https://www.devglan.com/online-tools/aes-encryption-decryption"" rel=""nofollow noreferrer"">https://www.devglan.com/online-tools/aes-encryption-decryption</a>, there is an online tool where you can upload a file and then encrypt it into Base64 format by using AES encryption and also choosing a cipher mode, secret key, and initialization vector. I want to achieve the same thing in my C# web app. Here is my code:</p>

<pre><code>FileUpload3.SaveAs(Server.MapPath(FileUpload3.FileName));
string inputFile = Server.MapPath(FileUpload3.FileName);
byte[] bytesToEncrypt = File.ReadAllBytes(inputFile);
byte[] encryptedBytes = EncryptAESfile(bytesToEncrypt, CipherMode.CBC, keyArray, IV);
string encryptedFileBase64 = Convert.ToBase64String(encryptedBytes);
string encryptedFileHex = BitConverter.ToString(encryptedBytes).Replace(""-"", """");

    public byte[] EncryptAESfile(byte[] data, CipherMode mode, byte[] key, byte[] iv)
    {
        byte[] encryptedData = null;
        if (data == null)
            throw new ArgumentNullException(""data"");

        if (data == key)
            throw new ArgumentNullException(""key"");

        if (data == iv)
            throw new ArgumentNullException(""iv"");

        using (RijndaelManaged aesAlg = new RijndaelManaged())
        {
            aesAlg.Key = key;
            aesAlg.IV = iv;
            aesAlg.Mode = mode;
            ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);
            encryptedData = encryptor.TransformFinalBlock(data, 0, data.Length);
        }

        return encryptedData;
    }
</code></pre>

<p>The code does return a Base64 string of the file, as in the variable <code>encryptedFileBase64</code>, but not the correct one in reference to DevGlan. My code only returns a Base64 string of length 24 whereas DevGlan returns a string of nearly 100,000 characters. Also, when I test to see if bytes are being read, the following code returns 0, so the problem could be in my first few lines:</p>

<pre><code>lblBytes.Text += ""Bytes read: "" + bytesToEncrypt.Length;
</code></pre>

<p>I've also seen many examples of encrypting files - whether in AES or some other symmetric encryption algorithm - but not ones that return a Base64 string. Most end with lines like this before the CryptoStream is closed:</p>

<pre><code>byte[] bytearrayinput = new byte[fsInput.Length];
fsInput.Read(bytearrayinput, 0, bytearrayinput.Length);   // The input FileStream
cryptostream.Write(bytearrayinput, 0, bytearrayinput.Length);
</code></pre>

<p>Reference: <a href=""https://stackoverflow.com/questions/23374121/encrypting-any-file-using-aes"">Encrypting any file using AES</a></p>

<p>Is there a way to read the byte array of the CryptoStream and then convert it to Base64, because I don't see <code>bytearrayinput</code> left alone as storing the correct information. Help would be much appreciated. Thanks!</p>
","<p>First: How is key created? Have you double-checked that your salt is the same?</p>

<p>Also I haven't checked, but this code should work:</p>

<pre><code>AesManaged cipher = new AesManaged();
cipher.Mode = MODE;
ICryptoTransform encryptor = cipher.CreateEncryptor(KEY, IV);
MemoryStream to = new MemoryStream();
CryptoStream writer = new CryptoStream(to, encryptor, CryptoStreamMode.Write);

writer.Write(input, 0, input.Length);
writer.FlushFinalBlock();
byte[] encrypted = to.ToArray();
return Convert.ToBase64String(encrypted);
</code></pre>
","61","<c#><encryption><aes><rijndael>","0","0","1","2019-08-20 02:26:59","","2","","11155207","","2019-08-20 02:26:59","2019-08-19 23:17:51",""
"30379981","How to convert(not just output) elements of an array into it's hexadecimal values","<p>I have to implement Rijndael algorithm in C. I start with this:</p>

<pre><code>   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
   int main() {
    int i=0,j;
    char m[5000];
    char message[5000];
    char ch;
    printf(""Introduce the message\n\n"");
    while((ch=getchar())!='\n')
    {
        message[i]=ch;
        i++;
    }
    message[i]='\0';
    i=0;
    while(message[i]!='\0')
    {
        sscanf(&amp;message[i],""%x"",&amp;m);
        i++;
    }
    printf(""\nResult\n"");
    for(j=0;j&lt;i;j++)
    {
        printf("" %x"",&amp;m[j]);
    }
    printf(""\n"");
}
</code></pre>

<p>I need an array in which for example ""Hello""(where array1[0] will show H) will be written as 48656c6c6f, and when calling array2[0] it will show 48.</p>
","<p>Do you want a hexadecimal representation of <code>message</code>'s contents? If so, what you need is this:</p>

<pre><code>char messageHex[sizeof(message)*2];
memset(messageHex, 0, sizeof(messageHex));
size_t len = strlen(message);
for (size_t i = 0; i &lt; len; i++)
{
    sprintf(messageHex + i*2, ""%02X"", message[i] &amp; 0xFF);
}
</code></pre>
","57","<c><rijndael>","0","1","2","2015-05-24 18:58:01","","2","","4660473","","2015-05-21 18:16:37","2015-05-21 16:58:23","2015-05-22 03:40:16"
"30379981","How to convert(not just output) elements of an array into it's hexadecimal values","<p>I have to implement Rijndael algorithm in C. I start with this:</p>

<pre><code>   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
   int main() {
    int i=0,j;
    char m[5000];
    char message[5000];
    char ch;
    printf(""Introduce the message\n\n"");
    while((ch=getchar())!='\n')
    {
        message[i]=ch;
        i++;
    }
    message[i]='\0';
    i=0;
    while(message[i]!='\0')
    {
        sscanf(&amp;message[i],""%x"",&amp;m);
        i++;
    }
    printf(""\nResult\n"");
    for(j=0;j&lt;i;j++)
    {
        printf("" %x"",&amp;m[j]);
    }
    printf(""\n"");
}
</code></pre>

<p>I need an array in which for example ""Hello""(where array1[0] will show H) will be written as 48656c6c6f, and when calling array2[0] it will show 48.</p>
","<p>What use would it be to you to make an array that contains the <strong>hexadecimal</strong> value in a <strong>decimal</strong> representation? It's the same numeric value after all.</p>

<p>Printing it would be as simple as <code>printf(""%x\n"", arr[0]);</code>.</p>

<p>If you insist, then you can have an array of strings (<code>char*</code>) with each containing the string of the hexadecimal value then you might want to use <code>sprintf()</code> (so you won't need to do any calculations yourself) as following:</p>

<pre><code>unsigned char** hex_arr = malloc(arrLen); //arrLen is the integer array length
for(i = 0 ; i &lt; arrLen ; i++) //declare i first
{
    hex_arr[i] = malloc(3); //2 characters and null (two hexadecimal notes can represent up to 255 which is the size of the wide ASCII table)
    sprintf(hex_arr[i], ""%x"", (uint8_t)arr[i]); //as arr is your integer array
}
</code></pre>

<p>Note that you can also organize everything unto one string (<code>char*</code>) where every character in spot of <code>i</code> in the integer array would be represented by two characters: <code>xArr[i*2]</code> and <code>xArr[i*2+1]</code></p>

<p>Cheers.</p>
","57","<c><rijndael>","0","0","2","2015-05-24 18:58:01","","2","","4660473","","2015-05-21 18:16:37","2015-05-21 16:58:23","2015-05-22 03:40:16"
"56540147","Convert .NET Rijndael's encryption function to PHP language","<p>I need to exactly convert this .NET function in PHP Language, any help?</p>

<p>I've tried different solutions found on StackOverflow, but no-one seems work for me.</p>

<pre><code>internal string Encrypt(string plaintext, string password)
{
    RijndaelManaged rijndaelCipher = new RijndaelManaged();

    byte[] plaintextByte = System.Text.Encoding.Unicode.GetBytes(plaintext);
    byte[] saltByte = Encoding.ASCII.GetBytes(password.Length.ToString());

    PasswordDeriveBytes secretKey = new PasswordDeriveBytes(password, saltByte);
    ICryptoTransform encryptor = rijndaelCipher.CreateEncryptor(secretKey.GetBytes(32), secretKey.GetBytes(16));
    MemoryStream memoryStream = new MemoryStream();
    CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);

    cryptoStream.Write(plaintextByte, 0, plaintextByte.Length);
    cryptoStream.FlushFinalBlock();

    byte[] cipherBytes = memoryStream.ToArray();

    memoryStream.Close();
    cryptoStream.Close();
    encryptor.Dispose();

    return Convert.ToBase64String(cipherBytes);
}
</code></pre>

<p>Thanks!</p>

<p>EDIT:</p>

<p>Here one of the code I've tried:</p>

<pre><code>class Crypt
{
private $key,$iv_size,$iv;

/**
 * constructor
 * @param $key (string:'TheKey')
 * @return void
 */
function __construct($key='TheKey'){
    $this-&gt;key = trim($key);
    $this-&gt;iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB);
    $this-&gt;iv = mcrypt_create_iv($this-&gt;iv_size, MCRYPT_RAND);
}

public function encrypt($string){
    $string=trim($string);
    return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $this-&gt;key, $string, MCRYPT_MODE_ECB, $this-&gt;iv));
}
}
</code></pre>
","<p>I got the solution from web service developer, it works fine!</p>

<pre><code>&lt;?php
class RijndaelOpenSSL
{
const METHOD = 'aes-256-cbc';
private $pbkdfBase = '';
private $pbkdfExtra = '';
private $pbkdfExtracount = 0;
private $pbkdfHashno = 0;
private $pbkdfState = 0;
private $iterations = 100;
public function reset()
{
    $this-&gt;pbkdfBase = '';
    $this-&gt;pbkdfExtra = '';
    $this-&gt;pbkdfExtracount = 0;
    $this-&gt;pbkdfHashno = 0;
    $this-&gt;pbkdfState = 0;
}
public function decrypt($inputText, $password)
{
    $this-&gt;reset();
    $salt = (string) mb_strlen($password);
    $key = $this-&gt;pbkdf1($password, $salt, 32);
    $iv = $this-&gt;pbkdf1($password, $salt, 16);
    $decrypted = openssl_decrypt(base64_decode($inputText), self::METHOD, $key, OPENSSL_RAW_DATA, $iv);
    return mb_convert_encoding($decrypted, 'UTF-8', 'UTF-16LE');
}

public function encrypt($inputText, $password)
{
    $this-&gt;reset();
    $salt = (string) mb_strlen($password);
    $key = $this-&gt;pbkdf1($password, $salt, 32);
    $iv = $this-&gt;pbkdf1($password, $salt, 16);
    $textUTF = mb_convert_encoding($inputText, 'UTF-16LE');
    $encrypted = openssl_encrypt($textUTF, self::METHOD, $key, OPENSSL_RAW_DATA, $iv);
    return base64_encode($encrypted);
}
private function pbkdf1($pass, $salt, $countBytes)
{
    if ($this-&gt;pbkdfState == 0) {
        $this-&gt;pbkdfHashno = 0;
        $this-&gt;pbkdfState = 1;
        $key = $pass . $salt;
        $this-&gt;pbkdfBase = sha1($key, true);
        for ($i = 2; $i &lt; $this-&gt;iterations; $i++) {
            $this-&gt;pbkdfBase = sha1($this-&gt;pbkdfBase, true);
        }
    }
    $result = '';
    if ($this-&gt;pbkdfExtracount &gt; 0) {
        $rlen = strlen($this-&gt;pbkdfExtra) - $this-&gt;pbkdfExtracount;
        if ($rlen &gt;= $countBytes) {
            $result = substr($this-&gt;pbkdfExtra, $this-&gt;pbkdfExtracount, $countBytes);
            if ($rlen &gt; $countBytes) {
                $this-&gt;pbkdfExtracount += $countBytes;
            } else {
                $this-&gt;pbkdfExtra = null;
                $this-&gt;pbkdfExtracount = 0;
            }
            return $result;
        }
        $result = substr($this-&gt;pbkdfExtra, $rlen, $rlen);
    }
    $current = '';
    $clen = 0;
    $remain = $countBytes - strlen($result);
    while ($remain &gt; $clen) {
        if ($this-&gt;pbkdfHashno == 0) {
            $current = sha1($this-&gt;pbkdfBase, true);
        } else if ($this-&gt;pbkdfHashno &lt; 1000) {
            $num = sprintf('%d', $this-&gt;pbkdfHashno);
            $tmp = $num . $this-&gt;pbkdfBase;
            $current .= sha1($tmp, true);
        }
        $this-&gt;pbkdfHashno++;
        $clen = strlen($current);
    }
    // $current now holds at least as many bytes as we need
    $result .= substr($current, 0, $remain);
    // Save any left over bytes for any future requests
    if ($clen &gt; $remain) {
        $this-&gt;pbkdfExtra = $current;
        $this-&gt;pbkdfExtracount = $remain;
    }
    return $result;
}
</code></pre>

<p>}</p>
","56","<c#><php><encryption><rijndael>","-1","0","1","2019-06-12 07:37:12","","12","","11629947","","2019-06-11 09:26:11","2019-06-11 09:06:17",""
"57904160","C# AES encryption/decryption","<p>I'm encrypting a string in .Net C#, sending it over using HttpRequest and decrypting it in .Net CF 3.5. Encrypting goes ok, but I get an error when decrypting the string.</p>

<p>Encrypting code:</p>

<pre><code>   public string Encrypt(string s)
    {
        byte[] encrypted;
        using (RijndaelManaged myRijndael = new RijndaelManaged())
        {
            //myRijndael.GenerateKey();
            myRijndael.Mode = CipherMode.ECB;
            myRijndael.KeySize = 256;
            myRijndael.Key = Encoding.ASCII.GetBytes(keystring);
            //myRijndael.GenerateIV();
            myRijndael.IV = Encoding.ASCII.GetBytes(IVstring);
            encrypted = EncryptStringToBytes(s, myRijndael.Key, myRijndael.IV);
            string x = Encoding.UTF8.GetString(encrypted);
        }
        return Encoding.UTF8.GetString(encrypted);
    }

private byte[] EncryptStringToBytes(string plainText, byte[] Key, byte[] IV)
{
    if (plainText == null || plainText.Length &lt;= 0)
        throw new ArgumentNullException(""plainText"");
    if (Key == null || Key.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");
    if (IV == null || IV.Length &lt;= 0)
        throw new ArgumentNullException(""IV"");
    byte[] encrypted;
    using (RijndaelManaged rijAlg = new RijndaelManaged())
    {
        rijAlg.Key = Key;
        rijAlg.IV = IV;
        ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
        using (MemoryStream msEncrypt = new MemoryStream())
        {
            using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
            {
                using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                {
                    swEncrypt.Write(plainText);
                }
                encrypted = msEncrypt.ToArray();
            }
        }
    }
    return encrypted;
}
</code></pre>

<p>Decrypting code in CF 3.5:</p>

<pre><code>public string Decrypt(string toDecrypt)
{
    byte[] keyArray = UTF8Encoding.UTF8.GetBytes(keystring);
    byte[] keyIV = UTF8Encoding.UTF8.GetBytes(IVstring);
    byte[] toEncryptArray = Convert.FromBase64String(toDecrypt);
    RijndaelManaged rDel = new RijndaelManaged();
    rDel.Key = keyArray;
    rDel.KeySize = 256;
    rDel.Mode = CipherMode.ECB;
    rDel.Padding = PaddingMode.PKCS7;
    ICryptoTransform cTransform = rDel.CreateDecryptor();
    byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
    return Encoding.ASCII.GetString(resultArray, 0, resultArray.Length);
}
</code></pre>

<p>The line <strong>byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);</strong> throws error : <strong>base {System.SystemException} = {""Length of the data to decrypt is invalid.""}</strong></p>

<p>I tried playing around with Padding etc, but to no avail. Thanks for your input.</p>

<p><strong>EDIT</strong>
As suggested, I tried to use CryptoStream, but to no avail. </p>

<pre><code>static string DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV)
{
    if (cipherText == null || cipherText.Length &lt;= 0)
        throw new ArgumentNullException(""cipherText"");
    if (Key == null || Key.Length &lt;= 0)
        throw new ArgumentNullException(""Key"");
    if (IV == null || IV.Length &lt;= 0)
        throw new ArgumentNullException(""IV"");

    string plaintext = null;
    using (RijndaelManaged rijAlg = new RijndaelManaged())
    {
        rijAlg.Mode = CipherMode.ECB;
        rijAlg.KeySize = 256;
        rijAlg.Key = Key;
        rijAlg.IV = IV;

        ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);
        using (MemoryStream msDecrypt = new MemoryStream(cipherText))
        {
            using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
            {
                using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                {
                    plaintext = srDecrypt.ReadToEnd();
                }
            }
        }

    }
    return plaintext;
}
</code></pre>

<p>Now I get error:
<strong>base {System.ArgumentException} = {""Value can not be null.\r\nParameter name: inputBuffer""}</strong> at line <strong>plaintext = srDecrypt.ReadToEnd();</strong></p>
","","51","<c#><.net><aes><compact-framework><rijndael>","0","","0","2019-09-12 10:10:42","","7","","9671207","","2019-09-12 10:10:42","2019-09-12 09:54:53",""
"53200757","Best Encryption Algorithm for long passwords","<p>Recently I implemented AES/Rijndael-256 into a component to store passwords. Recently I tried to store a longer password of character length 36 and when decrypting this password from the database the implementation fails due to and invalid padding error. This issue doesn't occur with shorter passwords.</p>

<p>The current implementation:</p>

<pre><code>   public static string Encrypt(string plainText, string passPhrase)
    {
        // Salt and IV is randomly generated each time, but is preprended to encrypted cipher text
        // so that the same Salt and IV values can be used when decrypting.  
        var saltStringBytes = Generate256BitsOfRandomEntropy();
        var ivStringBytes = Generate256BitsOfRandomEntropy();
        var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
        using (var password = new Rfc2898DeriveBytes(passPhrase, saltStringBytes, DerivationIterations))
        {
            var keyBytes = password.GetBytes(Keysize / 8);
            using (var symmetricKey = new RijndaelManaged())
            {
                symmetricKey.BlockSize = 256;
                symmetricKey.Mode = CipherMode.CBC;
                symmetricKey.Padding = PaddingMode.PKCS7;
                using (var encryptor = symmetricKey.CreateEncryptor(keyBytes, ivStringBytes))
                {
                    using (var memoryStream = new MemoryStream())
                    {
                        using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
                        {
                            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
                            cryptoStream.FlushFinalBlock();
                            // Create the final bytes as a concatenation of the random salt bytes, the random iv bytes and the cipher bytes.
                            var cipherTextBytes = saltStringBytes;
                            cipherTextBytes = cipherTextBytes.Concat(ivStringBytes).ToArray();
                            cipherTextBytes = cipherTextBytes.Concat(memoryStream.ToArray()).ToArray();
                            memoryStream.Close();
                            cryptoStream.Close();
                            return Convert.ToBase64String(cipherTextBytes);
                        }
                    }
                }
            }
        }
    }
</code></pre>

<p>I'm no cryptographer but I assume this is due to the limitations of the AES/Rijndael max key size of 256 bits. </p>

<p>Are there some other recommended encryption methods which would support longer passwords?</p>
","","48","<c#><aes><rijndael>","0","","0","2018-11-08 02:56:33","","10","","","","","2018-11-08 02:35:42",""
"55792829","How to fix Rijindael decryption (php code to python3 migration) IV problem?","<p>I'm migrating my existing code to Python3, unfortunately the decryption shows error that IV must be 16 bytes long.</p>

<p>I have tried decrypting the key with sha1 then tried to decrypt.</p>

<p>My php5.6 code is</p>

<pre><code>&lt;?php

    define('ENCR_ALGO', MCRYPT_RIJNDAEL_256);
    define('ENCR_MODE', MCRYPT_MODE_CBC);
    define('KEY',""This is test key"");



    function encryptData($plaintext){

        $iv=generateIv();
        $ciphertext = mcrypt_encrypt(ENCR_ALGO, getKey(), $plaintext, ENCR_MODE, $iv);
        $ciphertext.=$iv;
        return trim(base64_encode($ciphertext));
    }
    function decryptData($ciphertext){

        $iv=getIvFromCiphertext($ciphertext);
        $ciphertext=getActualCiphertext($ciphertext);
        $plaintext = mcrypt_decrypt(ENCR_ALGO, getKey(), $ciphertext, ENCR_MODE, $iv);
        return trim($plaintext);
    }

    function getIvFromCiphertext($encryptedData){
        $encryptedData  =   base64_decode($encryptedData);
        $cipherTextSize =   strlen($encryptedData);
        $ivStartIndex   =   $cipherTextSize-ivSize();
        return substr($encryptedData, $ivStartIndex , ivSize());
        }

    function getActualCiphertext($encryptedData){
        $encryptedData  =   base64_decode($encryptedData);
        $cipherTextSize =   strlen($encryptedData);

        return substr($encryptedData, 0,$cipherTextSize-ivSize());
        }

    function ivSize(){
        return mcrypt_get_iv_size(ENCR_ALGO, ENCR_MODE);
        }

    function keySize(){
        return mcrypt_get_key_size(ENCR_ALGO, ENCR_MODE);
        }

    function generateIv(){
        return mcrypt_create_iv(keySize(), MCRYPT_RAND );
    }

    function getKey(){
        return substr(sha1(KEY), 0, keySize());
    }

    echo ""&lt;br/&gt;"";
    echo encryptData(""my pass"");
    echo decryptData(""vuv6kZgweA2YqSU4vMOuYStrbwZayDYaL7UQ+JajFCVc2p4HW1o68OmIm2l3Rbi/IaCWtKD5m6an7LqnvwRYVA=="");
?&gt;
</code></pre>

<p>In my python3 file, it's like</p>

<pre><code>from hashlib import sha1
import base64
from Crypto import Random
from Crypto.Cipher import AES


def actual_text(txt):
    data = base64.b64decode(txt)
    return data[:32], data[32:64]


passs = ""vuv6kZgweA2YqSU4vMOuYStrbwZayDYaL7UQ+JajFCVc2p4HW1o68OmIm2l3Rbi/IaCWtKD5m6an7LqnvwRYVA==""

key = ""This is test key""
text, iv = actual_text(passs)


class Encryptor:
    def __init__(self, key):
        self.key = key

    def pad(self, s):
        return s + b""\0"" * (AES.block_size - len(s) % AES.block_size)

    def encrypt(self, message, key, key_size=256):
        message = self.pad(message)
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(key, AES.MODE_CBC, iv)
        return iv + cipher.encrypt(message)


    def decrypt(self, ciphertext, key, iv):
        # iv = ciphertext[:AES.block_size]
        cipher = AES.new(key, AES.MODE_CBC, iv)
        plaintext = cipher.decrypt(ciphertext[AES.block_size:])
        return plaintext.rstrip(b""\0"")


def make_sha1(s, encoding='utf-8'):
    return sha1(s.encode(encoding)).hexdigest()


make_sha1(key, encoding='utf-8')

key2 = make_sha1(key, encoding='utf-8')[:32]
print(iv)
enc = Encryptor(key2)
enc.decrypt(text,key2,iv)

</code></pre>

<p>The error is showing ValueError: IV must be 16 bytes long</p>

<p>I've expected result is ""my pass""</p>
","","42","<php><python-3.x><encryption><rijndael><cbc-mode>","0","","0","2019-04-25 13:29:14","","8","","10901477","","2019-04-25 13:29:14","2019-04-22 10:20:24",""
"28870930","AES 128 Bit IOS Encryption","<p>I am new to encryption in IOS. I've String and i want to encrypt it using AES-128 bit (rijndael algorithm) in IOS. I have found many links but did not get the exact answer.What is the best way to do that</p>
","","42","<ios><aes><rijndael>","0","","0","2015-03-05 05:49:52","","6","","","","","2015-03-05 05:49:52","2015-03-05 09:45:31"
"58602277","rijndael Encryption support java","<pre><code>I need A Sample Code in Java to 
Encrypt The String in AES 256 (Rijndael) with padding in CBC mode : MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC 
Then Encode the result  in base 64.
using Encryption Key:-""f53c50e4ab798944a4debe137ec8ba677dbf44ebd37e373f785bf59a8c048c54"".
</code></pre>

<p>*i had created this example and it is giving error key invalid but i want to use the above key only  </p>

<pre><code>public class aes {
    public static void main(String[] args) throws Exception {
        System.out.println(""started"");
        System.out.println(encrypt(""hello""));
        System.out.println(""end"");

    }
    public static String encrypt(String value) throws Exception{

byte[] keyBytes=""f53c50e4ab798944a4debe137ec8ba677dbf44ebd37e373f785bf59a8c048c54"".getBytes();
        SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] res=cipher.doFinal(value.getBytes());
        String result=Base64.getEncoder().encodeToString(res);
        return result;

    }
}
</code></pre>
","","38","<encryption><base64><key><rijndael><cbc-mode>","0","","0","2019-10-29 06:43:34","","9","","11261384","","2019-10-29 06:43:34","2019-10-29 06:20:38",""
"55402632","OutputLengthException in Rijndael impletation","<p>I'm having a trouble with Rijndael encryption implementation with BouncyCastle API for Java.</p>

<p>I'm getting the <code>OutputLengthException</code> when I execute <code>cipher.doFinal(inputTextBytes, intOutOff);</code>:</p>

<blockquote>
  <p>org.bouncycastle.crypto.OutputLengthException: output buffer too short</p>
</blockquote>

<p>I do not fully understand how to generate that integer to execute the <code>doFinal()</code> method.</p>

<p>Here is what I'm tried:</p>

<pre><code>public class RijndaelAndRFC2899Implementation {

    final static String WORD = ""763059"";
    final static String PASSWORD = ""515t3ma5m15B4d35"";
    final static byte[] SALT = new byte[]{1, 2, 3, 4, 5, 6, 7, 8};
    final static int KEY_SIZE = 256;
    final static int BLOCK_SIZE = 128;
    final static int ITERATIONS = 1000;

    public static void main(String[] args) throws Exception {
        BufferedBlockCipher cipher = getCipher(PASSWORD, true);
        byte[] inputText = WORD.getBytes(""UTF-8"");
        byte asd[] = new byte[cipher.getOutputSize(inputText.length)];
        int l = cipher.processBytes(inputText, 0, inputText.length, asd, 0);
        int n = cipher.doFinal(inputText, l); //&lt;---HERE PRODUCES OutputLengthException
    }

    private static BufferedBlockCipher getCipher(String password, boolean encrypt) throws Exception {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(password.getBytes(""UTF-8""));
        byte[] newPassword = md.digest();

        PKCS5S2ParametersGenerator generator = new PKCS5S2ParametersGenerator();
        generator.init(newPassword, SALT, ITERATIONS);

        ParametersWithIV iv = ((ParametersWithIV) generator.generateDerivedParameters(KEY_SIZE, BLOCK_SIZE));

        RijndaelEngine engine = new RijndaelEngine();
        BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(engine));   
        cipher.init(encrypt, iv);

        return cipher;
    }

}
</code></pre>

<p>Can you help me by understanding what I'm doing wrong?</p>
","<p>The call to <code>doFinal()</code> should have the output array as the first arg - not the input you were processing:</p>

<pre><code>public static void main(String[] args) throws Exception {
    BufferedBlockCipher cipher = getCipher(PASSWORD, true);
    byte[] inputText = WORD.getBytes(""UTF-8"");
    byte asd[] = new byte[cipher.getOutputSize(inputText.length)];
    int l = cipher.processBytes(inputText, 0, inputText.length, asd, 0);
    int n = cipher.doFinal(asd, l); // &lt;--- Change to asd
}
</code></pre>

<p>(I have not validated the rest of the implementation!)</p>
","36","<java><encryption><bouncycastle><rijndael><block-cipher>","0","2","1","2019-03-28 16:40:54","55402833","0","","","","","2019-03-28 16:29:52",""
"34390842","Android AES 256-bit ECB Encrypt data","<p>The code encrypted with Rijndael-128, but I need to encrypt with Rijndael-256.<br />I don't know how to change.<br /></p>

<p>Crypto：</p>

<pre><code>public class Crypto {
private static final String mEngine = ""AES"";
private static final String mCryptoEncrypt = ""AES/ECB/ZeroBytePadding"";
private String mKey;
public Crypto(String key) {
    this.mKey = key;
}
public byte[] cipher(byte[] data, int mode, String crypto)
        throws NoSuchAlgorithmException, NoSuchPaddingException,
        InvalidKeyException, IllegalBlockSizeException,
        BadPaddingException, InvalidAlgorithmParameterException {
    SecretKeySpec sks =new SecretKeySpec(mKey.getBytes(Charset
            .forName(""UTF-8"")), mEngine);

    Cipher c = Cipher.getInstance(crypto);
    c.init(mode, sks);
    return c.doFinal(data);
}

public String encrypt(byte[] data) throws InvalidKeyException,
        NoSuchAlgorithmException, NoSuchPaddingException,
        IllegalBlockSizeException, BadPaddingException,
        InvalidAlgorithmParameterException {
    return Base64.encodeToString(cipher(data, Cipher.ENCRYPT_MODE, mCryptoEncrypt), Base64.DEFAULT);
}

}
</code></pre>

<p><br />
MainActivity：</p>

<pre><code>private static final String STORE_UID = ""test"";
private static final String AES_KEY = ""0123456789123456"";
Crypto crypto = new Crypto(AES_KEY);     
String encode = crypto.encrypt(STORE_UID.getBytes(Charset.forName(""UTF-8"")));
</code></pre>

<p>Content：test<br />
Key：0123456789123456<br />
Result：vw4sykPYP90szFDu9RA4hA==</p>

<p>It encrypted with Rijndael-256 that should be ""WEszhnxsZvq/TtK8lnwfBs91A/S8XT9oHAGC0lCRAEM=""</p>
","","35","<android><encryption><rijndael>","0","","0","2015-12-21 07:32:30","","2","4","","","","2015-12-21 07:32:30","2015-12-23 05:46:00"
"58109626","How to match Key & IV generated by C# and JS CryptoJS","<p>I need help to find a way how to match IV and KEY from C# and JS,</p>

<p>with a simple C# code:</p>

<pre><code>Rijndael rijndael = Rijndael.Create();
byte[] saltArray = Encoding.ASCII.GetBytes(""20190925"");
Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(""password"", saltArray, 1000);
rijndael.Key = pdb.GetBytes(32);
rijndael.IV = pdb.GetBytes(16);
Console.WriteLine(BitConverter.ToString(rijndael.Key).Replace(""-"","""").ToLower());
//Output rijndael.Key = c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f
Console.WriteLine(BitConverter.ToString(rijndael.IV).Replace(""-"","""").ToLower());
//Output rijndael.IV = 063ead20a9d5f35ab83e1156ebe7c099
</code></pre>

<p>with a CryptoJS i can get a same KEY as C# but with the IV i don't get it why the value is not match</p>

<p>CryptoJS code:</p>

<pre><code>let key = CryptoJS.PBKDF2('password', '20190925', {keySize:256/32, iterations:1000})
console.log('key', key.toString(CryptoJS.enc.Hex))
//Output key =  'key', 'c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f'
let iv = CryptoJS.PBKDF2('password', '20190925', {keySize:128/32, iterations:1000})
console.log('iv', iv.toString(CryptoJS.enc.Hex))
//Output iv =  'iv', 'c1b34ea814586db4a22dad37e11c7256'
</code></pre>

<p>I just think if <code>rijndael.IV = pdb.GetBytes(16);</code> will just get half of <code>rijndael.Key = pdb.GetBytes(32);</code> hex, but the value totally different</p>

<p>is there a way to match IV of C# using CryptoJS?</p>
","<p>PBKDF2 must be executed for a length equal to the sum of key length and IV length. The result is divided into two parts. The first part corresponds to the key, the second part to the IV:</p>

<pre><code>let keyLen = 256/32
let ivLen = 128/32
let keyiv = CryptoJS.PBKDF2('password', '20190925', {keySize:keyLen + ivLen, iterations:1000})
let key = CryptoJS.lib.WordArray.create(keyiv.words.slice(0, keyLen));
let iv = CryptoJS.lib.WordArray.create(keyiv.words.slice(keyLen, keyLen + ivLen));
console.log('keyiv:', keyiv.toString())
console.log('key  :', key.toString())
console.log('iv   :', iv.toString())
</code></pre>

<p>This results in:</p>

<pre><code>keyiv: c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f063ead20a9d5f35ab83e1156ebe7c099
key  : c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f
iv   : 063ead20a9d5f35ab83e1156ebe7c099
</code></pre>

<p>which matches the result of the C# code. </p>
","34","<javascript><c#><aes><cryptojs><rijndael>","1","1","1","2019-09-26 08:49:46","58112975","0","","8943429","","2019-09-26 05:56:18","2019-09-26 04:35:00",""
"55683802","Rijandeal and special characters","<p>I'm using Rijandeal for enc./dec. and I noticed that some special characters are not correctly managed.</p>

<p>Here is the code:</p>

<pre><code>    static void Main(string[] args)
    {        
        string enc = RijanENC(""šđčćž"");
        string dec = RijanDEC(enc);

        Console.WriteLine(dec);
        Console.ReadKey();
    }

    private static string RijanENC(string texto_puro)
    {
        byte[] key = System.Text.Encoding.Default.GetBytes(""123abc12"");
        byte[] iv = System.Text.Encoding.Default.GetBytes(""0123456789abcdef"");
        byte[] stringToEncrypt = System.Text.Encoding.UTF32.GetBytes(texto_puro);


        Rijndael rjnAlg = Rijndael.Create();
        System.IO.MemoryStream ms = new MemoryStream();
        CryptoStream cs = new CryptoStream(ms, rjnAlg.CreateEncryptor(key, iv), CryptoStreamMode.Write);
        cs.Write(stringToEncrypt, 0, stringToEncrypt.Length);
        cs.FlushFinalBlock();
        return Convert.ToBase64String(ms.ToArray());
    }

    private static string RijanDEC(string texto_encriptado)
    {
        byte[] key = System.Text.Encoding.Default.GetBytes(""123abc12"");
        byte[] iv = System.Text.Encoding.Default.GetBytes(""0123456789abcdef"");
        byte[] stringToDecrypt = new byte[texto_encriptado.Length];


        Rijndael rjnAlg = Rijndael.Create();
        MemoryStream ms = new MemoryStream();
        CryptoStream cs = new CryptoStream(ms, rjnAlg.CreateDecryptor(key, iv), CryptoStreamMode.Write);
        stringToDecrypt = Convert.FromBase64String(texto_encriptado);
        cs.Write(stringToDecrypt, 0, stringToDecrypt.Length);
        cs.FlushFinalBlock();

        Encoding encoding = Encoding.UTF32;
        return encoding.GetString(ms.ToArray());
    }
</code></pre>

<p>So the text I want to enc. contains some diacritic characters šđčćž. After decoding i get sdccz instead even if using UTF32.</p>
","<p>The code for encrypting/decrypting works as expected, the console output is the problem.</p>

<p>Set the outputEncoding to display the characters in the proper encoding </p>

<pre><code>Console.OutputEncoding = System.Text.Encoding.UTF8;
Console.WriteLine(dec);
Console.ReadKey();
</code></pre>
","31","<c#><encryption><diacritics><rijndael>","2","1","1","2019-04-15 07:33:57","55684429","5","","","","","2019-04-15 06:46:59",""
"56449065","Converting RIJNDAEL 256 function from .Net to Python","<p>Can someone please help me with converting this code?</p>

<p>I tried to make RIJNDAEL256 function out of this code:</p>

<pre class=""lang-vb prettyprint-override""><code>EncryptRJ256(""lkirwf897+22#bbtrm8814z5qq=498j5"", ""741952hheeyy66#cs!9hjv887mxx7@8y"", ""A padded string to BLOCKSIZE length."")

Public Function EncryptRJ256(ByVal prm_key As String, ByVal prm_iv As String, ByVal prm_text_to_encrypt As String) As String
    Dim s As String = prm_text_to_encrypt
    Dim managed2 As New RijndaelManaged With {
    .Padding = PaddingMode.Zeros,
    .Mode = CipherMode.CBC,
    .BlockSize = 256
}
    Dim stream As New MemoryStream
    Dim stream2 As New CryptoStream(stream, managed2.CreateEncryptor(Encoding.ASCII.GetBytes(prm_key), Encoding.ASCII.GetBytes(prm_iv)), CryptoStreamMode.Write)
    Dim bytes As Byte() = Encoding.ASCII.GetBytes(s)
    stream2.Write(bytes, 0, bytes.Length)
    stream2.FlushFinalBlock()
    Return Convert.ToBase64String(stream.ToArray)
End Function
</code></pre>

<p>I need the output of the encrypted string to be something like this:</p>

<pre class=""lang-none prettyprint-override""><code>Dv0Y/AFXdFMlDrcldFCu8v5o9zAlLNgyM+vO+PFeSrpO8Ve82mdUcc4rkzp9afDYc75NmkSd4mdflt38kceOdA==

A padded string to BLOCKSIZE length
</code></pre>

<p>I came up with this but the output is invalid. It's probably because of wrong padding but I have no idea how to fix it:</p>

<pre class=""lang-python prettyprint-override""><code>from rijndael.cipher.crypt import new
from rijndael.cipher.blockcipher import MODE_CBC
import base64

PADDING = b'.'

def r_pad(payload, block_size=32):
    return payload + (block_size - len(payload) % block_size) * PADDING

KEY = 'lkirwf897+22#bbtrm8814z5qq=498j5'
IV = '741952hheeyy66#cs!9hjv887mxx7@8y'
plain_text = ""A padded string to BLOCKSIZE length.""

rjn = new(KEY, MODE_CBC, IV, blocksize=32)
encd = rjn.encrypt(r_pad(plain_text))
data = base64.b64encode(encd)
print(data)

rjn = new(KEY, MODE_CBC, IV, blocksize=32)
data = base64.b64decode(data)
decd = rjn.decrypt(r_pad(data))
print (decd)
</code></pre>

<p>This is the output:</p>

<pre class=""lang-none prettyprint-override""><code>Dv0Y/AFXdFMlDrcldFCu8v5o9zAlLNgyM+vO+PFeSrqWdzP1S1cumviFiEjNAjz5njnMMC9lfxsBl71x5y+xCw==

A padded string to BLOCKSIZE length.............................Å¿:è°⌐┘n┤«╞Px╜:æC┬♣╬Q┤▼«U_♦â☻ìr
</code></pre>
","<p>How silly of me! Here's what fixed my issue:</p>

<pre><code>from rijndael.cipher.crypt import new
from rijndael.cipher.blockcipher import MODE_CBC
import base64

PADDING = b'\x00'

def pad(payload, block_size=32):
    return payload + (block_size - len(payload) % block_size) * PADDING

def un_pad(payload):
    return payload.replace(PADDING, '')

KEY = 'lkirwf897+22#bbtrm8814z5qq=498j5'
IV = '741952hheeyy66#cs!9hjv887mxx7@8y'
plain_text = ""A padded string to BLOCKSIZE length.""

rjn = new(KEY, MODE_CBC, IV, blocksize=32)
encd = rjn.encrypt(pad(plain_text))
data = base64.b64encode(encd)
print(data)

rjn = new(KEY, MODE_CBC, IV, blocksize=32)
data = base64.b64decode(data)
decd = rjn.decrypt(un_pad(data))
print (decd)
</code></pre>
","26","<python><vb.net><encryption><rijndael>","1","1","1","2019-06-04 18:48:34","","0","","589259","","2019-06-04 18:48:34","2019-06-04 17:54:10",""
"51127271","Padding is invalid and cannot be removed - randomly thrown by RijndaelManaged","<p>I have searched for a good plain text file encryption in C# and came across a post on SO and have been using it for a while now. </p>

<p>I don't remember the original post I got the code from; but here's the copy of the original code, slightly modified for my own use:</p>

<pre><code>public static class StringCipher
{
    private const int Keysize = 256;

    private const int DerivationIterations = 1000;

    public static string Encrypt(string plainText, string fileName)
    {
        try
        {
            var saltStringBytes = Generate256BitsOfRandomEntropy();
            var ivStringBytes = Generate256BitsOfRandomEntropy();
            var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
            using (var password = new Rfc2898DeriveBytes(Machine.Udid, saltStringBytes, DerivationIterations))
            {
                var keyBytes = password.GetBytes(Keysize / 8);
                using (var symmetricKey = new RijndaelManaged())
                {
                    symmetricKey.BlockSize = 256;
                    symmetricKey.Mode = CipherMode.CBC;
                    symmetricKey.Padding = PaddingMode.PKCS7;
                    using (var encryptor = symmetricKey.CreateEncryptor(keyBytes, ivStringBytes))
                    {
                        using (var memoryStream = new MemoryStream())
                        {
                            using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
                            {
                                cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
                                cryptoStream.FlushFinalBlock();
                                var cipherTextBytes = saltStringBytes;
                                cipherTextBytes = cipherTextBytes.Concat(ivStringBytes).ToArray();
                                cipherTextBytes = cipherTextBytes.Concat(memoryStream.ToArray()).ToArray();
                                memoryStream.Close();
                                cryptoStream.Close();
                                return Convert.ToBase64String(cipherTextBytes);
                            }
                        }
                    }
                }
            }
        }
        catch (Exception exception)
        {
            throw new Exception(""Failed to encrypt "" + fileName + "" - "" + exception.Message, exception);
        }
    }

    public static string Decrypt(string cipherText, string fileName)
    {
        try
        {
            var cipherTextBytesWithSaltAndIv = Convert.FromBase64String(cipherText);
            var saltStringBytes = cipherTextBytesWithSaltAndIv.Take(Keysize / 8).ToArray();
            var ivStringBytes = cipherTextBytesWithSaltAndIv.Skip(Keysize / 8).Take(Keysize / 8).ToArray();
            var cipherTextBytes = cipherTextBytesWithSaltAndIv.Skip((Keysize / 8) * 2).Take(cipherTextBytesWithSaltAndIv.Length - ((Keysize / 8) * 2)).ToArray();
            using (var password = new Rfc2898DeriveBytes(Machine.Udid, saltStringBytes, DerivationIterations))
            {
                var keyBytes = password.GetBytes(Keysize / 8);
                using (var symmetricKey = new RijndaelManaged())
                {
                    symmetricKey.BlockSize = 256;
                    symmetricKey.Mode = CipherMode.CBC;
                    symmetricKey.Padding = PaddingMode.PKCS7;
                    using (var decryptor = symmetricKey.CreateDecryptor(keyBytes, ivStringBytes))
                    {
                        using (var memoryStream = new MemoryStream(cipherTextBytes))
                        {
                            using (var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read))
                            {
                                var plainTextBytes = new byte[cipherTextBytes.Length];
                                var decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
                                memoryStream.Close();
                                cryptoStream.Close();
                                return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
                            }
                        }
                    }
                }
            }
        }
        catch (Exception exception)
        {
            throw new Exception(""Failed to decrypt "" + fileName + "" - "" + exception.Message, exception);
        }
    }

    private static byte[] Generate256BitsOfRandomEntropy()
    {
        var randomBytes = new byte[32];
        using (var rngCsp = new RNGCryptoServiceProvider())
        {
            rngCsp.GetBytes(randomBytes);
        }
        return randomBytes;
    }
}
</code></pre>

<p>Every now and then, my app randomly throws this exception:</p>

<blockquote>
  <p>Padding is invalid and cannot be removed.</p>
</blockquote>

<p>And this is my stack trace:</p>

<pre><code>at System.Security.Cryptography.RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode paddingMode, Boolean fLast)
   at System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount)
   at System.Security.Cryptography.CryptoStream.FlushFinalBlock()
   at System.Security.Cryptography.CryptoStream.Dispose(Boolean disposing)
   at System.IO.Stream.Close()
   at System.IO.Stream.Dispose()
   at DisplayMapper.Lib.StringCipher.Decrypt(String cipherText, String fileName) in C:\Users\Latheesan\Desktop\MyApp\StringCipher.cs:line 82
</code></pre>

<p>The line <strong>82</strong> is referring to this:</p>

<blockquote>
  <p>return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);</p>
</blockquote>

<p>I have been reading up on this error and many post point to saying that the same key/password used to encrypt must be used to decrypt etc...</p>

<p>That is what I am doing in my implementation, I use a static password generated from a hash of the cpu/motherboard/hdd serial numbers with some random strings (which comes from <code>Machine.Udid</code>.</p>

<p>So, I am not sure what's causing this error. I haven't been able to re-produce it as the error occurs randomly. Any ideas?</p>
","","24","<c#><encryption><rijndael><rijndaelmanaged>","1","","0","2018-07-01 21:52:11","","5","","","","","2018-07-01 21:52:11",""
"57996716","Rijndael algo from Python to Android java result mismatch","<p>I'd like to convert from Python to Android java the following code:
<a href=""https://github.com/kdschlosser/samsungctl/blob/master/samsungctl/remote_encrypted/py3rijndael/rijndael.py"" rel=""nofollow noreferrer"">https://github.com/kdschlosser/samsungctl/blob/master/samsungctl/remote_encrypted/py3rijndael/rijndael.py</a></p>

<p>I just want to use the decrypt part like this:</p>

<pre><code>    r = Rijndael(binascii.unhexlify(key))
    return r.encrypt(input)
</code></pre>

<p>It seems AES/ECB/NoPadding</p>

<p>So I try:</p>

<pre><code>    Cipher ecipher = Cipher.getInstance(""AES/ECB/NoPadding""); 
</code></pre>

<p>But with same input and key, the result mismatch.
I also try the BouncyCastle library with RijndaelEngine but the result is the same.</p>

<p>Thanks to give me some help.</p>
","","23","<java><android><rijndael>","0","","0","2019-09-18 15:57:29","","0","1","","","","2019-09-18 15:57:29",""
"55198476","Why is my Encrypt/decrypt program not working?","<p>I'm learning algorithms and I coded a console project working with Rijndae cryption, with a given IV and Key.</p>

<p>It's really not working since It does not make any change to the given string, whatever you input it will output the same string.</p>

<p>Can someone tell me or guide me trough? I really don't know where am I doing wrong</p>

<p>Thank you in advance</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace RijndaelManage
{


    class Rijndael
    {


        public static void Main()
        {

            try
            {


                string original = ""input data here"";
                using (RijndaelManaged myRijndael = new RijndaelManaged())
                {


                    byte[] encrypted = EncryptStringToBytes(original);
                    string aftdecryp = DecryptStringFromBytes(encrypted);

                    Console.WriteLine(""Original:   {0}"", original);
                    Console.WriteLine(""After Decryption: {0}"", aftdecryp);

                }

            }
            catch (Exception e)
            {
                Console.WriteLine(""Error: {0}"", e.Message);
            }
        }

        public static byte[] EncryptStringToBytes(string plainText)

        {
            byte[] encrypted;
            if (plainText == null)
            {
                goto TR_0000;
            }
            else if (plainText.Length &gt; 0)
            {
                using (RijndaelManaged rijAlg = new RijndaelManaged())
                {
                    string s = ""NigeroTomoyo!@#$"";
                    string str2 = ""8321947192739743"";
                    rijAlg.KeySize = 0x80;
                    rijAlg.Mode = CipherMode.CBC;
                    rijAlg.Key = Encoding.UTF8.GetBytes(s);
                    rijAlg.IV = Encoding.UTF8.GetBytes(str2);
                    ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
                    using (MemoryStream msEncrypt = new MemoryStream())
                    {
                        using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                        {
                            using (StreamWriter writer = new StreamWriter(csEncrypt))
                            {
                                writer.Write(plainText);
                            }
                            encrypted = msEncrypt.ToArray();
                        }
                    }
                }
            }
            else
            {
                goto TR_0000;
            }
            return encrypted;
        TR_0000:
            throw new ArgumentNullException(""plainText"");
        }



         static string DecryptStringFromBytes(byte[] cipherText)
        {

            string plaintext;
            if (cipherText == null)
            {
                goto TR_0000;
            }
            else if (cipherText.Length &gt; 0)
            {
                plaintext = null;
                using (RijndaelManaged rijAlg = new RijndaelManaged())
                {
                    string s = ""NigeroTomoyo!@#$"";
                    string str3 = ""8321947192739743"";
                    rijAlg.KeySize = 0x80;
                    rijAlg.Mode = CipherMode.CBC;
                    rijAlg.Key = Encoding.UTF8.GetBytes(s);
                    rijAlg.IV = Encoding.UTF8.GetBytes(str3);
                    ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);
                    using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                    {
                        using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                        {
                            using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                            {
                                plaintext = srDecrypt.ReadToEnd();
                            }
                        }
                    }
                }
            }
            else
            {
                goto TR_0000;
            }
            return plaintext;
        TR_0000:
            throw new ArgumentNullException(""cipherText"");
        }

    }
}
</code></pre>
","","16","<rijndael>","0","","0","2019-03-16 16:34:57","","0","","11213281","","2019-03-16 16:34:57","2019-03-16 15:33:21",""
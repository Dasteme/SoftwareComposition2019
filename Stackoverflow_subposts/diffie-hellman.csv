post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>You can try using <a href=""http://docs.python.org/library/struct.html#format-characters"">struct</a>:</p>

<pre><code>import struct
struct.pack('L',longvalue)
</code></pre>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","5","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p><em>long/int to the byte array</em> looks like exact purpose of <code>struct.pack</code>.  For long integers that exceed 4(8) bytes, you can come up with something like the next:</p>

<pre><code>&gt;&gt;&gt; limit = 256*256*256*256 - 1
&gt;&gt;&gt; i = 1234567890987654321
&gt;&gt;&gt; parts = []
&gt;&gt;&gt; while i:
        parts.append(i &amp; limit)
        i &gt;&gt;= 32

&gt;&gt;&gt; struct.pack('&gt;' + 'L'*len(parts), *parts )
'\xb1l\x1c\xb1\x11""\x10\xf4'

&gt;&gt;&gt; struct.unpack('&gt;LL', '\xb1l\x1c\xb1\x11""\x10\xf4')
(2976652465L, 287445236)
&gt;&gt;&gt; (287445236L &lt;&lt; 32) + 2976652465L
1234567890987654321L
</code></pre>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","7","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>Basically what you need to do is convert the int/long into its base 256 representation -- i.e. a number whose ""digits"" range from 0-255. Here's a fairly efficient way to do something like that:</p>

<pre><code>def base256_encode(n, minwidth=0): # int/long to byte array
    if n &gt; 0:
        arr = []
        while n:
            n, rem = divmod(n, 256)
            arr.append(rem)
        b = bytearray(reversed(arr))
    elif n == 0:
        b = bytearray(b'\x00')
    else:
        raise ValueError

    if minwidth &gt; 0 and len(b) &lt; minwidth: # zero padding needed?
        b = (minwidth-len(b)) * '\x00' + b
    return b
</code></pre>

<p>You many not need the<code>reversed()</code>call depending on the endian-ness desired (doing so would require the padding to be done differently as well). Also note that as written it doesn't handle negative numbers.</p>

<p>You might also want to take a look at the similar but highly optimized <code>long_to_bytes()</code> function in the<code>number.py</code>module which is part of the open source <a href=""https://pypi.python.org/pypi/pycrypto"" rel=""nofollow"">Python Cryptography Toolkit</a>. It actually converts the number into a string, not a byte array, but that's a minor issue.</p>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","3","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>I haven't done any benchmarks, but this recipe ""works for me"".</p>

<p>The short version: use <code>'%x' % val</code>, then <code>unhexlify</code> the result. The devil is in the details, though, as <code>unhexlify</code> requires an even number of hex digits, which <code>%x</code> doesn't guarantee. See the docstring, and the liberal inline comments for details.</p>

<pre class=""lang-py prettyprint-override""><code>from binascii import unhexlify

def long_to_bytes (val, endianness='big'):
    """"""
    Use :ref:`string formatting` and :func:`~binascii.unhexlify` to
    convert ``val``, a :func:`long`, to a byte :func:`str`.

    :param long val: The value to pack

    :param str endianness: The endianness of the result. ``'big'`` for
      big-endian, ``'little'`` for little-endian.

    If you want byte- and word-ordering to differ, you're on your own.

    Using :ref:`string formatting` lets us use Python's C innards.
    """"""

    # one (1) hex digit per four (4) bits
    width = val.bit_length()

    # unhexlify wants an even multiple of eight (8) bits, but we don't
    # want more digits than we need (hence the ternary-ish 'or')
    width += 8 - ((width % 8) or 8)

    # format width specifier: four (4) bits per hex digit
    fmt = '%%0%dx' % (width // 4)

    # prepend zero (0) to the width, to zero-pad the output
    s = unhexlify(fmt % val)

    if endianness == 'little':
        # see http://stackoverflow.com/a/931095/309233
        s = s[::-1]

    return s
</code></pre>

<p>...and my <a href=""https://nose.readthedocs.org/en/latest/"" rel=""noreferrer"">nosetest</a> unit tests ;-)</p>

<pre class=""lang-py prettyprint-override""><code>class TestHelpers (object):
    def test_long_to_bytes_big_endian_small_even (self):
        s = long_to_bytes(0x42)
        assert s == '\x42'

        s = long_to_bytes(0xFF)
        assert s == '\xff'

    def test_long_to_bytes_big_endian_small_odd (self):
        s = long_to_bytes(0x1FF)
        assert s == '\x01\xff'

        s = long_to_bytes(0x201FF)
        assert s == '\x02\x01\xff'

    def test_long_to_bytes_big_endian_large_even (self):
        s = long_to_bytes(0xab23456c8901234567)
        assert s == '\xab\x23\x45\x6c\x89\x01\x23\x45\x67'

    def test_long_to_bytes_big_endian_large_odd (self):
        s = long_to_bytes(0x12345678901234567)
        assert s == '\x01\x23\x45\x67\x89\x01\x23\x45\x67'

    def test_long_to_bytes_little_endian_small_even (self):
        s = long_to_bytes(0x42, 'little')
        assert s == '\x42'

        s = long_to_bytes(0xFF, 'little')
        assert s == '\xff'

    def test_long_to_bytes_little_endian_small_odd (self):
        s = long_to_bytes(0x1FF, 'little')
        assert s == '\xff\x01'

        s = long_to_bytes(0x201FF, 'little')
        assert s == '\xff\x01\x02'

    def test_long_to_bytes_little_endian_large_even (self):
        s = long_to_bytes(0xab23456c8901234567, 'little')
        assert s == '\x67\x45\x23\x01\x89\x6c\x45\x23\xab'

    def test_long_to_bytes_little_endian_large_odd (self):
        s = long_to_bytes(0x12345678901234567, 'little')
        assert s == '\x67\x45\x23\x01\x89\x67\x45\x23\x01'
</code></pre>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","18","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>Little-endian, reverse the result or the range if you want Big-endian:</p>

<pre><code>def int_to_bytes(val, num_bytes):
    return [(val &amp; (0xff &lt;&lt; pos*8)) &gt;&gt; pos*8 for pos in range(num_bytes)]
</code></pre>

<p>Big-endian:</p>

<pre><code>def int_to_bytes(val, num_bytes):
    return [(val &amp; (0xff &lt;&lt; pos*8)) &gt;&gt; pos*8 for pos in reversed(range(num_bytes))]
</code></pre>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","6","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>One-liner:</p>

<pre><code>bytearray.fromhex('{:0192x}'.format(big_int))
</code></pre>

<p>The 192 is 768 / 4, because OP wanted 768-bit numbers and there are 4 bits in a hex digit. If you need a bigger <code>bytearray</code> use a format string with a higher number. Example:</p>

<pre><code>&gt;&gt;&gt; big_int = 911085911092802609795174074963333909087482261102921406113936886764014693975052768158290106460018649707059449553895568111944093294751504971131180816868149233377773327312327573120920667381269572962606994373889233844814776702037586419
&gt;&gt;&gt; bytearray.fromhex('{:0192x}'.format(big_int))
bytearray(b'\x96;h^\xdbJ\x8f3obL\x9c\xc2\xb0-\x9e\xa4Sj-\xf6i\xc1\x9e\x97\x94\x85M\x1d\x93\x10\\\x81\xc2\x89\xcd\xe0a\xc0D\x81v\xdf\xed\xa9\xc1\x83p\xdbU\xf1\xd0\xfeR)\xce\x07\xdepM\x88\xcc\x7fv\\\x1c\x8di\x87N\x00\x8d\xa8\xbd[&lt;\xdf\xaf\x13z:H\xed\xc2)\xa4\x1e\x0f\xa7\x92\xa7\xc6\x16\x86\xf1\xf3')
&gt;&gt;&gt; lepi_int = 0x963b685edb4a8f336f624c9cc2b02d9ea4536a2df669c19e9794854d1d93105c81c289cde061c0448176dfeda9c18370db55f1d0fe5229ce07de704d88cc7f765c1c8d69874e008da8bd5b3cdfaf137a3a48edc229a41e0fa792a7c61686f1f
&gt;&gt;&gt; bytearray.fromhex('{:0192x}'.format(lepi_int))
bytearray(b'\tc\xb6\x85\xed\xb4\xa8\xf36\xf6$\xc9\xcc+\x02\xd9\xeaE6\xa2\xdff\x9c\x19\xe9yHT\xd1\xd91\x05\xc8\x1c(\x9c\xde\x06\x1c\x04H\x17m\xfe\xda\x9c\x187\r\xb5_\x1d\x0f\xe5""\x9c\xe0}\xe7\x04\xd8\x8c\xc7\xf7e\xc1\xc8\xd6\x98t\xe0\x08\xda\x8b\xd5\xb3\xcd\xfa\xf17\xa3\xa4\x8e\xdc""\x9aA\xe0\xfay*|aho\x1f')
</code></pre>

<p>[My answer had used <code>hex()</code> before. I corrected it with <code>format()</code> in order to handle ints with odd-sized byte expressions. This fixes previous complaints about <code>ValueError</code>.]</p>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","14","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>With Python 3.2 and later, you can use <code>int.to_bytes</code> and <code>int.from_bytes</code>: <a href=""https://docs.python.org/3/library/stdtypes.html#int.to_bytes"" rel=""noreferrer"">https://docs.python.org/3/library/stdtypes.html#int.to_bytes</a></p>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","44","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>Everyone has overcomplicated this answer:</p>

<pre><code>some_int = &lt;256 bit integer&gt;
some_bytes = some_int.to_bytes(32, sys.byteorder)
my_bytearray = bytearray(some_bytes)
</code></pre>

<p>You just need to know the number of bytes that you are trying to convert. In my use cases, normally I only use this large of numbers for crypto, and at that point I have to worry about modulus and what-not, so I don't think this is a big problem to be required to know the max number of bytes to return.</p>

<p>Since you are doing it as 768-bit math, then instead of 32 as the argument it would be 96.</p>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","13","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<p>Python 2.7 does not implement the int.to- very slow_bytes() method.</p>

<p>I tried 3 methods:</p>

<ol>
<li>hex unpack/pack : very slow</li>
<li>byte shifting 8 bits at a time: significantly faster.</li>
<li>using a ""C"" module and packing into the lower (7 ia64 or 3 i32) bytes.
This was about twice as fast as 2/ . It is the fastest option, but still too slow.</li>
</ol>

<p>All these methods are very inefficient for two reasons: </p>

<ul>
<li>Python 2.7 does not support this useful operation.</li>
<li>c does not support extended precision arithmetic using the carry/borrow/overflow flags available on most platforms.</li>
</ul>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","2","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"8730927","Convert python long/int to fixed size byte array","<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>

<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
","<pre><code>i = 0x12345678
s = struct.pack('&lt;I',i)
b = struct.unpack('BBBB',s)
</code></pre>
","81465","<python><bytearray><long-integer><diffie-hellman><rc4-cipher>","39","0","10","2019-03-06 02:09:10","14527004","2","10","21234","","2012-05-05 16:16:07","2012-01-04 17:11:09",""
"10471009","How does the man in the middle attack work in Diffie–Hellman?","<p>I'm having doubts about the mechanics of a man in the middle attack during a Diffie–Hellman key exchange. I have heard that it can happen during the key agreement communication. But in the presence of CA (Certificate Authority) the receiver can authenticate the sender as he received the sender's public key. Therefore, how is a man in the middle attack possible?</p>
","<p>I think you're confusing the basic Diffe-Hellman, which is a key exchange protocol, with the 'authenticated version' which uses a certificate authority (CA).</p>

<p>Nice explanation of how the basic Diffe-Hellman is vulnerable to man-in-the-middle <a href=""http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/what-is-diffie-hellman.htm"">from RSA Labs</a>.</p>

<blockquote>
  <p>""The Diffie-Hellman key exchange is vulnerable to a man-in-the-middle
  attack. In this attack, an opponent Carol intercepts Alice's public
  value and sends her own public value to Bob. When Bob transmits his
  public value, Carol substitutes it with her own and sends it to Alice.
  Carol and Alice thus agree on one shared key and Carol and Bob agree
  on another shared key. After this exchange, Carol simply decrypts any
  messages sent out by Alice or Bob, and then reads and possibly
  modifies them before re-encrypting with the appropriate key and
  transmitting them to the other party. This vulnerability is present
  because Diffie-Hellman key exchange does not authenticate the
  participants. Possible solutions include the use of digital signatures
  and other protocol variants.""</p>
</blockquote>

<p>and it follows with the authenticated version, also known as the <a href=""http://en.wikipedia.org/wiki/Station-to-Station_protocol"">Station-to-Station protocol</a>:</p>

<blockquote>
  <p>""Roughly speaking, the basic idea is as follows. Prior to execution of
  the protocol, the two parties Alice and Bob each obtain a
  public/private key pair and a certificate for the public key. During
  the protocol, Alice computes a signature on certain messages, covering
  the public value <em>g</em><sup>a</sup> mod <em>p</em>. Bob proceeds in a similar way. Even though
  Carol is still able to intercept messages between Alice and Bob, she
  cannot forge signatures without Alice's private key and Bob's private
  key. Hence, the enhanced protocol defeats the man-in-the-middle
  attack.""</p>
</blockquote>

<p>So the basic version is susceptible to a man-in-the-middle attack, the authenticated version that uses public key certificates is not.</p>
","55469","<public-key-encryption><diffie-hellman>","26","73","2","2018-08-12 22:54:03","10496684","0","9","104223","","2012-05-25 12:34:20","2012-05-06 13:48:18",""
"10471009","How does the man in the middle attack work in Diffie–Hellman?","<p>I'm having doubts about the mechanics of a man in the middle attack during a Diffie–Hellman key exchange. I have heard that it can happen during the key agreement communication. But in the presence of CA (Certificate Authority) the receiver can authenticate the sender as he received the sender's public key. Therefore, how is a man in the middle attack possible?</p>
","<p>This is how Diffie-Hellman works:</p>

<p><img src=""https://i.imgur.com/oFIYQRW.png?1"" alt=""Diffie-Hellman""></p>

<p>And this is how the man-in-the-middle attack works in Diffie-Hellman:</p>

<p><img src=""https://i.imgur.com/Cq78TET.png?1"" alt=""mitm""></p>

<p>There are two D-H key exchange, Alice and Attacker share the same key with k1, while Bob and Attacker share the other same key with k2. </p>

<p>Because Alice and Bob had no prior knowledge of each other. </p>

<p>But the Attacker must keep listening and forwarding.  </p>
","55469","<public-key-encryption><diffie-hellman>","26","26","2","2018-08-12 22:54:03","10496684","0","9","104223","","2012-05-25 12:34:20","2012-05-06 13:48:18",""
"14034508","DH vs. DHE and ECDHE and perfect forward secrecy","<p>Does Diffie-Hellman (DH) provide perfect forward secrecy? or is it a feature for Ephemeral Diffie-Hellman (DHE) only ?
Is Elliptic Curve Ephemeral diffie-Hellman (ECDHE) is better than DHE ? </p>
","<p>It's the ephemeral aspect of DHE and ECDHE that provides perfect forward secrecy.</p>

<p>The idea is that even if someone records traffic and compromises the server to get its private key, they won't be able to decipher that traffic, because they'll be missing the ephemeral DH parameters that won't have been saved. With fixed DH, the private DH parameters are effectively the private key: they would also be compromised in the same way and allow the attacker to decipher past traffic too.
(Note that support for fixed DH, non-anonymous cipher suites is quite rare in practice anyway.)</p>

<p>The perfect forward secrecy offered by DHE comes at a price: more computation. The ECDHE variants uses elliptic curve cryptography to reduce this computational cost. You may find further details and benchmarks in <a href=""http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html"" rel=""noreferrer"">Vincent Bernat's <em>SSL/TLS &amp; Perfect Forward Secrecy</em> article</a>.</p>
","41788","<ssl><public-key-encryption><diffie-hellman>","37","44","1","2012-12-26 13:08:41","14041040","0","16","1810868","","2012-12-25 23:41:22","2012-12-25 22:43:05",""
"30931692","Diffie-Hellman public key error with Tomcat 7","<p>I successfully set up two Ubuntu machines with Tomcat and SSL certificates. 
I followed exactly the same procedure with Centos 6, but I'm getting this when I'm trying to connect to the Server (using Opera):</p>

<blockquote>
  <p>Server has a weak, ephemeral Diffie-Hellman public key</p>
</blockquote>

<p>The connector is the following, and there are no errors in catalina.log:</p>

<pre><code>&lt;Connector port=""some port number""  
           protocol=""org.apache.coyote.http11.Http11Protocol"" 
           SSLEnabled=""true""
           maxThreads=""150"" scheme=""https"" secure=""true""
           clientAuth=""false"" sslProtocol=""TLS""
           keystoreFile=""path to jks""
           keystoreType=""JKS""
           keystorePass=""mypass1""
           keyPass=""mypass2""  /&gt; 
</code></pre>

<p>With Firefox, I get the untrusted communication error.</p>
","<p>For me it worked after adding a list of allowed ciphers to the Tomcat configuration in conf/server.xml to disable the weak Diffie-Hellman ciphers:</p>

<pre><code>    &lt;Connector
        ...
        ciphers=""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA""
        ...
</code></pre>
","31987","<tomcat><ssl><centos><certificate><diffie-hellman>","14","30","5","2015-11-24 09:40:29","31044451","0","5","4996088","","2015-06-19 06:58:09","2015-06-19 06:48:09",""
"30931692","Diffie-Hellman public key error with Tomcat 7","<p>I successfully set up two Ubuntu machines with Tomcat and SSL certificates. 
I followed exactly the same procedure with Centos 6, but I'm getting this when I'm trying to connect to the Server (using Opera):</p>

<blockquote>
  <p>Server has a weak, ephemeral Diffie-Hellman public key</p>
</blockquote>

<p>The connector is the following, and there are no errors in catalina.log:</p>

<pre><code>&lt;Connector port=""some port number""  
           protocol=""org.apache.coyote.http11.Http11Protocol"" 
           SSLEnabled=""true""
           maxThreads=""150"" scheme=""https"" secure=""true""
           clientAuth=""false"" sslProtocol=""TLS""
           keystoreFile=""path to jks""
           keystoreType=""JKS""
           keystorePass=""mypass1""
           keyPass=""mypass2""  /&gt; 
</code></pre>

<p>With Firefox, I get the untrusted communication error.</p>
","<p>It works with Google Chrome ver.44 and Thanks to Jason Scroggins for suggesting:</p>

<ol>
<li>In a new tab, type or paste <code>about:config</code> in the address bar and press Enter. Click the button promising to be careful.</li>
<li>In the search box above the list, type or paste dhe and pause while the list is filtered.</li>
<li>Double-click the <code>security.ssl3.dhe_rsa_aes_128_sha</code> preference to switch it from true to false (disable Firefox from using this cipher).</li>
<li>Double-click the <code>security.ssl3.dhe_rsa_aes_256_sha</code> preference to switch it from true to false (disable Firefox from using this cipher).</li>
</ol>
","31987","<tomcat><ssl><centos><certificate><diffie-hellman>","14","2","5","2015-11-24 09:40:29","31044451","0","5","4996088","","2015-06-19 06:58:09","2015-06-19 06:48:09",""
"30931692","Diffie-Hellman public key error with Tomcat 7","<p>I successfully set up two Ubuntu machines with Tomcat and SSL certificates. 
I followed exactly the same procedure with Centos 6, but I'm getting this when I'm trying to connect to the Server (using Opera):</p>

<blockquote>
  <p>Server has a weak, ephemeral Diffie-Hellman public key</p>
</blockquote>

<p>The connector is the following, and there are no errors in catalina.log:</p>

<pre><code>&lt;Connector port=""some port number""  
           protocol=""org.apache.coyote.http11.Http11Protocol"" 
           SSLEnabled=""true""
           maxThreads=""150"" scheme=""https"" secure=""true""
           clientAuth=""false"" sslProtocol=""TLS""
           keystoreFile=""path to jks""
           keystoreType=""JKS""
           keystorePass=""mypass1""
           keyPass=""mypass2""  /&gt; 
</code></pre>

<p>With Firefox, I get the untrusted communication error.</p>
","<p>This is due to the fact that new browser versions have started to either issue warning/errors when accessing web sites which are configured with weak DH ciphers for SSL. For more information about issue follow below links</p>

<p><a href=""https://weakdh.org"" rel=""nofollow noreferrer"">https://weakdh.org</a></p>

<p><a href=""https://security.stackexchange.com/questions/89689/what-is-logjam-and-how-do-i-prevent-it"">logjam issue</a> </p>

<p>To fix this either you can find a way around this at browser side or server side. Servers side is the best as it will fix the issue for all users , if they are accessing server from different browsers/locations. </p>

<p>Fix the issue we have to make sure our server (in this case tomcat) use strong ciphers for SSL.</p>

<p>In tomcat, there are two different implementations of SSL. Defautl is JSSE implementation provided as part of the Java runtime. Other being APR implementation, which uses the OpenSSL engine by default. </p>

<p>JSSE since it's dependent on the Java runtime, we have to first find out which Java version we are using with tomcat. Tomcat 7 supports java 1.6 upwards. Then we have to find the respective cipher suites supported by relevant java version of JSSE. Weak ones are which which has '<em>DHE</em>', so pick ones which does not contain '<em>DHE</em>'. Few of stronger suites for java 1.6 JSSE is listed below. </p>

<pre><code>TLS_RSA_WITH_AES_128_CBC_SHA
TLS_RSA_WITH_AES_256_CBC_SHA
TLS_ECDH_ECDSA_WITH_RC4_128_SHA
TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
TLS_ECDH_RSA_WITH_RC4_128_SHA
TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
TLS_ECDHE_RSA_WITH_RC4_128_SHA
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDH_ECDSA_WITH_NULL_SHA
TLS_ECDH_RSA_WITH_NULL_SHA
TLS_ECDHE_ECDSA_WITH_NULL_SHA
TLS_ECDHE_RSA_WITH_NULL_SHA
...
</code></pre>

<p>Compile a list of strong cipher suits and add it to the connector ciphers in conf/server.xml in your tomcat</p>

<pre><code>&lt;Connector
...
ciphers=""TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDH_ECDSA_WITH_RC4_128_SHA,TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDH_RSA_WITH_RC4_128_SHA,TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_RC4_128_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDH_ECDSA_WITH_NULL_SHA,TLS_ECDH_RSA_WITH_NULL_SHA,TLS_ECDHE_ECDSA_WITH_NULL_SHA,TLS_ECDHE_RSA_WITH_NULL_SHA""
...
/&gt;
</code></pre>

<p>Restart the server and error/warning should go away. Remember if Java version is different copy/pasting above might not work. So refer to correct version and supported cipher suites.</p>

<p>Note: To be able to use the 256 bit AES Ciphers, it is necessary to install the JCE Unlimited Strength Jurisdiction Policy Files</p>

<p>If Tomcat is configured to use APR instead of JSSE, above configuration will not work. You can enable strong cipher suites by following tomcat ssl configuration guide for APR  and <a href=""https://weakdh.org"" rel=""nofollow noreferrer"">logjam</a> admin guide .</p>
","31987","<tomcat><ssl><centos><certificate><diffie-hellman>","14","7","5","2015-11-24 09:40:29","31044451","0","5","4996088","","2015-06-19 06:58:09","2015-06-19 06:48:09",""
"30931692","Diffie-Hellman public key error with Tomcat 7","<p>I successfully set up two Ubuntu machines with Tomcat and SSL certificates. 
I followed exactly the same procedure with Centos 6, but I'm getting this when I'm trying to connect to the Server (using Opera):</p>

<blockquote>
  <p>Server has a weak, ephemeral Diffie-Hellman public key</p>
</blockquote>

<p>The connector is the following, and there are no errors in catalina.log:</p>

<pre><code>&lt;Connector port=""some port number""  
           protocol=""org.apache.coyote.http11.Http11Protocol"" 
           SSLEnabled=""true""
           maxThreads=""150"" scheme=""https"" secure=""true""
           clientAuth=""false"" sslProtocol=""TLS""
           keystoreFile=""path to jks""
           keystoreType=""JKS""
           keystorePass=""mypass1""
           keyPass=""mypass2""  /&gt; 
</code></pre>

<p>With Firefox, I get the untrusted communication error.</p>
","<p>For me,It was the issue of java version being used by tomcat.
I changed the version from JDK 6 to JDK 1.7_080 and the error vanished.<p>
When I said I changed the JAVA version,I meant I modified the environment variable ""JAVA_HOME"".</p>
","31987","<tomcat><ssl><centos><certificate><diffie-hellman>","14","0","5","2015-11-24 09:40:29","31044451","0","5","4996088","","2015-06-19 06:58:09","2015-06-19 06:48:09",""
"30931692","Diffie-Hellman public key error with Tomcat 7","<p>I successfully set up two Ubuntu machines with Tomcat and SSL certificates. 
I followed exactly the same procedure with Centos 6, but I'm getting this when I'm trying to connect to the Server (using Opera):</p>

<blockquote>
  <p>Server has a weak, ephemeral Diffie-Hellman public key</p>
</blockquote>

<p>The connector is the following, and there are no errors in catalina.log:</p>

<pre><code>&lt;Connector port=""some port number""  
           protocol=""org.apache.coyote.http11.Http11Protocol"" 
           SSLEnabled=""true""
           maxThreads=""150"" scheme=""https"" secure=""true""
           clientAuth=""false"" sslProtocol=""TLS""
           keystoreFile=""path to jks""
           keystoreType=""JKS""
           keystorePass=""mypass1""
           keyPass=""mypass2""  /&gt; 
</code></pre>

<p>With Firefox, I get the untrusted communication error.</p>
","<p>Add this into the server.xml file and restart the server </p>

<pre><code>&lt;Connector port=""8443"" protocol=""HTTP/1.1"" SSLEnabled=""true""
       maxThreads=""150"" scheme=""https"" secure=""true""
       keystoreFile=""keystorePath""
       keystorePass=""keystorepass""
       ciphers=""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA""
       clientAuth=""false"" sslProtocol=""TLS""/&gt;
</code></pre>

<p>Try to browse with <a href=""https://localhost:8443"" rel=""nofollow"">https://localhost:8443</a></p>
","31987","<tomcat><ssl><centos><certificate><diffie-hellman>","14","2","5","2015-11-24 09:40:29","31044451","0","5","4996088","","2015-06-19 06:58:09","2015-06-19 06:48:09",""
"4413023","AES encryption: InvalidKeyException: Key length not 128/192/256 bits","<p>I'm trying to encrypt a string on Android with AES. The symmetric key is determined previously with the Diffie-Hellman algorithm and seems to be ok (Key Length is 128 Bit, see below).<br>
Nevertheless, I get a  <code>InvalidKeyException: ""Key length not 128/192/256 bits.</code>""</p>

<p>Code:</p>

<pre><code>KeyAgreement keyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
keyAgree.init(this.smartphonePrivKey);
keyAgree.doPhase(serverPubKey, true);
SecretKey key = keyAgree.generateSecret(""AES"");
System.out.println(""Key Length: "" + key.getEncoded().length);
System.out.println(""Key Algorithm: ""+ key.getAlgorithm());
System.out.println(""Key Format: ""+ key.getFormat());

byte[] encrypted = null;
  Cipher cipher;
  try {
   cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
   System.out.println(""Allowed Key Length: ""
     + cipher.getMaxAllowedKeyLength(""AES""));
   cipher.init(Cipher.ENCRYPT_MODE, key);
   encrypted = cipher.doFinal(""YEAH"".getBytes(""UTF8""));
  } catch (NoSuchAlgorithmException e) {
   e.printStackTrace();
  } catch (NoSuchPaddingException e) {
   e.printStackTrace();
  } catch (InvalidKeyException e) {
   e.printStackTrace();
  } catch (IllegalBlockSizeException e) {
   e.printStackTrace();
  } catch (BadPaddingException e) {
   e.printStackTrace();
  } catch (UnsupportedEncodingException e) {
   e.printStackTrace();
  }
</code></pre>

<p>The above Code leads to the following output:  </p>

<pre><code>_12-10 20:24:53.119: INFO/System.out(757): Key Length: 128_  
_12-10 20:24:53.119: INFO/System.out(757): Key Algorithm: AES_   
_12-10 20:24:53.119: INFO/System.out(757): Key Format: RAW_  
_12-10 20:24:53.470: INFO/System.out(757): Allowed Key Length: 2147483647_ 
</code></pre>

<p>After that, I get the <code>InvalidKeyException: Key length not 128/192/256 bits.</code> But as you can see, the SecretKey has a length of 128 Bits!  </p>

<p>Any ideas?</p>
","<p>The key you generated is 128 <em>bytes</em>, not 128 <em>bits</em>. ""Key Length"" should be 16.</p>
","20039","<android><encryption><aes><diffie-hellman>","13","24","2","2017-11-02 17:15:30","4413290","0","5","663604","","2017-11-02 17:15:30","2010-12-10 20:29:52",""
"4413023","AES encryption: InvalidKeyException: Key length not 128/192/256 bits","<p>I'm trying to encrypt a string on Android with AES. The symmetric key is determined previously with the Diffie-Hellman algorithm and seems to be ok (Key Length is 128 Bit, see below).<br>
Nevertheless, I get a  <code>InvalidKeyException: ""Key length not 128/192/256 bits.</code>""</p>

<p>Code:</p>

<pre><code>KeyAgreement keyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
keyAgree.init(this.smartphonePrivKey);
keyAgree.doPhase(serverPubKey, true);
SecretKey key = keyAgree.generateSecret(""AES"");
System.out.println(""Key Length: "" + key.getEncoded().length);
System.out.println(""Key Algorithm: ""+ key.getAlgorithm());
System.out.println(""Key Format: ""+ key.getFormat());

byte[] encrypted = null;
  Cipher cipher;
  try {
   cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
   System.out.println(""Allowed Key Length: ""
     + cipher.getMaxAllowedKeyLength(""AES""));
   cipher.init(Cipher.ENCRYPT_MODE, key);
   encrypted = cipher.doFinal(""YEAH"".getBytes(""UTF8""));
  } catch (NoSuchAlgorithmException e) {
   e.printStackTrace();
  } catch (NoSuchPaddingException e) {
   e.printStackTrace();
  } catch (InvalidKeyException e) {
   e.printStackTrace();
  } catch (IllegalBlockSizeException e) {
   e.printStackTrace();
  } catch (BadPaddingException e) {
   e.printStackTrace();
  } catch (UnsupportedEncodingException e) {
   e.printStackTrace();
  }
</code></pre>

<p>The above Code leads to the following output:  </p>

<pre><code>_12-10 20:24:53.119: INFO/System.out(757): Key Length: 128_  
_12-10 20:24:53.119: INFO/System.out(757): Key Algorithm: AES_   
_12-10 20:24:53.119: INFO/System.out(757): Key Format: RAW_  
_12-10 20:24:53.470: INFO/System.out(757): Allowed Key Length: 2147483647_ 
</code></pre>

<p>After that, I get the <code>InvalidKeyException: Key length not 128/192/256 bits.</code> But as you can see, the SecretKey has a length of 128 Bits!  </p>

<p>Any ideas?</p>
","<p>This exception basically occur due to length of key that you hava passed for encryption.If you are using AES encryption then the number of characters must be in length of 128/192/256 bits.
For example you can use the key of 16 character,24 character or 32 character.</p>

<pre><code>String encrypted_data=AES.encrypt(""HELLO"",""ASDFGHJKLASDFGHJ"");
</code></pre>

<p>Hope this help...</p>
","20039","<android><encryption><aes><diffie-hellman>","13","7","2","2017-11-02 17:15:30","4413290","0","5","663604","","2017-11-02 17:15:30","2010-12-10 20:29:52",""
"22479508","Java Diffie-Hellman key exchange","<p>I'm trying to execute code to perform the Diffie-Hellman key exchange. I sourced the code from an example online (forget where now).
I had to import the bouncycastle.jar, which I assumed worked up until execution.</p>

<p><img src=""https://i.stack.imgur.com/ypoi7.png"" alt=""stacktrace screenshot""></p>

<p>my code:</p>

<pre><code>package testproject;

import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.Security;
import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;

public class KeyGen {

  private static BigInteger g512 = new BigInteger(""1234567890"", 16);
  //generates a random, non-negative integer for Base

  private static BigInteger p512 = new BigInteger(""1234567890"", 16);
  //generates a random, non-negative integer for Prime

  public static void main(String[] args) throws Exception {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    DHParameterSpec dhParams = new DHParameterSpec(p512, g512);
    //Specify parameters to use for the algorithm
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"", ""BC"");
    //Define specific algorithm to use ""diffie-hellman"", with provider ""bc""

    keyGen.initialize(dhParams, new SecureRandom());
    //initialize with parameters &amp; secure random seed

    KeyAgreement aKeyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
    //define algorithm for A's key agreement
    KeyPair aPair = keyGen.generateKeyPair();
    //generate keyPair for A

    KeyAgreement bKeyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
    //define algorithm for B's key agreement
    KeyPair bPair = keyGen.generateKeyPair();
    //generate keyPair for B

    aKeyAgree.init(aPair.getPrivate());
    //initialize A's keyAgreement with A's private key
    bKeyAgree.init(bPair.getPrivate());
    //initialize B's keyAgreement with B's private key

    aKeyAgree.doPhase(bPair.getPublic(), true);
    //do last phase of A's keyAgreement with B's public key
    bKeyAgree.doPhase(aPair.getPublic(), true);
    //do last phase of B's keyAgreement with A's public key

    MessageDigest hash = MessageDigest.getInstance(""SHA1"", ""BC"");

    System.out.println(new String(hash.digest(aKeyAgree.generateSecret())));
    //generate secret key for A, hash it.
    System.out.println(new String(hash.digest(bKeyAgree.generateSecret())));
    //generate secret key for B, hash it.
  }
}
</code></pre>

<p>This is the line causing the problem:</p>

<pre><code>KeyPair aPair = keyGen.generateKeyPair();
</code></pre>

<p>I'm confused as to what the error is, as I've found each of the methods it's returning 'unknown source' for.</p>

<p>Any light shed on this would be much appreciated.</p>

<p>Continued(Edit):
<a href=""https://stackoverflow.com/questions/22492417/java-diffie-hellman-encryption-wrong-output"">Java - Diffie-Hellman Encryption - Wrong Output</a></p>
","<p>This comment is simply wrong:</p>

<pre><code>private static BigInteger g512 = new BigInteger(""1234567890"", 16);
//generates a random, non-negative integer for Base
</code></pre>

<p>All you are doing there is creating the number <code>0x1234567890</code> every time.  There is nothing random about it.</p>

<p>It looks like you copied from <a href=""http://www.java2s.com/Tutorial/Java/0490__Security/DiffieHellmanKeyAgreement.htm"" rel=""nofollow noreferrer"">http://www.java2s.com/Tutorial/Java/0490__Security/DiffieHellmanKeyAgreement.htm</a>.  As <a href=""https://stackoverflow.com/a/10902798/701303"">this answer</a> agrees, the code there does not make sense.</p>

<p>You could try <a href=""http://www.java2s.com/Tutorial/Java/0490__Security/ImplementingtheDiffieHellmankeyexchange.htm"" rel=""nofollow noreferrer"">the actual key exchange example</a> on that site.</p>
","13466","<java><bouncycastle><diffie-hellman>","5","4","3","2019-02-25 14:53:00","","0","3","-1","","2017-05-23 11:54:07","2014-03-18 12:32:33",""
"22479508","Java Diffie-Hellman key exchange","<p>I'm trying to execute code to perform the Diffie-Hellman key exchange. I sourced the code from an example online (forget where now).
I had to import the bouncycastle.jar, which I assumed worked up until execution.</p>

<p><img src=""https://i.stack.imgur.com/ypoi7.png"" alt=""stacktrace screenshot""></p>

<p>my code:</p>

<pre><code>package testproject;

import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.Security;
import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;

public class KeyGen {

  private static BigInteger g512 = new BigInteger(""1234567890"", 16);
  //generates a random, non-negative integer for Base

  private static BigInteger p512 = new BigInteger(""1234567890"", 16);
  //generates a random, non-negative integer for Prime

  public static void main(String[] args) throws Exception {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    DHParameterSpec dhParams = new DHParameterSpec(p512, g512);
    //Specify parameters to use for the algorithm
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"", ""BC"");
    //Define specific algorithm to use ""diffie-hellman"", with provider ""bc""

    keyGen.initialize(dhParams, new SecureRandom());
    //initialize with parameters &amp; secure random seed

    KeyAgreement aKeyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
    //define algorithm for A's key agreement
    KeyPair aPair = keyGen.generateKeyPair();
    //generate keyPair for A

    KeyAgreement bKeyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
    //define algorithm for B's key agreement
    KeyPair bPair = keyGen.generateKeyPair();
    //generate keyPair for B

    aKeyAgree.init(aPair.getPrivate());
    //initialize A's keyAgreement with A's private key
    bKeyAgree.init(bPair.getPrivate());
    //initialize B's keyAgreement with B's private key

    aKeyAgree.doPhase(bPair.getPublic(), true);
    //do last phase of A's keyAgreement with B's public key
    bKeyAgree.doPhase(aPair.getPublic(), true);
    //do last phase of B's keyAgreement with A's public key

    MessageDigest hash = MessageDigest.getInstance(""SHA1"", ""BC"");

    System.out.println(new String(hash.digest(aKeyAgree.generateSecret())));
    //generate secret key for A, hash it.
    System.out.println(new String(hash.digest(bKeyAgree.generateSecret())));
    //generate secret key for B, hash it.
  }
}
</code></pre>

<p>This is the line causing the problem:</p>

<pre><code>KeyPair aPair = keyGen.generateKeyPair();
</code></pre>

<p>I'm confused as to what the error is, as I've found each of the methods it's returning 'unknown source' for.</p>

<p>Any light shed on this would be much appreciated.</p>

<p>Continued(Edit):
<a href=""https://stackoverflow.com/questions/22492417/java-diffie-hellman-encryption-wrong-output"">Java - Diffie-Hellman Encryption - Wrong Output</a></p>
","<p>Instead of the code:</p>

<pre><code>private static BigInteger g512 = new BigInteger(""1234567890"", 16);
   //generates a random, non-negative integer for Base

   private static BigInteger p512 = new BigInteger(""1234567890"", 16);
   //generates a random, non-negative integer for Prime
</code></pre>

<p>you need to use:</p>

<pre><code>// The base used with the SKIP 1024 bit modulus
private static final BigInteger g512 = BigInteger.valueOf(2);

// The 1024 bit Diffie-Hellman modulus values used by SKIP
private static final byte skip1024ModulusBytes[] = { (byte) 0xF4,
    (byte) 0x88, (byte) 0xFD, (byte) 0x58, (byte) 0x4E, (byte) 0x49,
    (byte) 0xDB, (byte) 0xCD, (byte) 0x20, (byte) 0xB4, (byte) 0x9D,
    (byte) 0xE4, (byte) 0x91, (byte) 0x07, (byte) 0x36, (byte) 0x6B,
    (byte) 0x33, (byte) 0x6C, (byte) 0x38, (byte) 0x0D, (byte) 0x45,
    (byte) 0x1D, (byte) 0x0F, (byte) 0x7C, (byte) 0x88, (byte) 0xB3,
    (byte) 0x1C, (byte) 0x7C, (byte) 0x5B, (byte) 0x2D, (byte) 0x8E,
    (byte) 0xF6, (byte) 0xF3, (byte) 0xC9, (byte) 0x23, (byte) 0xC0,
    (byte) 0x43, (byte) 0xF0, (byte) 0xA5, (byte) 0x5B, (byte) 0x18,
    (byte) 0x8D, (byte) 0x8E, (byte) 0xBB, (byte) 0x55, (byte) 0x8C,
    (byte) 0xB8, (byte) 0x5D, (byte) 0x38, (byte) 0xD3, (byte) 0x34,
    (byte) 0xFD, (byte) 0x7C, (byte) 0x17, (byte) 0x57, (byte) 0x43,
    (byte) 0xA3, (byte) 0x1D, (byte) 0x18, (byte) 0x6C, (byte) 0xDE,
    (byte) 0x33, (byte) 0x21, (byte) 0x2C, (byte) 0xB5, (byte) 0x2A,
    (byte) 0xFF, (byte) 0x3C, (byte) 0xE1, (byte) 0xB1, (byte) 0x29,
    (byte) 0x40, (byte) 0x18, (byte) 0x11, (byte) 0x8D, (byte) 0x7C,
    (byte) 0x84, (byte) 0xA7, (byte) 0x0A, (byte) 0x72, (byte) 0xD6,
    (byte) 0x86, (byte) 0xC4, (byte) 0x03, (byte) 0x19, (byte) 0xC8,
    (byte) 0x07, (byte) 0x29, (byte) 0x7A, (byte) 0xCA, (byte) 0x95,
    (byte) 0x0C, (byte) 0xD9, (byte) 0x96, (byte) 0x9F, (byte) 0xAB,
    (byte) 0xD0, (byte) 0x0A, (byte) 0x50, (byte) 0x9B, (byte) 0x02,
    (byte) 0x46, (byte) 0xD3, (byte) 0x08, (byte) 0x3D, (byte) 0x66,
    (byte) 0xA4, (byte) 0x5D, (byte) 0x41, (byte) 0x9F, (byte) 0x9C,
    (byte) 0x7C, (byte) 0xBD, (byte) 0x89, (byte) 0x4B, (byte) 0x22,
    (byte) 0x19, (byte) 0x26, (byte) 0xBA, (byte) 0xAB, (byte) 0xA2,
    (byte) 0x5E, (byte) 0xC3, (byte) 0x55, (byte) 0xE9, (byte) 0x2F,
    (byte) 0x78, (byte) 0xC7 };

// The SKIP 1024 bit modulus
private static final BigInteger p512 = new BigInteger(1, skip1024ModulusBytes);
</code></pre>
","13466","<java><bouncycastle><diffie-hellman>","5","0","3","2019-02-25 14:53:00","","0","3","-1","","2017-05-23 11:54:07","2014-03-18 12:32:33",""
"22479508","Java Diffie-Hellman key exchange","<p>I'm trying to execute code to perform the Diffie-Hellman key exchange. I sourced the code from an example online (forget where now).
I had to import the bouncycastle.jar, which I assumed worked up until execution.</p>

<p><img src=""https://i.stack.imgur.com/ypoi7.png"" alt=""stacktrace screenshot""></p>

<p>my code:</p>

<pre><code>package testproject;

import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.Security;
import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;

public class KeyGen {

  private static BigInteger g512 = new BigInteger(""1234567890"", 16);
  //generates a random, non-negative integer for Base

  private static BigInteger p512 = new BigInteger(""1234567890"", 16);
  //generates a random, non-negative integer for Prime

  public static void main(String[] args) throws Exception {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    DHParameterSpec dhParams = new DHParameterSpec(p512, g512);
    //Specify parameters to use for the algorithm
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"", ""BC"");
    //Define specific algorithm to use ""diffie-hellman"", with provider ""bc""

    keyGen.initialize(dhParams, new SecureRandom());
    //initialize with parameters &amp; secure random seed

    KeyAgreement aKeyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
    //define algorithm for A's key agreement
    KeyPair aPair = keyGen.generateKeyPair();
    //generate keyPair for A

    KeyAgreement bKeyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
    //define algorithm for B's key agreement
    KeyPair bPair = keyGen.generateKeyPair();
    //generate keyPair for B

    aKeyAgree.init(aPair.getPrivate());
    //initialize A's keyAgreement with A's private key
    bKeyAgree.init(bPair.getPrivate());
    //initialize B's keyAgreement with B's private key

    aKeyAgree.doPhase(bPair.getPublic(), true);
    //do last phase of A's keyAgreement with B's public key
    bKeyAgree.doPhase(aPair.getPublic(), true);
    //do last phase of B's keyAgreement with A's public key

    MessageDigest hash = MessageDigest.getInstance(""SHA1"", ""BC"");

    System.out.println(new String(hash.digest(aKeyAgree.generateSecret())));
    //generate secret key for A, hash it.
    System.out.println(new String(hash.digest(bKeyAgree.generateSecret())));
    //generate secret key for B, hash it.
  }
}
</code></pre>

<p>This is the line causing the problem:</p>

<pre><code>KeyPair aPair = keyGen.generateKeyPair();
</code></pre>

<p>I'm confused as to what the error is, as I've found each of the methods it's returning 'unknown source' for.</p>

<p>Any light shed on this would be much appreciated.</p>

<p>Continued(Edit):
<a href=""https://stackoverflow.com/questions/22492417/java-diffie-hellman-encryption-wrong-output"">Java - Diffie-Hellman Encryption - Wrong Output</a></p>
","<p>You already preferred bouncycastle version. But I implemented a little helloworld version of it for learning purposes. Maybe it can be helpful for those who simply wants to use Diffie-Hellman in pure Java without dependencies:</p>

<pre><code>// 1. ------------------------------------------------------------------
// This is Alice and Bob
// Alice and Bob want to chat securely. But how?

final Person alice = new Person();
final Person bob   = new Person();

//    ?                                        ?
//
//    O                                        O
//   /|\                                      /|\
//   / \                                      / \
//
//  ALICE                                     BOB

// 2. ------------------------------------------------------------------
// Alice and Bob generate public and private keys.

alice.generateKeys();
bob.generateKeys();

//
//    O                                        O
//   /|\                                      /|\
//   / \                                      / \
//
//  ALICE                                     BOB
//  _ PUBLIC KEY                              _ PUBLIC KEY
//  _ PRIVATE KEY                             _ PRIVATE KEY

// 3. ------------------------------------------------------------------
// Alice and Bob exchange public keys with each other.

alice.receivePublicKeyFrom(bob);
bob.receivePublicKeyFrom(alice);

//
//    O                                        O
//   /|\                                      /|\
//   / \                                      / \
//
//  ALICE                                     BOB
//  + public key                              + public key
//  + private key                             + private key
//  _ PUBLIC KEY &lt;-------------------------&gt;  _ PUBLIC KEY

// 4. ------------------------------------------------------------------
// Alice generates common secret key via using her private key and Bob's public key.
// Bob generates common secret key via using his private key and Alice's public key.
// Both secret keys are equal without TRANSFERRING. This is the magic of Diffie-Helman algorithm.

alice.generateCommonSecretKey();
bob.generateCommonSecretKey();

//
//    O                                        O
//   /|\                                      /|\
//   / \                                      / \
//
//  ALICE                                     BOB
//  + public key                              + public key
//  + private key                             + private key
//  + public key                              + public key
//  _ SECRET KEY                              _ SECRET KEY

// 5. ------------------------------------------------------------------
// Alice encrypts message using the secret key and sends to Bob

alice.encryptAndSendMessage(""Bob! Guess Who I am."", bob);

//
//    O                                        O
//   /|\ []--------------------------------&gt;  /|\
//   / \                                      / \
//
//  ALICE                                     BOB
//  + public key                              + public key
//  + private key                             + private key
//  + public key                              + public key
//  + secret key                              + secret key
//  + message                                 _ MESSAGE

// 6. ------------------------------------------------------------------
// Bob receives the important message and decrypts with secret key.

bob.whisperTheSecretMessage();

//
//    O                     (((   (((   (((   \O/   )))
//   /|\                                       |
//   / \                                      / \
//
//  ALICE                                     BOB
//  + public key                              + public key
//  + private key                             + private key
//  + public key                              + public key
//  + secret key                              + secret key
//  + message                                 + message
</code></pre>

<p><a href=""https://github.com/firatkucuk/diffie-hellman-helloworld"" rel=""nofollow noreferrer"">https://github.com/firatkucuk/diffie-hellman-helloworld</a></p>
","13466","<java><bouncycastle><diffie-hellman>","5","6","3","2019-02-25 14:53:00","","0","3","-1","","2017-05-23 11:54:07","2014-03-18 12:32:33",""
"24502672","How to expand DH key size to 2048 in java 8","<p>I read a lot of posts saying that in java 8 it is possible to expand the DH key size to 2048. They say it is possible from the system property by changing the value of:
<code>jdk.tls.ephemeralDHKeySize</code> to 2048. I tried to figure out where and how to do this and could not find. Where can I find this variable or property? which file? path? I am using windows.</p>
","<p>This is a system property, so you could set it via <code>-Djdk.tls.ephemeralDHKeySize=2048</code> as a JVM argument or via <code>System.setProperty</code> within the code. (I haven't checked for this property, but some properties are read only once by the library that uses them, and then cached permanently during the execution time of the JVM, so you'd generally want to set that setting early enough if you set it within the code.)</p>

<p>The acceptable values are documented in the <a href=""http://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#customizing_dh_keys"" rel=""noreferrer"">JSSE reference guide: ""<em>Customizing Size of Ephemeral Diffie-Hellman Keys</em>""</a>.</p>
","12921","<java><security><ssl><diffie-hellman>","6","10","1","2014-07-01 11:12:30","24508841","0","4","","","","2014-07-01 04:51:55",""
"9833527","Client-side encryption over HTTP with Diffie-Hellman Key Exchange and AES","<p>After watching a YouTube video on the <a href=""http://www.youtube.com/watch?v=3QnD2c4Xovk"">Diffie-Hellman Key Exchange</a>, I wanted to try an implementation in JavaScript (Atwood's law).</p>

<p>I sketched up an cipher on Node.js with the following rules:</p>

<ul>
<li><p>Step 1: Client and server agree on a shared key:</p>

<ul>
<li><p>Client &amp; server start with a 512bit prime public key pK</p></li>
<li><p>Client generates a 512bit prime private key kC and sends powMod(3, kC, pK)</p></li>
<li><p>Server generates a 512bit prime private key kS and sends powMod(3, kS, pK)</p></li>
<li><p>Client &amp; Server use powMod(response, privatekey, pK) as the shared key</p></li>
</ul></li>
<li><p>Step 2: Communication</p>

<ul>
<li><p>Before a client sends data it is encrypted with the shared key using the Stanford Javascript Crypto Library (256bit AES, HMAC authentication, PBKDF2 password strengthening, and CCM authenticated-encryption.)</p></li>
<li><p>Once the server decrypts the data with the shared key, it generates a new 512bit prime private key and sends it as a SJCL encrypted response.</p></li>
<li><p>The client and server switch to a new shared key using powMod(3, prevSharedKey, newPrivKey)</p></li>
</ul></li>
</ul>

<p>Now I have a few questions..</p>

<p>How secure would such a system be in comparison with HTTPS or other algorithms?  What are the weakest points of such a system?</p>

<p>In terms of security / practicality, would it be better to use 1024 bit keys for stronger security?  Are the HMAC/PBKDF2/CCM options overkill?  Is it worth modulating the shared key?  Thanks for reading!</p>
","<p>I've seen questions like this <a href=""https://stackoverflow.com/a/8235235/201952"">before</a> &ndash; this is <strong>completely insecure</strong> <a href=""http://www.matasano.com/articles/javascript-cryptography/"" rel=""nofollow noreferrer"">for a number of reasons</a>, foremost of which is the fact that it is impossible for a JavaScript client to verify that the server's key is authentic.</p>

<p>In a nutshell, without SSL, you are vulnerable to man-in-the-middle attacks.  No browser-based JavaScript crypto implementation can overcome this fact.</p>
","12758","<javascript><node.js><encryption><aes><diffie-hellman>","10","8","3","2014-03-28 13:22:08","9833722","0","5","479947","","2012-03-23 06:14:03","2012-03-23 02:50:05",""
"9833527","Client-side encryption over HTTP with Diffie-Hellman Key Exchange and AES","<p>After watching a YouTube video on the <a href=""http://www.youtube.com/watch?v=3QnD2c4Xovk"">Diffie-Hellman Key Exchange</a>, I wanted to try an implementation in JavaScript (Atwood's law).</p>

<p>I sketched up an cipher on Node.js with the following rules:</p>

<ul>
<li><p>Step 1: Client and server agree on a shared key:</p>

<ul>
<li><p>Client &amp; server start with a 512bit prime public key pK</p></li>
<li><p>Client generates a 512bit prime private key kC and sends powMod(3, kC, pK)</p></li>
<li><p>Server generates a 512bit prime private key kS and sends powMod(3, kS, pK)</p></li>
<li><p>Client &amp; Server use powMod(response, privatekey, pK) as the shared key</p></li>
</ul></li>
<li><p>Step 2: Communication</p>

<ul>
<li><p>Before a client sends data it is encrypted with the shared key using the Stanford Javascript Crypto Library (256bit AES, HMAC authentication, PBKDF2 password strengthening, and CCM authenticated-encryption.)</p></li>
<li><p>Once the server decrypts the data with the shared key, it generates a new 512bit prime private key and sends it as a SJCL encrypted response.</p></li>
<li><p>The client and server switch to a new shared key using powMod(3, prevSharedKey, newPrivKey)</p></li>
</ul></li>
</ul>

<p>Now I have a few questions..</p>

<p>How secure would such a system be in comparison with HTTPS or other algorithms?  What are the weakest points of such a system?</p>

<p>In terms of security / practicality, would it be better to use 1024 bit keys for stronger security?  Are the HMAC/PBKDF2/CCM options overkill?  Is it worth modulating the shared key?  Thanks for reading!</p>
","<p>Your system is massively insecure, but I'm not trying to dissuade you or anyone from playing around with stuff like this. You should continue to. But it is vital that you consider anything you create to be a ""toy"" system that should never be considered or advertised as ""secure"".</p>

<p>Let's break down the security question into two parts.</p>

<ol>
<li>How secure is the key exchange?</li>
<li>How secure is the encryption you use once you've got a shared key?</li>
</ol>

<p>Let me answer (2) first as that will be the simplest. It will be terribly insecure unless you are smarter than all of the people who've worked on and studied TLS over the years. TLS before version 1.2 (which few sites use) is vulnerable to Chosen Ciphertext Attacks (CCAs) in principle and to the <a href=""http://luxsci.com/blog/is-ssltls-really-broken-by-the-beast-attack-what-is-the-real-story-what-should-i-do.html"" rel=""nofollow noreferrer"">BEAST attack</a> in practice depending on cipher suit choice.  And SSL 2.0 is more badly broken.</p>

<p>The point is that very very smart people, working on these protocols over years, got some things wrong. There is every reason to believe that you are I working on these sorts of things on our own will make huge mistakes. The basic encryption algorithms are fine. They aren't broken. But the protocols are.</p>

<p>So if you haven't studied and fully understood all of the details of SSL, why they are there and how they have gone wrong in some cases, then it is almost certain that any protocol you devise will be terrible.</p>

<p>Now to question (2). There are two issues with this. (a) Diffie-Hellman is not designed to provide the sorts of security you probably need; and (b) I don't think that you've implemented DH correctly. </p>

<p>2.a:</p>

<p>Diffie-Hellman Key exchange, when done right, is secure for key exchange, but it does nothing for authentication. This is why the question ""is it secure"" is often the wrong question. It is secure for some purposes, but massively insecure for others as it isn't designed for those other purposes.</p>

<p>As <a href=""https://stackoverflow.com/users/201952/josh3736"">Josh3737</a> pointed out, there is no way for the client and the server to know that they are talking to the right party. If Sam is the server and Charlie is the Client, there is nothing that stops Mallory from setting up her own server that masquerades as Sam. So Cathy can go through the key exchange with Mallory, thinking that she is talking to Sam. Mallory can pretend to be Charlie when talking to Sam.</p>

<p>Once set up this way, Mallory can act as a Man In The Middle between Sam and Charlie. When Charlie sends data intended to Sam, Mallory will decrypt it using the shared key between C and M, read it (and possibly change it), and then re-encrypt it the the shared key between M and S and send that off to S.</p>

<p>To solve the authentication problem, you need some sort of Public Key Infrastructure (PKI) and these are really a pain. The system of Certificate Authorities and such that we have with SSL/TLS is fraught with problems, but it remains the best system out there.</p>

<p>2.b:</p>

<p>A 512 bit public modulus along with 512 bit private keys are not strong enough. DH keys need to be bigger. I wouldn't go with anything less than 2048 bits. You might get away with 1024 bits you aren't worried about someone being able to break today's secrets five years from now.</p>

<p>You didn't give enough information on how your primes were selected. Not every prime will work. You need to use a ""safe prime"" for your modulus, otherwise there are shortcuts available for an attacker to compute the discrete logarithm. </p>
","12758","<javascript><node.js><encryption><aes><diffie-hellman>","10","16","3","2014-03-28 13:22:08","9833722","0","5","479947","","2012-03-23 06:14:03","2012-03-23 02:50:05",""
"9833527","Client-side encryption over HTTP with Diffie-Hellman Key Exchange and AES","<p>After watching a YouTube video on the <a href=""http://www.youtube.com/watch?v=3QnD2c4Xovk"">Diffie-Hellman Key Exchange</a>, I wanted to try an implementation in JavaScript (Atwood's law).</p>

<p>I sketched up an cipher on Node.js with the following rules:</p>

<ul>
<li><p>Step 1: Client and server agree on a shared key:</p>

<ul>
<li><p>Client &amp; server start with a 512bit prime public key pK</p></li>
<li><p>Client generates a 512bit prime private key kC and sends powMod(3, kC, pK)</p></li>
<li><p>Server generates a 512bit prime private key kS and sends powMod(3, kS, pK)</p></li>
<li><p>Client &amp; Server use powMod(response, privatekey, pK) as the shared key</p></li>
</ul></li>
<li><p>Step 2: Communication</p>

<ul>
<li><p>Before a client sends data it is encrypted with the shared key using the Stanford Javascript Crypto Library (256bit AES, HMAC authentication, PBKDF2 password strengthening, and CCM authenticated-encryption.)</p></li>
<li><p>Once the server decrypts the data with the shared key, it generates a new 512bit prime private key and sends it as a SJCL encrypted response.</p></li>
<li><p>The client and server switch to a new shared key using powMod(3, prevSharedKey, newPrivKey)</p></li>
</ul></li>
</ul>

<p>Now I have a few questions..</p>

<p>How secure would such a system be in comparison with HTTPS or other algorithms?  What are the weakest points of such a system?</p>

<p>In terms of security / practicality, would it be better to use 1024 bit keys for stronger security?  Are the HMAC/PBKDF2/CCM options overkill?  Is it worth modulating the shared key?  Thanks for reading!</p>
","<p>If you want to get around the SSL cert and man in the middle problem, you can use the bitcoin blockchain. (Or an altcoin blockchain.)</p>

<p>The Huge Caveat: the client has to either download or maintain an entire file of the blockchain.</p>

<p>There are two public/private key pairs:</p>

<p>CERTpublic     CERTprivate</p>

<p>CLIENTpublic   CLIENTprivate</p>

<p>NAME REGISTRATION:</p>

<pre><code>Server -&gt; CERTpublic and name_to_register -&gt; Bitcoin Blockchain
</code></pre>

<p>AUTHENTICATED CONNECTION:</p>

<pre><code>Client &lt;- CERTpublic &lt;- Bitcoin Blockchain
Client -&gt; CERTpublic(CLIENTpublic) -&gt; Server or Adversary
Client &lt;- No_response_or_incorrect &lt;- Adversary 
Client &lt;- CLIENTpublic(CERTprivate(content)) &lt;- Server
</code></pre>
","12758","<javascript><node.js><encryption><aes><diffie-hellman>","10","0","3","2014-03-28 13:22:08","9833722","0","5","479947","","2012-03-23 06:14:03","2012-03-23 02:50:05",""
"1633046","Diffie-Hellman in place of SSL?","<p>Can a Diffie-Hellman key exchange algorithm be used to encrypt client-server communication on a web-page in place of SSL?  If it can, what are the disadvantages (i.e. why does the standard use SSL which requires a certificate authority)?  My understanding is that Diffie-Hellman can be used to secretly establish a shared key which then can be use to encrypt any further communication.</p>
","<p>Actually Diffie-Hellman is a part of SSL.
But one part does not replace others.</p>

<p>From <a href=""http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_1-1/ssl.html"" rel=""noreferrer"">here</a> SSL Diffie-Helman is used for:</p>

<blockquote>
  <p>This a Diffie-Hellman key exchange in
  which the server's certificate
  contains the Diffie-Hellman public
  parameters signed by the certificate
  authority (CA). That is, the
  public-key certificate contains the
  Diffie-Hellman public-key parameters.
  The client provides its Diffie-Hellman
  public key parameters either in a
  certificate, if client authentication
  is required, or in a key exchange
  message. This method results in a
  fixed secret key between two peers,
  based on the Diffie-Hellman
  calculation using the fixed public
  keys.</p>
</blockquote>
","10936","<encryption><ssl><diffie-hellman>","15","9","5","2019-03-28 15:40:55","","0","2","15168","","2009-10-27 19:26:39","2009-10-27 19:13:57",""
"1633046","Diffie-Hellman in place of SSL?","<p>Can a Diffie-Hellman key exchange algorithm be used to encrypt client-server communication on a web-page in place of SSL?  If it can, what are the disadvantages (i.e. why does the standard use SSL which requires a certificate authority)?  My understanding is that Diffie-Hellman can be used to secretly establish a shared key which then can be use to encrypt any further communication.</p>
","<p>The two aren't really comparable. DH is a key-exchange algorithm, nothing more and nothing less. SSL attempts to establish that the server you're connecting to is really who it says it is. To do that, it uses a certificate that can be traced back to somebody you (are supposed to be able to) trust.</p>

<p>DH, by itself, only keeps others from reading the transmitted data. SSL is intended to establish considerably more than that (but can use DH to keep others from reading the stream).</p>

<p>Just for an obvious example, using DH (by itself) a Man in the middle attack is fairly simple. If I can get you to connect to my server instead of the one you intended to, I can use DH to establish a ""secure"" session with you. I then connect to the server you originally intended to. Every packet I get from you, I decrypt, re-encrypt with a key I used to connect to that server, and send on to that server. I do the same with all its response packets. To you, everything looks like it came directly from the original server, and the purchase you made (for example) works just like normal. The only thing that changes is that I also store your credit card number, and when you try to fill your car with fuel the next day, the charge is declined, because in the meantime I've spent all your credit.</p>

<p>The authentication in SSL is at least intended to prevent that from happening. If your browser tried to connect to (for example) www.amazon.com, it should give you a warning if my SSL certificate doesn't specify that it was issued to www.amazon.com -- and a CA shouldn't issue such a certificate to <em>anybody</em> but Amazon.</p>

<p>DH, by itself, doesn't really even guarantee most of what I've said above. By itself, DH is just a way to exchange a key (or, perhaps it could be phrased as ""exchange information necessary for both parties to create identical keys, without ever exchanging the key itself in the clear""). After both parties have the key, they can (and presumably will) use it to encrypt/decrypt data -- but that encryption is actually separate from DH itself.</p>
","10936","<encryption><ssl><diffie-hellman>","15","23","5","2019-03-28 15:40:55","","0","2","15168","","2009-10-27 19:26:39","2009-10-27 19:13:57",""
"1633046","Diffie-Hellman in place of SSL?","<p>Can a Diffie-Hellman key exchange algorithm be used to encrypt client-server communication on a web-page in place of SSL?  If it can, what are the disadvantages (i.e. why does the standard use SSL which requires a certificate authority)?  My understanding is that Diffie-Hellman can be used to secretly establish a shared key which then can be use to encrypt any further communication.</p>
","<p>You can use anonymous Diffie-Hellman key agreement with SSL. This provides privacy on the channel, but no authentication.</p>

<p>Of course, without authentication, you really can't have privacy, because your private channel could be connected to a ""man-in-the-middle"". That's why the anonymous DH cipher suites are discouraged.</p>

<p>If the lack of a certificate is stopping you from using SSL where it's really needed, get a free one from <a href=""http://cert.startcom.org/"" rel=""nofollow noreferrer"">startcom.org.</a></p>
","10936","<encryption><ssl><diffie-hellman>","15","4","5","2019-03-28 15:40:55","","0","2","15168","","2009-10-27 19:26:39","2009-10-27 19:13:57",""
"1633046","Diffie-Hellman in place of SSL?","<p>Can a Diffie-Hellman key exchange algorithm be used to encrypt client-server communication on a web-page in place of SSL?  If it can, what are the disadvantages (i.e. why does the standard use SSL which requires a certificate authority)?  My understanding is that Diffie-Hellman can be used to secretly establish a shared key which then can be use to encrypt any further communication.</p>
","<p>Diffie-Hellman key exchange is <em>only</em> for keyexchange. It does not give you authenticitation (who you're talking to), you need certificates and a PKI for that.</p>

<p>So yes you can do encryption, but you dont know with who you're talking to</p>
","10936","<encryption><ssl><diffie-hellman>","15","2","5","2019-03-28 15:40:55","","0","2","15168","","2009-10-27 19:26:39","2009-10-27 19:13:57",""
"1633046","Diffie-Hellman in place of SSL?","<p>Can a Diffie-Hellman key exchange algorithm be used to encrypt client-server communication on a web-page in place of SSL?  If it can, what are the disadvantages (i.e. why does the standard use SSL which requires a certificate authority)?  My understanding is that Diffie-Hellman can be used to secretly establish a shared key which then can be use to encrypt any further communication.</p>
","<p>The DH key exchange cannot, of itself, do encryption.  It is used to establish a session key, but not to do the encryption.   So, at this level, the question is mis-stated or reveals either lack of precision or lack of understanding (I suspect precision is the problem this time).</p>

<p>The question is:</p>

<ul>
<li>Do you want to encrypt data with anybody at all?</li>
<li>Do you want to be sure who you are talking to?</li>
</ul>

<p>As already pointed out, SSL uses a DH key exchange to establish a session key.  However, it also ensures that the program on the other end is someone you trust (directly or indirectly).  If you don't need to worry about whether the other person is trustworthy, you could just use a simple DH key exchange and then send encrypted data without needing certificates.  But you won't be sure who you are talking to unless you validate that - and the certificates used by SSL etc helps with that validation.</p>
","10936","<encryption><ssl><diffie-hellman>","15","1","5","2019-03-28 15:40:55","","0","2","15168","","2009-10-27 19:26:39","2009-10-27 19:13:57",""
"9953187","How to exploit Diffie-hellman to perform a man in the middle attack","<p>Im doing a project where Alice and Bob send each other messages using the Diffie-Hellman key-exchange. What is throwing me for a loop is how to incorporate the certificate they are using in this so i can obtain their secret messages. </p>

<p>From what I understand about MIM attakcs, the MIM acts as an imposter as seen on this diagram:</p>

<p><img src=""https://i.stack.imgur.com/uYqQe.png"" alt=""enter image description here""></p>

<p>Below are the details for my project. I understand that they both have g and p agreed upon before communicating, but how would I be able to implement this with they both having a certificate to verify their signatures?</p>

<p>Alice prepares ⟨signA(NA, Bob), pkA, certA⟩ where signA is the digital signature algorithm used by Alice, “Bob” is Bob’s name, pkA is the public-key of Alice which equals gx mod p encoded according to X.509 for a fixed g, p as specified in the Diffie-Hellman key- exchange and certA is the certificate of Alice that contains Alice’s public-key that verifies the signature; Finally, NA is a nonce (random string) that is 8 bytes long.</p>

<p>Bob checks Alice's signature, and response with ⟨signB{NA,NB,Alice},pkB,certB⟩. Alice gets the message she checks her nonce NA and calculates the joint key based on pkA, pkB according to the Diffie-Hellman key exchange. Then Alice submits the message ⟨signA{NA,NB,Bob},EK(MA),certA⟩ to Bob and Bobrespondswith⟨SignB{NA,NB,Alice},EK(MB),certB⟩.</p>

<p>where MA and MB are their corresponding secret messages.</p>
","<p>The internet can help!</p>

<blockquote>
  <p>The Diffie-Hellman key exchange is vulnerable to a man-in-the-middle
  attack. In this attack, an opponent Carol intercepts Alice's public
  value and sends her own public value to Bob. When Bob transmits his
  public value, Carol substitutes it with her own and sends it to Alice.
  Carol and Alice thus agree on one shared key and Carol and Bob agree
  on another shared key. After this exchange, Carol simply decrypts any
  messages sent out by Alice or Bob, and then reads and possibly
  modifies them before re-encrypting with the appropriate key and
  transmitting them to the other party. This vulnerability is present
  because Diffie-Hellman key exchange does not authenticate the
  participants. Possible solutions include the use of digital signatures
  and other protocol variants.</p>
</blockquote>

<p>So you have your own value for A, and you just swap the message contents and recompute signatures and forward along.</p>
","9710","<diffie-hellman><man-in-the-middle>","4","4","2","2014-06-02 16:29:53","9953242","0","1","","","","2012-03-31 05:07:51",""
"9953187","How to exploit Diffie-hellman to perform a man in the middle attack","<p>Im doing a project where Alice and Bob send each other messages using the Diffie-Hellman key-exchange. What is throwing me for a loop is how to incorporate the certificate they are using in this so i can obtain their secret messages. </p>

<p>From what I understand about MIM attakcs, the MIM acts as an imposter as seen on this diagram:</p>

<p><img src=""https://i.stack.imgur.com/uYqQe.png"" alt=""enter image description here""></p>

<p>Below are the details for my project. I understand that they both have g and p agreed upon before communicating, but how would I be able to implement this with they both having a certificate to verify their signatures?</p>

<p>Alice prepares ⟨signA(NA, Bob), pkA, certA⟩ where signA is the digital signature algorithm used by Alice, “Bob” is Bob’s name, pkA is the public-key of Alice which equals gx mod p encoded according to X.509 for a fixed g, p as specified in the Diffie-Hellman key- exchange and certA is the certificate of Alice that contains Alice’s public-key that verifies the signature; Finally, NA is a nonce (random string) that is 8 bytes long.</p>

<p>Bob checks Alice's signature, and response with ⟨signB{NA,NB,Alice},pkB,certB⟩. Alice gets the message she checks her nonce NA and calculates the joint key based on pkA, pkB according to the Diffie-Hellman key exchange. Then Alice submits the message ⟨signA{NA,NB,Bob},EK(MA),certA⟩ to Bob and Bobrespondswith⟨SignB{NA,NB,Alice},EK(MB),certB⟩.</p>

<p>where MA and MB are their corresponding secret messages.</p>
","<p>Offering <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Security"" rel=""noreferrer"">the Wikipedia answer</a>:</p>

<blockquote>
  <p>In the original description, the Diffie–Hellman exchange by itself
  does not provide authentication of the communicating parties and is
  thus vulnerable to a man-in-the-middle attack. A person in the middle
  may establish two distinct Diffie–Hellman key exchanges, one with
  Alice and the other with Bob, effectively masquerading as Alice to
  Bob, and vice versa, allowing the attacker to decrypt (and read or
  store) then re-encrypt the messages passed between them. </p>
  
  <p>A method to
  authenticate the communicating parties to each other is generally
  needed to prevent this type of attack. Variants of Diffie-Hellman,
  such as <a href=""http://en.wikipedia.org/wiki/Station-to-Station_protocol"" rel=""noreferrer"">STS</a>, may be used instead to avoid these types of attacks.</p>
</blockquote>

<p>You may consider impressing your professor by discussing <a href=""http://en.wikipedia.org/wiki/Station-to-Station_protocol"" rel=""noreferrer"">the variants of Diffie-Hellman that are more secure</a>. For now, given you've noted the original implementation, this will do.</p>

<p>Best of luck!</p>
","9710","<diffie-hellman><man-in-the-middle>","4","6","2","2014-06-02 16:29:53","9953242","0","1","","","","2012-03-31 05:07:51",""
"35228063","Encrypt message for Web Push API in Java","<p>I'm trying to create a server capable of sending push messages using the Push API: <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Push_API"" rel=""noreferrer"">https://developer.mozilla.org/en-US/docs/Web/API/Push_API</a></p>

<p>I've got the client side working but now I want to be able to send messages with a payload from a Java server.</p>

<p>I saw the nodejs web-push example (<a href=""https://www.npmjs.com/package/web-push"" rel=""noreferrer"">https://www.npmjs.com/package/web-push</a>) but I couldn't translate that correctly to Java.</p>

<p>I tried following the example to use the DH key exchange found here: <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex"" rel=""noreferrer"">http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex</a></p>

<p>With the help of sheltond below I was able to figure out some code that should be working but isn't. </p>

<p>When I post the encrypted message to the Push service, I get back the expected 201 status code but the push never reaches Firefox. If I remove the payload and headers and simply send a POST request to the same URL the message successfully arrives in Firefox with no data. I suspect it may have something to do with the way I'm encrypting the data with Cipher.getInstance(""AES/GCM/NoPadding"");</p>

<p>This is the code I'm using currently:</p>

<pre><code>try {
    final byte[] alicePubKeyEnc = Util.fromBase64(""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"");
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""EC"");
    ECGenParameterSpec kpgparams = new ECGenParameterSpec(""secp256r1"");
    kpg.initialize(kpgparams);

    ECParameterSpec params = ((ECPublicKey) kpg.generateKeyPair().getPublic()).getParams();
    final ECPublicKey alicePubKey = fromUncompressedPoint(alicePubKeyEnc, params);
    KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(""EC"");
    bobKpairGen.initialize(params);

    KeyPair bobKpair = bobKpairGen.generateKeyPair();
    KeyAgreement bobKeyAgree = KeyAgreement.getInstance(""ECDH"");
    bobKeyAgree.init(bobKpair.getPrivate());


    byte[] bobPubKeyEnc = toUncompressedPoint((ECPublicKey) bobKpair.getPublic());


    bobKeyAgree.doPhase(alicePubKey, true);
    Cipher bobCipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    SecretKey bobDesKey = bobKeyAgree.generateSecret(""AES"");
    byte[] saltBytes = new byte[16];
    new SecureRandom().nextBytes(saltBytes);
    Mac extract = Mac.getInstance(""HmacSHA256"");
    extract.init(new SecretKeySpec(saltBytes, ""HmacSHA256""));
    final byte[] prk = extract.doFinal(bobDesKey.getEncoded());

    // Expand
    Mac expand = Mac.getInstance(""HmacSHA256"");
    expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
    String info = ""Content-Encoding: aesgcm128"";
    expand.update(info.getBytes(StandardCharsets.US_ASCII));
    expand.update((byte) 1);
    final byte[] key_bytes = expand.doFinal();

    // Use the result
    SecretKeySpec key = new SecretKeySpec(key_bytes, 0, 16, ""AES"");
    bobCipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cleartext = ""{\""this\"":\""is a test that is supposed to be working but it is not\""}"".getBytes();
    byte[] ciphertext = bobCipher.doFinal(cleartext);

    URL url = new URL(""PUSH_ENDPOINT_URL"");
    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
    urlConnection.setRequestMethod(""POST"");
    urlConnection.setRequestProperty(""Content-Length"", ciphertext.length + """");
    urlConnection.setRequestProperty(""Content-Type"", ""application/octet-stream"");
    urlConnection.setRequestProperty(""Encryption-Key"", ""keyid=p256dh;dh="" + Util.toBase64UrlSafe(bobPubKeyEnc));
    urlConnection.setRequestProperty(""Encryption"", ""keyid=p256dh;salt="" + Util.toBase64UrlSafe(saltBytes));
    urlConnection.setRequestProperty(""Content-Encoding"", ""aesgcm128"");
    urlConnection.setDoInput(true);
    urlConnection.setDoOutput(true);
    final OutputStream outputStream = urlConnection.getOutputStream();
    outputStream.write(ciphertext);
    outputStream.flush();
    outputStream.close();
    if (urlConnection.getResponseCode() == 201) {
        String result = Util.readStream(urlConnection.getInputStream());
        Log.v(""PUSH"", ""OK: "" + result);
    } else {
        InputStream errorStream = urlConnection.getErrorStream();
        String error = Util.readStream(errorStream);
        Log.v(""PUSH"", ""Not OK: "" + error);
    }
} catch (Exception e) {
    Log.v(""PUSH"", ""Not OK: "" + e.toString());
}
</code></pre>

<p>where ""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"" is the key the Push API subscription method in the browser provided and ""PUSH_ENDPOINT_URL"" is the push endpoint the browser provided.</p>

<p>If I get values (ciphertext, base64 bobPubKeyEnc and salt) from a successful nodejs web-push request and hard-code them in Java, it works. If I use the code above with dynamic values it does not work.</p>

<p>I did notice that the ciphertext that worked in the nodejs implementation is always 1 byte bigger then the Java ciphertext with the code above. The example I used here always produces a 81 byte cipher text but in nodejs it's always 82 bytes for example. Does this give us a clue on what might be wrong?</p>

<p>How do I correctly encrypt the payload so that it reaches Firefox?</p>

<p>Thanks in advance for any help</p>
","<p>See <a href=""https://tools.ietf.org/html/draft-ietf-webpush-encryption-01#section-5"" rel=""nofollow"">https://tools.ietf.org/html/draft-ietf-webpush-encryption-01#section-5</a> and <a href=""https://w3c.github.io/push-api/#widl-PushSubscription-getKey-ArrayBuffer-PushEncryptionKeyName-name"" rel=""nofollow"">https://w3c.github.io/push-api/#widl-PushSubscription-getKey-ArrayBuffer-PushEncryptionKeyName-name</a> (point 4).</p>

<p>The key is encoded using the uncompressed format defined in ANSI X9.62, so you can't use x509EncodedKeySpec.</p>

<p>You could use BouncyCastle, that should support the X9.62 encoding.</p>
","7278","<java><encryption><diffie-hellman><push-api>","17","3","4","2016-08-30 08:55:11","36129174","3","10","1002963","","2016-03-03 14:58:17","2016-02-05 15:43:15",""
"35228063","Encrypt message for Web Push API in Java","<p>I'm trying to create a server capable of sending push messages using the Push API: <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Push_API"" rel=""noreferrer"">https://developer.mozilla.org/en-US/docs/Web/API/Push_API</a></p>

<p>I've got the client side working but now I want to be able to send messages with a payload from a Java server.</p>

<p>I saw the nodejs web-push example (<a href=""https://www.npmjs.com/package/web-push"" rel=""noreferrer"">https://www.npmjs.com/package/web-push</a>) but I couldn't translate that correctly to Java.</p>

<p>I tried following the example to use the DH key exchange found here: <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex"" rel=""noreferrer"">http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex</a></p>

<p>With the help of sheltond below I was able to figure out some code that should be working but isn't. </p>

<p>When I post the encrypted message to the Push service, I get back the expected 201 status code but the push never reaches Firefox. If I remove the payload and headers and simply send a POST request to the same URL the message successfully arrives in Firefox with no data. I suspect it may have something to do with the way I'm encrypting the data with Cipher.getInstance(""AES/GCM/NoPadding"");</p>

<p>This is the code I'm using currently:</p>

<pre><code>try {
    final byte[] alicePubKeyEnc = Util.fromBase64(""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"");
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""EC"");
    ECGenParameterSpec kpgparams = new ECGenParameterSpec(""secp256r1"");
    kpg.initialize(kpgparams);

    ECParameterSpec params = ((ECPublicKey) kpg.generateKeyPair().getPublic()).getParams();
    final ECPublicKey alicePubKey = fromUncompressedPoint(alicePubKeyEnc, params);
    KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(""EC"");
    bobKpairGen.initialize(params);

    KeyPair bobKpair = bobKpairGen.generateKeyPair();
    KeyAgreement bobKeyAgree = KeyAgreement.getInstance(""ECDH"");
    bobKeyAgree.init(bobKpair.getPrivate());


    byte[] bobPubKeyEnc = toUncompressedPoint((ECPublicKey) bobKpair.getPublic());


    bobKeyAgree.doPhase(alicePubKey, true);
    Cipher bobCipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    SecretKey bobDesKey = bobKeyAgree.generateSecret(""AES"");
    byte[] saltBytes = new byte[16];
    new SecureRandom().nextBytes(saltBytes);
    Mac extract = Mac.getInstance(""HmacSHA256"");
    extract.init(new SecretKeySpec(saltBytes, ""HmacSHA256""));
    final byte[] prk = extract.doFinal(bobDesKey.getEncoded());

    // Expand
    Mac expand = Mac.getInstance(""HmacSHA256"");
    expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
    String info = ""Content-Encoding: aesgcm128"";
    expand.update(info.getBytes(StandardCharsets.US_ASCII));
    expand.update((byte) 1);
    final byte[] key_bytes = expand.doFinal();

    // Use the result
    SecretKeySpec key = new SecretKeySpec(key_bytes, 0, 16, ""AES"");
    bobCipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cleartext = ""{\""this\"":\""is a test that is supposed to be working but it is not\""}"".getBytes();
    byte[] ciphertext = bobCipher.doFinal(cleartext);

    URL url = new URL(""PUSH_ENDPOINT_URL"");
    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
    urlConnection.setRequestMethod(""POST"");
    urlConnection.setRequestProperty(""Content-Length"", ciphertext.length + """");
    urlConnection.setRequestProperty(""Content-Type"", ""application/octet-stream"");
    urlConnection.setRequestProperty(""Encryption-Key"", ""keyid=p256dh;dh="" + Util.toBase64UrlSafe(bobPubKeyEnc));
    urlConnection.setRequestProperty(""Encryption"", ""keyid=p256dh;salt="" + Util.toBase64UrlSafe(saltBytes));
    urlConnection.setRequestProperty(""Content-Encoding"", ""aesgcm128"");
    urlConnection.setDoInput(true);
    urlConnection.setDoOutput(true);
    final OutputStream outputStream = urlConnection.getOutputStream();
    outputStream.write(ciphertext);
    outputStream.flush();
    outputStream.close();
    if (urlConnection.getResponseCode() == 201) {
        String result = Util.readStream(urlConnection.getInputStream());
        Log.v(""PUSH"", ""OK: "" + result);
    } else {
        InputStream errorStream = urlConnection.getErrorStream();
        String error = Util.readStream(errorStream);
        Log.v(""PUSH"", ""Not OK: "" + error);
    }
} catch (Exception e) {
    Log.v(""PUSH"", ""Not OK: "" + e.toString());
}
</code></pre>

<p>where ""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"" is the key the Push API subscription method in the browser provided and ""PUSH_ENDPOINT_URL"" is the push endpoint the browser provided.</p>

<p>If I get values (ciphertext, base64 bobPubKeyEnc and salt) from a successful nodejs web-push request and hard-code them in Java, it works. If I use the code above with dynamic values it does not work.</p>

<p>I did notice that the ciphertext that worked in the nodejs implementation is always 1 byte bigger then the Java ciphertext with the code above. The example I used here always produces a 81 byte cipher text but in nodejs it's always 82 bytes for example. Does this give us a clue on what might be wrong?</p>

<p>How do I correctly encrypt the payload so that it reaches Firefox?</p>

<p>Thanks in advance for any help</p>
","<p>Have a look at the answer from Maarten Bodewes in <a href=""https://stackoverflow.com/questions/28172710/java-compact-representation-of-ecc-publickey"">this question</a>.</p>

<p>He gives Java source for encoding/decoding from the X9.62 uncompressed format into an ECPublicKey, which I think should be suitable for what you're trying to do.</p>

<p><strong>== Update 1 ==</strong></p>

<p>The spec says ""<em>User Agents that enforce encryption MUST expose an elliptic curve Diffie-Hellman share on the P-256 curve</em>"".</p>

<p>The P-256 curve is a standard curve approved by NIST for use in US government encryption applications. The definition, parameter values and rationale for choosing this particular curve (along with a few others) are given <a href=""http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf"" rel=""nofollow noreferrer"">here</a>.</p>

<p>There is support for this curve in the standard library using the name ""secp256r1"", but for reasons that I haven't been able to fully work out (I think it's to do with the separation of cryptography providers from the JDK itself), you seem to have to jump through some very inefficient hoops to get one of these ECParameterSpec values from this name:</p>

<pre><code>KeyPairGenerator kpg = KeyPairGenerator.getInstance(""EC"");
ECGenParameterSpec kpgparams = new ECGenParameterSpec(""secp256r1"");
kpg.initialize(kpgparams);
ECParameterSpec params = ((ECPublicKey) kpg.generateKeyPair().getPublic()).getParams();
</code></pre>

<p>This is pretty heavyweight because it actually generates a keypair using the named ECGenParameterSpec object, then extracts the ECParameterSpec from it. You should then be able to use this to decode (I'd recommend caching this value somewhere to avoid having to do this key-generation frequently).</p>

<p>Alternatively, you can just take the numbers from page 8 of <a href=""http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf"" rel=""nofollow noreferrer"">the NIST document</a> and plug them in directly to the ECParameterSpec constructor.</p>

<p>There is some code <a href=""https://github.com/google/keyczar/blob/master/java/code/unofficial/org/keyczar/jce/EcCore.java"" rel=""nofollow noreferrer"">here</a> which looks like it does exactly that (around line 124). That code is <a href=""http://www.apache.org/licenses/LICENSE-2.0"" rel=""nofollow noreferrer"">Apache licensed</a>. I haven't used that code myself, but it looks like the constants match what's in the NIST document.</p>

<p><strong>== Update 2 ==</strong></p>

<p>The actual encryption key is derived from the salt (randomly generated) and the shared secret (agreed by the DH key exchange), using the HMAC-based key derivation function (HKDF) described in section 3.2 of <a href=""https://tools.ietf.org/html/draft-thomson-http-encryption-01#section-3.2"" rel=""nofollow noreferrer"">Encrypted Content-Encoding for HTTP</a>.</p>

<p>That document references <a href=""https://tools.ietf.org/html/rfc5869"" rel=""nofollow noreferrer"">RFC 5869</a> and specifies the use of SHA-256 as the hash used in the HKDF.</p>

<p>This RFC describes a two stage process: Extract and Expand. The Extract phase is defined as:</p>

<pre><code>PRK = HMAC-Hash(salt, IKM)
</code></pre>

<p>In the case of web-push, this should be an HMAC-SHA-256 operation, the salt value should be the ""saltBytes"" value that you already have, and as far as I can see the IKM value should be the shared secret (the webpush document just says ""These values are used to calculate the content encryption key"" without specifically stating that the shared secret is the IKM).</p>

<p>The Expand phase takes the value produced by the Extract phase plus an 'info' value, and repeatedly HMACs them until it has produced enough key data for the encryption algorithm that you're using (the output of each HMAC is fed into the next one - see <a href=""https://tools.ietf.org/html/rfc5869"" rel=""nofollow noreferrer"">the RFC</a> for details).</p>

<p>In this case, the algorithm is AEAD_AES_128_GCM which requires a 128-bit key, which is smaller than the output of SHA-256, so you only need to do one hash in the Expand stage.</p>

<p>The 'info' value in this case has to be ""Content-Encoding: aesgcm128"" (specified in <a href=""https://tools.ietf.org/html/draft-thomson-http-encryption-01#section-3.2"" rel=""nofollow noreferrer"">Encrypted Content-Encoding for HTTP</a>), so the operation that you need is:</p>

<pre><code>HMAC-SHA-256(PRK, ""Content-Encoding: aesgcm128"" | 0x01)
</code></pre>

<p>where the '|' is concatenation. You then take the first 16 bytes of the result, and that should be the encryption key.</p>

<p>In Java terms, that would look something like:</p>

<pre><code>// Extract
Mac extract = Mac.getInstance(""HmacSHA256"");
extract.init(new SecretKeySpec(saltBytes, ""HmacSHA256""));
final byte[] prk = extract.doFinal(bobDesKey.getEncoded());

// Expand
Mac expand = Mac.getInstance(""HmacSHA256"");
expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
String info = ""Content-Encoding: aesgcm128"";
expand.update(info.getBytes(StandardCharsets.US_ASCII));
expand.update((byte)1);
final byte[] key_bytes = expand.doFinal();

// Use the result
SecretKeySpec key = new SecretKeySpec(key_bytes, 0, 16, ""AES"");
bobCipher.init(Cipher.ENCRYPT_MODE, key);
</code></pre>

<p>For reference, <a href=""http://javadox.com/org.bouncycastle/bcprov-jdk15on/1.51/org/bouncycastle/crypto/generators/HKDFBytesGenerator.java.html"" rel=""nofollow noreferrer"">here's a link</a> to the part of the BouncyCastle library that does this stuff.</p>

<p>Finally, I just noticed this part in the webpush document: </p>

<blockquote>
  <p>Public keys, such as are encoded into the ""dh"" parameter, MUST be in
  the form of an uncompressed point</p>
</blockquote>

<p>so it looks like you will need to use something like this:</p>

<pre><code>byte[] bobPubKeyEnc = toUncompressedPoint((ECPublicKey)bobKpair.getPublic());
</code></pre>

<p>instead of using the standard getEncoded() method.</p>

<p><strong>== Update 3 ==</strong></p>

<p>First, I should point out that there is a more recent draft of the spec for http content encryption than the one that I have previous linked to: <a href=""https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding-00"" rel=""nofollow noreferrer"">draft-ietf-httpbis-encryption-encoding-00</a>. People who want to use this system should make sure that they are using the latest available draft of the spec - this is work in progress and seems to be changing slightly every few months.</p>

<p>Second, in <a href=""https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding-00#section-2"" rel=""nofollow noreferrer"">section 2</a> of that document, it specifies that some padding must be added to the plaintext before encryption (and removed after decryption).</p>

<p>This would account for the one byte difference in length between what you mentioned that you're getting and what the Node.js example produces.</p>

<p>The document says:</p>

<blockquote>
  <p>Each record contains between 1 and 256 octets of padding, inserted
  into a record before the enciphered content.  Padding consists of a
  length byte, followed that number of zero-valued octets.  A receiver
  MUST fail to decrypt if any padding octet other than the first is
  non-zero, or a record has more padding than the record size can
  accommodate.</p>
</blockquote>

<p>So I think what you need to do is to push a single '0' byte into the cipher before your plaintext. You <em>could</em> add more padding than that - I couldn't see anything that specified that the padding must be the minimum amount possible, but a single '0' byte is the simplest (anyone reading this who is trying to decode these messages from the other end should make sure that they support any legal amount of padding).</p>

<p>In general for http content encryption, the mechanism is a bit more complicated than that (since you have to split up the input into records and add padding to each one), but the webpush spec says that the encrypted message must fit into a single record, so you don't need to worry about that.</p>

<p>Note the following text in the webpush encryption spec:</p>

<blockquote>
  <p>Note that a push service is not required to support more than 4096
  octets of payload body, which equates to 4080 octets of cleartext</p>
</blockquote>

<p>The 4080 octets of cleartext here includes the 1 byte of padding, so there effectively seems to be a limit of 4079 bytes. You can specify a larger record size using the ""rs"" parameter in the ""Encryption"" header, but according to the text quoted above, the recipient isn't required to support that.</p>

<p>One warning: some of the code that I've seen to do this seems to be changing to using 2 bytes of padding, presumably as a result of some proposed spec change, but I haven't been able to track down where this is coming from. At the moment 1 byte of padding should be ok, but if this stops working in the future, you may need to go to 2 bytes - as I mentioned above this spec is a work in progress and browser support is experimental right now.</p>
","7278","<java><encryption><diffie-hellman><push-api>","17","2","4","2016-08-30 08:55:11","36129174","3","10","1002963","","2016-03-03 14:58:17","2016-02-05 15:43:15",""
"35228063","Encrypt message for Web Push API in Java","<p>I'm trying to create a server capable of sending push messages using the Push API: <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Push_API"" rel=""noreferrer"">https://developer.mozilla.org/en-US/docs/Web/API/Push_API</a></p>

<p>I've got the client side working but now I want to be able to send messages with a payload from a Java server.</p>

<p>I saw the nodejs web-push example (<a href=""https://www.npmjs.com/package/web-push"" rel=""noreferrer"">https://www.npmjs.com/package/web-push</a>) but I couldn't translate that correctly to Java.</p>

<p>I tried following the example to use the DH key exchange found here: <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex"" rel=""noreferrer"">http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex</a></p>

<p>With the help of sheltond below I was able to figure out some code that should be working but isn't. </p>

<p>When I post the encrypted message to the Push service, I get back the expected 201 status code but the push never reaches Firefox. If I remove the payload and headers and simply send a POST request to the same URL the message successfully arrives in Firefox with no data. I suspect it may have something to do with the way I'm encrypting the data with Cipher.getInstance(""AES/GCM/NoPadding"");</p>

<p>This is the code I'm using currently:</p>

<pre><code>try {
    final byte[] alicePubKeyEnc = Util.fromBase64(""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"");
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""EC"");
    ECGenParameterSpec kpgparams = new ECGenParameterSpec(""secp256r1"");
    kpg.initialize(kpgparams);

    ECParameterSpec params = ((ECPublicKey) kpg.generateKeyPair().getPublic()).getParams();
    final ECPublicKey alicePubKey = fromUncompressedPoint(alicePubKeyEnc, params);
    KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(""EC"");
    bobKpairGen.initialize(params);

    KeyPair bobKpair = bobKpairGen.generateKeyPair();
    KeyAgreement bobKeyAgree = KeyAgreement.getInstance(""ECDH"");
    bobKeyAgree.init(bobKpair.getPrivate());


    byte[] bobPubKeyEnc = toUncompressedPoint((ECPublicKey) bobKpair.getPublic());


    bobKeyAgree.doPhase(alicePubKey, true);
    Cipher bobCipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    SecretKey bobDesKey = bobKeyAgree.generateSecret(""AES"");
    byte[] saltBytes = new byte[16];
    new SecureRandom().nextBytes(saltBytes);
    Mac extract = Mac.getInstance(""HmacSHA256"");
    extract.init(new SecretKeySpec(saltBytes, ""HmacSHA256""));
    final byte[] prk = extract.doFinal(bobDesKey.getEncoded());

    // Expand
    Mac expand = Mac.getInstance(""HmacSHA256"");
    expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
    String info = ""Content-Encoding: aesgcm128"";
    expand.update(info.getBytes(StandardCharsets.US_ASCII));
    expand.update((byte) 1);
    final byte[] key_bytes = expand.doFinal();

    // Use the result
    SecretKeySpec key = new SecretKeySpec(key_bytes, 0, 16, ""AES"");
    bobCipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cleartext = ""{\""this\"":\""is a test that is supposed to be working but it is not\""}"".getBytes();
    byte[] ciphertext = bobCipher.doFinal(cleartext);

    URL url = new URL(""PUSH_ENDPOINT_URL"");
    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
    urlConnection.setRequestMethod(""POST"");
    urlConnection.setRequestProperty(""Content-Length"", ciphertext.length + """");
    urlConnection.setRequestProperty(""Content-Type"", ""application/octet-stream"");
    urlConnection.setRequestProperty(""Encryption-Key"", ""keyid=p256dh;dh="" + Util.toBase64UrlSafe(bobPubKeyEnc));
    urlConnection.setRequestProperty(""Encryption"", ""keyid=p256dh;salt="" + Util.toBase64UrlSafe(saltBytes));
    urlConnection.setRequestProperty(""Content-Encoding"", ""aesgcm128"");
    urlConnection.setDoInput(true);
    urlConnection.setDoOutput(true);
    final OutputStream outputStream = urlConnection.getOutputStream();
    outputStream.write(ciphertext);
    outputStream.flush();
    outputStream.close();
    if (urlConnection.getResponseCode() == 201) {
        String result = Util.readStream(urlConnection.getInputStream());
        Log.v(""PUSH"", ""OK: "" + result);
    } else {
        InputStream errorStream = urlConnection.getErrorStream();
        String error = Util.readStream(errorStream);
        Log.v(""PUSH"", ""Not OK: "" + error);
    }
} catch (Exception e) {
    Log.v(""PUSH"", ""Not OK: "" + e.toString());
}
</code></pre>

<p>where ""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"" is the key the Push API subscription method in the browser provided and ""PUSH_ENDPOINT_URL"" is the push endpoint the browser provided.</p>

<p>If I get values (ciphertext, base64 bobPubKeyEnc and salt) from a successful nodejs web-push request and hard-code them in Java, it works. If I use the code above with dynamic values it does not work.</p>

<p>I did notice that the ciphertext that worked in the nodejs implementation is always 1 byte bigger then the Java ciphertext with the code above. The example I used here always produces a 81 byte cipher text but in nodejs it's always 82 bytes for example. Does this give us a clue on what might be wrong?</p>

<p>How do I correctly encrypt the payload so that it reaches Firefox?</p>

<p>Thanks in advance for any help</p>
","<p>Able to receive notifications after changing code as per <a href=""https://jrconlin.github.io/WebPushDataTestPage/"" rel=""noreferrer"">https://jrconlin.github.io/WebPushDataTestPage/</a></p>

<p>Find the modified code below :</p>

<p><pre> </p>

<code>import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import java.io.BufferedInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.interfaces.ECPublicKey;
import java.security.spec.ECFieldFp;
import java.security.spec.ECParameterSpec;
import java.security.spec.ECPoint;
import java.security.spec.ECPublicKeySpec;
import java.security.spec.EllipticCurve;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.bouncycastle.jce.provider.BouncyCastleProvider;


public class WebPushEncryption {

    private static final byte UNCOMPRESSED_POINT_INDICATOR = 0x04;
    private static final ECParameterSpec params = new ECParameterSpec(
            new EllipticCurve(new ECFieldFp(new BigInteger(
                                    ""FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF"",
                                    16)), new BigInteger(
                            ""FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC"",
                            16), new BigInteger(
                            ""5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B"",
                            16)), new ECPoint(new BigInteger(
                            ""6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"",
                            16), new BigInteger(
                            ""4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5"",
                            16)), new BigInteger(
                    ""FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551"",
                    16), 1);

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());
        String endpoint = ""https://updates.push.services.mozilla.com/push/v1/xxx"";
        final byte[] alicePubKeyEnc = Base64.decode(""base64 encoded public key "");

        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""ECDH"", ""BC"");
        keyGen.initialize(params);

        KeyPair bobKpair = keyGen.generateKeyPair();
        PrivateKey localPrivateKey = bobKpair.getPrivate();
        PublicKey localpublickey = bobKpair.getPublic();

        final ECPublicKey remoteKey = fromUncompressedPoint(alicePubKeyEnc, params);

        KeyAgreement bobKeyAgree = KeyAgreement.getInstance(""ECDH"", ""BC"");
        bobKeyAgree.init(localPrivateKey);

        byte[] bobPubKeyEnc = toUncompressedPoint((ECPublicKey) bobKpair.getPublic());

        bobKeyAgree.doPhase(remoteKey, true);

        SecretKey bobDesKey = bobKeyAgree.generateSecret(""AES"");

        byte[] saltBytes = new byte[16];
        new SecureRandom().nextBytes(saltBytes);

        Mac extract = Mac.getInstance(""HmacSHA256"", ""BC"");
        extract.init(new SecretKeySpec(saltBytes, ""HmacSHA256""));
        final byte[] prk = extract.doFinal(bobDesKey.getEncoded());

        // Expand
        Mac expand = Mac.getInstance(""HmacSHA256"", ""BC"");
        expand.init(new SecretKeySpec(prk, ""HmacSHA256""));

        //aes algorithm
        String info = ""Content-Encoding: aesgcm128"";
        expand.update(info.getBytes(StandardCharsets.US_ASCII));
        expand.update((byte) 1);
        final byte[] key_bytes = expand.doFinal();
        byte[] key_bytes16 = Arrays.copyOf(key_bytes, 16);
        SecretKeySpec key = new SecretKeySpec(key_bytes16, 0, 16, ""AES-GCM"");

        //nonce
        expand.reset();
        expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
        String nonceinfo = ""Content-Encoding: nonce"";
        expand.update(nonceinfo.getBytes(StandardCharsets.US_ASCII));
        expand.update((byte) 1);
        final byte[] nonce_bytes = expand.doFinal();
        byte[] nonce_bytes12 = Arrays.copyOf(nonce_bytes, 12);

        Cipher bobCipher = Cipher.getInstance(""AES/GCM/NoPadding"", ""BC"");

        byte[] iv = generateNonce(nonce_bytes12, 0);

        bobCipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));

        byte[] cleartext = (""{\n""
                + ""      \""message\"" : \""great match41eeee!\"",\n""
                + ""      \""title\"" : \""Portugal vs. Denmark4255\"",\n""
                + ""      \""icon\"" : \""http://icons.iconarchive.com/icons/artdesigner/tweet-my-web/256/single-bird-icon.png\"",\n""
                + ""   \""tag\"" : \""testtag1\"",\n""
                + ""   \""url\"" : \""http://www.yahoo.com\""\n""
                + ""    }"").getBytes();

        byte[] cc = new byte[cleartext.length + 1];
        cc[0] = 0;

        for (int i = 0; i &lt; cleartext.length; i++) {
            cc[i + 1] = cleartext[i];
        }

        cleartext = cc;
        byte[] ciphertext = bobCipher.doFinal(cleartext);

        URL url = new URL(endpoint);
        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
        urlConnection.setRequestMethod(""POST"");
        urlConnection.setRequestProperty(""Content-Length"", ciphertext.length + """");
        urlConnection.setRequestProperty(""Content-Type"", ""application/octet-stream"");
        urlConnection.setRequestProperty(""encryption-key"", ""keyid=p256dh;dh="" + Base64.encode(bobPubKeyEnc));
        urlConnection.setRequestProperty(""encryption"", ""keyid=p256dh;salt="" + Base64.encode(saltBytes));
        urlConnection.setRequestProperty(""content-encoding"", ""aesgcm128"");
        urlConnection.setRequestProperty(""ttl"", ""60"");
        urlConnection.setDoInput(true);
        urlConnection.setDoOutput(true);
        final OutputStream outputStream = urlConnection.getOutputStream();
        outputStream.write(ciphertext);
        outputStream.flush();
        outputStream.close();
        if (urlConnection.getResponseCode() == 201) {
            String result = readStream(urlConnection.getInputStream());
            System.out.println(""PUSH OK: "" + result);
        } else {
            InputStream errorStream = urlConnection.getErrorStream();
            String error = readStream(errorStream);
            System.out.println(""PUSH"" + ""Not OK: "" + error);
        }
    }

    static byte[] generateNonce(byte[] base, int index) {
        byte[] nonce = Arrays.copyOfRange(base, 0, 12);

        for (int i = 0; i &lt; 6; ++i) {
            nonce[nonce.length - 1 - i] ^= (byte) ((index / Math.pow(256, i))) &amp; (0xff);
        }
        return nonce;
    }

    private static String readStream(InputStream errorStream) throws Exception {
        BufferedInputStream bs = new BufferedInputStream(errorStream);
        int i = 0;
        byte[] b = new byte[1024];
        StringBuilder sb = new StringBuilder();
        while ((i = bs.read(b)) != -1) {
            sb.append(new String(b, 0, i));
        }

        return sb.toString();
    }

    public static ECPublicKey fromUncompressedPoint(
            final byte[] uncompressedPoint, final ECParameterSpec params)
            throws Exception {

        int offset = 0;
        if (uncompressedPoint[offset++] != UNCOMPRESSED_POINT_INDICATOR) {
            throw new IllegalArgumentException(
                    ""Invalid uncompressedPoint encoding, no uncompressed point indicator"");
        }

        int keySizeBytes = (params.getOrder().bitLength() + Byte.SIZE - 1)
                / Byte.SIZE;

        if (uncompressedPoint.length != 1 + 2 * keySizeBytes) {
            throw new IllegalArgumentException(
                    ""Invalid uncompressedPoint encoding, not the correct size"");
        }

        final BigInteger x = new BigInteger(1, Arrays.copyOfRange(
                uncompressedPoint, offset, offset + keySizeBytes));
        offset += keySizeBytes;
        final BigInteger y = new BigInteger(1, Arrays.copyOfRange(
                uncompressedPoint, offset, offset + keySizeBytes));
        final ECPoint w = new ECPoint(x, y);
        final ECPublicKeySpec ecPublicKeySpec = new ECPublicKeySpec(w, params);
        final KeyFactory keyFactory = KeyFactory.getInstance(""EC"");
        return (ECPublicKey) keyFactory.generatePublic(ecPublicKeySpec);
    }

    public static byte[] toUncompressedPoint(final ECPublicKey publicKey) {

        int keySizeBytes = (publicKey.getParams().getOrder().bitLength() + Byte.SIZE - 1)
                / Byte.SIZE;

        final byte[] uncompressedPoint = new byte[1 + 2 * keySizeBytes];
        int offset = 0;
        uncompressedPoint[offset++] = 0x04;

        final byte[] x = publicKey.getW().getAffineX().toByteArray();
        if (x.length &lt;= keySizeBytes) {
            System.arraycopy(x, 0, uncompressedPoint, offset + keySizeBytes
                    - x.length, x.length);
        } else if (x.length == keySizeBytes + 1 &amp;&amp; x[0] == 0) {
            System.arraycopy(x, 1, uncompressedPoint, offset, keySizeBytes);
        } else {
            throw new IllegalStateException(""x value is too large"");
        }
        offset += keySizeBytes;

        final byte[] y = publicKey.getW().getAffineY().toByteArray();
        if (y.length &lt;= keySizeBytes) {
            System.arraycopy(y, 0, uncompressedPoint, offset + keySizeBytes
                    - y.length, y.length);
        } else if (y.length == keySizeBytes + 1 &amp;&amp; y[0] == 0) {
            System.arraycopy(y, 1, uncompressedPoint, offset, keySizeBytes);
        } else {
            throw new IllegalStateException(""y value is too large"");
        }

        return uncompressedPoint;
    }
}
</code></pre>
","7278","<java><encryption><diffie-hellman><push-api>","17","5","4","2016-08-30 08:55:11","36129174","3","10","1002963","","2016-03-03 14:58:17","2016-02-05 15:43:15",""
"35228063","Encrypt message for Web Push API in Java","<p>I'm trying to create a server capable of sending push messages using the Push API: <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Push_API"" rel=""noreferrer"">https://developer.mozilla.org/en-US/docs/Web/API/Push_API</a></p>

<p>I've got the client side working but now I want to be able to send messages with a payload from a Java server.</p>

<p>I saw the nodejs web-push example (<a href=""https://www.npmjs.com/package/web-push"" rel=""noreferrer"">https://www.npmjs.com/package/web-push</a>) but I couldn't translate that correctly to Java.</p>

<p>I tried following the example to use the DH key exchange found here: <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex"" rel=""noreferrer"">http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex</a></p>

<p>With the help of sheltond below I was able to figure out some code that should be working but isn't. </p>

<p>When I post the encrypted message to the Push service, I get back the expected 201 status code but the push never reaches Firefox. If I remove the payload and headers and simply send a POST request to the same URL the message successfully arrives in Firefox with no data. I suspect it may have something to do with the way I'm encrypting the data with Cipher.getInstance(""AES/GCM/NoPadding"");</p>

<p>This is the code I'm using currently:</p>

<pre><code>try {
    final byte[] alicePubKeyEnc = Util.fromBase64(""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"");
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""EC"");
    ECGenParameterSpec kpgparams = new ECGenParameterSpec(""secp256r1"");
    kpg.initialize(kpgparams);

    ECParameterSpec params = ((ECPublicKey) kpg.generateKeyPair().getPublic()).getParams();
    final ECPublicKey alicePubKey = fromUncompressedPoint(alicePubKeyEnc, params);
    KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(""EC"");
    bobKpairGen.initialize(params);

    KeyPair bobKpair = bobKpairGen.generateKeyPair();
    KeyAgreement bobKeyAgree = KeyAgreement.getInstance(""ECDH"");
    bobKeyAgree.init(bobKpair.getPrivate());


    byte[] bobPubKeyEnc = toUncompressedPoint((ECPublicKey) bobKpair.getPublic());


    bobKeyAgree.doPhase(alicePubKey, true);
    Cipher bobCipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    SecretKey bobDesKey = bobKeyAgree.generateSecret(""AES"");
    byte[] saltBytes = new byte[16];
    new SecureRandom().nextBytes(saltBytes);
    Mac extract = Mac.getInstance(""HmacSHA256"");
    extract.init(new SecretKeySpec(saltBytes, ""HmacSHA256""));
    final byte[] prk = extract.doFinal(bobDesKey.getEncoded());

    // Expand
    Mac expand = Mac.getInstance(""HmacSHA256"");
    expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
    String info = ""Content-Encoding: aesgcm128"";
    expand.update(info.getBytes(StandardCharsets.US_ASCII));
    expand.update((byte) 1);
    final byte[] key_bytes = expand.doFinal();

    // Use the result
    SecretKeySpec key = new SecretKeySpec(key_bytes, 0, 16, ""AES"");
    bobCipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cleartext = ""{\""this\"":\""is a test that is supposed to be working but it is not\""}"".getBytes();
    byte[] ciphertext = bobCipher.doFinal(cleartext);

    URL url = new URL(""PUSH_ENDPOINT_URL"");
    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
    urlConnection.setRequestMethod(""POST"");
    urlConnection.setRequestProperty(""Content-Length"", ciphertext.length + """");
    urlConnection.setRequestProperty(""Content-Type"", ""application/octet-stream"");
    urlConnection.setRequestProperty(""Encryption-Key"", ""keyid=p256dh;dh="" + Util.toBase64UrlSafe(bobPubKeyEnc));
    urlConnection.setRequestProperty(""Encryption"", ""keyid=p256dh;salt="" + Util.toBase64UrlSafe(saltBytes));
    urlConnection.setRequestProperty(""Content-Encoding"", ""aesgcm128"");
    urlConnection.setDoInput(true);
    urlConnection.setDoOutput(true);
    final OutputStream outputStream = urlConnection.getOutputStream();
    outputStream.write(ciphertext);
    outputStream.flush();
    outputStream.close();
    if (urlConnection.getResponseCode() == 201) {
        String result = Util.readStream(urlConnection.getInputStream());
        Log.v(""PUSH"", ""OK: "" + result);
    } else {
        InputStream errorStream = urlConnection.getErrorStream();
        String error = Util.readStream(errorStream);
        Log.v(""PUSH"", ""Not OK: "" + error);
    }
} catch (Exception e) {
    Log.v(""PUSH"", ""Not OK: "" + e.toString());
}
</code></pre>

<p>where ""BASE_64_PUBLIC_KEY_FROM_PUSH_SUBSCRIPTION"" is the key the Push API subscription method in the browser provided and ""PUSH_ENDPOINT_URL"" is the push endpoint the browser provided.</p>

<p>If I get values (ciphertext, base64 bobPubKeyEnc and salt) from a successful nodejs web-push request and hard-code them in Java, it works. If I use the code above with dynamic values it does not work.</p>

<p>I did notice that the ciphertext that worked in the nodejs implementation is always 1 byte bigger then the Java ciphertext with the code above. The example I used here always produces a 81 byte cipher text but in nodejs it's always 82 bytes for example. Does this give us a clue on what might be wrong?</p>

<p>How do I correctly encrypt the payload so that it reaches Firefox?</p>

<p>Thanks in advance for any help</p>
","<p>The solution of santosh kumar works with one modification:</p>

<p>I added a 1-byte cipher padding right before defining the cleartext byte[].</p>

<pre><code>Cipher bobCipher = Cipher.getInstance(""AES/GCM/NoPadding"", ""BC"");
byte[] iv = generateNonce(nonce_bytes12, 0);
bobCipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));

// adding firefox padding:
bobCipher.update(new byte[1]);

byte[] cleartext = {...};
</code></pre>
","7278","<java><encryption><diffie-hellman><push-api>","17","0","4","2016-08-30 08:55:11","36129174","3","10","1002963","","2016-03-03 14:58:17","2016-02-05 15:43:15",""
"6912219","Diffie Hellman and AES on Android","<p>I am trying to use Diffie Hellman for key exchange and <code>AES</code> to encrypt data with keys. Can anyone provide me a suitable work sample for android ?</p>
","<p>I've actually been working on a similar problem lately myself. I don't have a working sample, but here are some points you should be aware of:</p>

<ol>
<li><p>Android uses a partial Bouncy Castle package to handle most of its cryptography, but some people prefer to user their own cryptographic package (Spongy Castle is a commonly cited alternative) since Android's is incomplete. See <a href=""https://stackoverflow.com/questions/6488658/can-i-use-latest-bouncycastle-provider-on-android"">the discussion in here</a>.</p></li>
<li><p>If you choose to use Android's existing tools, you can access them through <a href=""http://developer.android.com/reference/javax/crypto/Cipher.html"" rel=""nofollow noreferrer"">Cipher</a>. Here is a <a href=""http://groups.google.com/group/android-developers/browse_thread/thread/a4c3673dee73eac8?fwc=1"" rel=""nofollow noreferrer"">useful list of algorithms Android supports</a>.</p></li>
<li><p>Be aware that if you choose to use some non-Android Java crypto library, Android does not support all Java packages your library may need. See <a href=""https://stackoverflow.com/questions/6898801/how-to-include-the-spongy-castle-jar-in-android"">my (currently unanswered) question about how to deal with that in Spongy Castle</a>.</p></li>
</ol>

<p>Hope these help!</p>
","7207","<android><encryption><aes><diffie-hellman>","3","3","1","2011-08-02 15:49:38","","0","5","517247","","2011-08-02 12:44:24","2011-08-02 12:40:38",""
"17248095","Diffie Hellman Key Exchange","<p>i am currently trying to do a diffie hellman key exchange using the java crypto libray, I have succeeded in finding a safe prime and also a generator for it. However i seem to have trouble creating a DH key with the values that i have found. It gives me the following exception </p>

<p><strong>Exception in thread ""main"" java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 1024 (inclusive)
    at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
    at java.security.KeyPairGenerator$Delegate.initialize(Unknown Source)
    at java.security.KeyPairGenerator.initialize(Unknown Source)
    at DH.createSpecificKey(DH.java:35)
    at DH.main(DH.java:166)</strong></p>

<p>As you all know, in cryptography we cannot let our primes be small. How do i cater my safe primes and generator to fit the criteria of the DH library.</p>

<p>Below is my source code</p>

<pre><code>public static void createKey()throws Exception
{
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""DiffieHellman"");
    kpg.initialize(512);
    KeyPair kp = kpg.generateKeyPair();
    KeyFactory kfactory = KeyFactory.getInstance(""DiffieHellman"");

    DHPublicKeySpec kspec = (DHPublicKeySpec) kfactory.getKeySpec(kp.getPublic(), DHPublicKeySpec.class);

}

public static void createSpecificKey(BigInteger p,BigInteger g)throws Exception
{
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""DiffieHellman"");
    DHParameterSpec param = new DHParameterSpec(p,g);
    kpg.initialize(param);

    KeyPair kp = kpg.generateKeyPair();

    KeyFactory kfactory = KeyFactory.getInstance(""DiffieHellman"");

    DHPublicKeySpec kspec = (DHPublicKeySpec) kfactory.getKeySpec(kp.getPublic(), DHPublicKeySpec.class);

}


static boolean isPrime(long n)
{
    if (n%2 == 0)
    {
        return false;
    }

    for(int i = 3 ; i*i&lt;=n;i+=2)
    {
        if(n%i==0)
            return false;
    }
    return true;
}


public static void main(String [] args) throws Exception
{

    Random randomGenerator = new Random();

    long pValue = randomGenerator.nextInt(1000000);
    long gValue = randomGenerator.nextInt(100000);
    long correctPValue;

    boolean checkPrime = isPrime(pValue);
    System.out.println(""the number generated is ""+pValue);
    System.out.println(checkPrime);

    while(checkPrime == false)

    {
        long pValue2 = randomGenerator.nextInt(1000000);
        boolean checkPrimeInLoop = isPrime(pValue2);
        //System.out.println(""value in loop is ""+pValue2);
        if(checkPrimeInLoop == true)
        {
            pValue=pValue2;
            break;
        }
    }


    long checkSP = (pValue*2)+1;
    boolean checkSafePrime = isPrime(checkSP);
    //System.out.println(checkSafePrime);
    while(checkSafePrime==false)
    {
        long pValue3=randomGenerator.nextInt(1000000);
        boolean checkPrimeInLoop = isPrime(pValue3);
        long pValue5=(pValue3*2)+1;
        //boolean checkSafePrimeInLoop = isPrime(pValue4);
        boolean checkSafePrime2InLoop = isPrime(pValue5);

        if(checkSafePrime2InLoop == true &amp;&amp; checkPrimeInLoop == true)
        {
            pValue=pValue3;
            break;
        }

    }

    System.out.println(""the safe prime is""+pValue);//safe prime

    while(gValue&gt;pValue)
    {
        long gValue2=randomGenerator.nextInt(100000);

        if(gValue2&lt;pValue)
        {
            gValue=gValue2;
            break;
        }
    }

    long getDivisor = (pValue-1)/2;
    BigInteger bi1,bi2,bi3,bi4;

    bi1=BigInteger.valueOf(getDivisor);

    bi2 = BigInteger.valueOf(pValue);

    bi3 = BigInteger.valueOf(gValue);

    bi4= bi3.modPow(bi1,bi2);

    long calculatedValue = bi4.longValue();


    while(calculatedValue == 1)
    {
        long gValue3=randomGenerator.nextInt(100000);
        long getDivisorInLoop = (pValue-1)/2;
        BigInteger bi5,bi6,bi7,bi8;

        bi5=BigInteger.valueOf(getDivisorInLoop);

        bi6 = BigInteger.valueOf(pValue);

        bi7 = BigInteger.valueOf(gValue3);

        bi8= bi7.modPow(bi5,bi6);

        long calculatedValueInLoop = bi8.longValue();
        System.out.println(calculatedValueInLoop);
        if(calculatedValueInLoop!=1)
        {
            gValue=gValue3;
            break;
        }
    }

    BigInteger generatorValue,primeValue;

    generatorValue = BigInteger.valueOf(gValue);
    primeValue = BigInteger.valueOf(pValue);

    createKey();

    int bitLength=512;

    createSpecificKey(generatorValue,primeValue);


}
</code></pre>

<p>Hope you guys can help me with this. Thanks in advance! </p>
","<p>You aim to go for 512 bit length:
<code>kpg.initialize(512);</code></p>

<p>You can generate p and g of such length like this:</p>

<pre><code>int bitLength = 1024;
SecureRandom rnd = new SecureRandom();
BigInteger p = BigInteger.probablePrime(bitLength, rnd);
BigInteger g = BigInteger.probablePrime(bitLength, rnd);
</code></pre>

<p>The <code>probablePrime</code> probably use Rabin-Miller or Solovay-Strassen test which gives only 2^-100 chance (virtually no chance) that the resulting integer is not prime. Since 2002 a there's a polinomial-time algorithm called AKS (Agrawal–Kayal–Saxena) to test primes for 100% certainty (but I haven't seen it used so far, probably 2^-100 is good for anyone).</p>
","7079","<java><security><diffie-hellman>","1","2","2","2014-03-11 08:28:23","","0","1","","","","2013-06-22 06:45:35",""
"17248095","Diffie Hellman Key Exchange","<p>i am currently trying to do a diffie hellman key exchange using the java crypto libray, I have succeeded in finding a safe prime and also a generator for it. However i seem to have trouble creating a DH key with the values that i have found. It gives me the following exception </p>

<p><strong>Exception in thread ""main"" java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 1024 (inclusive)
    at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
    at java.security.KeyPairGenerator$Delegate.initialize(Unknown Source)
    at java.security.KeyPairGenerator.initialize(Unknown Source)
    at DH.createSpecificKey(DH.java:35)
    at DH.main(DH.java:166)</strong></p>

<p>As you all know, in cryptography we cannot let our primes be small. How do i cater my safe primes and generator to fit the criteria of the DH library.</p>

<p>Below is my source code</p>

<pre><code>public static void createKey()throws Exception
{
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""DiffieHellman"");
    kpg.initialize(512);
    KeyPair kp = kpg.generateKeyPair();
    KeyFactory kfactory = KeyFactory.getInstance(""DiffieHellman"");

    DHPublicKeySpec kspec = (DHPublicKeySpec) kfactory.getKeySpec(kp.getPublic(), DHPublicKeySpec.class);

}

public static void createSpecificKey(BigInteger p,BigInteger g)throws Exception
{
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""DiffieHellman"");
    DHParameterSpec param = new DHParameterSpec(p,g);
    kpg.initialize(param);

    KeyPair kp = kpg.generateKeyPair();

    KeyFactory kfactory = KeyFactory.getInstance(""DiffieHellman"");

    DHPublicKeySpec kspec = (DHPublicKeySpec) kfactory.getKeySpec(kp.getPublic(), DHPublicKeySpec.class);

}


static boolean isPrime(long n)
{
    if (n%2 == 0)
    {
        return false;
    }

    for(int i = 3 ; i*i&lt;=n;i+=2)
    {
        if(n%i==0)
            return false;
    }
    return true;
}


public static void main(String [] args) throws Exception
{

    Random randomGenerator = new Random();

    long pValue = randomGenerator.nextInt(1000000);
    long gValue = randomGenerator.nextInt(100000);
    long correctPValue;

    boolean checkPrime = isPrime(pValue);
    System.out.println(""the number generated is ""+pValue);
    System.out.println(checkPrime);

    while(checkPrime == false)

    {
        long pValue2 = randomGenerator.nextInt(1000000);
        boolean checkPrimeInLoop = isPrime(pValue2);
        //System.out.println(""value in loop is ""+pValue2);
        if(checkPrimeInLoop == true)
        {
            pValue=pValue2;
            break;
        }
    }


    long checkSP = (pValue*2)+1;
    boolean checkSafePrime = isPrime(checkSP);
    //System.out.println(checkSafePrime);
    while(checkSafePrime==false)
    {
        long pValue3=randomGenerator.nextInt(1000000);
        boolean checkPrimeInLoop = isPrime(pValue3);
        long pValue5=(pValue3*2)+1;
        //boolean checkSafePrimeInLoop = isPrime(pValue4);
        boolean checkSafePrime2InLoop = isPrime(pValue5);

        if(checkSafePrime2InLoop == true &amp;&amp; checkPrimeInLoop == true)
        {
            pValue=pValue3;
            break;
        }

    }

    System.out.println(""the safe prime is""+pValue);//safe prime

    while(gValue&gt;pValue)
    {
        long gValue2=randomGenerator.nextInt(100000);

        if(gValue2&lt;pValue)
        {
            gValue=gValue2;
            break;
        }
    }

    long getDivisor = (pValue-1)/2;
    BigInteger bi1,bi2,bi3,bi4;

    bi1=BigInteger.valueOf(getDivisor);

    bi2 = BigInteger.valueOf(pValue);

    bi3 = BigInteger.valueOf(gValue);

    bi4= bi3.modPow(bi1,bi2);

    long calculatedValue = bi4.longValue();


    while(calculatedValue == 1)
    {
        long gValue3=randomGenerator.nextInt(100000);
        long getDivisorInLoop = (pValue-1)/2;
        BigInteger bi5,bi6,bi7,bi8;

        bi5=BigInteger.valueOf(getDivisorInLoop);

        bi6 = BigInteger.valueOf(pValue);

        bi7 = BigInteger.valueOf(gValue3);

        bi8= bi7.modPow(bi5,bi6);

        long calculatedValueInLoop = bi8.longValue();
        System.out.println(calculatedValueInLoop);
        if(calculatedValueInLoop!=1)
        {
            gValue=gValue3;
            break;
        }
    }

    BigInteger generatorValue,primeValue;

    generatorValue = BigInteger.valueOf(gValue);
    primeValue = BigInteger.valueOf(pValue);

    createKey();

    int bitLength=512;

    createSpecificKey(generatorValue,primeValue);


}
</code></pre>

<p>Hope you guys can help me with this. Thanks in advance! </p>
","<p>I assume your question is why you can only create primes from 512 to 1024 bits, while 2048 bits is recommended?! The answer is simple: the 2048 bits do not relate to the primes, but to the <strong>size of the modulus</strong> which is the product of the two primes. Two primes with 1024 bit each will give you a modulus of 2048 bit. That's why it's safe to use 1024 bit for the DH primes.</p>

<p>Regarding your exception: Csaba Toth is right: your primes are too small and the way to generate them is suboptimal. Just use your <code>createKey()</code> method and you are fine.</p>
","7079","<java><security><diffie-hellman>","1","0","2","2014-03-11 08:28:23","","0","1","","","","2013-06-22 06:45:35",""
"18155559","How does one access the raw ECDH public key, private key and params inside OpenSSL's EVP_PKEY structure?","<p>I'm using OpenSSL's c library to generate an elliptic curve Diffie-Hellman (ECDH) key pair, following the first code sample <a href=""http://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman"">here</a>. It glosses over the actual exchange of public keys with this line:</p>

<pre><code>peerkey = get_peerkey(pkey);
</code></pre>

<p>The <code>pkey</code> variable and the return value are both of type <code>EVP *</code>. <code>pkey</code> contains the public key, private key, and params generated earlier, and the return value only contains the peer's public key. So this raises three questions:</p>

<ol>
<li>How would <code>get_peerkey()</code> actually extract just the public key from <code>pkey</code> for sending to the peer?</li>
<li>How would the code extract the private key and params from <code>pKey</code> to store them for later use after the key exchange?</li>
<li>How would <code>get_peerkey()</code> generate a new <code>EVP_PKEY</code> structure from the peer's raw public key?</li>
</ol>

<p>I've seen the OpenSSL functions <code>EVP_PKEY_print_public()</code>, <code>EVP_PKEY_print_private()</code>, and <code>EVP_PKEY_print_params()</code> but these are for generating human-readable output. And I haven't found any equivalent for converting a human-readable public key back into an <code>EVP_PKEY</code> structure.</p>
","<p>To answer my own question, there's a different path for the private key and the public key.</p>

<p>To serialize the public key:</p>

<ol>
<li>Pass the EVP_PKEY to EVP_PKEY_get1_EC_KEY() to get an EC_KEY.</li>
<li>Pass the EC_KEY to EC_KEY_get0_public_key() to get an EC_POINT.</li>
<li>Pass the EC_POINT to EC_POINT_point2oct() to get octets, which are just unsigned char *.</li>
</ol>

<p>To deserialize the public key:</p>

<ol>
<li>Pass the octets to EC_POINT_oct2point() to get an EC_POINT.</li>
<li>Pass the EC_POINT to EC_KEY_set_public_key() to get an EC_KEY.</li>
<li>Pass the EC_KEY to EVP_PKEY_set1_EC_KEY to get an EVP_KEY.</li>
</ol>

<p>To serialize the private key:</p>

<ol>
<li>Pass the EVP_PKEY to EVP_PKEY_get1_EC_KEY() to get an EC_KEY.</li>
<li>Pass the EC_KEY to EC_KEY_get0_private_key() to get a BIGNUM. </li>
<li>Pass the BIGNUM to BN_bn2mpi() to get an mpi, which is a format written to
unsigned char *.</li>
</ol>

<p>To deserialize the private key:</p>

<ol>
<li>Pass the mpi to BN_mpi2bn() to get a BIGNUM.</li>
<li>Pass the BIGNUM to EC_KEY_set_private_key() to get an EC_KEY.</li>
<li>Pass the EC_KEY to EVP_PKEY_set1_EC_KEY to get an EVP_KEY.</li>
</ol>

<p>It is also possible to convert the BIGNUM to hex, decimal, or ""bin"", although I think that mpi used the fewest bytes.</p>
","6926","<c><openssl><pki><elliptic-curve><diffie-hellman>","17","36","1","2015-07-26 01:22:57","18603667","0","7","","","","2013-08-09 20:58:23",""
"32486811","Chrome error ""Server has a weak ephemeral Diffie-Hellman public key"" for internal sites","<p>Chrome seems to have released an update over the past week. This has caused at least 50 of our internal applications to throw the exception shown below. The solutions I have researched over the Internet, talk about updating the application server with a stronger cipher. However, our applications are spread out over IIS, tomcat, jboss, weblogic and websphere. Its not practical to expect all of these application servers to be updated. Is there no way to get Chrome to allow an ""exception"" for these sites ? Since these sites are all internal, the security is not really a concern.  </p>

<p>Apparently, Firefox throws the same exception but there is a documented fix for that (by changing some settings in Firefox). Is anyone aware of a similar fix in Chrome.</p>

<p><strong>Error</strong></p>

<pre><code>Server has a weak ephemeral Diffie-Hellman public key

ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY
</code></pre>
","<p>I found a temporary workaround that should disable the security check in Chrome that is causing that error. It goes without saying that you do NOT want to use this while browsing the open web.</p>

<p>Try adding the following command argument to Chrome when you start it up:</p>

<pre><code>--cipher-suite-blacklist=0x0088,0x0087,0x0039,0x0038,0x0044,0x0045,0x0066,0x0032,0x0033,0x0016,0x0013
</code></pre>

<p>I found this solution at <a href=""https://productforums.google.com/d/msg/chrome/o3vZD-Mg2Ic/eJFgRWTynG8J"" rel=""nofollow"">this google forum post</a>. Hopefully it will help!</p>
","6670","<google-chrome><ssl><ssl-certificate><diffie-hellman>","3","3","4","2016-11-22 13:44:44","32487067","0","","2234742","","2015-09-12 00:05:24","2015-09-09 18:30:56",""
"32486811","Chrome error ""Server has a weak ephemeral Diffie-Hellman public key"" for internal sites","<p>Chrome seems to have released an update over the past week. This has caused at least 50 of our internal applications to throw the exception shown below. The solutions I have researched over the Internet, talk about updating the application server with a stronger cipher. However, our applications are spread out over IIS, tomcat, jboss, weblogic and websphere. Its not practical to expect all of these application servers to be updated. Is there no way to get Chrome to allow an ""exception"" for these sites ? Since these sites are all internal, the security is not really a concern.  </p>

<p>Apparently, Firefox throws the same exception but there is a documented fix for that (by changing some settings in Firefox). Is anyone aware of a similar fix in Chrome.</p>

<p><strong>Error</strong></p>

<pre><code>Server has a weak ephemeral Diffie-Hellman public key

ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY
</code></pre>
","<p>While Maximillian's workaround might work for you at the moment, there is no supported way to add an exception.
The only safe solution is to upgrade the servers, and a less fragile workaround might be to put better proxies right in front of some of the servers.</p>
","6670","<google-chrome><ssl><ssl-certificate><diffie-hellman>","3","1","4","2016-11-22 13:44:44","32487067","0","","2234742","","2015-09-12 00:05:24","2015-09-09 18:30:56",""
"32486811","Chrome error ""Server has a weak ephemeral Diffie-Hellman public key"" for internal sites","<p>Chrome seems to have released an update over the past week. This has caused at least 50 of our internal applications to throw the exception shown below. The solutions I have researched over the Internet, talk about updating the application server with a stronger cipher. However, our applications are spread out over IIS, tomcat, jboss, weblogic and websphere. Its not practical to expect all of these application servers to be updated. Is there no way to get Chrome to allow an ""exception"" for these sites ? Since these sites are all internal, the security is not really a concern.  </p>

<p>Apparently, Firefox throws the same exception but there is a documented fix for that (by changing some settings in Firefox). Is anyone aware of a similar fix in Chrome.</p>

<p><strong>Error</strong></p>

<pre><code>Server has a weak ephemeral Diffie-Hellman public key

ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY
</code></pre>
","<p>This problem I found because of the JDK version running on App Server.</p>

<p>If your weblogic/apache server running on java JRockit version ""1.6.0_33""  &amp; ""1.6.0_45"" or below you will face this issue.</p>

<p>A solution is to upgrade java to higher version like ""1.6.0_101"" and higher and restart app server.</p>
","6670","<google-chrome><ssl><ssl-certificate><diffie-hellman>","3","0","4","2016-11-22 13:44:44","32487067","0","","2234742","","2015-09-12 00:05:24","2015-09-09 18:30:56",""
"32486811","Chrome error ""Server has a weak ephemeral Diffie-Hellman public key"" for internal sites","<p>Chrome seems to have released an update over the past week. This has caused at least 50 of our internal applications to throw the exception shown below. The solutions I have researched over the Internet, talk about updating the application server with a stronger cipher. However, our applications are spread out over IIS, tomcat, jboss, weblogic and websphere. Its not practical to expect all of these application servers to be updated. Is there no way to get Chrome to allow an ""exception"" for these sites ? Since these sites are all internal, the security is not really a concern.  </p>

<p>Apparently, Firefox throws the same exception but there is a documented fix for that (by changing some settings in Firefox). Is anyone aware of a similar fix in Chrome.</p>

<p><strong>Error</strong></p>

<pre><code>Server has a weak ephemeral Diffie-Hellman public key

ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY
</code></pre>
","<p>I've solved this problem without upgrading jrockit but configuring the ssl section like this</p>

<pre><code>&lt;ssl&gt;
    &lt;enabled&gt;true&lt;/enabled&gt;
    &lt;hostname-verifier xsi:nil=""true""&gt;&lt;/hostname-verifier&gt;
    &lt;hostname-verification-ignored&gt;false&lt;/hostname-verification-ignored&gt;
    &lt;export-key-lifespan&gt;500&lt;/export-key-lifespan&gt;
    &lt;client-certificate-enforced&gt;false&lt;/client-certificate-enforced&gt;
    &lt;two-way-ssl-enabled&gt;false&lt;/two-way-ssl-enabled&gt;
    &lt;ssl-rejection-logging-enabled&gt;true&lt;/ssl-rejection-logging-enabled&gt;
    &lt;inbound-certificate-validation&gt;BuiltinSSLValidationOnly&lt;/inbound-certificate-validation&gt;
    &lt;outbound-certificate-validation&gt;BuiltinSSLValidationOnly&lt;/outbound-certificate-validation&gt;
    &lt;allow-unencrypted-null-cipher&gt;false&lt;/allow-unencrypted-null-cipher&gt;
    &lt;use-server-certs&gt;false&lt;/use-server-certs&gt;
    &lt;jsse-enabled&gt;true&lt;/jsse-enabled&gt;
&lt;/ssl&gt;
</code></pre>

<p>Can't tell you exactly whats makes the difference but it solved many different problems on SSL with chrome</p>
","6670","<google-chrome><ssl><ssl-certificate><diffie-hellman>","3","0","4","2016-11-22 13:44:44","32487067","0","","2234742","","2015-09-12 00:05:24","2015-09-09 18:30:56",""
"8788736","Diffie-Hellman implementation for iOS?","<p>This is my first question here as before I found all workarounds from another questions.</p>

<p>The question is very short: Does anyone know if there is any Diffie-Hellman implementation for iOS? I mean...the idea is to share between 2 devices (one is iOS and the other a java web service) a secret key, and I think the best idea should be that method.</p>

<p>If not, can anyone suggest me another option?</p>

<p>I'm not an advanced developer, that's why i'm trying to check for a framework for this.</p>

<p>Thanks in advance everyone!</p>
","<p>A quick google gives;</p>

<p><a href=""http://www.chilkatsoft.com/dh-objc.asp"" rel=""nofollow"">http://www.chilkatsoft.com/dh-objc.asp</a></p>

<p>You should <em>really</em> look into just using SSL though instead of inventing your own security protocol.</p>
","4743","<ios><diffie-hellman>","5","1","5","2017-12-12 04:30:53","","1","","","","","2012-01-09 12:55:26",""
"8788736","Diffie-Hellman implementation for iOS?","<p>This is my first question here as before I found all workarounds from another questions.</p>

<p>The question is very short: Does anyone know if there is any Diffie-Hellman implementation for iOS? I mean...the idea is to share between 2 devices (one is iOS and the other a java web service) a secret key, and I think the best idea should be that method.</p>

<p>If not, can anyone suggest me another option?</p>

<p>I'm not an advanced developer, that's why i'm trying to check for a framework for this.</p>

<p>Thanks in advance everyone!</p>
","<p>You can include openssl as a static library in your app project and use its <a href=""http://www.openssl.org/docs/crypto/dh.html"" rel=""nofollow"">Diffie-Hellman</a> functions. As Joachim rightly says though, if you're communicating to a web service the easiest and best approach is to use SSL.</p>
","4743","<ios><diffie-hellman>","5","0","5","2017-12-12 04:30:53","","1","","","","","2012-01-09 12:55:26",""
"8788736","Diffie-Hellman implementation for iOS?","<p>This is my first question here as before I found all workarounds from another questions.</p>

<p>The question is very short: Does anyone know if there is any Diffie-Hellman implementation for iOS? I mean...the idea is to share between 2 devices (one is iOS and the other a java web service) a secret key, and I think the best idea should be that method.</p>

<p>If not, can anyone suggest me another option?</p>

<p>I'm not an advanced developer, that's why i'm trying to check for a framework for this.</p>

<p>Thanks in advance everyone!</p>
","<p>There is a Diffie-Hellman implementation for iOS in github.
You can use it.
<a href=""https://github.com/benjholla/Diffie-Hellman-iOS"" rel=""nofollow"">https://github.com/benjholla/Diffie-Hellman-iOS</a>
Also you can use openssl with ios. Considering openssl is a proven library, it is better to use openssl for this purpose.</p>
","4743","<ios><diffie-hellman>","5","0","5","2017-12-12 04:30:53","","1","","","","","2012-01-09 12:55:26",""
"8788736","Diffie-Hellman implementation for iOS?","<p>This is my first question here as before I found all workarounds from another questions.</p>

<p>The question is very short: Does anyone know if there is any Diffie-Hellman implementation for iOS? I mean...the idea is to share between 2 devices (one is iOS and the other a java web service) a secret key, and I think the best idea should be that method.</p>

<p>If not, can anyone suggest me another option?</p>

<p>I'm not an advanced developer, that's why i'm trying to check for a framework for this.</p>

<p>Thanks in advance everyone!</p>
","<p>Apple has an implementation of Diffie-Hellman in iOS as part of <a href=""https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/SecureNetworkCommunicationAPIs/SecureNetworkCommunicationAPIs.html#//apple_ref/doc/uid/TP40011172-CH13-CHDHDIBB"" rel=""nofollow"">Secure Transport</a>. Here is the <a href=""https://developer.apple.com/library/ios/documentation/Security/Reference/secureTransportRef/index.html#//apple_ref/doc/uid/TP30000155"" rel=""nofollow"">Secure Transport Reference</a></p>

<p>I'm posting this answer on a very old question because it's still relevant and other questions might link to this one. Improving this question's completeness may help answer newer questions.</p>
","4743","<ios><diffie-hellman>","5","4","5","2017-12-12 04:30:53","","1","","","","","2012-01-09 12:55:26",""
"8788736","Diffie-Hellman implementation for iOS?","<p>This is my first question here as before I found all workarounds from another questions.</p>

<p>The question is very short: Does anyone know if there is any Diffie-Hellman implementation for iOS? I mean...the idea is to share between 2 devices (one is iOS and the other a java web service) a secret key, and I think the best idea should be that method.</p>

<p>If not, can anyone suggest me another option?</p>

<p>I'm not an advanced developer, that's why i'm trying to check for a framework for this.</p>

<p>Thanks in advance everyone!</p>
","<p>There is a Diffie-Hellman implementation for iOS SWIFT-4 on github with complete example code. You can use it. <a href=""https://github.com/raoarafat/DeffieHelmanKeyExchange-Swift"" rel=""nofollow noreferrer"">https://github.com/raoarafat/DeffieHelmanKeyExchange-Swift</a>. Just download &amp; use it.</p>

<p>SWIFT-4 Compatible.</p>

<p>Enjoy...</p>
","4743","<ios><diffie-hellman>","5","0","5","2017-12-12 04:30:53","","1","","","","","2012-01-09 12:55:26",""
"36869631","DHGEX failing with 2048-bit key under Java 8, but succeeding with 1024-bit key","<p>I'm using JSCH 0.1.53 to connect to a remote SSH server, which uses a 1024-bit RSA key.  We are able to connect successfully to the remote server when we also use a 1024-bit RSA key, but when we generated stronger 2048-bit keys we stopped being able to connect.  We got an error message that reads ""prime size must be multiple of 64, and can only range from 512 to 2048"" and that originates from a call to DHGEX.java (Diffie-Hellman Group EXchange).</p>

<p>We're running Java 1.8, and the error message correctly specifies a max bit size of 2048, so the problem is not the JCE key limitation of 1024 bits in Java 1.6 and 1.7.  And we've confirmed that both our private and our public key are in fact 2048 bits, via openssl rsa -text -noout -in id_rsa and ssh-keygen -lf id_rsa.pub.</p>

<p>Since everything looked fine on our end, I started adding debugging lines to the JSCH code and recompiling the JAR, and I was eventually able to determine that the modulus being passed to us during the key exchange was in fact 2047 bits long.  Now, 2047 bits in length doesn't inherently mean that you didn't generate a 2048-bit key or that it's any less strong than a key that actually contains 2048 bits, it just means that you happened to get two primes that multiplied together to something whose first bit was a 0. So it's expected behavior (some of the time) and the JCE check should probably be (n % 64 == 0 || n % 64 == 63).  But JCE is a stickler on the point, so it rejects this key for not being of a length it considers valid.</p>

<p>Based on that, I thought I'd found the problem: the remote server had generated a 2048-bit key that only contained 2047 bits, so they just needed to generate a new one (and keep doing it till they got one that really was 2048 bits).  But when I asked their administrators about it, they were insistent that they were using a 1024-bit key, and indeed that's what you get in the known_hosts file when you SSH over.  So that doesn't appear to be the cause after all.</p>

<p>So I started logging the contents of the buffer that contained what they sent us and pulling out the p and g values (modulus and group), and I discovered that in just a few short periods of testing over a couple of days, there were 33 different modulus values, and all of them differed by only the last few characters when encoded in either base 64 or base 10.  Modulii values were reused, sometimes only once and sometimes a dozen times, but there were lots of distinct values, so the keys are neither generated for one-time use nor generated once and reused forever.</p>

<p>Is this (having the server send many different keys that are very close numerically, with some reuse but many unique values) expected behavior under any conditions, and especially is this expected behavior when the client uses a 2048-bit key but the server uses a 1024-bit key?  I know nothing about Diffie-Hellman group exchange besides what I've read since I started investigating last week, so maybe this is just how it works, but it seems strange to me.</p>

<p>Also, does the SSH standard specify anything about how keys should be generated in cases like these?  I haven't yet found out what SSH server the far side is using (I suspect OpenSSH, but don't know for sure and don't know what version), but I'm hopeful that there might be some standard that forces the use of keys that are of the same size as was requested (between 1^(n-1) and 1^n - 1), and that the remote server might have an option to force this or that I can submit a bug against them to get them to change the behavior.  I'll probably also submit a bug against the JDK to allow keys of n-1 bits, with 0-padding for the first bit.</p>

<p>Any guidance that anyone can give would be greatly appreciated.</p>

<p>I've also posted this question to the JSCH mailing list: <a href=""https://sourceforge.net/p/jsch/mailman/message/35042955/"" rel=""nofollow noreferrer"">https://sourceforge.net/p/jsch/mailman/message/35042955/</a></p>

<p><strong>UPDATE:</strong></p>

<p>After further reading, I believe that Diffie-Hellman's forward secrecy characteristic means that different primes (often from a pre-generated set stored somewhere like /etc/ssl/moduli) would be used for each session (source: <a href=""https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Forward_secrecy"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Forward_secrecy</a>) and that the prime used is not actually the RSA key (source: <a href=""https://stackoverflow.com/a/23346185/1247705"">https://stackoverflow.com/a/23346185/1247705</a>), so the fact that many different p values are seen no longer seems like a concern.  I'm still surprised that they're so close in value, but maybe that's expected as well.</p>

<p>The far side is using Solaris SSH 1.1.4 (which as I understand it is based on OpenSSH) as the SSH daemon.  Is it expected that that daemon would pass 2047-bit primes as part of the Diffie-Hellman key exchange, and is there anything that can be done to get it to send 2048-bit primes instead?</p>
","<p>We fixed similar symptoms with:</p>

<pre><code>Security.insertProviderAt(new BouncyCastleProvider(), 1)
</code></pre>

<p>we were using Jsch 0.1.54 and saw:</p>

<blockquote>
  <p>java.security.InvalidAlgorithmParameterException: DH key size must be multiple of 64, and can only range from 512 to 4096 (inclusive). The specific key size 2047 is not supported</p>
</blockquote>

<p>possibly related is <a href=""https://bugs.openjdk.java.net/browse/JDK-8164963"" rel=""nofollow noreferrer"">JDK-8164963: InvalidAlgorithmParameterException prime size issue after JDK upgrade with JSCH libraries</a></p>
","4723","<java><public-key-encryption><jsch><diffie-hellman>","3","4","2","2017-04-02 03:34:46","","5","1","-1","","2017-05-23 12:32:29","2016-04-26 15:39:31",""
"36869631","DHGEX failing with 2048-bit key under Java 8, but succeeding with 1024-bit key","<p>I'm using JSCH 0.1.53 to connect to a remote SSH server, which uses a 1024-bit RSA key.  We are able to connect successfully to the remote server when we also use a 1024-bit RSA key, but when we generated stronger 2048-bit keys we stopped being able to connect.  We got an error message that reads ""prime size must be multiple of 64, and can only range from 512 to 2048"" and that originates from a call to DHGEX.java (Diffie-Hellman Group EXchange).</p>

<p>We're running Java 1.8, and the error message correctly specifies a max bit size of 2048, so the problem is not the JCE key limitation of 1024 bits in Java 1.6 and 1.7.  And we've confirmed that both our private and our public key are in fact 2048 bits, via openssl rsa -text -noout -in id_rsa and ssh-keygen -lf id_rsa.pub.</p>

<p>Since everything looked fine on our end, I started adding debugging lines to the JSCH code and recompiling the JAR, and I was eventually able to determine that the modulus being passed to us during the key exchange was in fact 2047 bits long.  Now, 2047 bits in length doesn't inherently mean that you didn't generate a 2048-bit key or that it's any less strong than a key that actually contains 2048 bits, it just means that you happened to get two primes that multiplied together to something whose first bit was a 0. So it's expected behavior (some of the time) and the JCE check should probably be (n % 64 == 0 || n % 64 == 63).  But JCE is a stickler on the point, so it rejects this key for not being of a length it considers valid.</p>

<p>Based on that, I thought I'd found the problem: the remote server had generated a 2048-bit key that only contained 2047 bits, so they just needed to generate a new one (and keep doing it till they got one that really was 2048 bits).  But when I asked their administrators about it, they were insistent that they were using a 1024-bit key, and indeed that's what you get in the known_hosts file when you SSH over.  So that doesn't appear to be the cause after all.</p>

<p>So I started logging the contents of the buffer that contained what they sent us and pulling out the p and g values (modulus and group), and I discovered that in just a few short periods of testing over a couple of days, there were 33 different modulus values, and all of them differed by only the last few characters when encoded in either base 64 or base 10.  Modulii values were reused, sometimes only once and sometimes a dozen times, but there were lots of distinct values, so the keys are neither generated for one-time use nor generated once and reused forever.</p>

<p>Is this (having the server send many different keys that are very close numerically, with some reuse but many unique values) expected behavior under any conditions, and especially is this expected behavior when the client uses a 2048-bit key but the server uses a 1024-bit key?  I know nothing about Diffie-Hellman group exchange besides what I've read since I started investigating last week, so maybe this is just how it works, but it seems strange to me.</p>

<p>Also, does the SSH standard specify anything about how keys should be generated in cases like these?  I haven't yet found out what SSH server the far side is using (I suspect OpenSSH, but don't know for sure and don't know what version), but I'm hopeful that there might be some standard that forces the use of keys that are of the same size as was requested (between 1^(n-1) and 1^n - 1), and that the remote server might have an option to force this or that I can submit a bug against them to get them to change the behavior.  I'll probably also submit a bug against the JDK to allow keys of n-1 bits, with 0-padding for the first bit.</p>

<p>Any guidance that anyone can give would be greatly appreciated.</p>

<p>I've also posted this question to the JSCH mailing list: <a href=""https://sourceforge.net/p/jsch/mailman/message/35042955/"" rel=""nofollow noreferrer"">https://sourceforge.net/p/jsch/mailman/message/35042955/</a></p>

<p><strong>UPDATE:</strong></p>

<p>After further reading, I believe that Diffie-Hellman's forward secrecy characteristic means that different primes (often from a pre-generated set stored somewhere like /etc/ssl/moduli) would be used for each session (source: <a href=""https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Forward_secrecy"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Forward_secrecy</a>) and that the prime used is not actually the RSA key (source: <a href=""https://stackoverflow.com/a/23346185/1247705"">https://stackoverflow.com/a/23346185/1247705</a>), so the fact that many different p values are seen no longer seems like a concern.  I'm still surprised that they're so close in value, but maybe that's expected as well.</p>

<p>The far side is using Solaris SSH 1.1.4 (which as I understand it is based on OpenSSH) as the SSH daemon.  Is it expected that that daemon would pass 2047-bit primes as part of the Diffie-Hellman key exchange, and is there anything that can be done to get it to send 2048-bit primes instead?</p>
","<p>I ended up working around this issue by disabling the key-exchange algorithms that used a variant of Diffie-Hellman Group key exchange.  @Brian Low appears to have worked around it by using BouncyCastle instead of the JDK's built-in security provider.</p>

<p>I consider both of those to be workarounds that don't solve the underlying problem (which appears to be a bug in either the JDK for what key sizes they accept or in OpenSSH for what key sizes they generate), but neither I nor my project cared enough to spend time and money trying to force one or the other to take ownership of the issue.</p>
","4723","<java><public-key-encryption><jsch><diffie-hellman>","3","0","2","2017-04-02 03:34:46","","5","1","-1","","2017-05-23 12:32:29","2016-04-26 15:39:31",""
"20505325","How to Export Private Key For ECDiffieHellmanCng","<p>I am trying to export the keys from a new instance of a <em>ECDiffieHellmanCng</em> object so I can create an instance of it later with the same keys. But I am getting an error when trying to export it.</p>

<pre><code>//Create new ECDiffieHellmanCng which automatically creates new keys
var ecdh = new ECDiffieHellmanCng();
//Export the keys
var privateKey = ecdh.Key.Export(CngKeyBlobFormat.EccPrivateBlob);
</code></pre>

<p>I am getting a CryptographicException when I call the <em>Export</em> method with the message ""<strong><em>The requested operation is not supported.</em></strong>""  After putting some breakpoints in the code it looks like it is throwing the exception before even executing the method. Looking at the definition of the Export method it is adorned with a <em>SecuritySafeCriticalAttribute</em> so I am suspicious that this attribute is actually throwing the exception. What is causing this exception? How can I save the keys so I can create an instance of the same ECDiffieHellmanCng object at a later time?</p>
","<p>I believe you are specifying the wrong BLOB format. Try:</p>

<pre><code>var privateKey = ecdh.Key.Export(CngKeyBlobFormat.Pkcs8PrivateBlob);
</code></pre>

<p>If that fails, you need to set up a key policy that allows private key export. See this answer: <a href=""https://stackoverflow.com/a/10274270/2420979"">https://stackoverflow.com/a/10274270/2420979</a> for more details on your problem.</p>
","4683","<c#><security><public-key-encryption><diffie-hellman><cng>","4","1","2","2013-12-13 13:26:41","20505976","0","1","","","","2013-12-10 21:11:36",""
"20505325","How to Export Private Key For ECDiffieHellmanCng","<p>I am trying to export the keys from a new instance of a <em>ECDiffieHellmanCng</em> object so I can create an instance of it later with the same keys. But I am getting an error when trying to export it.</p>

<pre><code>//Create new ECDiffieHellmanCng which automatically creates new keys
var ecdh = new ECDiffieHellmanCng();
//Export the keys
var privateKey = ecdh.Key.Export(CngKeyBlobFormat.EccPrivateBlob);
</code></pre>

<p>I am getting a CryptographicException when I call the <em>Export</em> method with the message ""<strong><em>The requested operation is not supported.</em></strong>""  After putting some breakpoints in the code it looks like it is throwing the exception before even executing the method. Looking at the definition of the Export method it is adorned with a <em>SecuritySafeCriticalAttribute</em> so I am suspicious that this attribute is actually throwing the exception. What is causing this exception? How can I save the keys so I can create an instance of the same ECDiffieHellmanCng object at a later time?</p>
","<p>By default, keys aren't exportable - they are securely stored in the KSP. When creating the key, it needs to be marked allowed for export. Example:</p>

<pre><code>var ecdh = new ECDiffieHellmanCng(CngKey.Create(CngAlgorithm.ECDiffieHellmanP256, null, new CngKeyCreationParameters {ExportPolicy = CngExportPolicies.AllowPlaintextExport}));
//Export the keys
var privateKey = ecdh.Key.Export(CngKeyBlobFormat.EccPrivateBlob);
</code></pre>

<p>To make this simpler, we can just export it from the CngKey directly and not use the algorithm if all you want to do is create a new key and export the private key.</p>

<pre><code>var cngKey = CngKey.Create(CngAlgorithm.ECDiffieHellmanP256, null, new CngKeyCreationParameters {ExportPolicy = CngExportPolicies.AllowPlaintextExport});
var privateKey = cngKey.Export(CngKeyBlobFormat.EccPrivateBlob);
</code></pre>

<p>You can re-create the CngKey from the exported blob by using <code>CngKey.Import(yourBlob, CngKeyBlobFormat.EccPrivateBlob)</code> and passing that to the constructor of ECDiffieHellmanCng.</p>

<hr>

<p>SecuritySafeCriticalAttribute is part of the <a href=""http://msdn.microsoft.com/en-us/library/ee191569%28v=vs.110%29.aspx"" rel=""noreferrer"">.NET Security Transparency model</a>. It is not the source of your errors. </p>
","4683","<c#><security><public-key-encryption><diffie-hellman><cng>","4","11","2","2013-12-13 13:26:41","20505976","0","1","","","","2013-12-10 21:11:36",""
"9483897","1024-bit Diffie-Hellman in C#","<p>So I'm working on a project to interface a C# client with an existing server technology. One of the requirements is a key exchange using Diffie-Hellman.</p>

<p>We have known public P and G and I need to generate a 1024-bit public key to send to the server.</p>

<p>The following is used on the server side in C++ with OpenSSL. Currently I am using the same code in a native DLL called via P/Invoke, and it works as well. I would prefer to eliminate the native DLL dependency if possible.</p>

<pre><code>char publicKey[128];
char P[128]; //this is set to a static 128-byte value, omitting for brevity
unsigned long G = 2;

DH* dh = DH_new();
dh-&gt;p = BN_new();
dh-&gt;g = BN_new();

BN_set_word(dh-&gt;g, G);
BN_bin2bn(P, 128, dh-&gt;p);
if(DH_generate_key(dh))
{
   BN_bn2bin(dh-&gt;pub_key, publicKey);
}
</code></pre>

<p>This generates a 1024-bit public key.</p>

<p>I've tried using the DH classes in BouncyCastle, but for whatever reason I can't get it to give me a 1024-bit key, it wants to give me a 960 bit key instead. Possibly because I don't really know what I'm doing. I couldn't find much in the way of actual explanations of how the classes are supposed to be used.</p>

<p>Is it possible to use BouncyCastle DH classes to work the same as the OpenSSL DH code posted above? If not, is there another C# implementation that would work better?</p>
","<p>Here is a working code example + article on CodeProject with an excellent rating:</p>

<p><a href=""http://www.codeproject.com/Articles/24632/Shared-Key-Generation-using-Diffie-Hellman"" rel=""nofollow"">http://www.codeproject.com/Articles/24632/Shared-Key-Generation-using-Diffie-Hellman</a></p>
","4139","<c#><bouncycastle><diffie-hellman>","5","3","1","2014-01-15 12:44:20","9484092","0","1","","","","2012-02-28 14:39:08",""
"2701294","How does the elliptic-curve version of Diffie-Hellman cryptography work?","<p>Does the Elliptic curve diffie hellman calculation look any different from the standard one defined here:</p>

<pre><code>            /*
             * The basic Diffie-Hellman Key Agreement Equation 
             * 
             * The client initiates
             * A = g^a mod p
             * 
             * Sends (g p A) to the server
             * 
             * The server calculates B
             * B = g^b mod p
             * 
             * Sends B back to client
             * 
             * The client calculates K
             * K = B^a mod p
             * 
             * The server calucaltes K
             * K = A^b mod p
             * 
             */
</code></pre>

<p>Or is it just a specific way of selecting g, a, p and b? How are g,a,p and b selected anyway?</p>
","<p>The basic principle is the same, but the selection of the private key and how the public key are computed are significantly different. In addition, everyone has to agree beforehand on the elliptic curve to use.</p>

<p>As noted, in the elliptic-curve version of Diffie-Hellman, you first decide <em>which</em> elliptic curve you're using. That determines a number of independent parameters called the <em>domain parameters</em>. Without getting too technical, it turns out that some curves are better than others for cryptographic purposes, so the parameters are actually chosen carefully rather than at random. This is somewhat analogous to picking good prime factors.</p>

<p>There are two sets of domain parameters:</p>

<ul>
<li><em>E</em>, the elliptic curve itself.</li>
<li><em>G</em>, a point on <em>E</em> that is called the <em>base point</em>.</li>
</ul>

<p><em>E</em> and <em>G</em> are necessary and sufficient to describe all the information you need.</p>

<p>In ECC-DH, the private key <em>d</em> is computed by taking a randomly selected number on the interval <code>[1, n-1]</code>, where <code>n</code> is the <strong><a href=""http://en.wikipedia.org/wiki/Order_%28group_theory%29"" rel=""noreferrer"">order</a></strong> of <em>G</em>. The public key <em>Q</em> is computed by taking <code>Q = dG</code>. After that the general idea is the same, except that instead of trying to solve a hard <strong><a href=""http://en.wikipedia.org/wiki/Integer_factorization"" rel=""noreferrer"">integer factorization problem</a></strong>, you're trying to solve a hard <strong><a href=""http://en.wikipedia.org/wiki/Discrete_logarithm"" rel=""noreferrer"">discrete logarithm problem</a></strong>.</p>
","3953","<elliptic-curve><diffie-hellman>","3","7","1","2010-04-23 19:51:32","2701449","0","1","75170","","2010-04-23 19:51:32","2010-04-23 19:06:48",""
"10891119","Diffie Hellman key agreement generates different key every time JAVA","<p>I am experiencing a problem with Diffie Hellman implementation. I am using this code 
<a href=""http://www.java2s.com/Tutorial/Java/0490__Security/DiffieHellmanKeyAgreement.htm"" rel=""nofollow"">http://www.java2s.com/Tutorial/Java/0490__Security/DiffieHellmanKeyAgreement.htm</a></p>

<p>It is actually an example from one book I am reading. But I can't understand why <code>generateSecret()</code> creates a different key for every <code>KeyAgreement</code>. I have noticed the function creates different keys even if I call it with the same <code>KeyAgreement</code> twice!
If someone has something to suggest I will be really glad!</p>

<p>Thanks for your time! </p>
","<p>I think the part of the example</p>

<pre><code>private static BigInteger g512 = new BigInteger(""1234567890"", 16);
private static BigInteger p512 = new BigInteger(""1234567890"", 16);
</code></pre>

<p>is completely bogus.  <code>p</code> needs to be prime and <code>g</code>needs to be a generator.  When I try running the example I get an exception.
<a href=""http://www.exampledepot.com/egs/javax.crypto/KeyAgree.html"" rel=""nofollow"">This</a> seems to be a more reasonable example (but I haven't tested it myself yet).</p>

<p>Basically the interesting input to the DH exchange is that (<code>p,g</code>) pair which needs to be generated and must have some unique properties.  Clearly, the example above shows just place holder values which will not produce a correctly functioning algorithm (<code>p</code> can not be equal to <code>g</code> and <code>p</code> should be prime, while in the example it is clearly divisible by 10).  The example I linked to shows how to use the libraries to generate a correct (<code>p, g</code>) pair. </p>

<p>It is also worth noting that DH parameter generation is usually a separate step from generating the secret key.  While DH parameters are somewhat private, they are not as sensitive as your private key and can be generated once and then reused.</p>

<p><strong>(Edit: <a href=""http://www.exampledepot.com/egs/javax.crypto/GenDhParams.html"" rel=""nofollow"">Example</a>)</strong></p>

<pre><code>AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator.getInstance(""DH"");
paramGen.init(512); // number of bits
AlgorithmParameters params = paramGen.generateParameters();
DHParameterSpec dhSpec = params.getParameterSpec(DHParameterSpec.class);

BigInteger p512 = dhSpec.getP();
BigInteger g512 = dhSpec.getG();
int l = dhSpec.getL();
...
</code></pre>
","3933","<java><bouncycastle><diffie-hellman>","1","6","1","2016-02-08 10:37:18","","3","2","104223","","2012-06-06 03:47:42","2012-06-05 03:17:05",""
"4767125","SSL key exchange encryption techniques","<p>what are the differences between the three key exchange algortihms namely Anonymous DH, Ephermal DH and fixed DH?</p>
","<p>From <a href=""http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_1-1/ssl.html"" rel=""noreferrer"">Cisco's docs</a>:</p>

<blockquote>
  <p>Fixed Diffie-Hellman: 
  This a Diffie-Hellman key exchange in which
  the server's certificate contains the
  Diffie-Hellman public parameters
  signed by the certificate authority
  (CA). That is, the public-key
  certificate contains the
  Diffie-Hellman public-key parameters.
  The client provides its Diffie-Hellman
  public key parameters either in a
  certificate, if client authentication
  is required, or in a key exchange
  message. This method results in a
  fixed secret key between two peers,
  based on the Diffie-Hellman
  calculation using the fixed public
  keys.</p>
  
  <p>Ephemeral Diffie-Hellman: 
  This technique is used to create ephemeral
  (temporary, one-time) secret keys. In
  this case, the Diffie-Hellman public
  keys are exchanged, and signed using
  the sender's private RSA or DSS key.
  The receiver can use the corresponding
  public key to verify the signature.
  Certificates are used to authenticate
  the public keys. This option appears
  to be the most secure of the three
  Diffie-Hellman options because it
  results in a temporary, authenticated
  key.</p>
  
  <p>Anonymous Diffie-Hellman: 
  The base Diffie-Hellman algorithm is used, with
  no authentication. That is, each side
  sends its public Diffie-Hellman
  parameters to the other, with no
  authentication. This approach is
  vulnerable to man-in-the-middle
  attacks, in which the attacker
  conducts anonymous Diffie-Hellman
  exchanges with both parties.</p>
</blockquote>
","3896","<security><encryption><ssl><diffie-hellman>","4","9","1","2011-08-05 21:57:06","","1","1","600500","","2011-08-05 21:57:06","2011-01-22 09:33:07","2011-08-05 22:01:55"
"6003705","C++ tutorial on Diffie Hellman","<p>Is there a C++ tutorial for Diffie Hellman key exchange using OpenSSL? I keep searching and I can't find anything. If you know of a tutorial, I would be grateful for a link to it.  Thank you.</p>
","","3853","<c++><diffie-hellman>","4","","0","2011-10-26 06:36:49","","1","2","733798","","2011-06-22 04:49:31","2011-05-14 17:46:59","2014-08-07 15:02:30"
"27773086","How to decrypt HTTPS (ECDHE) data?","<p>I am trying to understand how exactly HTTPS works and doing a little practical tests.</p>

<p>I have a data captured from HTTPS communication encrypted by TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA.</p>

<p>If I understood it right, client during the TLS handshake creates a master key, which is then encrypted using server's public key and sent to server. This master key (as a plain text) is then used as a symmetric key for encrypting ongoing communication. Is this correct?</p>

<p>If yes, how to decrypt the data, if I know the master key?</p>

<p>It sounded pretty easy to me at first, so I just wrote this script</p>

<pre><code>$masterKey = '8ef36f0eb2c10ea6142693374f6c5c7ae65eee5f6bd45bd1990b08e6c144227382726496b795d62284bd8c6c0cadbbdb';

$someRandomEncryptedData = '170303001D314A69C7DF95E07AAF51FBDA01C178D45330BC902308DF8C418FA5B02B';

$sDecrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, pack('H*', $masterKey), pack('H*', $someRandomEncryptedData), MCRYPT_MODE_CBC);

echo $sDecrypted;
</code></pre>

<p>Then I notice that master key is 96 byte long (48 as binary string), which results to PHP warning as the key should be 256 bit (32 byte) long. Am I missing something?</p>
","<blockquote>
  <p>client during the request creates a master key, which is then encrypted using server's public key and sent to server. This master key (as a plain text) is then used as a symmetric key for encrypting ongoing communication. Is this correct?</p>
</blockquote>

<p>Well, all-in-all, No.</p>

<p>Because you are asking about DH and ECDH, which are Key Agreement protocols: the client does <strong><em>not</em></strong> generate a random key, encrypt it under the server's public key and then send it to the server. That's Key Transport (like RSA Key Transport), and <strong><em>not</em></strong> DH or ECDH. Key transport is going away in TLS 1.3.</p>

<p>There are two phases to TLS: key agreement and bulk transfer. The phases are not as well defined as in IPSec. When the client and server use DH or ECDH, they arrive at a <code>premaster_secret</code>. That's the shared secret drops out of Diffie-Hellman or Elliptic Curve  Diffie-Hellman.</p>

<p>They take the <code>premaster_secret</code>, they add a client random, a server random, and arrive at a <code>master_secret</code>. Then they take the <code>master_secret</code> and derive 6 symmetric keys from it:</p>

<ul>
<li>Client initial IV</li>
<li>Client encryption key</li>
<li>Client mac key</li>
<li>Server initial IV</li>
<li>Server encryption key</li>
<li>Server mac key</li>
</ul>

<p>Those keys are used to key a block or stream cipher.</p>

<p>If you notice, each side contributes to the <code>premaster_secret</code> - the client contributes <code>g^a</code> and the server contributes <code>g^b</code>. Then each side contributes to the <code>master_secret</code> through nonces - the client random and the server random.</p>

<p>The reason there's two contributions from both sides is transport schemes, like RSA Key Transport, don't allow the server to contribute to the <code>premaster_secret</code>. The server has to wait until the derivation of the <code>master_secret</code> to contribute to the key material via a nonce.</p>

<p>So the progression is <code>premaster_secret</code> to <code>master_secret</code> to 6 session keys. I'm not sure where the master key is...</p>

<hr>

<blockquote>
  <p>If yes, how to decrypt the data, if I know the master key?</p>
</blockquote>

<p>I think its usually easier to just plug it into Wireshark if you have the master key. The Wireshark wiki talks about a master key (though I don't know what it is - there's a <code>premaster_secret</code> and <code>master_secret</code>). See the Wireshark wiki for <a href=""http://wiki.wireshark.org/SSL"" rel=""nofollow"">Secure Socket Layer (SSL)</a>.</p>

<hr>

<blockquote>
  <p>It sounded pretty easy to me at first, so I just wrote this script</p>
</blockquote>

<p>Yeah... :) Check out RFC 5246. That's <a href=""https://tools.ietf.org/html/rfc5246"" rel=""nofollow"">Transport Layer Security (TLS) Protocol Version 1.2</a>. Then let's talk about easy :)</p>

<hr>

<blockquote>
  <p>Then I notice that master key is 96 byte long (48 as binary string)</p>
</blockquote>

<p>96 bytes is the output of the PseudoRandom Function (PRF). Check out RFC 5246, page 13.</p>
","3829","<php><encryption><https><elliptic-curve><diffie-hellman>","5","3","1","2015-01-05 04:21:03","27773283","0","1","1322616","","2015-01-05 03:56:29","2015-01-05 03:38:37",""
"19714334","java.security.NoSuchProviderException: JCE cannot authenticate the provider BC in servelets","<p>I am implementing Elliptic Curve Diffie Hellman using bouncy castle. I am using <code>bcprov-jdk15on-149.jar</code>. But</p>

<blockquote>
  <p>java.security.NoSuchProviderException: JCE cannot authenticate the
  provider BC</p>
</blockquote>

<p>exception is thrown. It happens in the following line <code>KeyAgreement.getInstance(""ECDHC"", ""BC"");</code></p>

<pre><code>KeyAgreement aKeyAgree = null;
try {
     //exception occur here
     aKeyAgree = KeyAgreement.getInstance(""ECDHC"", ""BC"");
}
</code></pre>

<p>The exception is</p>

<blockquote>
  <p>java.security.NoSuchProviderException: JCE cannot authenticate the
  provider BC   at
  javax.crypto.JceSecurity.getInstance(JceSecurity.java:101)    at
  javax.crypto.KeyAgreement.getInstance(KeyAgreement.java:223)</p>
</blockquote>

<p>I added the Bouncy castle provider to the java.security file in the JRE. But it did not help. I want to know the solution for this situation. <br>
Also this problem only occurs with servelets. I tested with a J2SE project and the code works fine. Exception is thrown only when I put this in a servelet.</p>
","<p>So, possible reasons: </p>

<ol>
<li>You repacked bcprovider.jar in some way, for example, with maven shade plugin. It made invalid BC signature.</li>
<li>You added/removed BC provider more then once. For example: <a href=""https://stackoverflow.com/questions/6932681/how-do-i-get-javax-crypto-classes-such-as-javax-crypto-cipher-to-work-on-a-servl"">How do I get javax.crypto classes such as javax.crypto.Cipher to work on a servlet with jboss?</a></li>
<li>Your jre installation or some jars US_export_policy.jar, local_policy.jar is corrupted or has invalid signature. Try to make some crypto operation with different provider to check this. For example, create 2K RSA key.</li>
<li>Problem with export JCE restrictions: download and install UnlimitedJCEPolicy <a href=""https://edelivery.oracle.com/otn-pub/java/jce/7/UnlimitedJCEPolicyJDK7.zip"" rel=""nofollow noreferrer"">https://edelivery.oracle.com/otn-pub/java/jce/7/UnlimitedJCEPolicyJDK7.zip</a></li>
</ol>
","3786","<java><diffie-hellman>","0","1","1","2013-11-01 07:14:58","","4","1","1035054","","2013-11-01 07:14:58","2013-10-31 16:04:59",""
"2904292","diffie-hellman ssh keyxchange","<p>I've set out to make a primitive SSH client in C#; you might remember me from posts such as <a href=""https://stackoverflow.com/questions/2872279/c-primitive-ssh-connection-lowlevel"">primitive ssh connection (lowlevel)</a> hehe.</p>

<p>Anyway, things are great up until the time when I initiate a DH key exchange.
I've compared the traffic when I establish a ssh connection (from openssh client to openssh server), to the traffic when my client connects to the same openssh server.</p>

<p>OpenSSH client -> OpenSSH server (S for server, C for client):
S: SSH-2.0-OpenSSH_5.1p1 Debian-6ubuntu2\r (saying hello)
C: SSH-2.0-OpenSSH_5.2\r (introducing myself)
C: Key Exchange Init (0x14 = 20)
S: Key Exchange Init
C: Diffie-Hellman GEX Request (0x22 = 34) (with DH GEX min, number of bits and max)
S: Diffie-Hellman Key Exchange Reply (with P, G, etc.)
C: Diffie-Hellman GEX Init
S: Diffie-Hellman GEX Reply</p>

<p>My client -> OpenSSH server:
S: SSH-2.0-OpenSSH_5.1p1 Debian-6ubuntu2\r (saying hello)
C: SSH-2.0-Some_Name\r (introducing myself)
C: Key Exchange Init (0x14 = 20)
S: Key Exchange Init
C: Diffie-Hellman GEX Request (0x22 = 34) (with DH GEX min, number of bits and max)</p>

<p>and then a bogus TCP packet as reply (probably the server connection has been terminated after/upon GEX Request.</p>

<p>I have yet to use AES128 (which I think is the encryption chosen, but I'm not sure how to verify this...), and I'm still sending in a non-compressed format, looking to get the P, G etc. values to make the DH calculations.</p>

<p>So where I'm stranded is:
RFC 4419 page 3 <a href=""http://www.ietf.org/rfc/rfc4419.txt"" rel=""nofollow noreferrer"">http://www.ietf.org/rfc/rfc4419.txt</a>
I've send SSH_MSG_KEY_DH_GEX_REQUEST, but the server does not respond SSH_MSG_KEX_DH_GEX_GROUP.</p>

<p>Can anyone give me a little advice on what I'm not understanding here? Does the server not understand my GEX request (due to it expecting encryption, or?)?</p>

<p>Any help is very much appreciated, thanks :)</p>
","<p>I'm pretty sure the problem is that after the key exchange init, the keys aren't being taking into (correct) use.</p>
","3768","<ssh><rfc><diffie-hellman>","3","0","2","2010-05-25 12:41:12","","0","","-1","","2017-05-23 12:30:45","2010-05-25 11:56:36",""
"2904292","diffie-hellman ssh keyxchange","<p>I've set out to make a primitive SSH client in C#; you might remember me from posts such as <a href=""https://stackoverflow.com/questions/2872279/c-primitive-ssh-connection-lowlevel"">primitive ssh connection (lowlevel)</a> hehe.</p>

<p>Anyway, things are great up until the time when I initiate a DH key exchange.
I've compared the traffic when I establish a ssh connection (from openssh client to openssh server), to the traffic when my client connects to the same openssh server.</p>

<p>OpenSSH client -> OpenSSH server (S for server, C for client):
S: SSH-2.0-OpenSSH_5.1p1 Debian-6ubuntu2\r (saying hello)
C: SSH-2.0-OpenSSH_5.2\r (introducing myself)
C: Key Exchange Init (0x14 = 20)
S: Key Exchange Init
C: Diffie-Hellman GEX Request (0x22 = 34) (with DH GEX min, number of bits and max)
S: Diffie-Hellman Key Exchange Reply (with P, G, etc.)
C: Diffie-Hellman GEX Init
S: Diffie-Hellman GEX Reply</p>

<p>My client -> OpenSSH server:
S: SSH-2.0-OpenSSH_5.1p1 Debian-6ubuntu2\r (saying hello)
C: SSH-2.0-Some_Name\r (introducing myself)
C: Key Exchange Init (0x14 = 20)
S: Key Exchange Init
C: Diffie-Hellman GEX Request (0x22 = 34) (with DH GEX min, number of bits and max)</p>

<p>and then a bogus TCP packet as reply (probably the server connection has been terminated after/upon GEX Request.</p>

<p>I have yet to use AES128 (which I think is the encryption chosen, but I'm not sure how to verify this...), and I'm still sending in a non-compressed format, looking to get the P, G etc. values to make the DH calculations.</p>

<p>So where I'm stranded is:
RFC 4419 page 3 <a href=""http://www.ietf.org/rfc/rfc4419.txt"" rel=""nofollow noreferrer"">http://www.ietf.org/rfc/rfc4419.txt</a>
I've send SSH_MSG_KEY_DH_GEX_REQUEST, but the server does not respond SSH_MSG_KEX_DH_GEX_GROUP.</p>

<p>Can anyone give me a little advice on what I'm not understanding here? Does the server not understand my GEX request (due to it expecting encryption, or?)?</p>

<p>Any help is very much appreciated, thanks :)</p>
","<p>My best guess would be that the key exchange are mutually exclusive, i.e. the openssh server does not have the algorithm that the client is looking for <strong>or</strong> the client does not have the algorithm to exchange with the openssh server. You could verify it by running wireshark on the putty to openssh server and monitor the exchanges and compare it with your own client. </p>

<p>I would gauge a guess that is how putty works, if the exchange fails, fall back to another algorithm after 'querying the openssh server' for the algorithm it uses... since putty is open source, it might be worth your while to look at the code to see how putty accomplishes it.</p>
","3768","<ssh><rfc><diffie-hellman>","3","0","2","2010-05-25 12:41:12","","0","","-1","","2017-05-23 12:30:45","2010-05-25 11:56:36",""
"19890075","Diffie-Hellman Method in C# not working","<p>So, after all, i want to explain the method:</p>

<p>The ideia is to two persons exchange one value through a public channel of comunication without really sending it.</p>

<p>This is how this works:</p>

<p><a href=""https://en.wikipedia.org/wiki/Diffie-Hellman"" rel=""nofollow"">https://en.wikipedia.org/wiki/Diffie-Hellman</a></p>

<hr>

<p>This is my C# code:</p>

<pre><code>    double primemodulus = 251;
    double generator = 11;

    public string TestarGamaValores()
    {
        Random R = new Random();
        double Alice = R.Next(1, 100); //alice exp
        double AliceCalculado = DefaultMod(Alice);

        double Bob = R.Next(1, 100); //bob exp
        double BobCalculado = DefaultMod(Bob);

        //Trocar os calculados entre eles

        double ChaveFinalAlice = CalcularAposTroca(Alice, BobCalculado);
        double ChaveFinalBob = CalcularAposTroca(Bob, AliceCalculado);

        return (""Chave Final Alice: "" + ChaveFinalAlice + "" Chave Final Bob: "" + ChaveFinalBob);
    }
                  //Calculate after exchange
    public double CalcularAposTroca(double MyExp, double HisResultFromHisModulus)
    {
        double genrt = Math.Pow(HisResultFromHisModulus, MyExp);
        double Chave = genrt % primemodulus;
        return Chave;
    }

    public double DefaultMod(double MyExp)
    {
        double genrt = Math.Pow(generator, MyExp);
        double Chave = genrt % primemodulus;
        return Chave;
    }
</code></pre>

<p>the only problem is, i cant get the values to be the same.
ive reaserched if the formula is ok, and i think i didnt get it wrong, but the C# code seems not to be agreeing.</p>

<p>the results are indeed between 0 and 251 but are always different.</p>

<p>so what am i doing wrong?</p>

<p>is the C# code ok?</p>
","<p>I think your problem is that you are using double instead of long (integer values), since doubles are stored only as approximations to the real number you might get rounding errors. See also this post <a href=""https://stackoverflow.com/questions/906564/why-is-modulus-operator-not-working-for-double-in-c"">Why is modulus operator not working for double in c#?</a></p>

<p>If you are dealing with larger values you will have to use a Structure with arbitrary size like <code>BigInteger</code>.</p>
","3563","<c#><public-key-encryption><diffie-hellman>","0","2","3","2014-11-20 23:30:32","19890110","0","","","","","2013-11-10 13:09:42",""
"19890075","Diffie-Hellman Method in C# not working","<p>So, after all, i want to explain the method:</p>

<p>The ideia is to two persons exchange one value through a public channel of comunication without really sending it.</p>

<p>This is how this works:</p>

<p><a href=""https://en.wikipedia.org/wiki/Diffie-Hellman"" rel=""nofollow"">https://en.wikipedia.org/wiki/Diffie-Hellman</a></p>

<hr>

<p>This is my C# code:</p>

<pre><code>    double primemodulus = 251;
    double generator = 11;

    public string TestarGamaValores()
    {
        Random R = new Random();
        double Alice = R.Next(1, 100); //alice exp
        double AliceCalculado = DefaultMod(Alice);

        double Bob = R.Next(1, 100); //bob exp
        double BobCalculado = DefaultMod(Bob);

        //Trocar os calculados entre eles

        double ChaveFinalAlice = CalcularAposTroca(Alice, BobCalculado);
        double ChaveFinalBob = CalcularAposTroca(Bob, AliceCalculado);

        return (""Chave Final Alice: "" + ChaveFinalAlice + "" Chave Final Bob: "" + ChaveFinalBob);
    }
                  //Calculate after exchange
    public double CalcularAposTroca(double MyExp, double HisResultFromHisModulus)
    {
        double genrt = Math.Pow(HisResultFromHisModulus, MyExp);
        double Chave = genrt % primemodulus;
        return Chave;
    }

    public double DefaultMod(double MyExp)
    {
        double genrt = Math.Pow(generator, MyExp);
        double Chave = genrt % primemodulus;
        return Chave;
    }
</code></pre>

<p>the only problem is, i cant get the values to be the same.
ive reaserched if the formula is ok, and i think i didnt get it wrong, but the C# code seems not to be agreeing.</p>

<p>the results are indeed between 0 and 251 but are always different.</p>

<p>so what am i doing wrong?</p>

<p>is the C# code ok?</p>
","<p>you are using <code>double</code> which is a floating point number for something that is mathematicaly not defined for floating point numbers ... the modulo operator ...</p>

<p>i suggest using arbitrary precision integers like <code>BigInteger</code></p>
","3563","<c#><public-key-encryption><diffie-hellman>","0","2","3","2014-11-20 23:30:32","19890110","0","","","","","2013-11-10 13:09:42",""
"19890075","Diffie-Hellman Method in C# not working","<p>So, after all, i want to explain the method:</p>

<p>The ideia is to two persons exchange one value through a public channel of comunication without really sending it.</p>

<p>This is how this works:</p>

<p><a href=""https://en.wikipedia.org/wiki/Diffie-Hellman"" rel=""nofollow"">https://en.wikipedia.org/wiki/Diffie-Hellman</a></p>

<hr>

<p>This is my C# code:</p>

<pre><code>    double primemodulus = 251;
    double generator = 11;

    public string TestarGamaValores()
    {
        Random R = new Random();
        double Alice = R.Next(1, 100); //alice exp
        double AliceCalculado = DefaultMod(Alice);

        double Bob = R.Next(1, 100); //bob exp
        double BobCalculado = DefaultMod(Bob);

        //Trocar os calculados entre eles

        double ChaveFinalAlice = CalcularAposTroca(Alice, BobCalculado);
        double ChaveFinalBob = CalcularAposTroca(Bob, AliceCalculado);

        return (""Chave Final Alice: "" + ChaveFinalAlice + "" Chave Final Bob: "" + ChaveFinalBob);
    }
                  //Calculate after exchange
    public double CalcularAposTroca(double MyExp, double HisResultFromHisModulus)
    {
        double genrt = Math.Pow(HisResultFromHisModulus, MyExp);
        double Chave = genrt % primemodulus;
        return Chave;
    }

    public double DefaultMod(double MyExp)
    {
        double genrt = Math.Pow(generator, MyExp);
        double Chave = genrt % primemodulus;
        return Chave;
    }
</code></pre>

<p>the only problem is, i cant get the values to be the same.
ive reaserched if the formula is ok, and i think i didnt get it wrong, but the C# code seems not to be agreeing.</p>

<p>the results are indeed between 0 and 251 but are always different.</p>

<p>so what am i doing wrong?</p>

<p>is the C# code ok?</p>
","<p>I appreciate that You are going to implement the Diffie-Hellman algorithm idea, but for everyone who are looking for a solution I can tell that there is no need to discover the circle again.</p>

<p>The Diffie-Hellman secret key exchange protocol is already implemented here:</p>

<pre><code>System.Security.Cryptography.ECDiffieHellmanCng 
</code></pre>

<p>and there is a link to great example of usage:
<a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.ecdiffiehellmancng(v=vs.110).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/system.security.cryptography.ecdiffiehellmancng(v=vs.110).aspx</a></p>

<p>Pay attention to measure the performance of the solution in Your environment before deploy. Process of generation PublicKey takes up to 40ms on my Intel Core I5. :-(</p>
","3563","<c#><public-key-encryption><diffie-hellman>","0","1","3","2014-11-20 23:30:32","19890110","0","","","","","2013-11-10 13:09:42",""
"2823881","How To Generate Parameter Set for the Diffie-Hellman Key Agreement Algorithm in Android","<p>I am working on mobile/server security related project. I am now stuck in generating a Diffie-Hellman key agreement part. It works fine in server side program but it is not working in mobile side. Thus, I assume that it is not compactible with Android.</p>

<p>I used the following class to get the parameters. It returns a comma-separated string of 3 values. The first number is the prime modulus P. The second number is the base generator G. The third number is bit size of the random exponent L.  </p>

<p><em>My question is is there anything wrong with the code or it is not compactible for android?What kind of changes should I do?</em><br>
Your suggestion and guidance would be very much help for me. Thanks a lot in advance.</p>

<pre><code>public static String genDhParams() {
 try {
// Create the parameter generator for a 1024-bit DH key pair
AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator.getInstance(""DH"");
paramGen.init(1024);
// Generate the parameters
AlgorithmParameters params = paramGen.generateParameters();
DHParameterSpec dhSpec = (DHParameterSpec)params.getParameterSpec(DHParameterSpec.class);
// Return the three values in a string
return """"+dhSpec.getP()+"",""+dhSpec.getG()+"",""+dhSpec.getL();
} catch (NoSuchAlgorithmException e) {
} catch (InvalidParameterSpecException e) {
}
return null;
}
</code></pre>

<p>Regards,<br>
<em>Sebby</em></p>
","<p>As revealed by <a href=""https://stackoverflow.com/questions/2469235/dh-keypair-generation-time-on-android"">this question</a> DH parameter generation is incredibly slow on Android.  (That asker thought the culprit was generating a <code>new SecureRandom()</code>, but I find the slowness in <code>DHParametersGenerator.generateParameters()</code>, specifically its call to <code>java.math.BigInt.generatePrimeDefault()</code>.)  </p>

<p>Moreover, that asker shows how to use pre-generated parameters.  The parameters can be fixed, and the key pair generator will still generate a new keypair each time.</p>
","3362","<java><android><diffie-hellman>","0","0","1","2011-02-04 18:44:48","","5","2","290167","","2010-05-13 01:36:50","2010-05-13 01:14:01",""
"2469235","DH Keypair generation time on Android","<p>This is the code that I'm using to generate a DH keypair:</p>

<pre><code>KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"");
keyGen.initialize(1024, new SecureRandom());
KeyPair ackp = keyGen.generateKeyPair();
</code></pre>

<p>(without the needed try/catch, of course).</p>

<p>I've done some tests running such code iteratively and varying the key size (in particular ramping up from 128 with a 128 step up to 1024. 1024 would be the desired size.</p>

<p>First of all, running each size generation 10 times to have some minimal std deviation on the results gives HIGH fluctuation of results, on average, anyway, the time needed for creating the keys (<strong>1024 bit</strong>) is: 683027ms, which rounds up to around <strong>11 minutes</strong> for creating a key.</p>

<p>The questions are: </p>

<ol>
<li>Is anyone else getting the same results? </li>
<li>Is there some optimization to be run in order to achieve lower times?</li>
<li>What is the high fluctuation dependent of? (i.e. for generating a 1024bit key it can take from 18 seconds to 30 minutes...)</li>
</ol>

<p>Tests have been run on a Nexus-One phone</p>

<p>Thanks in advance for shedding some light on the ""issue""</p>

<p>Regards</p>
","<p>I did some further coding/research and apparently the call that's the most time (battery?) consuming is:</p>

<pre><code>new SecureRandom()
</code></pre>

<p>In particular, though, since for DH the parameters (g, p, l) can be pre-computed and hard-coded it's a wise suggestion to do so beforehand and use the generated values to generate the key pair (which will be almost instantaneous).</p>

<p>Example code:</p>

<pre><code>KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"");
keyGen.initialize(new DHParameterSpec(p, g, l));
KeyPair ackp = keyGen.generateKeyPair();
</code></pre>

<p>Where p, g, and l are:</p>

<pre><code>final BigInteger p = new BigInteger(""X"");
final BigInteger g = new BigInteger(""Y"");
final int l = 1023;
</code></pre>

<p>And X and Y can be generated offline with:</p>

<pre><code>AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator.getInstance(""DH"");
paramGen.init(1024, new SecureRandom());
AlgorithmParameters params = paramGen.generateParameters();
DHParameterSpec dhSpec = (DHParameterSpec)params.getParameterSpec(DHParameterSpec.class);
System.out.println(""p: "" + dhSpec.getP() + ""\ng: "" + dhSpec.getG() + "" \nl: "" + dhSpec.getL());
</code></pre>
","3259","<android><time><nexus-one><diffie-hellman>","3","7","1","2010-10-26 09:32:33","2510173","0","6","","","","2010-03-18 11:01:56",""
"19605954","Getting ECPoint/ECPublicKeyParameters from byte[] in Bouncy Castle","<p>So far I've managed to generate a ECDHE pair in bouncy castle's lightweight API. However I have issues trying to recreate the public key from an byte[].</p>

<p>Since the ECPublicKeyParameters object only has one method getQ() I am assuming thats all that is required to reconstruct the key. The other parameters such as the curve used (P-521) are kept constant.</p>

<p>I am doing the following:</p>

<pre><code>AsymmetricCipherKeyPair kp = kpgen.generateKeyPair(); //ECDHE Key Generator

ECPublicKeyParameters pubKey = (ECPublicKeyParameters)kp.getPublic();
byte[] aPubKeybytes = pubKey.getQ().getEncoded(false); //Should I set to true or false?
</code></pre>

<p>Unless there is another way to get the raw bytes of the public key pubKey, I don't see a way to get the bytes without invoking method getQ() which returns an ECPoint object.</p>

<p>My question is how to reconstruct the byte[] into a ECPoint object using bouncy castle's lightweight API. Or, better yet, how to reconstruct the whole ECPublicKeyParameter object using an byte array somehow derived from the original pubKey object.</p>
","<p>To whomever it may concern I resolved this issue by using the PublicKeyFactory and SubjectPublicKeyInfoFactory to encode and decode the key.</p>

<p>Using:</p>

<pre><code>byte[] key = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(pubKey).getEncoded();
</code></pre>

<p>I was able to get the raw bytes of the key.</p>

<p>and using:</p>

<pre><code>ECPublicKeyParameters bpubKey = (ECPublicKeyParameters)PublicKeyFactory.createKey(key);
</code></pre>

<p>I was able to recreate the public key.</p>
","3157","<java><bouncycastle><public-key-encryption><elliptic-curve><diffie-hellman>","3","8","1","2013-12-05 21:31:29","19614887","0","","","","","2013-10-26 11:06:49",""
"27440450","javax.net.ssl.SSLException: java.lang.RuntimeException: Could not generate DH keypair","<p>I am getting below error while hitting HTTPS URL with Java code develoed in JDK1.6</p>

<pre><code>    javax.net.ssl.SSLException: java.lang.RuntimeException: Could not generate DH keypair
        at com.sun.net.ssl.internal.ssl.Alerts.getSSLException(Alerts.java:190)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1649)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1612)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1595)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1172)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1149)
        at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:434)
    at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:166)
    at sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1019)
    at 
sun.net.www.protocol.https.HttpsURLConnectionImpl.getOutputStream(HttpsURLConnectionImpl.java:230)
        at testHTTP.main(testHTTP.java:70)
Caused by: java.lang.RuntimeException: Could not generate DH keypair
        at com.sun.net.ssl.internal.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:106)
        at com.sun.net.ssl.internal.ssl.ClientHandshaker.serverKeyExchange(ClientHandshaker.java:556)
        at com.sun.net.ssl.internal.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:183)
        at com.sun.net.ssl.internal.ssl.Handshaker.processLoop(Handshaker.java:593)
        at com.sun.net.ssl.internal.ssl.Handshaker.process_record(Handshaker.java:529)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:893)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1138)
        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1165)
        ... 6 more
Caused by: java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 1024 (inclusive)
        at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DashoA13*..)
        at java.security.KeyPairGenerator$Delegate.initialize(KeyPairGenerator.java:627)
        at com.sun.net.ssl.internal.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:100)
        ... 13 more
</code></pre>

<p><br/><br/>
What should be done in this case if I want to use JDK1.6 only..
<br/><br/>
Please suggest</p>
","<p>When I have started using Java7, my issue was resolved but DH issue couldn't work with Java6</p>
","2945","<java><url><ssl><jdk1.6><diffie-hellman>","0","0","1","2014-12-24 10:27:18","","0","","","","","2014-12-12 09:24:27",""
"14230096","Java security init Cipher from SecretKeySpec properly","<p>I'm testing Diffie-Hellman KeyAgreement Algorithm. And use it to generate a secret key. But after I get the <code>SecretKeySpec</code>, I'm confronted with problem about using it to initialize a <code>Cipher</code>. Here's my code:<br></p>

<h2>DiffieHellmanModule</h2>

<pre><code>package ggicci.infosec;

import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;

import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Diffie-Hellman module for demonstrating KeyAgreement Algorithm
 * @author Ggicci
 * @since 2013.01.09
 */
public class DiffieHellmanModule {
    private static final byte[] skip1024ModulusBytes = { (byte) 0xF4,
            (byte) 0x88, (byte) 0xFD, (byte) 0x58, (byte) 0x4E, (byte) 0x49,
            (byte) 0xDB, (byte) 0xCD, (byte) 0x20, (byte) 0xB4, (byte) 0x9D,
            (byte) 0xE4, (byte) 0x91, (byte) 0x07, (byte) 0x36, (byte) 0x6B,
            (byte) 0x33, (byte) 0x6C, (byte) 0x38, (byte) 0x0D, (byte) 0x45,
            (byte) 0x1D, (byte) 0x0F, (byte) 0x7C, (byte) 0x88, (byte) 0xB3,
            (byte) 0x1C, (byte) 0x7C, (byte) 0x5B, (byte) 0x2D, (byte) 0x8E,
            (byte) 0xF6, (byte) 0xF3, (byte) 0xC9, (byte) 0x23, (byte) 0xC0,
            (byte) 0x43, (byte) 0xF0, (byte) 0xA5, (byte) 0x5B, (byte) 0x18,
            (byte) 0x8D, (byte) 0x8E, (byte) 0xBB, (byte) 0x55, (byte) 0x8C,
            (byte) 0xB8, (byte) 0x5D, (byte) 0x38, (byte) 0xD3, (byte) 0x34,
            (byte) 0xFD, (byte) 0x7C, (byte) 0x17, (byte) 0x57, (byte) 0x43,
            (byte) 0xA3, (byte) 0x1D, (byte) 0x18, (byte) 0x6C, (byte) 0xDE,
            (byte) 0x33, (byte) 0x21, (byte) 0x2C, (byte) 0xB5, (byte) 0x2A,
            (byte) 0xFF, (byte) 0x3C, (byte) 0xE1, (byte) 0xB1, (byte) 0x29,
            (byte) 0x40, (byte) 0x18, (byte) 0x11, (byte) 0x8D, (byte) 0x7C,
            (byte) 0x84, (byte) 0xA7, (byte) 0x0A, (byte) 0x72, (byte) 0xD6,
            (byte) 0x86, (byte) 0xC4, (byte) 0x03, (byte) 0x19, (byte) 0xC8,
            (byte) 0x07, (byte) 0x29, (byte) 0x7A, (byte) 0xCA, (byte) 0x95,
            (byte) 0x0C, (byte) 0xD9, (byte) 0x96, (byte) 0x9F, (byte) 0xAB,
            (byte) 0xD0, (byte) 0x0A, (byte) 0x50, (byte) 0x9B, (byte) 0x02,
            (byte) 0x46, (byte) 0xD3, (byte) 0x08, (byte) 0x3D, (byte) 0x66,
            (byte) 0xA4, (byte) 0x5D, (byte) 0x41, (byte) 0x9F, (byte) 0x9C,
            (byte) 0x7C, (byte) 0xBD, (byte) 0x89, (byte) 0x4B, (byte) 0x22,
            (byte) 0x19, (byte) 0x26, (byte) 0xBA, (byte) 0xAB, (byte) 0xA2,
            (byte) 0x5E, (byte) 0xC3, (byte) 0x55, (byte) 0xE9, (byte) 0x2F,
            (byte) 0x78, (byte) 0xC7 };
    private static final BigInteger skip1024Modulus;
    private static final BigInteger skip1024Base;
    private static KeyPairGenerator kpg;
    static {
        skip1024Modulus = new BigInteger(1, skip1024ModulusBytes);
        skip1024Base = BigInteger.valueOf(2);
        try {
            kpg = KeyPairGenerator.getInstance(""DH"");
            DHParameterSpec dhp = new DHParameterSpec(skip1024Modulus,
                    skip1024Base);
            kpg.initialize(dhp);
        } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        }
    }

    /**
     * Create KeyAgreement and generate secret key
     * 
     * @param prk_self
     *            the private key from the user who wants to generate the secret
     *            key
     * @param pbk_peer
     *            the public key from the user whom is to be agree on the secret
     *            key with
     * @param lastPhase
     *            flag which indicates whether or not this is the last phase of
     *            this key agreement
     * @return the secret key
     */
    public static SecretKeySpec agreeSecretKey(PrivateKey prk_self,
            PublicKey pbk_peer, boolean lastPhase) throws Exception {
        KeyAgreement ka = KeyAgreement.getInstance(""DH"");
        ka.init(prk_self);
        ka.doPhase(pbk_peer, lastPhase);
        byte[] bkey = ka.generateSecret();
        return new SecretKeySpec(bkey, ""AES"");
    }

    /**
     * Generate a key pair of algorithm ""DiffieHellman""
     * 
     * @return the public and private key pair
     */
    public static KeyPair genDHKeyPair() {
        return kpg.genKeyPair();
    }
}
</code></pre>

<h2>DHTest</h2>

<pre><code>import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import ggicci.infosec.DiffieHellmanModule;

public class DHTest {

    public static void main(String[] args) {
        KeyPair kp1 = DiffieHellmanModule.genDHKeyPair();
        KeyPair kp2 = DiffieHellmanModule.genDHKeyPair();
        PublicKey pbk1 = kp1.getPublic();
        PublicKey pbk2 = kp2.getPublic();
        PrivateKey prk1 = kp1.getPrivate();
        PrivateKey prk2 = kp2.getPrivate();
        try {
            SecretKeySpec sk1 = DiffieHellmanModule.agreeSecretKey(prk1, pbk2, true);
            SecretKeySpec sk2 = DiffieHellmanModule.agreeSecretKey(prk2, pbk1, true);
            Cipher cipher = Cipher.getInstance(sk1.getAlgorithm());
            cipher.init(Cipher.ENCRYPT_MODE, sk1); //--&gt;Exception here:Invalid AES key length: 128 bytes
            byte[] ciphertext = cipher.doFinal(""Hello World"".getBytes(""utf-8""));
            cipher.init(Cipher.DECRYPT_MODE, sk2);
            System.out.println(""Decrypted: "" + new String(cipher.doFinal(ciphertext), ""utf-8""));
            System.out.println(""Done"");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
</code></pre>
","<p>You are generating key data for a DiffieHellman key of 128 bytes with the statement:     <code>byte[] bkey = ka.generateSecret();</code>, but then use it as input for a AES keyspec with     <code>new SecretKeySpec(bkey, ""AES"");</code> </p>

<p>This later trigger the exception you see when trying to initialize a cipher with <code>cipher.init(Cipher.ENCRYPT_MODE, sk1);</code> as an AES key is expected to have 16, 24 or 32 bytes (128, 192 or 256 bits) of key data and not 128 bytes.</p>
","2932","<java><jce><diffie-hellman>","1","0","1","2013-03-23 02:00:23","15582575","0","3","1592264","","2013-01-10 05:58:55","2013-01-09 07:16:05",""
"5682137","Difference between Bouncy Castle ECDH and the .net4 native ECDiffieHellmanCNG","<p>I've been able to generate a private key using the ECDiffieHellmanCNG in .net4 and I've also used the Bouncy Castle C# library to successfully generate private keys. I want to know why the .net 4 version generates a byte array of chars and the ECDHBasicAgreement from Bouncy Castle generates a type of BigInteger (manually implemented). I would like to be able to use these libraries interchangeably. Thanks!</p>
","<p>Eachy Diffie-Hellman implementation uses unique set of constants to derive the shared secret from the public+private key. So neither implementation may derive the exact same shared secret from the very same key pairs. You are better off testing it for yourself or asking it on the BouncyCastle mailing lists.</p>

<p>Note: ECDiffieHellmanCNG is only available on Windows Vista/Windows 7 and above. On the other hand, you can use BouncyCastle on .net 1.1 and above and older Windows versions (2000, XP etc.)</p>
","2378","<c#><bouncycastle><elliptic-curve><diffie-hellman>","3","2","2","2012-02-02 07:12:15","5682706","0","","628273","","2011-04-17 11:14:31","2011-04-15 20:40:29",""
"5682137","Difference between Bouncy Castle ECDH and the .net4 native ECDiffieHellmanCNG","<p>I've been able to generate a private key using the ECDiffieHellmanCNG in .net4 and I've also used the Bouncy Castle C# library to successfully generate private keys. I want to know why the .net 4 version generates a byte array of chars and the ECDHBasicAgreement from Bouncy Castle generates a type of BigInteger (manually implemented). I would like to be able to use these libraries interchangeably. Thanks!</p>
","<p>You're probably in the wrong area of the BouncyCastle class hierarchy for what you want to do.  (I stumbled around in the same place, for probably the same reasons.)  If you're looking to implement ECDH that must be interoperable, you're definitely in the wrong place.</p>

<p>Why is it structured so unintuitively?  Well, the reason is that the abstractions in BouncyCastle are where they focus their attention and provide their value.  Instead of gearing for people saying ""I'm going to use ECDH key-encrypting keys"" and wanting to deal with low-level crypto details, BC expects you to use manager-level abstractions like ""public key"", ""private key"", and ""certificate"", and fill in the security parameters like ""kind"" and ""bitstrength"" in the middle of it.</p>

<pre><code>var _keypair = new ECKeyPairGenerator(""EC"").Init(
    new KeyGenerationParameters(_SecureRandomSingleton, 256)).GenerateKeyPair();
// For the love of all that's holy don't do this in production, encrypt your keys!
var pkcs8gen = new Pkcs8Generator(_keypair.Private);
Stream pkcs8stream = new MemoryStream();
using(System.IO.TextWriter pkcs8writer = new StreamWriter(pkcs8stream))
{
    var mywriter = new Org.BouncyCastle.OpenSsl.PemWriter(pkcs8writer);
    mywriter.WriteObject(pkcs8gen.Generate());
    mywriter.Writer.Flush();
}
</code></pre>

<p>BouncyCastle will quite happily waste time and electricity recalculating the public key every time you load this, unless you take care to save _keypair.Public in something like a self-signed X509Certificate.</p>

<pre><code>var _cgen = new X509V3CertificateGenerator();
_cgen.Reset();
_cgen.SetNotBefore(DateTime.Now);
_cgen.SetNotAfter(new DateTime(2999, 12, 31, 23, 59, 59, DateTimeKind.Utc));
var DN = new X509Name(""CN=Self Signed Certificate"");
_cgen.SetIssuerDN(DN);
_cgen.SetSubjectDN(DN);
_cgen.SetPublicKey(_keypair.Public);
_cgen.SetSignatureAlgorithm(             // Can be anything ECDsaWith*
    Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ECDsaWithSha256.ToString());
_cgen.SetSerialNumber(                   // Serial number collisions suck
     new Org.BouncyCastle.Math.BigInteger(
         8 * 8 - 1,                      // number of bits to generate
         _SecureRandomSingleton));       // source to generate from
var _cert = _cgen.Generate(_keypair.Private);
try
{
    _cert.Verify(_keypair.Public);
} catch (Org.BouncyCastle.Security.Certificates.CertificateException E)
{
    // error-handling code for Verify failure
    // Ridiculous here because we know that _keypair is correct, but good practice
    // to ensure that your keypair is correct and intact
}
Stream certStream = new MemoryStream();
TextWriter certWriter = new StreamWriter(certStream);
var pemWriter = new Org.BouncyCastle.OpenSsl.PemWriter(certWriter);
pemWriter.WriteObject(_cert);
pemWriter.Writer.Flush();
</code></pre>

<p>And here's how to load the keypair from the two structures.</p>

<pre><code>AsymmetricKeyParameter privateKey;
AsymmetricKeyParameter publicKey;
AsymmetricKeyPair reconstitutedPair;
certStream.Position = 0;
pkcs8Stream.Position = 0;
using (TextReader pkcs8reader = new StreamReader(pkcs8stream))
{
    PemReader pemreader = new PemReader(pkcs8reader);
    var privateKey = pemreader.ReadObject() as ECPrivateKeyParameters;
    if (thisprivate == null)
        throw new GeneralSecurityException(""failed to read private key"");
    }
}
var certificate = new Org.BouncyCastle.X509.X509CertificateParser()
    .ReadCertificate(certStream);
var publicKey = certificate.GetPublicKey();
reconstitutedPair = new AsymmetricKeyPair(publicKey,privateKey);
</code></pre>

<p>Now, that all said, here's the answer your actual question.</p>

<p>.NET 4 provides a byte[] because it's calling OLE platform-native code which does all of the abstraction for you.  It's the most efficient representation for this purpose, because it doesn't parse what it gets back from CNG, performing the least amount of object boxing back into the CLR object space and relying on the programmer to deal with what's essentially an opaque blob.  </p>

<p>BouncyCastle uses its BigInteger class because it's how it implements bignum calculations with 64-bit longs.  It is the most efficient representation for this purpose, because the overhead of processing 8-bit byte by 8-bit byte is far more than 8 times the cost of processing 64-bit long by 64-bit long.  Either way, it requires iteratively calling BitConverter on a different section of the input byte[].  Those iterations and method calls add up, so BigInteger is the ""internal representation of a number"".</p>

<p>These are not even remotely comparable uses, so this is probably not what you want to do.</p>

<p>If you want to get a byte[] from BigInteger, use its ToByteArray() method.  If you want to transform a byte[] to a BigInteger, construct a new BigInteger object with the byte[] containing the bit string you want to calculate with.  new BigInteger(oldBigInteger.ToByteArray()) works as you'd expect (a new BigInteger object which has the same value as the old one).  Directly working with them is usually inappropriate, because EC public keys are made up of two numbers.  Also, ToByteArray() only dumps the value of the integer, it doesn't include any DER encoding information to identify it as an integer of whatever length.</p>

<p>(Also, in C#, 'byte' and 'char' are different things with different sizes.  'byte' is 8 bits long.  'char' is a Unicode code point, and those are potentially larger than 8 bits.  'char' (along with 'string', which is conceptually a sequence of chars) requires encoding/decoding before it'll fit into byte-sized pieces.)</p>
","2378","<c#><bouncycastle><elliptic-curve><diffie-hellman>","3","3","2","2012-02-02 07:12:15","5682706","0","","628273","","2011-04-17 11:14:31","2011-04-15 20:40:29",""
"2835959","Diffie-Hellman -- Primitive root mod n -- cryptography question","<p>In the below snippet, please explain starting with the first ""for"" loop what is happening and why. Why is 0 added, why is 1 added in the second loop. What is going on in the ""if"" statement under bigi. Finally explain the modPow method. Thank you in advance for meaningful replies. </p>

<pre><code>public static boolean isPrimitive(BigInteger m, BigInteger n) {

    BigInteger bigi, vectorint;
    Vector&lt;BigInteger&gt; v = new Vector&lt;BigInteger&gt;(m.intValue());
    int i;

    for (i=0;i&lt;m.intValue();i++)
        v.add(new BigInteger(""0""));

    for (i=1;i&lt;m.intValue();i++)
    {
        bigi = new BigInteger("""" + i);

        if (m.gcd(bigi).intValue() == 1)
            v.setElementAt(new BigInteger(""1""), n.modPow(bigi,m).intValue());
    }

    for (i=0;i&lt;m.intValue();i++)
    {
        bigi = new BigInteger("""" + i);

        if (m.gcd(bigi).intValue() == 1)
        {
            vectorint = v.elementAt(bigi.intValue());
            if ( vectorint.intValue() == 0)
                i = m.intValue() + 1;
        }
    }

    if (i == m.intValue() + 2)
        return false;
    else
        return true;

}
</code></pre>
","<ul>
<li><p>Treat the vector as a list of booleans, with one boolean for each number 0 to m.  When you view it that way, it becomes obvious that each value is set to 0 to initialize it to false, and then set to 1 later to set it to true.</p></li>
<li><p>The last for loop is testing all the booleans.  If any of them are 0 (indicating false), then the function returns false.  If all are true, then the function returns true.</p></li>
<li><p>Explaining the <code>if</code> statement you asked about would require explaining what a primitive root mod n is, which is the whole point of the function.  I think if your goal is to understand this program, you should first understand what it implements.  If you read <a href=""http://en.wikipedia.org/wiki/Primitive_root_modulo_n"" rel=""nofollow noreferrer"">Wikipedia's article</a> on it, you'll see this in the first paragraph:</p></li>
</ul>

<blockquote>
  <p>In modular arithmetic, a branch of
  number theory, a primitive root modulo
  n is any number g with the property
  that any number coprime to n is
  congruent to a power of g (mod n).
  That is, if g is a primitive root (mod
  n), then for every integer a that has
  gcd(a, n) = 1, there is an integer k
  such that gk ≡ a (mod n). k is called
  the index of a. That is, g is a
  generator of the multiplicative group
  of integers modulo n.</p>
</blockquote>

<ul>
<li>The function <a href=""http://java.sun.com/j2se/1.4.2/docs/api/java/math/BigInteger.html"" rel=""nofollow noreferrer"">modPow</a> implements <a href=""http://en.wikipedia.org/wiki/Modular_exponentiation"" rel=""nofollow noreferrer"">modular exponentiation</a>.  Once you understand how to find a primitive root mod n, you'll understand it.</li>
</ul>

<p>Perhaps the final piece of the puzzle for you is to know that two numbers are <em>coprime</em> if their greatest common divisor is 1.  And so you see these checks in the algorithm you pasted.</p>

<p>Bonus link:  <a href=""http://www.math.umn.edu/~garrett/coding/Overheads/11_sunze_proots.pdf"" rel=""nofollow noreferrer"">This paper</a> has some nice background, including how to test for primitive roots near the end.</p>
","2321","<vector><root><primitive><diffie-hellman>","-2","1","1","2010-12-17 10:42:12","","1","1","309308","","2010-05-14 17:23:45","2010-05-14 16:46:57",""
"28521374","Possibility of Man in the Middle Attack during TLS handshake","<p>I have read through the previous discussion on the same topic <a href=""https://stackoverflow.com/questions/21969536/man-in-the-middle-attacks-and-ssl?rq=1"">here</a>, <a href=""https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding"">here</a> and a few other places. While I understand that during the course of TLS communication, a MiTM is quite not possible, what are the chances of MiTM attack during TLS handshake?</p>

<p>I realize that TLS client hello, server hello and the following packets sent before establishing the key cannot be encrypted. For establishing the key, TLS uses Diffie Hellman protocol. SO will the traditional Man in the Middle attack still work here? </p>
","<p>High level view:
At the end of the handshake a signature is done covering the whole handshake. This signature implicitly includes that only the server knows the private key of the certificate. Thus the signature can not be faked by a man-in-the-middle as long as the certificate was properly validated by the client.</p>

<p>If you need a more detailed view on how this process really works you will find lots of information on the internet.</p>
","2288","<ssl><diffie-hellman><man-in-the-middle>","0","1","2","2018-04-02 11:04:46","28523502","3","1","-1","","2017-05-23 11:56:59","2015-02-14 23:18:41",""
"28521374","Possibility of Man in the Middle Attack during TLS handshake","<p>I have read through the previous discussion on the same topic <a href=""https://stackoverflow.com/questions/21969536/man-in-the-middle-attacks-and-ssl?rq=1"">here</a>, <a href=""https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding"">here</a> and a few other places. While I understand that during the course of TLS communication, a MiTM is quite not possible, what are the chances of MiTM attack during TLS handshake?</p>

<p>I realize that TLS client hello, server hello and the following packets sent before establishing the key cannot be encrypted. For establishing the key, TLS uses Diffie Hellman protocol. SO will the traditional Man in the Middle attack still work here? </p>
","<p>Just a remark, DH exchange is just a way to exchange keys without knowing the private keys for encryption.   There is nothing inside it to prevent MITM attack.   But if the public key (for both client and server) is validated through some exchange with third party like certification authority, then now MITM attack is not possible, as end-to-end the public key has be verified, so modification in between is mathematically infeasible.
Reference:</p>

<p><a href=""http://slideplayer.com/slide/5938889/"" rel=""nofollow noreferrer"">http://slideplayer.com/slide/5938889/</a></p>

<p><a href=""https://i.stack.imgur.com/RV8AH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RV8AH.png"" alt=""enter image description here""></a></p>
","2288","<ssl><diffie-hellman><man-in-the-middle>","0","0","2","2018-04-02 11:04:46","28523502","3","1","-1","","2017-05-23 11:56:59","2015-02-14 23:18:41",""
"3868881","Choosing a encryption key from Diffie-Hellman output","<p>I implemented <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""noreferrer"">Diffie–Hellman key exchange</a> in Java with some large groups from <a href=""http://www.ietf.org/rfc/rfc3526.txt"" rel=""noreferrer"">RFC 3526</a>. My output is a fairly large array of bytes. <strong>Is it safe to use the first 448 bits (56 bytes) of the output for a blowfish key?</strong> Should I transform the bytes in any way, or pick any specific bytes for the key?</p>
","<p>From a theoretical point of view, no, it is not safe. Not that I could pinpoint an actual attack; but the output of a Diffie-Hellman key exchange is an element of a group consisting in <em>q</em> elements and offering <em>sqrt(q)</em> security at most. Truncating parts of the encoding of that element does not look like a good idea...</p>

<p>The ""proper"" way is to use a one-way key derivation function. In simple words, process the Diffie-Hellman output with a good hash function such as <a href=""http://en.wikipedia.org/wiki/SHA-2"" rel=""nofollow"">SHA-256</a> and use the hash result as key. Hashing time will be negligible with regards to the Diffie-Hellman step. Java already includes fine implementations of SHA-256 and SHA-512, and if you are after compatibility with very old Java implementations (e.g. the Microsoft JVM which was coming with Internet Explorer 5.5) then you can use an independent Java implementation of SHA-2 such as the one in <a href=""http://www.saphir2.com/sphlib/"" rel=""nofollow"">sphlib</a>. Or possibly reimplement it from the spec (that's not hard): <a href=""http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf"" rel=""nofollow"">FIPS 180-3 (a PDF file)</a>.</p>

<p>If you need more than 128 bits for your key then this means that you are a time-traveler from year 2050 or so; 128 bits are (much) more than enough to protect you for the time being, assuming that you use a proper symmetric encryption scheme.</p>

<p>Speaking of which: Blowfish is not really recommended anymore. It has 64-bit blocks, which implies trouble when the encrypted data length reaches a few gigabytes, a size which is not that big nowadays. You would be better off using a 128-bit block cipher such as the <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">AES</a>. Also, in any serious symmetric encryption system you will need a keyed integrity check. This can be done with a MAC (Message Authentication Code) such as <a href=""http://tools.ietf.org/html/rfc2104"" rel=""nofollow"">HMAC</a>, itself built over a hash function (then again, easy to implement, and there is a Java implementation in sphlib). Or, even better, use the AES in a combined encryption/MAC mode which will handle the tricky details for you (because using a block cipher properly is <em>not</em> easy); lookup <a href=""http://www.zork.org/cwc/"" rel=""nofollow"">CWC</a> and <a href=""http://en.wikipedia.org/wiki/Galois/Counter_Mode"" rel=""nofollow"">GCM</a> (both are patent-free; the latter has been approved by NIST).</p>
","2212","<java><encryption><blowfish><diffie-hellman>","5","3","2","2010-10-13 08:56:20","3872182","0","","","","","2010-10-06 01:10:07",""
"3868881","Choosing a encryption key from Diffie-Hellman output","<p>I implemented <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""noreferrer"">Diffie–Hellman key exchange</a> in Java with some large groups from <a href=""http://www.ietf.org/rfc/rfc3526.txt"" rel=""noreferrer"">RFC 3526</a>. My output is a fairly large array of bytes. <strong>Is it safe to use the first 448 bits (56 bytes) of the output for a blowfish key?</strong> Should I transform the bytes in any way, or pick any specific bytes for the key?</p>
","<p>The solution that you propose depends on whether the most significant bits of a Diffie-Hellman exchange are hard core. There are some small results known that show that the most significant bits are unpredictable, but I'm not aware of a paper that is strong enough to show that your approach is correct.</p>

<p>However, there are several proposals for a key derivation from Diffie-Hellman keys.
E.g. a nice paper is NIST SP 800-135. So far this is only a draft and can be found <a href=""http://csrc.nist.gov/publications/PubsDrafts.html"" rel=""nofollow"">here</a>. However, it reviews some existing standards. Of course, using a standard is always preferable to develop it yourself.</p>

<p>While Thomas Pornin's proposal looks reasonable it is nonetheless an ad hoc solution. And to be on the safe side you should probably not use it. Rather I'd use something that has been analyzed (e.g. the key derivation scheme use in TLS version 1.2).</p>
","2212","<java><encryption><blowfish><diffie-hellman>","5","0","2","2010-10-13 08:56:20","3872182","0","","","","","2010-10-06 01:10:07",""
"24919173","Generate EC Diffie-Hellman public and private key pair","<p>I need to generate an EC Diffie Hellman key pair. I am using the secp256r1 named curve, and OpenSSL. This is what I have with me so far:</p>

<pre><code>unsigned char *ecdh(size_t *secret_len)
{
    EVP_PKEY_CTX *pctx, *kctx;
    EVP_PKEY_CTX *ctx;
    unsigned char *secret;
    EVP_PKEY *pkey = NULL, *peerkey, *params = NULL;
    /* NB: assumes pkey, peerkey have been already set up */

    /* Create the context for parameter generation */
    if(NULL == (pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL))) 
        printf(""Error in EC key generation\n"");

    /* Initialise the parameter generation */
    if(1 != EVP_PKEY_paramgen_init(pctx)) 
        printf(""Error in EC key generation\n"");

    /* We're going to use the ANSI X9.62 Prime 256v1 curve */
    if(1 != EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_X9_62_prime256v1)) 
        printf(""Error in EC key generation\n"");

    /* Create the parameter object params */
    if (!EVP_PKEY_paramgen(pctx, &amp;params)) 
        printf(""Error in EC key generation\n"");

    /* Create the context for the key generation */
    if(NULL == (kctx = EVP_PKEY_CTX_new(params, NULL))) 
        printf(""Error in EC key generation\n"");

    /* Generate the key */
    if(1 != EVP_PKEY_keygen_init(kctx)) 
        printf(""Error in EC key generation\n"");

    if (1 != EVP_PKEY_keygen(kctx, &amp;pkey)) 
        printf(""Error in EC key generation\n"");

    /* Get the peer's public key, and provide the peer with our public key -
     * how this is done will be specific to your circumstances */
    peerkey = get_peerkey(pkey);

    /* Create the context for the shared secret derivation */
    if(NULL == (ctx = EVP_PKEY_CTX_new(pkey, NULL))) 
        printf(""Error in EC key generation\n"");

    /* Initialise */
    if(1 != EVP_PKEY_derive_init(ctx)) 
        printf(""Error in EC key generation\n"");

    /* Provide the peer public key */
    if(1 != EVP_PKEY_derive_set_peer(ctx, peerkey)) 
        printf(""Error in EC key generation\n"");

    /* Determine buffer length for shared secret */
    if(1 != EVP_PKEY_derive(ctx, NULL, secret_len)) 
        printf(""Error in EC key generation\n"");

    /* Create the buffer */
    if(NULL == (secret = OPENSSL_malloc(*secret_len))) 
        printf(""Error in EC key generation\n"");

    /* Derive the shared secret */
    if(1 != (EVP_PKEY_derive(ctx, secret, secret_len))) 
        printf(""Error in EC key generation\n"");

    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(peerkey);
    EVP_PKEY_free(pkey);
    EVP_PKEY_CTX_free(kctx);
    EVP_PKEY_free(params);
    EVP_PKEY_CTX_free(pctx);

    /* Never use a derived secret directly. Typically it is passed
     * through some hash function to produce a key */
    return secret;
} 
</code></pre>

<p>I figured out that for this function to work, i need a <code>EVP_KEY</code> object with the second party's public key. I have this public key in a byte array, and also its length. How do I convert it to the required type? And also I could not find the secp256r1 curve in OpenSSL, but I used the one in the code after doing some research. Is it correct?</p>

<p>Thanks !</p>
","<p>The peer's public key is a point on the curve. From <code>crypto\ec\ec_lcl.h</code>:</p>

<pre><code>struct ec_key_st {
    int version;

    EC_GROUP *group;

    EC_POINT *pub_key;
    BIGNUM   *priv_key;

    unsigned int enc_flag;
    point_conversion_form_t conv_form;

    int     references;
    int flags;

    EC_EXTRA_DATA *method_data;
} /* EC_KEY */;
</code></pre>

<p>I <em>believe</em> you need to call <code>EC_POINT_new</code> (<code>c_lcl.h</code> is a private header, so you won't have access to the structure).</p>

<p>Luckily, there's a lot of functions to manipulate them. From the <a href=""http://www.openssl.org/docs/crypto/EC_POINT_new.html"" rel=""nofollow""><code>EC_POINT_new(3)</code></a> docs:</p>

<blockquote>
  <p>EC_POINTs can be converted to and from various external
  representations. Supported representations are octet strings, BIGNUMs
  and hexadecimal. The format of the external representation is
  described by the point_conversion_form. See EC_GROUP_copy(3) for a
  description of point_conversion_form. Octet strings are stored in a
  buffer along with an associated buffer length. A point held in a
  BIGNUM is calculated by converting the point to an octet string and
  then converting that octet string into a BIGNUM integer. Points in
  hexadecimal format are stored in a NULL terminated character string
  where each character is one of the printable values 0-9 or A-F (or
  a-f).</p>
</blockquote>

<p>Also see <code>EC_POINT_set_affine_coordinates_GFp</code>, <code>EC_POINT_set_affine_coordinates_GF2m</code> and <code>EC_KEY_set_public_key</code>:</p>

<pre><code>$ grep -R EC_KEY_set_public_key *
crypto/ec/ec.h:int EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);
...
</code></pre>

<p>You can see an example of how to set the point on the OpenSSL wiki at <a href=""http://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography"" rel=""nofollow"">Elliptic Curve Cryptography</a>.</p>
","2182","<c><openssl><encryption-asymmetric><elliptic-curve><diffie-hellman>","3","1","1","2014-07-24 14:32:48","","3","1","","","","2014-07-23 19:23:28",""
"29089311","How to use BouncyCastle's Diffie-Hellman in C#?","<p>I'm writing an app that'll exchange data between a phone and a Windows PC, and I want to protect the data sent with  key generated with a Diffie-Hellman exchange.</p>

<p>I'm trying to use BouncyCastle for that, but the almost non-existant documentation for the C# implementation has me stumped.</p>

<p>What I want to know is: what's the workflow for generating a DH key and computing a shared key when the other side's key is received? (I'm assuming I can send my key as a string and I can work with the other side's key as a string.) What objects/methods do I use in C# for that?</p>
","<p>Alright, after a lot of trial, I got it working. Posting answer in case someone else needs it.</p>

<p>I'll assume the reader (1) knows what Diffie-Hellman is and what it's useful for (read <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""noreferrer"">here</a> for details) and (2) already imported Bouncycastle to a .NET project via NuGet.</p>

<p>Imports you'll need:</p>

<pre><code>using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;
</code></pre>

<p>How to generate g and p:</p>

<pre><code>public DHParameters GenerateParameters()
{
    var generator = new DHParametersGenerator();
    generator.Init(BitSize, DefaultPrimeProbability, new SecureRandom());
    return generator.GenerateParameters();
}
</code></pre>

<p>Wanna get g and p as strings?</p>

<pre><code>public string GetG(DHParameters parameters)
    {
        return parameters.G.ToString();
    }

public string GetP(DHParameters parameters)
    {
        return parameters.P.ToString();
    }
</code></pre>

<p>How to generate a and A:</p>

<pre><code>public AsymmetricCipherKeyPair GenerateKeys(DHParameters parameters)
    {
    var keyGen = GeneratorUtilities.GetKeyPairGenerator(""DH"");
    var kgp = new DHKeyGenerationParameters(new SecureRandom(), parameters);
    keyGen.Init(kgp);
    return keyGen.GenerateKeyPair();
}
</code></pre>

<p>Wanna read a and A as a string?</p>

<pre><code>// This returns A
public string GetPublicKey(AsymmetricCipherKeyPair keyPair)
{
    var dhPublicKeyParameters = _generatedKey.Public as DHPublicKeyParameters;
    if (dhPublicKeyParameters != null)
    {
        return dhPublicKeyParameters.Y.ToString();
    }
    throw new NullReferenceException(""The key pair provided is not a valid DH keypair."");
}

// This returns a
public string GetPrivateKey(AsymmetricCipherKeyPair keyPair)
{
    var dhPrivateKeyParameters = _generatedKey.Private as DHPrivateKeyParameters;
    if (dhPrivateKeyParameters != null)
    {
        return dhPrivateKeyParameters.X.ToString();
    }
    throw new NullReferenceException(""The key pair provided is not a valid DH keypair."");
}
</code></pre>

<p>To import the parameters from strings just do:</p>

<pre><code>var importedParameters = new DHParameters(p, g);
</code></pre>

<p>To generate b and B just use <code>GenerateKeys()</code> with <code>importedParameters</code> instead of the generated <code>parameters</code>.</p>

<p>Let's say you generated b and B and already got p, g and A. To compute the shared secret:</p>

<pre><code>public BigInteger ComputeSharedSecret(string A, AsymmetricKeyParameter bPrivateKey, DHParameters internalParameters)
{
    var importedKey = new DHPublicKeyParameters(new BigInteger(A), internalParameters);
    var internalKeyAgree = AgreementUtilities.GetBasicAgreement(""DH"");
    internalKeyAgree.Init(bPrivateKey);
    return internalKeyAgree.CalculateAgreement(importedKey);
}
</code></pre>

<p>Repeat for A and now you have a shared secret between 2 clients, ready to be used to encrypt communications.</p>

<p>Hope this is useful.</p>
","2115","<c#><bouncycastle><diffie-hellman>","4","8","1","2015-05-01 01:41:47","29980483","0","1","","","","2015-03-17 00:24:57",""
"29052620","How do I enable diffie-hellman-group-exchange-sha1 as the type of key exchange in Twisted Python framework (Kippo HoneyPot Related)?","<p>I have an application that is an SSH client that supports the following key algorithms for negotiation.</p>

<p>diffie-hellman-group-exchange-sha1
diffie-hellman-group14-sha1
diffie-hellman-group-exchange-sha256</p>

<p>I don't have the option of changing the SSH client, so I am trying to solve the problem on the SSH server, which is utilizing Twisted. The SSH server is actually implemented in the Kippo Honeypot, but the underlying problem is with Twisted. </p>

<p>I see that Twisted supports diffie-hellman-group-exchange-sha1 and diffie-hellman-group1-sha1 in line 221 here:  <a href=""https://github.com/twisted/twisted/blob/38421d6fcffa1ddb590e51df0e1c6cba6f29d052/twisted/conch/ssh/transport.py"" rel=""nofollow"">https://github.com/twisted/twisted/blob/38421d6fcffa1ddb590e51df0e1c6cba6f29d052/twisted/conch/ssh/transport.py</a></p>

<p>I see that diffie-hellman-group-exchange-sha1 is being disabled in line 60 here:  ​<a href=""https://github.com/twisted/twisted/blob/38421d6fcffa1ddb590e51df0e1c6cba6f29d052/twisted/conch/ssh/factory.py"" rel=""nofollow"">https://github.com/twisted/twisted/blob/38421d6fcffa1ddb590e51df0e1c6cba6f29d052/twisted/conch/ssh/factory.py</a></p>

<p>The diffie-hellman-group-exchange-sha1 supported but then later disabled. My application's SSH client cannot negotiate a key to establish an SSH connection to the SSH server that is utilizing Twisted.</p>

<p>I see this note in the code prior to disabling it ""log.msg('disabling diffie-hellman-group-exchange because we cannot find moduli file')"" If I try to force Twisted to use diffie-hellman-group-exchange-sha1 I get the following error.</p>

<pre><code>   Traceback (most recent call last):
      File ""/usr/lib/python2.7/dist-packages/twisted/python/log.py"", line 84, in callWithLogger
        return callWithContext({""system"": lp}, func, *args, **kw)
      File ""/usr/lib/python2.7/dist-packages/twisted/python/log.py"", line 69, in callWithContext
        return context.call({ILogContext: newCtx}, func, *args, **kw)
      File ""/usr/lib/python2.7/dist-packages/twisted/python/context.py"", line 118, in callWithContext
        return self.currentContext().callWithContext(ctx, func, *args, **kw)
      File ""/usr/lib/python2.7/dist-packages/twisted/python/context.py"", line 81, in callWithContext
        return func(*args,**kw)
    --- &lt;exception caught here&gt; ---
      File ""/usr/lib/python2.7/dist-packages/twisted/internet/posixbase.py"", line 586, in _doReadOrWrite
        why = selectable.doRead()
      File ""/usr/lib/python2.7/dist-packages/twisted/internet/tcp.py"", line 199, in doRead
        rval = self.protocol.dataReceived(data)
      File ""/home/sudopwn/kippo-master/kippo/core/ssh.py"", line 150, in dataReceived
        transport.SSHServerTransport.dataReceived(self, data)
      File ""/usr/lib/python2.7/dist-packages/twisted/conch/ssh/transport.py"", line 438, in dataReceived
        self.dispatchMessage(messageNum, packet[1:])
      File ""/usr/lib/python2.7/dist-packages/twisted/conch/ssh/transport.py"", line 453, in dispatchMessage
        f(payload)
      File ""/usr/lib/python2.7/dist-packages/twisted/conch/ssh/transport.py"", line 950, in ssh_KEX_DH_GEX_REQUEST
        self.g, self.p = self.factory.getDHPrime(ideal)
      File ""/usr/lib/python2.7/dist-packages/twisted/conch/ssh/factory.py"", line 126, in getDHPrime
        primesKeys = self.primes.keys()
    exceptions.AttributeError: 'NoneType' object has no attribute ‘keys'
</code></pre>

<p>Is there a workaround or a solution to allow diffie-hellman-group-exchange-sha1 to be enabled?</p>
","<p>There is no ""workaround"" to the fact that DH key exchange requires moduli.  That's how the math works.  If you look in <code>openssh_compat.py</code> you will see that the <code>getPrimes</code> has a parser for openssh's primes format, and if you have moduli at <code>/path/to/moduli</code> then <code>twistd -n conch --data=/path/to</code> will parse them.  You can generate these with <code>ssh-keygen -G</code>.  You need to implement something similar on <code>HoneyPotSSHFactory</code>, implemented here: <a href=""https://github.com/desaster/kippo/blob/master/kippo/core/ssh.py#L53"" rel=""nofollow"">https://github.com/desaster/kippo/blob/master/kippo/core/ssh.py#L53</a></p>

<p>Remember that generating moduli takes a while so you will want to do it in advance.</p>
","2091","<python><ssh><twisted><diffie-hellman><honeypot>","1","1","1","2015-04-30 16:55:34","","0","","","","","2015-03-14 18:28:43",""
"13319109","Performance of Bouncy Castle in Java","<p>I'm having some problems with performance using the Bouncy Castle Provider when generating DH parameters. Anyone knows why the Bouncy Castle example below is about 50 times slower than using the standard provider?</p>

<p>Using Bouncy Castle provider:</p>

<pre><code>Security.addProvider(new BouncyCastleProvider());
AlgorithmParameterGenerator generator = AlgorithmParameterGenerator.getInstance(""DH"", ""BC"");
for (int i = 0; i &lt; 3; i++) {
    generator.init(1024, new SecureRandom());
    AlgorithmParameters params = generator.generateParameters();
    DHParameterSpec dhSpec = (DHParameterSpec) params.getParameterSpec(DHParameterSpec.class);
    System.out.println(""P: "" + dhSpec.getP() + "", G:"" + dhSpec.getG());
}
</code></pre>

<p>Using standard provider:</p>

<pre><code>AlgorithmParameterGenerator generator = AlgorithmParameterGenerator.getInstance(""DH"");
for (int i = 0; i &lt; 3; i++) {
    generator.init(1024, new SecureRandom());
    AlgorithmParameters params = generator.generateParameters();
    DHParameterSpec dhSpec = (DHParameterSpec) params.getParameterSpec(DHParameterSpec.class);
    System.out.println(""P: "" + dhSpec.getP() + "", G:"" + dhSpec.getG());
}
</code></pre>
","<p>The reason for the speed difference is that the BC provider is searching for a ""Safe Prime"", i.e. a prime p: p = 2q + 1, where q is also prime.</p>

<p>As you noticed, this is a lot slower than just finding a prime. The standard provider is not doing that, as can easily be verified.</p>

<p>Looking for a safe prime might be overkill, as it may suffice to have p = 2Rq + 1 for some R, which admits of a considerably faster implementation, while still ensuring a large prime factor of (p - 1).</p>

<p>It shouldn't be necessary to generate these parameters yourself often (if at all). A single set can be used for many key pairs, and there are standardized sets of parameters around that you may be better off using.</p>
","2008","<java><performance><bouncycastle><diffie-hellman>","3","4","1","2012-11-13 10:40:12","13359253","0","","","","","2012-11-10 03:56:58",""
"33079925","AsymmetricKeyParameter as byte[]","<p>I'm trying to do an ECDH key exchange using C# BouncyCastle. 
I have been successful in creating the necessary AsymmetricCipherKeyPair objects and I'm also able to generate the shared key of the other partys public key.</p>

<p>However, to actually exchange the public key, I need it as a byte[] or at least anything I can turn into raw data, since the protocol I'm using to transport the keys between the parties wont take any BouncyCastle object.</p>

<pre><code>   X9ECParameters ecPars = NistNamedCurves.GetByName(""P-521"");
  ECDomainParameters ecDomPars = new ECDomainParameters(ecPars.Curve, ecPars.G, ecPars.N, ecPars.H, ecPars.GetSeed());
  IAsymmetricCipherKeyPairGenerator gen = GeneratorUtilities.GetKeyPairGenerator(""ECDH"");
  gen.Init(new ECKeyGenerationParameters(ecDomPars, new SecureRandom()));

  AsymmetricCipherKeyPair keyPair = gen.GenerateKeyPair();
  IBasicAgreement keyAgreement = AgreementUtilities.GetBasicAgreement(""ECDH"");
  keyAgreement.Init(keyPair.Private);
</code></pre>

<p>So what I'm needing here is the key value of keyPair.Public as a byte[].</p>

<p>I hope you understand where I'm heading and can help me.</p>
","<p>If you have only an ECPublicKeyParameter 'pub' (i.e. from keyPair.Public), you can get the public point encoding:</p>

<pre><code>byte[] data = pub.Q.GetEncoded();
</code></pre>

<p>At the receiving end:</p>

<pre><code>ECCurve curve = ecDomPars.Curve;
ECPoint q = curve.DecodePoint(data);
ECPublicKeyParameter peerPub = new ECPublicKeyParameter(q, ecDomPars);
</code></pre>

<p>It's more typical to exchange certificates, or else you will have no assurance of whom you're ""agreeing"" with.</p>

<p>I'm a bit concerned that you might be ""rolling your own crypto protocol""; if this is for a real application, please consider using an existing protocol, maybe just TLS. </p>
","1992","<c#><bouncycastle><public-key><elliptic-curve><diffie-hellman>","1","1","1","2015-10-19 15:39:47","33218568","0","1","1364007","","2015-10-12 11:29:38","2015-10-12 11:25:46",""
"14757108","How to force the use of Diffie Hellman Key Exchange","<p>I want to create a TLS Socket connection. I know TLS has a few ways to exchange the key eg. RSA, Diffie-Hellman, etc. How can I force the use of Diffie-Hellman key exchange instead of other forms of key exchange?</p>

<p>I know that if using Diffie-Hellman key exchange, it is vulnerable to man-in-middle attack. When using RSA, we have server authentication which prevents MITM. But one concern I have is that using RSA prohibits the forward secrecy.</p>

<p>What should I do?</p>
","<p>Specifying the key exchange method is done by choosing a cipher suite that supports that key exchange method.</p>

<p>You can the cipher suite on an <code>SSLSocket</code> (or <code>SSLEngine</code>) using <a href=""http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites%28java.lang.String%5b%5d%29"" rel=""nofollow""><code>setEnabledCipherSuites</code></a>.</p>

<p>The tables of supported cipher suites and those enabled by default with the Oracle JRE are available in the <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider"" rel=""nofollow"">SunJSSE provider documentation</a>.</p>

<p>The anonymous cipher suites (<code>_DH_anon_</code>) are the ones that are vulnerable to MITM attacks. </p>

<p>The <code>_DH_RSA_</code> or <code>_DH_DSA_</code> cipher suites also use RSA or DSA for the authentication of the DH key exchange (not for the key exchange itself), to prevent MITM attacks. In addition, the <em>Ephemeral</em> DH cipher suites (those that contain <code>_DHE_</code>, or <code>_ECDHE_</code> for the elliptic curve variant) provide Perfect Forward Secrecy. (The non-ephemeral <code>_DH_RSA_</code> or <code>_DH_DSA_</code> cipher suites are not supported by the Sun JSSE provider anyway.)</p>
","1976","<java><ssl><diffie-hellman>","0","3","1","2016-09-18 11:25:51","14759695","2","","276232","","2016-09-18 11:25:51","2013-02-07 17:21:17","2013-02-08 00:44:21"
"22149271","ECDH secrets generated by BouncyCastle Java API and by OpenSSL are different","<p>I'm trying to make use of elliptic curve crypto. I need two implementations of the same thing, one in Java and one in C. I'm testing them using two key pairs which were generated using the curve <em>secp256k1</em>. When I generate the derived secret in Java I always get a different number from what I get from OpenSSL.</p>

<p>Java code:</p>

<pre><code>/* privateKey and peerPublicKey are generated with the following parameters */
ECParameterSpec paramSpec = ECNamedCurveTable.getParameterSpec(""secp256k1"");
/* ... */
Provider BC = new BouncyCastleProvider();
KeyAgreement agr = KeyAgreement.getInstance(""ECDH"", BC);
agr.init(privateKey);
agr.doPhase(peerPublicKey, true);
byte[] secret = agr.generateSecret();
</code></pre>

<p>C code</p>

<pre><code>/* pkey and peerkey are generated using EC_KEY_new_by_curve_name(NID_secp256k1) */
/* and than wrapped in an EVP_PKEY */
EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(pkey, NULL);
uint8_t *secret = NULL;
size_t secret_len;
EVP_PKEY_derive_init(ctx);
EVP_PKEY_derive_set_peer(ctx, peerkey);
EVP_PKEY_derive(ctx, NULL, &amp;secret_len);
secret = malloc(secret_len);
EVP_PKEY_derive(ctx, secret, &amp;secret_len);
</code></pre>

<p>I'm sure that the keys are valid and that they are the same both in C and in Java code, but I don't understand why the derived secret is different. Am I missing something?</p>

<p>Thanks</p>
","<pre><code>EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(pkey, NULL);
uint8_t *secret = NULL;
size_t secret_len;
EVP_PKEY_derive_init(ctx);
EVP_PKEY_derive_set_peer(ctx, peerkey);
EVP_PKEY_derive(ctx, NULL, &amp;secret_len);
secret = malloc(secret_len);
EVP_PKEY_derive(ctx, secret, &amp;secret_len);
</code></pre>

<p>This code looks like its missing a few steps. For example, <code>EVP_PKEY_paramgen_init</code> is not present.</p>

<p>The OpenSSL wiki has an example at <a href=""http://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman"" rel=""nofollow"">Elliptic Curve Diffie-Hellman</a>. I'm going to copy/paste it below to avoid the link-only answer, but I believe its the work of Matt Caswell.</p>

<pre><code>EVP_PKEY_CTX *pctx, *kctx;
EVP_PKEY_CTX *ctx;
unsigned char *secret;
EVP_PKEY *pkey = NULL, *peerkey, *params = NULL;

/* Create the context for parameter generation */
if(NULL == (pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL))) handleErrors();

/* Initialise the parameter generation */
if(1 != EVP_PKEY_paramgen_init(pctx)) handleErrors();

/* We're going to use the ANSI X9.62 Prime 256v1 curve */
if(1 != EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_X9_62_prime256v1)) handleErrors();

/* Create the parameter object params */
if (!EVP_PKEY_paramgen(pctx, &amp;params)) handleErrors();

/* Create the context for the key generation */
if(NULL == (kctx = EVP_PKEY_CTX_new(params, NULL))) handleErrors();

/* Generate the key */
if(1 != EVP_PKEY_keygen_init(kctx)) handleErrors();
if (1 != EVP_PKEY_keygen(kctx, &amp;pkey)) handleErrors();

/* Get the peer's public key, and provide the peer with our public key -
 * how this is done will be specific to your circumstances */
peerkey = get_peerkey(pkey);

/* Create the context for the shared secret derivation */
if(NULL == (ctx = EVP_PKEY_CTX_new(pkey, NULL))) handleErrors();

/* Initialise */
if(1 != EVP_PKEY_derive_init(ctx)) handleErrors();

/* Provide the peer public key */
if(1 != EVP_PKEY_derive_set_peer(ctx, peerkey)) handleErrors();

/* Determine buffer length for shared secret */
if(1 != EVP_PKEY_derive(ctx, NULL, secret_len)) handleErrors();

/* Create the buffer */
if(NULL == (secret = OPENSSL_malloc(*secret_len))) handleErrors();

/* Derive the shared secret */
if(1 != (EVP_PKEY_derive(ctx, secret, secret_len))) handleErrors();

EVP_PKEY_CTX_free(ctx);
EVP_PKEY_free(peerkey);
EVP_PKEY_free(pkey);
EVP_PKEY_CTX_free(kctx);
EVP_PKEY_free(params);
EVP_PKEY_CTX_free(pctx);

/* Never use a derived secret directly. Typically it is passed
 * through some hash function to produce a key */
return secret;
</code></pre>

<hr>

<blockquote>
  <p>When I generate the derived secret in Java I always get a different number from what I get from OpenSSL.</p>
</blockquote>

<p>Each run of the protocol will produce different results. That's because each party picks a random value for each run of the protocol. That is, the <code>a</code> in <code>g^a</code> is random and different for each run, so the public key <code>A = g^a</code> is different for each run. </p>

<p>If everything is working correctly, you'll never see the parties use the same values, or one party to reuse a past value. Independent executions will never produce the same result. It does not matter if its OpenSSL ↔ OpenSSL, OpenSSL ↔ Java, or Java ↔ Java. They will always produce different results.</p>
","1975","<java><openssl><bouncycastle><elliptic-curve><diffie-hellman>","1","2","1","2014-03-04 13:23:47","","1","","","","","2014-03-03 14:27:12",""
"14531113","How to use Diffie-Hellman key exchange to secure data transfer between a client and server?","<p>I am a beginner programmer. I have been asked to secure data transfer between a client and a server by using a Diffie-Hellman key exchange. I have searched a lot on this issue, but I have just found some example codes that find big integers <code>p</code> and <code>g</code>. </p>

<p>The problem is I don't know how to use these numbers to secure a transfer of information. I would like to transfer ""strings"" over the connection between the client and the server, not integers. How can these numbers be useful to me? I'm approaching the deadline for this project for the course I`m taking and could really use some help.</p>
","<p>I'd suggest reading and undertanding this: <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""nofollow"">http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a></p>

<p>And here is a PHP code snippet that will help...</p>

<p>GENERATOR=2 and PRIME (300 digit prime) are constants </p>

<pre><code>        // generate server secret
        $privateKey = 0;

        for ($i=0; $i&lt;100; $i++) {
            if ($i==0) {
                $privateKey = mt_rand(1, 9);
            } else {
                $privateKey .= mt_rand(0, 9);
            }
        }

        // output server public key
        echo gmp_strval(gmp_powm(GENERATOR, $privateKey, PRIME));

        // calculate server secret key
        $secretKey = md5(
            gmp_strval(
                gmp_powm($_POST['public_key'], $privateKey, PRIME)
            )
        );
</code></pre>
","1887","<java><diffie-hellman>","0","0","1","2013-03-18 18:16:41","","2","","104223","","2013-03-18 18:16:41","2013-01-25 22:07:56",""
"17931487","Load certificate keys into CngKey class for use with DiffieHellman (ECDiffieHellmanCng class)","<p>This is related to .NET / C#. Lets assume there is a certificate + private key (P521 ECC one) inside a PFX or a PKCS#12 file. We have loaded this certificate and it's private key into the Windows certificate store by installing it (either double clicking the PFX or running <code>certutil -f -p myPfxPassword -importPFX MY SomeEcCert.pfx</code>). I have noted that if the certificate is compatible (eg. p521 curve), it is automatically installed as a CNG certificate/key.</p>

<p>Now, how can I load the private key into a CngKey so I can then use it inside the <code>ECDiffieHellmanCng</code> class? I would also like to load the X509 (CNG) certificate to read it's serial #, issuer, common name etc for some bookkeeping. </p>

<pre><code>var myCngKey = SomehowLoadTheCngKey(""my ecc certificate""); // &lt;== ??
var myDH = new ECDiffieHellmanCng(myCngKey);
</code></pre>
","<p>Well, .NET's doesn't have a good API into CNG. If you even scratch the surface of their API you immediately see it's kinda ridiculous, especially considering both are from Microsoft and CNG is the most serious of all Crypto APIs on the entire windows platform.</p>

<p>So you need to use <a href=""http://clrsecurity.codeplex.com/"" rel=""nofollow"">CLRSecurity</a> which provides C# interfaces (via P/Invoke) into the C++ CNG API. Even with that it's not the nicest of API designs; but it helps.</p>

<pre><code>// Load the cert, many ways, one implementation
var store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
store.Open(OpenFlags.OpenExistingOnly | OpenFlags.ReadOnly);
var certs = store.Certificates.Find(X509FindType.FindBySubjectName, ""My cert subject name"", true);
store.Close();

if (certs.Count &gt; 0)
    cert = certs[0];
else
    return;

// Magic happens here! We load the private CngKey (if it exists)
// You need CLR Security for this, it manages the P/Invoke
// into the C++ api behind the scenes. 
var pvtCngKey = cert.GetCngPrivateKey(); 

// Create the DiffieHellman helper
var ecDh = new ECDiffieHellmanCng(ourPvtEcCngKey)
{
   KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash,
   HashAlgorithm = CngAlgorithm.Sha256
};

ECDiffieHellmanCngPublicKey theirPubCngKey = LoadOtherPartiesCngPublicKey(theirCert);
byte[] symKey = ecDh.DeriveKeyMaterial(theirPubCngKey);
</code></pre>
","1857","<c#><encryption><public-key-encryption><diffie-hellman><cng>","3","1","1","2014-04-02 18:23:25","","0","","862563","","2013-08-09 01:28:36","2013-07-29 18:27:31",""
"29745760","Does JDK 1.8 support Cipher suites with Diffie-Hellman (DH) keys of size 4096 bits","<p>I want to know if <em>JDK 1.8</em> supports DH key length of 4096 bits. </p>

<p>Everywhere I searched, I found that <code>jdk.tls.ephemeralDHKeySize</code> can accept only <em>between 1024 and 2048 bits</em>. </p>

<p>I have to connect to a site which supports </p>

<blockquote>
  <p>""TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (0x9e)   DH 4096 bits (p: 512, g:
  1, Ys: 512)"".</p>
</blockquote>

<p>But I am getting </p>

<p>""Could not generate DH keypair"" Exception. </p>

<p>EDIT:</p>

<p>Adding a bit additional info,</p>

<p>I am using Apache httpclient-4.2.5 for connecting to the site. 
The server also supports </p>

<blockquote>
  <p>""TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 (0x9f) - 4096 bits"". </p>
</blockquote>

<p>When I use JDK 1.8 and try to connect the cipher suite is getting selected by the Server but JDK 1.8 is supporting only 2048 bits and my connection is failing. </p>

<p>EDIT:</p>

<p>Bouncy castle can be used as a workaround to support 4096 bits.
<a href=""http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6521495"" rel=""nofollow"">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6521495</a></p>
","<p>Apparently it works on Windows and OS X, but not on Linux. Don't ask why, all I know is Windows and OS X clients can connect via Java to servers with 4096 key size while Linux clients can't.</p>

<p><a href=""https://bugzilla.redhat.com/show_bug.cgi?id=1163501"" rel=""nofollow"">https://bugzilla.redhat.com/show_bug.cgi?id=1163501</a></p>

<p>It's not even fixed in Fedora yet, so it may take quite a while before it makes it into CentOS/RHEL.</p>
","1840","<ssl><java-8><apache-httpclient-4.x><diffie-hellman>","7","0","1","2015-06-25 07:30:58","","2","5","4809941","","2015-06-25 07:30:58","2015-04-20 10:47:40",""
"48436300","Disable Diffie-Hellman (DH) key in Ubuntu 16 and Nginx","<p>For website hosted in Ubuntu 16 with Nginx, SSL tests always shows B grade. Below  is the reason shown. See also the attached image.  Current SSL cipher settings are below.  I have noticed the same thing in around 8 to 10 servers I have with ubuntu 16 and Nginx. </p>

<pre><code>ssl_protocols TLSv1.2 TLSv1.1 TLSv1;
ssl_ciphers 'AES256+EECDH:AES256+EDH::!EECDH+aRSA+RC4:!RC4:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS';
ssl_session_cache shared:SSL:10m;
</code></pre>

<blockquote>
  <p>Diffie-Hellman (DH) key exchange parameters. Grade capped to B</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/r9tUv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r9tUv.png"" alt=""Qualys SSL Labs - SSL Server Test""></a></p>
","<p><a href=""https://mozilla.github.io/server-side-tls/ssl-config-generator/"" rel=""nofollow noreferrer"">The Mozilla SSL Configuration Generator</a> is the best way to properly configure your TLS setup.</p>
","1746","<ssl><nginx><ssl-certificate><ubuntu-16.04><diffie-hellman>","3","-2","2","2018-01-26 17:49:30","","0","1","3961903","","2018-01-25 06:09:04","2018-01-25 05:37:26",""
"48436300","Disable Diffie-Hellman (DH) key in Ubuntu 16 and Nginx","<p>For website hosted in Ubuntu 16 with Nginx, SSL tests always shows B grade. Below  is the reason shown. See also the attached image.  Current SSL cipher settings are below.  I have noticed the same thing in around 8 to 10 servers I have with ubuntu 16 and Nginx. </p>

<pre><code>ssl_protocols TLSv1.2 TLSv1.1 TLSv1;
ssl_ciphers 'AES256+EECDH:AES256+EDH::!EECDH+aRSA+RC4:!RC4:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS';
ssl_session_cache shared:SSL:10m;
</code></pre>

<blockquote>
  <p>Diffie-Hellman (DH) key exchange parameters. Grade capped to B</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/r9tUv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r9tUv.png"" alt=""Qualys SSL Labs - SSL Server Test""></a></p>
","<p>Finally I found the solution.  By default Linux  uses inbuilt DH provided by openssl. This uses weak key.  The solution is to generate our own.  Use the below to generate new one. I used 2048, you can also try 4096.</p>

<blockquote>
  <p>openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048</p>
</blockquote>

<p>Then add it to nginx main conf and reload.  Here we go. We now have A grade. </p>

<blockquote>
  <p>ssl_dhparam /etc/nginx/ssl/dhparam.pem;</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/25Aqd.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/25Aqd.png"" alt=""enter image description here""></a></p>

<p>Reference urls:- </p>

<p><a href=""https://michael.lustfield.net/nginx/getting-a-perfect-ssl-labs-score"" rel=""noreferrer"">https://michael.lustfield.net/nginx/getting-a-perfect-ssl-labs-score</a></p>

<p><a href=""https://geekflare.com/nginx-webserver-security-hardening-guide/"" rel=""noreferrer"">https://geekflare.com/nginx-webserver-security-hardening-guide/</a></p>
","1746","<ssl><nginx><ssl-certificate><ubuntu-16.04><diffie-hellman>","3","5","2","2018-01-26 17:49:30","","0","1","3961903","","2018-01-25 06:09:04","2018-01-25 05:37:26",""
"35616770","Derive Key with ECDiffieHellmanP256","<p>I am working on a project to integrate with the new <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Using_the_Push_API"">Push API</a> that exists in Firefox and is being developed as a W3C standard.</p>

<p>Part of this is encrypting the data. The server will receive a Diffie Hellman P256 Curve (Generated in JS using <code>var key = subscription.getKey('p256dh');</code>)</p>

<p>An example of this when converted to a .NET base64 is </p>

<blockquote>
  <p>BOAiqZO6ucAzDlZKKhF1aLjNpU8+R2Pfsz4bQzNpV145D+agNxvLqyu5Q2tLalK2w31RpoDHE8Sipo0m2jiX4WA=</p>
</blockquote>

<p>However I ran into issues generating the Derived Material.</p>

<pre><code>var key1 = Convert.FromBase64String(""&lt;stringFromAbove&gt;"").ToList() // You can criticize my .toList inefficiencies later

// .NET doesn't like the key without these prefixes. See here
// http://stackoverflow.com/questions/24251336/import-a-public-key-from-somewhere-else-to-cngkey
// I know the bytes don't match that post, but that is because the key type is different between their example and mine.
var keyType = new byte[] { 0x45, 0x43, 0x4B, 0x31 };
var keyLength = new byte[] { 0x20, 0x00, 0x00, 0x00 };
key1.RemoveAt(0);
key1 = keyType.Concat(keyLength).Concat(key1).ToList();

ECDiffieHellmanCng a = new ECDiffieHellmanCng();
a.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
// If I set this as CngAlgorithm.Sha256 it works, but that's not what Firefox gives me.
a.HashAlgorithm = CngAlgorithm.ECDiffieHellmanP256; 
a.KeySize = 256; // It complains if I don't add this since keys are different lengths.

// Now time to actually import the key
CngKey k = CngKey.Import(key1.ToArray(), CngKeyBlobFormat.EccPublicBlob); // Works successfully
byte[] derivedMaterial = a.DeriveKeyMaterial(k); // Exception Here
</code></pre>

<blockquote>
  <p>System.Security.Cryptography.CryptographicException: The requested operation is not supported.</p>
</blockquote>

<p>What do I not understand correctly (or on the more sad side, what is not implemented correctly (or at all) in windows/.NET)?</p>

<p>As an alternative, if somebody could explain how to port this <a href=""https://github.com/marco-c/web-push/blob/master/index.js"">Node JS library</a> to .NET that'd work too (I think that's a bit of a reach) </p>

<p><strong>Update</strong><br>
I needed to keep working through the rest of the problem and not be held up by the encryption, so I used a Node.JS Wrapper to allow for further development on the .NET side. The node code simply generates the local public key and the Shared secret and returns those values to me. I still need to get this working without the Node wrapper.</p>

<p>Because of this test I can confirm that the rest of the code (not included here) works, so the issue definitely lies in the code above (and my inability to generate the derived key material if the HashAlgorithm is specified as <code>CngAlgorithm.ECDiffieHellmanP256</code></p>
","<p><strong>This solution is only confirmed working on Windows 10 64-bit.</strong> It is confirmed not working on Windows 8.1 64 bit, and is untested on other platforms.</p>

<p>The problem is that <code>ECDiffieHellmanP256</code> is not a hash algorithm, but you are specifying to use a hash key derivation function. Your <code>KeyDerivationFunction</code> should be set to <code>ECDiffieHellmanKeyDerivationFunction.Tls</code>, and you need to specify the seed and label for the KDF.</p>

<p>Your fixed code looks like this:</p>

<pre><code>var key1 = Convert.FromBase64String(""BOAiqZO6ucAzDlZKKhF1aLjNpU8+R2Pfsz4bQzNpV145D+agNxvLqyu5Q2tLalK2w31RpoDHE8Sipo0m2jiX4WA="").ToList();
var keyType = new byte[] { 0x45, 0x43, 0x4B, 0x31 };
var keyLength = new byte[] { 0x20, 0x00, 0x00, 0x00 };
key1.RemoveAt(0);
key1 = keyType.Concat(keyLength).Concat(key1).ToList();

ECDiffieHellmanCng a = new ECDiffieHellmanCng();
a.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Tls;

byte[] label = new byte[32];
string labelStr = ""The purpose"";
Encoding.ASCII.GetBytes(labelStr, 0, labelStr.Length, label, 0);
a.Label = label;

byte[] seed = new byte[32];
RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
rng.GetBytes(seed);
a.Seed = seed;

a.HashAlgorithm = CngAlgorithm.ECDiffieHellmanP256;
a.KeySize = 256;

CngKey k = CngKey.Import(key1.ToArray(), CngKeyBlobFormat.EccPublicBlob);
byte[] derivedMaterial = a.DeriveKeyMaterial(k);
</code></pre>

<p>Note that I set a nonsense value to the <code>a.Label</code> property.</p>

<p>The <a href=""http://csrc.nist.gov/publications/nistpubs/800-108/sp800-108.pdf"" rel=""nofollow noreferrer"">NIST SP 800-108 publication</a> defines the label as:</p>

<blockquote>
  <p>Label – A string that identifies the purpose for the derived keying material, which is encoded as a binary string.</p>
</blockquote>

<p>I'm not sure what the purpose should be set to in your specific context. If anyone has a better understanding what this string should be, please leave a comment.</p>

<p>Also note that if you're going to call this function repeatedly, you should probably keep a persistent copy of the <code>RNGCryptoServiceProvider</code> and use that.</p>

<p>Thanks to a <a href=""https://stackoverflow.com/questions/35616770/derive-key-with-ecdiffiehellmanp256#comment59133696_35616770"">comment by Simon Mourier</a> which got me on the right track.</p>
","1736","<c#><elliptic-curve><diffie-hellman>","15","5","1","2016-03-04 00:08:32","35783393","13","1","2106228","","2016-02-27 21:31:36","2016-02-25 01:50:08",""
"6681549","Determining a Private Key (Diffie-Hellman)","<p>I've been given a challenge and it has to do with testing a friend's encryption process.</p>

<p>It's a Diffie-Hellman exchange process, and here are the known variables / constants: </p>

<ul>
<li><code>P</code>, <code>G</code> </li>
<li>my generated private key (variable)</li>
<li>my generated public key(variable)</li>
<li>the recipients public key (constant). </li>
</ul>

<p>When looking at my private key - <code>P</code> and <code>G</code> are both within it. For example, the first 'x' bytes seem to have no relation to anything, then the next 'y' bytes are <code>P</code>, the next two bytes are static, and the next 'z' bytes are <code>G</code>, the remainder are variable.</p>

<p>The process is to encrypt a file, and send it to a device, which will in turn decrypt it - my ideas of attack are this:</p>

<ol>
<li><p>try to duplicate the secret shared key. The problem here is that is fine as long as I know my generated private key, at which case - I don't for the files he's given me.</p></li>
<li><p>Try to find the recipients private key. Here, I could brute force my way in - but would take forever unless I had some sort of supercomputer.</p></li>
</ol>

<p>Are there any other options to look at when trying to attack this?</p>
","<p>I probably should keep my mouth shut, but it is also an opportunity for those interested in Diffie-Hellman to learn something:</p>

<ol>
<li><p>Simple implementation of Diffie-Hellman to generate the shared key is vulnerable to man-in-the-middle attacks. However, most implementation of DH tackle this issue properly by adding authentication between Alice and Bob.</p></li>
<li><p>If your implementation of DH allows declaring a new set of PQG, you could request the other peer to use a new weak set. If Bob does not verify the quality of this set, then it is vulnerable to attacks.</p></li>
<li><p>DH requires Alice to send X = g^x, if Bob does not check the quality of X, he is vulnerable, since the space of possible values of the secret key can significantly be reduced by Eve in the middle.</p></li>
<li><p>If your implementation does not remember compromised keys, they can be re-used by Eve.</p></li>
<li><p>If your implementation does not remember compromised certificates, they can be re-used by Eve.</p></li>
<li><p>If your implementation does not check certificates, Eve will have fun for sure.</p></li>
</ol>
","1726","<java><diffie-hellman>","4","2","1","2011-08-05 17:15:27","","2","","419","","2011-07-14 23:16:01","2011-07-13 15:37:39",""
"36353025","Java JVM Hotspot ephemeralDHKeySize","<p>I am trying to increase the DH key size from 1024 bits to 2048 bits, as per this question: <a href=""https://stackoverflow.com/questions/24502672/how-to-expand-dh-key-size-to-2048-in-java-8"">How to expand DH key size to 2048 in java 8</a>.</p>

<p>However, it does not seem to work. Relevant information:</p>

<pre><code>java -version
java version ""1.8.0_45"" 
Java(TM) SE Runtime Environment (build 1.8.0_45-b14) 
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
</code></pre>

<p>And</p>

<pre><code>System.out.println(Security.getProperty(""jdk.tls.ephemeralDHKeySize""));
2048
</code></pre>

<p>However, if I connect to that server from a client, it uses 1024-bit:</p>

<pre><code>openssl s_client -connect server:port -cipher ""EDH"" 2&gt;/dev/null | grep -ie ""Server .* key""
Server Temp Key: DH, 1024 bits
</code></pre>

<p>Any idea what else I can do?</p>
","<p>I'm concerned that you're calling <code>Security.getProperty(""jdk.tls.ephemeralDHKeySize"")</code> to check the DH key size. The <code>jdk.tls.ephemeralDHKeySize</code> property is not a <em>Security</em> property, it's a <em>System</em> property, which leads me to suspect that you're not setting it properly. If you're setting it like this:</p>

<pre><code>Security.setProperty(""jdk.tls.ephemeralDHKeySize"", ""2048""); // don't do this
</code></pre>

<p>then that's not going to work. Try either passing:</p>

<pre><code>-Djdk.tls.ephemeralDHKeySize=2048
</code></pre>

<p>in the command-line of your program, or set it like this:</p>

<pre><code>System.setProperty(""jdk.tls.ephemeralDHKeySize"", ""2048"");
</code></pre>

<p>in code. </p>
","1685","<java><diffie-hellman>","4","1","1","2016-04-03 17:54:51","36388986","7","","-1","","2017-05-23 10:27:27","2016-04-01 09:44:48",""
"17491812","Man in the middle attack in LAN","<p>I am pretty new in this kind of things.</p>

<p>I have a local area network, accessed by some users via cable some and via wifi others.
I have developed a local application in php which receives only some of the LAN clients as authentic users; they can be identified by the system with an algorithm of key exchange similar to Diffie–Hellman's, to estabilish a secret key. The client then asks to be identified throug such a channel.</p>

<p>The problem is, MITM attack is possible in this kind of situation. I read wikipedia about how such an attack is executed: somebody listens the messages of the two, and puts himself between them creating two different secret keys for the client and server.</p>

<p>This attack is reality, so it must be possible; but I do not understand how it happens in a LAN: 
the attacker can listen to the messages, and inject message of his own, impersoning the two subjects of the communications by forging https' IP fields if necessary... 
But he can't prevent the original unforged message to reach, concurrently (but also later, because of forging process taking the attacker computer some time) with his malevolent forged one, the recipient! Especially in a wifi connection, which cannot be cut off for a single user, for example cutting his cable.
So, client and server receive two different http requests from each other, a true and a forged one; isn't this a way for them to recognize that such an attack is in progress?</p>

<p>Maybe this question is newby-ous; as I said, I am pretty new at this.</p>
","<p>I think that is a scenario where you would use a digital signature (which also uses the idea that asymmetric encryption/Diffie-Hellman uses, that is ""public and private key"") to sign your messages. </p>

<p>The MITM attacker can not forge a message with a bad ""from"" and then sign it with the private signature of the original sender. The recipient uses the public part of the signature/certificate to validate the message. So that way he will not only know he is being attacked but also which message is genuine.</p>
","1612","<security><diffie-hellman><man-in-the-middle>","2","1","1","2013-07-05 15:22:24","17491948","1","","","","","2013-07-05 14:59:11",""
"18143476","Diffie-Hellman Library for c++ and java","<p>I want to exchange a public key between a c++ application and and android application.
I decided to use <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""nofollow"">Diffie-Hellman</a>. On the C++ side <a href=""http://www.codeproject.com/Articles/70330/Implementation-of-Diffie-Hellman-Algorithm-of-Key"" rel=""nofollow"">this</a> library looks promising for generating the keys with c++. Now I am looking for an implementation for java to generate the keys on the android smartphone. </p>

<p>What libraries would you suggest, also on the c++ side?
In the end i want to share the public key as a string via UDP.</p>

<p>kind regards </p>
","<p>A long time ago I used Crypto++ for the C++ which worked well for me and has support for many different algorithms.</p>

<p><a href=""http://www.cryptopp.com/"" rel=""nofollow"">http://www.cryptopp.com/</a></p>

<p>For android the KeyAgreement class can be used on some JavaVM, it is initialized with a String to choose the algorithm. You could try to instantiate it with ""DiffieHellman"" and see if you get an instance.</p>

<p>According to Java7 docs, <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/KeyAgreement.html"" rel=""nofollow"">http://docs.oracle.com/javase/7/docs/api/javax/crypto/KeyAgreement.html</a> - 
""<em>Every implementation of the Java platform is required to support the following standard KeyAgreement algorithm:
DiffieHellman</em>""</p>

<p>Test it and see if that includes dalvik or not.</p>
","1582","<java><android><c++><diffie-hellman>","1","2","1","2013-08-09 09:42:16","18143804","1","1","","","","2013-08-09 09:24:05",""
"12993410","Why does iOS 5 fail to connect to a server running JDK 1.6, but not JDK 1.5","<p>We have a Java Socket Server listening on an SSLSocket (port 443) and an iOS application that connects with it.  When running on <strong>iOS 5.1</strong>, the application stopped working when we upgraded the Java version of the server from <strong>JDK 1.5</strong> to <strong>1.6</strong> (or <strong>1.7</strong>). The app connects just fine to JDK 5 and 6 when running on iOS 6.</p>

<p>The iOS app is reporting an error:  <code>-9809 = errSSLCrypto</code>.  On the Java side, we get <code>javax.net.ssl.SSLException: Received fatal alert: close_notify</code>.  </p>

<p>On the Java server side, we have enabled all the available cipher suites.  On the client side we have tested enabling several different suites, although we have yet to complete a test involving each one individually enabled.  Right now, it is failing when we use <code>TLS_DH_anon_WITH_AES_128_CBC_SHA</code> although it has failed with others and we are starting to think it's not the suite. </p>

<p>Here is the debug output.  It makes it all the way to <code>ServerHelloDone</code> and then fails shortly thereafter:</p>

<pre><code>Is secure renegotiation: false
[Raw read]: length = 5
0000: 16 03 03 00 41                                     ....A
[Raw read]: length = 65
0000: 01 00 00 3D 03 03 50 83   1E 0B 56 19 25 65 C8 F2  ...=..P...V.%e..
0010: AF 02 AD 48 FE E2 92 CF   B8 D7 A6 A3 EA C5 FF 5D  ...H...........]
0020: 74 0F 1B C1 99 18 00 00   08 00 FF 00 34 00 1B 00  t...........4...
0030: 18 01 00 00 0C 00 0D 00   08 00 06 05 01 04 01 02  ................
0040: 01                                                 .
URT-, READ: Unknown-3.3 Handshake, length = 65
*** ClientHello, Unknown-3.3
RandomCookie:  GMT: 1333992971 bytes = { 86, 25, 37, 101, 200, 242, 175, 2, 173, 72, 254, 226, 146, 207, 184, 215, 166, 163, 234, 197, 255, 93, 116, 15, 27, 193, 153, 24 }
Session ID:  {}
Cipher Suites: [TLS_EMPTY_RENEGOTIATION_INFO_SCSV, TLS_DH_anon_WITH_AES_128_CBC_SHA, SSL_DH_anon_WITH_3DES_EDE_CBC_SHA, SSL_DH_anon_WITH_RC4_128_MD5]
Compression Methods:  { 0 }
Unsupported extension signature_algorithms, data: 00:06:05:01:04:01:02:01
***
[read] MD5 and SHA1 hashes:  len = 65
0000: 01 00 00 3D 03 03 50 83   1E 0B 56 19 25 65 C8 F2  ...=..P...V.%e..
0010: AF 02 AD 48 FE E2 92 CF   B8 D7 A6 A3 EA C5 FF 5D  ...H...........]
0020: 74 0F 1B C1 99 18 00 00   08 00 FF 00 34 00 1B 00  t...........4...
0030: 18 01 00 00 0C 00 0D 00   08 00 06 05 01 04 01 02  ................
0040: 01                                                 .
%% Created:  [Session-1, TLS_DH_anon_WITH_AES_128_CBC_SHA]
*** ServerHello, TLSv1
RandomCookie:  GMT: 1333992972 bytes = { 100, 3, 56, 153, 7, 2, 251, 64, 41, 32, 66, 240, 227, 181, 55, 190, 2, 237, 146, 0, 73, 119, 70, 0, 160, 9, 28, 207 }
Session ID:  {80, 131, 30, 12, 241, 73, 52, 38, 46, 41, 237, 226, 199, 246, 156, 45, 3, 247, 182, 43, 223, 8, 49, 169, 188, 63, 160, 41, 102, 199, 50, 190}
Cipher Suite: TLS_DH_anon_WITH_AES_128_CBC_SHA
Compression Method: 0
Extension renegotiation_info, renegotiated_connection: &lt;empty&gt;
***
Cipher suite:  TLS_DH_anon_WITH_AES_128_CBC_SHA
*** Diffie-Hellman ServerKeyExchange
DH Modulus:  { 233, 230, 66, 89, 157, 53, 95, 55, 201, 127, 253, 53, 103, 18, 11, 142, 37, 201, 205, 67, 233, 39, 179, 169, 103, 15, 190, 197, 216, 144, 20, 25, 34, 210, 195, 179, 173, 36, 128, 9, 55, 153, 134, 157, 30, 132, 106, 171, 73, 250, 176, 173, 38, 210, 206, 106, 34, 33, 157, 71, 11, 206, 125, 119, 125, 74, 33, 251, 233, 194, 112, 181, 127, 96, 112, 2, 243, 206, 248, 57, 54, 148, 207, 69, 238, 54, 136, 193, 26, 140, 86, 171, 18, 122, 61, 175 }
DH Base:  { 48, 71, 10, 213, 160, 5, 251, 20, 206, 45, 157, 205, 135, 227, 139, 199, 209, 177, 197, 250, 203, 174, 203, 233, 95, 25, 10, 167, 163, 29, 35, 196, 219, 188, 190, 6, 23, 69, 68, 64, 26, 91, 44, 2, 9, 101, 216, 194, 189, 33, 113, 211, 102, 132, 69, 119, 31, 116, 186, 8, 77, 32, 41, 216, 60, 28, 21, 133, 71, 243, 169, 241, 162, 113, 91, 226, 61, 81, 174, 77, 62, 90, 31, 106, 112, 100, 243, 22, 147, 58, 52, 109, 63, 82, 146, 82 }
Server DH Public Key:  { 8, 60, 59, 13, 224, 110, 32, 168, 116, 139, 246, 146, 15, 12, 216, 107, 82, 182, 140, 80, 193, 237, 159, 189, 87, 34, 18, 197, 181, 252, 26, 27, 94, 160, 188, 162, 30, 29, 165, 165, 68, 152, 11, 204, 251, 187, 14, 233, 239, 103, 134, 168, 181, 173, 206, 151, 197, 128, 65, 239, 233, 191, 29, 196, 93, 80, 217, 55, 81, 240, 101, 31, 119, 98, 188, 211, 52, 146, 168, 127, 127, 66, 63, 111, 198, 134, 70, 213, 31, 162, 146, 25, 178, 79, 56, 116 }
Anonymous
*** ServerHelloDone
[write] MD5 and SHA1 hashes:  len = 383
0000: 02 00 00 4D 03 01 50 83   1E 0C 64 03 38 99 07 02  ...M..P...d.8...
0010: FB 40 29 20 42 F0 E3 B5   37 BE 02 ED 92 00 49 77  .@) B...7.....Iw
0020: 46 00 A0 09 1C CF 20 50   83 1E 0C F1 49 34 26 2E  F..... P....I4&amp;.
0030: 29 ED E2 C7 F6 9C 2D 03   F7 B6 2B DF 08 31 A9 BC  ).....-...+..1..
0040: 3F A0 29 66 C7 32 BE 00   34 00 00 05 FF 01 00 01  ?.)f.2..4.......
0050: 00 0C 00 01 26 00 60 E9   E6 42 59 9D 35 5F 37 C9  ....&amp;.`..BY.5_7.
0060: 7F FD 35 67 12 0B 8E 25   C9 CD 43 E9 27 B3 A9 67  ..5g...%..C.'..g
0070: 0F BE C5 D8 90 14 19 22   D2 C3 B3 AD 24 80 09 37  .......""....$..7
0080: 99 86 9D 1E 84 6A AB 49   FA B0 AD 26 D2 CE 6A 22  .....j.I...&amp;..j""
0090: 21 9D 47 0B CE 7D 77 7D   4A 21 FB E9 C2 70 B5 7F  !.G...w.J!...p..
00A0: 60 70 02 F3 CE F8 39 36   94 CF 45 EE 36 88 C1 1A  `p....96..E.6...
00B0: 8C 56 AB 12 7A 3D AF 00   60 30 47 0A D5 A0 05 FB  .V..z=..`0G.....
00C0: 14 CE 2D 9D CD 87 E3 8B   C7 D1 B1 C5 FA CB AE CB  ..-.............
00D0: E9 5F 19 0A A7 A3 1D 23   C4 DB BC BE 06 17 45 44  ._.....#......ED
00E0: 40 1A 5B 2C 02 09 65 D8   C2 BD 21 71 D3 66 84 45  @.[,..e...!q.f.E
00F0: 77 1F 74 BA 08 4D 20 29   D8 3C 1C 15 85 47 F3 A9  w.t..M ).&lt;...G..
0100: F1 A2 71 5B E2 3D 51 AE   4D 3E 5A 1F 6A 70 64 F3  ..q[.=Q.M&gt;Z.jpd.
0110: 16 93 3A 34 6D 3F 52 92   52 00 60 08 3C 3B 0D E0  ..:4m?R.R.`.&lt;;..
0120: 6E 20 A8 74 8B F6 92 0F   0C D8 6B 52 B6 8C 50 C1  n .t......kR..P.
0130: ED 9F BD 57 22 12 C5 B5   FC 1A 1B 5E A0 BC A2 1E  ...W""......^....
0140: 1D A5 A5 44 98 0B CC FB   BB 0E E9 EF 67 86 A8 B5  ...D........g...
0150: AD CE 97 C5 80 41 EF E9   BF 1D C4 5D 50 D9 37 51  .....A.....]P.7Q
0160: F0 65 1F 77 62 BC D3 34   92 A8 7F 7F 42 3F 6F C6  .e.wb..4....B?o.
0170: 86 46 D5 1F A2 92 19 B2   4F 38 74 0E 00 00 00     .F......O8t....
URT-, WRITE: TLSv1 Handshake, length = 383
[Raw write]: length = 388
0000: 16 03 01 01 7F 02 00 00   4D 03 01 50 83 1E 0C 64  ........M..P...d
0010: 03 38 99 07 02 FB 40 29   20 42 F0 E3 B5 37 BE 02  .8....@) B...7..
0020: ED 92 00 49 77 46 00 A0   09 1C CF 20 50 83 1E 0C  ...IwF..... P...
0030: F1 49 34 26 2E 29 ED E2   C7 F6 9C 2D 03 F7 B6 2B  .I4&amp;.).....-...+
0040: DF 08 31 A9 BC 3F A0 29   66 C7 32 BE 00 34 00 00  ..1..?.)f.2..4..
0050: 05 FF 01 00 01 00 0C 00   01 26 00 60 E9 E6 42 59  .........&amp;.`..BY
0060: 9D 35 5F 37 C9 7F FD 35   67 12 0B 8E 25 C9 CD 43  .5_7...5g...%..C
0070: E9 27 B3 A9 67 0F BE C5   D8 90 14 19 22 D2 C3 B3  .'..g.......""...
0080: AD 24 80 09 37 99 86 9D   1E 84 6A AB 49 FA B0 AD  .$..7.....j.I...
0090: 26 D2 CE 6A 22 21 9D 47   0B CE 7D 77 7D 4A 21 FB  &amp;..j""!.G...w.J!.
00A0: E9 C2 70 B5 7F 60 70 02   F3 CE F8 39 36 94 CF 45  ..p..`p....96..E
00B0: EE 36 88 C1 1A 8C 56 AB   12 7A 3D AF 00 60 30 47  .6....V..z=..`0G
00C0: 0A D5 A0 05 FB 14 CE 2D   9D CD 87 E3 8B C7 D1 B1  .......-........
00D0: C5 FA CB AE CB E9 5F 19   0A A7 A3 1D 23 C4 DB BC  ......_.....#...
00E0: BE 06 17 45 44 40 1A 5B   2C 02 09 65 D8 C2 BD 21  ...ED@.[,..e...!
00F0: 71 D3 66 84 45 77 1F 74   BA 08 4D 20 29 D8 3C 1C  q.f.Ew.t..M ).&lt;.
0100: 15 85 47 F3 A9 F1 A2 71   5B E2 3D 51 AE 4D 3E 5A  ..G....q[.=Q.M&gt;Z
0110: 1F 6A 70 64 F3 16 93 3A   34 6D 3F 52 92 52 00 60  .jpd...:4m?R.R.`
0120: 08 3C 3B 0D E0 6E 20 A8   74 8B F6 92 0F 0C D8 6B  .&lt;;..n .t......k
0130: 52 B6 8C 50 C1 ED 9F BD   57 22 12 C5 B5 FC 1A 1B  R..P....W""......
0140: 5E A0 BC A2 1E 1D A5 A5   44 98 0B CC FB BB 0E E9  ^.......D.......
0150: EF 67 86 A8 B5 AD CE 97   C5 80 41 EF E9 BF 1D C4  .g........A.....
0160: 5D 50 D9 37 51 F0 65 1F   77 62 BC D3 34 92 A8 7F  ]P.7Q.e.wb..4...
0170: 7F 42 3F 6F C6 86 46 D5   1F A2 92 19 B2 4F 38 74  .B?o..F......O8t
0180: 0E 00 00 00                                        ....
[Raw read]: length = 5
0000: 15 03 01 00 02                                     .....
[Raw read]: length = 2
0000: 02 00                                              ..
URT-, READ: TLSv1 Alert, length = 2
URT-, RECV TLSv1 ALERT:  fatal, close_notify
URT-, called closeSocket()
URT-, handling exception: javax.net.ssl.SSLException: Received fatal alert: close_notify
</code></pre>

<p>FYI, this works in iOS 6.0</p>
","<p>Have you tried exporting a ""new"" self signed certificate from the Java server and import to the trust store of your app/OS?</p>
","1537","<java><ios5><ssl><jsse><diffie-hellman>","21","1","3","2013-12-14 02:13:24","","7","1","1262634","","2013-06-25 16:04:00","2012-10-20 22:54:09",""
"12993410","Why does iOS 5 fail to connect to a server running JDK 1.6, but not JDK 1.5","<p>We have a Java Socket Server listening on an SSLSocket (port 443) and an iOS application that connects with it.  When running on <strong>iOS 5.1</strong>, the application stopped working when we upgraded the Java version of the server from <strong>JDK 1.5</strong> to <strong>1.6</strong> (or <strong>1.7</strong>). The app connects just fine to JDK 5 and 6 when running on iOS 6.</p>

<p>The iOS app is reporting an error:  <code>-9809 = errSSLCrypto</code>.  On the Java side, we get <code>javax.net.ssl.SSLException: Received fatal alert: close_notify</code>.  </p>

<p>On the Java server side, we have enabled all the available cipher suites.  On the client side we have tested enabling several different suites, although we have yet to complete a test involving each one individually enabled.  Right now, it is failing when we use <code>TLS_DH_anon_WITH_AES_128_CBC_SHA</code> although it has failed with others and we are starting to think it's not the suite. </p>

<p>Here is the debug output.  It makes it all the way to <code>ServerHelloDone</code> and then fails shortly thereafter:</p>

<pre><code>Is secure renegotiation: false
[Raw read]: length = 5
0000: 16 03 03 00 41                                     ....A
[Raw read]: length = 65
0000: 01 00 00 3D 03 03 50 83   1E 0B 56 19 25 65 C8 F2  ...=..P...V.%e..
0010: AF 02 AD 48 FE E2 92 CF   B8 D7 A6 A3 EA C5 FF 5D  ...H...........]
0020: 74 0F 1B C1 99 18 00 00   08 00 FF 00 34 00 1B 00  t...........4...
0030: 18 01 00 00 0C 00 0D 00   08 00 06 05 01 04 01 02  ................
0040: 01                                                 .
URT-, READ: Unknown-3.3 Handshake, length = 65
*** ClientHello, Unknown-3.3
RandomCookie:  GMT: 1333992971 bytes = { 86, 25, 37, 101, 200, 242, 175, 2, 173, 72, 254, 226, 146, 207, 184, 215, 166, 163, 234, 197, 255, 93, 116, 15, 27, 193, 153, 24 }
Session ID:  {}
Cipher Suites: [TLS_EMPTY_RENEGOTIATION_INFO_SCSV, TLS_DH_anon_WITH_AES_128_CBC_SHA, SSL_DH_anon_WITH_3DES_EDE_CBC_SHA, SSL_DH_anon_WITH_RC4_128_MD5]
Compression Methods:  { 0 }
Unsupported extension signature_algorithms, data: 00:06:05:01:04:01:02:01
***
[read] MD5 and SHA1 hashes:  len = 65
0000: 01 00 00 3D 03 03 50 83   1E 0B 56 19 25 65 C8 F2  ...=..P...V.%e..
0010: AF 02 AD 48 FE E2 92 CF   B8 D7 A6 A3 EA C5 FF 5D  ...H...........]
0020: 74 0F 1B C1 99 18 00 00   08 00 FF 00 34 00 1B 00  t...........4...
0030: 18 01 00 00 0C 00 0D 00   08 00 06 05 01 04 01 02  ................
0040: 01                                                 .
%% Created:  [Session-1, TLS_DH_anon_WITH_AES_128_CBC_SHA]
*** ServerHello, TLSv1
RandomCookie:  GMT: 1333992972 bytes = { 100, 3, 56, 153, 7, 2, 251, 64, 41, 32, 66, 240, 227, 181, 55, 190, 2, 237, 146, 0, 73, 119, 70, 0, 160, 9, 28, 207 }
Session ID:  {80, 131, 30, 12, 241, 73, 52, 38, 46, 41, 237, 226, 199, 246, 156, 45, 3, 247, 182, 43, 223, 8, 49, 169, 188, 63, 160, 41, 102, 199, 50, 190}
Cipher Suite: TLS_DH_anon_WITH_AES_128_CBC_SHA
Compression Method: 0
Extension renegotiation_info, renegotiated_connection: &lt;empty&gt;
***
Cipher suite:  TLS_DH_anon_WITH_AES_128_CBC_SHA
*** Diffie-Hellman ServerKeyExchange
DH Modulus:  { 233, 230, 66, 89, 157, 53, 95, 55, 201, 127, 253, 53, 103, 18, 11, 142, 37, 201, 205, 67, 233, 39, 179, 169, 103, 15, 190, 197, 216, 144, 20, 25, 34, 210, 195, 179, 173, 36, 128, 9, 55, 153, 134, 157, 30, 132, 106, 171, 73, 250, 176, 173, 38, 210, 206, 106, 34, 33, 157, 71, 11, 206, 125, 119, 125, 74, 33, 251, 233, 194, 112, 181, 127, 96, 112, 2, 243, 206, 248, 57, 54, 148, 207, 69, 238, 54, 136, 193, 26, 140, 86, 171, 18, 122, 61, 175 }
DH Base:  { 48, 71, 10, 213, 160, 5, 251, 20, 206, 45, 157, 205, 135, 227, 139, 199, 209, 177, 197, 250, 203, 174, 203, 233, 95, 25, 10, 167, 163, 29, 35, 196, 219, 188, 190, 6, 23, 69, 68, 64, 26, 91, 44, 2, 9, 101, 216, 194, 189, 33, 113, 211, 102, 132, 69, 119, 31, 116, 186, 8, 77, 32, 41, 216, 60, 28, 21, 133, 71, 243, 169, 241, 162, 113, 91, 226, 61, 81, 174, 77, 62, 90, 31, 106, 112, 100, 243, 22, 147, 58, 52, 109, 63, 82, 146, 82 }
Server DH Public Key:  { 8, 60, 59, 13, 224, 110, 32, 168, 116, 139, 246, 146, 15, 12, 216, 107, 82, 182, 140, 80, 193, 237, 159, 189, 87, 34, 18, 197, 181, 252, 26, 27, 94, 160, 188, 162, 30, 29, 165, 165, 68, 152, 11, 204, 251, 187, 14, 233, 239, 103, 134, 168, 181, 173, 206, 151, 197, 128, 65, 239, 233, 191, 29, 196, 93, 80, 217, 55, 81, 240, 101, 31, 119, 98, 188, 211, 52, 146, 168, 127, 127, 66, 63, 111, 198, 134, 70, 213, 31, 162, 146, 25, 178, 79, 56, 116 }
Anonymous
*** ServerHelloDone
[write] MD5 and SHA1 hashes:  len = 383
0000: 02 00 00 4D 03 01 50 83   1E 0C 64 03 38 99 07 02  ...M..P...d.8...
0010: FB 40 29 20 42 F0 E3 B5   37 BE 02 ED 92 00 49 77  .@) B...7.....Iw
0020: 46 00 A0 09 1C CF 20 50   83 1E 0C F1 49 34 26 2E  F..... P....I4&amp;.
0030: 29 ED E2 C7 F6 9C 2D 03   F7 B6 2B DF 08 31 A9 BC  ).....-...+..1..
0040: 3F A0 29 66 C7 32 BE 00   34 00 00 05 FF 01 00 01  ?.)f.2..4.......
0050: 00 0C 00 01 26 00 60 E9   E6 42 59 9D 35 5F 37 C9  ....&amp;.`..BY.5_7.
0060: 7F FD 35 67 12 0B 8E 25   C9 CD 43 E9 27 B3 A9 67  ..5g...%..C.'..g
0070: 0F BE C5 D8 90 14 19 22   D2 C3 B3 AD 24 80 09 37  .......""....$..7
0080: 99 86 9D 1E 84 6A AB 49   FA B0 AD 26 D2 CE 6A 22  .....j.I...&amp;..j""
0090: 21 9D 47 0B CE 7D 77 7D   4A 21 FB E9 C2 70 B5 7F  !.G...w.J!...p..
00A0: 60 70 02 F3 CE F8 39 36   94 CF 45 EE 36 88 C1 1A  `p....96..E.6...
00B0: 8C 56 AB 12 7A 3D AF 00   60 30 47 0A D5 A0 05 FB  .V..z=..`0G.....
00C0: 14 CE 2D 9D CD 87 E3 8B   C7 D1 B1 C5 FA CB AE CB  ..-.............
00D0: E9 5F 19 0A A7 A3 1D 23   C4 DB BC BE 06 17 45 44  ._.....#......ED
00E0: 40 1A 5B 2C 02 09 65 D8   C2 BD 21 71 D3 66 84 45  @.[,..e...!q.f.E
00F0: 77 1F 74 BA 08 4D 20 29   D8 3C 1C 15 85 47 F3 A9  w.t..M ).&lt;...G..
0100: F1 A2 71 5B E2 3D 51 AE   4D 3E 5A 1F 6A 70 64 F3  ..q[.=Q.M&gt;Z.jpd.
0110: 16 93 3A 34 6D 3F 52 92   52 00 60 08 3C 3B 0D E0  ..:4m?R.R.`.&lt;;..
0120: 6E 20 A8 74 8B F6 92 0F   0C D8 6B 52 B6 8C 50 C1  n .t......kR..P.
0130: ED 9F BD 57 22 12 C5 B5   FC 1A 1B 5E A0 BC A2 1E  ...W""......^....
0140: 1D A5 A5 44 98 0B CC FB   BB 0E E9 EF 67 86 A8 B5  ...D........g...
0150: AD CE 97 C5 80 41 EF E9   BF 1D C4 5D 50 D9 37 51  .....A.....]P.7Q
0160: F0 65 1F 77 62 BC D3 34   92 A8 7F 7F 42 3F 6F C6  .e.wb..4....B?o.
0170: 86 46 D5 1F A2 92 19 B2   4F 38 74 0E 00 00 00     .F......O8t....
URT-, WRITE: TLSv1 Handshake, length = 383
[Raw write]: length = 388
0000: 16 03 01 01 7F 02 00 00   4D 03 01 50 83 1E 0C 64  ........M..P...d
0010: 03 38 99 07 02 FB 40 29   20 42 F0 E3 B5 37 BE 02  .8....@) B...7..
0020: ED 92 00 49 77 46 00 A0   09 1C CF 20 50 83 1E 0C  ...IwF..... P...
0030: F1 49 34 26 2E 29 ED E2   C7 F6 9C 2D 03 F7 B6 2B  .I4&amp;.).....-...+
0040: DF 08 31 A9 BC 3F A0 29   66 C7 32 BE 00 34 00 00  ..1..?.)f.2..4..
0050: 05 FF 01 00 01 00 0C 00   01 26 00 60 E9 E6 42 59  .........&amp;.`..BY
0060: 9D 35 5F 37 C9 7F FD 35   67 12 0B 8E 25 C9 CD 43  .5_7...5g...%..C
0070: E9 27 B3 A9 67 0F BE C5   D8 90 14 19 22 D2 C3 B3  .'..g.......""...
0080: AD 24 80 09 37 99 86 9D   1E 84 6A AB 49 FA B0 AD  .$..7.....j.I...
0090: 26 D2 CE 6A 22 21 9D 47   0B CE 7D 77 7D 4A 21 FB  &amp;..j""!.G...w.J!.
00A0: E9 C2 70 B5 7F 60 70 02   F3 CE F8 39 36 94 CF 45  ..p..`p....96..E
00B0: EE 36 88 C1 1A 8C 56 AB   12 7A 3D AF 00 60 30 47  .6....V..z=..`0G
00C0: 0A D5 A0 05 FB 14 CE 2D   9D CD 87 E3 8B C7 D1 B1  .......-........
00D0: C5 FA CB AE CB E9 5F 19   0A A7 A3 1D 23 C4 DB BC  ......_.....#...
00E0: BE 06 17 45 44 40 1A 5B   2C 02 09 65 D8 C2 BD 21  ...ED@.[,..e...!
00F0: 71 D3 66 84 45 77 1F 74   BA 08 4D 20 29 D8 3C 1C  q.f.Ew.t..M ).&lt;.
0100: 15 85 47 F3 A9 F1 A2 71   5B E2 3D 51 AE 4D 3E 5A  ..G....q[.=Q.M&gt;Z
0110: 1F 6A 70 64 F3 16 93 3A   34 6D 3F 52 92 52 00 60  .jpd...:4m?R.R.`
0120: 08 3C 3B 0D E0 6E 20 A8   74 8B F6 92 0F 0C D8 6B  .&lt;;..n .t......k
0130: 52 B6 8C 50 C1 ED 9F BD   57 22 12 C5 B5 FC 1A 1B  R..P....W""......
0140: 5E A0 BC A2 1E 1D A5 A5   44 98 0B CC FB BB 0E E9  ^.......D.......
0150: EF 67 86 A8 B5 AD CE 97   C5 80 41 EF E9 BF 1D C4  .g........A.....
0160: 5D 50 D9 37 51 F0 65 1F   77 62 BC D3 34 92 A8 7F  ]P.7Q.e.wb..4...
0170: 7F 42 3F 6F C6 86 46 D5   1F A2 92 19 B2 4F 38 74  .B?o..F......O8t
0180: 0E 00 00 00                                        ....
[Raw read]: length = 5
0000: 15 03 01 00 02                                     .....
[Raw read]: length = 2
0000: 02 00                                              ..
URT-, READ: TLSv1 Alert, length = 2
URT-, RECV TLSv1 ALERT:  fatal, close_notify
URT-, called closeSocket()
URT-, handling exception: javax.net.ssl.SSLException: Received fatal alert: close_notify
</code></pre>

<p>FYI, this works in iOS 6.0</p>
","<p>May I suggest to use Apache or another HTTP(S) Server in front of your Java application Server? Just thinking into the future perhaps your application will not have Java serving directly all requests anyway (think about TLS security fixes, load balancing, failover etc). My two cents.</p>
","1537","<java><ios5><ssl><jsse><diffie-hellman>","21","0","3","2013-12-14 02:13:24","","7","1","1262634","","2013-06-25 16:04:00","2012-10-20 22:54:09",""
"12993410","Why does iOS 5 fail to connect to a server running JDK 1.6, but not JDK 1.5","<p>We have a Java Socket Server listening on an SSLSocket (port 443) and an iOS application that connects with it.  When running on <strong>iOS 5.1</strong>, the application stopped working when we upgraded the Java version of the server from <strong>JDK 1.5</strong> to <strong>1.6</strong> (or <strong>1.7</strong>). The app connects just fine to JDK 5 and 6 when running on iOS 6.</p>

<p>The iOS app is reporting an error:  <code>-9809 = errSSLCrypto</code>.  On the Java side, we get <code>javax.net.ssl.SSLException: Received fatal alert: close_notify</code>.  </p>

<p>On the Java server side, we have enabled all the available cipher suites.  On the client side we have tested enabling several different suites, although we have yet to complete a test involving each one individually enabled.  Right now, it is failing when we use <code>TLS_DH_anon_WITH_AES_128_CBC_SHA</code> although it has failed with others and we are starting to think it's not the suite. </p>

<p>Here is the debug output.  It makes it all the way to <code>ServerHelloDone</code> and then fails shortly thereafter:</p>

<pre><code>Is secure renegotiation: false
[Raw read]: length = 5
0000: 16 03 03 00 41                                     ....A
[Raw read]: length = 65
0000: 01 00 00 3D 03 03 50 83   1E 0B 56 19 25 65 C8 F2  ...=..P...V.%e..
0010: AF 02 AD 48 FE E2 92 CF   B8 D7 A6 A3 EA C5 FF 5D  ...H...........]
0020: 74 0F 1B C1 99 18 00 00   08 00 FF 00 34 00 1B 00  t...........4...
0030: 18 01 00 00 0C 00 0D 00   08 00 06 05 01 04 01 02  ................
0040: 01                                                 .
URT-, READ: Unknown-3.3 Handshake, length = 65
*** ClientHello, Unknown-3.3
RandomCookie:  GMT: 1333992971 bytes = { 86, 25, 37, 101, 200, 242, 175, 2, 173, 72, 254, 226, 146, 207, 184, 215, 166, 163, 234, 197, 255, 93, 116, 15, 27, 193, 153, 24 }
Session ID:  {}
Cipher Suites: [TLS_EMPTY_RENEGOTIATION_INFO_SCSV, TLS_DH_anon_WITH_AES_128_CBC_SHA, SSL_DH_anon_WITH_3DES_EDE_CBC_SHA, SSL_DH_anon_WITH_RC4_128_MD5]
Compression Methods:  { 0 }
Unsupported extension signature_algorithms, data: 00:06:05:01:04:01:02:01
***
[read] MD5 and SHA1 hashes:  len = 65
0000: 01 00 00 3D 03 03 50 83   1E 0B 56 19 25 65 C8 F2  ...=..P...V.%e..
0010: AF 02 AD 48 FE E2 92 CF   B8 D7 A6 A3 EA C5 FF 5D  ...H...........]
0020: 74 0F 1B C1 99 18 00 00   08 00 FF 00 34 00 1B 00  t...........4...
0030: 18 01 00 00 0C 00 0D 00   08 00 06 05 01 04 01 02  ................
0040: 01                                                 .
%% Created:  [Session-1, TLS_DH_anon_WITH_AES_128_CBC_SHA]
*** ServerHello, TLSv1
RandomCookie:  GMT: 1333992972 bytes = { 100, 3, 56, 153, 7, 2, 251, 64, 41, 32, 66, 240, 227, 181, 55, 190, 2, 237, 146, 0, 73, 119, 70, 0, 160, 9, 28, 207 }
Session ID:  {80, 131, 30, 12, 241, 73, 52, 38, 46, 41, 237, 226, 199, 246, 156, 45, 3, 247, 182, 43, 223, 8, 49, 169, 188, 63, 160, 41, 102, 199, 50, 190}
Cipher Suite: TLS_DH_anon_WITH_AES_128_CBC_SHA
Compression Method: 0
Extension renegotiation_info, renegotiated_connection: &lt;empty&gt;
***
Cipher suite:  TLS_DH_anon_WITH_AES_128_CBC_SHA
*** Diffie-Hellman ServerKeyExchange
DH Modulus:  { 233, 230, 66, 89, 157, 53, 95, 55, 201, 127, 253, 53, 103, 18, 11, 142, 37, 201, 205, 67, 233, 39, 179, 169, 103, 15, 190, 197, 216, 144, 20, 25, 34, 210, 195, 179, 173, 36, 128, 9, 55, 153, 134, 157, 30, 132, 106, 171, 73, 250, 176, 173, 38, 210, 206, 106, 34, 33, 157, 71, 11, 206, 125, 119, 125, 74, 33, 251, 233, 194, 112, 181, 127, 96, 112, 2, 243, 206, 248, 57, 54, 148, 207, 69, 238, 54, 136, 193, 26, 140, 86, 171, 18, 122, 61, 175 }
DH Base:  { 48, 71, 10, 213, 160, 5, 251, 20, 206, 45, 157, 205, 135, 227, 139, 199, 209, 177, 197, 250, 203, 174, 203, 233, 95, 25, 10, 167, 163, 29, 35, 196, 219, 188, 190, 6, 23, 69, 68, 64, 26, 91, 44, 2, 9, 101, 216, 194, 189, 33, 113, 211, 102, 132, 69, 119, 31, 116, 186, 8, 77, 32, 41, 216, 60, 28, 21, 133, 71, 243, 169, 241, 162, 113, 91, 226, 61, 81, 174, 77, 62, 90, 31, 106, 112, 100, 243, 22, 147, 58, 52, 109, 63, 82, 146, 82 }
Server DH Public Key:  { 8, 60, 59, 13, 224, 110, 32, 168, 116, 139, 246, 146, 15, 12, 216, 107, 82, 182, 140, 80, 193, 237, 159, 189, 87, 34, 18, 197, 181, 252, 26, 27, 94, 160, 188, 162, 30, 29, 165, 165, 68, 152, 11, 204, 251, 187, 14, 233, 239, 103, 134, 168, 181, 173, 206, 151, 197, 128, 65, 239, 233, 191, 29, 196, 93, 80, 217, 55, 81, 240, 101, 31, 119, 98, 188, 211, 52, 146, 168, 127, 127, 66, 63, 111, 198, 134, 70, 213, 31, 162, 146, 25, 178, 79, 56, 116 }
Anonymous
*** ServerHelloDone
[write] MD5 and SHA1 hashes:  len = 383
0000: 02 00 00 4D 03 01 50 83   1E 0C 64 03 38 99 07 02  ...M..P...d.8...
0010: FB 40 29 20 42 F0 E3 B5   37 BE 02 ED 92 00 49 77  .@) B...7.....Iw
0020: 46 00 A0 09 1C CF 20 50   83 1E 0C F1 49 34 26 2E  F..... P....I4&amp;.
0030: 29 ED E2 C7 F6 9C 2D 03   F7 B6 2B DF 08 31 A9 BC  ).....-...+..1..
0040: 3F A0 29 66 C7 32 BE 00   34 00 00 05 FF 01 00 01  ?.)f.2..4.......
0050: 00 0C 00 01 26 00 60 E9   E6 42 59 9D 35 5F 37 C9  ....&amp;.`..BY.5_7.
0060: 7F FD 35 67 12 0B 8E 25   C9 CD 43 E9 27 B3 A9 67  ..5g...%..C.'..g
0070: 0F BE C5 D8 90 14 19 22   D2 C3 B3 AD 24 80 09 37  .......""....$..7
0080: 99 86 9D 1E 84 6A AB 49   FA B0 AD 26 D2 CE 6A 22  .....j.I...&amp;..j""
0090: 21 9D 47 0B CE 7D 77 7D   4A 21 FB E9 C2 70 B5 7F  !.G...w.J!...p..
00A0: 60 70 02 F3 CE F8 39 36   94 CF 45 EE 36 88 C1 1A  `p....96..E.6...
00B0: 8C 56 AB 12 7A 3D AF 00   60 30 47 0A D5 A0 05 FB  .V..z=..`0G.....
00C0: 14 CE 2D 9D CD 87 E3 8B   C7 D1 B1 C5 FA CB AE CB  ..-.............
00D0: E9 5F 19 0A A7 A3 1D 23   C4 DB BC BE 06 17 45 44  ._.....#......ED
00E0: 40 1A 5B 2C 02 09 65 D8   C2 BD 21 71 D3 66 84 45  @.[,..e...!q.f.E
00F0: 77 1F 74 BA 08 4D 20 29   D8 3C 1C 15 85 47 F3 A9  w.t..M ).&lt;...G..
0100: F1 A2 71 5B E2 3D 51 AE   4D 3E 5A 1F 6A 70 64 F3  ..q[.=Q.M&gt;Z.jpd.
0110: 16 93 3A 34 6D 3F 52 92   52 00 60 08 3C 3B 0D E0  ..:4m?R.R.`.&lt;;..
0120: 6E 20 A8 74 8B F6 92 0F   0C D8 6B 52 B6 8C 50 C1  n .t......kR..P.
0130: ED 9F BD 57 22 12 C5 B5   FC 1A 1B 5E A0 BC A2 1E  ...W""......^....
0140: 1D A5 A5 44 98 0B CC FB   BB 0E E9 EF 67 86 A8 B5  ...D........g...
0150: AD CE 97 C5 80 41 EF E9   BF 1D C4 5D 50 D9 37 51  .....A.....]P.7Q
0160: F0 65 1F 77 62 BC D3 34   92 A8 7F 7F 42 3F 6F C6  .e.wb..4....B?o.
0170: 86 46 D5 1F A2 92 19 B2   4F 38 74 0E 00 00 00     .F......O8t....
URT-, WRITE: TLSv1 Handshake, length = 383
[Raw write]: length = 388
0000: 16 03 01 01 7F 02 00 00   4D 03 01 50 83 1E 0C 64  ........M..P...d
0010: 03 38 99 07 02 FB 40 29   20 42 F0 E3 B5 37 BE 02  .8....@) B...7..
0020: ED 92 00 49 77 46 00 A0   09 1C CF 20 50 83 1E 0C  ...IwF..... P...
0030: F1 49 34 26 2E 29 ED E2   C7 F6 9C 2D 03 F7 B6 2B  .I4&amp;.).....-...+
0040: DF 08 31 A9 BC 3F A0 29   66 C7 32 BE 00 34 00 00  ..1..?.)f.2..4..
0050: 05 FF 01 00 01 00 0C 00   01 26 00 60 E9 E6 42 59  .........&amp;.`..BY
0060: 9D 35 5F 37 C9 7F FD 35   67 12 0B 8E 25 C9 CD 43  .5_7...5g...%..C
0070: E9 27 B3 A9 67 0F BE C5   D8 90 14 19 22 D2 C3 B3  .'..g.......""...
0080: AD 24 80 09 37 99 86 9D   1E 84 6A AB 49 FA B0 AD  .$..7.....j.I...
0090: 26 D2 CE 6A 22 21 9D 47   0B CE 7D 77 7D 4A 21 FB  &amp;..j""!.G...w.J!.
00A0: E9 C2 70 B5 7F 60 70 02   F3 CE F8 39 36 94 CF 45  ..p..`p....96..E
00B0: EE 36 88 C1 1A 8C 56 AB   12 7A 3D AF 00 60 30 47  .6....V..z=..`0G
00C0: 0A D5 A0 05 FB 14 CE 2D   9D CD 87 E3 8B C7 D1 B1  .......-........
00D0: C5 FA CB AE CB E9 5F 19   0A A7 A3 1D 23 C4 DB BC  ......_.....#...
00E0: BE 06 17 45 44 40 1A 5B   2C 02 09 65 D8 C2 BD 21  ...ED@.[,..e...!
00F0: 71 D3 66 84 45 77 1F 74   BA 08 4D 20 29 D8 3C 1C  q.f.Ew.t..M ).&lt;.
0100: 15 85 47 F3 A9 F1 A2 71   5B E2 3D 51 AE 4D 3E 5A  ..G....q[.=Q.M&gt;Z
0110: 1F 6A 70 64 F3 16 93 3A   34 6D 3F 52 92 52 00 60  .jpd...:4m?R.R.`
0120: 08 3C 3B 0D E0 6E 20 A8   74 8B F6 92 0F 0C D8 6B  .&lt;;..n .t......k
0130: 52 B6 8C 50 C1 ED 9F BD   57 22 12 C5 B5 FC 1A 1B  R..P....W""......
0140: 5E A0 BC A2 1E 1D A5 A5   44 98 0B CC FB BB 0E E9  ^.......D.......
0150: EF 67 86 A8 B5 AD CE 97   C5 80 41 EF E9 BF 1D C4  .g........A.....
0160: 5D 50 D9 37 51 F0 65 1F   77 62 BC D3 34 92 A8 7F  ]P.7Q.e.wb..4...
0170: 7F 42 3F 6F C6 86 46 D5   1F A2 92 19 B2 4F 38 74  .B?o..F......O8t
0180: 0E 00 00 00                                        ....
[Raw read]: length = 5
0000: 15 03 01 00 02                                     .....
[Raw read]: length = 2
0000: 02 00                                              ..
URT-, READ: TLSv1 Alert, length = 2
URT-, RECV TLSv1 ALERT:  fatal, close_notify
URT-, called closeSocket()
URT-, handling exception: javax.net.ssl.SSLException: Received fatal alert: close_notify
</code></pre>

<p>FYI, this works in iOS 6.0</p>
","<p>If the app works with JDK5, I suggest to repeat the same test with JDK6 and compare the two log files: it should then be clear where the real differences are.</p>

<p>Inspecting your debug log, the server is saying that the client is sending a <em>fatal</em> close_notify message, and because of this the server closes the connection immediately, and that is the right server behavior.</p>

<blockquote>
  <p><a href=""http://tools.ietf.org/html/rfc5246#section-7.2.1"" rel=""nofollow"">7.2.1.  Closure Alerts</a></p>
  
  <p>The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack.  Either party may initiate the exchange of closing messages.</p>
  
  <p><strong>close_notify</strong> This message notifies the recipient that the sender will not send any more messages on this connection.  Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be resumed.  This is a change from TLS 1.0 to conform with widespread implementation practice.</p>
  
  <p>Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored. Unless some other fatal alert has been transmitted, each party is required to send a close_notify alert before closing the write side of the connection.  The other party MUST respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes.  It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.</p>
</blockquote>

<p>About TLS_DH_anon_WITH_AES_128_CBC_SHA, please note there was a REGRESSION fix in JDK6u29 that <strong>broke SSL connectivity using TLS_DH_anon_WITH_AES_128_CBC_SHA</strong>. More info here:</p>

<p><a href=""http://www.oracle.com/technetwork/java/javase/documentation/overview-137139.html"" rel=""nofollow"">http://www.oracle.com/technetwork/java/javase/documentation/overview-137139.html</a>
<a href=""http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7103725"" rel=""nofollow"">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7103725</a></p>
","1537","<java><ios5><ssl><jsse><diffie-hellman>","21","1","3","2013-12-14 02:13:24","","7","1","1262634","","2013-06-25 16:04:00","2012-10-20 22:54:09",""
"14589735","Implement full Diffie-Helllman key exchange encryption in java","<p>I have a chat program that uses sockets for sending and receiving data. Now, I want to encrypt the data transfers via sockets with Diffie-Hellman key exchange system.
What is the easiest way to do that?</p>
","<blockquote>
  <p>What is the easiest way to do that?</p>
</blockquote>

<p>Use <a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html"" rel=""nofollow"">JSSE</a> and configure to use Diffie Hellman.<br>
<code>JSSE</code> is Java's socket extension for <code>SSL</code>. Using the <code>SecureSocket</code> classes which provide the same interface as regular sockets (so your current code does not need to change) but operate over <code>SSL</code> you can achieve encryption in your network connectivity.<br>
You should study the link provided to see how to configure to do what you need.</p>
","1477","<java><encryption><diffie-hellman>","1","3","1","2013-01-29 19:32:01","14589923","5","","","","","2013-01-29 18:30:00",""
"29201387","How to generate an ECDHE public key with OpenSSL?","<p>I'm trying to generate an ECDHE key using OpenSSL <code>1.0.2a</code> on Windows and have the following sample code:</p>

<pre><code>#include &lt;openssl/crypto.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/pem.h&gt;
#include &lt;openssl/ecdh.h&gt;

int main()
{
    OpenSSL_add_all_algorithms(); ERR_load_crypto_strings();

    EVP_PKEY_CTX* parameters_context = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);
    EVP_PKEY* cparameters = nullptr;
    EVP_PKEY* private_key = nullptr;

    if (EVP_PKEY_paramgen_init(parameters_context) != 1) { return 1; }
    if (EVP_PKEY_CTX_set_ec_paramgen_curve_nid(parameters_context, NID_sect571k1) != 1) { return 1; }
    if (EVP_PKEY_paramgen(parameters_context, &amp;cparameters) != 1) { return 1; }

    EVP_PKEY_CTX* key_generation_context = EVP_PKEY_CTX_new(cparameters, NULL);

    if (!key_generation_context) { return 1; }
    if (EVP_PKEY_keygen_init(key_generation_context) != 1) { return 1; }        
    if (EVP_PKEY_keygen(key_generation_context, &amp;private_key) != 1) { return 1; }

    BIO* bio = BIO_new(BIO_s_mem());
    PEM_write_bio_PUBKEY(bio, private_key); // &lt;== This is where things go wrong.

    ERR_free_strings(); EVP_cleanup(); CRYPTO_cleanup_all_ex_data();
}
</code></pre>

<p>I tested the said code on other platforms (OSX and Debian Linux, using <code>gcc</code>) and it seems works fine (no errors reported under <code>valgrind</code>).</p>

<p>When I run it on Windows, it always fails on this line:</p>

<pre><code>PEM_write_bio_PUBKEY(bio, private_key);
</code></pre>

<p>And I get this ""nice"" error screen:</p>

<p><img src=""https://i.imgur.com/4FU6a3B.png"" alt=""heap error""></p>

<p>I'm at loss figuring out what is wrong: from the many tutorials and documentation pages I could find, this seems to be the right way of doing things.</p>

<p>Before I spend another day trying to figure out what's wrong, I figured it might smarter to ask the community: <strong>is this the right way of generating and writing an ECDHE key as PEM format with OpenSSL ?</strong></p>
","<p>It was indeed a bug in OpenSSL.</p>

<p>From the <a href=""https://www.mail-archive.com/openssl-dev@openssl.org/msg38577.html"" rel=""nofollow noreferrer"">OpenSSL-dev mailing-list</a>:</p>

<blockquote>
  <p>On Tue, Mar 31, 2015, ****** ******* wrote:</p>
  
  <p>></p>
  
  <blockquote>
    <p>if (!combine)
        *pval = NULL;</p>
  </blockquote>
  
  <p>I'd suggest deleting the two lines above. The structure should be
  cleared without this and the above line is wrong for non pointer
  fields anyway.</p>
  
  <p>Steve.
  -- Dr Stephen N. Henson. OpenSSL project core developer. Commercial tech support now available see: <a href=""http://www.openssl.org"" rel=""nofollow noreferrer"">http://www.openssl.org</a></p>
</blockquote>

<p>See also <a href=""https://stackoverflow.com/questions/29335795/what-can-explain-heap-corruption-on-a-call-to-free"">this other question</a> for details.</p>
","1431","<c><openssl><elliptic-curve><diffie-hellman>","1","0","1","2015-04-01 23:09:52","29402408","6","","","","","2015-03-22 23:59:23",""
"39374024","Determine Diffie-Hellman ""Parameters"" Length for a TLS handshake in Java","<p>I'd like to make an HTTPS connection to a server and, if I'm using
non-ephemeral DH key exchange, I'd like to know what the parameters
are for that connection. Actually, I don't really care if it's
ephemeral or not.</p>

<p>What I'm looking for is the ability to make a connection and then warn
if the connection is using ""weak"" DH parameters. Is that something I
can check at connection-time? Or is the set of DH parameters (or, more
specifically, the <em>length</em> of those parameters, in bits) defined by
the cipher suite itself?</p>

<p>For example, the Qualys community thread has an illustration of the
cipher suites that SSLLabs considers ""weak"" (well, everyone considers
them weak... they just have a public tool which complains about them):
<a href=""https://community.qualys.com/thread/14821"" rel=""nofollow"">https://community.qualys.com/thread/14821</a></p>

<p>They specifically mention e.g. <code>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</code>
which is cipher suite 0x9f and mention the DH parameters. Are those
parameters' parameters baked-into the cipher suite (meaning they are
<em>always</em> 1024-bit) or is this a configuration of the server that makes
those cipher suites weak due to the specific DH parameter choice?</p>

<p>In either case, I'd like to be able to sniff that information from the
connection if at all possible. Does anyone know if this can be done,
and how?</p>

<p>I've written some code to attempt to get this information about the handshake, but I keep getting <code>null</code> for the object I was hoping would contain this data.</p>

<pre><code>SSLSocketFactory sf = ...;
Socket sock = new Socket();
sock.connect(address, timeout);

SSLSocket socket = (SSLSocket)sf.createSocket(sock, host, port, true);
socket.startHandshake();
SSLSession sess = socket.getHandshakeSession();
</code></pre>

<p>I was hoping that <code>sess</code> at this point would contain some interesting information about the handshake, but it's <code>null</code>. The javadoc for <code>startHandshake</code> indicates that it will notify an event listener when the handshake is completed. So I tried this:</p>

<pre><code>SSLSocketFactory sf = ...;
Socket sock = new Socket();
sock.connect(address, timeout);

SSLSocket socket = (SSLSocket)sf.createSocket(sock, host, port, true);
socket.startHandshake();
// SSLSession sess = socket.getHandshakeSession();
SSLSession sess = socket.getSession(); // This forces the handshake to complete
sess = socket.getHandshakeSession();
</code></pre>

<p>... but <code>sess</code> is still <code>null</code> at this point. The ""real"" SSLSession does exist and gives me information about the connection, but the ""handshake session"" seems to always be <code>null</code>.</p>

<p>So I tried writing an <code>HandshakeCompletedListener</code>, and I do in fact get an <code>SSLSession</code>, but it appears to be the same one that I can get from the <code>SSLSocket</code> already, so the ""handshake"" session seems to be unhelpful.</p>

<p>How can I get those parameters from the <code>SSLSession</code>?</p>
","<p>For most cipher algorithms, the length is determined by the name cypher name, as also mentioned here <a href=""https://stackoverflow.com/questions/29611120/how-to-get-the-actual-block-cipher-key-size-for-java-ssl-connection-in-code"">How to get the actual block cipher key size for Java SSL connection _in code_?</a> .
Instead of trying to warn people when they are using unsecure cyphers, I'd recommend to disable those ciphers by selecting only the cyphers you want to support. You can do this on a jvm level or on the SSLSocket, e.g.</p>

<pre><code>String pickedCipher[] ={""TLS_RSA_WITH_AES_128_CBC_SHA""}; 
socket.setEnabledCipherSuites(pickedCipher);
</code></pre>

<p>You can also set the desired key size, see here
<a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#customizing_dh_keys"" rel=""nofollow noreferrer"">https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#customizing_dh_keys</a></p>

<p>You can see defaults and classes used in Java security here <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html"" rel=""nofollow noreferrer"">https://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html</a></p>

<p>If you are curious and want to investigate this in more detail, I'd recommend to turn on ssl logging, as described here.</p>
","1429","<java><ssl><handshake><diffie-hellman>","3","0","2","2017-01-03 17:05:35","","4","1","","","","2016-09-07 15:32:15",""
"39374024","Determine Diffie-Hellman ""Parameters"" Length for a TLS handshake in Java","<p>I'd like to make an HTTPS connection to a server and, if I'm using
non-ephemeral DH key exchange, I'd like to know what the parameters
are for that connection. Actually, I don't really care if it's
ephemeral or not.</p>

<p>What I'm looking for is the ability to make a connection and then warn
if the connection is using ""weak"" DH parameters. Is that something I
can check at connection-time? Or is the set of DH parameters (or, more
specifically, the <em>length</em> of those parameters, in bits) defined by
the cipher suite itself?</p>

<p>For example, the Qualys community thread has an illustration of the
cipher suites that SSLLabs considers ""weak"" (well, everyone considers
them weak... they just have a public tool which complains about them):
<a href=""https://community.qualys.com/thread/14821"" rel=""nofollow"">https://community.qualys.com/thread/14821</a></p>

<p>They specifically mention e.g. <code>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</code>
which is cipher suite 0x9f and mention the DH parameters. Are those
parameters' parameters baked-into the cipher suite (meaning they are
<em>always</em> 1024-bit) or is this a configuration of the server that makes
those cipher suites weak due to the specific DH parameter choice?</p>

<p>In either case, I'd like to be able to sniff that information from the
connection if at all possible. Does anyone know if this can be done,
and how?</p>

<p>I've written some code to attempt to get this information about the handshake, but I keep getting <code>null</code> for the object I was hoping would contain this data.</p>

<pre><code>SSLSocketFactory sf = ...;
Socket sock = new Socket();
sock.connect(address, timeout);

SSLSocket socket = (SSLSocket)sf.createSocket(sock, host, port, true);
socket.startHandshake();
SSLSession sess = socket.getHandshakeSession();
</code></pre>

<p>I was hoping that <code>sess</code> at this point would contain some interesting information about the handshake, but it's <code>null</code>. The javadoc for <code>startHandshake</code> indicates that it will notify an event listener when the handshake is completed. So I tried this:</p>

<pre><code>SSLSocketFactory sf = ...;
Socket sock = new Socket();
sock.connect(address, timeout);

SSLSocket socket = (SSLSocket)sf.createSocket(sock, host, port, true);
socket.startHandshake();
// SSLSession sess = socket.getHandshakeSession();
SSLSession sess = socket.getSession(); // This forces the handshake to complete
sess = socket.getHandshakeSession();
</code></pre>

<p>... but <code>sess</code> is still <code>null</code> at this point. The ""real"" SSLSession does exist and gives me information about the connection, but the ""handshake session"" seems to always be <code>null</code>.</p>

<p>So I tried writing an <code>HandshakeCompletedListener</code>, and I do in fact get an <code>SSLSession</code>, but it appears to be the same one that I can get from the <code>SSLSocket</code> already, so the ""handshake"" session seems to be unhelpful.</p>

<p>How can I get those parameters from the <code>SSLSession</code>?</p>
","<blockquote>
  <p>Are those parameters' parameters baked-into the cipher suite (meaning they are always 1024-bit) or is this a configuration of the server that makes those cipher suites weak due to the specific DH parameter choice?</p>
</blockquote>

<p>No, this is a configuration parameter <em>for the protocol</em>. There is a default of 1024 bits for Java but that may be changed <em>globally</em> for JSSE (the Java TLS implementation) using a system property: <code>jdk.tls.ephemeralDHKeySize</code>. Best set this during startup with a -D option for the Java VM.</p>

<p>For static DH key pairs (that are used for authentication) you would have to look into the DH certificate. But I don't think you'll find any, everybody uses RSA for authentication.</p>

<blockquote>
  <p>In either case, I'd like to be able to sniff that information from the connection if at all possible. Does anyone know if this can be done, and how?</p>
</blockquote>

<p>Well, for <em>sniffing</em> tools such as WireShark would suffice. Undoubtedly you can parse things like DH parameters from a TLS connection (if they are used in the first place of course).</p>

<p>You can also debug connections using <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/ReadDebug.html"" rel=""nofollow noreferrer""><code>-Djavax.net.debug</code></a></p>

<p>For Java applications / libraries you could look up the cipher suite and then, if it contains <code>DHE_</code> look up the aforementioned system property (keeping in mind its default values).</p>

<hr>

<p>The Java JSSE API was not written with deep packet inspection in mind. It's (literally) a service oriented implementation for servers and client applications. Although you could of course use the OpenJDK code itself (it's GPL'ed, right?) you are better off using a separate implementation, possibly with an even more permissive license.</p>

<p>For a sniffer however I would rather use C/C++ (or at least a C/C++ frontend) than Java.</p>
","1429","<java><ssl><handshake><diffie-hellman>","3","1","2","2017-01-03 17:05:35","","4","1","","","","2016-09-07 15:32:15",""
"15483736","Diffie-Hellman Private Key","<p>I have the line of code below to generate a private key:</p>

<pre><code>int Xa = randomNo.nextInt(10000);
int Ya = (int) Math.pow(G, Xa) % P;
</code></pre>

<p><code>G</code> and <code>P</code> are static numbers. Whereas <code>Xa</code> is randomly generated. Every time I run the program, it gives me the same result for <code>Ya</code>. Is this correct for Diffie-Hellman? I thought the private key had to be changed every time the algorithm was run.</p>
","<p>The problem is that the <code>Random</code> class in Java has a constructor with one <code>long</code> argument (called <em>seed</em>) that allows you to start the pseudorandom number sequence in a particular way.</p>

<p>If you always use the same seed, you will always obtain the same sequence. </p>

<p>To solve the problem, try this:</p>

<pre><code>Random randomNo = new Random(System.nanoTime());
int Xa = randomNo.nextInt(10000);
</code></pre>

<p>In this way, the seed is always different, and the sequence changes everytime you call the above line.</p>
","1371","<java><diffie-hellman>","4","3","4","2013-03-19 16:51:54","15483941","8","2","104223","","2013-03-18 18:13:57","2013-03-18 18:02:39",""
"15483736","Diffie-Hellman Private Key","<p>I have the line of code below to generate a private key:</p>

<pre><code>int Xa = randomNo.nextInt(10000);
int Ya = (int) Math.pow(G, Xa) % P;
</code></pre>

<p><code>G</code> and <code>P</code> are static numbers. Whereas <code>Xa</code> is randomly generated. Every time I run the program, it gives me the same result for <code>Ya</code>. Is this correct for Diffie-Hellman? I thought the private key had to be changed every time the algorithm was run.</p>
","<p>This can only give different results if <code>Xa</code> is different. How did you generate the value of <code>Xa</code>? Chances are you've used a pseudo-random generator that typically need to be seeded. If you take the default seed each time (same seed each time) it will always return the same sequence of random numbers.</p>

<p>Try seeding your generator with <code>System.currentTimeMillis();</code></p>
","1371","<java><diffie-hellman>","4","1","4","2013-03-19 16:51:54","15483941","8","2","104223","","2013-03-18 18:13:57","2013-03-18 18:02:39",""
"15483736","Diffie-Hellman Private Key","<p>I have the line of code below to generate a private key:</p>

<pre><code>int Xa = randomNo.nextInt(10000);
int Ya = (int) Math.pow(G, Xa) % P;
</code></pre>

<p><code>G</code> and <code>P</code> are static numbers. Whereas <code>Xa</code> is randomly generated. Every time I run the program, it gives me the same result for <code>Ya</code>. Is this correct for Diffie-Hellman? I thought the private key had to be changed every time the algorithm was run.</p>
","<p>I think the problem may be that you are overflowing double with your exponentiation, resulting in infinity, resulting in the same value every time (unless you are lucky enough to end up with a very low number returned for your exponent).</p>

<p>Also, be sure to use secure random to get your random value:</p>

<pre><code>Random random = new SecureRandom();

// If you use more than 100 here, then
// with your value of 486 for G you will
// end up with infinity when doing Math.pow(G,Xa).
// Of course, this does not provide enough possible
// values to be cryptographically secure.
int Xa = random.nextInt(100);
int Ya = (int) (Math.pow(G, Xa) % P);
</code></pre>

<p>Edit:  Code with debugging (the below works for me):</p>

<pre><code>double G = 42;
int P = 26;


Random random = new SecureRandom();
int Xa = random.nextInt(100);
double val = Math.pow(G, Xa);
System.out.println(""Xa: "" + Xa);
System.out.println(""(double) Math.pow: "" + val + "" (int): "" + (int) val);
int Ya = (int) (val % P);
System.out.println(""Ya: "" + Ya);
</code></pre>
","1371","<java><diffie-hellman>","4","2","4","2013-03-19 16:51:54","15483941","8","2","104223","","2013-03-18 18:13:57","2013-03-18 18:02:39",""
"15483736","Diffie-Hellman Private Key","<p>I have the line of code below to generate a private key:</p>

<pre><code>int Xa = randomNo.nextInt(10000);
int Ya = (int) Math.pow(G, Xa) % P;
</code></pre>

<p><code>G</code> and <code>P</code> are static numbers. Whereas <code>Xa</code> is randomly generated. Every time I run the program, it gives me the same result for <code>Ya</code>. Is this correct for Diffie-Hellman? I thought the private key had to be changed every time the algorithm was run.</p>
","<p>Other people seem to have given good answers on the issue with your generation of random numbers, so I'll respond to your question ""Is this correct for Diffie-Hellman?""</p>

<p>Your understanding of Diffie-Helman is a bit off I think. For one thing, you keep using the term 'private key' as though there is also a 'public key'. Diffie-Hellman key exchange is a technique used for exchanging one symmetric key. There isn't a private key and a public key, there is just a key that both parties are going to use to encrypt their messages. Moreover, you said that this is code for 'generating' a key. With Diffie-Hellman, it takes two to tango. This code isn't enough to generate the final product of the key. You'll need to send <code>Ya</code> to a 2nd party and get something back from that second party to finish the process. See below for more info.</p>

<p>Your formula for generating <code>Ya</code> is correct, assuming that <code>Xa</code> is what it is supposed to be. I'm a little concerned about your understanding of what you're supposed to do with <code>Xa</code> because you're reassigning it to a random value after you've generated <code>Ya</code>. You will need to hang on to <code>Xa</code> in order to create the final version of the key. </p>

<p>After you've generated <code>Ya</code>, you should be sending that to the other party. The other party will send you back some number in return (let's call that <code>R</code>). In order for you to create the final version of the symmetric key (let's call it <code>SK</code>), you will need to calculate it as </p>

<pre><code>SK = (int)Math.pow(R, Xa) % P;
</code></pre>

<p>So in a nutshell, don't recalculate <code>Xa</code> after you've calculated <code>Ya</code>, otherwise you won't be able to generate the key. The process goes:</p>

<ol>
<li>Generate <code>Ya</code> (I'm just using this variable name because it's what you used).</li>
<li>Send <code>Ya</code> to some person.</li>
<li>Receive some number from the person you sent <code>Ya</code> to (called this number <code>R</code> in example above).</li>
<li>Calculate what the symmetric-key should be that you'll be using for encryption using <code>R</code>, <code>Xa</code>, and <code>P</code>. (See formula above for <code>SK</code>)</li>
</ol>
","1371","<java><diffie-hellman>","4","3","4","2013-03-19 16:51:54","15483941","8","2","104223","","2013-03-18 18:13:57","2013-03-18 18:02:39",""
"46644481","How to enforce DH key size in the OpenSSL client?","<p>In our Application, we use OpenSSL for secure connections and we use DH for key exchange.  With the recent OpenSSL versions, minimum key length that can be used is 768 and 1024 is recommended. 
Our application is peer-peer application and to comply with this requirement, all our application instances need to be updated to start using 1024 DH keys. As on today, our application uses 512 key by default. They can be configured via configuration file to specify 102/2048/4096 lengths but this requires manual change on all systems. </p>

<p>To my understanding, server side will decides DH key length always. So, we will not be able to update the OpenSSL version on client side without updating server side. </p>

<p>Is there any way to enforce the minimum DH key length from client side so that server will generate DH key with minimum length specified by client?</p>
","","1334","<openssl><diffie-hellman>","3","","0","2017-10-09 10:38:44","","2","1","","","","2017-10-09 10:38:44",""
"32452904","Weak DH ssl_error_bad_cert_alert Firefox but Chrome is OK","<h1>Problem:</h1>

<p>We have difficulty trying to connect to our server using a browser.
Google Chrome can connect, but Mozilla Firefox cannot.
This problem is related to the ""Weak Diffie-Hellman and the Logjam Attack"" (<a href=""https://weakdh.org/"" rel=""nofollow noreferrer"">https://weakdh.org/</a>)</p>

<h1>Activity log, sequence of actions we have conducted to try and fix the problem, and things we already know:</h1>

<ol>
<li>Everything was fine</li>
<li>Firefox complained about the Weak Diffie-Hellman ephemeral key</li>
<li>Firefox can no longer access our server</li>
<li>But, Google Chrome CAN STILL access</li>
<li>Found out about ""Weak Diffie-Hellman and the Logjam Attack""
(<a href=""https://weakdh.org/"" rel=""nofollow noreferrer"">https://weakdh.org/</a>)</li>
<li>Tested Firefox using their website, and responded ""Good News! Your browser is safe against the Logjam attack.""</li>
<li>Tested Chrome using their website, and it responded that Chrome was vulnerable.</li>
<li>This explained why we could still access our server using Chrome</li>
<li>Updated Chrome to the latest version.</li>
<li>Tested Chrome using weakdh.org, and responded ""Good News! Your
 browser is safe against the Logjam attack.""</li>
<li>Tried accessing our site using Chrome, and it has the same error
 with Firefox.</li>
<li>Both Chrome and Firefox can no longer access the site at this
 point.</li>
<li>We followed the instruction located at
 <a href=""https://weakdh.org/sysadmin.html"" rel=""nofollow noreferrer"">https://weakdh.org/sysadmin.html</a> for Apache Tomcat servers.    </li>
<li>Fix did not work both for Chrome and Firefox, still the same error.</li>
<li>We followed the instruction at
 <a href=""https://stackoverflow.com/questions/30931692/diffie-hellman-public-key-error-with-tomcat-7"">Diffie-Hellman public key error with Tomcat 7</a></li>
<li>Fix WORKED for Chrome BUT NOT for Firefox.</li>
<li>Firefox has error code: ssl_error_bad_cert_alert</li>
<li>We experimented on lesser number of ciphers but none worked</li>
<li>Same error for Firefox, still OK for Chrome.</li>
</ol>

<h1><strong>TECHNICAL DETAILS</strong></h1>

<h2>Certificate:</h2>

<pre><code>Signature algorithm: sha256RSA
Signature hash algorithm: sha256
Public key: RSA (2048 Bits)
Thumbprint algorithm: sha1
</code></pre>

<h2>Environment:</h2>

<pre><code>Apache Tomcat 6.0
Java 1.6.0_34
</code></pre>

<h2>Current server configuration:</h2>

<pre><code>&lt;Connector port=""443"" SSLEnabled=""true"" maxThreads=""150"" scheme=""https"" 
secure=""true"" clientAuth=""true"" sslProtocol=""TLS"" 
keystoreFile=""********.pfx"" 
keystoreType=""PKCS12"" 
keystorePass=""********"" 
ciphers=""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA""/&gt;
</code></pre>
","<p>Basically, you'll need to upgrade your java version. More details in here: <a href=""https://stackoverflow.com/questions/21053346/apachejmetertemporaryrootca-crt-not-generated"">ApacheJMeterTemporaryRootCA.crt not generated</a></p>

<p>[]'s</p>
","1295","<google-chrome><tomcat><firefox><openssl><diffie-hellman>","1","0","1","2015-12-17 12:28:39","","0","","-1","","2017-05-23 11:52:17","2015-09-08 08:30:53",""
"24677932","Diffie-Hellman Key Exchange with Javascript sometimes wrong","<p>After watching this video
<a href=""http://youtu.be/3QnD2c4Xovk"" rel=""nofollow"">http://youtu.be/3QnD2c4Xovk</a></p>

<p>I've been trying to follow it step by step, and haven't been able to produce the same results.</p>

<p>Notably, when I try to do Math.pow(3, 54)%17, I get 7.  While the speaker gets 15.</p>

<p>I wrote a method that is supposed to simulate Diffie Hellman's key exchange using exactly what I found on <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""nofollow"">http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a></p>

<p>This is my code:</p>

<pre><code>function diffieHellman(generator, prime, alice_secret, bob_secret){
  var alice_public = Math.pow(generator, alice_secret)%prime
    , bob_public = Math.pow(generator, bob_secret)%prime
    , alice_private = Math.pow(bob_public, alice_secret)%prime
    , bob_private = Math.pow(alice_public, bob_secret)%prime;
  console.log(""alice""
  , ""\n\t"", ""secret -- "", alice_secret
  , ""\n\t"", ""public -- "", alice_public
  , ""\n\t"", ""private -- "", alice_private
  )
  console.log(""bob""
  , ""\n\t"", ""secret -- "", bob_secret
  , ""\n\t"", ""public -- "", bob_public
  , ""\n\t"", ""private -- "", bob_private
  )
  return {
    alice:{
      secret: alice_secret
    , public: alice_public
    , private: alice_private
    },
    bob:{
      secret: bob_secret
    , public: bob_public
    , private: bob_private
    }
  }
};
</code></pre>

<p>These examples work:</p>

<pre><code>diffieHellman(3, 17, 4, 12) // 1, 1
diffieHellman(3, 23, 6, 19) // 12, 12
diffieHellman(3, 13, 8, 4) // 9, 9
</code></pre>

<p>However, some numbers don't work</p>

<pre><code>diffieHellman(3, 17, 40, 120) // 13, 0
diffieHellman(3, 23, 16, 129) // 21, 2
diffieHellman(3, 13, 44, 11) // 9, 1
</code></pre>

<p>What am I doing wrong?</p>

<p>Edit -- I'm not trying to implement Diffie-Hellman's Key Exchange in Javascript for a project.  It's just the language I'm most comfortable with, but I am afraid if this could be a javascript limitation.</p>
","<p>The problem is the limited precision of Javascript numbers that causes rounding errors in your code where you first exponentiate and then calculate the modulus. For your example numbers, you could fix this by periodically calculating the modulus inside the exponentiation, e.g. by never calculating more than a square before taking the modulus. But for actual cryptography your calculations will involve numbers too big to be handled as Javascript numbers (and most programming languages pose the same problem). The usual approach is to use a large integer (or even arbitrary precision) library. If you do end up implementing your own cryptography, please watch out for side channels, e.g. by calling library functions that are not constant time or allow cache-based attacks by using data dependent array indices.</p>
","1266","<javascript><public-key-encryption><diffie-hellman>","3","4","2","2017-07-08 08:57:46","24787581","2","2","2628234","","2014-07-10 13:39:36","2014-07-10 13:33:16",""
"24677932","Diffie-Hellman Key Exchange with Javascript sometimes wrong","<p>After watching this video
<a href=""http://youtu.be/3QnD2c4Xovk"" rel=""nofollow"">http://youtu.be/3QnD2c4Xovk</a></p>

<p>I've been trying to follow it step by step, and haven't been able to produce the same results.</p>

<p>Notably, when I try to do Math.pow(3, 54)%17, I get 7.  While the speaker gets 15.</p>

<p>I wrote a method that is supposed to simulate Diffie Hellman's key exchange using exactly what I found on <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""nofollow"">http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a></p>

<p>This is my code:</p>

<pre><code>function diffieHellman(generator, prime, alice_secret, bob_secret){
  var alice_public = Math.pow(generator, alice_secret)%prime
    , bob_public = Math.pow(generator, bob_secret)%prime
    , alice_private = Math.pow(bob_public, alice_secret)%prime
    , bob_private = Math.pow(alice_public, bob_secret)%prime;
  console.log(""alice""
  , ""\n\t"", ""secret -- "", alice_secret
  , ""\n\t"", ""public -- "", alice_public
  , ""\n\t"", ""private -- "", alice_private
  )
  console.log(""bob""
  , ""\n\t"", ""secret -- "", bob_secret
  , ""\n\t"", ""public -- "", bob_public
  , ""\n\t"", ""private -- "", bob_private
  )
  return {
    alice:{
      secret: alice_secret
    , public: alice_public
    , private: alice_private
    },
    bob:{
      secret: bob_secret
    , public: bob_public
    , private: bob_private
    }
  }
};
</code></pre>

<p>These examples work:</p>

<pre><code>diffieHellman(3, 17, 4, 12) // 1, 1
diffieHellman(3, 23, 6, 19) // 12, 12
diffieHellman(3, 13, 8, 4) // 9, 9
</code></pre>

<p>However, some numbers don't work</p>

<pre><code>diffieHellman(3, 17, 40, 120) // 13, 0
diffieHellman(3, 23, 16, 129) // 21, 2
diffieHellman(3, 13, 44, 11) // 9, 1
</code></pre>

<p>What am I doing wrong?</p>

<p>Edit -- I'm not trying to implement Diffie-Hellman's Key Exchange in Javascript for a project.  It's just the language I'm most comfortable with, but I am afraid if this could be a javascript limitation.</p>
","<p>3^54 is 58149737003040059690390169. It causes an overflow, therefore you should implement <a href=""http://en.wikipedia.org/wiki/Modular_exponentiation"" rel=""nofollow noreferrer"">modular exponentation</a>, since i don't know javascript too well i have written a c code which should be easy to implement in javascript :</p>

<pre><code>int power(int a, int b, int prime){
      int result;
      if(b == 0){
           result = 1;
      }else if(b == 1){
           result = a % prime;
      }else if(b % 2 == 0){
           result = power((a*a) % prime, b/2, prime);
           result = result % prime;
      }else{
           result = power((a*a) % prime, b/2, prime);
           result = (result * a) % prime;
      }
  return result;
  }
</code></pre>

<p>Now you can call this function :</p>

<pre><code>int value = power(3, 54, 17);
</code></pre>

<p>and it should work.</p>

<p>Edit: added javascript version</p>

<pre><code>function power(a, b, prime) {
    if (b &lt;= 0) {
        return 1;
    } else if (b === 1) {
        return a % prime;
    } else if (b % 2 === 0) {
        return power((a * a) % prime, b / 2 | 0, prime) % prime;
    } else {
        return (power((a * a) % prime, b / 2 | 0, prime) * a) % prime;
    }
}
</code></pre>
","1266","<javascript><public-key-encryption><diffie-hellman>","3","3","2","2017-07-08 08:57:46","24787581","2","2","2628234","","2014-07-10 13:39:36","2014-07-10 13:33:16",""
"39448142","getting Algorithm negotiation fail when creating jsch connection to an sftp server","<p>I am trying to connect to an sftp server from using Jsch.  For some reason, I am getting the following error. </p>

<pre><code>com.jcraft.jsch.JSchException: Algorithm negotiation fail
at com.jcraft.jsch.Session.receive_kexinit(Session.java:590)
at com.jcraft.jsch.Session.connect(Session.java:320)
at com.jcraft.jsch.Session.connect(Session.java:183)
at Test.main(test.java:65)
</code></pre>

<p>My verbose output of the session connection log looks like this:</p>

<pre><code>Connecting to xx.xx.xx.xx port 22
Connection established
Remote version string: SSH-2.0-6.4.5.90 SSH Tectia Server
Local version string: SSH-2.0-JSCH-0.1.54
CheckCiphers: aes256-ctr,aes192-ctr,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,3des-ctr,arcfour,arcfour128,arcfour256
CheckKexes: diffie-hellman-group14-sha1,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521
diffie-hellman-group14-sha1 is not available.
CheckSignatures: ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521
SSH_MSG_KEXINIT sent
SSH_MSG_KEXINIT received
kex: server: diffie-hellman-group14-sha1,diffie-hellman-group14-sha256@ssh.com,diffie-hellman-group15-sha256@ssh.com,diffie-hellman-group15-sha384@ssh.com,diffie-hellman=group16-sha384@ssh.com,diffie-hellman-group16-sha512@ssh.com,diffie-hellman-group18-sha512@ssh.com
kex: server: ssh-rsa,ssh-rsa-sha256@ssh.com
kex: server: crypticore128@ssh.com,aes128-cbc,aes128-ctr,aes192-cbc,aes192-ctr,aes256-cbc,aes256-ctr,3des-cbc
kex: server: crypticore128@ssh.com,aes128-cbc,aes128-ctr,aes192-cbc,aes192-ctr,aes256-cbc,aes256-ctr,3des-cbc
kex: server: hmac-sha1,hmac-sha256-2@ssh.com,hmac-sha224@ssh.com,hmac-sha256@ssh.com,hmac-sha384@ssh.com
kex: server: hmac-sha1,hmac-sha256-2@ssh.com,hmac-sha224@ssh.com,hmac-sha256@ssh.com,hmac-sha384@ssh.com
kex: server: none,zlib
kex: server: none,zlib
kex: server: 
kex: server: 
kex: client: diffie-hellman-group1-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256
kex: client: ssh-rsa,ssh-dss,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521
kex: client: aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-ctr,aes192-cbc,aes256-ctr,aes256-cbc
kex: client: aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-ctr,aes192-cbc,aes256-ctr,aes256-cbc
kex: client: hmac-md5,hmac-sha1,hmac-sha2-256,hmac-sha1-96,hmac-md5-96
kex: client: hmac-md5,hmac-sha1,hmac-sha2-256,hmac-sha1-96,hmac-md5-96
kex: client: none
kex: client: none
kex: client: 
kex: client: 
Disconnecting from xx.xx.xx.xx port 22
</code></pre>

<p>From other answers on this forum, it seems as if the usual cause of this is one of the following:</p>

<ul>
<li>Java Cryptography Extension (JCE) not installed</li>
<li>Old version of Jsch</li>
</ul>

<p>Here is the test code I used to generate this error, and I have enabled the cryptography extension.</p>

<pre><code>import javax.crypto.Cipher;
import java.security.*;
import java.security.Provider.Service;
import com.jcraft.jsch.*;
import java.util.Properties;


class Test {
  public static void main(String[] args) {

    Logger jschLogger = new Logger() {

            @Override
            public boolean isEnabled(int arg0) {
                return true;
             }

            @Override
            public void log(int arg0, String arg1) {
                   System.out.println(Integer.toString(arg0)+"" - ""+arg1);
            }
        };


  JSch jsch = new JSch();
  Session session = null;

    try {
    Properties config = new Properties();
    config.put(""kex"", ""diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256"");
    config.put(""StrictHostKeyChecking"", ""no"");

        jsch.setLogger(jschLogger);
    session = jsch.getSession(""*****"", ""******"", 22);
    session.setConfig(""StrictHostKeyChecking"", ""no"");
    session.setPassword(""******"");
        session.setConfig(config);
        System.out.println(session.getConfig(""kex""));
    session.connect();

    Channel channel = session.openChannel(""sftp"");
    channel.connect();
    ChannelSftp sftpChannel = (ChannelSftp) channel;
    sftpChannel.get(""remotefile.txt"", ""localfile.txt"");
    sftpChannel.exit();
    session.disconnect();
        } catch (JSchException e) {
            e.printStackTrace();
                System.out.println(e.getMessage());
                System.out.println(e.getCause().toString());
        } catch (Exception  e) {
                e.printStackTrace();
                System.out.println(e.getMessage());
                System.out.println(e.getCause().toString());
        }
 }

}
</code></pre>

<p>Can anyone point me in the right direction? I have no control over the server.</p>
","","1172","<java><encryption><ssh><jsch><diffie-hellman>","1","","0","2016-09-12 11:12:23","","2","","1601474","","2016-09-12 11:12:23","2016-09-12 10:21:58",""
"38274214","TLS 1.2 ECDHE_RSA signature","<p>I'm currently working on a Java TLS server. I'm trying to get the following CipherSuite to work : TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</p>

<p>When I test it using openssl s_client I get the following error after the ServerKeyExchange message : </p>

<blockquote>
  <p>140735242416208:error:1414D172:SSL
  routines:tls12_check_peer_sigalg:wrong signature type:t1_lib.c:1130:</p>
</blockquote>

<p>Here is the TLS message as seen in Wireshark
<a href=""https://i.stack.imgur.com/UWU0Q.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UWU0Q.png"" alt=""The TLS message as seen in Wireshark""></a></p>

<p>The Handshake fails on a decode_error fatal error.</p>

<p>So I guess the client doesn't like the signature algorithm chosen. </p>

<p>But I am only using the default SignatureAndHashAlgorithm for now as per <a href=""https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1"" rel=""nofollow noreferrer"">RFC 5246 Section-7.4.1.4.1</a></p>

<blockquote>
  <p>If the negotiated key exchange algorithm is one of (RSA, DHE_RSA,
  DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had sent
  the value {sha1,rsa}.</p>
</blockquote>

<p>(I'm still checking if the client do offer theses default values though)</p>

<p>Since I'm doing ECDHE_RSA I believe I should hash and sign the serverECDHparams as per RFC 4492 Section 5.4 (First post here so only 2 links sorry :) )</p>

<pre><code>ServerKeyExchange.signed_params.sha_hash
        SHA(ClientHello.random + ServerHello.random +
                                          ServerKeyExchange.params);
struct {
    select (KeyExchangeAlgorithm) {
        case ec_diffie_hellman:
            ServerECDHParams params;
            Signature signed_params;
    };
} ServerKeyExchange;
</code></pre>

<p>And I should do this as per RFC 2246 Section 7.4.3 </p>

<pre><code>select (SignatureAlgorithm) {   
    case rsa:
        digitally-signed struct {
            opaque md5_hash[16];
            opaque sha_hash[20];
        };
} Signature;


md5_hash
MD5(ClientHello.random + ServerHello.random + ServerParams);

sha_hash
SHA(ClientHello.random + ServerHello.random + ServerParams);
</code></pre>

<p>My Java code regarding signing the serverParams : </p>

<pre><code>private byte[] getSignedParams(ChannelBuffer params)
        throws NoSuchAlgorithmException, DigestException, 
        SignatureException, InvalidKeyException {
    byte[] signedParams = null;
    ChannelBuffer signAlg = ChannelBuffers.buffer(2);
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
    switch (session.cipherSuite.sign) {
        case rsa:
            signAlg.writeByte(2); // 2 for SHA1
            sha.update(clientRandom);
            sha.update(serverRandom);
            sha.update(params.toByteBuffer());
            md5.update(clientRandom);
            md5.update(serverRandom);
            md5.update(params.toByteBuffer());
            signedParams = concat(md5.digest(), sha.digest());
        break;
    }
    signAlg.writeByte(session.cipherSuite.sign.value); // for RSA he byte is one
    ChannelBuffer signLength = ChannelBuffers.buffer(2);
    signLength.writeShort(signedParams.length);
    return concat(signAlg.array(),concat(signLength.array(),signedParams));
}
</code></pre>

<p>So my question is basically : Am I wrong about all this ? and if so, what am I doing wrong ?</p>

<p>Thank you for your time ! :)</p>
","<p>It's me again, I seem to have fixed my particular problem 2 things I noted  : </p>

<ol>
<li>Regarding my Java code, the MessageDigest class only does hashing no signing so I now use the Signature class instead.</li>
<li><strong>It seems I only need to sign using SHA1 in TLS1.2 I don't need to do MD5 at all.</strong></li>
</ol>

<p>The second item is what I should have found in the RFC but didn't (maybe it is written somewhere, I don't know) I think this could be useful for people even if they're not doing Java ;)</p>

<p>How my code looks now : </p>

<pre><code>private byte[] getSignedParams(ChannelBuffer params)
        throws NoSuchAlgorithmException, DigestException, 
        SignatureException, InvalidKeyException {
    byte[] signedParams = null;
    Signature signature = Signature.getInstance(selectedSignAndHash.toString());
    ChannelBuffer signAlg = ChannelBuffers.buffer(2);
    signAlg.writeByte(selectedSignAndHash.hash.value);
    signature.initSign(privateKey);

    signature.update(clientRandom);
    signature.update(serverRandom);
    signature.update(params.toByteBuffer());

    signedParams = signature.sign();

    signAlg.writeByte(session.cipherSuite.sign.value);
    ChannelBuffer signLength = ChannelBuffers.buffer(2);
    signLength.writeShort(signedParams.length);
    return concat(signAlg.array(), concat(signLength.array(), signedParams));
}
</code></pre>

<p>The code is different because in between I added a function to choose the SignatureAndHashAlgorithm to use from the list the client provides. But you could modify this to only respond using SHA1withRSA as this seems to be the default HashAndSignatureAlgorithm.</p>
","1164","<ssl><java><digital-signature><rsa><diffie-hellman>","3","0","1","2016-07-08 19:37:48","38274215","5","4","","","","2016-07-07 08:10:09",""
"7284010","Protecting ECDH against MITM attacks","<p>I am working on a project that requires an ECDH key exchange. I am trying to understand how to protect against MITM attacks. I can sign the public key and send a signature along with the public key transfer to ensure that the key has not been tampered with but that doesn't stop a MITM attack from just doing the same thing. I understand that the key exchange must be verified somehow by a third party but I'm having a hard time understanding how it is that a third party can be the solution assuming that someone can do an MITM attack. Why couldn't they just do an MITM on the third party verification too? Is there really a fail proof way of completely eliminating all possible MITM attacks without some kind of pre-known by both parties?</p>
","<p>You need a¹ <strong>trusted</strong> third party to sign both keys.</p>

<p>Without <em>any</em> knowledge or assertions about the identity of the intended partner, there's simply no way to distinguish him² from anyone else.</p>

<p><sup>¹ one or multiple</sup>
<sup>² Bob</sup></p>
","1149","<security><diffie-hellman>","1","1","3","2011-09-09 03:51:38","","0","","","","","2011-09-02 13:19:02",""
"7284010","Protecting ECDH against MITM attacks","<p>I am working on a project that requires an ECDH key exchange. I am trying to understand how to protect against MITM attacks. I can sign the public key and send a signature along with the public key transfer to ensure that the key has not been tampered with but that doesn't stop a MITM attack from just doing the same thing. I understand that the key exchange must be verified somehow by a third party but I'm having a hard time understanding how it is that a third party can be the solution assuming that someone can do an MITM attack. Why couldn't they just do an MITM on the third party verification too? Is there really a fail proof way of completely eliminating all possible MITM attacks without some kind of pre-known by both parties?</p>
","<p>In a PKI system, ""certifying authorities"" are an important part of the infrastructure. Certifying authorities sign the public key and the identifying information, so that you know the corresponding private really belongs to the purported identity. This is true for EC keys just as it is for RSA.</p>

<p>By the way, <a href=""https://serverfault.com/questions/91212/do-any-well-known-cas-issue-elliptic-curve-certificates"">I've looked for CAs that issue EC certificates,</a> and apparently they aren't in practical use.</p>

<p>Most people obtain certificates for their certifying authorities as part of their operating system or security application. They trust these certificates implicitly. There are several dangers here, though.</p>

<p>First, most users don't have an effective way to verify the integrity of these certificates. This is a pretty hard problem, because, at the root of it, you have to have a 100% trustworthy channel for the verification&mdash;channel between the authority and the user with which an attacker cannot tamper. When a user downloads a new browser with an collection of root certificates, he can't know that the software wasn't tampered with in transit, or even built with a bogus CA certificate in the collection.</p>

<p>Even if the certificate collection is received intact as the provider intended, there have been questions raised about the integrity of many certifying authorities included by default in popular software. For example, some have pointed out that telecommunications companies in states that have been linked to terror sponsorship have their certificates included in popular browsers. Any trusted authority can issue a certificate for any domain name, and a browser will accept it without question.</p>

<p>In short, no, there is <em>no way</em> to establish a secure channel without first sharing some information on a secure channel. The benefit of PKI and asymmetric cryptography is that <em>one</em> exchange on a secure channel (the receipt of a trusted authority's certificate) permits the establishment of secure channels with <em>many</em> parties. But you have to bootstrap the system somehow.</p>
","1149","<security><diffie-hellman>","1","0","3","2011-09-09 03:51:38","","0","","","","","2011-09-02 13:19:02",""
"7284010","Protecting ECDH against MITM attacks","<p>I am working on a project that requires an ECDH key exchange. I am trying to understand how to protect against MITM attacks. I can sign the public key and send a signature along with the public key transfer to ensure that the key has not been tampered with but that doesn't stop a MITM attack from just doing the same thing. I understand that the key exchange must be verified somehow by a third party but I'm having a hard time understanding how it is that a third party can be the solution assuming that someone can do an MITM attack. Why couldn't they just do an MITM on the third party verification too? Is there really a fail proof way of completely eliminating all possible MITM attacks without some kind of pre-known by both parties?</p>
","<p>It sounds like you are heading down a path of rolling your own crypto protocol.  Don't do that.  It's a bad idea.  It leads to insecure systems.</p>

<p>Instead, use SSL or TLS.  That is designed to take care of the subtle issues in designing this kind of crypto protocol -- and it has been well-vetted.  You'll need a way to verify the other endpoint's certificate.  You could use a certification authority, or in some cases it might be feasible to hardcode the public key of the entity you expect to talk to.</p>

<p>You may get better answers if you ask on the <a href=""https://crypto.stackexchange.com/"">Crypto</a> stack exchange.</p>
","1149","<security><diffie-hellman>","1","0","3","2011-09-09 03:51:38","","0","","","","","2011-09-02 13:19:02",""
"2706506","RSA encrypted Diffie-Hellman handshake","<p>Would a RSA encrypted Diffie-Hellman handshake enable secure communication?
I'm encrypting communication from a silverlight client to a php webservice.
The silverlight client initiates they key agreement by sending the RSA public key encrypted DH parameters to the webservice. Only the webservice has the private key, so a MITM attack is not possible. The webservice sends plain text answer back to the client, and a key is agreed upon. This key is then used to encrypt communication between the webservice and silverlight client with AES, which is also encrypted with the RSA public key.</p>

<p>Does anyone see a flaw? </p>
","<p>There is no way to store a ""private"" key in your application securely.  </p>
","1101","<silverlight><rsa><diffie-hellman>","0","0","2","2010-04-25 23:39:27","2710401","1","","","","","2010-04-24 23:11:43",""
"2706506","RSA encrypted Diffie-Hellman handshake","<p>Would a RSA encrypted Diffie-Hellman handshake enable secure communication?
I'm encrypting communication from a silverlight client to a php webservice.
The silverlight client initiates they key agreement by sending the RSA public key encrypted DH parameters to the webservice. Only the webservice has the private key, so a MITM attack is not possible. The webservice sends plain text answer back to the client, and a key is agreed upon. This key is then used to encrypt communication between the webservice and silverlight client with AES, which is also encrypted with the RSA public key.</p>

<p>Does anyone see a flaw? </p>
","<p>This gains you nothing over just using SSL with a server certificate that's embedded in the client, and a cipher suite that uses DH key exchange.</p>
","1101","<silverlight><rsa><diffie-hellman>","0","0","2","2010-04-25 23:39:27","2710401","1","","","","","2010-04-24 23:11:43",""
"22676620","String to PublicKey using Diffie-Hellman algorithm","<p>I have a Public key string (128 bytes byte to hex processed) given by my client. I need to generate shared key using the private key and Public key given by client. I'm getting below exception while converting the String to Public key. I tried <strong>decoding/encoding</strong> the bytes, no improvement. I have the following code.</p>

<p>// This is a sample key.</p>

<pre><code>private static final String PUB_KEY = ""0DC1B7102DE3F6785A284ABFCA1822A6B59C947B5F2FAAE"" + ""672D8EE29C3D801BC153777CD3AF5478FD25C234C50BBABF8CD5215A8F1CB19B0B4A24FD5E9"" + ""412264646E2A06FCB5929FFBE196A1BD58B9927424C3B3D0388FDDA15FD1FF1C3E7600A629E"" + 
""B3F0B38B85CCCE03D44CF8D53B2E4E5EFD54E991CE92E55B10FCCD79F04"";

public static void main(String[] argv) throws Exception {   
    PublicKey key = getKey(h2b(PUB_KEY));
}

private static PublicKey getKey(final byte[] pubKey) throws Exception {
    final KeyFactory keyFactory = KeyFactory.getInstance(""DH"");  
    final X509EncodedKeySpec keySpec = new X509EncodedKeySpec(pubKey);
    return keyFactory.generatePublic(keySpec); // THROWS EXCEPTION
}

private static byte[] h2b(String hex) {
    if ((hex.length() &amp; 0x01) == 0x01)
        throw new IllegalArgumentException();
    byte[] bytes = new byte[hex.length() / 2];
    for (int idx = 0; idx &lt; bytes.length; ++idx) {
        int hi = Character.digit((int) hex.charAt(idx * 2), 16);
        int lo = Character.digit((int) hex.charAt(idx * 2 + 1), 16);
        if ((hi &lt; 0) || (lo &lt; 0))
            throw new IllegalArgumentException();
        bytes[idx] = (byte) ((hi &lt;&lt; 4) | lo);
    }
    return bytes;
}
</code></pre>

<p>Throws follwoing excetpion. Any help to solve this?</p>

<p><strong>Exception in thread ""main"" java.security.spec.InvalidKeySpecException: Inappropriate key specification
    at com.sun.crypto.provider.DHKeyFactory.engineGeneratePublic(DHKeyFactory.java:87)</strong></p>
","<p>The <code>X509EncodedKeySpec</code> is expected to contain an array of bytes with the ASN.1 <code>SubjectPublicKeyInfo</code> structure.</p>

<p>The <code>PUB_KEY</code> in your example is probably the raw key value (<code>y</code> in the terms of <code>javax.crypto.spec.DHPublicKeySpec</code>) which is not enough to create the keyspec.</p>

<p>You should ask your client eother for the proper public key in the ASN.1 form to be used as input for <code>X509EncodedKeySpec</code> (this is preferable) or for <code>p</code> and <code>g</code> parameters required for <code>DHPublicKeySpec</code>.</p>
","1047","<java><encryption><public-key-encryption><diffie-hellman>","0","0","1","2014-03-27 05:46:48","","1","","3085625","","2014-03-27 01:59:11","2014-03-27 01:35:01",""
"33642100","Generating 64-byte public key for DH key exchange using Bouncy Castle","<p>I need to generate a key pair for Diffie-Hellman key exchange using the <code>secp256r1</code> curve using Bouncy Castle in C#. The public key should be 64 bytes (I'm not sure which format this is (compressed?), but I can find out).</p>

<p>I have the following code, but the lack of Bouncy Castle documentation has me lost.</p>

<pre><code>X9ECParameters ecParams = SecNamedCurves.GetByName(""secp256r1"");
var spec = new ECDomainParameters(ecParams.Curve, ecParams.G, ecParams.N, ecParams.H, ecParams.GetSeed());
var keyGenParams = new ECKeyGenerationParameters(spec, new SecureRandom());

var keyGen = new ECKeyPairGenerator(""ECDH"");
keyGen.Init(keyGenParams);
AsymmetricCipherKeyPair keyPair = keyGen.GenerateKeyPair();
var pubKeyInfo = SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(keyPair.Public);

// pubKeyInfo.GetDerEncoded()
// pubKeyInfo.GetEncoded()
// pubKeyInfo.PublicKey
// pubKeyInfo.ToAsn1Object()
</code></pre>

<p>From here, I have access to a lot of different export formats (seen above), but most values end up being 335 bytes long. <code>pubKeyInfo.PublicKeyData.GetBytes()</code> gives 65 bytes, but I'm not sure why.</p>

<p>I must have some basic misunderstanding here. What am I missing?</p>

<p>If it helps, another client uses the <a href=""https://github.com/kmackay/micro-ecc/blob/master/uECC.c#L981"" rel=""nofollow""><code>uECC_make_key</code> function</a> to generate the key pair.</p>
","<p>I believe the data  is provided by <code>pubKeyInfo.PublicKeyData.GetBytes()</code>. It's 65 bytes long because it has a prefix <code>0x04</code> byte indicating that the remaining 64 bytes describe the public key in uncompressed format (vs. <code>0x02</code> indicating compressed format).</p>

<p>See <a href=""https://bitcointalk.org/index.php?topic=42384.0"" rel=""nofollow"">here</a> for some discussion.</p>
","1042","<c#><.net><diffie-hellman>","3","1","1","2015-11-11 00:21:35","","0","","1364007","","2015-11-11 00:21:35","2015-11-10 23:30:21",""
"7949471","Windows CNG ECDH Secret Agreement structure","<p>I've spent a few days by searching what structure does ECDH secret agreement have, but no success. I found in MSDN that the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376289%28v=vs.85%29.aspx"" rel=""nofollow"">NCryptSecretAgreement</a> function sets a pointer to an NCRYPT_SECRET_HANDLE variable that receives a handle that represents the secret agreement value. I'm not familar with WinAPI at all so I simply can't do anything but reading docs.</p>

<p>I need to exchange keys between a Windows-based desktop app and a web app. <strong>What I need to know is how exactly CNG's KDF uses (hashes in my case) the secret agreement value.</strong> I'm using the SHA-256 algorithm as KDF and trying to hash X and Y of the secret agreement but result doesn't match to the one CNG computes. Any ideas?</p>

<p>Thank you.</p>
","<p>I cannot vouch for what Microsoft found fit to implement, but there is a standard on ECDH called <a href=""http://webstore.ansi.org/RecordDetail.aspx?sku=ANSI%20X9.63:2001"" rel=""nofollow"">X9.63</a>. In that standard, ECDH works like this:</p>

<ul>
<li><p>You run the DH thing, yielding the common curve point <em>(X, Y)</em> (that's the point you got from the peer, multiplied by your secret DH value).</p></li>
<li><p>You convert <em>X</em> (and only <em>X</em>; <em>Y</em> is discarded) into a sequence of bytes which we will call <em>Z</em>. Conversion is unsigned big-endian, and uses the field size: if <em>X</em> lives in field <em>F<sub>q</sub></em>, then the conversion yields exactly <em>ceil(ceil(log q)/8)</em>. E.g. if you use the NIST P-521 curve, you work modulo a prime <em>q</em> which is such that <em>2<sup>520</sup> &lt; q &lt; 2<sup>521</sup></em>, so <em>ceil(log q) = 521</em> and the resulting byte sequence consists in exactly 66 bytes, whatever the value <em>X</em>. With the most commonly used elliptic curve (known as ""P-256""), that's 32 bytes.</p></li>
<li><p>To derive <em>Z</em> into a key, with a hash function <em>H</em> which has an output length of <em>n</em> bytes (e.g. <em>n = 32</em> with SHA-256), you compute the potentially infinite string <em>H<sub>1</sub>||H<sub>2</sub>||H<sub>3</sub>||...</em> where ""<em>||</em>"" denotes concatenation, and <em>H<sub>i</sub> = H(Z||i)</em> where ""<em>i</em>"" is represented as four bytes, using big-endian convention. In plain words, you hash <em>Z</em> along with a 32-bit counter, and do so again and again until you have enough bytes for your intended key length.</p></li>
</ul>
","1035","<windows><elliptic-curve><diffie-hellman><cng>","2","1","1","2019-08-19 10:32:44","7953736","0","1","608639","","2019-08-19 10:32:44","2011-10-31 02:32:03",""
"44224561","Generate Derived Key from Shared Secret (ECDH-ES) - ConcatKDF","<p>I have used the <a href=""https://github.com/ricmoo/GMEllipticCurveCrypto"" rel=""noreferrer"">https://github.com/ricmoo/GMEllipticCurveCrypto</a> to generate a Shared Secret using ECDH Algorithm.</p>

<p>I now have to Generate a Derived Key using the ECDH-ES algorithm as mentioned here: <a href=""https://tools.ietf.org/html/rfc7518#section-4.6"" rel=""noreferrer"">https://tools.ietf.org/html/rfc7518#section-4.6</a></p>

<p>I had highly appreciate if someone could guide me in the direction of generating a Derived Key</p>
","<p>You need to read about <a href=""https://en.wikipedia.org/wiki/Key_derivation_function"" rel=""nofollow noreferrer"">KDF</a> in general and <a href=""https://en.wikipedia.org/wiki/HKDF"" rel=""nofollow noreferrer"">HKDF</a> as common example. BTW KDF was mentioned in link you provided.</p>
","1033","<ios><objective-c><encryption><diffie-hellman><kdf>","12","2","1","2019-05-15 15:46:59","","0","2","942966","","2017-10-13 10:47:05","2017-05-28 06:47:28",""
"32947040","How to reject weak DH parameters in an OpenSSL client?","<p>Currently OpenSSL in client mode stops handshake only if the keylength of server selected DH parameters is less than 768 bit (hardcoded in source).</p>

<p>In my client I want to stop handshake if the keylength of Server selected DH parameters is less than 2048-bit. The preferred way would be to set via API, e.g. option setting exposed by OpenSSL.</p>

<p>Is there any way to set the minimum key length using public APIs?</p>
","<blockquote>
  <p>Is there any way to set the minimum key length using public APIs?</p>
</blockquote>

<p>Yes (or maybe I should say, ""I believe so""). Use your Diffie-Hellman callback. The callback is set with <a href=""http://www.openssl.org/docs/manmaster/ssl/SSL_CTX_set_tmp_dh_callback.html"" rel=""nofollow noreferrer"">SSL_CTX_set_tmp_dh_callback</a> and <a href=""http://www.openssl.org/docs/manmaster/ssl/SSL_CTX_set_tmp_dh_callback.html"" rel=""nofollow noreferrer"">SSL_set_tmp_dh_callback</a>.</p>

<p>Usually the Diffie-Hellman callback is used on the server to generate its keys. But according to OpenSSL's <a href=""https://www.openssl.org/docs/manmaster/ssl/SSL_CTX_set_tmp_dh_callback.html"" rel=""nofollow noreferrer""><code>SSL_CTX_set_tmp_dh_callback(3)</code></a> man page, its ""... to be used when a DH parameters are required for <code>tmp_dh_callback</code>..."".</p>

<p>For an example of using the callback in the context of a server (which should be similar to using it in a client), see <a href=""https://stackoverflow.com/a/29834909/608639"">'No Shared Cipher' Error with EDH-RSA-DES-CBC3-SHA</a>. It performs key length checks.</p>
","1020","<openssl><diffie-hellman>","2","1","1","2015-10-05 13:52:25","","2","","608639","","2015-10-05 13:52:25","2015-10-05 11:04:23",""
"28005253","Diffie-Hellman with BIGNUM (OpenSSL) vs. BigInteger (C#)","<p>I'm implementing a <a href=""http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"" rel=""nofollow"">Diffie-Hellman</a> key exchange algorithm between an embedded device which uses OpenSSL libraries for <code>BIGNUM</code> operations and a C# software which uses <code>System.Numerics.BigInteger</code> methods to calculate the secret shared key generation. </p>

<p>But after Alice and Bob exchange keys, they calculate different shared secrets.</p>

<p>The keys are printed out on each side <code>(PubA, PrivA, PubB, PrivB, DHPrime, DHGenerator)</code> and I can see that they are the same.</p>

<p>I suspect there is an issue about little/big endianness, or maybe openssl doesn't care about negative numbers for the exponent, and I don't know how to debug those operations. I don't have the code with me right now, but all the operations are kept simple, like this. </p>

<p><strong>C# side</strong></p>

<pre><code>BigInteger bintA = new BigInteger(baByteArrayReceived);
BigInteger bintb = new BigInteger(baRandomBobSecret);
BigInteger bintDHPrime = new BigInteger(baDHPrime2048);

BigInteger bintSharedSecret = bintA.ModPow(bintb,bintDHPrime);
</code></pre>

<p><strong>C side</strong></p>

<pre><code>BIGNUM *bnB = BN_new();
BIGNUM *bna = BN_new();
BIGNUM *bnDHPrime = BN_new();
BIGNUM *bnResult = BN_new();
BN_CTX *bnctx = BN_CTX_new();

BN_bin2bn(baBReceived, 256,bnB);
BN_bin2bn(baRandomAliceSecret, 256,bna);
BN_bin2bn(baDHPrime2048, 256,bnDHPrime);

BN_mod_exp(bnResult,bnB,bna,bnDHPrime,bnctx);
</code></pre>

<p>Some additional info for C methods of OpenSSL:
></p>

<blockquote>
<pre><code>BIGNUM *BN_bin2bn(const uint8_t *in, size_t len, BIGNUM *ret);
</code></pre>
  
  <p><strong>BN_bin2bn</strong> sets |*ret| to the value of |len| bytes from |in|, interpreted as a <strong>big-endian number</strong>, and returns |ret|. If |ret| is NULL then a fresh |BIGNUM| is allocated and returned. It returns NULL on allocation failure.</p>

<pre><code> int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, 
     const BIGNUM *m, BN_CTX *ctx);
</code></pre>
  
  <p><strong>BN_mod_exp</strong> sets |r| equal to |a|^{|p|} mod |m|. It does so with the best algorithm for the values provided and can run in constant time if |BN_FLG_CONSTTIME| is set for |p|. It returns one on success or zero otherwise.</p>
</blockquote>

<p>And they produce different results. </p>

<p>What should I do about this? What would be your next thing to check? </p>

<p>Thanks in advance.</p>
","<p>Solved by using BouncyCastle Crypto Library's BigInteger methods. Couldn't tell System.Numerics.BigInteger that we are using big endian unsigned chars for initialization.</p>
","970","<c#><c><openssl><biginteger><diffie-hellman>","5","1","1","2015-01-21 15:09:38","28070459","4","","916000","","2015-01-18 15:55:09","2015-01-17 22:57:02",""
"48643291","Change KexAlgorithms on OpenSSH","<p>I would like to disable 'diffie-hellman-group1-sha1' and 'diffie-hellman-group-exchange-sha1' key exchange algorithms on my OpenSSH.
I edited /etc/ssh/sshd_config and added this line:
KexAlgorithms ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha256</p>

<p>After this I restarted SSH by command -> 'service sshd restart'</p>

<p>Now, when I run command 'ssh -Q kex', the output is still:
diffie-hellman-group1-sha1
diffie-hellman-group14-sha1
diffie-hellman-group14-sha256
diffie-hellman-group16-sha512
diffie-hellman-group18-sha512
diffie-hellman-group-exchange-sha1
diffie-hellman-group-exchange-sha256
ecdh-sha2-nistp256
ecdh-sha2-nistp384
ecdh-sha2-nistp521
curve25519-sha256
curve25519-sha256@libssh.org
gss-gex-sha1-
gss-group1-sha1-
gss-group14-sha1-</p>

<p>Why didn't do any changes? Did I do something wrong?</p>
","","969","<openssh><diffie-hellman><sshd>","0","","0","2018-02-28 10:31:52","","1","","","","","2018-02-06 12:39:07",""
"22492417","Java - Diffie-Hellman Encryption - Wrong Output","<p>I'm attempting to implement Diffie-Hellman key exchange. I am a little confused with how to use the secret key once generated.</p>

<p>As seen in the output, the 2 secret keys are generated using the same prime &amp; base as normal in the key exchange, and trade public keys when generating the secret keys, however they are not outputting the same value as I expected.</p>

<p>I'm getting very confused with how to implement this encryption method and would be very grateful for some direction.  My overall aim for this is to implement an encrypted SMS Android application.</p>

<p><img src=""https://i.stack.imgur.com/1hO9P.png"" alt=""enter image description here""><br>
    (The screenshot was unable to capture the entire length of a &amp; b's base &amp; prime)</p>

<pre><code>AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator.getInstance(""DH"");
paramGen.init(512); // number of bits
AlgorithmParameters params = paramGen.generateParameters();
DHParameterSpec dhSpec = (DHParameterSpec)params.getParameterSpec(DHParameterSpec.class); 

BigInteger p512 = dhSpec.getP();
BigInteger g512 = dhSpec.getG();

//A  
KeyPairGenerator akpg = KeyPairGenerator.getInstance(""DiffieHellman"");

DHParameterSpec param = new DHParameterSpec(p512, g512);
System.out.println(""Prime: "" + p512);
System.out.println(""Base: "" + g512);
akpg.initialize(param);
KeyPair kp = akpg.generateKeyPair();

//B
KeyPairGenerator bkpg = KeyPairGenerator.getInstance(""DiffieHellman"");

DHParameterSpec param2 = new DHParameterSpec(p512, g512);
System.out.println(""Prime: "" + p512);
System.out.println(""Base: "" + g512);
bkpg.initialize(param2);
KeyPair kp2 = bkpg.generateKeyPair();


KeyAgreement aKeyAgree = KeyAgreement.getInstance(""DiffieHellman"");
KeyAgreement bKeyAgree = KeyAgreement.getInstance(""DiffieHellman"");

aKeyAgree.init(kp.getPrivate());
bKeyAgree.init(kp2.getPrivate());

aKeyAgree.doPhase(kp2.getPublic(), true);
bKeyAgree.doPhase(kp.getPublic(), true);

//System.out.println(""Alice Secret Key: "" + aKeyAgree.generateSecret());
//System.out.println(""Bob's Secret Key: "" + bKeyAgree.generateSecret());

MessageDigest hash = MessageDigest.getInstance(""SHA-256"");

byte[] ASharedSecret = hash.digest(aKeyAgree.generateSecret());
byte[] BSharedSecret = hash.digest(bKeyAgree.generateSecret());

System.out.println(""Alice's Shared Secret: "" + ASharedSecret.toString());
System.out.println(""Bob's Shared Secret: "" + BSharedSecret.toString());
</code></pre>
","<p>byte[].toString() doesn't print the contents. Try Arrays.toString().</p>
","964","<java><android><public-key-encryption><diffie-hellman>","0","2","1","2015-04-24 19:15:26","","2","4","701303","","2015-04-24 19:15:26","2014-03-18 22:30:11",""
"2695907","Diffie-Hellman in Silverlight","<p>I am trying to devise a security scheme for encrypting the application level data between a silverlight client, and a php webservice that I created. Since I am dealing with a public website the information I am pulling from the service is public, but the information I'm submitting to the webservice is not public. There is also a back end to the website for administration, so naturally all application data being pushed and pulled from the webservice to the silverlight administration back end must also be encrypted. </p>

<p>Silverlight does not support asymmetric encryption, which would work for the public website. Symmetric encryption would only work on the back end because users do not log in to the public website, so no password based keys could be derived. Still symmetric encryption would be great, but I cannot securely save the private key in the silverlight client. Because it would either have to be hardcoded or read from some kind of config file. None of that is considered secure. So... plan B.</p>

<p>My final alternative would be then to implement the Diffie-Hellman algorithm, which supports symmetric encryption by means of key agreement. However Diffie-Hellman is vulnerable to man-in-the-middle attacks. In other words, there is no guarantee that either side is sure of each others identity, making it possible for communication to be intercepted and altered without the receiving party knowing about it. It is thus recommended to use a private shared key to encrypt the key agreement handshaking, so that the identity of either party is confirmed.</p>

<p>This brings me back to my initial problem that resulted in me needing to use Diffie-Hellman, how can I use a private key in a silverlight client without hardcoding it either in the code or an xml file.</p>

<p>I'm all out of love on this one... is there any answer to this?</p>

<p><strong>EDIT:</strong></p>

<p>Remember that this is about a custom PHP web service that I rolled out on my own.</p>

<p>I found an RSA implementation i can use in Silverlight. It seems pretty safe to use this to encrypt the handshake for the  DiffieHellman key agreement between the Silverlight client and PHP web service, and subsequently also use it to encrypt the symmetric key that was agreed upon (which is itself generated from the result of the key exchange by hashing it). </p>

<p>After this I'm pretty much guaranteed that all communication <strong>going to</strong> the web service has not been intercepted, modified and then retransmitted (MITM). However I believe it is still possible; technically, for an attacker to impersonate the silverlight client and send messages to the webservice (assuming they discover the url). </p>

<p>Security from unauthorized access is provided since the attacker does not know the ""secret api"" of my custom webservice, hence they are unable to communicate with it. </p>

<p>The only way to break this would be to brute force the webservice with whatever strings an attacker may suspect to be valid to try and get a response from the web service. I don't think you can brute force a variable length string. It sounds impractical.</p>

<p>Does anyone see a problem with this approach?</p>
","<p>The obvious solution would be to use WCF to establish an SSL or TLS connection instead of attempting to build that into the application.</p>
","957","<silverlight><diffie-hellman><encryption-symmetric>","3","1","3","2010-05-04 03:16:30","2695983","1","","134485","","2010-04-23 16:29:14","2010-04-23 02:54:55",""
"2695907","Diffie-Hellman in Silverlight","<p>I am trying to devise a security scheme for encrypting the application level data between a silverlight client, and a php webservice that I created. Since I am dealing with a public website the information I am pulling from the service is public, but the information I'm submitting to the webservice is not public. There is also a back end to the website for administration, so naturally all application data being pushed and pulled from the webservice to the silverlight administration back end must also be encrypted. </p>

<p>Silverlight does not support asymmetric encryption, which would work for the public website. Symmetric encryption would only work on the back end because users do not log in to the public website, so no password based keys could be derived. Still symmetric encryption would be great, but I cannot securely save the private key in the silverlight client. Because it would either have to be hardcoded or read from some kind of config file. None of that is considered secure. So... plan B.</p>

<p>My final alternative would be then to implement the Diffie-Hellman algorithm, which supports symmetric encryption by means of key agreement. However Diffie-Hellman is vulnerable to man-in-the-middle attacks. In other words, there is no guarantee that either side is sure of each others identity, making it possible for communication to be intercepted and altered without the receiving party knowing about it. It is thus recommended to use a private shared key to encrypt the key agreement handshaking, so that the identity of either party is confirmed.</p>

<p>This brings me back to my initial problem that resulted in me needing to use Diffie-Hellman, how can I use a private key in a silverlight client without hardcoding it either in the code or an xml file.</p>

<p>I'm all out of love on this one... is there any answer to this?</p>

<p><strong>EDIT:</strong></p>

<p>Remember that this is about a custom PHP web service that I rolled out on my own.</p>

<p>I found an RSA implementation i can use in Silverlight. It seems pretty safe to use this to encrypt the handshake for the  DiffieHellman key agreement between the Silverlight client and PHP web service, and subsequently also use it to encrypt the symmetric key that was agreed upon (which is itself generated from the result of the key exchange by hashing it). </p>

<p>After this I'm pretty much guaranteed that all communication <strong>going to</strong> the web service has not been intercepted, modified and then retransmitted (MITM). However I believe it is still possible; technically, for an attacker to impersonate the silverlight client and send messages to the webservice (assuming they discover the url). </p>

<p>Security from unauthorized access is provided since the attacker does not know the ""secret api"" of my custom webservice, hence they are unable to communicate with it. </p>

<p>The only way to break this would be to brute force the webservice with whatever strings an attacker may suspect to be valid to try and get a response from the web service. I don't think you can brute force a variable length string. It sounds impractical.</p>

<p>Does anyone see a problem with this approach?</p>
","<p>SSL/TLS suffers from the same problem that any Diffie-Hellman-based implementation you come up with would have, in that it can still be broken by a man-in-the-middle attack.</p>

<p>The reason TLS is secure and trusted is because the client, when receiving the server's certificate, authenticates it by checking that it is signed with another certificate from a known trusted identity - say, VeriSign. Thus far, this makes it impossible to enact a man-in-the-middle attack without having VeriSign's <em>private</em> key - when the interloper sends a fake certificate proclaiming to be the server, the client would easily detect that this certificate is not signed using the trusted identity's certificate, and bails out of the connection, displaying a warning to the user.</p>

<p>For your purposes, it's likely easiest to use TLS. To make it secure, you would generate a certificate for your server, and then embed in your client the <em>public</em> key for that certificate. The client can then verify that it is talking to your server, without having to expose the private key, which you <em>don't</em> have to distribute.</p>

<p><strong>EDIT:</strong> In response to your comment on Jerry's answer, if your hosting provider doesn't allow SSL/TLS connections at all, preventing a man-in-the-middle attack will be tricky. If this is your only reason for avoiding TLS, I would suggest getting your provider to turn it on, or finding a provider that allows for it.</p>

<p><strong>EDIT:</strong> In response to your edited question: even if you're now using RSA in your Silverlight client to send data to your web service, you cannot guarantee that the client <em>itself</em> has not been modified. It's quite possible for an attacker to dig into your client, determine the algorithm you're using to perform the encryption/handshake, and then write code to impersonate your client (or indeed, modify the client to include their code). Once they've done that, they can start analyzing your API and use it to make calls to your web service.</p>

<p>It's the same with SSL/TLS - the client can validate the identity of the host using the host's certificate, and as long as the host's server is secured, the client can trust the output from the host; however, there is no mechanism in which the host can 100% validate that the client is who they say they are, as the client will be run on a machine which does not have a controlled execution environment.</p>

<p>However - despite the above being true, and that it's <em>possible</em> that an attacker can compromise your system in this way, it's likely not <em>probable</em> -- unless you're working on a public-facing system that attracts a lot of attention/use, or a system that deals directly with money in some form, the attacker needs to make some effort before being able to send their own input to your web service.</p>

<p>Your best bet is to validate the input received by your web service thoroughly, and don't leave dangling APIs accessible that your regular client would never use.</p>
","957","<silverlight><diffie-hellman><encryption-symmetric>","3","3","3","2010-05-04 03:16:30","2695983","1","","134485","","2010-04-23 16:29:14","2010-04-23 02:54:55",""
"2695907","Diffie-Hellman in Silverlight","<p>I am trying to devise a security scheme for encrypting the application level data between a silverlight client, and a php webservice that I created. Since I am dealing with a public website the information I am pulling from the service is public, but the information I'm submitting to the webservice is not public. There is also a back end to the website for administration, so naturally all application data being pushed and pulled from the webservice to the silverlight administration back end must also be encrypted. </p>

<p>Silverlight does not support asymmetric encryption, which would work for the public website. Symmetric encryption would only work on the back end because users do not log in to the public website, so no password based keys could be derived. Still symmetric encryption would be great, but I cannot securely save the private key in the silverlight client. Because it would either have to be hardcoded or read from some kind of config file. None of that is considered secure. So... plan B.</p>

<p>My final alternative would be then to implement the Diffie-Hellman algorithm, which supports symmetric encryption by means of key agreement. However Diffie-Hellman is vulnerable to man-in-the-middle attacks. In other words, there is no guarantee that either side is sure of each others identity, making it possible for communication to be intercepted and altered without the receiving party knowing about it. It is thus recommended to use a private shared key to encrypt the key agreement handshaking, so that the identity of either party is confirmed.</p>

<p>This brings me back to my initial problem that resulted in me needing to use Diffie-Hellman, how can I use a private key in a silverlight client without hardcoding it either in the code or an xml file.</p>

<p>I'm all out of love on this one... is there any answer to this?</p>

<p><strong>EDIT:</strong></p>

<p>Remember that this is about a custom PHP web service that I rolled out on my own.</p>

<p>I found an RSA implementation i can use in Silverlight. It seems pretty safe to use this to encrypt the handshake for the  DiffieHellman key agreement between the Silverlight client and PHP web service, and subsequently also use it to encrypt the symmetric key that was agreed upon (which is itself generated from the result of the key exchange by hashing it). </p>

<p>After this I'm pretty much guaranteed that all communication <strong>going to</strong> the web service has not been intercepted, modified and then retransmitted (MITM). However I believe it is still possible; technically, for an attacker to impersonate the silverlight client and send messages to the webservice (assuming they discover the url). </p>

<p>Security from unauthorized access is provided since the attacker does not know the ""secret api"" of my custom webservice, hence they are unable to communicate with it. </p>

<p>The only way to break this would be to brute force the webservice with whatever strings an attacker may suspect to be valid to try and get a response from the web service. I don't think you can brute force a variable length string. It sounds impractical.</p>

<p>Does anyone see a problem with this approach?</p>
","<p>I recommend starting with this JavaScript+PHP DH key Exchange protocol:
<a href=""http://enanocms.org/News:Article/2008/02/20/Diffie_Hellman_key_exchange_implemented"" rel=""nofollow noreferrer"">http://enanocms.org/News:Article/2008/02/20/Diffie_Hellman_key_exchange_implemented</a></p>

<p>You can then re-write the javascript in silverlight.  I recommend using Wireshark to dump packets then you can use Meld or whatever to diff the packets to see where your implementation is differs from the original. </p>

<p>Good Luck!</p>

<p>(Disclaimer:  I totally agree with the Enano dev team,  this is not a full replacement of SSL and SSL should be used whenever possible.)</p>
","957","<silverlight><diffie-hellman><encryption-symmetric>","3","0","3","2010-05-04 03:16:30","2695983","1","","134485","","2010-04-23 16:29:14","2010-04-23 02:54:55",""
"33813108","BouncyCastle Diffie Hellman","<p>I want to write a complete diffie Hellman example for bouncy castle that includes key generation, key exchange, encryption, and decryption. <strong>I also want to verify that if Alice is initiating a connection to Bob, that she should send her public key, Parameter P, and Parameter G.</strong></p>

<p>I posted a <a href=""https://codereview.stackexchange.com/questions/110952/bouncycastle-diffie-hellman"">Code Review</a>. However, that is more about style, syntax, and grammar. I'm still trying to make sure my logic is correct.</p>

<p><a href=""https://stackoverflow.com/questions/29089311/how-to-use-bouncycastles-diffie-hellman-in-c"">This</a> is also a good reference.</p>

<p>Namespaces:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Org.BouncyCastle.Asn1;
using Org.BouncyCastle.Asn1.X9;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Agreement;
using Org.BouncyCastle.Crypto.Agreement.Kdf;
using Org.BouncyCastle.Crypto.Digests;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Utilities;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.Asn1.X509;
using System.Diagnostics;
using Org.BouncyCastle.OpenSsl;
</code></pre>

<p>Some constants for this test case:</p>

<pre><code>const string Algorithm = ""ECDH""; //What do you think about the other algorithms?
const int KeyBitSize = 256;
const int NonceBitSize = 128;
const int MacBitSize = 128;
const int DefaultPrimeProbability = 30;
</code></pre>

<p>Main method that starts the pairing and handles verifying encryption:</p>

<pre><code>public static void TestMethod() {
    //BEGIN SETUP ALICE
    IAsymmetricCipherKeyPairGenerator aliceKeyGen = GeneratorUtilities.GetKeyPairGenerator (Algorithm);
    DHParametersGenerator aliceGenerator = new DHParametersGenerator ();
    aliceGenerator.Init (KeyBitSize, DefaultPrimeProbability, new SecureRandom ());
    DHParameters aliceParameters = aliceGenerator.GenerateParameters ();

    KeyGenerationParameters aliceKGP = new DHKeyGenerationParameters (new SecureRandom (), aliceParameters);
    aliceKeyGen.Init (aliceKGP);

    AsymmetricCipherKeyPair aliceKeyPair = aliceKeyGen.GenerateKeyPair ();
    IBasicAgreement aliceKeyAgree = AgreementUtilities.GetBasicAgreement (Algorithm);
    aliceKeyAgree.Init (aliceKeyPair.Private);

    //END SETUP ALICE

    /////AT THIS POINT, Alice's Public Key, Alice's Parameter P and Alice's Parameter G are sent unsecure to BOB

    //BEGIN SETUP BOB
    IAsymmetricCipherKeyPairGenerator bobKeyGen = GeneratorUtilities.GetKeyPairGenerator (Algorithm);
    DHParameters bobParameters = new DHParameters( aliceParameters.P, aliceParameters.G );

    KeyGenerationParameters bobKGP = new DHKeyGenerationParameters (new SecureRandom (), bobParameters);
    bobKeyGen.Init (bobKGP);

    AsymmetricCipherKeyPair bobKeyPair = bobKeyGen.GenerateKeyPair ();
    IBasicAgreement bobKeyAgree = AgreementUtilities.GetBasicAgreement (Algorithm);
    bobKeyAgree.Init (bobKeyPair.Private);
    //END SETUP BOB

    BigInteger aliceAgree = aliceKeyAgree.CalculateAgreement (bobKeyPair.Public);
    BigInteger bobAgree = bobKeyAgree.CalculateAgreement (aliceKeyPair.Public);

    if (!aliceAgree.Equals (bobAgree)) {
        throw new Exception (""Keys do not match."");
    }

    byte[] nonSecretMessage = GetBytes (""HeaderMessageForASDF"");
    byte[] secretMessage = GetBytes (""Secret message contents"");
    byte[] decNonSecretBytes;

    KeyParameter sharedKey = new KeyParameter (aliceAgree.ToByteArrayUnsigned ());

    var encMessage = EncryptMessage( sharedKey, nonSecretMessage, secretMessage );
    var decMessage = DecryptMessage( sharedKey, encMessage, out decNonSecretBytes );

    var decNonSecretMessage = GetString( decNonSecretBytes );
    var decSecretMessage = GetString( decMessage );

    Debug.WriteLine( decNonSecretMessage + "" - "" + decSecretMessage );

    return;
}
</code></pre>

<p>Wrapper method to Encrypt a message with given data:</p>

<pre><code>public static byte[] EncryptMessage (string sharedKey, string nonSecretMessage, string secretMessage)
{
    return EncryptMessage( new KeyParameter( Convert.FromBase64String( sharedKey ) ), GetBytes( nonSecretMessage ), GetBytes( secretMessage ) );
}
</code></pre>

<p>Helper method to Encrypt a message with given data</p>

<pre><code>public static byte[] EncryptMessage( KeyParameter sharedKey, byte[] nonSecretMessage, byte[] secretMessage ) {
    if( nonSecretMessage != null &amp;&amp; nonSecretMessage.Length &gt; 255 ) throw new Exception( ""Non Secret Message Too Long!"" );
    byte nonSecretLength = nonSecretMessage == null ? (byte)0 : (byte)nonSecretMessage.Length;

    var nonce = new byte[NonceBitSize / 8];
    var rand = new SecureRandom();
    rand.NextBytes(nonce, 0, nonce.Length);

    var cipher = new GcmBlockCipher(new AesFastEngine());
    var aeadParameters = new AeadParameters(sharedKey, MacBitSize, nonce, nonSecretMessage );
    cipher.Init(true, aeadParameters);

    //Generate Cipher Text With Auth Tag
    var cipherText = new byte[cipher.GetOutputSize(secretMessage.Length)];
    var len = cipher.ProcessBytes(secretMessage, 0, secretMessage.Length, cipherText, 0);
    cipher.DoFinal(cipherText, len);

    using (var combinedStream = new MemoryStream())
    {
        using (var binaryWriter = new BinaryWriter(combinedStream))
        {
            //Prepend Authenticated Payload
            binaryWriter.Write(nonSecretLength);
            binaryWriter.Write(nonSecretMessage);

            //Prepend Nonce
            binaryWriter.Write(nonce);
            //Write Cipher Text
            binaryWriter.Write(cipherText);
        }
        return combinedStream.ToArray();
    }
}        
</code></pre>

<p>Wrapper method to Decrypt a message</p>

<pre><code>public static string DecryptMessage (string sharedKey, byte[] encryptedMessage, out string nonSecretPayload)
{
    byte[] nonSecretPayloadBytes;
    byte[] payload = DecryptMessage( new KeyParameter( Convert.FromBase64String( sharedKey ) ), encryptedMessage, out nonSecretPayloadBytes );

    nonSecretPayload = GetString( nonSecretPayloadBytes );
    return GetString( payload );
}
</code></pre>

<p>Helper method to decrypt a message</p>

<pre><code>public static byte[] DecryptMessage( KeyParameter sharedKey, byte[] encryptedMessage, out byte[] nonSecretPayloadBytes )
{
    using (var cipherStream = new MemoryStream(encryptedMessage))
    using (var cipherReader = new BinaryReader(cipherStream))
    {
        //Grab Payload
        int nonSecretLength = (int)cipherReader.ReadByte();
        nonSecretPayloadBytes = cipherReader.ReadBytes(nonSecretLength);

        //Grab Nonce
        var nonce = cipherReader.ReadBytes(NonceBitSize / 8);

        var cipher = new GcmBlockCipher(new AesFastEngine());
        var parameters = new AeadParameters(sharedKey, MacBitSize, nonce, nonSecretPayloadBytes);
        cipher.Init(false, parameters);

        //Decrypt Cipher Text
        var cipherText = cipherReader.ReadBytes(encryptedMessage.Length - nonSecretLength - nonce.Length);
        var plainText = new byte[cipher.GetOutputSize(cipherText.Length)];  

        try
        {
            var len = cipher.ProcessBytes(cipherText, 0, cipherText.Length, plainText, 0);
            cipher.DoFinal(plainText, len);
        }
        catch (InvalidCipherTextException)
        {
            //Return null if it doesn't authenticate
            return null;
        }

        return plainText;
    }
}
</code></pre>

<p>Returns byte data for a given string:</p>

<pre><code>static byte[] GetBytes(string str)
{
    if( str == null ) return null;
    return System.Text.Encoding.Unicode.GetBytes( str );
}
</code></pre>

<p>Returns a string for given byte data:</p>

<pre><code>static string GetString(byte[] bytes)
{
    if( bytes == null ) return null;
    return System.Text.Encoding.Unicode.GetString( bytes, 0, bytes.Length );
}
</code></pre>
","","946","<c#><encryption><bouncycastle><diffie-hellman>","2","","0","2015-11-19 19:50:36","","3","1","-1","","2017-05-23 10:30:54","2015-11-19 19:50:36",""
"32734700","Is there a way to bypass ""ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY"" on Chrome","<p>I have an application which used to work fine on Chrome before the update. But since the update I keep getting this error ""ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY""</p>

<p>I have been searching how to get rid of this error on Chrome</p>

<p>People have figured a way to do this on Mozilla and that's what I found on SO too. But is there a way to do it on Chrome as well. </p>

<p>I don't want all the unsecured websites to open in my browser, but at least my localhost. I cannot add any more ciphers to my application. </p>

<p>Thanks in advance. </p>

<p>Is there a way I can add exception for my localhost to bypass this. </p>
","<p>I found a solution, just add the appropriate ciphers to the domain.xml or server.xml</p>

<pre><code>ciphers=""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA""
</code></pre>

<p>There was actually a solution on SO. This link might help you too.. </p>

<p><a href=""https://stackoverflow.com/questions/30931692/diffie-hellman-public-key-error-with-tomcat-7"">Diffie-Hellman public key error with Tomcat 7</a></p>
","938","<google-chrome><diffie-hellman>","1","0","1","2015-09-24 06:45:25","","0","","","","","2015-09-23 08:36:49",""
"18418727","ssh2 how base 'G' and modulus 'P' are negociated, unknown field","<p>(first at all i'm sorry for my English because it is not my native language)
I try to understand ssh2 with wireshark(you can find the wireshark record here : <a href=""https://dl.dropboxusercontent.com/s/e9ut8z6v8oldg7g/ssh_wireshark.pcap?token_hash=AAGtkPMwKLt4IIr1Rlrht5_21HpMwQZBfeEFjGoRA85cjQ&amp;dl=1"" rel=""nofollow"">https://dl.dropboxusercontent.com/s/e9ut8z6v8oldg7g/ssh_wireshark.pcap?token_hash=AAGtkPMwKLt4IIr1Rlrht5_21HpMwQZBfeEFjGoRA85cjQ&amp;dl=1</a>) and rfc 4253 but i have some difficulties:</p>

<p>After SSH_MSG_KEXINIT messages there is SSH_MSG_KEXDH_INIT (30) and SSH_MSG_KEXDH_REPLY (31).</p>

<p>my problem is the understanding of SSH_MSG_KEXDH_INIT and SSH_MSG_KEXDH_REPLY.
According to the rfc4253:</p>

<pre><code>First, the client sends the following:

  byte      SSH_MSG_KEXDH_INIT
  mpint     e

The server then responds with the following:

  byte      SSH_MSG_KEXDH_REPLY
  string    server public host key and certificates (K_S)
  mpint     f
  string    signature of H
</code></pre>

<p>but with wireshark i see:</p>

<pre><code>from Client:

-SSH Version 2 (encryption:aes128-ctr mac:hmac-md5 compression:none)
    Packet Length: 76
    Padding Length: 5
    -Key Exchange
            Msg Code: Diffie-Hellman Key Exchange Init (30)
            Payload: 0000004104e2d6ad26e76531efa9ea(...)
            Padding String: 0000000000




from Server:
-SSH Version 2 (encryption:aes128-ctr mac:hmac-md5 compression:none)
    Packet Length: 292
    Padding Length: 8
    -Key Exchange
            Msg Code: Diffie-Hellman Key Exchange Reply (31)
            Multi Precision Integer Length: 104
            DH modulus (P): 0000001365636473612d73686(...)
            Multi Precision Integer Length: 65
            DH base (G): 04ead7f3936361df10c39d7d(...)
            Payload: 000000650000001365636473612d(...)
            Padding String: 0000000000000000
</code></pre>

<p>what are 'payload' fields? how base 'G' and modulus 'P' are negociated? an ecdsa public key is prime or composite number?</p>

<p>this is my analyze:</p>

<p>a)wireshark is wrong.</p>

<p>If rfc is right, payloads field are 'e' and 'f'!</p>

<p>But there is a problem : if rfc is right, modulus p and base g have to be known BEFORE SSH_MSG_KEXDH_INIT because we need them to compute 'e'; so the wireshark decoding is wrong because wireshark tell me that P and G are transmit AFTER SSH_MSG_KEXDH_INIT.</p>

<p>and there is something else telling me wireshark is wrong : if i decode the base64 that i can find in the /etc/....pub file, i can see the value of wireshark DH_modulus field.
So DH_modulus field is not really DH_modulus but server public host key : rfc is right, wireshark is wrong!</p>

<p>In this case base and modulus are not transmit by ""Diffie-Hellman Key Exchange Reply"" so how 'g' and 'p' are transmitted??are they ""prefixed"" in all ssh client/server and never transmitted?</p>

<p>b)wireshark is right</p>

<p>if we suppose server public host key is a prime number it can be DH_modulus and rfc AND wireshark are right.</p>

<p>but in this, there is again a problem : payload from client can't be 'e' because payload is transmit before DH_modulus and DH_base...</p>

<p>so what are the payload field? </p>

<p>when 'e' and 'f' are sent? because just after ""Diffie-Hellman Key Exchange Reply"" i have ""Newkeys messages"" which indicate the end of key exchange</p>

<p>but on other hand i have 4 packets to/from port 22 which are not decoded as ssh but it is maybe ""e"" and ""f""??</p>

<p>first two packet are 48 bytes length and the 2 others are 64bytes length.</p>

<p>are 'e' and 'f' transmitted in these 4 tcp packets ? maybe e and f are 64+48=112 bytes length?</p>

<p>as you can see i'm in confusion. can you help me (maybe not for all question but some indications can help)</p>

<p>thank you.</p>
","<p>In this case it's Wireshark incorrectly interpreting the public key algorithm.  Packet number 13 which came from the server is properly formatted according to RFC5656 (<a href=""http://tools.ietf.org/html/rfc5656"" rel=""nofollow"">http://tools.ietf.org/html/rfc5656</a>).  It's using the ecdsa-sha2-nistp256 algorithm which is an elliptic curve algorithm with 2 variables: q and r.</p>

<p>Wireshark is improperly parsing this packet using a different RFC (although not strictly 4253).  RFC5656 section 3.1 will give you the information you need to get on the right track.  For your information I'll post variables r and s in this response.</p>

<p>In reality, the information contained is:</p>

<p>Server's public host key (string K_S):
    string  ""ecdsa-sha2-nistp256"" (where ""nistp256"" is the [identifier])
    byte[n]  ecc_key_blob
               string  ""nistp256"" (repeated again as [identifier] portion of blob)
               string   Q (where Q is as follows)</p>

<p>Q (0073-00b3):
         04 bb e6 6e 8e   b6 b4 f8 29 8f e2 b1 ba
a0 2f 24 a2 d6 33 74 d4   17 ce b2 17 73 da 95 1a
ac c4 4b d7 a8 fc 92 6d   c6 c1 38 95 a6 5b 1f da
ec d2 29 df 2c 68 5c dc   de 36 bc 8b 34 16 24 28
0c 57 e1 7e</p>

<p>Server's ephemeral public key octet string (string Q_S):</p>

<p>Q_S (00b8-00f8):
                          04 ea d7 f3 93 63 61 df
10 c3 9d 7d bb ff 4d 38   0d 78 53 ea 00 97 30 b9
f5 cb a0 ea 1f 59 68 5b   c6 c6 de fb a8 16 f6 a9
e2 88 96 d8 e9 48 c4 c3   4a 24 bc 58 7f cd 6e b3
2f 4a 18 ac d7 68 d7 df   0b</p>

<p>Signature on the exchange hash (string):
    string  ""ecdsa-sha2-nistp256"" (again where nistp256 is the [identifier])
    string   ecdsa_signature_blob
               mpint r (011c-013c):
                                      00 84 0a a1
08 cf e8 2b a9 77 80 f2   82 99 59 e4 bb e4 f0 e8
bf 56 f2 ca 70 7a 4d 53   b0 6e b1 fc 0a</p>

<pre><code>           mpint s (0141-0161):
</code></pre>

<p>00 bb 2a 08 c1 3e 41   ec 27 db 24 e8 1f 57 06
db 55 9f 5d e9 fa 48 87   b2 2e 97 3c 46 59 7a 14
c9 40</p>

<p>Hopefully this helps clear up the confusion.  You'll still have a bit of research to do with RFC5656 and possibly referring back to RFC4253 to fill in the blanks but that is the breakdown of the packet.</p>

<p>Good luck!</p>

<p>Scott in New York, USA</p>
","937","<ssh><wireshark><public-key-encryption><diffie-hellman>","0","2","1","2013-09-16 20:42:45","","1","","","","","2013-08-24 12:46:02",""
"7935890","continued encryption with diffie-hellman shared key","<p>I'm currently working on a protocol, which uses Diffie-Hellman for an key exchange.
I receive a packet, which consists of an aes-128 encrypted part and a 128 Bit DH Public Key.</p>

<p>In a very last step in the protocol, the aes key is sent to another peer in the network.
This aes-key should be encrypted with a cipher using a 128 bit strong secretkey.</p>

<p>I plan to use Blowfish (can also be another cipher, doesn't really matter for the problem)</p>

<p>Now to encrypt the aes-key, with lets say blowfish, I have to build a secretkey for the encryption  with a class called SecretKeySpec (I'm using javax.crypto stuff), which takes an byteArray in the constructor to build the secretKey.</p>

<p>The sharedkey from DH is a 128 Bit BigInteger.
Well, now I can interpret my shared-key as a byteArray (wich gives me still 128 Bit in 16Bytes [where the numbers are interpreted as frames of 8 Bit data])</p>

<p>So my question is, how strong is my key really?</p>

<p>Is there any impact because I only use numbers as input for the byteArray (so does this limit the keyspace in any way?)</p>

<p>I think this is not the case, but I'm not 100% sure.
Maybe someone can do the math and proof me right or wrong.</p>

<p>If I'm wrong what keysize for the shared key give me piece of mind to finally get to the 128Bit SecretKey for the encryption?</p>
","<p>Not an expert in DH here, but to me it seems that DH's keyspace for the shared key represented in <em>n</em> bits is somewhat smaller than 2^<em>n</em>. </p>
","914","<java><security><key><theory><diffie-hellman>","3","1","2","2011-10-30 00:37:02","7941750","2","","","","","2011-10-28 23:28:15",""
"7935890","continued encryption with diffie-hellman shared key","<p>I'm currently working on a protocol, which uses Diffie-Hellman for an key exchange.
I receive a packet, which consists of an aes-128 encrypted part and a 128 Bit DH Public Key.</p>

<p>In a very last step in the protocol, the aes key is sent to another peer in the network.
This aes-key should be encrypted with a cipher using a 128 bit strong secretkey.</p>

<p>I plan to use Blowfish (can also be another cipher, doesn't really matter for the problem)</p>

<p>Now to encrypt the aes-key, with lets say blowfish, I have to build a secretkey for the encryption  with a class called SecretKeySpec (I'm using javax.crypto stuff), which takes an byteArray in the constructor to build the secretKey.</p>

<p>The sharedkey from DH is a 128 Bit BigInteger.
Well, now I can interpret my shared-key as a byteArray (wich gives me still 128 Bit in 16Bytes [where the numbers are interpreted as frames of 8 Bit data])</p>

<p>So my question is, how strong is my key really?</p>

<p>Is there any impact because I only use numbers as input for the byteArray (so does this limit the keyspace in any way?)</p>

<p>I think this is not the case, but I'm not 100% sure.
Maybe someone can do the math and proof me right or wrong.</p>

<p>If I'm wrong what keysize for the shared key give me piece of mind to finally get to the 128Bit SecretKey for the encryption?</p>
","<p>The <a href=""http://www.cryptopp.com/wiki/Diffie-Hellman"" rel=""nofollow"">Crypto++</a> website suggests using a minimum <code>p</code> of 3072 bits (or 256 bits for an <a href=""http://en.wikipedia.org/wiki/Elliptic_curve_cryptography"" rel=""nofollow"">ECC</a> implementation) to transport a 128 bit AES key.</p>

<p>You might wish to study the references provided at <a href=""http://www.keylength.com/en/compare/"" rel=""nofollow"">http://www.keylength.com/en/compare/</a> for further information about comparing key lengths among different algorithms.</p>
","914","<java><security><key><theory><diffie-hellman>","3","2","2","2011-10-30 00:37:02","7941750","2","","","","","2011-10-28 23:28:15",""
"28222970","SSL jdbc connection fails with Diffie-Hellman (DH_ANON) cipher suites","<p>I am trying create an SSL enabled connection to the Oracle database 11g (Release 11.2.0.1.0) using jdbc. I just want to use SSL for encryption only and not authentication, which is why I am using the Diffie-Hellman anonymous cipher suites, but it is failing. </p>

<p>I totally understand that anonymous cipher suites are not advisable and inherently insecure against man-in-the-middle attacks and probably I will not use it in production. But I would still like to find out what is wrong with my implementation that is preventing the ssl connection. Following is the excerpt of the code</p>

<pre><code>    String url = ""jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=tcps)(HOST=&lt;IP&gt;)(PORT=2484))(CONNECT_DATA=(SERVICE_NAME=&lt;service_name&gt;)) )"";
    Properties props = new Properties();
    props.setProperty(""user"", ""hr"");
    props.setProperty(""password"", ""hr"");
    props.setProperty(""oracle.net.ssl_cipher_suites"",    ""(SSL_DH_anon_WITH_3DES_EDE_CBC_SHA, SSL_DH_anon_WITH_RC4_128_MD5, SSL_DH_anon_WITH_DES_CBC_SHA)"");

    // commented out since Diffie-Hellman cipher suite should not require trust store or key-store, but the connection works only if I uncomment it.
    //props.setProperty(""javax.net.ssl.trustStore"", ""/truststore/cwallet.sso"");
    //props.setProperty(""javax.net.ssl.trustStoreType"", ""SSO"");

    Connection conn = null;
    try {
        //Security.insertProviderAt(new oracle.security.pki.OraclePKIProvider(),3);
        Class.forName(""oracle.jdbc.OracleDriver"");
        conn = DriverManager.getConnection(url, props);
        System.out.println(""conn "" + conn);
    } catch (Exception e) {
        e.printStackTrace();
    }
</code></pre>

<p>IN sqlnet.ora I added the following to make sure client is not authenticated and client server uses the same cipher suite:</p>

<pre><code>SSL_CLIENT_AUTHENTICATION = FALSE
SSL_CIPHER_SUITES=(SSL_DH_anon_WITH_3DES_EDE_CBC_SHA,SSL_DH_anon_WITH_RC4_128_MD5,SSL_DH_anon_WITH_DES_CBC_SHA)
</code></pre>

<p>However when I run the code I get the following error:</p>

<pre><code>java.sql.SQLRecoverableException: IO Error: The Network Adapter could not establish the connection
  at oracle.jdbc.driver.T4CConnection.logon(T4CConnection.java:419)
  at oracle.jdbc.driver.PhysicalConnection.&lt;init&gt;(PhysicalConnection.java:538)
  at oracle.jdbc.driver.T4CConnection.&lt;init&gt;(T4CConnection.java:228)
  at oracle.jdbc.driver.T4CDriverExtension.getConnection(T4CDriverExtension.java:32)
  at oracle.jdbc.driver.OracleDriver.connect(OracleDriver.java:521)
  at java.sql.DriverManager.getConnection(DriverManager.java:582)
  at java.sql.DriverManager.getConnection(DriverManager.java:154)
  at oracle.bi.modeling.Test.createConnection(Test.java:50)
  at oracle.bi.modeling.Test.main(Test.java:18)
    Caused by: oracle.net.ns.NetException: The Network Adapter could not establish the connection
  at oracle.net.nt.ConnStrategy.execute(ConnStrategy.java:375)
  at oracle.net.resolver.AddrResolution.resolveAndExecute(AddrResolution.java:422)
  at oracle.net.ns.NSProtocol.establishConnection(NSProtocol.java:686)
  at oracle.net.ns.NSProtocol.connect(NSProtocol.java:246)
  at oracle.jdbc.driver.T4CConnection.connect(T4CConnection.java:1056)
  at oracle.jdbc.driver.T4CConnection.logon(T4CConnection.java:308)
  ... 8 more
    Caused by: oracle.net.ns.NetException: Unable to initialize ssl context.
  at oracle.net.nt.CustomSSLSocketFactory.getSSLSocketFactory(CustomSSLSocketFactory.java:327)
  at oracle.net.nt.TcpsNTAdapter.connect(TcpsNTAdapter.java:110)
  at oracle.net.nt.ConnOption.connect(ConnOption.java:130)
  at oracle.net.nt.ConnStrategy.execute(ConnStrategy.java:353)
  ... 13 more
Caused by: oracle.net.ns.NetException: Unable to initialize the trust store.
  at oracle.net.nt.CustomSSLSocketFactory.getTrustManagerArray(CustomSSLSocketFactory.java:415)
  at oracle.net.nt.CustomSSLSocketFactory.getSSLSocketFactory(CustomSSLSocketFactory.java:311)
  ... 16 more
Caused by: java.io.IOException: Keystore was tampered with, or password was incorrect
  at sun.security.provider.JavaKeyStore.engineLoad(JavaKeyStore.java:771)
  at sun.security.provider.JavaKeyStore$JKS.engineLoad(JavaKeyStore.java:38)
  at java.security.KeyStore.load(KeyStore.java:1185)
  at oracle.net.nt.CustomSSLSocketFactory.getTrustManagerArray(CustomSSLSocketFactory.java:406)
  ... 17 more
    Caused by: java.security.UnrecoverableKeyException: Password verification failed
  at sun.security.provider.JavaKeyStore.engineLoad(JavaKeyStore.java:769)
  ... 20 more
</code></pre>

<p>If do specify the trust store, then the connection works fine when I uncomment the following lines:</p>

<pre><code>props.setProperty(""javax.net.ssl.trustStore"", ""/truststore/cwallet.sso"");
props.setProperty(""javax.net.ssl.trustStoreType"", ""SSO"");
</code></pre>

<p>But Diffie-Hellman cipher suite should not require truststore or keystore. So what am I doing wrong?</p>

<p>I do see the following in one of oracle docs:
<a href=""http://docs.oracle.com/cd/B28359_01/network.111/b28530/asossl.htm#i1009717"" rel=""nofollow"">http://docs.oracle.com/cd/B28359_01/network.111/b28530/asossl.htm#i1009717</a></p>

<p>""There is a known bug in which an OCI client requires a wallet even when using a cipher suite with DH_ANON, which does not authenticate the client.""</p>

<p>However I am not using OCI client. Instead I am using JDBC (ojdbc6.jar). Does the same exist even in JDBC? If so what is the work around to use Diffie-Hellman cipher suite?</p>

<p>Thanks</p>

<p>Joyjit</p>
","","908","<ssl><encryption><jdbc><oracle11g><diffie-hellman>","1","","0","2015-01-29 19:28:03","","2","","","","","2015-01-29 19:28:03",""
"17110723","why is the secret not the same for both parties?","<p>I'm trying to understand how the diffie hellman key exchange works and wrote a simple node.js program to make a test:</p>

<pre><code>var crypto = require(""crypto"");

//create a public &amp; private key for alice
var Alice = crypto.createDiffieHellman(512);
Alice.generateKeys();

//create a public &amp; private key for bob
var Bob = crypto.createDiffieHellman(512);
Bob.generateKeys();

//let bob and alice compute the shared secret
console.log(Alice.computeSecret(Bob.getPublicKey()).toString(""hex""));
console.log(Bob.computeSecret(Alice.getPublicKey()).toString(""hex""));
</code></pre>

<p>If i understood the right graphics on <a href=""http://en.wikipedia.org/wiki/Public-key_cryptography"" rel=""nofollow"">this</a> wikipedia article right, then both secrets should be the same. But they never are, why?</p>
","<p>Ah well I already found the solution:</p>

<pre><code>var crypto = require(""crypto"");

var prime = crypto.createDiffieHellman(512).getPrime();

//create a public &amp; private key for alice
var Alice = crypto.createDiffieHellman(prime);
Alice.generateKeys();

//create a public &amp; private key for bob
var Bob = crypto.createDiffieHellman(prime);
Bob.generateKeys();

//let bob and alice compute the shared secret
console.log(Alice.computeSecret(Bob.getPublicKey()).toString(""hex""));
console.log(Bob.computeSecret(Alice.getPublicKey()).toString(""hex""));
</code></pre>
","899","<node.js><diffie-hellman>","0","0","1","2013-06-14 14:30:48","17110871","0","1","","","","2013-06-14 14:22:39",""
"17587249","Diffie Hellman Key exchange with Android applications","<p>i am currently trying to do diffie hellman key exchange with an android application.
I got my codes out for the diffie hellman as shown below.</p>

<p>However i am just lost on how do i implement it on the server side and the client side in order for them to communicate to each other.</p>

<p>My codes are shown below</p>

<p>DH.java</p>

<p>public class DH 
{</p>

<pre><code>static boolean isPrime(long n)
{
    if (n%2 == 0)
    {
        return false;
    }

    for(int i = 3 ; i*i&lt;=n;i+=2)
    {
        if(n%i==0)
            return false;
    }
    return true;
}


public static void main(String [] args) throws Exception
{

    Random randomGenerator = new Random();

    long pValue = randomGenerator.nextInt(1000000);
    long gValue = randomGenerator.nextInt(100000);
    long correctPValue;

    boolean checkPrime = isPrime(pValue);
    System.out.println(""the number generated is ""+pValue);
    System.out.println(checkPrime);

    while(checkPrime == false)

    {
        long pValue2 = randomGenerator.nextInt(1000000);
        boolean checkPrimeInLoop = isPrime(pValue2);
        //System.out.println(""value in loop is ""+pValue2);
        if(checkPrimeInLoop == true)
        {
            pValue=pValue2;
            break;
        }
    }


    long checkSP = (pValue*2)+1;
    boolean checkSafePrime = isPrime(checkSP);
    //System.out.println(checkSafePrime);
    while(checkSafePrime==false)
    {
        long pValue3=randomGenerator.nextInt(1000000);
        boolean checkPrimeInLoop = isPrime(pValue3);
        long pValue5=(pValue3*2)+1;
        //boolean checkSafePrimeInLoop = isPrime(pValue4);
        boolean checkSafePrime2InLoop = isPrime(pValue5);

        if(checkSafePrime2InLoop == true &amp;&amp; checkPrimeInLoop == true)
        {
            pValue=pValue3;
            break;
        }

    }

    //System.out.println(""the safe prime is""+pValue);//safe prime

    while(gValue&gt;pValue)
    {
        long gValue2=randomGenerator.nextInt(100000);

        if(gValue2&lt;pValue)
        {
            gValue=gValue2;
            break;
        }
    }

    long getDivisor = (pValue-1)/2;
    BigInteger bi1,bi2,bi3,bi4,bi10,bi11,bi12,bi13;

    bi1=BigInteger.valueOf(getDivisor);

    bi2 = BigInteger.valueOf(pValue);

    bi3 = BigInteger.valueOf(gValue);

    bi4= bi3.modPow(bi1,bi2);

    String getBi1 = bi1.toString();

    String getBi2 = bi2.toString();

    String getBi3 = bi3.toString();

    String getBi4 = bi4.toString();


    //bi10 = new BigInteger(getBi1,64); // divisor
    //bi11 = new BigInteger(getBi2,64); // safe prime value
    //bi12 = new BigInteger(getBi3,64); // generator value
    //bi13 = new BigInteger(getBi4,64); // modular value




    long calculatedValue = bi4.longValue();


    while(calculatedValue == 1)
    {
        long gValue3=randomGenerator.nextInt(100000);
        long getDivisorInLoop = (pValue-1)/2;
        BigInteger bi5,bi6,bi7,bi8,bi14,bi15,bi16,bi17,bi18;

        bi5=BigInteger.valueOf(getDivisorInLoop);

        bi6 = BigInteger.valueOf(pValue);

        bi7 = BigInteger.valueOf(gValue3);

        bi8= bi7.modPow(bi5,bi6);


        String getBi5 = bi5.toString();

        String getBi6 = bi6.toString();

        String getBi7 = bi7.toString();

        String getBi8 = bi8.toString();


        //bi14 = new BigInteger(getBi1,64); // divisor
        //bi15 = new BigInteger(getBi2,64); // safe prime value
        //bi16 = new BigInteger(getBi3,64); // generator value
        //bi17 = new BigInteger(getBi4,64); // modular value


        long calculatedValueInLoop = bi8.longValue();
        System.out.println(""the proof that it is  a generator is ""+calculatedValueInLoop);
        if(calculatedValueInLoop!=1)
        {
            gValue=gValue3;
            break;
        }
    }

    BigInteger generatorValue,primeValue,biA,biB,skA,skB,sharedKeyA,sharedKeyB;

    generatorValue = BigInteger.valueOf(gValue);
    primeValue = BigInteger.valueOf(pValue);
    long SecretKeyA=generateSKA();
    long SecretKeyB=generateSKB();
    skA = BigInteger.valueOf(SecretKeyA);
    skB = BigInteger.valueOf(SecretKeyB);
    biA=generatePkA(generatorValue,primeValue,SecretKeyA);
    biB=generatePkB(generatorValue,primeValue,SecretKeyB);
    sharedKeyA = calculateSharedKey(biB,skA,primeValue);
    sharedKeyB = calculateSharedKey(biA,skB,primeValue);

    System.out.println(""the safe prime is""+primeValue);
    System.out.println(""the generator of the safe prime is ""+generatorValue);
    System.out.println(""the public key of A is ""+generatePkA(generatorValue,primeValue,SecretKeyA));
    System.out.println(""the public key of B is ""+generatePkB(generatorValue,primeValue,SecretKeyB));
    System.out.println(""the shared key for A is""+calculateSharedKey(biB,skA,primeValue));
    System.out.println(""the shared key for B is""+calculateSharedKey(biA,skB,primeValue));
    System.out.println(""The secret key for A is""+generateSKA());

    //createKey();
    String getAValue=sharedKeyA.toString();
    String getBValue=sharedKeyB.toString();

    MessageDigest md = MessageDigest.getInstance(""SHA-256"");
    md.update(getAValue.getBytes());

    byte byteData[] = md.digest();
    StringBuffer sb = new StringBuffer();

    for(int i=0;i&lt;byteData.length;i++)
    {
        sb.append(Integer.toString((byteData[i] &amp; 0xff) + 0x100, 16).substring(1));
    }

    String getHexValue = sb.toString();
    System.out.println(""hex format in SHA-256 is ""+getHexValue);

    //createSpecificKey(biG,biP);

    byte [] key = getAValue.getBytes(""UTF-8"");

    MessageDigest sha = MessageDigest.getInstance(""SHA-256"");

    key =  sha.digest(key);
    key = Arrays.copyOf(key, 16);
    SecretKeySpec secretKeySpec =  new SecretKeySpec(key,""AES"");

    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

    CipherInputStream cipt = new CipherInputStream(new FileInputStream(new File(""C:\\Users\\Larry\\Desktop\\Java\\diffie hellman\\src\\jessica.jpg"")),cipher); // enter your filename here
    FileOutputStream fop=new FileOutputStream(new File(""C:\\Users\\Larry\\Desktop\\Java\\diffie hellman\\src\\testEncrypt.jpg""));



    int i;
    while((i=cipt.read())!= -1)
    {
        fop.write(i);
    }

    cipher.init(Cipher.DECRYPT_MODE,secretKeySpec);

    CipherInputStream cipt2 = new CipherInputStream(new FileInputStream(new File(""C:\\Users\\Larry\\Desktop\\Java\\diffie hellman\\src\\testEncrypt.jpg"")),cipher); // encryption of image
    FileOutputStream fop2 = new FileOutputStream(new File(""C:\\Users\\Larry\\Desktop\\Java\\diffie hellman\\src\\testDecrypt.jpg""));//decryption of images

    int j;
    while((j=cipt2.read())!=-1)
    {
        fop2.write(j);
    }





}

public static BigInteger calculateSharedKey(BigInteger pk , BigInteger sk, BigInteger safePrime)
{
    BigInteger sharedKey;

    sharedKey = pk.modPow(sk, safePrime);

    return sharedKey;
}


public static long generateSKA()
{
    Random randomGenerator2=new Random();
    long SKa = randomGenerator2.nextInt(1000000000);

    return SKa;
}

public static long generateSKB()
{
    Random randomGenerator3=new Random();
    long SKb = randomGenerator3.nextInt(10000000);

    return SKb;
}


public static BigInteger generatePkA(BigInteger g,BigInteger p,long skA)
{
    BigInteger Pka,SK;
    long secretKeyA = skA;

    SK = BigInteger.valueOf(secretKeyA);

    Pka=g.modPow(SK, p);

    return Pka;
}


public static BigInteger generatePkB(BigInteger g,BigInteger p,long skB)
{
    BigInteger Pkb,SK;
    long secretKeyB = skB;
    SK = BigInteger.valueOf(secretKeyB);
    Pkb=g.modPow(SK, p);
    return Pkb;
}
</code></pre>

<p>My question is how do i incoporate the DH algorithms that i coded in a servlet that is on a server that is hosted an apache tomcat.
I hope you guys can enlighten me with some example codes as i am really lost on this.</p>

<p>My servlet code is as follows below </p>

<p>LoginServlet.java</p>

<pre><code>&gt;    public class LoginServlet extends HttpServlet {



protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(""text/html;charset=UTF-8"");
        PrintWriter out = response.getWriter();
        try {
        String un,pw;
        un=request.getParameter(""username"");
        pw=request.getParameter(""password"");
        if(un.equalsIgnoreCase(""hello"") &amp;&amp; pw.equals(""world""))
        {
            out.print(1);
            System.out.println(un);
            System.out.println(pw);
        }
        else
        {
            out.print(0);
            System.out.println(un);
            System.out.println(pw);
        }
        } finally {            
            out.close();
        }
    }


    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);


    }


    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }


    @Override
    public String getServletInfo() {
        return ""Short description"";
    }
}
</code></pre>

<p>Hope you guys can enlighten me on this issue. Thanks in advance! =)</p>
","","883","<java><android><diffie-hellman>","2","","0","2017-04-16 18:51:35","","0","3","","","","2013-07-11 07:16:32",""
"34237971","Conducting Diffie Hellman between Java and Crypto++ (C++)","<p>I want to encrypt some data between a c++ client and a java server. Searching the web I found crypto++ to use on the client and on the java side to use the KeyAgreement built in java class(btw, I already have bouncycastle jar in my project, I can use it if it's somehow better than the built in one).</p>

<p>I was able to perform DH on on every side with itself as an example, but due to key sizes I cannot make them to agree on a secret key.</p>

<p>My C++ code:</p>

<pre><code>// g++ -g3 -ggdb -O0 -I. -I/usr/include/cryptopp dh-agree.cpp -o dh-agree.exe -lcryptopp -lpthread
// g++ -g -O2 -I. -I/usr/include/cryptopp dh-agree.cpp -o dh-agree.exe -lcryptopp -lpthread

#include &lt;iostream&gt;
using std::cout;
using std::cerr;
using std::endl;

#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#include &lt;string&gt;
using std::string;

#include &lt;stdexcept&gt;
using std::runtime_error;

#include ""osrng.h""
using CryptoPP::AutoSeededRandomPool;

#include ""integer.h""
using CryptoPP::Integer;

#include ""nbtheory.h""
using CryptoPP::ModularExponentiation;

#include ""dh.h""
using CryptoPP::DH;

#include ""secblock.h""
using CryptoPP::SecByteBlock;

#include &lt;hex.h&gt;
using CryptoPP::HexEncoder;

#include &lt;filters.h&gt;
using CryptoPP::StringSink;
int main(int argc, char** argv)
{
    try
    {
        // RFC 5114, 1024-bit MODP Group with 160-bit Prime Order Subgroup
        // http://tools.ietf.org/html/rfc5114#section-2.1
        Integer p(""0xB10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C6""
            ""9A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C0""
            ""13ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD70""
            ""98488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0""
            ""A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708""
            ""DF1FB2BC2E4A4371"");

        Integer g(""0xA4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507F""
            ""D6406CFF14266D31266FEA1E5C41564B777E690F5504F213""
            ""160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1""
            ""909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28A""
            ""D662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24""
            ""855E6EEB22B3B2E5"");

        Integer q(""0xF518AA8781A8DF278ABA4E7D64B7CB9D49462353"");        

        // Schnorr Group primes are of the form p = rq + 1, p and q prime. They
        // provide a subgroup order. In the case of 1024-bit MODP Group, the
        // security level is 80 bits (based on the 160-bit prime order subgroup).       

        // For a compare/contrast of using the maximum security level, see
        // dh-agree.zip. Also see http://www.cryptopp.com/wiki/Diffie-Hellman
        // and http://www.cryptopp.com/wiki/Security_level .

        DH dh;
        AutoSeededRandomPool rnd;

        dh.AccessGroupParameters().Initialize(p, q, g);

        if(!dh.GetGroupParameters().ValidateGroup(rnd, 3)) 
            throw runtime_error(""Failed to validate prime and generator"");

        size_t count = 0;

        p = dh.GetGroupParameters().GetModulus();
        q = dh.GetGroupParameters().GetSubgroupOrder();
        g = dh.GetGroupParameters().GetGenerator();

        // http://groups.google.com/group/sci.crypt/browse_thread/thread/7dc7eeb04a09f0ce
        Integer v = ModularExponentiation(g, q, p);
        if(v != Integer::One())
            throw runtime_error(""Failed to verify order of the subgroup"");

        //////////////////////////////////////////////////////////////

        SecByteBlock priv(dh.PrivateKeyLength());
        SecByteBlock pub(dh.PublicKeyLength());
        dh.GenerateKeyPair(rnd, priv, pub);
        printf(""lengths: %d %d\n"",dh.PrivateKeyLength(),dh.PublicKeyLength());
        byte* pubData = pub.data();     
        for(int j = 0; j &lt; pub.size()-1; j++)
            printf(""%02X:"", pubData[j]);    
        printf(""%02X\n"", pubData[pub.size()-1]);    
        // Send pub to Java
        sendData(pub.data(),pub.size());
        // Read pubB from Java
        byte pubBbytes[10000];
        int n = readData(pubBbytes,sizeof(pubBbytes));
        SecByteBlock pubB(pubBbytes,n);
        //////////////////////////////////////////////////////////////

        SecByteBlock sharedA(dh.AgreedValueLength());

        if(!dh.Agree(sharedA, priv, pubB))
            throw runtime_error(""Failed to reach shared secret (1A)"");


        //////////////////////////////////////////////////////////////

        Integer a;

        a.Decode(sharedA.BytePtr(), sharedA.SizeInBytes());
        cout &lt;&lt; ""Shared secret (A): "" &lt;&lt; std::hex &lt;&lt; a &lt;&lt; endl;
    }

    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return -2;
    }

    catch(const std::exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return -1;
    }

    return 0;
}
</code></pre>

<p>Server code in Java:</p>

<pre><code>package test;
/*
 * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS
 * IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;

/**
 * This program executes the Diffie-Hellman key agreement protocol
 * between 2 parties: Alice and Bob.
 *
 * By default, preconfigured parameters (1024-bit prime modulus and base
 * generator used by SKIP) are used.
 * If this program is called with the ""-gen"" option, a new set of
 * parameters is created.
 */

public class DHKeyAgreement2 {

    private DHKeyAgreement2() {}

    public final static String sP = ""B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C6"" +
            ""9A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C0"" +
            ""13ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD70"" +
            ""98488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0"" +
            ""A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708"" +
            ""DF1FB2BC2E4A4371"";

    public final static String sG = ""A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507F"" +
            ""D6406CFF14266D31266FEA1E5C41564B777E690F5504F213"" +
            ""160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1"" +
            ""909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28A"" +
            ""D662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24"" +
            ""855E6EEB22B3B2E5"";


    public static void main(String argv[]) {
        try {
            DHKeyAgreement2 keyAgree = new DHKeyAgreement2();
            keyAgree.run();
        } catch (Exception e) {
            System.err.println(""Error: "" + e);
            System.exit(1);
        }
    }

    private void run() throws Exception {

        DHParameterSpec dhSkipParamSpec;

        // use some pre-generated, default DH parameters
        System.out.println(""Using SKIP Diffie-Hellman parameters"");
        BigInteger p = new BigInteger(sP,16);
        BigInteger g = new BigInteger(sG,16);
        System.out.println(""P "" + sP.length() + "" is: "" + toHexString(p.toByteArray()));
        System.out.println(""G "" + sG.length() + "" is: "" + toHexString(g.toByteArray()));
        dhSkipParamSpec = new DHParameterSpec(p,g);
        /*
         * Alice creates her own DH key pair, using the DH parameters from
         * above
         */
        System.out.println(""ALICE: Generate DH keypair ..."");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(""DH"");
        aliceKpairGen.initialize(dhSkipParamSpec);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

        // Alice creates and initializes her DH KeyAgreement object
        System.out.println(""ALICE: Initialization ..."");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(""DH"");
        aliceKeyAgree.init(aliceKpair.getPrivate());

        // Alice encodes her public key, and sends it over to Bob.
        byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();
        byte[] alicePrivKeyEnc = aliceKpair.getPrivate().getEncoded();
        System.out.println(""Alice pub key size: "" + alicePubKeyEnc.length);
        System.out.println(""Alice pub key: "" + toHexString(alicePubKeyEnc));
        System.out.println(""Alice priv key size: "" + alicePrivKeyEnc.length);
        System.out.println(""Alice priv key: "" + toHexString(alicePrivKeyEnc));
        ServerSocket ss = new ServerSocket(5454);
        Socket accept = ss.accept();
        byte[] bobPubKeyEnc = readByteArrayFromSocket(accept);
        System.out.println(""Read bob's pubkey: "" + toHexString(bobPubKeyEnc));
        sendByteArrayToBob(alicePubKeyEnc);
        System.out.println(""Sent Alice's pubkey"");

        /*
         * Alice uses Bob's public key for the first (and only) phase
         * of her version of the DH
         * protocol.
         * Before she can do so, she has to instantiate a DH public key
         * from Bob's encoded key material.
         */
        KeyFactory aliceKeyFac = KeyFactory.getInstance(""DH"");
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);
        PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);
        System.out.println(""ALICE: Execute PHASE1 ..."");
        aliceKeyAgree.doPhase(bobPubKey, true);

        /*
         * At this stage, both Alice and Bob have completed the DH key
         * agreement protocol.
         * Both generate the (same) shared secret.
         */
        byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
        int aliceLen = aliceSharedSecret.length;

        System.out.println(""Alice secret: "" +
          toHexString(aliceSharedSecret));
    }
}
</code></pre>

<p>My output from C++:</p>

<pre><code>lengths: 20 128
77:61:FD:93:D9:23:38:41:6D:B0:9B:F8:7A:FB:CE:CA:0E:DF:7D:0A:95:F6:B4:55:FF:64:32:03:2C:B5:9C:47:05:06:FF:1B:72:F3:C6:8A:91:68:13:98:DE:56:0C:D6:02:30:C2:4B:DB:AD:0A:B3:7D:2A:7E:DD:13:A8:7C:97:4A:46:79:6A:85:C7:5B:79:29:D8:E5:2B:F4:59:21:B3:29:EA:6A:2F:FB:70:A1:C8:FD:5C:31:E1:92:A9:B0:67:74:65:3D:C1:1B:33:4B:DE:1C:EB:1E:A1:3A:36:29:0F:DF:A2:FA:5D:DA:69:DC:6D:00:D7:76:95:3A:FD:7D:76
sent 128 bytes, remaining 0
Failed to reach shared secret (1A)
</code></pre>

<p>And output from Java:</p>

<pre><code>Using SKIP Diffie-Hellman parameters
P 256 is: 00:B1:0B:8F:96:A0:80:E0:1D:DE:92:DE:5E:AE:5D:54:EC:52:C9:9F:BC:FB:06:A3:C6:9A:6A:9D:CA:52:D2:3B:61:60:73:E2:86:75:A2:3D:18:98:38:EF:1E:2E:E6:52:C0:13:EC:B4:AE:A9:06:11:23:24:97:5C:3C:D4:9B:83:BF:AC:CB:DD:7D:90:C4:BD:70:98:48:8E:9C:21:9A:73:72:4E:FF:D6:FA:E5:64:47:38:FA:A3:1A:4F:F5:5B:CC:C0:A1:51:AF:5F:0D:C8:B4:BD:45:BF:37:DF:36:5C:1A:65:E6:8C:FD:A7:6D:4D:A7:08:DF:1F:B2:BC:2E:4A:43:71
G 256 is: 00:A4:D1:CB:D5:C3:FD:34:12:67:65:A4:42:EF:B9:99:05:F8:10:4D:D2:58:AC:50:7F:D6:40:6C:FF:14:26:6D:31:26:6F:EA:1E:5C:41:56:4B:77:7E:69:0F:55:04:F2:13:16:02:17:B4:B0:1B:88:6A:5E:91:54:7F:9E:27:49:F4:D7:FB:D7:D3:B9:A9:2E:E1:90:9D:0D:22:63:F8:0A:76:A6:A2:4C:08:7A:09:1F:53:1D:BF:0A:01:69:B6:A2:8A:D6:62:A4:D1:8E:73:AF:A3:2D:77:9D:59:18:D0:8B:C8:85:8F:4D:CE:F9:7C:2A:24:85:5E:6E:EB:22:B3:B2:E5
ALICE: Generate DH keypair ...
ALICE: Initialization ...
Alice pub key size: 426
Alice pub key: 30:82:01:A6:30:82:01:1B:06:09:2A:86:48:86:F7:0D:01:03:01:30:82:01:0C:02:81:81:00:B1:0B:8F:96:A0:80:E0:1D:DE:92:DE:5E:AE:5D:54:EC:52:C9:9F:BC:FB:06:A3:C6:9A:6A:9D:CA:52:D2:3B:61:60:73:E2:86:75:A2:3D:18:98:38:EF:1E:2E:E6:52:C0:13:EC:B4:AE:A9:06:11:23:24:97:5C:3C:D4:9B:83:BF:AC:CB:DD:7D:90:C4:BD:70:98:48:8E:9C:21:9A:73:72:4E:FF:D6:FA:E5:64:47:38:FA:A3:1A:4F:F5:5B:CC:C0:A1:51:AF:5F:0D:C8:B4:BD:45:BF:37:DF:36:5C:1A:65:E6:8C:FD:A7:6D:4D:A7:08:DF:1F:B2:BC:2E:4A:43:71:02:81:81:00:A4:D1:CB:D5:C3:FD:34:12:67:65:A4:42:EF:B9:99:05:F8:10:4D:D2:58:AC:50:7F:D6:40:6C:FF:14:26:6D:31:26:6F:EA:1E:5C:41:56:4B:77:7E:69:0F:55:04:F2:13:16:02:17:B4:B0:1B:88:6A:5E:91:54:7F:9E:27:49:F4:D7:FB:D7:D3:B9:A9:2E:E1:90:9D:0D:22:63:F8:0A:76:A6:A2:4C:08:7A:09:1F:53:1D:BF:0A:01:69:B6:A2:8A:D6:62:A4:D1:8E:73:AF:A3:2D:77:9D:59:18:D0:8B:C8:85:8F:4D:CE:F9:7C:2A:24:85:5E:6E:EB:22:B3:B2:E5:02:02:02:00:03:81:84:00:02:81:80:25:E7:BD:24:57:C9:59:EE:E0:EC:7A:F3:D6:22:1C:84:68:52:D9:19:40:5F:1B:C6:CB:A9:3A:42:BF:AB:3C:C2:EC:6F:BC:F9:F9:B2:70:AC:A2:E5:CE:36:FC:06:4F:2D:B3:4F:B5:25:D9:59:AD:D6:AD:B6:17:FA:09:76:AE:89:99:91:52:9B:E0:10:1D:9F:AC:50:AF:02:6D:25:F6:E8:DD:B8:6C:51:17:44:59:98:52:4B:E9:75:E1:D1:26:FE:EA:73:EF:C7:89:7F:70:A8:ED:6F:57:28:A4:0F:1B:F8:21:7D:A5:A2:59:B9:74:42:42:45:BA:EC:E2:53:B3:C4
Alice priv key size: 362
Alice priv key: 30:82:01:66:02:01:00:30:82:01:1B:06:09:2A:86:48:86:F7:0D:01:03:01:30:82:01:0C:02:81:81:00:B1:0B:8F:96:A0:80:E0:1D:DE:92:DE:5E:AE:5D:54:EC:52:C9:9F:BC:FB:06:A3:C6:9A:6A:9D:CA:52:D2:3B:61:60:73:E2:86:75:A2:3D:18:98:38:EF:1E:2E:E6:52:C0:13:EC:B4:AE:A9:06:11:23:24:97:5C:3C:D4:9B:83:BF:AC:CB:DD:7D:90:C4:BD:70:98:48:8E:9C:21:9A:73:72:4E:FF:D6:FA:E5:64:47:38:FA:A3:1A:4F:F5:5B:CC:C0:A1:51:AF:5F:0D:C8:B4:BD:45:BF:37:DF:36:5C:1A:65:E6:8C:FD:A7:6D:4D:A7:08:DF:1F:B2:BC:2E:4A:43:71:02:81:81:00:A4:D1:CB:D5:C3:FD:34:12:67:65:A4:42:EF:B9:99:05:F8:10:4D:D2:58:AC:50:7F:D6:40:6C:FF:14:26:6D:31:26:6F:EA:1E:5C:41:56:4B:77:7E:69:0F:55:04:F2:13:16:02:17:B4:B0:1B:88:6A:5E:91:54:7F:9E:27:49:F4:D7:FB:D7:D3:B9:A9:2E:E1:90:9D:0D:22:63:F8:0A:76:A6:A2:4C:08:7A:09:1F:53:1D:BF:0A:01:69:B6:A2:8A:D6:62:A4:D1:8E:73:AF:A3:2D:77:9D:59:18:D0:8B:C8:85:8F:4D:CE:F9:7C:2A:24:85:5E:6E:EB:22:B3:B2:E5:02:02:02:00:04:42:02:40:3C:16:B6:8F:73:CD:9D:0F:19:D5:A7:54:61:FC:A9:AF:3E:79:78:B8:5E:3E:3D:58:52:2F:95:5E:0D:3F:E0:19:92:17:22:B4:06:9A:E4:ED:9D:55:54:3F:1F:DE:20:36:31:5A:AC:58:FB:A3:C2:7E:65:31:A4:F0:43:37:A2:37
Read 128 bytes
Read bob's pubkey: 77:61:FD:93:D9:23:38:41:6D:B0:9B:F8:7A:FB:CE:CA:0E:DF:7D:0A:95:F6:B4:55:FF:64:32:03:2C:B5:9C:47:05:06:FF:1B:72:F3:C6:8A:91:68:13:98:DE:56:0C:D6:02:30:C2:4B:DB:AD:0A:B3:7D:2A:7E:DD:13:A8:7C:97:4A:46:79:6A:85:C7:5B:79:29:D8:E5:2B:F4:59:21:B3:29:EA:6A:2F:FB:70:A1:C8:FD:5C:31:E1:92:A9:B0:67:74:65:3D:C1:1B:33:4B:DE:1C:EB:1E:A1:3A:36:29:0F:DF:A2:FA:5D:DA:69:DC:6D:00:D7:76:95:3A:FD:7D:76
Sent Alice's pubkey
Error: java.security.spec.InvalidKeySpecException: Inappropriate key specification
</code></pre>

<p>Seems like altough I use the same G and P in both programs, the keys generated in C++ are 128\20 byte long (public\private) while in java they are 426\362 byte long. I was wondering where I can set the desired key length in crypto++ but yet to discover that. Also I removed some helper function from the codes above, so I guess copy-paste and trying to compile them won't work. If anyone will actually want to do that I will submit my complete code.</p>

<p>Thanks</p>
","","879","<java><c++><crypto++><diffie-hellman><java-security>","2","","0","2015-12-12 08:45:30","","4","","","","","2015-12-12 08:45:30",""
"4011440","Unknown value in SSH2 Diffie-Hellman Group Exchange Reply packet","<p>I'm trying to understand more about how SSH works. I'm using Wireshark to grab the packets going between my machines (OpenSSH running on both ends). I'm stuck at the Diffie-Hellman Group Exchange Reply packet. There seems to be a length (4 Bytes) and value (1 Byte) not accounted for or not described by RFC 4419, just after the encryption algorithm name. The RFC says that the first chunk of data sent in this packet will be the server's public key and certificates, but I don't know where to look for certificate formats to try and decode this data.</p>

<p>Here is the packet received from the server (TCP, IP, and Ethernet packet information not included). I've spread it out for readability. I've also indicated values and field purposes as I understand them. The 'host key', 'f', and 'hash signature' are indicated to be in these positions by RFC 4419. The line marked with a ""-&gt;"" has the data that is confusing me. I can't see anything that the value 0x23 (35) would correlate to.</p>

<pre>
Packet Length: 444
Padding Length: 10
  Key Exchange
    Msg code: Diffie-Hellman GEX Reply (33)
    Payload:
  00000095                                         Value = 149 bytes
  00000007 7373682d727361                          Value =   7 bytes ; ""ssh-rsa""
-&gt;00000001 23                                      Value =   1 byte  ; 35
  00000081 00dca412f58b8d7bea991901652857b3        Value = 129 bytes ; host key
           ...
           ... Total of 129 bytes
           ...

  00000080 420b85197d902a986c7c67b2c4f72336        Value = 128 bytes ; f
         ...
         ... Total of 128 bytes
         ...

  0000008f                                         Value = 143 bytes
  00000007 7373682d727361                          Value =   7 bytes ; ""ssh-rsa""
  00000080 0c9f8b1a7f59c25f279fcc8199ea1ffe        Value = 128 bytes ; hash signature
           ...
           ... Total of 128 bytes
           ...
    Padding String: 
    MAC String: 
</pre>

<p>I've read through RFCs 4250-4254 and 4419 to try to find some clue for this code 0x23, but I have been unsuccessful so far. It is entirely possible that I missed an explanation in the RFCs, so feel free to point one out to me if that's the case. Any hints or explanation will be helpful.</p>

<p>Thank You</p>
","<p>If you look at <a href=""http://tools.ietf.org/html/rfc4253#page-15"" rel=""nofollow"">RFC 4253, 6.6. Public Key Algorithms</a>, where the key format is described, immediately after the <code>ssh-rsa</code> string comes the key's exponent (<code>mpint e</code>) which in your case is 35.</p>
","876","<ssh><diffie-hellman>","1","1","1","2011-07-16 21:59:09","","0","","","","","2010-10-25 02:04:29",""
"41356625","Can someone tell me how to make a server choose a ECDH_* cipher over ECDHE_*?","<p>I am using RSA cipher for signing the certificate and  <strong>SSL_CTX_set_tmp_ecdh_callback</strong>() api to set the ECDH parameters for key-exchange. The server always ends up choosing TLS_ECDHE_RSA_* cipher suite. If i make the client send only TLS_ECDH_* cipher suites in the clientHello, the server breaks the connection stating ""no shared cipher"".</p>

<p>Can someone tell me how to make a server choose a ECDH_* cipher over ECDHE_* ?</p>

<p>How is it that the server decides I should choose ECDH_* cipher over ECDHE_* ciphers ?</p>
","<p>Now that this is moved where it's ontopic, and clarified enough, and the partying is over:</p>

<p><strong>Ephemeral ECDH suites:</strong> TLS suites that use ephemeral ECDH key exchange (<code>ECDHE-*</code>) use at least nominally ephemeral ECDH keys, which OpenSSL calls 'temporary'. OpenSSL through 1.0.2 has 4-6 ways of setting these keys:</p>

<p><code>SSL_CTX_set_tmp_ecdh</code> or <code>SSL_set_tmp_ecdh</code> set (only) the 'curve' to be used; to be exact this is an <code>EC_GROUP</code> or formally 'parameter set' that consists of an actual curve defined by a curve equation on an underlying field, plus a specified base point which generates a subgroup on the curve of sufficiently high order and low cofactor, but most of the time we ignore this detail and just call it a 'curve'. OpenSSL then generates a random key on that curve for and during each handshake.</p>

<p><code>SSL_CTX_set_tmp_ecdh_callback</code> or <code>SSL_set_tmp_ecdh_callback</code> sets a function that is called during each handshake and can either set a specific key, or set a curve and OpenSSL generates a random key on that curve.</p>

<p><code>SSL_CTX_set_ecdh_auto</code> or <code>SSL_set_ecdh_auto</code> new in 1.0.2 causes OpenSSL during each handshake to choose a curve based on the client hello, and generate a random key on that curve.</p>

<p>Note that each ciphersuite using ECDHE also defines the type of key with matching certificate chain the server must use to authenticate: <code>ECDHE-RSA</code> must use an RSA key&amp;cert while <code>ECDHE-ECDSA</code> must use an ECDSA key&amp;cert (or to be precise EC key and ECDSA cert, since the same EC key can be used for ECDSA, ECDH, ECIES, and more, but usually shouldn't). OpenSSL library can be configured with multiple key&amp;cert pairs, one of each type, and commandline <code>s_server</code> can do two static pairs using <code>-cert -key -dcert -dkey</code> plus one for SNI <code>-cert2 -key2</code>, but other programs may or may not.</p>

<p>However, in 1.1.0 these functions are removed and it appears OpenSSL <em>always</em> does what was formerly <code>ecdh_auto</code>.</p>

<p><strong>Static ECDH suites:</strong> TLS suites that use static aka fixed ECDH key exchange (<code>ECDH-*</code>) use a static ECDH key and do not use an ephemeral or temporary ECDH key. Since they do not use a temporary key, the functions involved in setting a temporary curve or key are irrelevant and have no useful effect. Instead the static ECDH key must be <strong>in the server's configured key and certificate pair</strong>, and the certificate must allow ECDH i.e. it must not have <code>keyUsage</code> that excludes <code>keyAgreement</code>. In addition, in TLS 1.0 and 1.1 the configured certificate must be signed by a CA using a signature algorithm matching the ciphersuite: <code>ECDH-ECDSA</code> ciphersuites must use an ECDH cert signed by an ECDSA CA, and <code>ECDH-RSA</code> ciphersuites must use an ECDH cert signed by an RSA CA; see <a href=""https://tools.ietf.org/html/rfc4492#section-5.3"" rel=""nofollow noreferrer"">rfc4492 section 5.3</a>. For TLS 1.2 <a href=""https://tools.ietf.org/html/rfc5246#section-7.4.2"" rel=""nofollow noreferrer"">rfc 5246 section 7.4.2</a> and <a href=""https://tools.ietf.org/html/rfc5246#appendix-A.7"" rel=""nofollow noreferrer"">A.7 for ECC</a> relaxes this requirement and allows the <em>CA</em> cert to be any algorithm permitted by the client's signature_algorithms extension. However on checking I found OpenSSL doesn't implement this relaxation, so part of my earlier comment is wrong; <strong>even for 1.2 it requires the CA signature algorithm match the ciphersuite</strong>. </p>

<p>In addition for all protocol versions the key and (EE) cert must use a curve supported by the client in supported_curves extension, and the cert must express that key in 'named' form (using an OID to identify the curve rather than explicit parameters) and a point format supported by the client in supported_formats extension. With OpenSSL client this is never an issue because it supports all named curves and point formats, and in practice certificates don't use explicit curve parameters.</p>

<p>Thus to get static ECDH with OpenSSL:</p>

<ul>
<li><p>configure the server with an EC key (<code>SSL_[CTX_]use_PrivateKey*</code>) and matching certificate (<code>SSL_[CTX_]use_certificate[_chain]*</code>) that allows keyAgreement and is signed by a CA using RSA or ECDSA -- and like all PK-based ciphersuites also configure any chain certs needed by the client(s) to validate the cert</p></li>
<li><p>configure both ends to allow (which is true by default) and at least one end to require or the preference end to prefer ciphersuite(s) using <code>ECDH-xyz</code> where <code>xyz</code> is <code>RSA</code> or <code>ECDSA</code> to match the CA signature on the server cert</p></li>
<li><p>ignore <code>ecdh_tmp</code> and <code>ecdh_auto</code> entirely</p></li>
</ul>

<p>... <strong>except in 1.1.0</strong>, which on checking I found no longer implements any static-ECDH <em>or</em> static-DH ciphersuites -- even though the static-DH suites are still in the manpage for ciphers. This is not in the CHANGES file that I can find, and I haven't had time to go through the code yet.</p>
","857","<diffie-hellman><openssl>","1","3","2","2019-10-18 12:44:53","41430543","4","","","","","2016-12-27 15:58:21",""
"41356625","Can someone tell me how to make a server choose a ECDH_* cipher over ECDHE_*?","<p>I am using RSA cipher for signing the certificate and  <strong>SSL_CTX_set_tmp_ecdh_callback</strong>() api to set the ECDH parameters for key-exchange. The server always ends up choosing TLS_ECDHE_RSA_* cipher suite. If i make the client send only TLS_ECDH_* cipher suites in the clientHello, the server breaks the connection stating ""no shared cipher"".</p>

<p>Can someone tell me how to make a server choose a ECDH_* cipher over ECDHE_* ?</p>

<p>How is it that the server decides I should choose ECDH_* cipher over ECDHE_* ciphers ?</p>
","<blockquote>
  <p>... except in 1.1.0, which on checking I found no longer implements
  any static-ECDH or static-DH ciphersuites -- even though the static-DH
  suites are still in the manpage for ciphers. This is not in the
  CHANGES file that I can find, and I haven't had time to go through the
  code yet.</p>
</blockquote>

<p><a href=""https://github.com/openssl/openssl/commit/ce0c1f2bb2fd296f10a2847844205df0ed95fb8e"" rel=""nofollow noreferrer"">https://github.com/openssl/openssl/commit/ce0c1f2bb2fd296f10a2847844205df0ed95fb8e</a></p>
","857","<diffie-hellman><openssl>","1","0","2","2019-10-18 12:44:53","41430543","4","","","","","2016-12-27 15:58:21",""
"20774631","ftp server with diffie-hellman in java","<p>i have only server side code in java and i want to use diffie-hellman encryption for my server so can anyone help me with this I'm new to programming and I'm just starting to learn so it's my homework and deadline is very close so can anyone help me that would be great...
so far i got this code and i have no idea how i can merge it with my server code</p>

<pre><code>import java.util.*;
import java.math.BigInteger;

public class DiffieHellmanBigInt {

final static BigInteger one = new BigInteger(""1"");

public static void main(String args[]) {

    Scanner stdin = new Scanner(System.in);
    BigInteger p;

    // Get a start spot to pick a prime from the user.
    System.out.println(""Enter the approximate value of p you want."");
    String ans = stdin.next();
    p = getNextPrime(ans);
    System.out.println(""Your prime is ""+p+""."");

    // Get the base for exponentiation from the user.
    System.out.println(""Now, enter a number in between 2 and p-1."");
    BigInteger g = new BigInteger(stdin.next());

    // Get A's secret number.
    System.out.println(""Person A: enter your secret number now."");
    BigInteger a = new BigInteger(stdin.next());

    // Make A's calculation.
    BigInteger resulta = g.modPow(a,p);

    System.out.println(""Person A sends to person B ""+resulta+""."");

    // Get B's secret number.
    System.out.println(""Person B: enter your secret number now."");
    BigInteger b = new BigInteger(stdin.next());

    // Make B's calculation.
    BigInteger resultb = g.modPow(b,p);

    System.out.println(""Person B sends to person A ""+resultb+""."");

    BigInteger KeyACalculates = resultb.modPow(a,p);
    BigInteger KeyBCalculates = resulta.modPow(b,p);

    // Print out the Key A calculates.
    System.out.println(""A takes ""+resultb+"" raises it to the power ""+a+"" mod ""+p);
    System.out.println(""The Key A calculates is ""+KeyACalculates+""."");

    // Print out the Key B calculates.
    System.out.println(""B takes ""+resulta+"" raises it to the power ""+b+"" mod ""+p);
    System.out.println(""The Key B calculates is ""+KeyBCalculates+""."");

}

public static BigInteger getNextPrime(String ans) {

    BigInteger test = new BigInteger(ans);
    while (!test.isProbablePrime(99))
        test = test.add(one);
    return test;        
}

}
</code></pre>
","<p>As the comment got too long...</p>

<p>Diffie-hellman is just for key exchange over an unprotected connection, using a prime number math problem. It is used to initialize asynchronous encryption with public and private keys (as used early for SSL/TLS).</p>

<p>Unless required as an exercise (for which you should add a homework or exercise tag), <strong>DO NOT</strong> implement such security stuff yourself, use existing, well tested libraries. Java has builtin support for SSL (perhaps using other key exchange methods): <a href=""http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLContext.html"" rel=""nofollow"">SSLContext</a></p>

<p>Despite that, you could use those numbers to derive public and private keys, however, you must assure, that they're really large (and not just <code>isProbablePrime</code>) prime numbers, what can get slow with <code>BigInteger</code>.</p>

<p>To connect client and server, start with <a href=""http://docs.oracle.com/javase/7/docs/api/java/net/Socket.html"" rel=""nofollow"">Socket</a>. But again a disclaimer, if this is not an exercise, you WILL most probably be attacked (hacked, DDOSed,...), you're best using an existing, well tested and hardened server.</p>
","825","<java><diffie-hellman>","0","2","1","2016-03-15 12:41:14","","1","","573032","","2016-03-15 12:41:14","2013-12-25 16:11:10","2013-12-25 21:13:56"
"48550872","Ignore Weak SSL Algorithm in PHP streamcontext/curl/soap","<p><strong>Statement</strong>: At the beginning I would like to state, that I'm well aware (and want to inform others) that this is not the proper way of doing things. If soultion is found, use it as last resort.</p>

<p><strong>My problem</strong> is Weak Algorithm. And can't find a way to skip checks.<br>
Company which exposes me endpoint states it is secure and they're not going to upgrade SSL Certificate. I know it's insecure, but can't do anything and must <em>obey</em> their decision.</p>

<p>Error i get <em>file_get_contents(): SSL operation failed with code 1. OpenSSL Error messages: error:14082174:SSL routines:ssl3_check_cert_and_algorithm:dh key too small</em><br>
and <em>file_get_contents(): Failed to enable crypto in...</em></p>

<p>My code is:</p>

<pre><code>$context = stream_context_create([
    'http' =&gt; [
        'timeout' =&gt; 5,
    ],
    'ssl' =&gt; [
        // set some SSL/TLS specific options
        'verify_peer' =&gt; false,
        'verify_peer_name' =&gt; false,
        'allow_self_signed' =&gt; true
    ]
]);
var_dump(file_get_contents($wsdl, false, $context));
</code></pre>

<p>In browser i ge <code>SSL_ERROR_WEAK_SERVER_EPHEMERAL_DH_KEY</code> and information about weak <code>Diffie Hellman</code> key.</p>

<p>I'm looking for a way to disable this check.</p>

<p>Most preferably via streamContext which I can use in <code>SoapClient</code></p>
","","784","<php><ssl><soap><diffie-hellman>","0","","0","2018-01-31 20:25:47","","12","","","","","2018-01-31 20:25:47",""
"39534456","How to generate Diffie Hellman parameters in Python?","<p>I need to generate a PEM encoded string in Python which contains DH parameters, something like the following:</p>

<pre><code>openssl dhparam -out dhparam.pem 1024
</code></pre>

<p>With the difference I would like to get a string object instead of writing to disk.</p>

<p>How to accomplish this?</p>

<p>While digging I found the following code:</p>

<pre><code>from OpenSSL._util import ffi as _ffi, lib as _lib

dh = _lib.DH_new()
_lib.DH_generate_parameters_ex(dh, 2048, 2, _ffi.NULL)
_lib.DHparams_print_fp(dhfile, dh)
with open('dh.pem', 'w') as dhfile:
    _lib.DHparams_print_fp(dhfile, dh)
</code></pre>

<p>But this code writes to disk and uses a different format than PEM.</p>
","","773","<python><diffie-hellman>","0","","0","2017-11-06 06:38:20","","3","1","462707","","2016-09-16 15:00:58","2016-09-16 14:53:24",""
"2403855","Selection of parameters in Diffie-Hellman","<p>maybe it's not so proper to ask this question here... anyway, I'm trying to use the gmp library for the implementation of DH, but the problem here I got is:</p>

<p>Once, when I was doing the tests to observe the output, although big values of prime and the private keys were selected: </p>

<ul>
<li>p was about more than 300 digits long in decimal</li>
<li>a, b were about 100 digits long</li>
</ul>

<p>finally I got a shared secret key which was extremely small, perhaps smaller than 10^8 in decimal... </p>

<p>This problem didn't show up many times, in fact, during all the observation, it appeared just once...but still, this was not so good at all. </p>

<p>So I wonder if there are some methods which can avoid this... Thanx a lot</p>
","<p>The Diffie-Hellman key exchange is designed to generate a secret shared key.</p>

<p>By using large values of p, a and b, you ensure that the pool of potential shared keys is a very large one.</p>

<p>However, the <em>actual</em> value of the shared key can be <strong>any</strong> value within that pool. As a result, it could range from zero to (p - 1)... that's because, the Key is</p>

<p><code>G^(ab) mod p</code></p>

<p>Hence, you haven't discovered a problem here... your just seeing the instances when <code>G^(ab)</code> is close in value to a multiple of <code>p</code>, and hence the <code>mod</code> is a low number.</p>
","752","<c><gmp><diffie-hellman>","3","2","2","2010-03-08 19:05:39","2403909","1","","26227","","2010-03-08 19:01:55","2010-03-08 18:55:18",""
"2403855","Selection of parameters in Diffie-Hellman","<p>maybe it's not so proper to ask this question here... anyway, I'm trying to use the gmp library for the implementation of DH, but the problem here I got is:</p>

<p>Once, when I was doing the tests to observe the output, although big values of prime and the private keys were selected: </p>

<ul>
<li>p was about more than 300 digits long in decimal</li>
<li>a, b were about 100 digits long</li>
</ul>

<p>finally I got a shared secret key which was extremely small, perhaps smaller than 10^8 in decimal... </p>

<p>This problem didn't show up many times, in fact, during all the observation, it appeared just once...but still, this was not so good at all. </p>

<p>So I wonder if there are some methods which can avoid this... Thanx a lot</p>
","<p>Part of the point of D-H is that the secret key could be <em>any</em> value within the range specified by p. At least in theory, eliminating some of those possibilities would make it less secure, not more so (realistically, as long as you leave a sufficiently large pool of keys, it makes little real difference).</p>

<p>It is true that <em>if</em> an attacker decided to try key-exhaustion (brute-force) attack, and started from 0 and just counted up, they'd hit this one relatively soon. Then again, if you decided on some other lower bound and (for example) re-negotiated the key if it was below that bound, it wouldn't do any real good -- instead of starting at 0, the attacker would start at the specified lower bound, and you'd have gained nothing.</p>
","752","<c><gmp><diffie-hellman>","3","1","2","2010-03-08 19:05:39","2403909","1","","26227","","2010-03-08 19:01:55","2010-03-08 18:55:18",""
"46446456","How to disable diffie-hellman-group1-sha1 in ganymed-ssh2-build210.jar","<p>In Java we are using ganymed-ssh2-build210.jar for connecting to the server via ssh. I need to restrict the weaker algorithm "" diffie-hellman-group1-sha1 "" specifically.</p>

<p>Is there any customizable settings in ganymed-ssh2-build210.jar that allows to restrict this ?</p>

<p>Is there any java.security setting available for restricting the same ?</p>
","<p>You want to change allowed ciphers on the server rather than in your client, otherwise anyone can bypass this easily.</p>

<p>Check answer: <a href=""https://unix.stackexchange.com/questions/333728/ssh-how-to-disable-weak-ciphers"">https://unix.stackexchange.com/questions/333728/ssh-how-to-disable-weak-ciphers</a></p>
","748","<java><ssh><diffie-hellman><java-security><ganymede>","0","1","2","2017-09-29 11:06:44","","2","","2169951","","2017-09-27 13:01:59","2017-09-27 11:12:45",""
"46446456","How to disable diffie-hellman-group1-sha1 in ganymed-ssh2-build210.jar","<p>In Java we are using ganymed-ssh2-build210.jar for connecting to the server via ssh. I need to restrict the weaker algorithm "" diffie-hellman-group1-sha1 "" specifically.</p>

<p>Is there any customizable settings in ganymed-ssh2-build210.jar that allows to restrict this ?</p>

<p>Is there any java.security setting available for restricting the same ?</p>
","<p>If you cannot control the server but the library on the client.</p>

<p>Following might be an option</p>

<ul>
<li>get the source of the library <a href=""http://central.maven.org/maven2/ch/ethz/ganymed/ganymed-ssh2/build210/ganymed-ssh2-build210-sources.jar"" rel=""nofollow noreferrer"">ganymed-ssh2-build210-sources.jar</a></li>
<li>amend <code>ch/ethz/ssh2/transport/KexManager.java</code> to not support anymore <code>diffie-hellman-group1-sha1</code></li>
<li>compile the amended code</li>
<li>create the patched library as <code>ganymed-ssh2-build210_1.jar</code> and use this one with the client application</li>
</ul>

<p><strong>edit</strong> Find a step-by-step instruction to verify the above.</p>

<p>Assume following structure</p>

<pre><code>bin/
apache-sshd-1.6.0.tar.gz
ganymed-ssh2-build210.jar
ganymed-ssh2-build210-sources.jar
SshClientDemo.java
SshServerDemo.java
</code></pre>

<ul>
<li>download the archives<br><a href=""https://mina.apache.org/sshd-project/downloads.html"" rel=""nofollow noreferrer"">choose a mirror for apache-sshd-1.6.0.tar.gz</a><br><a href=""http://central.maven.org/maven2/ch/ethz/ganymed/ganymed-ssh2/build210/ganymed-ssh2-build210.jar"" rel=""nofollow noreferrer"">ganymed-ssh2-build210.jar</a><br><a href=""http://central.maven.org/maven2/ch/ethz/ganymed/ganymed-ssh2/build210/ganymed-ssh2-build210-sources.jar"" rel=""nofollow noreferrer"">ganymed-ssh2-build210-sources.jar</a></li>
</ul>

<p><strong>SshServerDemo.java</strong></p>

<pre><code>package sub.optimal;

import java.nio.file.Paths;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.sshd.common.NamedFactory;
import org.apache.sshd.common.kex.KeyExchange;
import org.apache.sshd.common.util.GenericUtils;
import org.apache.sshd.server.SshServer;
import org.apache.sshd.server.keyprovider.SimpleGeneratorHostKeyProvider;
import org.apache.sshd.server.scp.ScpCommandFactory;
import org.apache.sshd.server.shell.InteractiveProcessShellFactory;
import org.apache.sshd.server.shell.ProcessShellFactory;

public class SshServerDemo extends Thread {

    public static void main(String[] args) throws Exception {
        Logger.getGlobal().setLevel(Level.FINEST);
        SshServer sshd = SshServer.setUpDefaultServer();
        sshd.setPort(2222);
        sshd.setKeyPairProvider(
                new SimpleGeneratorHostKeyProvider(Paths.get(""hostkey.ser""))
        );
        sshd.setShellFactory(InteractiveProcessShellFactory.INSTANCE);
        sshd.setCommandFactory(
                new ScpCommandFactory.Builder().withDelegate(
                        cmd -&gt; new ProcessShellFactory(
                                GenericUtils.split(cmd, ' ')
                        ).create()
                ).build()
        );

        List&lt;NamedFactory&lt;KeyExchange&gt;&gt; keyExchangeFactories;
        keyExchangeFactories = sshd.getKeyExchangeFactories();
        keyExchangeFactories.removeIf(
                e -&gt; !e.getName().equals(""diffie-hellman-group1-sha1"")
        );

        sshd.setKeyExchangeFactories(keyExchangeFactories);
        sshd.setPasswordAuthenticator(
                (username, password, session) -&gt; username.equals(password)
        );

        sshd.start();
        Thread.sleep(Long.MAX_VALUE);
    }
}
</code></pre>

<p><strong>SshClientDemo.java</strong></p>

<pre><code>package sub.optimal;

import ch.ethz.ssh2.Connection;
import ch.ethz.ssh2.Session;
import ch.ethz.ssh2.StreamGobbler;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;

public class SshClientDemo {

    public static void main(String[] args) throws Exception {
        Connection conn = new Connection(""localhost"", 2222);
        conn.connect();
        boolean isAuthenticated = conn.authenticateWithPassword(""foo"", ""foo"");
        Session sess = conn.openSession();
        System.out.println(""session is authenticated: "" + isAuthenticated);

        sess.execCommand(""echo I'm there..."");

        InputStream stdout = new StreamGobbler(sess.getStdout());
        BufferedReader br = new BufferedReader(new InputStreamReader(stdout));

        while (true) {
            String line = br.readLine();
            if (line == null) {
                break;
            }
            System.out.println(line);
        }

        sess.close();
        conn.close();
    }
}
</code></pre>

<ul>
<li><p>extract the Apache server</p>

<pre><code>tar xzf apache-sshd-1.6.0.tar.gz
</code></pre></li>
<li><p>compile the demo classes</p>

<pre><code>javac -cp ""apache-sshd-1.6.0/lib/*"" -d bin/ SshServerDemo.java
javac -cp ganymed-ssh2-build210.jar -d bin/ SshClientDemo.java
</code></pre></li>
<li><p>extract the <code>KexManager.java</code></p>

<pre><code>jar vxf ganymed-ssh2-build210-sources.jar \
    ch/ethz/ssh2/transport/KexManager.java
</code></pre></li>
<li><p>modify the file <code>KexManager.java</code></p>

<pre><code>public static final String[] getDefaultKexAlgorithmList() {
    return new String[] { 
        ""diffie-hellman-group-exchange-sha1"", 
        ""diffie-hellman-group14-sha1""// ,
        // ""diffie-hellman-group1-sha1""
    };
}
...
public static final void checkKexAlgorithmList(String[] algos)
    ...
    if (""diffie-hellman-group14-sha1"".equals(algos[i]))
        continue;

    // if (""diffie-hellman-group1-sha1"".equals(algos[i]))
    //    continue;
    ...
</code></pre></li>
<li><p>compile the patched <code>KexManager.java</code></p>

<pre><code>javac -cp ganymed-ssh2-build210.jar ch/ethz/ssh2/transport/KexManager.java
</code></pre></li>
<li><p>create a patched library</p>

<pre><code>cp ganymed-ssh2-build210.jar ganymed-ssh2-build210-patched.jar
jar vuf ganymed-ssh2-build210-patched.jar \
    ch/ethz/ssh2/transport/KexManager.class 
</code></pre></li>
</ul>

<p><strong>in command line session ONE</strong></p>

<ul>
<li><p>start the server</p>

<pre><code>java -cp ""bin/:apache-sshd-1.6.0/lib/*"" sub.optimal.SshServerDemo
</code></pre></li>
</ul>

<p><strong>in command line session TWO</strong></p>

<ul>
<li><p>check first the key exchange algos supported by the server</p>

<pre><code>ssh -vv foo@localhost -p 2222
</code></pre>

<p>in the output only the <code>diffie-hellman-group1-sha1</code> is reported</p>

<pre><code>debug2: peer server KEXINIT proposal
debug2: KEX algorithms: diffie-hellman-group1-sha1
</code></pre></li>
<li><p>run the client with the <strong>un-patched</strong> library</p>

<pre><code>java -cp bin/:ganymed-ssh2-build210.jar sub.optimal.SshClientDemo
</code></pre>

<p>output</p>

<pre><code>session is authenticated: true
I'm there...
</code></pre></li>
<li><p>run the client with the <strong>patched</strong> library</p>

<pre><code>java -cp bin/:ganymed-ssh2-build210-patched.jar sub.optimal.SshClientDemo
</code></pre>

<p>output</p>

<pre><code>Caused by: java.io.IOException: Cannot negotiate, proposals do not match.
</code></pre>

<p>on the server log</p>

<pre><code>Unable to negotiate key exchange for kex algorithms \
   (client: diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1 \
   / server: diffie-hellman-group1-sha1)
</code></pre></li>
</ul>

<p>That proves that the SshClientDemo with the <strong>patched</strong> library cannot use the key exchange algorithm <code>diffie-hellman-group1-sha1</code> to connect to the server (which for the PoC only support this one).</p>
","748","<java><ssh><diffie-hellman><java-security><ganymede>","0","2","2","2017-09-29 11:06:44","","2","","2169951","","2017-09-27 13:01:59","2017-09-27 11:12:45",""
"47504844","How to generalize the Diffie-Hellman key exchange to three or more parties?","<p>I know how to do a key exchange between 2 parties, but I need to be able to have a key agreement between 3 or more parties.</p>
","<p>It may be a bit more complex than two.</p>

<p>Consider a loop with <em>N</em> people. Each is numbered 1, 2, 3, ..., <em>N</em>. They share the same <em>P</em> and <em>G</em>. Everyone has his own <em>a<sub>i</sub></em> number. Now everyone computes <em>G<sup>a</sup></em> for themselves, and send the result to the next one. Then everyone computes the value <em>G<sub>1</sub><sup>a</sup></em> where <em>G<sub>1</sub></em> is the value that the previous person gives. Repeat the procedure for <em>N</em> times and everyone has the same number <em>G<sub>N</sub></em> = <em>G<sup>a<sub>1</sub>a<sub>2</sub>...a<sub>N</sub></sup></em>.</p>

<p>Pseudocode:</p>

<pre><code>import G, P from public
generate a
send pair{pow(G, a, P), 1} to next person
for i = 1 to N-1:
  receive pair{Gx, x} from previous person
  if x = N:
    key = Gx
  else
    send pair{pow(Gx, a, P), x+1} to next person
return key
</code></pre>
","742","<diffie-hellman>","0","1","1","2017-11-27 11:09:09","47504979","4","1","472495","","2017-11-27 11:07:51","2017-11-27 06:06:24",""
"15838381","OpenSSL Diffie Hellman DER Encoding in C","<p>I have a problem and spent the last two days searching for an answers.</p>

<p>I generated a DH Object with OpenSSL in C (more specific Objective-C, but I think there isn't something like that) and now can access the p,q and publickey values that are Bignums. I need to send these values as ASN.1 DER Encoding to a server as one base64 string.</p>

<p>On the Android Client the important step is <em>.getPublic().getEncoded() followed by a base64 Encoding. (</em> is something with a keyagreement or so)</p>

<p>How can I do that on c or objective-c? Code examples would be very very great.</p>
","<p>For DER encoding, you can i2d_DHParams may solve your purpose.</p>

<p>Suppose you have DH parameters in dh, then you can call</p>

<pre><code>  int len;
  len  = i2d_DHParams (dh, &amp;buf);
  //It should write encoded dh to buf and len should be number of bytes written.
</code></pre>

<p>You can see DH methods <a href=""http://www.openssl.org/docs/crypto/dh.html"" rel=""nofollow"">here</a>.</p>
","733","<objective-c><c><openssl><asn.1><diffie-hellman>","3","1","1","2016-02-26 13:29:17","15851875","0","","","","","2013-04-05 15:58:26",""
"16455365","How Ephemeral Diffie Hellman works?","<p>can anybody please provide link which will clearly explains how ephemeral  Diffie hellman algorithm works (TLS_DHE_RSA_DES_256_CBC)?</p>
","<p>It is described in TSL 1.0 and 1.1 RFCs, see RFC 2246 and RFC 4346.</p>
","727","<openssl><encryption><diffie-hellman>","1","1","1","2013-05-09 07:45:16","16456925","1","","","","","2013-05-09 05:59:17","2013-05-09 11:42:36"
"47190886","certbot using weak diffie hellman encryption","<p>I was reading here</p>

<p><a href=""https://weakdh.org/"" rel=""nofollow noreferrer"">https://weakdh.org/</a></p>

<p>If I verify security on</p>

<p><a href=""https://www.ssllabs.com/ssltest/analyze.html"" rel=""nofollow noreferrer"">https://www.ssllabs.com/ssltest/analyze.html</a></p>

<p>of one of my sites using <a href=""http://certbot.eff.org"" rel=""nofollow noreferrer"">certbot</a> I get rated B because of that</p>

<p><a href=""https://i.stack.imgur.com/437fC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/437fC.png"" alt=""enter image description here""></a></p>

<p>is there a solution?</p>

<p>certbot basically is the implementation of <a href=""https://letsencrypt.org/"" rel=""nofollow noreferrer"">https://letsencrypt.org/</a> for many systems.</p>
","<p>I just ran into the same problem.  The core issue is described here:
<a href=""https://weakdh.org/"" rel=""nofollow noreferrer"">https://weakdh.org/</a></p>

<p>As I understand it, most web servers start Diffie-Hellman with the same default set of prime numbers, and this was later found to be a security flaw.  The fix is to generate new primes for your site's Diffie-Hellman key negotiation.  This page has details: <a href=""https://weakdh.org/sysadmin.html"" rel=""nofollow noreferrer"">https://weakdh.org/sysadmin.html</a></p>

<p>In short, run <code>openssl dhparam -out dhparams.pem 2048</code>, and then add the path to the resulting file in your nginx server config block:</p>

<pre><code>ssl_dhparam {path to dhparams.pem};
</code></pre>

<p>For example, I put mine in <code>/etc/letsencrypt</code>, so I ran</p>

<pre><code>sudo openssl /etc/letsencrypt/dhparam -out dhparams.pem 2048
</code></pre>

<p>and added</p>

<pre><code>ssl_dhparam /etc/letsencrypt/dhparams.pem;
</code></pre>

<p>under the other Certbot config lines in my server block.</p>

<p>After restarting nginx with <code>sudo service nginx restart</code> I got an A grade on ssllabs.com.</p>

<p>I hope this helps.</p>
","718","<ssl><lets-encrypt><diffie-hellman><starttls><certbot>","2","2","1","2018-01-15 17:34:32","48268046","3","","","","","2017-11-08 22:36:05",""
"47944301","Diffie-Hellman crack with partial info known","<p>This is school work.</p>

<p>I'm given the problem of finding the private keys of both parties in a DH exchange. The numbers involved in the tests aren't big enough and the task is basically brute-force.
In the task, I can get the prime <code>p</code>, generator <code>g</code> and Alice's public key <code>A</code>.
I'm also given the methods to encrypt a message and decrypt a message with a custom key.</p>

<p>Right now I've only gotten <code>a</code> by simply looping through integers <code>i=1...p</code> and checking if <code>g^i mod p == g^A mod p</code> and promptly returning the first value that meets the requirement.</p>

<p>However, my solution isn't always true according to automated tests.
Anyone know how or even if it's possible to fins <code>a</code> and <code>b</code> with the given info?</p>
","<p>Thanks to a third party, I managed to crack the DH code:</p>

<pre><code>public Integer crackAlice() {
        // TODO
        Integer alicePrivate = 0;

        int p = session.getP();
        int g = session.getG();
        int A = session.getAlicesPublicKey();
        // A = g^a mod p


        System.out.println(""Alice public A: ""+A);
        String message = String.valueOf(156215);

        for (int i = 1; i &lt; p; i++) {
            if (BigInteger.valueOf(g).pow(i).mod(BigInteger.valueOf(p)).equals(BigInteger.valueOf(A))) {
                //System.out.println(""\t\t\t\t""+BigInteger.valueOf(g).pow(i));
                alicePrivate = i;
                System.out.println(""Potential Alice private a: ""+i);
                //break;
            }
        }
        return alicePrivate;
    }
</code></pre>

<p>and</p>

<pre><code>public Integer crackBob() {
        // TODO

        Integer bobPrivate = 0;
        Integer a = crackAlice();
        int p = session.getP();
        int g = session.getG();
        int A = session.getAlicesPublicKey();
        String mainMessage = ""teade"";

        String msg = null;
        try {
            msg = session.getEncrypted(mainMessage);
        } catch (Exception e) {
            e.printStackTrace();
        }

        for (int i = 1; i &lt; p; i++) {
            int ai = a*i;
            int Ai = A*i;
            //System.out.println(""a*b = ""+ai);
            BigInteger bigintP = BigInteger.valueOf(p);
            if (((BigInteger.valueOf(g).pow(a).mod(bigintP)).pow(i)).mod(bigintP)
                    .equals(((BigInteger.valueOf(g).pow(i).mod(bigintP)).pow(a)).mod(bigintP))) {
                String decrypt = null;
                try {
                    decrypt = session.getDecryptedWithCustomKey(msg, BigInteger.valueOf(g).pow(a*i).mod(bigintP).intValue());
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (decrypt != null &amp;&amp; decrypt.trim().equals(mainMessage)) {
                    bobPrivate = i;
                    break;
                }
            }
        }
        return bobPrivate;
    }
</code></pre>

<p>I hope this will help out other with a similar problem.</p>
","709","<java><algorithm><diffie-hellman>","-1","0","1","2017-12-22 18:42:27","47945970","1","","","","","2017-12-22 16:05:32",""
"36260101","BlueZ: LE secure pairing using Elliptical Curve Diffie-Hellman from command line","<p>One of the main features of Bluetooth v4.2 is LE secure connections, where Elliptic Curve Diffie Helman (ECDH) is used for the key agreement protocol. As of BlueZ v5.26, support for LE secure connections has been added as follows:-</p>

<p>""<em>BlueZ 5.26 is the first release with support for Blueooth 4.2 features. Perhaps the most notable one of these is Low Energy Secure Connections which will require a 3.19 or newer kernel.</em>""[1]</p>

<p>Is there a way to test ECDH pairing through the command line? if not, what is the easiest way to test this?</p>

<p>I'm using BlueZ v5.38 on kernel 3.19 but I can't figure out how to do this. </p>

<p>[1] <a href=""http://www.bluez.org/release-of-bluez-5-26/"" rel=""nofollow"">http://www.bluez.org/release-of-bluez-5-26/</a></p>
","<p>In Linux, the secure connections feature using ECDH can be verified by performing pairing (using bluetoothctl) between two Bluetooth v4.2 devices and observing the output through btmon. Look for HCI Event: Link Key Notification and observe the Key type. If it shows P-256, then Secure Connections feature is verified. If it shows P-192, then it is using Secure Simple Pairing (SSP).</p>

<p>Additional background on this can be found in the Bluetooth Core Specification v4.2 in Vol 1, Part A, Section 5.1: Security Architecture.</p>

<p>I hope this helps.</p>
","690","<linux><bluetooth-lowenergy><bluez><diffie-hellman>","2","1","1","2017-02-03 02:19:53","42015695","0","2","","","","2016-03-28 10:07:53",""
"38105010","Extract the shared secret from class ECDiffieHellmanCng","<p>I am currently developing an SSH client and it is necessary that said client is able to exchange keys with the server via ECDH KEX (NIST-256, 384 and 521).</p>

<p>I did some (actually a lot) of research, found the .NET class <code>ECDiffieHellmanCng</code>, and was able to extract and import the public key of the server into the class. </p>

<p>The problem, however, is that I can't extract the shared secret without deriving it (<code>ECDiffieHellmanCng.DeriveKeyMaterial(CngKey otherpartyPublicKey)</code>).</p>

<p>Is there a way to directly access the shared secret (""k"" as it's called in the RFC papers)?</p>

<p><a href=""https://www.ietf.org/rfc/rfc5656.txt"" rel=""nofollow"">Here</a> is page 7 from the RFC of the ECDH implementation and why I need the shared secret:</p>

<blockquote>
  <p>The exchange hash H is computed as the hash of the concatenation of
  the following.</p>
  
  <p>string V_C, client's identification string (CR and LF excluded)</p>
  
  <p>string   V_S, server's identification string (CR and LF excluded)</p>
  
  <p>string   I_C, payload of the client's SSH_MSG_KEXINIT</p>
  
  <p>string   I_S, payload of the server's SSH_MSG_KEXINIT</p>
  
  <p>string   K_S, server's public host key</p>
  
  <p>string   Q_C, client's ephemeral public key octet string</p>
  
  <p>string   Q_S, server's ephemeral public key octet string</p>
  
  <p>mpint    K,   shared secret &lt;-- this is why I need the pure secret
  before any derivation</p>
</blockquote>

<p>Thanks for any solutions or hints!</p>
","<p>Even after a lot of research i couldn't find a way to do it so the answer is no - you can not extract the secret.</p>

<p>My solution for the big picture was to discard the ECDiffieHellmanCng class altogether and instead wrap the OpenSSH library in C#.</p>

<p>Hope this at least helps someone else with the same idea.</p>
","681","<c#><.net><ssh><elliptic-curve><diffie-hellman>","0","0","2","2016-07-17 01:00:05","38182858","0","","1636276","","2016-06-29 16:48:13","2016-06-29 16:13:15",""
"38105010","Extract the shared secret from class ECDiffieHellmanCng","<p>I am currently developing an SSH client and it is necessary that said client is able to exchange keys with the server via ECDH KEX (NIST-256, 384 and 521).</p>

<p>I did some (actually a lot) of research, found the .NET class <code>ECDiffieHellmanCng</code>, and was able to extract and import the public key of the server into the class. </p>

<p>The problem, however, is that I can't extract the shared secret without deriving it (<code>ECDiffieHellmanCng.DeriveKeyMaterial(CngKey otherpartyPublicKey)</code>).</p>

<p>Is there a way to directly access the shared secret (""k"" as it's called in the RFC papers)?</p>

<p><a href=""https://www.ietf.org/rfc/rfc5656.txt"" rel=""nofollow"">Here</a> is page 7 from the RFC of the ECDH implementation and why I need the shared secret:</p>

<blockquote>
  <p>The exchange hash H is computed as the hash of the concatenation of
  the following.</p>
  
  <p>string V_C, client's identification string (CR and LF excluded)</p>
  
  <p>string   V_S, server's identification string (CR and LF excluded)</p>
  
  <p>string   I_C, payload of the client's SSH_MSG_KEXINIT</p>
  
  <p>string   I_S, payload of the server's SSH_MSG_KEXINIT</p>
  
  <p>string   K_S, server's public host key</p>
  
  <p>string   Q_C, client's ephemeral public key octet string</p>
  
  <p>string   Q_S, server's ephemeral public key octet string</p>
  
  <p>mpint    K,   shared secret &lt;-- this is why I need the pure secret
  before any derivation</p>
</blockquote>

<p>Thanks for any solutions or hints!</p>
","<p>You don't actually need <code>k</code>, then, you just need to compute H.  The ECDiffieHellman class allows you to do that.</p>

<pre><code>byte[] prepend = Concat(V_C, V_S, I_C, I_S, K_S, Q_C, Q_S);
byte[] exchangeHash = ecdh.DeriveKeyFromHash(otherPublic, new HashAlgorithmName(""whatever your hash algorithm is""), prepend, null);
</code></pre>

<p>Though that is using .NET 4.6.2 (currently in preview) API: <a href=""https://msdn.microsoft.com/en-us/library/mt693487(v=vs.110).aspx"" rel=""nofollow"">DeriveKeyFromHash</a></p>

<p>If you are on an older framework it's still possible, but requires using the ECDiffieHellmanCng type specifically:</p>

<pre><code>ecdhCng.SecretPrepend = prepend;
ecdhCng.SecretAppend = null;
ecdhCng.HashAlgorithm = new CngAlgorithm(""whatever your hash algorithm is"");
ecdhCng.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
byte[] exchangeHash = ecdhCng.DeriveKeyMaterial(otherPublic);
</code></pre>
","681","<c#><.net><ssh><elliptic-curve><diffie-hellman>","0","1","2","2016-07-17 01:00:05","38182858","0","","1636276","","2016-06-29 16:48:13","2016-06-29 16:13:15",""
"31736118","How do you create an EVP_KEY for a peer key given the Base64 encoding?","<p>Using OpenSSL, I've created my Diffie-Hellman Private/Public keys and received my peer's public key.  I can decode my peer's key from Base64 string to byte array, but how do I poke that into my original Public/Private Key EVP_KEY structure so it can be used with the EVP_PKEY_derive() to produce the shared key?</p>

<p>It's very unclear exactly what one should do to create the ""peerkey"" EVP_PKEY, but here's my code that takes a shot at it.</p>

<pre><code>void CreateSharedKey(string &amp;peerKey64)
{
    EVP_PKEY *publicKey;  // Created earlier
    EVP_PKEY *peerKey;

    // Decode peer key
    unsigned char *pBuff;
    int buffLen = base64Decode(peerKey64, &amp;pBuff);
    const unsigned char *pConst = pBuff;

    // Create peer key
    peerKey = d2i_PUBKEY(NULL, &amp;pConst, buffLen);
    if (peerKey == NULL)
        return;

    // Create shared key context
    EVP_PKEY_CTX *ctxShared;
    ctxShared = EVP_PKEY_CTX_new(publicKey, NULL);
    if (ctxShared == NULL)
        return;

    // Initialize for deriving shared key
    if (EVP_PKEY_derive_init(ctxShared) &lt;= 0)
        return;

    // Add peer key to context
    if (int rc = EVP_PKEY_derive_set_peer(ctxShared, peerKey) &lt;= 0)
        return;

    // Determine buffer length for shared key
    size_t sharedKeyBufferSize;
    if (EVP_PKEY_derive(ctxShared, NULL, &amp;sharedKeyBufferSize) &lt;= 0)
        return;

    // Allocate buffer for shared key
    unsigned char *sharedKeyBuffer = new unsigned char[sharedKeyBufferSize];
    if (sharedKeyBuffer == NULL)
        return;

    // Derive the shared key
    if (EVP_PKEY_derive(ctxShared, sharedKeyBuffer, &amp;sharedKeyBufferSize) &lt;= 0)
    {
        unsigned long error = ERR_get_error();
        cout &lt;&lt; ""Failed to derive shared key. Error code = "" &lt;&lt; error &lt;&lt; std::endl;
        cout &lt;&lt; ERR_reason_error_string(error) &lt;&lt; std::endl;

        return;
    }

    // Free shared key context
    EVP_PKEY_CTX_free(ctxShared);

    // Create Base64 shared key string
    base64Encode(sharedKeyStr, sharedKeyBuffer, sharedKeyBufferSize);
}
</code></pre>

<p>The OpenSSL error output is as follows:</p>

<p><em>Failed to add peer to shared key context. Error code = 101298329
different parameters</em></p>

<p>How can it have different parameters when it was derived from a Context that was BASED on the parameters already existing in the original publicKey?</p>
","","669","<c++><openssl><diffie-hellman>","3","","0","2015-07-31 20:25:17","","1","2","1340021","","2015-07-31 20:25:17","2015-07-31 00:11:51",""
"43871026","C# and PHP ECDH not matching","<p>I'm trying to generate a shared secret between a web server running PHP and a C# desktop application. I'm aware of the BouncyCastle library, but I'd prefer not having to use it since it's pretty huge.</p>

<p>I'm using <a href=""https://github.com/phpecc/phpecc"" rel=""nofollow noreferrer"">phpecc</a> and <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.ecdiffiehellmancng(v=vs.110).aspx"" rel=""nofollow noreferrer"">ECDiffieHellmanCng</a> and trying to generate a shared secret between the two parties but I'm having issues with exporting/importing in C#.</p>

<p>It seems phpecc requires der/pem format in order to import a key, and ECDiffieHellmanCng doesn't seem to have any easy way to export in a compatible format.</p>

<p>Would I need to write my own pem/der encoder and decoder in order to do this or is there some alternative easier way?</p>

<p>Currently I'm doing the following in C#:</p>

<pre><code>using (var ecdh = new ECDiffieHellmanCng())
        {
            ecdh.HashAlgorithm = CngAlgorithm.ECDiffieHellmanP384;
            ecdh.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;

            var encoded = EncodePem(ecdh.PublicKey.ToByteArray()); 
            //... do something with encoded
        }

private static string EncodePem(byte[] data)
    {
        var pemDat = new StringBuilder();
        var chunk = new char[64];

        pemDat.AppendLine(""-----BEGIN PUBLIC KEY-----"");

        var encodedData = Convert.ToBase64String(data);
        for (var i = 0; i &lt; encodedData.Length; i += chunk.Length)
        {
            var index = 0;
            while (index != chunk.Length &amp;&amp; i + index &lt; encodedData.Length)
            {
                chunk[index] = encodedData[i + index];
                index++;
            }
            pemDat.AppendLine(new string(chunk));
        }

        pemDat.AppendLine(""-----END PUBLIC KEY-----"");
        return pemDat.ToString();
    }
</code></pre>

<p>Obviously the above is only doing the pem encoding, so on the php side it returns an error when it's trying to parse it:</p>

<blockquote>
  <p>Type: Runtime</p>
  
  <p>Exception Message: Invalid data.</p>
  
  <p>File: /.../vendor/mdanter/ecc/src/Serializer/PublicKey/Der/Parser.php</p>
  
  <p>Line: 49</p>
</blockquote>
","<p>.NET Core 1.0 and <a href=""https://blogs.msdn.microsoft.com/dotnet/2017/04/05/announcing-the-net-framework-4-7/"" rel=""nofollow noreferrer"">.NET Framework 4.7</a> have the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.ecparameters(v=vs.110).aspx"" rel=""nofollow noreferrer"">ECParameters</a> struct to import/export keys.  The <code>ToByteArray()</code> method you called is producing a <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa375520(v=vs.85).aspx"" rel=""nofollow noreferrer"">CNG EccPublicBlob</a> which has very little to do with the SEC-1 ECParameters format.</p>

<p>I'm going to assume that you wanted to use secp384r1/NIST P-384, even though you specified that as a hash algorithm.  If you want some other curve, you'll need to do some translations.</p>

<p>The (.NET) ECParameters struct will only help you get started.  Turning that into a file requires translating it into a PEM-encoded DER-encoded ASN.1-based structure. (But if you're sticking with NIST P-256/384/521, you can do it with the byte[] you currently have)</p>

<p>In <a href=""http://www.secg.org/sec1-v2.pdf"" rel=""nofollow noreferrer"">SEC 1 v2.0</a> we get the following structures:</p>

<pre><code>SubjectPublicKeyInfo ::= SEQUENCE {
  algorithm AlgorithmIdentifier {{ECPKAlgorithms}} (WITH COMPONENTS {algorithm, parameters}),
  subjectPublicKey BIT STRING
}

ECPKAlgorithms ALGORITHM ::= {
  ecPublicKeyType |
  ecPublicKeyTypeRestricted |
  ecPublicKeyTypeSupplemented |
  {OID ecdh PARMS ECDomainParameters {{SECGCurveNames}}} |
  {OID ecmqv PARMS ECDomainParameters {{SECGCurveNames}}},
  ...
}

ecPublicKeyType ALGORITHM ::= {
  OID id-ecPublicKey PARMS ECDomainParameters {{SECGCurveNames}}
}

ECDomainParameters{ECDOMAIN:IOSet} ::= CHOICE {
  specified SpecifiedECDomain,
  named ECDOMAIN.&amp;id({IOSet}),
  implicitCA NULL
}

An elliptic curve point itself is represented by the following type
  ECPoint ::= OCTET STRING
whose value is the octet string obtained from the conversion routines given in Section 2.3.3.
</code></pre>

<p>Distilling this down to the relevant parts, you need to write</p>

<pre><code>SEQUENCE (SubjectPublicKeyInfo)
  SEQUENCE (AlgorithmIdentifier)
    OBJECT IDENTIFIER id-ecPublicKey
    OBJECT IDENTIFIER secp384r1 (or whatever named curve you're using)
  BIT STRING
    public key encoded as ECPoint
</code></pre>

<p>The AlgorithmIdentifier contains data that's fixed given you don't change the curve:</p>

<pre><code>SEQUENCE (AlgorithmIdentifier)
30 xx [yy [zz]]
   OBJECT IDENTIFIER id-ecPublicKey (1.2.840.10045.2.1)
   06 07 2A 86 48 CE 3D 02 01
   OBJECT IDENTIFIER secp384r1 (1.3.132.0.34)
   06 05 2B 81 04 00 22
</code></pre>

<p>and we can now count how many bytes were in the payload: 16 (0x10), so we fill in the length:</p>

<pre><code>30 10 06 07  2A 86 48 CE   3D 02 01 06  05 2B 81 04
00 22
</code></pre>

<p>The public key encoding that everyone understands is ""uncompressed point"", which is</p>

<pre><code>04 th eb yt es of x. th eb yt es of y.
</code></pre>

<p>Turns out, that has a fixed size for a given curve, too, so unlike most things that are DER encoded, you can do this in one pass :).  For secp384r1 the x and y coordinate are each 384 bit values, or (384 + 7)/8 == 48 bytes, so the ECPoint is 48 + 48 + 1 == 97 (0x61) bytes. Then it needs to be wrapped in a BIT STRING, which adds one payload byte and the length and tag. So, we get:</p>

<pre><code>private static byte[] s_secp384r1PublicPrefix = {
    // SEQUENCE (SubjectPublicKeyInfo, 0x76 bytes)
    0x30, 0x76,
    // SEQUENCE (AlgorithmIdentifier, 0x10 bytes)
    0x30, 0x10,
    // OBJECT IDENTIFIER (id-ecPublicKey)
    0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01,
    // OBJECT IDENTIFIER (secp384r1)
    0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22,
    // BIT STRING, 0x61 content bytes, 0 unused bits.
    0x03, 0x62, 0x00,
    // Uncompressed EC point
    0x04,
}

...

using (ECDiffieHellman ecdh = ECDiffieHellman.Create())
{
    ecdh.KeySize = 384;

    byte[] prefix = s_secp384r1PublicPrefix;
    byte[] derPublicKey = new byte[120];
    Buffer.BlockCopy(prefix, 0, derPublicKey, 0, prefix.Length);

    byte[] cngBlob = ecdh.PublicKey.ToByteArray();
    Debug.Assert(cngBlob.Length == 104);

    Buffer.BlockCopy(cngBlob, 8, derPublicKey, prefix.Length, cngBlob.Length - 8);

    // Now move it to PEM
    StringBuilder builder = new StringBuilder();
    builder.AppendLine(""-----BEGIN PUBLIC KEY-----"");
    builder.AppendLine(
        Convert.ToBase64String(derPublicKey, Base64FormattingOptions.InsertLineBreaks));
    builder.AppendLine(""-----END PUBLIC KEY-----"");

    Console.WriteLine(builder.ToString());
}
</code></pre>

<p>Running the output I got from that into OpenSSL:</p>

<pre><code>$ openssl ec -pubin -text -noout
read EC key
(paste)
-----BEGIN PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEwpbxYmcsNvr14D8k+0VQCkSY4WCV/3V10AiIq7sFdmUX
9+0DMuuLDmcKjL1ZFEFk0yHCPpY+pdkYtzPwE+dsApCPT3Ljk0AxHQBTSo4yjwsElMoA4Mtp8Qdo
LZD1Nx6v
-----END PUBLIC KEY-----
Private-Key: (384 bit)
pub:
    04:c2:96:f1:62:67:2c:36:fa:f5:e0:3f:24:fb:45:
    50:0a:44:98:e1:60:95:ff:75:75:d0:08:88:ab:bb:
    05:76:65:17:f7:ed:03:32:eb:8b:0e:67:0a:8c:bd:
    59:14:41:64:d3:21:c2:3e:96:3e:a5:d9:18:b7:33:
    f0:13:e7:6c:02:90:8f:4f:72:e3:93:40:31:1d:00:
    53:4a:8e:32:8f:0b:04:94:ca:00:e0:cb:69:f1:07:
    68:2d:90:f5:37:1e:af
ASN1 OID: secp384r1
NIST CURVE: P-384
</code></pre>
","649","<c#><php><diffie-hellman>","0","1","1","2017-05-10 15:52:02","43897367","0","","2654057","","2017-05-09 13:25:46","2017-05-09 13:20:36",""
"48130343","elliptic curve routines:o2i_ECPublicKey:passed a null parameter:ec_asn1.c:1271:","<p>I'm creating ECDH using openssl EVP method that is explained by <a href=""https://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman"" rel=""nofollow noreferrer"">openssl elliptic curve diffie helman</a></p>

<p>Everything works expect where I get the other peer's public key and generate EVP_PKEY* based on it. </p>

<p>In the given link, it ignores implementation details of decoding other peer's public key and has used get_peerkey pseudo function:</p>

<pre><code>/* Get the peer's public key, and provide the peer with our public key -
 * how this is done will be specific to your circumstances */
peerkey = get_peerkey(pkey);
</code></pre>

<p>In my implementation the other peer's public key is received and stored in publickey2 and its size is stored in pub_len2 </p>

<pre><code>size_t pub_len2 = 0;
const unsigned char *publickey2 = get_public_key(&amp;pub_len2);
</code></pre>

<p>then I try to create EVP_PKEY* using following code:</p>

<pre><code>EVP_PKEY *pkey3=NULL;

pkey3 = d2i_PublicKey(EVP_PKEY_EC, &amp;pkey3, (const unsigned char **)&amp;publickey2, pub_len2);

if(pkey3 == NULL) {

    ERR_print_errors_fp(stderr);
}
</code></pre>

<p>but pkey3 is always null and gives me following error!</p>

<pre><code>139898837907104:error:10098043:elliptic curve routines:o2i_ECPublicKey:passed a null parameter:ec_asn1.c:1389:
139898837907104:error:0D09B00D:asn1 encoding routines:d2i_PublicKey:ASN1 lib:d2i_pu.c:123:
</code></pre>

<p>passed a null parameter error.</p>

<p>Do you guys have any idea?</p>

<p>Edit:</p>

<p>I've managed to solve this by using 
    pkey3 = d2i_PUBKEY(NULL, (const unsigned char **)&amp;publickey2, pub_len2);</p>

<p>But I faced another problems, The main problem is that calculated derived secret from these public keys is different in both peers!</p>

<p>Here is my secret derivation procedure which is the same in both peers and exactly copy and pasted (with some modification) from provided link, I made some comments for the modifications reason: </p>

<pre><code>unsigned char *derive_secret(EVP_PKEY *pkey, 
const unsigned char *peer_key, 
size_t peerkey_len, size_t *secret_len)
{
    EVP_PKEY_CTX *ctx;
    unsigned char *secret;
    //MY modification to get peer key of peer_key buffer.
    //peer_key is created by i2d_PUBKEY at peer side and 
    //received by network and is passed here
    EVP_PKEY *peerkey = d2i_PUBKEY(NULL, &amp;peer_key, peerkey_len);

    //I also set the group of newly created EC
    EC_KEY_set_group(EVP_PKEY_get1_EC_KEY(peer_key),
        EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));

    //I also set the CONVERSION format to make sure!
    EC_KEY_set_conv_form(EVP_PKEY_get1_EC_KEY(peer_key), POINT_CONVERSION_COMPRESSED);

    /* Create the context for the shared secret derivation */
    if(NULL == (ctx = EVP_PKEY_CTX_new(pkey, NULL))) handleErrors();

    /* Initialise */
    if(1 != EVP_PKEY_derive_init(ctx)) handleErrors();

    /* Provide the peer public key */
    if(1 != EVP_PKEY_derive_set_peer(ctx, peerkey)) handleErrors();

    /* Determine buffer length for shared secret */
    if(1 != EVP_PKEY_derive(ctx, NULL, secret_len)) handleErrors();

    /* Create the buffer */
    if(NULL == (secret = OPENSSL_malloc(*secret_len))) handleErrors();

    /* Derive the shared secret */
    if(1 != (EVP_PKEY_derive(ctx, secret, secret_len))) handleErrors();

    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(peerkey);
    EVP_PKEY_free(pkey);

    /* Never use a derived secret directly. Typically it is passed
     * through some hash function to produce a key */
    return secret;
}
</code></pre>

<p>I also printed out sent and received public keys on both side and made sure public keys are being received in one piece and exactly the same as they created and sent!</p>

<p>There is also some minor problem an that is when I figured that a long bytes of public keys are the same for both peers! Is that normal for a public key of EC diffie-helman?</p>

<p>Here are the public keys shown in HEX format</p>

<pre><code>Peer1:
3082010A3081E306072A8648CE3D02013081D7020101302C06072A8648CE3D0101022100FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF305B0420FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC04205AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B031500C49D360886E704936A6678E1139D26B7819F7E900421036B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296022100FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551020101032200026B0E07FE6177D23B0E6B776CF4CB0569735159D3261767FA5FC0A4636EF310C4

Peer2:

3082010A3081E306072A8648CE3D02013081D7020101302C06072A8648CE3D0101022100FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF305B0420FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC04205AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B031500C49D360886E704936A6678E1139D26B7819F7E900421036B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296022100FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC6325510201010322000208AE9F32ECE16072428A5FC875A19B3913C4516419917E723AA4C2DC20105C0A
</code></pre>
","<p><strong>some bytes (prefix) the same</strong>: all public keys in X.509-format (more exactly, <a href=""https://tools.ietf.org/html/rfc5280#section-4.1"" rel=""nofollow noreferrer"">SubjectPublicKeyInfo</a>) have at least an 'object identifier' (OID), which is the same for all keys of a given algorithm (like EC), and EC keys also have 'parameters' specifying a group/curve, which is the same for all keys on the same curve -- and keys for an ECDH agreement must be on the same curve. This identical data, combined with the fact that the actual pubkeys have different values but same <em>size</em>, results in the ASN.1 DER encodings starting with the same bytes.</p>

<p>The pubkey encodings you posted use the mostly-obsolete <strong>explicit curve specification</strong>, see <a href=""https://tools.ietf.org/html/rfc3279#section-2.3.5"" rel=""nofollow noreferrer"">rfc3279 sec 2.3.5</a> (equivalent to X9.62 or SEC1) which is much longer than the now-preferred and often required 'named' specification. At a guess, you used OpenSSL library below 1.1.0 to generate these keys and didn't set asn1_flag in the EC_GROUP object (or group subobject of EC_KEY) before serializing (aka encoding) with i2d (or PEM_write).
The wiki page you referenced sort of covers this in section 3 ""ECDH and Named Curves"" although it only mentions private keys when this also applies to public keys and certificates -- but public key and (then) certificate are derived <em>from</em> private key, so setting asn1_flag on private key is sufficient. And it doesn't say that 'named' is now the default in 1.1.0 and no longer needs to be explicitly set.</p>

<p><strong>your newly-posted code</strong>: point_format is meaningful only when serializing (i2d or PEM_write) so setting it on a deserialized key that will only be used and free'd (not reserialized) is useless. OTOH setting the EC group to its existing value (which was set from deserialization) is useless, but setting it to any other value will cause chaos. EC public keys are points on a specific curve and different curves have entirely different points -- a value that is a point on one curve is not a point on another curve. Also, using a get1 function and not free'ing the result leaks memory.</p>

<p><strong>derivation result different</strong>: that's quite wrong for (EC)DH, and I can't reproduce it. Below is your deriviation code with the few fixes indicated above and some tiny changes to match my coding style, plus the generation code from the wiki and a trivial main to drive them, and when I run this I get pubkeys with a common prefix (shorter due to using named form) but as expected the same derivation result:</p>

<pre><code>$ cat SO48130343.c 
/* SO48130343 */
#include &lt;stdio.h&gt;
#include &lt;openssl/opensslv.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/x509.h&gt;
#include &lt;openssl/ec.h&gt;
#include &lt;openssl/err.h&gt;

void hex (unsigned char *p, size_t n){ while(n--) printf(""%02x"", *p++); }

void err (const char * msg){ fprintf(stderr, ""%s:\n"", msg); ERR_print_errors_fp(stderr); exit(1); }

EVP_PKEY * gen (void) {
  EVP_PKEY_CTX *pctx, *kctx;
  EVP_PKEY *params = NULL, *pkey = NULL;
  if( NULL == (pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) ) err(""CTX1_new"");
  if( 1 != EVP_PKEY_paramgen_init(pctx) ) err(""pg_init"");
  if( 1 != EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_X9_62_prime256v1) ) err(""pg_curve"");
  if( 1 != EVP_PKEY_paramgen(pctx, &amp;params) ) err(""pg"");
  if( NULL == (kctx = EVP_PKEY_CTX_new(params, NULL)) ) err(""CTX2_new"");
  if( 1 != EVP_PKEY_keygen_init(kctx) ) err(""kg_init"");
  if( 1 != EVP_PKEY_keygen(kctx, &amp;pkey) ) err(""kg"");
#if OPENSSL_VERSION_NUMBER &lt; 0x1010000fL
  EC_KEY_set_asn1_flag (pkey-&gt;pkey.ec, OPENSSL_EC_NAMED_CURVE);
  /* point format needed before 'sending' and this is convenient */
  EC_KEY_set_conv_form (pkey-&gt;pkey.ec, POINT_CONVERSION_COMPRESSED);
#else
  /* asn1_flag now default but point format still needed */
  EC_KEY_set_conv_form (EVP_PKEY_get0_EC_KEY (pkey), POINT_CONVERSION_COMPRESSED);
#endif
  EVP_PKEY_CTX_free(pctx);
  EVP_PKEY_CTX_free(kctx);
  EVP_PKEY_free(params);
  return pkey;
}
unsigned char * derive (EVP_PKEY * self,
    const unsigned char * peer_ptr, size_t peer_len, size_t *len_ptr){
  EVP_PKEY * peer = d2i_PUBKEY (NULL, &amp;peer_ptr, peer_len);
  /* DON'T change EC_GROUP; point_format not needed on 'receive' */

  EVP_PKEY_CTX *ctx; unsigned char * buf_ptr;
  if( !(ctx = EVP_PKEY_CTX_new (self, NULL)) ) err(""CTX_new"");
  if( 1 != EVP_PKEY_derive_init(ctx) ) err(""derive_init"");
  if( 1 != EVP_PKEY_derive_set_peer(ctx, peer) ) err(""derive_peer"");
  if( 1 != EVP_PKEY_derive (ctx, NULL, len_ptr) ) err(""derive1"");
  if( !(buf_ptr = OPENSSL_malloc (*len_ptr)) ) err(""malloc"");
  if( 1 != EVP_PKEY_derive (ctx, buf_ptr, len_ptr) ) err(""derive2"");
  EVP_PKEY_CTX_free(ctx);
  EVP_PKEY_free(peer);
  return buf_ptr;
}

int main (void){
  EVP_PKEY * pkey1 = gen(), * pkey2 = gen();
  unsigned char pub1 [100], pub2 [100], *ptr1 = &amp;pub1[0], *ptr2 = &amp;pub2[0];
  size_t publen1 = i2d_PUBKEY (pkey1, &amp;ptr1), publen2 = i2d_PUBKEY (pkey2, &amp;ptr2);
  printf (""pub1=""); hex(pub1, publen1); putchar('\n');
  printf (""pub2=""); hex(pub2, publen2); putchar('\n');

  size_t len1, len2;
  unsigned char * out1 = derive (pkey1, pub2, publen2, &amp;len1);
  unsigned char * out2 = derive (pkey2, pub1, publen1, &amp;len2);
  printf (""prv1/pub2=""); hex(out1, len1); putchar('\n');
  printf (""prv2/pub1=""); hex(out2, len2); putchar('\n');
  /* don't bother freeing for Q&amp;D test code */
  return 0;
}
$ gcc [details for my system redacted]
$ ./SO48130343.exe 
pub1=3039301306072a8648ce3d020106082a8648ce3d03010703220003302c6f990445ddd27b2c0ecd3a0cd33109eec44dea0edd538c6bfc98796885e3
pub2=3039301306072a8648ce3d020106082a8648ce3d0301070322000311940ba32c0b4d71f8785a884f7ea74cebed17e841e93a0fb1ccbeac32b2eb3b
prv1/pub2=84b7a84249f1e88741a751a05d34a43e4cb131e012181967e4f465c1f4bf3b35
prv2/pub1=84b7a84249f1e88741a751a05d34a43e4cb131e012181967e4f465c1f4bf3b35
</code></pre>
","648","<c><openssl><elliptic-curve><diffie-hellman>","1","2","1","2018-01-11 09:09:42","48203295","2","","2556354","","2018-01-09 23:36:33","2018-01-06 18:11:01",""
"47004063","How can I calculate private key in algorithm Diffie-Hellman with known public key using openssl ?","<p>I have the next formula:</p>

<pre><code>2^x mod p = m;
</code></pre>

<p>I know the value p and m, how can I calculate x using openssl library ? </p>
","","589","<openssl><diffie-hellman><mod>","0","","0","2017-10-29 18:57:56","","5","","","","","2017-10-29 18:57:56",""
"28953344","Javacard KeyAgreement differs from BouncyCastle KeyAgreement","<p>My problem looks like this. I have generated keys on the card and the terminal sides. I have on the terminal side the card public and private keys and the terminals public and private keys, and the same on the card side (i'm doing tests so thats why i have all of them on the terminal and on the card). When i generate KeyAgreement (terminal side) for the card as private and for the terminal as private the secters are the same, so the generation is OK and i get a 24 bytes (192 bit) secret. When i generate the the secrets on the card (2 cases like on the terminal) the secrets are also the same, but they ale shorter - 20 bytes (160 bit). Here are the generation codes. the terminal:</p>

<pre><code>ECPublicKey publicKey;
ECPrivateKey privateKey;
</code></pre>

<p>...</p>

<pre><code>KeyAgreement aKeyAgree = KeyAgreement.getInstance(""ECDH"", ""BC"");
aKeyAgree.init(privateKey);
aKeyAgree.doPhase(publicKey, true);
byte[] aSecret = aKeyAgree.generateSecret();
</code></pre>

<p>and the card side:</p>

<pre><code>eyAgreement = KeyAgreement.getInstance(KeyAgreement.ALG_EC_SVDP_DH, false);
short length = terminalEcPublicKey.getW(array, (short) 0);

keyAgreement.init(cardEcPrivateKey);
short secretlength = keyAgreement.generateSecret(array, (short)0, length, buffer, (short)0);
</code></pre>
","<p>There is a problem in your implementation of <code>KeyAgreement.ALG_EC_SVDP_DH</code> in the terminal side. The correct length of output of the this method of key agreement should always be 20 bytes since SHA-1 is being performed on the derived output.</p>

<p>So in your terminal side, you should perform SHA-1 after generating the secret data.</p>
","580","<bouncycastle><javacard><elliptic-curve><diffie-hellman>","2","5","1","2015-03-10 00:33:50","28954235","0","","","","","2015-03-09 23:02:55",""
"27914464","Storing very large numbers in Java","<p>I'd like to store a long integer in Java, specifically the 6144-bit MODP Group (Group 17) from RFC 3526. However this number does not seem to fit to a BigInteger. Is there a way to use this prime number in Java?</p>

<p>EDIT: I tried</p>

<pre><code>BigInteger p = new BigInteger(Integer.toString(pValue));
p = 33751521821438561184518523159967412330064897805741846548173890474429429901326672445203235101919165483964194359460994881062089387893762814044257438204432573941083014827006090258925875161018096327732335800595831915976014208822304007327848132734933297885803213675261564962603340457220776826322500058091310967253976619973988033663666385188155212656268079501726223369693427999804134467810120772356498596945532366527400517575471969335854905274504119509592366013711954148258884879224599915203456315881034776553083676995718335598586395591169999570824515035017543533352697525287753332500527176569576894926734950469293596134095086603716860086302051544539652689091299099784588919052383463057789440565460681441902442399956419060521629604697347879024654313800186078316526964529288062740879011035175920059192178561473199006205896719435014765345518490882366607110905303449152556221163232127426440691921134648766635695850239231304591744215610985029636895406718880766308249227315984267542266259489684372223916445411015900506239419267909716320331208988978180868987431623710347617992356201449023892203230133009421463914291201346063125219636964261683591541014344239275340735690997732222069758773963390876360546515755280517042160525487302898122311669799679447530453600399342697032714458549591285939453949034981248114322322367238645042515984447890788917823576330019151696568654314153058547592091366014550143819685170068343700104677609041166369760080933413605498962382077778845599834907475953430787446201384567328530675275792962354883770806900827183685718353469574731680520621944540947734619035177180057973022652571032196598229259194875709994709721793154158686515748507274224181316948797104601068212015232921691482496346854413698719750190601102705274481050543239815130686073601076304512284549218459846046082253596762433827419060089029417044871218316020923109988915707117567;
</code></pre>
","<p>That number will <em>easily</em> fit into a Java <code>BigInteger</code>, but <em>both</em> methods you're using to get it are using an intermediate form into which it <em>cannot</em> fit:</p>

<pre><code>BigInteger p = new BigInteger(Integer.toString(pValue));
p = 337515218214385611845185231599674123300648978057418465481...7117567;
</code></pre>

<p>The former won't work because the <code>Integer</code> class cannot hold a number that big. The latter won't work because a ""naked"" number in your source code is treated as an <code>int</code>.</p>

<p>With the actual hex value taken from <a href=""https://www.ietf.org/rfc/rfc3526.txt"">RFC3526</a>, the following program shows how to do it:</p>

<pre><code>import java.math.BigInteger;

public class Test
{
    public static void main(String[] args) {
        BigInteger num = new BigInteger(
            ""FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08"" +
            ""8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B"" +
            ""302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9"" +
            ""A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6"" +
            ""49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8"" +
            ""FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D"" +
            ""670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C"" +
            ""180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718"" +
            ""3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D"" +
            ""04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D"" +
            ""B3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226"" +
            ""1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C"" +
            ""BBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC"" +
            ""E0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26"" +
            ""99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB"" +
            ""04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2"" +
            ""233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127"" +
            ""D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"" +
            ""36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406"" +
            ""AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918"" +
            ""DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B33205151"" +
            ""2BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03"" +
            ""F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97F"" +
            ""BEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"" +
            ""CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58B"" +
            ""B7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632"" +
            ""387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E"" +
            ""6DCC4024FFFFFFFFFFFFFFFF"", 16);
        System.out.println(num);
    }
}
</code></pre>

<p>The output of that program is:</p>

<pre><code>33751521821438561184518523159...8915707117567
</code></pre>
","564","<java><diffie-hellman>","-1","12","2","2015-01-13 03:47:41","27914482","5","","1397215","","2015-01-13 03:34:19","2015-01-13 03:29:00",""
"27914464","Storing very large numbers in Java","<p>I'd like to store a long integer in Java, specifically the 6144-bit MODP Group (Group 17) from RFC 3526. However this number does not seem to fit to a BigInteger. Is there a way to use this prime number in Java?</p>

<p>EDIT: I tried</p>

<pre><code>BigInteger p = new BigInteger(Integer.toString(pValue));
p = 33751521821438561184518523159967412330064897805741846548173890474429429901326672445203235101919165483964194359460994881062089387893762814044257438204432573941083014827006090258925875161018096327732335800595831915976014208822304007327848132734933297885803213675261564962603340457220776826322500058091310967253976619973988033663666385188155212656268079501726223369693427999804134467810120772356498596945532366527400517575471969335854905274504119509592366013711954148258884879224599915203456315881034776553083676995718335598586395591169999570824515035017543533352697525287753332500527176569576894926734950469293596134095086603716860086302051544539652689091299099784588919052383463057789440565460681441902442399956419060521629604697347879024654313800186078316526964529288062740879011035175920059192178561473199006205896719435014765345518490882366607110905303449152556221163232127426440691921134648766635695850239231304591744215610985029636895406718880766308249227315984267542266259489684372223916445411015900506239419267909716320331208988978180868987431623710347617992356201449023892203230133009421463914291201346063125219636964261683591541014344239275340735690997732222069758773963390876360546515755280517042160525487302898122311669799679447530453600399342697032714458549591285939453949034981248114322322367238645042515984447890788917823576330019151696568654314153058547592091366014550143819685170068343700104677609041166369760080933413605498962382077778845599834907475953430787446201384567328530675275792962354883770806900827183685718353469574731680520621944540947734619035177180057973022652571032196598229259194875709994709721793154158686515748507274224181316948797104601068212015232921691482496346854413698719750190601102705274481050543239815130686073601076304512284549218459846046082253596762433827419060089029417044871218316020923109988915707117567;
</code></pre>
","<p>Use the <a href=""http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#BigInteger-java.lang.String-""><code>BigInteger(String val)</code></a> constructor to create the number, that is: pass the number as a <code>String</code>. The <code>BigInteger</code> class implements an arbitrary-precision integer data type, any integer can fit - as long as there's enough physical memory to represent it:</p>

<pre><code>BigInteger p = new BigInteger(""33751521821438561184518523159967412330064897805741846548173890474429429901326672445203235101919165483964194359460994881062089387893762814044257438204432573941083014827006090258925875161018096327732335800595831915976014208822304007327848132734933297885803213675261564962603340457220776826322500058091310967253976619973988033663666385188155212656268079501726223369693427999804134467810120772356498596945532366527400517575471969335854905274504119509592366013711954148258884879224599915203456315881034776553083676995718335598586395591169999570824515035017543533352697525287753332500527176569576894926734950469293596134095086603716860086302051544539652689091299099784588919052383463057789440565460681441902442399956419060521629604697347879024654313800186078316526964529288062740879011035175920059192178561473199006205896719435014765345518490882366607110905303449152556221163232127426440691921134648766635695850239231304591744215610985029636895406718880766308249227315984267542266259489684372223916445411015900506239419267909716320331208988978180868987431623710347617992356201449023892203230133009421463914291201346063125219636964261683591541014344239275340735690997732222069758773963390876360546515755280517042160525487302898122311669799679447530453600399342697032714458549591285939453949034981248114322322367238645042515984447890788917823576330019151696568654314153058547592091366014550143819685170068343700104677609041166369760080933413605498962382077778845599834907475953430787446201384567328530675275792962354883770806900827183685718353469574731680520621944540947734619035177180057973022652571032196598229259194875709994709721793154158686515748507274224181316948797104601068212015232921691482496346854413698719750190601102705274481050543239815130686073601076304512284549218459846046082253596762433827419060089029417044871218316020923109988915707117567"");
</code></pre>
","564","<java><diffie-hellman>","-1","12","2","2015-01-13 03:47:41","27914482","5","","1397215","","2015-01-13 03:34:19","2015-01-13 03:29:00",""
"48783559","Diffie-Hellman key exchange between Crypto++ and Python","<p>Consider the Diffie-Hellman key exchange between client and server, where the client application is written in c++ and the back-end is written in python.
The client application uses <a href=""https://cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++</a> lib for crypto stuff and Python uses <a href=""https://cryptography.io"" rel=""nofollow noreferrer"">cryptography</a>.</p>

<p>Here client application part where private and public key generate </p>

<pre><code>//domain parameters
OID CURVE = secp256k1();
AutoSeededX917RNG&lt;AES&gt; rng;
ECDH &lt; ECP &gt;::Domain dhA(CURVE);

// application private and publik key
SecByteBlock privA(dhA.PrivateKeyLength()), pubA(dhA.PublicKeyLength());
std::string privB64(R""(P3VfVpnSYcKQWX+6EZOly2XKy6no4UAB0cQhjBfyBD4=)"");
privA.Assign(reinterpret_cast&lt;const byte*&gt;(FromB64(privB64).c_str()), dhA.PrivateKeyLength());
dhA.GeneratePublicKey(rng, privA, pubA);

// serializa public key into integer
Integer intPub;
intPub.Decode(pubA.BytePtr(), pubA.SizeInBytes());
std::string ret;
intPub.DEREncode(CryptoPP::StringSink(ret));
std::cout &lt;&lt; ToB64(ret);// the output is loaded into python
</code></pre>

<p>Now the question is that I don't know how to deserialize the public key into python <a href=""https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey"" rel=""nofollow noreferrer"">EllipticCurvePublicKey</a>. When I use <a href=""https://cryptography.io/en/latest/hazmat/primitives/asymmetric/serialization/#cryptography.hazmat.primitives.serialization.load_der_public_key"" rel=""nofollow noreferrer"">cryptography.hazmat.primitives.serialization.load_der_public_key()</a>
I'm getting </p>

<pre><code>ValueError: Could not deserialize key data
</code></pre>

<p>Does anyone try to implement Diffie-Hellman key exchange between Crypto++ and Python using those two libraries?</p>
","<p>The issue was when serialized data in some way was transferred to backend how to recover it with Python <code>EllipticCurvePublicKey</code> type interface. Even if I decide to use protobuf the same question would arise.</p>

<p>But now I found the solution I'll put it here if anyone also will encounter this issue.</p>

<p>As I find out there is no interface to directly load Python <code>EllipticCurvePublicKey</code> object from Crypto++ <code>SecByteBlock</code> serialized object (which is representing the Diffie-Hellman public key in this scope).</p>

<p>To do this we need to convert public key into elliptic curve point and the serialize each coordinate of point (which is a big integer) in the way as you can see in this code snipped:</p>

<pre class=""lang-cxx prettyprint-override""><code>CryptoPP::DL_GroupParameters_EC&lt;ECP&gt; params(CURVE);    
CryptoPP::ECPPoint p = params.DecodeElement(pubA.BytePtr(), true);
std::cout &lt;&lt; CryptoPP::IntToString(p.x) &lt;&lt; std::endl;// this will be send to backend
std::cout &lt;&lt; CryptoPP::IntToString(p.y) &lt;&lt;std::endl;
</code></pre>

<p>To recover the two integers (x and y coordinates of the point) in the Python code as a DH public key you need to do the following </p>

<pre class=""lang-python prettyprint-override""><code># assuming that the x and y values are from client side 
x = 109064308162845536717682288676453496629093274218806834681903624047410153913758
y = 63162707562199639283552673289102028849183508196715869820627148926667819088660
peer_public_key =cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers(x, y, ec.SECP256K1()).public_key(default_backend())
</code></pre>
","533","<python><c++><crypto++><diffie-hellman><python-cryptography>","2","2","1","2018-02-17 15:21:42","48807366","0","","608639","","2018-02-15 00:51:42","2018-02-14 09:23:10",""
"51305689","Dart - secret key generation based on elliptic curve 25519","<p>I am looking for a dart package in order to implement key exchange protocol (Elliptic-curve Diffie–Hellman) in a Flutter application. So the flow will be like this:</p>

<ul>
<li>app generates a key pair during login and sends the public key to
server (so a new key pair is generated for every login)</li>
<li>server sends back its public key that it just generated</li>
<li>app generates a secret key from its private key and server's public
key</li>
<li>app includes the hmac of all subsequent messages sent to the server</li>
</ul>

<p>I tried using the <a href=""https://pub.dartlang.org/packages/ed25519_dart"" rel=""nofollow noreferrer"">ed25519_dart package</a> for the key generation, but it doesn't work. My app doesn't even start due to <code>integer literal can't be represented in 64 bits</code> error, which is also pointed out by the dart analyzer.</p>

<p>I also took a look at <a href=""https://pub.dartlang.org/packages/pointycastle"" rel=""nofollow noreferrer"">pointycastle</a>, but it doesn't seem to support Diffie–Hellman. </p>

<p>The <a href=""https://pub.dartlang.org/packages/dh"" rel=""nofollow noreferrer"">Diffie–Hellman package</a> also doesn't work for me. Provided example throws this exception in the first line: </p>

<pre><code>FormatException: Invalid radix-16 number
FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B1...
</code></pre>

<p>Any idea how I could achieve what I want to do in a Flutter application?</p>
","<p>The error I am assuming is connected to BigNum and Dart 2. Pointy Castle has a branch on GitHub where they are switching to Dart 2.0. </p>

<p>Here are some ways you could get a keypair:</p>

<ul>
<li>Use a native SDK (Java, Kotlin, or C++) and use a platform channel</li>
<li>Use the pointy castle Dart 2.0 branch</li>
<li>Try flutter_sodium package. It works with Dart 2 but is a work in progress.</li>
</ul>

<p>Hopefully, this helps. I am trying to figure out the best way as well!</p>
","519","<dart><flutter><diffie-hellman><ed25519>","0","0","1","2019-09-07 12:25:20","","5","","5277240","","2018-07-12 12:28:17","2018-07-12 12:26:50",""
"37562264","How does Elliptic Curve Diffie Hellman work on JavaCard, in combination with Java?","<p>I'm trying to get Elliptic Curve Diffie Hellman to work on a JavaCard (version 2.2.1).</p>

<p>On the JavaCard, I have the following code right now:</p>

<pre><code>byte temp[] = new byte[100];
byte secret[] = new byte[100];
byte size = buf[ISO7816.OFFSET_LC];

Util.arrayCopy(buf, ISO7816.OFFSET_CDATA, temp, (byte) 0, size);

// the public key is in temp
short len = dh.generateSecret(temp, (byte) 0, size, secret, (byte) 0);

Util.arrayCopy(temp, (byte) 0, buf, ISO7816.OFFSET_CDATA, size);
//Util.arrayCopy(secret, (byte) 0, buf, ISO7816.OFFSET_CDATA, len);
apdu.setOutgoingAndSend(ISO7816.OFFSET_CDATA, size);
</code></pre>

<p>And I initialize <code>dh</code> as follows:</p>

<pre><code>keyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_F2M_163);
keyPair.genKeyPair();
dh = KeyAgreement.getInstance(KeyAgreement.ALG_EC_SVDP_DH, false);
dh.init(keyPair.getPrivate());
</code></pre>

<p>All of this seems to work, except for the <code>dh.generateSecret</code> call, where the applet simply seems to crash. If I leave the call out, and return other data, that works nicely. In which I import the data that is sent by the terminal. In the terminal, I have the following:</p>

<pre><code>// generate an ecdh keypair
KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
keyGen.initialize(163);
KeyPair keyPair = keyGen.generateKeyPair();

// initialize DH
KeyAgreement dh = KeyAgreement.getInstance(""ECDH"");
dh.init(keyPair.getPrivate());

//byte encKey[] = keyPair.getPublic().getEncoded();

// X9.62 encoding, no compression
int qLength = (163+7)/8;
byte[] xArr = ((ECPublicKey) keyPair.getPublic()).getW().getAffineX().toByteArray();
byte[] yArr = ((ECPublicKey) keyPair.getPublic()).getW().getAffineY().toByteArray();
byte[] enc2 = new byte[1+2*qLength];
enc2[0] = (byte) 0x04;
System.arraycopy(xArr, 0, enc2, qLength - xArr.length, xArr.length);
System.arraycopy(yArr, 0, enc2, 2* qLength - yArr.length, yArr.length);

byte res[] =send((byte) 0x00, enc2).getData();
</code></pre>

<p>I have tried several things. Right now, the code that sends the public key tries to encode it in X9.62 encoding (uncompressed) as specified by the JavaCard docs. However, I've also tried the default <code>encode</code> method, which gives exactly the same result.</p>

<p>I don't seem to be able to get any error out of the JavaCard about what is going wrong. Does anyone know what is going wrong? Or does anyone have a working example on how to do a key-exchange on a JavaCard?</p>
","<p>As vojta already indicated:</p>

<pre><code>keyPair = new KeyPair(KeyPair.ALG_EC_FP, KeyBuilder.LENGTH_EC_F2M_163);
</code></pre>

<p>just tries to generate a key pair, and it probably works up to a point. But an Fp curve is different from a F2m curve, and to my knowledge there are no 163 bit Fp curves (to my knowledge anyway).</p>

<p>This means that you never actually installed the domain parameters, unless you generated your own, and I would call that unlikely.</p>

<p>Use a Fp curve with a known key length and set the parameters, at least for the public key (for JCOP cards you may have to set them for the private key as well). You'd normally use a 224 bit key size or higher to be secure.</p>
","518","<java><javacard><elliptic-curve><diffie-hellman>","4","0","1","2016-08-20 22:28:02","","2","1","","","","2016-06-01 07:35:51",""
"46052701","How to use Crypto++ to perfom DH key exchange (CryptoPP::DH::Agree returns false)","<p>I'm trying to use Crypto++ to perform Diffie-Hellman key exchange. I have written a simple program to check if this is working. As you can guess, it is not.</p>

<p>This program was written based on wiki article: <a href=""https://www.cryptopp.com/wiki/Diffie-Hellman"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/Diffie-Hellman</a> It is generating public and private keys and then uses them to cal function <code>CryptoPP::DH::Agree</code>. It was working when I was using the same pair of keys for both sides like it is on the wiki. This does not have much practical sense though. However, when I trying to use different keys, <code>CryptoPP::DH::Agree</code> returns <code>false</code>.</p>

<p>I suspect that I'm doing something incorrectly but I have no idea what.</p>

<pre class=""lang-c++ prettyprint-override""><code>#include &lt;crypto++/cryptlib.h&gt;
#include &lt;crypto++/dh.h&gt;
#include &lt;cryptopp/dh2.h&gt;
#include &lt;crypto++/osrng.h&gt;
#include &lt;crypto++/integer.h&gt;
#include &lt;crypto++/nbtheory.h&gt;
#include &lt;iostream&gt;


static CryptoPP::AutoSeededRandomPool rnd;
static CryptoPP::DH dhA, dhB;
static CryptoPP::SecByteBlock privKeyA, pubKeyA, privKeyB, pubKeyB;


static void createDomainParameters(CryptoPP::DH &amp;dh)
{
    CryptoPP::PrimeAndGenerator pg;
    pg.Generate(1, rnd, 512, 511);
    const CryptoPP::Integer p = pg.Prime();
    const CryptoPP::Integer q = pg.SubPrime();
    const CryptoPP::Integer g = pg.Generator();

    std::cout &lt;&lt; ""P: "" &lt;&lt; p &lt;&lt; '\n';
    std::cout &lt;&lt; ""Q: "" &lt;&lt; q &lt;&lt; '\n';
    std::cout &lt;&lt; ""G: "" &lt;&lt; g &lt;&lt; '\n';

    dh = CryptoPP::DH(p, q, g);
}

static void createAsymetricKey(const CryptoPP::DH &amp;dh, CryptoPP::SecByteBlock &amp;privKey, CryptoPP::SecByteBlock &amp;pubKey)
{
    privKey = CryptoPP::SecByteBlock(dh.PrivateKeyLength());
    pubKey = CryptoPP::SecByteBlock(dh.PublicKeyLength());
    dh.GenerateKeyPair(rnd, privKey, pubKey);

    CryptoPP::Integer a, b;

    a.Decode(privKey.BytePtr(), privKey.SizeInBytes());
    std::cout &lt;&lt; ""privKey: "" &lt;&lt; a &lt;&lt; std::endl;

    b.Decode(pubKey.BytePtr(), pubKey.SizeInBytes());
    std::cout &lt;&lt; ""pubKey:  "" &lt;&lt; b &lt;&lt; std::endl;
}

static void createSymetricKey(const CryptoPP::DH &amp;dh, const CryptoPP::SecByteBlock &amp;privKey, const CryptoPP::SecByteBlock &amp;pubKey)
{
    CryptoPP::SecByteBlock shared(dh.AgreedValueLength());
    if(!dh.Agree(shared, privKey, pubKey))
        throw std::runtime_error(""Failed to reach shared secret"");

    CryptoPP::Integer x;
    x.Decode(shared.BytePtr(), shared.SizeInBytes());
    std::cout &lt;&lt; ""shared: "" &lt;&lt; x &lt;&lt; std::endl;
}

int main()
{
    std::cout &lt;&lt; std::hex;

    createDomainParameters(dhA);
    std::cout &lt;&lt; std::endl;
    createDomainParameters(dhB);

    std::cout &lt;&lt; ""\n------------------------------\n"" &lt;&lt; std::endl;
    createAsymetricKey(dhA, privKeyA, pubKeyA);
    std::cout &lt;&lt; std::endl;
    createAsymetricKey(dhB, privKeyB, pubKeyB);

    if(dhA.AgreedValueLength() != dhB.AgreedValueLength())
        throw std::runtime_error(""Shared secret size mismatch"");

    std::cout &lt;&lt; ""\n------------------------------\n"" &lt;&lt; std::endl;
    createSymetricKey(dhA, privKeyA, pubKeyB);
    std::cout &lt;&lt; std::endl;
    createSymetricKey(dhB, privKeyB, pubKeyA);

    return 0;
}
</code></pre>

<p>When you change calls of <code>createSymetricKey</code> so it uses key from the same pair, it works.</p>

<pre class=""lang-c++ prettyprint-override""><code>createSymetricKey(dhA, privKeyA, pubKeyA);
std::cout &lt;&lt; std::endl;
createSymetricKey(dhB, privKeyB, pubKeyB);
</code></pre>

<p>AFAIK this has no sense though. What is the correct way to use <code>CryptoPP::DH::Agree</code>?</p>
","","502","<crypto++><diffie-hellman>","1","","0","2017-09-05 10:25:05","","3","1","","","","2017-09-05 10:25:05",""
"22410765","How to Format OpenSSL Keys to Match Online Sample (JSBN-ECC)","<p>I want to be able to format the public key of Elliptic Curve Diffie-Hellman in OpenSSL - Ruby into something like this online example <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/ecdh.html"" rel=""nofollow"">(link)</a>, as I have been using that JS library.</p>

<p>My code below generates an OpenSSL::PKey::EC public and private keys</p>

<pre><code>#Ruby
ec = OpenSSL::PKey::EC.new('secp128r1')
ec.generate_key

ec.private_key
#--&gt; 205607153615223513963863936713567041725

ec.public_key.to_bn
#--&gt; 499599043529551953518354858381998373780459818901085313561109939106744612770290
</code></pre>

<p>Try copying the private key above <code>205607153615223513963863936713567041725</code> and pasting it on the online <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/ecdh.html"" rel=""nofollow"">(link)</a> as Alices' Private value. But click the <code>secp1284r1</code> button first to have same curve parameters, and then click <code>Compute Public</code> button.</p>

<p>That will generate a public key from the inputted private key. However, the Ruby OpenSSL documentation isn't really helpful, and I am stuck on figuring out how to convert the generated public key above:</p>

<pre><code>499599043529551953518354858381998373780459818901085313561109939106744612770290
</code></pre>

<p>Into something like this (as seen from the online site):</p>

<pre><code>x: 107060165679262225845922473865530329196
y: 109296969851421346147544217212275741170
</code></pre>

<p>I've assumed that by properly converting one, it can somehow become equal to the other since they have same curve parameters. Or am I wrong? (And also because the default format of <code>point_conversion_form</code> is <code>:uncompressed</code>, as I just have tested) Please help.</p>

<p>P.S. You might wonder why I need to convert the public key into the other. No, I don't really have to. I just want to learn how to convert it as I'll be using that method to convert something similar. And this is the simplified question for your testing-convenience.</p>
","<pre><code>ec.public_key.to_bn
#--&gt; 499599043529551953518354858381998373780459818901085313561109939106744612770290
</code></pre>

<p>It would probably be better to print that in hex.</p>

<p>The public key is a point on the curve. That is, its an <code>(x,y)</code> coordinate. So that value probably needs to be split (hence the reason for printing in hex). Taking a guess:</p>

<pre><code>x = 499599043529551953518354858381998373780
y = 459818901085313561109939106744612770290
</code></pre>

<p>The public key is a point because its derived from the base point <code>G</code>, which is also a point. <code>G</code> is sometimes expanded as <code>(g_x, g_y)</code>. The private exponent is <code>a</code> (or <code>b</code>), which is a scalar or integer. So the public key is <code>A=G^a</code> or <code>A=(g_x, g_y)^a</code>, which is a point.</p>

<hr>

<blockquote>
  <p>And also because the default format of point_conversion_form is :uncompressed, as I just have tested</p>
</blockquote>

<p>Point conversion/compression is just a presentation layer optimization trick. It omits the <code>y</code> portion of the coordinate because you can solve for it given <code>x</code>. Because its a curve, sometimes you need to send <code>+1</code> or <code>-1</code> to specify the quadrant the <code>y</code> coordinate lies in. But again, its just an optimization and only matters for interop'ing. After you read the point into a library, both <code>x</code> and <code>y</code> are available.</p>

<hr>

<blockquote>
  <p>You might wonder why I need to convert the public key into the other...</p>
</blockquote>

<p>Nope :)</p>

<p>But one thing you might want to be aware of is OpenSSL's ""named curve"" flag. If you want to load an <code>EC</code> key into an OpenSSL based server, you will want to ensure the private key and resulting certificate have the <code>OPENSSL_EC_NAMED_CURVE</code> flag. Otherwise, you'll get bizarre errors like ""no shared ciphers"" when trying to connect to the server. See <a href=""http://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman#ECDH_and_Named_Curves"" rel=""nofollow"">ECDH and Named Curves</a> on the OpenSSL wiki for details.</p>
","489","<javascript><ruby><openssl><elliptic-curve><diffie-hellman>","2","0","3","2015-01-04 04:48:09","22436799","0","","3073313","","2014-03-14 16:41:18","2014-03-14 16:31:17",""
"22410765","How to Format OpenSSL Keys to Match Online Sample (JSBN-ECC)","<p>I want to be able to format the public key of Elliptic Curve Diffie-Hellman in OpenSSL - Ruby into something like this online example <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/ecdh.html"" rel=""nofollow"">(link)</a>, as I have been using that JS library.</p>

<p>My code below generates an OpenSSL::PKey::EC public and private keys</p>

<pre><code>#Ruby
ec = OpenSSL::PKey::EC.new('secp128r1')
ec.generate_key

ec.private_key
#--&gt; 205607153615223513963863936713567041725

ec.public_key.to_bn
#--&gt; 499599043529551953518354858381998373780459818901085313561109939106744612770290
</code></pre>

<p>Try copying the private key above <code>205607153615223513963863936713567041725</code> and pasting it on the online <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/ecdh.html"" rel=""nofollow"">(link)</a> as Alices' Private value. But click the <code>secp1284r1</code> button first to have same curve parameters, and then click <code>Compute Public</code> button.</p>

<p>That will generate a public key from the inputted private key. However, the Ruby OpenSSL documentation isn't really helpful, and I am stuck on figuring out how to convert the generated public key above:</p>

<pre><code>499599043529551953518354858381998373780459818901085313561109939106744612770290
</code></pre>

<p>Into something like this (as seen from the online site):</p>

<pre><code>x: 107060165679262225845922473865530329196
y: 109296969851421346147544217212275741170
</code></pre>

<p>I've assumed that by properly converting one, it can somehow become equal to the other since they have same curve parameters. Or am I wrong? (And also because the default format of <code>point_conversion_form</code> is <code>:uncompressed</code>, as I just have tested) Please help.</p>

<p>P.S. You might wonder why I need to convert the public key into the other. No, I don't really have to. I just want to learn how to convert it as I'll be using that method to convert something similar. And this is the simplified question for your testing-convenience.</p>
","<p>Finally! I somehow managed to convert it properly but it's somehow weird.</p>

<pre><code>#From above code
c.public_key.to_bn
#--&gt; 499599043529551953518354858381998373780459818901085313561109939106744612770290

#irb:
require 'openssl'

key_int = '499599043529551953518354858381998373780459818901085313561109939106744612770290'
key_bn = OpenSSL::BN.new(key_int, 10) #Convert to OpenSSL::BN (Big Number, with 10=Decimal as base)
key_hex = key_bn.to_s(16) #Convert to Hex String (16=Hexadecimal)
#--&gt; ""04508B09B35FA8C21820BE19C16B38486C5239D4A932D081DD56B90F91120551F2""

#I don't really know why, but removing '04' above will finally convert it properly
key_hex = key_hex[2..-1] #Remove first 2 chars: '04'
#--&gt; ""508B09B35FA8C21820BE19C16B38486C5239D4A932D081DD56B90F91120551F2""

#Split key_hex into halves
key_hexarr = key_hex.chars.each_slice( (key_hex.length/2.0).round ).map(&amp;:join)
#--&gt; [""508B09B35FA8C21820BE19C16B38486C"", ""5239D4A932D081DD56B90F91120551F2""]

#Convert first value into BN (input: 16=hexadecimal), then convert to string(output: 10=decimal)
key_x_int = OpenSSL::BN.new(key_hexarr[0], 16).to_s(10)
#--&gt; ""107060165679262225845922473865530329196""

#Convert second value into BN (input: 16=hexadecimal), then convert to string(output: 10=decimal)
key_y_int = OpenSSL::BN.new(key_hexarr[1], 16).to_s(10)
#--&gt; ""109296969851421346147544217212275741170""
</code></pre>

<p>Finally, <code>key_x_int</code> and <code>key_y_int</code> now matches the result from the online link</p>
","489","<javascript><ruby><openssl><elliptic-curve><diffie-hellman>","2","0","3","2015-01-04 04:48:09","22436799","0","","3073313","","2014-03-14 16:41:18","2014-03-14 16:31:17",""
"22410765","How to Format OpenSSL Keys to Match Online Sample (JSBN-ECC)","<p>I want to be able to format the public key of Elliptic Curve Diffie-Hellman in OpenSSL - Ruby into something like this online example <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/ecdh.html"" rel=""nofollow"">(link)</a>, as I have been using that JS library.</p>

<p>My code below generates an OpenSSL::PKey::EC public and private keys</p>

<pre><code>#Ruby
ec = OpenSSL::PKey::EC.new('secp128r1')
ec.generate_key

ec.private_key
#--&gt; 205607153615223513963863936713567041725

ec.public_key.to_bn
#--&gt; 499599043529551953518354858381998373780459818901085313561109939106744612770290
</code></pre>

<p>Try copying the private key above <code>205607153615223513963863936713567041725</code> and pasting it on the online <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/ecdh.html"" rel=""nofollow"">(link)</a> as Alices' Private value. But click the <code>secp1284r1</code> button first to have same curve parameters, and then click <code>Compute Public</code> button.</p>

<p>That will generate a public key from the inputted private key. However, the Ruby OpenSSL documentation isn't really helpful, and I am stuck on figuring out how to convert the generated public key above:</p>

<pre><code>499599043529551953518354858381998373780459818901085313561109939106744612770290
</code></pre>

<p>Into something like this (as seen from the online site):</p>

<pre><code>x: 107060165679262225845922473865530329196
y: 109296969851421346147544217212275741170
</code></pre>

<p>I've assumed that by properly converting one, it can somehow become equal to the other since they have same curve parameters. Or am I wrong? (And also because the default format of <code>point_conversion_form</code> is <code>:uncompressed</code>, as I just have tested) Please help.</p>

<p>P.S. You might wonder why I need to convert the public key into the other. No, I don't really have to. I just want to learn how to convert it as I'll be using that method to convert something similar. And this is the simplified question for your testing-convenience.</p>
","<p>Jay-Ar, </p>

<p>You shouldn't find your solution weird as I think the call to <strong>ec.public_key.to_bn</strong> might be adhering to <a href=""https://www.ietf.org/rfc/rfc5480.txt"" rel=""nofollow"">rfc5480 section 2.2</a> re: <strong>Subject Public Keys</strong> which states:</p>

<blockquote>
  <p>2.2.  Subject Public Key</p>
  
  <ul>
  <li>The first octet of the OCTET STRING indicates whether the key is
      compressed or uncompressed.  The uncompressed form is indicated
      by 0x04 and the compressed form is indicated by either 0x02 or
      0x03 (see 2.3.3 in [SEC1]).  The public key MUST be rejected if
      any other value is included in the first octet.</li>
  </ul>
</blockquote>

<p>Assuming this is the case and since you stated the format is <strong>:uncompressed</strong>, your own answer makes total sense to me.  Thanks for posting it! :) </p>
","489","<javascript><ruby><openssl><elliptic-curve><diffie-hellman>","2","2","3","2015-01-04 04:48:09","22436799","0","","3073313","","2014-03-14 16:41:18","2014-03-14 16:31:17",""
"55247051","Python: ValueError: invalid literal for int() with base 10:'\x00","<p>I am making a client-server program implementing the Diffie-Hellman algorithm</p>

<p>Client:</p>

<pre><code>from __future__ import print_function
import math
import socket

host = ""localhost""
port = 1200
s = socket.socket(socket.AF_INET,   socket.SOCK_STREAM)
s.connect((host, port))

print(""Connected with Server"")

sharedPrime = 23    # p
sharedBase = 5      # g

aliceSecret = 6     # a

s.send(bytes(aliceSecret))
bobSecret=s.recv(1024)

# Alice Sends Bob A = g^a mod p
A = (sharedBase**aliceSecret) % sharedPrime

s.send(bytes(A))
B=s.recv(1024)

B=B.decode()
# Alice Computes Shared Secret: s = B^a mod p
aliceSharedSecret = (int(B)** aliceSecret) % sharedPrime
print( ""Alice Shared Secret: "", aliceSharedSecret )
</code></pre>

<p>The server code is basically the same, except it handles ""Bob's"" side of the algorithm. My problem starts at this line:</p>

<pre><code>aliceSharedSecret = (int(B)** aliceSecret) % sharedPrime
</code></pre>

<p>Which gives me this error:</p>

<pre><code>invalid literal for int() with base 10: '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
</code></pre>

<p>I've gone back to see what ""B"" actually is and it's just blank. What am I doing wrong?</p>
","<p>Look at this line:</p>

<pre><code>s.send(bytes(aliceSecret))
</code></pre>

<p>You convert <code>int</code> value to <code>bytes</code> here. This produces result like <code>b'\x00\x00\x00\x00\x00\x00'</code> that later cannot be directly casted to <code>int</code> even after decoding because it's not number in decimal form. There are 2 possible solutions:</p>

<p>1) Properly decode value, this line will interpret <code>bytes</code> object as <code>int</code> splitted into bytes:</p>

<pre><code>B = int.from_bytes(B, byteorder='big', signed=False)  # instead of B = B.decode()
</code></pre>

<p>2) Convert your original <code>int</code> value to <code>str</code> before converting to <code>bytes</code> so back convertation will work</p>
","488","<python-3.x><client-server><diffie-hellman>","0","0","1","2019-03-19 18:16:27","","1","","","","","2019-03-19 17:43:47",""
"43236522","Convert P-256 DH java string to java PublicKey","<p>I'm trying to send web push notifications to my browser and am able to subscribe successfully. I get a subscription object with ""an elliptic curve Diffie–Hellman public key on P-256 curve"".</p>

<p>I want to convert this string to a public key in Java but keep getting a invalid key format exception.</p>

<p>Here's the code that I'm trying:</p>

<pre><code>  String publicK = ""BBoN_OkTfE_0uObues82qHr96z8x3nepYoUwCBoftFDS_Vgx2MUHN1vAFxc1eDiyDrvmZ2bQ4sJq3F8Qz71RWI0="";
  byte[] publicBytes = publicK.getBytes();
  X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicBytes);
  KeyFactory keyFactory = KeyFactory.getInstance(""DiffieHellman"");
  PublicKey pubKey = keyFactory.generatePublic(keySpec);
</code></pre>

<p>Could someone help me with this please? Encryption noob here :/</p>
","<p>For my code, I used <strong>java 1.7</strong> and <strong>BouncyCastle</strong> library. If you use maven, just add to your <strong>pom.xml</strong>:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcprov-jdk16&lt;/artifactId&gt;
    &lt;version&gt;1.46&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Or download the jars in <a href=""http://bouncycastle.org/latest_releases.html"" rel=""nofollow noreferrer"">BouncyCastle</a> site. This is a cryptography API for java, with lots of useful stuff (including classes to handle elliptic curves keys).</p>

<p>The code for reading the public key and converting to an object is:</p>

<pre class=""lang-java prettyprint-override""><code>import java.security.KeyFactory;
import java.security.Security;
import java.security.interfaces.ECPublicKey;
import java.security.spec.ECPoint;
import java.security.spec.ECPublicKeySpec;

import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.ECPointUtil;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;
import org.bouncycastle.jce.spec.ECNamedCurveSpec;
import org.bouncycastle.util.encoders.Base64;


// you need to add the BouncyCastle provider to use its functionalities
Security.addProvider(new BouncyCastleProvider());

String publicK = ""BBoN_OkTfE_0uObues82qHr96z8x3nepYoUwCBoftFDS_Vgx2MUHN1vAFxc1eDiyDrvmZ2bQ4sJq3F8Qz71RWI0="";
// publicK is encoded in base64, so you need to decode it first
byte[] publicBytes = Base64.decode(publicK.getBytes());

// spec for P-256 curve
ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(""prime256v1"");
// create a KeyFactory with ECDSA (Elliptic Curve Diffie-Hellman) algorithm and use BouncyCastle as the provider
KeyFactory kf = KeyFactory.getInstance(""ECDSA"", BouncyCastleProvider.PROVIDER_NAME);

// code below just creates the public key from the bytes contained in publicK
// using the curve parameters (spec variable)
ECNamedCurveSpec params = new ECNamedCurveSpec(""prime256v1"", spec.getCurve(), spec.getG(), spec.getN());
ECPoint point = ECPointUtil.decodePoint(params.getCurve(), publicBytes);
ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(point, params);
ECPublicKey pk = (ECPublicKey) kf.generatePublic(pubKeySpec);

System.out.println(pk.toString());
</code></pre>

<p>Output:</p>

<pre><code>EC Public Key
            X: 1a0d00e9137c4034b8e6ee7acf36a87afdeb3f31de77a9628530081a1fb450d2
            Y: 15831d8c507375bc01717357838b20ebbe66766d0e2c26adc5f10cfbd51588d
</code></pre>

<hr>

<p><strong>Notes</strong>:</p>

<ul>
<li><p>I'm not aware of all the math behind elliptic curve keys, just the basic idea. I know that a curve has parameters like <code>G</code> and <code>n</code> (which are obtained via <code>getG()</code> and <code>getN()</code> methods) and that there are some ""standard pre-defined"" curves (like P-256) that you can get using <code>ECNamedCurveTable.getParameterSpec()</code>.</p></li>
<li><p>You can take a look at all the <a href=""https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">math details</a> if you want. There is also a <a href=""https://safecurves.cr.yp.to/"" rel=""nofollow noreferrer"">list of different standard curves</a> and which ones are considered secure.</p></li>
<li><p><code>ECPublicKey</code> extends <code>PublicKey</code>, so you can use it just like a <code>PublicKey</code></p></li>
</ul>
","486","<java><diffie-hellman>","2","1","1","2017-04-05 19:15:34","43237307","0","","","","","2017-04-05 16:15:37",""
"47221029","weird result using EC_POINT_mul from OpenSSL","<p>I am trying to implement a Private Set Intersection (PSI) protocol that is based on the Diffie Hellman protocol.</p>

<p>The PSI protocol is the one mentioned in Section 2.2 of [<a href=""http://eprint.iacr.org/2017/670"" rel=""nofollow noreferrer"" title=""[1]Á. Kiss, J. Liu, T. Schneider, N. Asokan, and B. Pinkas, “Private Set Intersection for Unequal Set Sizes with Mobile Applications,” IACR Cryptology ePrint Archive, vol. 2017, p. 670, 2017."">Kiss et al. 2017</a>],,
there is already a Java implementation here:</p>

<p><a href=""https://github.com/encryptogroup/MobilePSI/blob/master/PSIServer/src/PSIDH.java"" rel=""nofollow noreferrer"">https://github.com/encryptogroup/MobilePSI/blob/master/PSIServer/src/PSIDH.java</a></p>

<p>I want to implement it in C++, so I thought of using OpenSSL</p>

<h1>What I am trying to do</h1>

<p>Here is roughly how it works:
let <code>G</code> be a generator for diffie hellman;
alice has a DH secret <code>a</code> and an element <code>x</code>,
bob has a DH secret <code>b</code> and an element <code>y</code>;
<code>h</code> is some function that takes any (bitstring) element and map it to an DH scalar.</p>

<ul>
<li>alice sends <code>G*a*h(x)</code> (call it <em>alice's side</em>)</li>
<li>bob replies with <code>(G*a*h(x))*b</code> (call it <em>final alice's side</em>)</li>
<li>bob sends <code>G*b*h(y)</code> (call it <em>bob's side</em>)</li>
<li>alice computes <code>(G*b*h(y))*a</code></li>
</ul>

<p>Alice then compares both final values to learn whether <code>x == y</code> or not.</p>

<h1>The code</h1>

<p>(minimal working example)</p>

<p>Using the fact that <code>G*a</code> is what is ""Alice's public key"" regarding Diffie-Hellman.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

#include &lt;openssl/obj_mac.h&gt;
#include &lt;openssl/ec.h&gt;

// list of possible curve names here:
// https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/objects/obj_mac.h;h=b5ea7cdab4f84b90280f0a3aae1478a8d715c7a7;hb=46ebd9e3bb623d3c15ef2203038956f3f7213620#l385
// also here:
// https://github.com/openssl/openssl/blob/67e247fad12308e34817e60c9242113c285fb00c/include/openssl/obj_mac.h#L261
#define CURVE_NAME NID_X9_62_prime256v1

class PSIEntity {
  public:
    BN_CTX* bn_ctx;
    const EC_GROUP* ec_group;
    EC_KEY* key;

    PSIEntity(BN_CTX* c, const EC_GROUP* g){
      bn_ctx = c;

      ec_group = g;
      key = EC_KEY_new();
      EC_KEY_set_group(key, ec_group);
      EC_KEY_generate_key(key);
    }

    EC_POINT* encode_and_mask(const unsigned char* x_data){
      BIGNUM* x = BN_bin2bn(x_data, 28, NULL);

      const EC_POINT* pubkey = EC_KEY_get0_public_key(key);
      EC_POINT* result = EC_POINT_dup(pubkey, ec_group);

      EC_POINT_mul(ec_group, result, x, NULL, NULL, bn_ctx);

      return result;
    }

    EC_POINT* mask(EC_POINT* p){
      EC_POINT* result = EC_POINT_dup(p, ec_group);
      const BIGNUM *priv_key = EC_KEY_get0_private_key(key);
      EC_POINT_mul(ec_group, result, priv_key, NULL, NULL, bn_ctx);

      return result;
    }
};



int main(){
  EC_GROUP *ec_group = EC_GROUP_new_by_curve_name(CURVE_NAME);
  BN_CTX *bn_ctx = BN_CTX_new();

  PSIEntity alice(bn_ctx, ec_group);
  PSIEntity bob(bn_ctx, ec_group);

  // taken from ""a_bin"" in
  // https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography#Defining_Curves
  unsigned char x_data[28] =
          {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
           0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,
           0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE};

  EC_POINT* alice_side = alice.encode_and_mask(x_data);
  EC_POINT* alice_side_final = bob.mask(alice_side);

  EC_POINT* bob_side = bob.encode_and_mask(x_data);
  EC_POINT* bob_side_final = alice.mask(bob_side);

  int final_points_are_different = EC_POINT_cmp(ec_group,
                                                alice_side_final, bob_side_final,
                                                bn_ctx);
  if(final_points_are_different==-1){
    std::cout &lt;&lt; ""comparison of final points failed"" &lt;&lt; std::endl;
  }else if(final_points_are_different==1){
    std::cout &lt;&lt; ""final points are different"" &lt;&lt; std::endl;
  }else if(final_points_are_different==0){
    std::cout &lt;&lt; ""final points are equal"" &lt;&lt; std::endl;
  }

  int temp_points_are_different = EC_POINT_cmp(ec_group,
                                                alice_side, bob_side,
                                                bn_ctx);
  if(temp_points_are_different==-1){
    std::cout &lt;&lt; ""comparison of temp points failed"" &lt;&lt; std::endl;
  }else if(temp_points_are_different==1){
    std::cout &lt;&lt; ""temp points are different"" &lt;&lt; std::endl;
  }else if(temp_points_are_different==0){
    std::cout &lt;&lt; ""temp points are equal"" &lt;&lt; std::endl;
  }
  return 0;
}
</code></pre>

<h1>Code Result and Problem</h1>

<p>The result is:</p>

<pre><code>final points are different
temp points are equal
</code></pre>

<p>I would expect the opposite:
final points should be equal because it's the same <code>x</code> on both sides</p>

<p>As to <em>""temp points are equal""</em>, this is very disturbing:
it means that we have <code>G*a*x == G*b*x</code> ?</p>

<p>If you compare <code>G*a</code> with <code>G*b</code> (the public keys) the answer is that they are different, so what seems to happen is that multiplication by <code>x</code> with <code>EC_POINT_mul</code> just ""messes things up"".</p>

<p>Any idea what is happening ?</p>
","<p>The following code should do the job. The problem is passing wrong parameters to <code>EC_POINT_mul()</code>. See <a href=""https://www.openssl.org/docs/man1.0.2/crypto/EC_POINT_mul.html"" rel=""nofollow noreferrer"">here</a> for documentation of <code>EC_POINT_mul()</code>.</p>

<pre><code>EC_POINT* encode_and_mask(const unsigned char* x_data){
    ...
    EC_POINT_mul(ec_group, result, NULL, result, x, bn_ctx);

    return result;
}

EC_POINT* mask(EC_POINT* p){
    ...
    EC_POINT_mul(ec_group, result, NULL, result, priv_key, bn_ctx);

    return result;
}
</code></pre>
","485","<c++><openssl><diffie-hellman>","0","1","1","2018-09-20 09:07:03","","0","","","","","2017-11-10 10:48:17",""
"51344351","Node.js crypto.publicEncrypt: 'Error: error:0906D06C:PEM routines:PEM_read_bio:no start line'","<p>I'm trying to use the public key encryption in crypto.js, I want to encrypt some message using <code>publicEncrypt</code>, and decrypt it with <code>privateDecrypt</code>.</p>

<pre><code>const crypto=require('crypto');
let alice=crypto.getDiffieHellman('modp14');
alice.generateKeys();
let enc=crypto.publicEncrypt(alice.getPublicKey(),Buffer.from('hello'));
</code></pre>

<p>However, the <code>crypto.publicEncrypt</code> line is causing the following error:
""Error: error:0906D06C:PEM routines:PEM_read_bio:no start line""</p>
","<p>The public key value returned by <code>crypto.DiffieHellman.getPublicKey()</code> is just the raw DH number, optionally encoded in base64 or hex. It is not in (any) PEM format or even ASN.1/DER format (which could easily be turned into PEM). Similarly <code>crypto.ECDH.getPublicKey()</code> is only the point (in conventional X9.62 format), not any PEM or DER format.</p>

<p>Moreover, DH and ECDH are not encryption algorithms, they are key-agreement (or secret-agreement) algorithms, and that operation is performed by <code>DiffieHellman.computeSecret()</code> or <code>ECDH.computeSecret()</code> respectively. Although not clearly documented, <code>publicEncrypt</code> actually calls OpenSSL's <code>EVP_PKEY_encrypt{_init,}</code> which doesn't support DH or ECDH, only RSA (with several choices of padding) and possibly GOST-wrap (I can't easily verify that and it may well be version dependent because upstream OpenSSL as of 1.1.0 a few years ago dropped the GOST algorithms).</p>

<p>In short, you can't do that.</p>
","481","<node.js><encryption><public-key-encryption><diffie-hellman>","0","1","1","2018-07-15 10:57:45","51347719","0","","10044403","","2018-07-15 00:21:04","2018-07-15 00:16:00",""
"46379624","C++ GMP random number generation for Diffie-Hellman Key Exchange","<p>I need to calculate a private key (privateKey) for Diffie-Hellman key exchange. I have given a big prime prime and now I just need to choose a number that is less than p. This is my code:</p>

<pre><code>        mpz_class privateKey;
        unsigned long seed;
        mpz_init(privateKey.get_mpz_t());

        gmp_randstate_t rstate;
        gmp_randinit_mt(rstate);
        gmp_randseed_ui(rstate, seed);

        mpz_urandomm(privateKey.get_mpz_t(), rstate, prime.get_mpz_t());
</code></pre>

<p>I don't really understand why I'm always getting the same ""random"" number. </p>
","<p>You never initialize the <code>seed</code> variable, so your program is obviously wrong and your compiler should have warned you about this. If it didn't, look up how to configure your compiler correctly (e.g. for GCC make sure you pass at least <code>-O -Wall</code>).</p>

<p>You'll always get the same random number if you initialize the RNG with the same seed. That's probably what's happening in your program: <code>seed</code> is not initialized, so its value is whatever was on the stack at this address previously, and that turns out to be always the same if you're calling this function in the same way.</p>

<p>Since this is a cryptographic application, you need to seed the random number generator with a high-entropy source. Ask your operating system for it (there's no way to generate entropy inside a program): read from <code>/dev/urandom</code> on Linux, call <code>CryptGenRandom</code> on Windows.</p>

<p>Also, since this is a cryptographic application, don't call <code>gmp_randinit_mt</code>. This creates a Mersenne twister, which is fast and good enough for a physics simulation, but not suitable for cryptography because its state can be reconstructed from its outputs. I'm not familiar with GMP, but looking at the <a href=""https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization"" rel=""nofollow noreferrer"">documentation</a>, I see that it offers several algorithms for random number generation but none are suitable for security applications. You can use the OS source like <code>/dev/urandom</code> or <code>CryptGenRandom</code> directly as a source of random bits, but then you'd need to use that to implement the <code>gmp_randstate_t</code> interface in order to hook it up with <code>mpz_urandomm</code>. I don't know how difficult that is.</p>

<p>If this is a school exercise, do whatever your teacher tells you. If this is for an actual application, use an existing cryptography library such as <a href=""http://www.libtom.net/"" rel=""nofollow noreferrer"">libtom</a>, which comes with all you need to generate cryptographic-quality random numbers and to perform the Diffie-Hellman computations, is very easy to integrate into a project, and has a license that allows it to be integrated into any project.</p>
","463","<c++><gmp><diffie-hellman>","2","2","1","2017-09-23 12:51:52","46379781","0","","","","","2017-09-23 12:34:08",""
"48118420","Server Side SSL using Diffie-Hellman in Python","<p>I'm trying to set up a socket using Diffie-Hellman SSL, but can't seem find any documentation on how to do this. I notice that SSLContext in Python 3.3+ supports load_dh_params and set_ecdh_curve which suggests that using DH is possible.</p>

<p>I'm fairly new to using SSL so perhaps missing something obvious, but here's the code I'm using:</p>

<pre><code>sock = socket.socket()
sock.bind((HOST, PORT))
sock.listen()
context = ssl.SSLContext(protocol=ssl.PROTOCOL_TLS)
context.set_ecdh_curve('prime256v1')
ssock, address = self._server.accept()
ssock= context.wrap_socket(ssock, server_side=True)
</code></pre>

<p>When using this code, I get the error:</p>

<p>ssl.SSLError: [SSL: NO_SHARED_CIPHER] no shared cipher</p>

<p>I've tried setting the ciphers like the following:</p>

<pre><code>context.set_ciphers('ECDHE-RSA-AES256-GCM-SHA384')
</code></pre>

<p>but all the ciphers I've tried still throw up the same exception.</p>

<p>If anyone could point out where I'm going wrong or provide a working example of using DH SSL, it'd be much appreciated!</p>
","<p>A TLS cipher defines the key exchange, the authentication method, the symmetric encryption algorithm and the HMAC. The authentication method in the cipher you explicitly try to use is RSA, i.e. using a certificate with an RSA public key. If you instead use the default cipher set the authentication methods are either RSA or ECDSA. </p>

<p>Both of these authentication methods need an appropriate certificate on the server side, i.e. with RSA or ECC public key. Since you have not configured any certificates these ciphers can not be used. This means in essence that from the ciphers the client has offered (which commonly also require certificate based authentication) none can be used for the connection, ergo NO_SHARED_CIPHER.</p>

<p>What you need to do: </p>

<ul>
<li>The recommended way is to setup a certificate on the server which is trusted by the client. See <a href=""https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_cert_chain"" rel=""nofollow noreferrer"">SSLContext.load_cert_chain</a>.</li>
<li>Or you could use ciphers which don't require authentication, for example <code>ADH-AES256-GCM-SHA384</code>. Note that you would need to explicitly configure the cipher in the client too since by default TLS stacks don't use ciphers without authentication for security reasons since man in the middle attacks will not be detected this way.</li>
</ul>
","455","<python><ssl><python-3.6><diffie-hellman>","0","0","1","2018-01-05 18:13:18","48119028","0","","","","","2018-01-05 17:25:07",""
"22483036","Why is the ECC-DH Symmetric Key Of This Site Different From OpenSSL","<p>I am using <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/ecdh.html"" rel=""nofollow"">(this site's)</a> Javascript library and OpenSSL Ruby to compute the symmetric key of Elliptic Curve Diffie Hellman. </p>

<p>However, from my results, OpenSSL Ruby only generated one key unlike that on the site which has X and Y symmetric keys. I am baffled as my OpenSSL symmetric key doesn't match either one of those x and y on the site.</p>

<p>The symmetric(shared secret) keys I got using <code>secp224r1</code> curve:</p>

<p>Ruby OpenSSL</p>

<pre><code>   13506351678569412185536677668115375188438201041599149052762191980775
</code></pre>

<p>Using Site's JS Library</p>

<pre><code>x: 26210366144026557327555572210249241206666031403062020900473236895358
y: 19676808255388748321882118528911150828003358302170965920476006073155
</code></pre>

<p>My questions are:</p>

<p>1) Why does OpenSSL Ruby yields only one key while that size yields two keys: x and y (as I've assumed x and y won't be concatenated with each other since the bitsize will be too long when compared to the Ruby symmetric key)</p>

<p>2) Is there a way to convert the two symmetric keys (OpenSSL and JSBN-EC library above) from one another? All my attempts to convert failed.</p>

<p>I've been struggling for a week now implementing Ruby OpenSSL with that JSBN-EC library. I've also tried <a href=""https://github.com/bitwiseshiftleft/sjcl"" rel=""nofollow"">(SJCL library)</a> but similar results (symmetric keys don't match). Please help.</p>
","<p>I've managed to work it out now with working symmetric keys on client (JSBN-EC) and on server OpenSSL Ruby</p>

<p>I found out that my problem actually lies in the code itself. After fixing it, I've ended up with a symmetric key on OpenSSL Ruby as follows:</p>

<pre><code>#Ruby: OpenSSL
...
...
symm_key = ec.dh_compute_key(point)
symm_key.unpack('B*').first.to_i(2) #Converts to binary, then to integer
#--&gt; 6922380353406615622038660570577625762884344085425862813095878420328
</code></pre>

<p>While on the client side using JSBN-EC</p>

<pre><code>#Javascript: JSBN-EC
...
...
var curve = get_curve();
var P = new ECPointFp(curve,
curve.fromBigInteger(server_pub_key_x),
curve.fromBigInteger(server_pub_key_y));
var a = client_priv_key;
var S = P.multiply(a);

console.log('SYMM_KEY X: '+S.getX().toBigInteger().toString());
//--&gt; 6922380353406615622038660570577625762884344085425862813095878420328
console.log('SYMM_KEY Y: '+S.getY().toBigInteger().toString());
//--&gt; 14426877769799867628378883482085635535383864283889042780773103726343
</code></pre>

<p>Therefore from the looks of it, the symmetric key that matches the Ruby OpenSSL value is the  X value of the JSBN-EC symmetric key</p>

<pre><code>6922380353406615622038660570577625762884344085425862813095878420328
==
6922380353406615622038660570577625762884344085425862813095878420328
</code></pre>

<p>I don't know what the Y value is now for. Looks like I won't need it. Cheers! :)</p>
","451","<javascript><ruby><openssl><elliptic-curve><diffie-hellman>","1","1","1","2014-03-19 15:31:21","22510720","0","2","3073313","","2014-03-18 15:03:57","2014-03-18 14:56:24",""
"39671926","openssl_dh_compute_key returns false","<p>I'm trying to compute the shared secret for ECDH (elliptic-curve Diffie Hellman) using PHP.</p>

<p>Assume I have someone's public key:</p>

<pre><code>$clientPublickey=""BOLcHOg4ajSHR6BjbSBeX_6aXjMu1V5RrUYXqyV_FqtQSd8RzdU1gkMv1DlRPDIUtFK6Nd16Jql0eSzyZh4V2uc"";
</code></pre>

<p>I generate my keys using openssl:</p>

<pre><code>exec('openssl ecparam -genkey -name prime256v1 -noout -out example-ecc.pem');
$private = openssl_pkey_get_private(""file://example-ecc.pem"");
</code></pre>

<p>Then I call:</p>

<pre><code>$sharedSecret=openssl_dh_compute_key(base64_decode($clientPublickey), $private);
</code></pre>

<p>... and I get false.
Calling openssl_error_string() returns nothing, no error.</p>

<p>I've var_dumped openssl_pkey_get_details($private) and verified it was created properly.</p>

<p>Any advice anyone? There doesn't seem to be much info on this function.
<a href=""http://php.net/manual/en/function.openssl-dh-compute-key.php"" rel=""nofollow"">http://php.net/manual/en/function.openssl-dh-compute-key.php</a></p>
","<p><a href=""https://www.openssl.org/docs/manmaster/crypto/DH_compute_key.html"" rel=""nofollow"">https://www.openssl.org/docs/manmaster/crypto/DH_compute_key.html</a> describes that function as being for (non-EC) Diffie Hellman.  You would need <code>ECDH_compute_key</code> (which I don't know if PHP exposes).</p>

<p>Though <a href=""https://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman"" rel=""nofollow"">https://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman</a> recommends using the EVP_PKEY wrappers instead of the low level routines. But, again, I can't say what support PHP has.</p>
","447","<php><diffie-hellman><php-openssl>","0","1","2","2019-06-29 15:45:29","","1","","608639","","2016-09-24 03:56:11","2016-09-24 02:31:58",""
"39671926","openssl_dh_compute_key returns false","<p>I'm trying to compute the shared secret for ECDH (elliptic-curve Diffie Hellman) using PHP.</p>

<p>Assume I have someone's public key:</p>

<pre><code>$clientPublickey=""BOLcHOg4ajSHR6BjbSBeX_6aXjMu1V5RrUYXqyV_FqtQSd8RzdU1gkMv1DlRPDIUtFK6Nd16Jql0eSzyZh4V2uc"";
</code></pre>

<p>I generate my keys using openssl:</p>

<pre><code>exec('openssl ecparam -genkey -name prime256v1 -noout -out example-ecc.pem');
$private = openssl_pkey_get_private(""file://example-ecc.pem"");
</code></pre>

<p>Then I call:</p>

<pre><code>$sharedSecret=openssl_dh_compute_key(base64_decode($clientPublickey), $private);
</code></pre>

<p>... and I get false.
Calling openssl_error_string() returns nothing, no error.</p>

<p>I've var_dumped openssl_pkey_get_details($private) and verified it was created properly.</p>

<p>Any advice anyone? There doesn't seem to be much info on this function.
<a href=""http://php.net/manual/en/function.openssl-dh-compute-key.php"" rel=""nofollow"">http://php.net/manual/en/function.openssl-dh-compute-key.php</a></p>
","<p>Quite an old post, but still..</p>

<p>I think your public key is not formatted in Base64, but in URL-safe-Base64.<br>
See: <a href=""https://en.wikipedia.org/wiki/Base64#URL_applications"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Base64#URL_applications</a></p>

<p>Furthermore, you can create the keys also from PHP now. Using <code>openssl_pkey_new()</code>.<br>
See: <a href=""https://www.php.net/manual/en/function.openssl-pkey-new.php"" rel=""nofollow noreferrer"">https://www.php.net/manual/en/function.openssl-pkey-new.php</a></p>
","447","<php><diffie-hellman><php-openssl>","0","0","2","2019-06-29 15:45:29","","1","","608639","","2016-09-24 03:56:11","2016-09-24 02:31:58",""
"7364804","Securing an android application","<p>I have 'secured' the communication between my android application and a tls server providing a financial transaction service, currently in development.</p>

<p>The security credentials are stored in a BKS keystore included in the Android apk.  The password to the keystore is visible in plain text in the application source:</p>

<p><code>
keyStore.load(is, ""passwd"".toCharArray());
</code></p>

<p>I am concerned that if someone was to reverse engineer the app, they would be able to impersonate another user and compromise the security of the service.</p>

<p>I was wondering whether there is a fault in my implementation, if anyone else has this concern, and what the best method of securing against this possibility is.</p>
","<p>currently programming for a Processing company-</p>

<p>their are a set of rules and regulations for a transaction application -OR- a POS APP(Point Of Sale application)</p>

<p>the rules are listed online as PCI validation, a certain amount of security has to be issued or it will be a law suit from Visa,inc or Many other Company's.</p>

<p>about your Question, it doesn't follow PCI compliance as that is a security issue.</p>

<p>please read the PCI compliance so that their is a complete understanding of Security, its not good to compromise Cardholder Data.</p>

<p>:)</p>
","439","<android><ssl><diffie-hellman>","3","0","4","2011-11-23 16:25:05","8245623","0","1","736033","","2011-11-23 16:25:05","2011-09-09 16:37:06",""
"7364804","Securing an android application","<p>I have 'secured' the communication between my android application and a tls server providing a financial transaction service, currently in development.</p>

<p>The security credentials are stored in a BKS keystore included in the Android apk.  The password to the keystore is visible in plain text in the application source:</p>

<p><code>
keyStore.load(is, ""passwd"".toCharArray());
</code></p>

<p>I am concerned that if someone was to reverse engineer the app, they would be able to impersonate another user and compromise the security of the service.</p>

<p>I was wondering whether there is a fault in my implementation, if anyone else has this concern, and what the best method of securing against this possibility is.</p>
","<p>Whenever you store security data on the client it can be compromised by reverse engineering. You may try to obscure it in the code but determined hacker will figure it anyway. So the only way to make it more secure is not to have the password openly in the code. May be you can just ask user for some pin code at the start of the application and use it to decrypt the password?</p>
","439","<android><ssl><diffie-hellman>","3","2","4","2011-11-23 16:25:05","8245623","0","1","736033","","2011-11-23 16:25:05","2011-09-09 16:37:06",""
"7364804","Securing an android application","<p>I have 'secured' the communication between my android application and a tls server providing a financial transaction service, currently in development.</p>

<p>The security credentials are stored in a BKS keystore included in the Android apk.  The password to the keystore is visible in plain text in the application source:</p>

<p><code>
keyStore.load(is, ""passwd"".toCharArray());
</code></p>

<p>I am concerned that if someone was to reverse engineer the app, they would be able to impersonate another user and compromise the security of the service.</p>

<p>I was wondering whether there is a fault in my implementation, if anyone else has this concern, and what the best method of securing against this possibility is.</p>
","<p>Are credentials stored in your app unique per user, i.e. every user gets it own apk with unique credentials? If you only have one apk with same credentials then this is as good as no security. Even worse, it gives false feeling of security.</p>

<p>You (your employer) should really hire a security expert to design your system from security point of view.</p>

<p>Here's what I'd do:</p>

<ol>
<li>App comes without security credentials. </li>
<li>Every user is generated security credentials on server.</li>
<li>Every user gets secret activation code which is generated in secure environment and delivered via alternative channel. Preferably via snail mail. Activation codes are time-limited and can be used only one time.</li>
<li>On first use user types into app the activation code which enables a one-time download of credentials over a secure (https) channel.</li>
<li>User provides password to encrypt the credentials while stored on device.</li>
<li>Every time the app is used user must provide this paswword. If app is not used for some time the app must timeout the session and ask for password again when user wants access.</li>
</ol>

<p>But don't take my word for granted. You still need a security expert if there are financial transactions involved.</p>
","439","<android><ssl><diffie-hellman>","3","2","4","2011-11-23 16:25:05","8245623","0","1","736033","","2011-11-23 16:25:05","2011-09-09 16:37:06",""
"7364804","Securing an android application","<p>I have 'secured' the communication between my android application and a tls server providing a financial transaction service, currently in development.</p>

<p>The security credentials are stored in a BKS keystore included in the Android apk.  The password to the keystore is visible in plain text in the application source:</p>

<p><code>
keyStore.load(is, ""passwd"".toCharArray());
</code></p>

<p>I am concerned that if someone was to reverse engineer the app, they would be able to impersonate another user and compromise the security of the service.</p>

<p>I was wondering whether there is a fault in my implementation, if anyone else has this concern, and what the best method of securing against this possibility is.</p>
","<p>I believe that <a href=""http://www.java2s.com/Tutorial/Java/0490__Security/ImplementingtheDiffieHellmankeyexchange.htm"" rel=""nofollow"">Diffie-Hellman Key Exchange</a> is what I was looking for.  I'd rather not have to re-implement my own version of DH using a complicated process which involves the user.</p>
","439","<android><ssl><diffie-hellman>","3","1","4","2011-11-23 16:25:05","8245623","0","1","736033","","2011-11-23 16:25:05","2011-09-09 16:37:06",""
"35357457","How can I fetch an SSL page using Diffie-Hellman with a 480-bit key length?","<p>I'm trying to fetch page that is using DH with a 480-bit key length but I cannot do so using the Apache HTTP Client. I can successfully fetch the page if I use Async HTTP Client with the JDK Provider. </p>

<p>I know that the JDK has limitations around the max size but this issue seems to be the other way around. The key size is too small and not a multiple of 64. </p>

<p>I've written a SSCCE to illustrate this behaviour and after two days of hunting, I'm at my wit's end.</p>

<pre><code>import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.SSLContext;

import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.HttpClientConnectionManager;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.conn.BasicHttpClientConnectionManager;
import org.apache.http.util.EntityUtils;
import org.junit.Assert;
import org.junit.Test;

import com.ning.http.client.AsyncHttpClient;
import com.ning.http.client.AsyncHttpClientConfig;
import com.ning.http.client.providers.jdk.JDKAsyncHttpProvider;

public class DH480Test extends Assert {

    private final String URL = ""https://dh480.badssl.com/"";

    @Test
    public void testNingHTTPClientWithJDKProvider() {
        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
        AsyncHttpClient client = new AsyncHttpClient(new JDKAsyncHttpProvider(config), config);

        try {
            client.prepareGet(URL).execute().get();
        } catch (Exception e) {
            e.printStackTrace();
            fail();
        }
    }

    @Test
    public void testApacheHTTClient() throws NoSuchAlgorithmException, KeyManagementException {
        SSLContext sslContext = SSLContext.getInstance(""SSL"");
        sslContext.init(null, null, null);

        Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()
                .register(""https"", new SSLConnectionSocketFactory(sslContext))
                .register(""http"", new PlainConnectionSocketFactory())
                .build();
        HttpClientConnectionManager ccm = new BasicHttpClientConnectionManager(registry);
        HttpClientBuilder builder = HttpClientBuilder.create();
        builder.setConnectionManager(ccm);

        HttpClient client = builder.build();

        try {
            HttpGet get = new HttpGet(URL);
            HttpResponse r = client.execute(get);
            EntityUtils.consume(r.getEntity());
        } catch (Exception e) {
            e.printStackTrace();
            fail();
        }
    }
}
</code></pre>

<p>Here's the stack trace of the the failing test.</p>

<pre><code>javax.net.ssl.SSLException: java.lang.RuntimeException: Could not generate DH keypair
    at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1906)
    at sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1889)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1410)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387)
    at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:290)
    at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:259)
    at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:125)
    at org.apache.http.impl.conn.BasicHttpClientConnectionManager.connect(BasicHttpClientConnectionManager.java:318)
    at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363)
    at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219)
    at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195)
    at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86)
    at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108)
    at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184)
    at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)
    at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106)
    at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)
    at DH480Test.testApacheHTTClient(DH480Test.java:59)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: java.lang.RuntimeException: Could not generate DH keypair
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:142)
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:114)
    at sun.security.ssl.ClientHandshaker.serverKeyExchange(ClientHandshaker.java:708)
    at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:268)
    at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979)
    at sun.security.ssl.Handshaker.process_record(Handshaker.java:914)
    at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)
    at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403)
    ... 41 more
Caused by: java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 2048 (inclusive)
    at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
    at java.security.KeyPairGenerator$Delegate.initialize(KeyPairGenerator.java:674)
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:128)
    ... 49 more

java.lang.AssertionError
    ...
</code></pre>

<hr>

<p>Here's another standalone test that showcases that I am able to fetch the page using the default JDK networking libs. This is the underlying networking implementation used by the async http client. Here are my JVM details</p>

<pre><code>➜  ~  java -version
java version ""1.8.0_66""
Java(TM) SE Runtime Environment (build 1.8.0_66-b17)
Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)

@Test
public void testHTTPURLConnection() throws IOException {
    try {
        java.net.URL url = new URL(URL);
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        connection.setHostnameVerifier((s, sslSession) -&gt; true);
        connection.setRequestMethod(""GET"");
        connection.setReadTimeout(15 * 1000);
        connection.connect();
        System.out.println(IOUtils.toString(connection.getInputStream()));
    } catch (Exception e) {
        fail();
    }
}
</code></pre>
","<p>I am not an expert and never worked with DH in java but after seeing your logs and little exploration of the code at <a href=""http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/com/sun/crypto/provider/DHKeyPairGenerator.java#DHKeyPairGenerator.initialize%28java.security.spec.AlgorithmParameterSpec%2Cjava.security.SecureRandom%29"" rel=""nofollow"">DHKeyPairGenerator Grepcode</a> it is really very clear in both the <code>initialize</code> function that it will always throw exception if <code>Prime size &lt; 512</code> as it is in written in code,</p>

<pre><code>83         if ((keysize &lt; 512) || (keysize &gt; 1024) || (keysize % 64 != 0)) {
84             throw new InvalidParameterException(""Keysize must be multiple ""
85                                                 + ""of 64, and can only range ""
86                                                 + ""from 512 to 1024 ""
87                                                 + ""(inclusive)"");
88         }
</code></pre>

<p>and    </p>

<pre><code>118    if ((pSize &lt; 512) || (pSize &gt; 1024) ||
119            (pSize % 64 != 0)) {
120            throw new InvalidAlgorithmParameterException
121                (""Prime size must be multiple of 64, and can only range ""
122                 + ""from 512 to 1024 (inclusive)"");
123        }
</code></pre>

<p>So it's for sure that you can not use these standard libraries for 480-bit key length.</p>

<p>It might be available in some other libraries which you need to explore, we used bouncycastle libraries to do some encryption stuff that might have those capabilities. </p>

<p>I little researched and found the same <a href=""http://grepcode.com/file/repo1.maven.org/maven2/org.bouncycastle/bcprov-debug-jdk15on/1.52/org/bouncycastle/crypto/generators/DHKeyPairGenerator.java"" rel=""nofollow"">DHKeyPairGenerator class</a> in bouncycastle package with no constraints and checks on key size.</p>
","430","<java><ssl><apache-httpclient-4.x><diffie-hellman><asynchttpclient>","1","0","2","2016-02-12 12:09:34","35358480","3","2","304151","","2016-02-12 11:05:11","2016-02-12 07:58:24",""
"35357457","How can I fetch an SSL page using Diffie-Hellman with a 480-bit key length?","<p>I'm trying to fetch page that is using DH with a 480-bit key length but I cannot do so using the Apache HTTP Client. I can successfully fetch the page if I use Async HTTP Client with the JDK Provider. </p>

<p>I know that the JDK has limitations around the max size but this issue seems to be the other way around. The key size is too small and not a multiple of 64. </p>

<p>I've written a SSCCE to illustrate this behaviour and after two days of hunting, I'm at my wit's end.</p>

<pre><code>import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.SSLContext;

import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.HttpClientConnectionManager;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.conn.BasicHttpClientConnectionManager;
import org.apache.http.util.EntityUtils;
import org.junit.Assert;
import org.junit.Test;

import com.ning.http.client.AsyncHttpClient;
import com.ning.http.client.AsyncHttpClientConfig;
import com.ning.http.client.providers.jdk.JDKAsyncHttpProvider;

public class DH480Test extends Assert {

    private final String URL = ""https://dh480.badssl.com/"";

    @Test
    public void testNingHTTPClientWithJDKProvider() {
        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
        AsyncHttpClient client = new AsyncHttpClient(new JDKAsyncHttpProvider(config), config);

        try {
            client.prepareGet(URL).execute().get();
        } catch (Exception e) {
            e.printStackTrace();
            fail();
        }
    }

    @Test
    public void testApacheHTTClient() throws NoSuchAlgorithmException, KeyManagementException {
        SSLContext sslContext = SSLContext.getInstance(""SSL"");
        sslContext.init(null, null, null);

        Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()
                .register(""https"", new SSLConnectionSocketFactory(sslContext))
                .register(""http"", new PlainConnectionSocketFactory())
                .build();
        HttpClientConnectionManager ccm = new BasicHttpClientConnectionManager(registry);
        HttpClientBuilder builder = HttpClientBuilder.create();
        builder.setConnectionManager(ccm);

        HttpClient client = builder.build();

        try {
            HttpGet get = new HttpGet(URL);
            HttpResponse r = client.execute(get);
            EntityUtils.consume(r.getEntity());
        } catch (Exception e) {
            e.printStackTrace();
            fail();
        }
    }
}
</code></pre>

<p>Here's the stack trace of the the failing test.</p>

<pre><code>javax.net.ssl.SSLException: java.lang.RuntimeException: Could not generate DH keypair
    at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1906)
    at sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1889)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1410)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387)
    at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:290)
    at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:259)
    at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:125)
    at org.apache.http.impl.conn.BasicHttpClientConnectionManager.connect(BasicHttpClientConnectionManager.java:318)
    at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363)
    at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219)
    at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195)
    at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86)
    at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108)
    at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184)
    at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)
    at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106)
    at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)
    at DH480Test.testApacheHTTClient(DH480Test.java:59)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: java.lang.RuntimeException: Could not generate DH keypair
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:142)
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:114)
    at sun.security.ssl.ClientHandshaker.serverKeyExchange(ClientHandshaker.java:708)
    at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:268)
    at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979)
    at sun.security.ssl.Handshaker.process_record(Handshaker.java:914)
    at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)
    at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403)
    ... 41 more
Caused by: java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 2048 (inclusive)
    at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
    at java.security.KeyPairGenerator$Delegate.initialize(KeyPairGenerator.java:674)
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:128)
    ... 49 more

java.lang.AssertionError
    ...
</code></pre>

<hr>

<p>Here's another standalone test that showcases that I am able to fetch the page using the default JDK networking libs. This is the underlying networking implementation used by the async http client. Here are my JVM details</p>

<pre><code>➜  ~  java -version
java version ""1.8.0_66""
Java(TM) SE Runtime Environment (build 1.8.0_66-b17)
Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)

@Test
public void testHTTPURLConnection() throws IOException {
    try {
        java.net.URL url = new URL(URL);
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        connection.setHostnameVerifier((s, sslSession) -&gt; true);
        connection.setRequestMethod(""GET"");
        connection.setReadTimeout(15 * 1000);
        connection.connect();
        System.out.println(IOUtils.toString(connection.getInputStream()));
    } catch (Exception e) {
        fail();
    }
}
</code></pre>
","<p>Disclaimer: I'm the maintainer of AsyncHttpClient (please, don't call it Ning).</p>

<p>Fun fact: this does work with AHC's JDK provider when running with JDK8, but not with JDK7!</p>

<p>Now: AHC JDK provider (which is a mere toy that is going away in AHC2, you shouldn't use it) boils down to Http(s)UrlConnection, so it's expected to get the same results.</p>

<p>Then, NIO based clients such as the other AHC providers, and Apache HttpComponents can't use the underlying HTTPS components that are being used by HttpsUrlConnection, because they are not public!</p>

<p>So they have to directly use <code>javax.net.ssl.SSLEngine</code>. But, this API was intended for generic TLS, not for the protocols built on top of it such as HTTPS.</p>

<p>For example, before JDK7, this cause a huge security issue on all Java NIO based HTTP clients, because they didn't have a way to properly perform hostname verification. Hostname verification is specific to HTTPS, so you can pass a HostnameVerifier to HttpsUrlConnection (HTTPS specific), but not to SSLEngine (generic TLS).</p>

<p>Now, since JDK7, we can finally configure a protocol (HTTPS or LDAP) on the SSLEngine so it takes care of the HTTPS specific behavior. But still, you have way less control than with HttpsUrlConnection.</p>

<p>Here, it seems that you found a JDK bug, and that HttpsUrlConnection and SSLEngine w/ HTTPS protocol enabled don't behave the same way.</p>

<p>For example, whatever I do (whatever cyphersuites I enable), I can't manage to get the BadSSL.com server pick <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>, which is the one HttpsUrlConnection picks. It always pick <code>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</code> instead (no elliptic curve). See ServerHello when enabling TLS debug (<code>-Djavax.net.debug=all</code>).</p>
","430","<java><ssl><apache-httpclient-4.x><diffie-hellman><asynchttpclient>","1","1","2","2016-02-12 12:09:34","35358480","3","2","304151","","2016-02-12 11:05:11","2016-02-12 07:58:24",""
"50518826","MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED","<p>im trying to code a Diffie-Hellman key Exchange (client side) into a XMC4500 and I'm using <a href=""https://github.com/ARMmbed/mbedtls"" rel=""nofollow noreferrer"">ARMmbed lib</a>.</p>

<p>This is the code I got (based on <a href=""https://github.com/ARMmbed/mbedtls/blob/development/programs/pkey/dh_client.c"" rel=""nofollow noreferrer"">dh_client.c</a>):  </p>

<p>int dhm (void)
{</p>

<pre><code>int ret;
size_t n, buflen;

unsigned char *p, *end;
unsigned char buf[512];
unsigned char hash[32];
const char *pers = ""dh_client"";

mbedtls_entropy_context entropy;
mbedtls_ctr_drbg_context ctr_drbg;
mbedtls_rsa_context rsa;
mbedtls_dhm_context dhm;
mbedtls_aes_context aes;

mbedtls_rsa_init( &amp;rsa, MBEDTLS_RSA_PKCS_V15, MBEDTLS_MD_SHA256 );
mbedtls_dhm_init( &amp;dhm );
mbedtls_aes_init( &amp;aes );
mbedtls_ctr_drbg_init( &amp;ctr_drbg );

/*
 * 1. Setup the RNG
 */

mbedtls_entropy_init( &amp;entropy );
ret = mbedtls_ctr_drbg_seed( &amp;ctr_drbg,
                            mbedtls_entropy_func,
                            &amp;entropy,
                            (const unsigned char *) pers,
                            strlen( pers ) );

mbedtls_aes_free( &amp;aes );
mbedtls_rsa_free( &amp;rsa );
mbedtls_dhm_free( &amp;dhm );
mbedtls_ctr_drbg_free( &amp;ctr_drbg );
mbedtls_entropy_free( &amp;entropy );

return ret;}
</code></pre>

<p>I did not try to go further this, because it is not working and it is the very beginning of dhm algorithm. The function <strong>mbedtls_ctr_drbg_seed</strong> is returning <strong>MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED</strong>.</p>

<p>Also in the <a href=""https://github.com/ARMmbed/mbedtls/blob/development/include/mbedtls/ctr_drbg.h"" rel=""nofollow noreferrer"">ctr_drbg.h</a> I had to edit the <strong>MBEDTLS_CTR_DRBG_MAX_SEED_INPUT</strong> from 384(default) to 336, otherwise the code would crash. Everything else is default.</p>

<p>Someone knows why is returning this error?
Thanks in advance.</p>

<p>Note: Im calling this function in main. Running the code gives me no errors.</p>
","<p>This error is returned when your entropy function(<code>mbedtls_entropy_func</code>) fails. Do you have an entropy source enabled? You probably don't have any strong entropy source configured in your platform, thus causing this failure.</p>
","430","<c><random><diffie-hellman><mbed><mbedtls>","0","0","1","2018-06-07 14:49:49","","0","","9215780","","2018-05-24 22:09:08","2018-05-24 22:04:15",""
"33507213","Diffie-Hellman Computing with VERY large numbers","<p>I am trying to compute some values for a Diffie-Hellman key exchange. I understand the concepts, but the data that I'm working with makes me question the method.</p>

<p>I have been given 5 values to work with p and g:</p>

<pre><code>    // p and g
    BigInteger p = new BigInteger(DH_PRIME, 16);
    BigInteger g = new BigInteger(DH_GEN, 16);

    // My Private Key
    BigInteger a = new BigInteger(
            ""5E8B02F2B2E9C96E0C359ECD14EB1B29EBDD61E70A61E4"" +
            ""2F0836A5974963E96D91F1462B699C222BC92BC068E9DC"" +
            ""E5C78E4349D28DDCB6D0ED2C41F7CD8AF2418C8AE27B69"" +
            ""09484DED7F0C5B4C286D9C36518FA5953974741B3A6F75"" +
            ""7B59A41A5CA0B74EFD919BB7ED8CCEC9CB3BC4B4F8D15D"" +
            ""16DC4642E54691904B2F35B969"", 16);

    // My Public Key
    BigInteger A = new BigInteger(
            ""85F04DD00345642AD12B65BD1A7C38728BFF0B8E281DDB"" +
            ""6AC4F2739E82A02145DAABF23D173C933913B1F8440597"" +
            ""10E9125591569DE427EAE1D269ACCBFA3305069DEB7622"" +
            ""D1DA3AD9820D11BD24FDCCE5381D2DF99BDA314394738D"" +
            ""FCBE210EAE247B1303E79297FF746CD919E189F6A5776E"" +
            ""6ECC24C8900DE0F38F159072DE"", 16);

    // Their Private Key
    BigInteger b = new BigInteger(
            ""42111D3A7ECAA6A83E503825F38629AD9754D93370D681"" +
            ""AEFEE152329D8DAE6C20732C5A7B6393DEDDB62753CEEF"" +
            ""AE0A5E1BD037A5A32364CE1375442E58997C2918563EE5"" +
            ""D7452373847AABAD5A5D02DF289B3A0B9096A375AE509F"" +
            ""16363B4573A5CCCDFFF2B60459D52C0E5280853000CE62"" +
            ""68560A95111723AF5916CC8376"", 16);

    // Their Public Key
    BigInteger B = new BigInteger(
            ""71257BA7758CDE21480706CA55861F5FE6122E5B879420"" +
            ""80F3E384890284FD62341B90A1B60FB44ADD61031D6AAC"" +
            ""3D5B267F1435B0765AC289040B63B242EED82863FD18BB"" +
            ""637757EDF44BA4589E0CE99D192E902C16EF1A89E7E7C1"" +
            ""C2EB5A6A8AB3E3E4F6B8A9CACCA4B8F6C4E20D12626797"" +
            ""5406CF9151D57BEEAE32C33CD8"", 16);

    // The Shared Secret
    BigInteger secret = new BigInteger(
            ""834A9D0434D817735589F22A4633FB6DD3E530DBA1EA2B"" +
            ""BB9E1ACCB438084513087F5DA00EA86ED53164D8893B81"" +
            ""A9C8DF65BC189CF6830D271E1A3E504CBCB25714164B51"" +
            ""9C75F6E0ADF41BB07E7F8C4FB7B9960D813E6577A73252"" +
            ""EEA9C139CDDA606D51122170E71636E7849149618C8238"" +
            ""A226128821F0B668490BDCA82F"", 16);
</code></pre>

<p>Using this post as a guide:
<a href=""https://security.stackexchange.com/questions/45963/diffie-hellman-key-exchange-in-plain-english"">https://security.stackexchange.com/questions/45963/diffie-hellman-key-exchange-in-plain-english</a></p>

<p>1) Are my assumptions correct that 'a' is the secret number on my side and 'b' is the secret number on their side?</p>

<p>2) Given the example data, am I correct in transforming the hex representation to a decimal value? Here are my results:</p>

<pre><code> a = 66390362007035946406218401401207761013475548285294105112105139639190607639308478292266684826306137190981682856073453566963077570668348041252633322979431955395580457467551843233313476557017872071709128383858840166213588753166690401421078658676432871207970713843501321433541674906101053126631545366776741476713
 A = 94054944803568781365809132293092437685411466113799940774655767034465070801688227674438324625217997304495304798217968020105674208988107083532555808216365925310845077730469696561179874023824545031639895643922574243862372138887930362438243722132412662233732339999845565810626073575967836399703588412025249755870
 b = 46393721373616931425713842738733091490641584087681350012011014830147740618840619997608221051635856275110730538390991643443828273505863608898989702862901548035408503167446323013096534700981785904886213090032981937144110592283933751272337196723467356342510104910060731712678136878986285012929934142772165247862
 B = 79454116791030243835993774846060329772022864579356590515844871048029546733381452221063689783318067017491406528317462838099472851672248798338610594948647929971365872809557181659701202351270701590108182485073251154126367917793952098022309258299793944660722596621675214128052755659890352643244396810687568100568
 secret = 92195997420654412005403859326763427963568159942225029128672319592580542441945382083896651021886036463236361034857638584808142466991971457292885469363097913358292550515467126779618590503912963769256823553075620480922531451229861911226149279841977690852350735509236250226638964983746622786925283953012622796847
</code></pre>

<p>3) Do these values make sense when it comes to computing the result? I am having a hard time getting this function to work with such large numbers:</p>

<p>A = g^a mod p </p>

<p>Given that 'a' is some 308 digits long, it seems too large to make any sense. I cannot set such a large number as the exponent on the BigInteger as it will only allow me to pass an int value, where my 'a' is most definitely out of range. </p>
","<p>You are correct on your first two questions.</p>

<p>For the 3rd one, use the <code>modPow(BigInteger exponent, BigInteger modulo)</code>, so</p>

<pre><code>BigInteger A = g.modPow(a,p);
</code></pre>
","428","<java><math><diffie-hellman>","3","3","1","2015-11-03 19:23:20","33507360","0","","-1","","2017-03-17 13:14:46","2015-11-03 19:14:17",""
"16731693","SSL Decryption programmatically","<p>I want to decrypt the packets which is using the ciphersuite TLS-DHE-RSA-WITH-AES-256-CBC-SHA.Using Master keys I am able to decrypt the data in wireshark.Still I can't save decrypted wireshark file so I am doing it programmatically.I am having Keyblock which includes client mac,server mac,client write,server write and both client and server iv's .So how can I decrypt encrypted data programmatically?</p>
","<p>Your best bet is probably to fork Wireshark and make a patch which allows you to save decrypted data (then give them the patch to incorporate if they so desire).</p>

<p>They've already done all the hard work, all you need to do is add some basic file I/O, and it also contributes back to the development of a program you're using.</p>
","427","<openssl><wireshark><encryption><diffie-hellman>","-1","0","1","2013-05-26 06:12:05","16756708","3","","952374","","2013-05-24 09:35:32","2013-05-24 09:27:22",""
"54311617","JSch: How to configure diffie-hellman-group14-sha256?","<p>I am trying to connect to a ssh server with diffie-hellman-group14-sha256@ssh.com, diffie-hellman-group-exchange-sha256 algorithm.</p>

<p>But my JSch client always encrypts with diffie-hellman-group14-sha1.</p>

<p>What can I do to setup the sha256 algorithm?</p>

<p>The problem occurs on our test environment only. The settings there are same as prod environments. Just OpenSSH version differs - it is newer on test.</p>

<p>Java version: 1.8.0_151</p>

<p>Server logs: ""The JCE Unlimited Strength Jurisdiction Policy File was found""</p>

<p>Available in server lib: jce_policy-8/US_export_policy.jar, jce_policy-8/local_policy.jar</p>

<p><strong>My code looks like:</strong></p>

<pre><code>        JSch jsch = new JSch(); 
        Session session = null;
        Channel channel = null;
        ChannelSftp c = null;

        //Now connect and SFTP to the SFTP Server
        try {
            //Create a session sending through our username and password
            session = jsch.getSession(ftpUserName, ftpHost, ftpPort);    
            session.setPassword(ftpPassword);

            Properties config = new Properties();
            config.put(""StrictHostKeyChecking"", ""no"");
            session.setConfig(config);
            session.connect();
            //
            //Open the SFTP channel
            //
            channel = session.openChannel(""sftp"");
            channel.connect();
            c = (ChannelSftp)channel;
            status = ""OK"";
        }
        catch (Exception e) {
            status = ""Unable to connect to FTP server. ""+e.toString();
        }
</code></pre>

<p><strong>Log out is:</strong></p>

<pre><code>INFO: Connecting to X.X.X.X port 22
INFO: Connection established
INFO: Remote version string: SSH-2.0-6.4.13.36 SSH Tectia Server
INFO: Local version string: SSH-2.0-JSCH-0.1.53
INFO: CheckCiphers: aes256-ctr,aes192-ctr,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,3des-ctr,arcfour,arcfour128,arcfour256
**INFO**:   CheckKexes: diffie-hellman-group14-sha1,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521
        CheckKexes: diffie-hellman-group14-sha1,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521
INFO: CheckSignatures: ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521
INFO: SSH_MSG_KEXINIT sent
INFO: SSH_MSG_KEXINIT received
**INFO: kex: server**: diffie-hellman-group14-sha256@ssh.com,diffie-hellman-group-exchange-sha256,diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1
INFO: kex: server: ssh-rsa,ssh-rsa-sha256@ssh.com
INFO: kex: server: aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,crypticore128@ssh.com
INFO: kex: server: aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,crypticore128@ssh.com
INFO: kex: server: hmac-sha2-256,hmac-sha2-512,hmac-md5,hmac-sha256-2@ssh.com,hmac-sha224@ssh.com,hmac-sha256@ssh.com,hmac-sha384@ssh.com,hmac-sha512@ssh.com,crypticore-mac@ssh.com
INFO: kex: server: hmac-sha2-256,hmac-sha2-512,hmac-md5,hmac-sha256-2@ssh.com,hmac-sha224@ssh.com,hmac-sha256@ssh.com,hmac-sha384@ssh.com,hmac-sha512@ssh.com,crypticore-mac@ssh.com
INFO: kex: server: none,zlib
INFO: kex: server: none,zlib
INFO: kex: server: 
INFO: kex: server: 
**INFO: kex: client**: ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha256,diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1
INFO: kex: client: ssh-rsa,ssh-dss,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521
INFO: kex: client: aes256-ctr,aes192-ctr,arcfour,arcfour128,arcfour256,aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc
INFO: kex: client: aes256-ctr,aes192-ctr,arcfour,arcfour128,arcfour256,aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc
INFO: kex: client: hmac-md5,hmac-sha1,hmac-sha2-256,hmac-sha1-96,hmac-md5-96
INFO: kex: client: hmac-md5,hmac-sha1,hmac-sha2-256,hmac-sha1-96,hmac-md5-96
INFO: kex: client: none
INFO: kex: client: none
INFO: kex: client: 
INFO: kex: client: 
INFO: kex: server-&gt;client aes256-ctr hmac-md5 none
INFO: kex: client-&gt;server aes256-ctr hmac-md5 none
INFO: SSH_MSG_KEXDH_INIT sent
INFO: expecting SSH_MSG_KEXDH_REPLY
INFO: ssh_rsa_verify: signature true
INFO: Permanently added '160.58.9.72' (RSA) to the list of known hosts.
INFO: SSH_MSG_NEWKEYS sent
INFO: SSH_MSG_NEWKEYS received
INFO: SSH_MSG_SERVICE_REQUEST sent
INFO: SSH_MSG_SERVICE_ACCEPT received
INFO: Authentications that can continue: publickey,keyboard-interactive,password
INFO: Next authentication method: publickey
INFO: Authentications that can continue: keyboard-interactive,password
INFO: Next authentication method: keyboard-interactive
INFO: Authentication succeeded (keyboard-interactive).
</code></pre>

<p>I've tried to set the SHA256 algorithm by putting the same algorithms in the same order as the server logs without success:</p>

<pre><code>config.put(""kex"", ""diffie-hellman-group14-sha256@ssh.com,diffie-hellman-group-exchange-sha256,diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1"");
</code></pre>

<p><strong>Log when algorithm order is the same</strong></p>

<pre><code>INFO: Connecting to X.X.X.X port 22
INFO: Connection established
INFO: Remote version string: SSH-2.0-6.4.13.36 SSH Tectia Server
INFO: Local version string: SSH-2.0-JSCH-0.1.53
INFO: CheckCiphers: aes256-ctr,aes192-ctr,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,3des-ctr,arcfour,arcfour128,arcfour256
INFO: CheckKexes: diffie-hellman-group14-sha1,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521
INFO: CheckSignatures: ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521
INFO: SSH_MSG_KEXINIT sent
INFO: SSH_MSG_KEXINIT received
INFO: kex: server: diffie-hellman-group14-sha256@ssh.com,diffie-hellman-group-exchange-sha256,diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1
INFO: kex: server: ssh-rsa,ssh-rsa-sha256@ssh.com
INFO: kex: server: aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,crypticore128@ssh.com
INFO: kex: server: aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,crypticore128@ssh.com
INFO: kex: server: hmac-sha2-256,hmac-sha2-512,hmac-md5,hmac-sha256-2@ssh.com,hmac-sha224@ssh.com,hmac-sha256@ssh.com,hmac-sha384@ssh.com,hmac-sha512@ssh.com,crypticore-mac@ssh.com
INFO: kex: server: hmac-sha2-256,hmac-sha2-512,hmac-md5,hmac-sha256-2@ssh.com,hmac-sha224@ssh.com,hmac-sha256@ssh.com,hmac-sha384@ssh.com,hmac-sha512@ssh.com,crypticore-mac@ssh.com
INFO: kex: server: none,zlib
INFO: kex: server: none,zlib
INFO: kex: server:   
INFO: kex: server:   
INFO: kex: client: ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha256,diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1
INFO: kex: client: ssh-rsa,ssh-dss,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521
INFO: kex: client: aes256-ctr,aes192-ctr,arcfour,arcfour128,arcfour256,aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc
INFO: kex: client: aes256-ctr,aes192-ctr,arcfour,arcfour128,arcfour256,aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc
INFO: kex: client: hmac-md5,hmac-sha1,hmac-sha2-256,hmac-sha1-96,hmac-md5-96
INFO: kex: client: hmac-md5,hmac-sha1,hmac-sha2-256,hmac-sha1-96,hmac-md5-96
INFO: kex: client: none
INFO: kex: client: none
INFO: kex: client:   
INFO: kex: client:   
INFO: kex: server-&gt;client aes256-ctr hmac-md5 none
INFO: kex: client-&gt;server aes256-ctr hmac-md5 none
INFO: SSH_MSG_KEXDH_INIT sent
INFO: expecting SSH_MSG_KEXDH_REPLY
INFO: ssh_rsa_verify: signature true
INFO: Permanently added 'X.X.X.X' (RSA) to the list of known hosts.
INFO: SSH_MSG_NEWKEYS sent
INFO: SSH_MSG_NEWKEYS received
INFO: SSH_MSG_SERVICE_REQUEST sent
INFO: SSH_MSG_SERVICE_ACCEPT received
INFO: Authentications that can continue: publickey,keyboard-interactive,password
INFO: Next authentication method: publickey
INFO: Authentications that can continue: keyboard-interactive,password
INFO: Next authentication method: keyboard-interactive
INFO: Authentication succeeded (keyboard-interactive).
INFO: Disconnecting from X.X.X.X port 22
INFO: Caught an exception, leaving main loop due to Socket closed
</code></pre>
","","398","<sftp><jsch><diffie-hellman>","0","","0","2019-01-31 12:14:03","","2","1","10950778","","2019-01-31 12:14:03","2019-01-22 15:34:48",""
"41861378","InitializeSecurityContext returned code= -2146892963","<p>I have an asmx webservice that consumes hundreds of other webservices from other companies. Each webservice is expected to return data in a very specific format (we provide a wsdl for the companies to use). I recently started encountering an error with two companies we communicate with. The error ended up being the very generic ""The request was aborted: Could not create SSL/TLS secure channel.."", so I turned on logging in our webservice.</p>

<p>Here is the portion of the log around the error:</p>

<pre><code>System.Net.Sockets Verbose: 0 : [10564] Data from Socket#39875033::Receive
System.Net.Sockets Verbose: 0 : [10564] 00000000 : 16 03 01 16  86                                  : .....
System.Net.Sockets Verbose: 0 : [10564] Exiting Socket#39875033::Receive()  -&gt; Int32#5
System.Net.Sockets Verbose: 0 : [10564] Socket#39875033::Receive()
System.Net.Sockets Verbose: 0 : [10564] Data from Socket#39875033::Receive
System.Net.Sockets Verbose: 0 : [10564] (printing 1024 out of 1375)
System.Net.Sockets Verbose: 0 : [10564] 00000005 : 02 00 00 4D 03 01 58 6F-CE 68 54 44 73 EB F6 F5 : ...M..Xo.hTDs...
System.Net.Sockets Verbose: 0 : [10564] 00000015 : BC E0 22 AF C8 A2 52 CA-86 CD F7 6D BA 97 33 CD : ..""...R....m..3.
System.Net.Sockets Verbose: 0 : [10564] 00000025 : B6 50 E0 0A 59 4C 20 58-6F CE 68 8A FB B6 30 54 : .P..YL Xo.h...0T
System.Net.Sockets Verbose: 0 : [10564] 00000035 : 9A 23 CE 4D 5A A3 2A 75-DF A2 4C A7 16 36 DD FA : .#.MZ.*u..L..6..
System.Net.Sockets Verbose: 0 : [10564] 00000045 : 26 64 5E 64 FF 7B 97 00-39 00 00 05 FF 01 00 01 : &amp;d^d.{..9.......
System.Net.Sockets Verbose: 0 : [10564] 00000055 : 00 0B 00 13 F8 00 13 F5-00 05 4A 30 82 05 46 30 : ..........J0..F0
System.Net.Sockets Verbose: 0 : [10564] 00000065 : 82 04 2E A0 03 02 01 02-02 04 50 D3 24 53 30 0D : ..........P.$S0.
System.Net.Sockets Verbose: 0 : [10564] 00000075 : 06 09 2A 86 48 86 F7 0D-01 01 0B 05 00 30 81 BA : ..*.H........0..
System.Net.Sockets Verbose: 0 : [10564] 00000085 : 31 0B 30 09 06 03 55 04-06 13 02 55 53 31 16 30 : 1.0...U....US1.0
System.Net.Sockets Verbose: 0 : [10564] 00000095 : 14 06 03 55 04 0A 13 0D-45 6E 74 72 75 73 74 2C : ...U....Entrust,
System.Net.Sockets Verbose: 0 : [10564] 000000A5 : 20 49 6E 63 2E 31 28 30-26 06 03 55 04 0B 13 1F :  Inc.1(0&amp;..U....
System.Net.Sockets Verbose: 0 : [10564] 000000B5 : 53 65 65 20 77 77 77 2E-65 6E 74 72 75 73 74 2E : See www.entrust.
System.Net.Sockets Verbose: 0 : [10564] 000000C5 : 6E 65 74 2F 6C 65 67 61-6C 2D 74 65 72 6D 73 31 : net/legal-terms1
System.Net.Sockets Verbose: 0 : [10564] 000000D5 : 39 30 37 06 03 55 04 0B-13 30 28 63 29 20 32 30 : 907..U...0(c) 20
System.Net.Sockets Verbose: 0 : [10564] 000000E5 : 31 32 20 45 6E 74 72 75-73 74 2C 20 49 6E 63 2E : 12 Entrust, Inc.
System.Net.Sockets Verbose: 0 : [10564] 000000F5 : 20 2D 20 66 6F 72 20 61-75 74 68 6F 72 69 7A 65 :  - for authorize
System.Net.Sockets Verbose: 0 : [10564] 00000105 : 64 20 75 73 65 20 6F 6E-6C 79 31 2E 30 2C 06 03 : d use only1.0,..
System.Net.Sockets Verbose: 0 : [10564] 00000115 : 55 04 03 13 25 45 6E 74-72 75 73 74 20 43 65 72 : U...%Entrust Cer
System.Net.Sockets Verbose: 0 : [10564] 00000125 : 74 69 66 69 63 61 74 69-6F 6E 20 41 75 74 68 6F : tification Autho
System.Net.Sockets Verbose: 0 : [10564] 00000135 : 72 69 74 79 20 2D 20 4C-31 4B 30 1E 17 0D 31 35 : rity - L1K0...15
System.Net.Sockets Verbose: 0 : [10564] 00000145 : 30 31 33 30 31 31 33 30-34 33 5A 17 0D 31 38 30 : 0130113043Z..180
System.Net.Sockets Verbose: 0 : [10564] 00000155 : 34 32 39 31 38 30 35 33-37 5A 30 7E 31 0B 30 09 : 429180537Z0~1.0.
System.Net.Sockets Verbose: 0 : [10564] 00000165 : 06 03 55 04 06 13 02 55-53 31 11 30 0F 06 03 55 : ..U....US1.0...U
System.Net.Sockets Verbose: 0 : [10564] 00000175 : 04 08 13 08 49 6C 6C 69-6E 6F 69 73 31 13 30 11 : ....Illinois1.0.
System.Net.Sockets Verbose: 0 : [10564] 00000185 : 06 03 55 04 07 13 0A 4E-6F 72 74 68 62 72 6F 6F : ..U....Northbroo
System.Net.Sockets Verbose: 0 : [10564] 00000195 : FF FF FF FF FF FF FF 55-04 FF FF FF FF FF FF FF : k1#0!..U....Goog
System.Net.Sockets Verbose: 0 : [10564] 000001A5 : FF FF FF FF FF FF FF 73-75 FF FF FF FF FF FF FF : le12 SafesearchC
System.Net.Sockets Verbose: 0 : [10564] 000001B5 : FF FF FF FF FF FF FF 22-30 FF FF FF FF FF FF FF : ompany1""0 ..U...
System.Net.Sockets Verbose: 0 : [10564] 000001C5 : FF FF FF FF FF FF FF 64-34 FF FF FF FF FF FF FF : .bot-gad4-c6c.go
System.Net.Sockets Verbose: 0 : [10564] 000001D5 : FF FF FF FF FF FF FF 63-6F 6D 30 82 01 22 30 0D : ogle12.com0..""0.
System.Net.Sockets Verbose: 0 : [10564] 000001E5 : 06 09 2A 86 48 86 F7 0D-01 01 01 05 00 03 82 01 : ..*.H...........
System.Net.Sockets Verbose: 0 : [10564] 000001F5 : 0F 00 30 82 01 0A 02 82-01 01 00 B2 52 E7 42 40 : ..0.........R.B@
System.Net.Sockets Verbose: 0 : [10564] 00000205 : 49 91 1D D3 F2 F5 D3 60-3B A8 32 A1 CF A9 6A F0 : I......`;.2...j.
System.Net.Sockets Verbose: 0 : [10564] 00000215 : B8 29 2B EF 5E B9 66 9B-9A 6A 39 19 86 54 1C 56 : .)+.^.f..j9..T.V
System.Net.Sockets Verbose: 0 : [10564] 00000225 : E9 14 7E 1C BB D1 A2 B3-8B C5 BE 27 10 EE 38 DB : ..~........'..8.
System.Net.Sockets Verbose: 0 : [10564] 00000235 : DC AC 89 F2 81 FC 96 8A-B0 8E D6 98 F5 96 5D 1C : ..............].
System.Net.Sockets Verbose: 0 : [10564] 00000245 : B6 79 E0 1D 2D C3 75 38-3B F1 20 FB 07 3A 9A B3 : .y..-.u8;. ..:..
System.Net.Sockets Verbose: 0 : [10564] 00000255 : 41 5E DC 8F 32 04 D1 46-07 06 89 DB 4D 32 DB B7 : A^..2..F....M2..
System.Net.Sockets Verbose: 0 : [10564] 00000265 : 8A 16 70 FD 90 74 92 B7-05 73 E7 AD B4 72 CC 4C : ..p..t...s...r.L
System.Net.Sockets Verbose: 0 : [10564] 00000275 : A4 49 35 31 8D 8E 53 68-2A 4B 4E 7A D8 5D EF 1A : .I51..Sh*KNz.]..
System.Net.Sockets Verbose: 0 : [10564] 00000285 : 4D 0C F6 83 51 CC 5C 65-1C A5 D0 6D 71 AC C9 62 : M...Q.\e...mq..b
System.Net.Sockets Verbose: 0 : [10564] 00000295 : 6C F8 82 90 02 63 27 BE-65 F5 BF 55 68 38 9C 6A : l....c'.e..Uh8.j
System.Net.Sockets Verbose: 0 : [10564] 000002A5 : 04 7A 35 C6 BC 69 12 84-6C 5E BF 3A 32 84 F6 E4 : .z5..i..l^.:2...
System.Net.Sockets Verbose: 0 : [10564] 000002B5 : 14 6D 8E 4E D0 FC B9 72-90 D2 06 76 6A 4B 8A 81 : .m.N...r...vjK..
System.Net.Sockets Verbose: 0 : [10564] 000002C5 : DB 14 B2 5B DE EE 9C A2-B2 81 84 EB 4C D7 13 0E : ...[........L...
System.Net.Sockets Verbose: 0 : [10564] 000002D5 : C3 2E 69 40 6C BC FE E7-BC 97 FC 87 7A 61 6B C1 : ..i@l.......zak.
System.Net.Sockets Verbose: 0 : [10564] 000002E5 : A7 A1 68 9F 71 4C 6B C3-98 6B 2C 6F E5 C1 64 14 : ..h.qLk..k,o..d.
System.Net.Sockets Verbose: 0 : [10564] 000002F5 : 0C 63 DE 17 71 58 7A C8-4E D7 4D 02 03 01 00 01 : .c..qXz.N.M.....
System.Net.Sockets Verbose: 0 : [10564] 00000305 : A3 82 01 8D 30 82 01 89-30 0B 06 03 55 1D 0F 04 : ....0...0...U...
System.Net.Sockets Verbose: 0 : [10564] 00000315 : 04 03 02 05 A0 30 1D 06-03 55 1D 25 04 16 30 14 : .....0...U.%..0.
System.Net.Sockets Verbose: 0 : [10564] 00000325 : 06 08 2B 06 01 05 05 07-03 01 06 08 2B 06 01 05 : ..+.........+...
System.Net.Sockets Verbose: 0 : [10564] 00000335 : 05 07 03 02 30 33 06 03-55 1D 1F 04 2C 30 2A 30 : ....03..U...,0*0
System.Net.Sockets Verbose: 0 : [10564] 00000345 : 28 A0 26 A0 24 86 22 68-74 74 70 3A 2F 2F 63 72 : (.&amp;.$.""http://cr
System.Net.Sockets Verbose: 0 : [10564] 00000355 : 6C 2E 65 6E 74 72 75 73-74 2E 6E 65 74 2F 6C 65 : l.entrust.net/le
System.Net.Sockets Verbose: 0 : [10564] 00000365 : 76 65 6C 31 6B 2E 63 72-6C 30 4B 06 03 55 1D 20 : vel1k.crl0K..U. 
System.Net.Sockets Verbose: 0 : [10564] 00000375 : 04 44 30 42 30 36 06 0A-60 86 48 01 86 FA 6C 0A : .D0B06..`.H...l.
System.Net.Sockets Verbose: 0 : [10564] 00000385 : 01 05 30 28 30 26 06 08-2B 06 01 05 05 07 02 01 : ..0(0&amp;..+.......
System.Net.Sockets Verbose: 0 : [10564] 00000395 : 16 1A 68 74 74 70 3A 2F-2F 77 77 77 2E 65 6E 74 : ..http://www.ent
System.Net.Sockets Verbose: 0 : [10564] 000003A5 : 72 75 73 74 2E 6E 65 74-2F 72 70 61 30 08 06 06 : rust.net/rpa0...
System.Net.Sockets Verbose: 0 : [10564] 000003B5 : 67 81 0C 01 02 02 30 68-06 08 2B 06 01 05 05 07 : g.....0h..+.....
System.Net.Sockets Verbose: 0 : [10564] 000003C5 : 01 01 04 5C 30 5A 30 23-06 08 2B 06 01 05 05 07 : ...\0Z0#..+.....
System.Net.Sockets Verbose: 0 : [10564] 000003D5 : 30 01 86 17 68 74 74 70-3A 2F 2F 6F 63 73 70 2E : 0...http://ocsp.
System.Net.Sockets Verbose: 0 : [10564] 000003E5 : 65 6E 74 72 75 73 74 2E-6E 65 74 30 33 06 08 2B : entrust.net03..+
System.Net.Sockets Verbose: 0 : [10564] 000003F5 : 06 01 05 05 07 30 02 86-27 68 74 74 70 3A 2F 2F : .....0..'http://
System.Net.Sockets Verbose: 0 : [10564] Exiting Socket#39875033::Receive()  -&gt; Int32#1375
System.Net.Sockets Verbose: 0 : [10564] Socket#39875033::Receive()
System.Net.Sockets Verbose: 0 : [10564] Data from Socket#39875033::Receive
System.Net.Sockets Verbose: 0 : [10564] (printing 1024 out of 4391)
System.Net.Sockets Verbose: 0 : [10564] 00000564 : BB F6 5B 28 01 80 2C DE-DA 84 E1 3F 50 19 CA 7A : ..[(..,....?P..z
System.Net.Sockets Verbose: 0 : [10564] 00000574 : 75 41 AA 4B A7 D5 F9 94-81 EE 68 E9 72 E4 47 6A : uA.K......h.r.Gj
System.Net.Sockets Verbose: 0 : [10564] 00000584 : 60 CF 92 1F 7B 34 E8 B3-2B 49 B8 CD 19 01 44 BC : `...{4..+I....D.
System.Net.Sockets Verbose: 0 : [10564] 00000594 : D7 5D 2A BF 95 A5 F3 7F-A3 6D CA C0 D4 E7 D7 87 : .]*......m......
System.Net.Sockets Verbose: 0 : [10564] 000005A4 : 09 69 07 FE F2 47 00 05-07 30 82 05 03 30 82 03 : .i...G...0...0..
System.Net.Sockets Verbose: 0 : [10564] 000005B4 : EB A0 03 02 01 02 02 04-51 D3 60 EE 30 0D 06 09 : ........Q.`.0...
System.Net.Sockets Verbose: 0 : [10564] 000005C4 : 2A 86 48 86 F7 0D 01 01-0B 05 00 30 81 BE 31 0B : *.H........0..1.
System.Net.Sockets Verbose: 0 : [10564] 000005D4 : 30 09 06 03 55 04 06 13-02 55 53 31 16 30 14 06 : 0...U....US1.0..
System.Net.Sockets Verbose: 0 : [10564] 000005E4 : 03 55 04 0A 13 0D 45 6E-74 72 75 73 74 2C 20 49 : .U....Entrust, I    
System.Net.Sockets Verbose: 0 : [10564] 000005F4 : 6E 63 2E 31 28 30 26 06-03 55 04 0B 13 1F 53 65 : nc.1(0&amp;..U....Se
System.Net.Sockets Verbose: 0 : [10564] 00000604 : 65 20 77 77 77 2E 65 6E-74 72 75 73 74 2E 6E 65 : e www.entrust.ne
System.Net.Sockets Verbose: 0 : [10564] 00000614 : 74 2F 6C 65 67 61 6C 2D-74 65 72 6D 73 31 39 30 : t/legal-terms190
System.Net.Sockets Verbose: 0 : [10564] 00000624 : 37 06 03 55 04 0B 13 30-28 63 29 20 32 30 30 39 : 7..U...0(c) 2009
System.Net.Sockets Verbose: 0 : [10564] 00000634 : 20 45 6E 74 72 75 73 74-2C 20 49 6E 63 2E 20 2D :  Entrust, Inc. -
System.Net.Sockets Verbose: 0 : [10564] 00000644 : 20 66 6F 72 20 61 75 74-68 6F 72 69 7A 65 64 20 :  for authorized 
System.Net.Sockets Verbose: 0 : [10564] 00000654 : 75 73 65 20 6F 6E 6C 79-31 32 30 30 06 03 55 04 : use only1200..U.
System.Net.Sockets Verbose: 0 : [10564] 00000664 : 03 13 29 45 6E 74 72 75-73 74 20 52 6F 6F 74 20 : ..)Entrust Root 
System.Net.Sockets Verbose: 0 : [10564] 00000674 : 43 65 72 74 69 66 69 63-61 74 69 6F 6E 20 41 75 : Certification Au
System.Net.Sockets Verbose: 0 : [10564] 00000684 : 74 68 6F 72 69 74 79 20-2D 20 47 32 30 1E 17 0D : thority - G20...
System.Net.Sockets Verbose: 0 : [10564] 00000694 : 31 34 31 30 32 32 31 37-30 35 31 34 5A 17 0D 32 : 141022170514Z..2
System.Net.Sockets Verbose: 0 : [10564] 000006A4 : 34 31 30 32 33 30 37 33-33 32 32 5A 30 81 BA 31 : 41023073322Z0..1
System.Net.Sockets Verbose: 0 : [10564] 000006B4 : 0B 30 09 06 03 55 04 06-13 02 55 53 31 16 30 14 : .0...U....US1.0.
System.Net.Sockets Verbose: 0 : [10564] 000006C4 : 06 03 55 04 0A 13 0D 45-6E 74 72 75 73 74 2C 20 : ..U....Entrust, 
System.Net.Sockets Verbose: 0 : [10564] 000006D4 : 49 6E 63 2E 31 28 30 26-06 03 55 04 0B 13 1F 53 : Inc.1(0&amp;..U....S
System.Net.Sockets Verbose: 0 : [10564] 000006E4 : 65 65 20 77 77 77 2E 65-6E 74 72 75 73 74 2E 6E : ee www.entrust.n
System.Net.Sockets Verbose: 0 : [10564] 000006F4 : 65 74 2F 6C 65 67 61 6C-2D 74 65 72 6D 73 31 39 : et/legal-terms19
System.Net.Sockets Verbose: 0 : [10564] 00000704 : 30 37 06 03 55 04 0B 13-30 28 63 29 20 32 30 31 : 07..U...0(c) 201
System.Net.Sockets Verbose: 0 : [10564] 00000714 : 32 20 45 6E 74 72 75 73-74 2C 20 49 6E 63 2E 20 : 2 Entrust, Inc. 
System.Net.Sockets Verbose: 0 : [10564] 00000724 : 2D 20 66 6F 72 20 61 75-74 68 6F 72 69 7A 65 64 : - for authorized
System.Net.Sockets Verbose: 0 : [10564] 00000734 : 20 75 73 65 20 6F 6E 6C-79 31 2E 30 2C 06 03 55 :  use only1.0,..U
System.Net.Sockets Verbose: 0 : [10564] 00000744 : 04 03 13 25 45 6E 74 72-75 73 74 20 43 65 72 74 : ...%Entrust Cert
System.Net.Sockets Verbose: 0 : [10564] 00000754 : 69 66 69 63 61 74 69 6F-6E 20 41 75 74 68 6F 72 : ification Author
System.Net.Sockets Verbose: 0 : [10564] 00000764 : 69 74 79 20 2D 20 4C 31-4B 30 82 01 22 30 0D 06 : ity - L1K0..""0..
System.Net.Sockets Verbose: 0 : [10564] 00000774 : 09 2A 86 48 86 F7 0D 01-01 01 05 00 03 82 01 0F : .*.H............
System.Net.Sockets Verbose: 0 : [10564] 00000784 : 00 30 82 01 0A 02 82 01-01 00 DA 3F 96 D0 4D B9 : .0.........?..M.
System.Net.Sockets Verbose: 0 : [10564] 00000794 : 2F 44 E7 DB 39 5E 9B 50-EE 5C A5 61 DA 41 67 53 : /D..9^.P.\.a.AgS
System.Net.Sockets Verbose: 0 : [10564] 000007A4 : 09 AA 00 9A 8E 57 7F 29-6B DB C7 E1 21 24 AA 3A : .....W.)k...!$.:
System.Net.Sockets Verbose: 0 : [10564] 000007B4 : D0 8D 47 23 D2 ED 72 16-F0 91 21 D2 5D B7 B8 4B : ..G#..r...!.]..K
System.Net.Sockets Verbose: 0 : [10564] 000007C4 : A8 83 8F B7 91 32 68 CF-CE 25 93 2C B2 7D 97 C8 : .....2h..%.,.}..
System.Net.Sockets Verbose: 0 : [10564] 000007D4 : FE C1 B4 17 BA 09 9E 03-90 93 7B 7C 49 83 22 68 : ..........{|I.""h
System.Net.Sockets Verbose: 0 : [10564] 000007E4 : 8A 9B DE 47 C3 31 98 7A-2E 7D 40 0B D2 EF 3E D3 : ...G.1.z.}@...&gt;.
System.Net.Sockets Verbose: 0 : [10564] 000007F4 : B2 8C AA 8F 48 A9 FF 00-E8 29 58 06 F7 B6 93 5A : ....H....)X....Z
System.Net.Sockets Verbose: 0 : [10564] 00000804 : 94 73 26 26 AD 58 0E E5-42 B8 D5 EA 73 79 64 68 : .s&amp;&amp;.X..B...sydh
System.Net.Sockets Verbose: 0 : [10564] 00000814 : 53 25 B8 84 CF 94 7A AE-06 45 0C A3 6B 4D D0 C6 : S%....z..E..kM..
System.Net.Sockets Verbose: 0 : [10564] 00000824 : BE EA 18 A4 36 F0 92 B2-BA 1C 88 8F 3A 52 7F F7 : ....6.......:R..
System.Net.Sockets Verbose: 0 : [10564] 00000834 : 5E 6D 83 1C 9D F0 1F E5-C3 D6 DD A5 78 92 3D B0 : ^m..........x.=.
System.Net.Sockets Verbose: 0 : [10564] 00000844 : 6D 2C EA C9 CF 94 41 19-71 44 68 BA 47 3C 04 E9 : m,....A.qDh.G&lt;..
System.Net.Sockets Verbose: 0 : [10564] 00000854 : 5D BA 3E F0 35 F7 15 B6-9E F2 2E 15 1E 3F 47 C8 : ].&gt;.5........?G.
System.Net.Sockets Verbose: 0 : [10564] 00000864 : C8 38 A7 73 45 5D 4D B0-3B B1 8E 17 29 37 EA DD : .8.sE]M.;...)7..
System.Net.Sockets Verbose: 0 : [10564] 00000874 : 05 01 22 BB 94 36 2A 8D-5B 35 FE 53 19 2F 08 46 : ..""..6*.[5.S./.F
System.Net.Sockets Verbose: 0 : [10564] 00000884 : C1 2A B3 1A 62 1D 4E 2B-D9 1B 02 03 01 00 01 A3 : .*..b.N+........
System.Net.Sockets Verbose: 0 : [10564] 00000894 : 82 01 09 30 82 01 05 30-0E 06 03 55 1D 0F 01 01 : ...0...0...U....
System.Net.Sockets Verbose: 0 : [10564] 000008A4 : FF 04 04 03 02 01 06 30-0F 06 03 55 1D 13 04 08 : .......0...U....
System.Net.Sockets Verbose: 0 : [10564] 000008B4 : 30 06 01 01 FF 02 01 00-30 33 06 08 2B 06 01 05 : 0.......03..+...
System.Net.Sockets Verbose: 0 : [10564] 000008C4 : 05 07 01 01 04 27 30 25-30 23 06 08 2B 06 01 05 : .....'0%0#..+...
System.Net.Sockets Verbose: 0 : [10564] 000008D4 : 05 07 30 01 86 17 68 74-74 70 3A 2F 2F 6F 63 73 : ..0...http://ocs
System.Net.Sockets Verbose: 0 : [10564] 000008E4 : 70 2E 65 6E 74 72 75 73-74 2E 6E 65 74 30 30 06 : p.entrust.net00.
System.Net.Sockets Verbose: 0 : [10564] 000008F4 : 03 55 1D 1F 04 29 30 27-30 25 A0 23 A0 21 86 1F : .U...)0'0%.#.!..
System.Net.Sockets Verbose: 0 : [10564] 00000904 : 68 74 74 70 3A 2F 2F 63-72 6C 2E 65 6E 74 72 75 : http://crl.entru
System.Net.Sockets Verbose: 0 : [10564] 00000914 : 73 74 2E 6E 65 74 2F 67-32 63 61 2E 63 72 6C 30 : st.net/g2ca.crl0
System.Net.Sockets Verbose: 0 : [10564] 00000924 : 3B 06 03 55 1D 20 04 34-30 32 30 30 06 04 55 1D : ;..U. .40200..U.
System.Net.Sockets Verbose: 0 : [10564] 00000934 : 20 00 30 28 30 26 06 08-2B 06 01 05 05 07 02 01 :  .0(0&amp;..+.......
System.Net.Sockets Verbose: 0 : [10564] 00000944 : 16 1A 68 74 74 70 3A 2F-2F 77 77 77 2E 65 6E 74 : ..http://www.ent
System.Net.Sockets Verbose: 0 : [10564] 00000954 : 72 75 73 74 2E 6E 65 74-2F 72 70 61 30 1D 06 03 : rust.net/rpa0...
System.Net.Sockets Verbose: 0 : [10564] Exiting Socket#39875033::Receive()  -&gt; Int32#4391
System.Net Information: 0 : [10564] InitializeSecurityContext(credential = System.Net.SafeFreeCredential_SECURITY, context = 1d73b60:1c191a0, targetName = bot-gad4-c6c.google12.com, inFlags = ReplayDetect, SequenceDetect, Confidentiality, AllocateMemory, InitManualCredValidation)
System.Net Information: 0 : [10564] InitializeSecurityContext(In-Buffers count=2, Out-Buffer length=0, returned code=-2146892963).
System.Net.Sockets Verbose: 0 : [10564] Socket#39875033::Dispose()
System.Net Error: 0 : [10564] Exception in HttpWebRequest#54487120:: - The request was aborted: Could not create SSL/TLS secure channel..
System.Net Error: 0 : [10564] Exception in HttpWebRequest#54487120::GetResponse - The request was aborted: Could not create SSL/TLS secure channel..
</code></pre>

<p>The returned code of -2146892963 is not in the list of enumerated returned codes for the InitializeSecurityContext method. Any idea what this means and how to fix it?</p>
","<p>So, after weeks of searching, I found out what the error code is.</p>

<p>My problem is the method was returning the code in decimal form and I should have been searching for the hex code, which is 8009035D. Searching for that error code resulted in this article: <a href=""https://www.nsoftware.com/kb/xml/06101501.rst#8009035D"" rel=""nofollow noreferrer"">https://www.nsoftware.com/kb/xml/06101501.rst#8009035D</a>, indicating that this particular error code could be related to Windows blocking weak security. </p>

<p>In my case, this is exactly what my problem was. I made the registry entry change given by the article, allowing for DHE Key length of 512 instead of the default 1024. After restarting the webserver, I was able to consume the company's webservice. </p>

<p>It turns out that this particular company was using a DHE key length of 768, resulting in the error. </p>

<p>As for fixing the problem, I feel the registry entry change should only be used to verify that this is the problem. I am currently in the process of updating this webservice to use TLS1.2, which seems to force the company to use a different algorithm.</p>
","396","<.net><web-services><diffie-hellman>","1","1","1","2017-01-25 20:47:12","41861379","0","","","","","2017-01-25 20:47:12",""
"29315955","Diffie-Hellman Parameters and safety","<p>I Want to create my own safe connection for a VOIP app.</p>

<p>Now I am looking into key exchange which seems to be much more Tricky than encrypting/decrypting.</p>

<p>Are there any better approaches than Diffie-Hellman in practice ?</p>

<p>I understand the concept of Diffie-Hellman but I think it needs the right values to be safe since with natural numbers it could be easily be guessed. How can I get those values using python, what are they and is it really safe from key guessing?</p>

<p>Please help me with some background informations / inspiring.</p>
","<p>Diffie-Hellman key exchange, also called exponential key exchange, is a method of digital encryption that uses numbers raised to specific powers to produce decryption keys on the basis of components that are never directly transmitted, making the task of a would-be code breaker mathematically overwhelming.</p>

<p>The most serious limitation of Diffie-Hellman in its basic or ""pure"" form is the lack of authentication. Communications using Diffie-Hellman all by itself are vulnerable to man in the middle attacks. Ideally, Diffie-Hellman should be used in conjunction with a recognized authentication method such as digital signatures to verify the identities of the users over the public communications medium.</p>

<p>More light on the topic is available below:</p>

<p>1 <a href=""https://stackoverflow.com/questions/10836320/on-diffie-hellman-key-exchange"">link 1</a></p>

<p>2 <a href=""https://security.stackexchange.com/questions/54359/what-is-the-difference-between-diffie-hellman-generator-2-and-5"">link 2</a></p>

<p>3 <a href=""https://crypto.stackexchange.com/questions/12223/how-should-i-manage-diffie-hellman-parameters-on-a-web-server"">link 3</a></p>
","395","<python><diffie-hellman>","0","1","3","2017-11-15 08:34:46","","1","","3051961","","2015-03-28 10:48:16","2015-03-28 10:16:30",""
"29315955","Diffie-Hellman Parameters and safety","<p>I Want to create my own safe connection for a VOIP app.</p>

<p>Now I am looking into key exchange which seems to be much more Tricky than encrypting/decrypting.</p>

<p>Are there any better approaches than Diffie-Hellman in practice ?</p>

<p>I understand the concept of Diffie-Hellman but I think it needs the right values to be safe since with natural numbers it could be easily be guessed. How can I get those values using python, what are they and is it really safe from key guessing?</p>

<p>Please help me with some background informations / inspiring.</p>
","<p>DH is fine for this purpose, just make to sure to use 2048 bit keys or more.</p>

<p>However for VoIP the standards are TLS with SRTP/zrtp so it would be better if you would implement these. With DH you loose compatibility and will introduce a lot of complications. Also note that DH is only for key exchange, so you will need something also for the encryption itself. With TLS you could handle all these in one step by using a well know implementation instead to write your own encryption stack from scratch.</p>
","395","<python><diffie-hellman>","0","0","3","2017-11-15 08:34:46","","1","","3051961","","2015-03-28 10:48:16","2015-03-28 10:16:30",""
"29315955","Diffie-Hellman Parameters and safety","<p>I Want to create my own safe connection for a VOIP app.</p>

<p>Now I am looking into key exchange which seems to be much more Tricky than encrypting/decrypting.</p>

<p>Are there any better approaches than Diffie-Hellman in practice ?</p>

<p>I understand the concept of Diffie-Hellman but I think it needs the right values to be safe since with natural numbers it could be easily be guessed. How can I get those values using python, what are they and is it really safe from key guessing?</p>

<p>Please help me with some background informations / inspiring.</p>
","<p>Diffie-Hellman is a key exchange algorithm. So Anyone can access your public parameters. You can use safety except declassified private parameters. It's so important create sharedkey safety. If you want to more secure system, try <a href=""https://en.wikipedia.org/wiki/Forward_secrecy"" rel=""nofollow noreferrer"">forward-secrecy</a></p>
","395","<python><diffie-hellman>","0","0","3","2017-11-15 08:34:46","","1","","3051961","","2015-03-28 10:48:16","2015-03-28 10:16:30",""
"33851539","Can KeyAgreement be used without AlgorithmParameterSpec?","<p>In my Android application working with <strong>SpongyCastle</strong>, I want to perform <strong>ECDH Key Exchange</strong> using a <strong>specific elliptic curve</strong> (<em>prime192v1</em>) and I am using this code to generate byte[] representation of private and public params:</p>

<pre><code>        try{
            KeyPairGenerator g = KeyPairGenerator.getInstance(""ECDH"", ""SC"");

            org.spongycastle.jce.spec.ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""prime192v1"");
            g.initialize(ecSpec, new SecureRandom());

            KeyPair kp1 = g.generateKeyPair();
            KeyPair kp2 = g.generateKeyPair();

            // Alice generated this
            byte[] privK1 = kp1.getPrivate().getEncoded();
            byte[] pubK1= kp1.getPrivate().getEncoded();

            // Bob generated this
            byte[] privK2 = kp2.getPrivate().getEncoded();
            byte[] pubK2= kp2.getPrivate().getEncoded();

        }catch(Exception e)
        {
            Log.e(LOGTAG, ""Exception caught in ECDHInit function"");
        }
</code></pre>

<p>now lets assume Alice and Bob save their private keys locally, exchange <code>pubK1</code> and <code>pubK2</code> and want to proceed with setting a shared secret (they have both keys now in <code>byte[]</code> format). I will describe only case of Alice, as for Bob this is identical:</p>

<pre><code>KeyAgreement keyAgreement = KeyAgreement.getInstance(""ECDH"", ""SC"");

PrivateKey privateKey = KeyFactory.getInstance(""ECDH"", ""SC"").generatePrivate(new PKCS8EncodedKeySpec(privK1));
PublicKey publicKey = KeyFactory.getInstance(""ECDH"", ""SC"").generatePublic(new X509EncodedKeySpec(pubK2));
</code></pre>

<p><strong>Here comes my question</strong> - 
using the following code, I manage to get same shared secret for both Alice and Bob                 </p>

<pre><code>keyAgreement.init(privateKey);
keyAgreement.doPhase(publicKey, true);

byte[] sharedSecret = SHA256(keyAgreement.generateSecret());
</code></pre>

<p>but I specify nowhere my special curve <em>prime192v1</em></p>

<p>If I try to supply this in this way:</p>

<pre><code>org.spongycastle.jce.spec.ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(""prime192v1"");

keyAgreement.init(privateKey, ecSpec);
keyAgreement.doPhase(publicKey, true);

byte[] sharedSecret = SHA256(keyAgreement.generateSecret());
</code></pre>

<p>an Exception is thrown saying</p>

<pre><code>java.security.InvalidAlgorithmParameterException: No algorithm parameters supported
</code></pre>

<p>Why can't I supply my desired parameter? Does the <code>KeyAgreement</code> somehow deduce this from the private key?</p>

<p>Thanks!</p>
","<p>So it turns out I had the answer right there in front of me in the Android Studio debugger. Upon inspecting <code>PrivateKey</code> object I found internal member <code>privateKey.ecSpec</code> which contains all the details of selected curve. So passing arguments is unnecessary and throws an error, <strong>use the code without providing additional <code>ecSpec</code></strong></p>
","381","<java><android><elliptic-curve><diffie-hellman><spongycastle>","1","1","1","2015-11-22 04:22:07","33851560","0","1","","","","2015-11-22 04:18:12",""
"19180835","How to generate certificate or key store for server using annoymous diffie-hellmen algorithm","<p>I want to create certificate using Anonymous diffie Hellman algorithms as need to create HTTPS web service with no authentication to perform.
Need help how can i configure certificate for Server and also steps to set up tomcat server.</p>
","<p>By definition, <em>anonymous</em> DH cipher suites don't require authentication of either parties. Hence, they don't use a certificate at all. You don't need to set a keystore in this case. It doesn't make any sense to create a certificate for anonymous DH.</p>

<p>(The lack of keystore is in fact one of the cause for the ""no cipher suites in common"" message when you're not using anonymous DH cipher suites, which are sensibly disabled by default.)</p>

<p>If you want to use anonymous DH cipher suites, it's the cipher suites you need to configure (see the names with <code>anon</code> in the <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider"" rel=""nofollow"">list of cipher suites disabled by default</a>).</p>

<p>Note that they're disabled by default for a good reason: they make the connection vulnerable to MITM attacks. If you want the connection to be secure, you should always at least have the client verify the identity of the server (by configuring a certificate on the server).</p>
","377","<tomcat><soap><ssl><wsdl><diffie-hellman>","0","1","1","2013-10-04 13:47:39","","0","","","","","2013-10-04 12:10:13",""
"47169665","How to compute a shared secret for 2 users in algorithm Diffie Hellman using openssl lib c language?","<p>I need some help with algorithm Diffie Hellman in openssl
I have prime number (p), generator (g), private key of user A and public key of user B. I need to compute the shared key. I wrote this code, but the code is executed till this line</p>

<pre><code> int dhSize = DH_size(dh-&gt;priv_key);
</code></pre>

<p>Here is the full code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;openssl/dh.h&gt;

const char* userA_PrivateKey = ""90ff0"";
const char* userB_PublicKey = ""9d1a59"";
const char* p = ""66c2fa"";
const char* g = ""2"";

int main(void)
{
    DH *dh = DH_new();

    BN_dec2bn(&amp;dh-&gt;g, g);
    BN_hex2bn(&amp;dh-&gt;p, p);
    BN_hex2bn(&amp;dh-&gt;priv_key, userA_PrivateKey);

    BIGNUM *pubKeyUserB = NULL;
    BN_dec2bn(&amp;pubKeyUserB, userB_PublicKey);

    //Compute the shared secret
    int secret_size;
    unsigned char *secret;
    printf("" Compute DH_size \n"");
    int dhSize = DH_size(dh-&gt;priv_key);
    printf("" dhSize = %d \n""); //NOT EXECUTED 
    secret = OPENSSL_malloc(sizeof(unsigned char) * dhSize);

    if(0 &gt; (secret_size = DH_compute_key(secret, pubKeyUserB, dh-&gt;priv_key)))
    {
        printf(""error \n"");
    }

    return 0;
}
</code></pre>

<p>I have two problems:</p>

<p>1) printf, that prints dhSize is not executed at all</p>

<p>2) I am not sure if I set values g, p, priv key correctly ? Will the function DH_compute_key use my g and p ? </p>
","<p>You are making silly mistakes:</p>

<ol>
<li><p><code>dhSize</code> should be typed as <code>DH_size</code> (~line 24)
and <code>DH_size</code> function calculates size of <code>struct DH</code> given a <em><code>const struct DH *</code></em> you are passing it <code>dh-&gt;priv_key</code> instead of passing it <code>dh</code> (~line 28)</p></li>
<li><p>Similar mistake in use of <code>DH_compute_key</code> (~line 28) third argument should be <code>dh</code> not <code>dh-&gt;priv_key</code>. </p></li>
</ol>

<p>Please fix accordingly and try again</p>
","376","<c><algorithm><openssl><diffie-hellman>","1","0","1","2017-11-08 03:05:51","47170927","3","","","","","2017-11-08 00:31:28",""
"28896164","Diffie-Hellman Server and Client Mismatch Computed Shared Key","<p>I am trying to implement a Diffie-Hellman key sharing between Linux (client side) using openssl, and Win 7 (server side) using Mentalis DiffieHellman C# package (downloaded from <a href=""http://www.mentalis.org"" rel=""nofollow"">http://www.mentalis.org</a>)</p>

<p><strong>Client side:</strong>
    DH *client_key = DH_new();</p>

<pre><code>int rc = DH_generate_parameters_ex(client_key, 1024, DH_GENERATOR_2, NULL);

rc = DH_generate_key(client_key) code:

// Example of the client-&gt;pub_key (128 bytes):

//""0E9948EB9B589678805A0CCD46FAF6D834478571F9C8046AB67C06B2B091DD63E752B4B48565F87CBED02E1B150064636C36BDFC3
//570CD7EC6D90BC1CEA1AC303F335592286B30BD6D42714EF50C78649A2E5F6C41BD9CE625C2CF20DF89F762253C0954CBFCCDE4ED
//728330C1378545EBE746FB04F4935E2251B17F577C87FE""

int generated_key_length = BN_num_bytes(client_key-&gt;pub_key);

unsigned char *share_key = (unsigned char *)calloc(DH_size(client_key));

// Share the client public key to the server

char *pub_key_string = BN_bn2hex(client_key-&gt;pub_key);

// Example of the server_pubkey (128 bytes):
//""3D69F1371BAD271518D5D51978CBEBAD463E743F450937600F15037BA9B134F7008065A337DDBACD9C7DE58188F0DCE4D546FA8591
//18A2C791EBABA751A2774E57831A5AE9F3C5FAA192A11AA170EC4B5BF23CF70354A865AA5CDDFCC50A364B6835AA0652C1D498A079
//F994C8004E0FC9C3727EFAAD8AFF7786EDD5B945454F""         

rc = DH_compute_key(share_key, server_pubkey, client_key):

// Example of the computed share_key (128 bytes):
 //""6B1387C957BBC5BE7EFA8B44E2DA2306CBD54838A94EB187532FEFC2EAE0D19EFA42DAA1330F9D32676E986959DC18DC98EBCD1703
//2B2B4B034E88E8270EAB766B0479469E2C1CA2B49D2DB47194D606038958CA683297B1982A571825631B55BCED80B9599DE64D7DA7
//CD7CECDB6D1B522641C95DAA1C859380A3D623515A44""         

free(secret_key);

DH_free(client_key);

// **End of Client side code!**

**Server side (C#) code:**

using Org.Mentalis.Security.Cryptography;

// Create a new DH instance
DiffieHellman dhServer = new DiffieHellmanManaged();

// Generate the public key of the first DH instance
byte[] server_pubkey = dhServer.CreateKeyExchange();
// And, hex encode server_pubkey and send it to the client side

// Decode the hex-encoded client_pubkey to get the share_key
byte[] sharedKey = dhServer.DecryptKeyExchange(client_pubkey); 

// **End of Server side code!**
</code></pre>

<p>Based on the above implementations, I never success in getting the computed share_keys (one from the client side, 
and the other from the server side) the same! What am I missing or doing wrong?</p>

<p>I would also like to ask whether there is other ""c# packages""/methods that can be used at the Server side to do DH key sharing with openssl? Many many thanks.</p>
","","371","<c#><openssl><diffie-hellman>","1","","0","2015-03-06 19:13:33","","2","","608639","","2015-03-06 19:13:33","2015-03-06 09:49:13",""
"15851134","Java.Security.Key.getEncoded() OpenSSL DH Equivalent","<p>How can I achieve the same result in C with OpenSSL as the getEncoded() Method produces? 
It is required for a Diffie-Hellman Key Agreement and I have to send my public key to a java server (But I think the getEncoded() Method not only encodes the Public Key but also the parameters which should be also required for my case)</p>

<p>My current status is that I have a OpenSSL DH Object which contains the PublicKey and p&amp;g as BigNums.</p>

<p>Would bey very great if anyone knows how to do that.</p>
","<p>If encoded DH object means DER encoded, then i2d_DHParams can help you. It is given <a href=""http://www.openssl.org/docs/crypto/dh.html"" rel=""nofollow"">here</a>.</p>
","366","<java><c><openssl><diffie-hellman>","1","1","1","2013-04-06 13:59:08","15851840","2","","","","","2013-04-06 12:46:44",""
"33010209","Java 1.8 Diffie Hellman Group 14 returns InvalidAlgorithmException","<p>I am trying to use RFC-3526 parameters for Diffie Hellman Group 14 (2048 bit key) with default generator from the RFC set to 2.</p>

<p>Attached is the codes I am trying out:</p>

<pre><code>KeyPairGenerator hostKeyGen = KeyPairGenerator.getInstance(""DH"");
DHParameterSpec dhGrp14KeySpec = new DHParameterSpec(new BigInteger(DH_GRP_14_P), BigInteger.valueOf(DH_GRP_14_G));
System.out.println(""\tP ("" + DH_GRP_14_P.length + ""): "" + dhGrp14KeySpec.getP());
System.out.println(""\tG: "" + dhGrp14KeySpec.getG());
hostKeyGen.initialize(dhGrp14KeySpec);
System.out.println(""Creating Host DH private key..."");
KeyPair hostKey = hostKeyGen.generateKeyPair();
System.out.println(""Initiating host side Schannel..."");
KeyAgreement schannel = KeyAgreement.getInstance(""DH"");
schannel.init(hostKey.getPrivate());
</code></pre>

<p>The error I am getting is:</p>

<pre><code>java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 2048 (inclusive)
    at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
    at java.security.KeyPairGenerator$Delegate.initialize(KeyPairGenerator.java:657)
    at java.security.KeyPairGenerator.initialize(KeyPairGenerator.java:399)
    at dhtest.SchannelDHTest.main(SchannelDHTest.java:124)
</code></pre>

<p>The DH_GRP_14_P byte array (as per RFC-3526 Grp 14 specs):</p>

<pre><code>(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xC9, (byte) 0x0F,
(byte) 0xDA, (byte) 0xA2, (byte) 0x21, (byte) 0x68, (byte) 0xC2,
(byte) 0x34, (byte) 0xC4, (byte) 0xC6, (byte) 0x62, (byte) 0x8B,
(byte) 0x80, (byte) 0xDC, (byte) 0x1C, (byte) 0xD1, (byte) 0x29,
(byte) 0x02, (byte) 0x4E, (byte) 0x08, (byte) 0x8A, (byte) 0x67,
(byte) 0xCC, (byte) 0x74, (byte) 0x02, (byte) 0x0B, (byte) 0xBE,
(byte) 0xA6, (byte) 0x3B, (byte) 0x13, (byte) 0x9B, (byte) 0x22,
(byte) 0x51, (byte) 0x4A, (byte) 0x08, (byte) 0x79, (byte) 0x8E,
(byte) 0x34, (byte) 0x04, (byte) 0xDD, (byte) 0xEF, (byte) 0x95,
(byte) 0x19, (byte) 0xB3, (byte) 0xCD, (byte) 0x3A, (byte) 0x43,
(byte) 0x1B, (byte) 0x30, (byte) 0x2B, (byte) 0x0A, (byte) 0x6D,
(byte) 0xF2, (byte) 0x5F, (byte) 0x14, (byte) 0x37, (byte) 0x4F,
(byte) 0xE1, (byte) 0x35, (byte) 0x6D, (byte) 0x6D, (byte) 0x51,
(byte) 0xC2, (byte) 0x45, (byte) 0xE4, (byte) 0x85, (byte) 0xB5,
(byte) 0x76, (byte) 0x62, (byte) 0x5E, (byte) 0x7E, (byte) 0xC6,
(byte) 0xF4, (byte) 0x4C, (byte) 0x42, (byte) 0xE9, (byte) 0xA6,
(byte) 0x37, (byte) 0xED, (byte) 0x6B, (byte) 0x0B, (byte) 0xFF,
(byte) 0x5C, (byte) 0xB6, (byte) 0xF4, (byte) 0x06, (byte) 0xB7,
(byte) 0xED, (byte) 0xEE, (byte) 0x38, (byte) 0x6B, (byte) 0xFB,
(byte) 0x5A, (byte) 0x89, (byte) 0x9F, (byte) 0xA5, (byte) 0xAE,
(byte) 0x9F, (byte) 0x24, (byte) 0x11, (byte) 0x7C, (byte) 0x4B,
(byte) 0x1F, (byte) 0xE6, (byte) 0x49, (byte) 0x28, (byte) 0x66,
(byte) 0x51, (byte) 0xEC, (byte) 0xE4, (byte) 0x5B, (byte) 0x3D,
(byte) 0xC2, (byte) 0x00, (byte) 0x7C, (byte) 0xB8, (byte) 0xA1,
(byte) 0x63, (byte) 0xBF, (byte) 0x05, (byte) 0x98, (byte) 0xDA,
(byte) 0x48, (byte) 0x36, (byte) 0x1C, (byte) 0x55, (byte) 0xD3,
(byte) 0x9A, (byte) 0x69, (byte) 0x16, (byte) 0x3F, (byte) 0xA8,
(byte) 0xFD, (byte) 0x24, (byte) 0xCF, (byte) 0x5F, (byte) 0x83,
(byte) 0x65, (byte) 0x5D, (byte) 0x23, (byte) 0xDC, (byte) 0xA3,
(byte) 0xAD, (byte) 0x96, (byte) 0x1C, (byte) 0x62, (byte) 0xF3,
(byte) 0x56, (byte) 0x20, (byte) 0x85, (byte) 0x52, (byte) 0xBB,
(byte) 0x9E, (byte) 0xD5, (byte) 0x29, (byte) 0x07, (byte) 0x70,
(byte) 0x96, (byte) 0x96, (byte) 0x6D, (byte) 0x67, (byte) 0x0C,
(byte) 0x35, (byte) 0x4E, (byte) 0x4A, (byte) 0xBC, (byte) 0x98,
(byte) 0x04, (byte) 0xF1, (byte) 0x74, (byte) 0x6C, (byte) 0x08,
(byte) 0xCA, (byte) 0x18, (byte) 0x21, (byte) 0x7C, (byte) 0x32,
(byte) 0x90, (byte) 0x5E, (byte) 0x46, (byte) 0x2E, (byte) 0x36,
(byte) 0xCE, (byte) 0x3B, (byte) 0xE3, (byte) 0x9E, (byte) 0x77,
(byte) 0x2C, (byte) 0x18, (byte) 0x0E, (byte) 0x86, (byte) 0x03,
(byte) 0x9B, (byte) 0x27, (byte) 0x83, (byte) 0xA2, (byte) 0xEC,
(byte) 0x07, (byte) 0xA2, (byte) 0x8F, (byte) 0xB5, (byte) 0xC5,
(byte) 0x5D, (byte) 0xF0, (byte) 0x6F, (byte) 0x4C, (byte) 0x52,
(byte) 0xC9, (byte) 0xDE, (byte) 0x2B, (byte) 0xCB, (byte) 0xF6,
(byte) 0x95, (byte) 0x58, (byte) 0x17, (byte) 0x18, (byte) 0x39,
(byte) 0x95, (byte) 0x49, (byte) 0x7C, (byte) 0xEA, (byte) 0x95,
(byte) 0x6A, (byte) 0xE5, (byte) 0x15, (byte) 0xD2, (byte) 0x26,
(byte) 0x18, (byte) 0x98, (byte) 0xFA, (byte) 0x05, (byte) 0x10,
(byte) 0x15, (byte) 0x72, (byte) 0x8E, (byte) 0x5A, (byte) 0x8A,
(byte) 0xAC, (byte) 0xAA, (byte) 0x68, (byte) 0xFF, (byte) 0xFF,
(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
(byte) 0xFF
</code></pre>

<p>I counted the bytes and they were exactly256 bytes (2048 bit) Prime. How do I resolve this ?</p>
","<p>new BigInteger(DH_GRP_14_P).bitLength() was 1982. Thats not how you construct a BigInteger from hexadecimal numbers.</p>

<p>This should work for you:</p>

<pre><code>import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;

import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;

public class Main {

    public static void main(String[] args) throws Exception {
        KeyPairGenerator hostKeyGen = KeyPairGenerator.getInstance(""DH"");
        BigInteger p = new BigInteger(modp2048, 16);
        BigInteger g = BigInteger.valueOf(2L);

        System.out.println(""p bits: ""+p.bitLength());
        System.out.println(""g bits: ""+g.bitLength());

        DHParameterSpec dhGrp14KeySpec = new DHParameterSpec(p, p);
        hostKeyGen.initialize(dhGrp14KeySpec);
        System.out.println(""Creating Host DH private key..."");
        KeyPair hostKey = hostKeyGen.generateKeyPair();
        System.out.println(""Initiating host side Schannel..."");
        KeyAgreement schannel = KeyAgreement.getInstance(""DH"");
        schannel.init(hostKey.getPrivate());
    }


    private static final String modp2048 = (
            ""FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1"" +
            ""29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD"" +
            ""EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245"" +
            ""E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED"" +
            ""EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D"" +
            ""C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F"" +
            ""83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D"" +
            ""670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B"" +
            ""E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9"" +
            ""DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510"" +
            ""15728E5A 8AACAA68 FFFFFFFF FFFFFFFF"")
            .replaceAll(""\\s"", """");

}
</code></pre>
","364","<java><diffie-hellman>","1","4","2","2015-10-09 19:19:46","33011923","1","2","","","","2015-10-08 08:13:27",""
"33010209","Java 1.8 Diffie Hellman Group 14 returns InvalidAlgorithmException","<p>I am trying to use RFC-3526 parameters for Diffie Hellman Group 14 (2048 bit key) with default generator from the RFC set to 2.</p>

<p>Attached is the codes I am trying out:</p>

<pre><code>KeyPairGenerator hostKeyGen = KeyPairGenerator.getInstance(""DH"");
DHParameterSpec dhGrp14KeySpec = new DHParameterSpec(new BigInteger(DH_GRP_14_P), BigInteger.valueOf(DH_GRP_14_G));
System.out.println(""\tP ("" + DH_GRP_14_P.length + ""): "" + dhGrp14KeySpec.getP());
System.out.println(""\tG: "" + dhGrp14KeySpec.getG());
hostKeyGen.initialize(dhGrp14KeySpec);
System.out.println(""Creating Host DH private key..."");
KeyPair hostKey = hostKeyGen.generateKeyPair();
System.out.println(""Initiating host side Schannel..."");
KeyAgreement schannel = KeyAgreement.getInstance(""DH"");
schannel.init(hostKey.getPrivate());
</code></pre>

<p>The error I am getting is:</p>

<pre><code>java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 2048 (inclusive)
    at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
    at java.security.KeyPairGenerator$Delegate.initialize(KeyPairGenerator.java:657)
    at java.security.KeyPairGenerator.initialize(KeyPairGenerator.java:399)
    at dhtest.SchannelDHTest.main(SchannelDHTest.java:124)
</code></pre>

<p>The DH_GRP_14_P byte array (as per RFC-3526 Grp 14 specs):</p>

<pre><code>(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xC9, (byte) 0x0F,
(byte) 0xDA, (byte) 0xA2, (byte) 0x21, (byte) 0x68, (byte) 0xC2,
(byte) 0x34, (byte) 0xC4, (byte) 0xC6, (byte) 0x62, (byte) 0x8B,
(byte) 0x80, (byte) 0xDC, (byte) 0x1C, (byte) 0xD1, (byte) 0x29,
(byte) 0x02, (byte) 0x4E, (byte) 0x08, (byte) 0x8A, (byte) 0x67,
(byte) 0xCC, (byte) 0x74, (byte) 0x02, (byte) 0x0B, (byte) 0xBE,
(byte) 0xA6, (byte) 0x3B, (byte) 0x13, (byte) 0x9B, (byte) 0x22,
(byte) 0x51, (byte) 0x4A, (byte) 0x08, (byte) 0x79, (byte) 0x8E,
(byte) 0x34, (byte) 0x04, (byte) 0xDD, (byte) 0xEF, (byte) 0x95,
(byte) 0x19, (byte) 0xB3, (byte) 0xCD, (byte) 0x3A, (byte) 0x43,
(byte) 0x1B, (byte) 0x30, (byte) 0x2B, (byte) 0x0A, (byte) 0x6D,
(byte) 0xF2, (byte) 0x5F, (byte) 0x14, (byte) 0x37, (byte) 0x4F,
(byte) 0xE1, (byte) 0x35, (byte) 0x6D, (byte) 0x6D, (byte) 0x51,
(byte) 0xC2, (byte) 0x45, (byte) 0xE4, (byte) 0x85, (byte) 0xB5,
(byte) 0x76, (byte) 0x62, (byte) 0x5E, (byte) 0x7E, (byte) 0xC6,
(byte) 0xF4, (byte) 0x4C, (byte) 0x42, (byte) 0xE9, (byte) 0xA6,
(byte) 0x37, (byte) 0xED, (byte) 0x6B, (byte) 0x0B, (byte) 0xFF,
(byte) 0x5C, (byte) 0xB6, (byte) 0xF4, (byte) 0x06, (byte) 0xB7,
(byte) 0xED, (byte) 0xEE, (byte) 0x38, (byte) 0x6B, (byte) 0xFB,
(byte) 0x5A, (byte) 0x89, (byte) 0x9F, (byte) 0xA5, (byte) 0xAE,
(byte) 0x9F, (byte) 0x24, (byte) 0x11, (byte) 0x7C, (byte) 0x4B,
(byte) 0x1F, (byte) 0xE6, (byte) 0x49, (byte) 0x28, (byte) 0x66,
(byte) 0x51, (byte) 0xEC, (byte) 0xE4, (byte) 0x5B, (byte) 0x3D,
(byte) 0xC2, (byte) 0x00, (byte) 0x7C, (byte) 0xB8, (byte) 0xA1,
(byte) 0x63, (byte) 0xBF, (byte) 0x05, (byte) 0x98, (byte) 0xDA,
(byte) 0x48, (byte) 0x36, (byte) 0x1C, (byte) 0x55, (byte) 0xD3,
(byte) 0x9A, (byte) 0x69, (byte) 0x16, (byte) 0x3F, (byte) 0xA8,
(byte) 0xFD, (byte) 0x24, (byte) 0xCF, (byte) 0x5F, (byte) 0x83,
(byte) 0x65, (byte) 0x5D, (byte) 0x23, (byte) 0xDC, (byte) 0xA3,
(byte) 0xAD, (byte) 0x96, (byte) 0x1C, (byte) 0x62, (byte) 0xF3,
(byte) 0x56, (byte) 0x20, (byte) 0x85, (byte) 0x52, (byte) 0xBB,
(byte) 0x9E, (byte) 0xD5, (byte) 0x29, (byte) 0x07, (byte) 0x70,
(byte) 0x96, (byte) 0x96, (byte) 0x6D, (byte) 0x67, (byte) 0x0C,
(byte) 0x35, (byte) 0x4E, (byte) 0x4A, (byte) 0xBC, (byte) 0x98,
(byte) 0x04, (byte) 0xF1, (byte) 0x74, (byte) 0x6C, (byte) 0x08,
(byte) 0xCA, (byte) 0x18, (byte) 0x21, (byte) 0x7C, (byte) 0x32,
(byte) 0x90, (byte) 0x5E, (byte) 0x46, (byte) 0x2E, (byte) 0x36,
(byte) 0xCE, (byte) 0x3B, (byte) 0xE3, (byte) 0x9E, (byte) 0x77,
(byte) 0x2C, (byte) 0x18, (byte) 0x0E, (byte) 0x86, (byte) 0x03,
(byte) 0x9B, (byte) 0x27, (byte) 0x83, (byte) 0xA2, (byte) 0xEC,
(byte) 0x07, (byte) 0xA2, (byte) 0x8F, (byte) 0xB5, (byte) 0xC5,
(byte) 0x5D, (byte) 0xF0, (byte) 0x6F, (byte) 0x4C, (byte) 0x52,
(byte) 0xC9, (byte) 0xDE, (byte) 0x2B, (byte) 0xCB, (byte) 0xF6,
(byte) 0x95, (byte) 0x58, (byte) 0x17, (byte) 0x18, (byte) 0x39,
(byte) 0x95, (byte) 0x49, (byte) 0x7C, (byte) 0xEA, (byte) 0x95,
(byte) 0x6A, (byte) 0xE5, (byte) 0x15, (byte) 0xD2, (byte) 0x26,
(byte) 0x18, (byte) 0x98, (byte) 0xFA, (byte) 0x05, (byte) 0x10,
(byte) 0x15, (byte) 0x72, (byte) 0x8E, (byte) 0x5A, (byte) 0x8A,
(byte) 0xAC, (byte) 0xAA, (byte) 0x68, (byte) 0xFF, (byte) 0xFF,
(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
(byte) 0xFF
</code></pre>

<p>I counted the bytes and they were exactly256 bytes (2048 bit) Prime. How do I resolve this ?</p>
","<p>The problem is that you are not using the correct <a href=""http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html"" rel=""nofollow"">BigInteger</a> constructor. The <a href=""http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#BigInteger-byte:A-"" rel=""nofollow"">BigInteger byte array constructor</a> is designed to reconstruct a BigInteger from the output of <a href=""http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#toByteArray--"" rel=""nofollow""><code>BigInteger.toByteArray()</code></a>. Java represents BigIntegers in byte arrays using something similar to a twos-complement scheme. As a result, a negative BigInteger is represented by a byte array whose high order byte (the 0'th byte of the array) is >= 128. A positive BigInteger is always represented by a byte array whose high-order byte is &lt; 128. If the true high-order byte of a positive BigInteger would be >= 128 then <a href=""http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#toByteArray--"" rel=""nofollow""><code>BigInteger.toByteArray()</code></a> emits a byte array with a leading 0 byte.</p>

<p>Thus you have two ways to solve your problem. You can prepend a zero byte to your array and use the same BigInteger constructor you have been using, or you can instead use the <a href=""http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#BigInteger-int-byte:A-"" rel=""nofollow"">BigInteger sign-magnitude constructor</a> with your byte array as is.</p>

<p>Here is an example using your byte array showing the differences.</p>

<pre><code>import java.math.BigInteger;

public class DhGroup14Toy {

    private static final byte[] DH_GRP_14_P = 
        {(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xC9, (byte) 0x0F,
            (byte) 0xDA, (byte) 0xA2, (byte) 0x21, (byte) 0x68, (byte) 0xC2,
            (byte) 0x34, (byte) 0xC4, (byte) 0xC6, (byte) 0x62, (byte) 0x8B,
            (byte) 0x80, (byte) 0xDC, (byte) 0x1C, (byte) 0xD1, (byte) 0x29,
            (byte) 0x02, (byte) 0x4E, (byte) 0x08, (byte) 0x8A, (byte) 0x67,
            (byte) 0xCC, (byte) 0x74, (byte) 0x02, (byte) 0x0B, (byte) 0xBE,
            (byte) 0xA6, (byte) 0x3B, (byte) 0x13, (byte) 0x9B, (byte) 0x22,
            (byte) 0x51, (byte) 0x4A, (byte) 0x08, (byte) 0x79, (byte) 0x8E,
            (byte) 0x34, (byte) 0x04, (byte) 0xDD, (byte) 0xEF, (byte) 0x95,
            (byte) 0x19, (byte) 0xB3, (byte) 0xCD, (byte) 0x3A, (byte) 0x43,
            (byte) 0x1B, (byte) 0x30, (byte) 0x2B, (byte) 0x0A, (byte) 0x6D,
            (byte) 0xF2, (byte) 0x5F, (byte) 0x14, (byte) 0x37, (byte) 0x4F,
            (byte) 0xE1, (byte) 0x35, (byte) 0x6D, (byte) 0x6D, (byte) 0x51,
            (byte) 0xC2, (byte) 0x45, (byte) 0xE4, (byte) 0x85, (byte) 0xB5,
            (byte) 0x76, (byte) 0x62, (byte) 0x5E, (byte) 0x7E, (byte) 0xC6,
            (byte) 0xF4, (byte) 0x4C, (byte) 0x42, (byte) 0xE9, (byte) 0xA6,
            (byte) 0x37, (byte) 0xED, (byte) 0x6B, (byte) 0x0B, (byte) 0xFF,
            (byte) 0x5C, (byte) 0xB6, (byte) 0xF4, (byte) 0x06, (byte) 0xB7,
            (byte) 0xED, (byte) 0xEE, (byte) 0x38, (byte) 0x6B, (byte) 0xFB,
            (byte) 0x5A, (byte) 0x89, (byte) 0x9F, (byte) 0xA5, (byte) 0xAE,
            (byte) 0x9F, (byte) 0x24, (byte) 0x11, (byte) 0x7C, (byte) 0x4B,
            (byte) 0x1F, (byte) 0xE6, (byte) 0x49, (byte) 0x28, (byte) 0x66,
            (byte) 0x51, (byte) 0xEC, (byte) 0xE4, (byte) 0x5B, (byte) 0x3D,
            (byte) 0xC2, (byte) 0x00, (byte) 0x7C, (byte) 0xB8, (byte) 0xA1,
            (byte) 0x63, (byte) 0xBF, (byte) 0x05, (byte) 0x98, (byte) 0xDA,
            (byte) 0x48, (byte) 0x36, (byte) 0x1C, (byte) 0x55, (byte) 0xD3,
            (byte) 0x9A, (byte) 0x69, (byte) 0x16, (byte) 0x3F, (byte) 0xA8,
            (byte) 0xFD, (byte) 0x24, (byte) 0xCF, (byte) 0x5F, (byte) 0x83,
            (byte) 0x65, (byte) 0x5D, (byte) 0x23, (byte) 0xDC, (byte) 0xA3,
            (byte) 0xAD, (byte) 0x96, (byte) 0x1C, (byte) 0x62, (byte) 0xF3,
            (byte) 0x56, (byte) 0x20, (byte) 0x85, (byte) 0x52, (byte) 0xBB,
            (byte) 0x9E, (byte) 0xD5, (byte) 0x29, (byte) 0x07, (byte) 0x70,
            (byte) 0x96, (byte) 0x96, (byte) 0x6D, (byte) 0x67, (byte) 0x0C,
            (byte) 0x35, (byte) 0x4E, (byte) 0x4A, (byte) 0xBC, (byte) 0x98,
            (byte) 0x04, (byte) 0xF1, (byte) 0x74, (byte) 0x6C, (byte) 0x08,
            (byte) 0xCA, (byte) 0x18, (byte) 0x21, (byte) 0x7C, (byte) 0x32,
            (byte) 0x90, (byte) 0x5E, (byte) 0x46, (byte) 0x2E, (byte) 0x36,
            (byte) 0xCE, (byte) 0x3B, (byte) 0xE3, (byte) 0x9E, (byte) 0x77,
            (byte) 0x2C, (byte) 0x18, (byte) 0x0E, (byte) 0x86, (byte) 0x03,
            (byte) 0x9B, (byte) 0x27, (byte) 0x83, (byte) 0xA2, (byte) 0xEC,
            (byte) 0x07, (byte) 0xA2, (byte) 0x8F, (byte) 0xB5, (byte) 0xC5,
            (byte) 0x5D, (byte) 0xF0, (byte) 0x6F, (byte) 0x4C, (byte) 0x52,
            (byte) 0xC9, (byte) 0xDE, (byte) 0x2B, (byte) 0xCB, (byte) 0xF6,
            (byte) 0x95, (byte) 0x58, (byte) 0x17, (byte) 0x18, (byte) 0x39,
            (byte) 0x95, (byte) 0x49, (byte) 0x7C, (byte) 0xEA, (byte) 0x95,
            (byte) 0x6A, (byte) 0xE5, (byte) 0x15, (byte) 0xD2, (byte) 0x26,
            (byte) 0x18, (byte) 0x98, (byte) 0xFA, (byte) 0x05, (byte) 0x10,
            (byte) 0x15, (byte) 0x72, (byte) 0x8E, (byte) 0x5A, (byte) 0x8A,
            (byte) 0xAC, (byte) 0xAA, (byte) 0x68, (byte) 0xFF, (byte) 0xFF,
            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
            (byte) 0xFF};

    public static void main(String[] args) throws Exception {

        BigInteger bad1 = new BigInteger(DH_GRP_14_P);
        BigInteger good1 = new BigInteger(1, DH_GRP_14_P);
        byte [] augmentedBytes = new byte[DH_GRP_14_P.length + 1];
        System.arraycopy(DH_GRP_14_P, 0, augmentedBytes, 1, DH_GRP_14_P.length);
        BigInteger good2 = new BigInteger(augmentedBytes);
        System.out.println(bad1);
        System.out.println(good1);
        System.out.println(good1.equals(good2));
        System.out.println(good1.isProbablePrime(50));

    }

}
</code></pre>

<p>The output is:</p>

<pre><code>-375962762246123711626161428575244919288335676123913432233536670577511994159344116570816223012193827739513685941295892241329166200826129908455464852399221571479961954311415857911811448906479927170863572543208032916411471816282939929662608171512069523761896175670948807549496521472891523674634075413613438850952413260397488155494376493989845498917437341434297119530075724469618920963199914531774956492590825946261921832765452432767164403516209782999137096145451001079860465649681054514172614217905576760949024270284588083855940299806145693407383904354238605196666010342535176157644001104014235140097
32317006071311007300338913926423828248817941241140239112842009751400741706634354222619689417363569347117901737909704191754605873209195028853758986185622153212175412514901774520270235796078236248884246189477587641105928646099411723245426622522193230540919037680524235519125679715870117001058055877651038861847280257976054903569732561526167081339361799541336476559160368317896729073178384589680639671900977202194168647225871031411336429319536193471636533209717077448227988588565369208645296636077250268955505928362751121174096972998068410554359584866583291642136218231078990999448652468262416972035911852507045361090559
true
true
</code></pre>
","364","<java><diffie-hellman>","1","2","2","2015-10-09 19:19:46","33011923","1","2","","","","2015-10-08 08:13:27",""
"33215740","Glassfish v2 can't find all ciphersuites","<p>I have 2 seemingly identical glassfish installations (installed using the same installer, same OS - SLES 11 SP2 - with the same installed packages and updates, same JRE/ JDK, same web applications deployed in the same way, similar keystores - different PKs, same method of getting/ signing, etc.), however, the two installations have 2 different sets of available ciphersuites. I believe that this is causing Server A to give a ""Server has a weak, ephemeral Diffie-Hellman public key"" error when visiting the application. </p>

<p>Server A:</p>

<pre><code>Available Common Ciphersuites:
        SSL_RSA_WITH_RC4_128_MD5
        SSL_RSA_WITH_RC4_128_SHA
        TLS_RSA_WITH_AES_128_SHA
        SSL_RSA_WITH_3DES_EDE_CBC_SHA

    Available Ephemeral Diffie-Hellman Ciphersuites:
        TLS_DHE_RSA_WITH_AES_128_CBC_SHA
        SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA
        TLS_DHE_DSS_WITH_AES_128_CBC_SHA
        SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA

    Available 40 bit and 56 bit Ciphersuites:
        SSL_WITH_DES_CBC_SHA
        SSL_DHE_RSA_WITH_DES_CBC_SHA
        SSL_DHE_DES_WITH_DES_CBC_SHA
        SSL_RSA_EXPORT_WITH_RC4_40_MD5
        SSL_RSA_EXPORT_WITH_DES40_CBC_SHA
        SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
        SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

    Available ECC Ciphersuites:
    none
</code></pre>

<p>Server B:</p>

<pre><code>Available Common Ciphersuites:
        TLS_RSA_WITH_AES_128_CBC_SHA
        SSL_RSA_WITH_RC4_128_SHA
        SSL_RSA_WITH_3DES_EDE_CBC_SHA
        SSL_RSA_WITH_RC4_128_MD5

    Available Ephemeral Diffie-Hellman Ciphersuites:
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
        TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
        TLS_DHE_RSA_WITH_AES_128_CBC_SHA
        TLS_ECDHE_RSA_WITH_RC4_128_SHA
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
        SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA
        TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
        TLS_DHE_DSS_WITH_AES_128_CBC_SHA
        SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA

    Available 40 bit and 56 bit Ciphersuites:
        none

    Available ECC Ciphersuites:
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
        TLS_ECDHE_RSA_WITH_RC4_128_SHA
        TLS_ECDH_ECDSA_WITH_RC4_128_SHA
        TLS_ECDH_RSA_WITH_RC4_128_SHA
        TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
        TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
        TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
        TLS_ECDHE_RSA_WITH_RC4_128_SHA
        TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
</code></pre>

<p>What could be causing this difference in available ciphersuites?</p>
","<p>It turns out that <code>asenv.conf</code> ({glassfish installation}/config/asenv.conf) was defining <code>AS_JAVA=...</code> and glassfish was using this instead of the version of java defined in the path and JAVA_HOME. Pointing <code>AS_JAVA</code> to the correct jre solved the issue.</p>
","363","<glassfish><certificate><suse><diffie-hellman><glassfish-2.x>","2","1","1","2015-10-27 19:17:00","33376684","0","","2852339","","2015-10-19 14:34:02","2015-10-19 13:29:18",""
"53153749","How to generate Diffie-Hellman parameters in golang","<p>Is there a Golang equivalent to the following openssl command?</p>

<p><code>openssl dhparam -out dh.pem 2048</code></p>

<p>I would like to be able to generate Diffie-Hellman parameters with golang and not need to invoke openssl.</p>
","","363","<go><diffie-hellman>","2","","0","2018-11-05 11:44:37","","1","","","","","2018-11-05 11:44:37",""
"9428342","node.js diffie-hellman-group1-sha1 error","<p>I'm trying to implement a diffie-hellman-group1-sha1 key exchange for my node.js implemenation of the SSH protocol.</p>

<p>I want to use the built in crypto module for this. My code:</p>

<pre><code>var hellman = crypto.createDiffieHellman(
""FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1""+
""29024E088A67CC74020BBEA63B139B22514A08798E3404DD""+
""EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245""+
""E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED""+
""EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381""+
""FFFFFFFFFFFFFFFF"",""hex"");
hellman.setPrivateKey(crypto.randomBytes(20));
hellman.generateKeys(); 
</code></pre>

<p>But node.js can't execute it. It throws the following error:
""Error: Not initialized""</p>

<p>Does anyone know what's going wrong?</p>
","<p>It seems to be a bug of node.js:
<a href=""https://github.com/joyent/node/issues/2338"" rel=""nofollow"">https://github.com/joyent/node/issues/2338</a></p>

<p>Node version 7.5 has included a solution to this, where one can get predefined diffieHellmans <code>using crypto.getDiffieHellman(""modp2"");</code></p>

<p>It was added in the following push request:
<a href=""https://github.com/joyent/node/pull/2638"" rel=""nofollow"">https://github.com/joyent/node/pull/2638</a></p>

<p>All predefined diffie hellmans can be watched here:
<a href=""https://gist.github.com/1899353"" rel=""nofollow"">https://gist.github.com/1899353</a></p>
","361","<node.js><diffie-hellman>","0","0","1","2012-02-24 10:19:45","9429027","0","","","","","2012-02-24 09:29:42",""
"10573344","Can we use Diffie-Hellman public key encrytion algorithm with asp.net login control?","<p>I am trying to find out the internals of login control in asp.net.
Does it uses some Public key encryption algorithm to exchange a key and then uses it for further communication as a symmetric key.</p>

<p>Also do we have our say in choosing the encryption algorithms like for ex i want to specifically use Diffie Hellman with login control. Is it possible and how can i achieve this?</p>
","<p>Disclaimer: I'm no cryptographer...</p>

<ul>
<li>The Login controls use ASP.Net Membership along with Forms Authentication <a href=""http://msdn.microsoft.com/en-us/library/ms178329.aspx"" rel=""nofollow"">by default</a>. </li>
<li>You can <a href=""http://msdn.microsoft.com/en-us/library/ms178329.aspx#the_login_control"" rel=""nofollow"">create your own auth mechanism</a></li>
<li>The default hash algorithm used in ASP.net Membership is <a href=""http://msdn.microsoft.com/en-us/library/1b9hw62f.aspx"" rel=""nofollow"">SHA1</a>. Yes, you have a choice. I've had to use MD5 in a migration project (if memory serves from phpBB to ASP.net) more than a few years back...</li>
<li>(see disclaimer) Elliptic Curve Diffie-Hellman (ECDiffieHellman) info
<ul>
<li>In <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.cryptoconfig.aspx"" rel=""nofollow"">config</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.ecdiffiehellmancng.aspx"" rel=""nofollow"">ECDiffieHellman</a></li>
</ul></li>
</ul>

<p>hth...</p>
","360","<asp.net><login-control><diffie-hellman>","0","0","1","2012-05-13 19:31:21","10574573","0","","","","","2012-05-13 16:31:33",""
"33198362","Using public key coordinate with Crypto++'s ECDH class","<p>I'm using crypto++ for ECDH key agreement</p>

<pre><code>ECDH.Agree(key, privateKey, outherpublicKey);
</code></pre>

<p>Given that for public key I have only X and Y coordinates. How to generate publicKey from this values ?</p>

<pre><code>ECDH.Agree(key,privateKey, getPublicKey(X,Y))
</code></pre>

<p>Thanks in advance</p>
","<blockquote>
  <p>Given that for public key I have only X and Y coordinates. How to generate publicKey from this values?<br>
  <code>ECDH.Agree(key,privateKey, getPublicKey(X,Y))</code></p>
</blockquote>

<p><code>{x,y}</code> is a point on the curve, but its never been easy to work with it directly.</p>

<p>This is all we really want to do but it does not work. The problem is <code>ECDH::Domain</code> are only domain parameters. The public point and the private exponent are layered on top.</p>

<pre><code>OID curve = ASN1::secp256r1();
DL_GroupParameters_EC&lt;ECP&gt; params(curve);

Integer x(""..."");
Integer y(""..."");
ECP::Point q(x, y);

DL_PublicKey_EC&lt;ECP&gt; pubKey;
pubKey.Initialize(params, q);

ECDH &lt; ECP &gt;::Domain theirs(pubKey);
</code></pre>

<p>To further complicate matters, the keys produced by the ECDH protocol are temporary or ephemeral. They are not meant to be persisted; rather, they are meant to be used once and discarded. So Crypto++ does not make it easy to persist them (by, say, providing a <code>DEREncode</code>).</p>

<p><strong><em>Analysis</em></strong></p>

<p>To use the <code>{x,y}</code> coordinate, we need to figure out how the library is using it. The ephemeral public and private keys are created in <a href=""http://www.cryptopp.com/docs/ref/pubkey_8h_source.html#l01380"" rel=""nofollow""><code>pubkey.h</code></a> around line 1380. The code for them is below:</p>

<pre><code>void GeneratePrivateKey(RandomNumberGenerator &amp;rng, byte *privateKey)
{
    Integer x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());
    x.Encode(privateKey, PrivateKeyLength());
}

void GeneratePublicKey(RandomNumberGenerator &amp;rng, const byte *privateKey, byte *publicKey)
{
    const DL_GroupParameters&lt;T&gt; &amp;params = GetAbstractGroupParameters();
    Integer x(privateKey, PrivateKeyLength());
    Element y = params.ExponentiateBase(x);
    params.EncodeElement(true, y, publicKey);
}
</code></pre>

<p>The line of interest above is the <code>params.EncodeElement(true, y, publicKey)</code>. To see what's going on there, we need to look at <a href=""http://www.cryptopp.com/docs/ref/eccrypto_8h_source.html#l00061"" rel=""nofollow""><code>eccrypto.h</code></a> around line 70, and note that <code>reversible</code> is <code>true</code>:</p>

<pre><code>void EncodeElement(bool reversible, const Element &amp;element, byte *encoded)
{
    if (reversible)
        GetCurve().EncodePoint(encoded, element, m_compress);
    else
        element.x.Encode(encoded, GetEncodedElementSize(false));
}
</code></pre>

<p><code>params.EncodeElement</code> calls <code>ECP::EncodePoint</code>. To see what that does we can examine <a href=""http://www.cryptopp.com/docs/ref/ecp_8cpp_source.html#l00118"" rel=""nofollow""><code>ecp.cpp</code></a> around line 120. The routine writes a uncompressed point, but blocks <code>x</code> and <code>y</code> on the maximum size of the public element, which should be the field size or the subgroup order.</p>

<pre><code>void ECP::EncodePoint(BufferedTransformation &amp;bt, const Point &amp;P, bool compressed)
{
    if (P.identity)
        NullStore().TransferTo(bt, EncodedPointSize(compressed));
    else if (compressed)
    {
        bt.Put(2 + P.y.GetBit(0));
        P.x.Encode(bt, GetField().MaxElementByteLength());
    }
    else
    {
        unsigned int len = GetField().MaxElementByteLength();
        bt.Put(4);      // uncompressed
        P.x.Encode(bt, len);
        P.y.Encode(bt, len);
    }
}
</code></pre>

<p>Don't worry too much about the <code>BufferedTransformation</code>. There are ways to turn a <code>byte[]</code> into one, and it happened before the code shown above. If you trace the code, you will see its transformed via an <code>ArraySource</code>:</p>

<pre><code>byte myArray[PublicEphemeralKeyLength()];
ArraySource as(myArray, COUNTOF(myArray));
</code></pre>

<p>Above, <code>as</code> is a <code>BufferedTransformation</code> that wraps the <code>byte[]</code> you passed into the function.</p>

<p>The final open question is the maximum size of the field element. That appears to be the modulus size less one, in bytes:</p>

<pre><code>$ grep -I -A 1 MaxElementByteLength modarith.h 
    unsigned int MaxElementByteLength() const
        {return (m_modulus-1).ByteCount();}
</code></pre>

<p><strong><em>Agreement</em></strong></p>

<p>Given the above information, here's what you should do. You need to supply the values for <code>x</code> and <code>y</code> in <code>ECP::Point q(x,y)</code>. They are just Crypto++ Integers.</p>

<pre><code>OID curve = ASN1::secp256r1();
DL_GroupParameters_EC&lt;ECP&gt; params(curve);

size_t size = params.GetEncodedElementSize(true);
vector&lt;byte&gt; othersPublicKey(size);

ECP::Point q(x,y);
params.EncodeElement(true, q, &amp;othersPublicKey[0]);
</code></pre>

<p>Then you can call:</p>

<pre><code>ecdh.Agree(key, myPrivateKey, &amp;othersPublicKey[0]);
</code></pre>

<p>One note: <code>params.GetEncodedElementSize(true)</code> should equal <code>PublicEphemeralKeyLength()</code>. If they are not equal, then something is wrong.</p>

<hr>

<p>If you need to modify compression, then you can:</p>

<pre><code>params.SetPointCompression(true);
</code></pre>

<hr>

<p>I'll get this added to Crypto++'s <a href=""https://cryptopp.com/wiki/Elliptic_Curve_Diffie-Hellman"" rel=""nofollow"">Elliptic Curve Diffie-Hellman</a> wiki page so others don't have to go rummaging for it.</p>
","348","<c++><crypto++><elliptic-curve><diffie-hellman>","1","0","1","2015-10-19 17:46:49","33206001","3","","608639","","2015-10-19 17:46:49","2015-10-18 13:19:28",""
"33505223","Diffie Helman key agreement on do phase, incompatible parameters","<p>I send a Diffie Helman public key in a byte array through a socket and store it in a file, when I need the key I transform it using the key factory but when I'm going to combine my private key and the public key of my partner on key agreement, doPhase function it give me a exception of incompatible parameters.</p>

<pre><code>public byte[] createMac(byte[] fileBytes, String nick){
    byte[] mac = null;
    byte[] digest;
    try {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(fileBytes);
        digest = md.digest();

        KeyFactory keyFactory = KeyFactory.getInstance(""DH"");

        byte[] myPrivateKey = Files.readAllBytes(Paths.get(dirMyKeys+""//dhPrivateKey.txt""));
        PrivateKey dhPrivKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(myPrivateKey));


        byte[] myPublicKey = Files.readAllBytes(Paths.get(dirKeys+""/""+nick+""DhPublicKey.txt""));
        System.out.println(dirKeys+""/""+nick+""DhPublicKey.txt"");
        PublicKey dhPubKey = keyFactory.generatePublic(new X509EncodedKeySpec(myPublicKey));

        SecretKey secretKey = combine(dhPrivKey, dhPubKey);

        Cipher cipher = Cipher.getInstance(""AES"");
        System.out.println( ""\nStart decryption"" );
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        mac = cipher.doFinal(digest);
        System.out.println( ""Finish decryption: "" );

        return mac;

    } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | NoSuchPaddingException ex) {
        Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);
    }
    return mac;
}

private static SecretKey combine(PrivateKey private1, PublicKey public1) throws NoSuchAlgorithmException, InvalidKeyException  {
    KeyAgreement ka = KeyAgreement.getInstance(""DH"");
    ka.init(private1);
    //error on this line
    ka.doPhase(public1, true);
    SecretKey secretKey = ka.generateSecret(""DES"");
    return secretKey;
}
</code></pre>

<p>This is the exception:</p>

<pre><code>java.security.InvalidKeyException: Incompatible parameters
        at com.sun.crypto.provider.DHKeyAgreement.engineDoPhase(DHKeyAgreement.java:199)
        at javax.crypto.KeyAgreement.doPhase(KeyAgreement.java:567)
        at safetalk_client.Client.combine(Client.java:279)
        at safetalk_client.Client.createMac(Client.java:260)
        at safetalk_client.Client.sendFile(Client.java:234)
        ...
</code></pre>
","<p>I don't have experience with the api, but it sounds like its expecting a different input type. There is a specific type of private and public key class for diffie-Hellman, maybe its needs those instead of the more generic sounding publickey and privatekey classes: </p>

<p><a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/interfaces/DHPublicKey.html"" rel=""nofollow"">https://docs.oracle.com/javase/7/docs/api/javax/crypto/interfaces/DHPublicKey.html</a></p>

<p><a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/interfaces/DHPrivateKey.html"" rel=""nofollow"">https://docs.oracle.com/javase/7/docs/api/javax/crypto/interfaces/DHPrivateKey.html</a></p>

<p>let me know if it works. </p>
","348","<java><diffie-hellman>","2","0","1","2018-04-17 01:31:57","","0","","1033581","","2018-04-17 01:31:57","2015-11-03 17:15:05",""
"48699428","Doing ECDHE key exchange using C#","<p>I am trying to do ECDHE key exchange over TLS 1.2 using .net. The server is responding with a server_key_exchange message, which begins with 04, so I guess it is unencrypted. From my understanding the first 32 bits of the message are considered as a value X, and the next 32 bits are considered as a value Y. Using these, and the elliptic curve (say secp256r1), the value of public key of server is created. I am referring to the following python code from <a href=""https://github.com/lpoulain/OpenTLS/blob/master/KeyExchange.py"" rel=""nofollow noreferrer"">OpenTLS</a>:</p>

<pre><code>class ECDHE_RSA_Key_Exchange: 
    def __init__(self, server_key_exchange): 
        curve_code = bytes_to_hex(server_key_exchange[5:7]) 
        print('Elliptic curve: ' + elliptic_curves[curve_code]) 
        self.curve = reg.get_curve(elliptic_curves[curve_code]) 
        x = bytes_to_int(server_key_exchange[9:9+32]) 
        y = bytes_to_int(server_key_exchange[9+32:9+64]) 
        self.server_pubKey = ec.Point(self.curve, x, y) 
</code></pre>

<p>Was looking at C# resources for achieving the same. Below is some of the porting that I could do:</p>

<pre><code>int skeLen = this.sKeyExch_hs[7];
skeLen = skeLen - 1;

byte[] sPubKey = new byte[skeLen];
Buffer.BlockCopy(this.sKeyExch_hs, 9, sPubKey, 0, skeLen);

ECDiffieHellmanCng ecdhCngClient = new ECDiffieHellmanCng(256);

this.client_pub_key = ecdhCngClient.PublicKey.ToByteArray();

byte[] i = {0x04};

this.client_pub_key = this.client_pub_key.Skip(8).ToArray();

this.client_pub_key = i.Concat(this.client_pub_key).ToArray();

byte[] x = {0x45, 0x43, 0x4B, 0x31, 0x20, 0, 0, 0};

sPubKey = x.Concat(sPubKey).ToArray();

ECDiffieHellmanPublicKey serverKey = ECDiffieHellmanCngPublicKey.FromByteArray(sPubKey, CngKeyBlobFormat.EccPublicBlob);

byte[] symmKey = ecdhCngClient.DeriveKeyMaterial(serverKey);

this.pre_master_secret = symmKey;

this.pre_master_secret_list = new List&lt;byte&gt;(this.pre_master_secret);

byte client_pub_key_len = (byte) this.client_pub_key.Length;

this.ckeMessage = new List&lt;byte&gt;();
this.ckeMessage.Add(client_pub_key_len);
this.ckeMessage.AddRange(this.client_pub_key);

return this.ckeMessage;
</code></pre>
","","344","<c#><diffie-hellman>","3","","0","2018-02-18 11:29:04","","5","1","9293518","","2018-02-18 11:29:04","2018-02-09 05:43:55",""
"43661747","I have general questions about Diffie Hellman parameters","<p>I am currently working on Diffie-Hellman Key exchange and use the key pairs for AES.</p>

<p>Q1) When I choose prime for Diffie-Hellman from RFC 3526 such as 1536, 2048, 3072 MODP groups, is bigger prime safer? could you explain me about it?</p>

<p>Q2) Each group all has generator of 2, should I always use 2 as generator if I use standard prime group from RFC3526??</p>

<p>Q3) I am using the key pairs from Diffie-Helman for AES. I understand that AES's key length can be 128, 192 or 256 bits. Should I choose specific prime or generator in Diffie-Hellman to meet the key lengths of 128, 192 or 256 bit for AES??</p>

<p>Sorry ask three questions in a single post but I believe that they are all related questions. Thanks!!</p>
","<p>In <a href=""https://www.ietf.org/rfc/rfc3526.txt"" rel=""nofollow noreferrer"">RFC 3528</a>, they address your questions in section 8, Security Considerations. I will attempt to restate/explain the answers here:</p>

<ol>
<li>In short, yes, the bigger prime is ""safer"". Assuming that Diffie-Hellman is not fundamentally broken, the difficulty of ""cracking"" the exchange, i.e. finding out the shared key the exchange establishes, scales directly with the size of the primes used. However, one additional bit of prime does not equal one additional bit of ""key strength"" in AES terms. This is because, simply, not every number is prime. In AES-128, for example, we expect the key to be a string of 128 random bits, meaning that the key could be any one of 2^128 possibilities. Yet we would never use a 128-bit prime in Diffie-Hellman (or RSA, or anything else that requires primes) simply because there are much fewer than 2^128 primes that are 128 bits in length. So if we used a 128-bit prime, an attacker wouldn't have to try all of the 2^128 possibilities, they would only have to try the much smaller number of 128-bit primes. Therefore, in order to say we have the same ""key-strength"" as AES-x, we need to use much, much larger primes, so that we have a number of possible primes in the range of 2^x.</li>
<li>I would say yes. When in doubt, follow the reference implementation; in this case, use 2 as the generator.</li>
<li>The table in section 8 shows the ""strength estimate"" of the various prime groups provided; I would always take the lower estimate of their strength. So for AES-128, use at least the 3072-bit group; for AES-192, at least the 8192-bit group. </li>
</ol>
","339","<security><aes><diffie-hellman>","0","1","1","2017-04-27 16:31:23","","0","","","","","2017-04-27 15:16:34",""
"20476365","Need to create DHPublicKey from y, p, g as BigIntegers","<p>I need a DHPublicKey to encrypt some data.
Therefore I have been provided with all the needed parameters as BigIntegers (y, p, g).
Unfortunately I don't see a straight way for creating a public key object from these parameters that would fit the DHPublicKey interface.
Any idea?</p>
","<pre><code>    KeyFactory keyFactory;
    KeyPairGenerator kpg;
    DHPublicKey originalDhPubKey, fromSpecsDhPubKey;
    DHPublicKeySpec dhPubKeySpecs;
    KeyPair kp;
    BigInteger p, g, y;

    // generate a DH key pair
    kpg = KeyPairGenerator.getInstance(""DH"");
    kp = kpg.generateKeyPair();

    // get the DH public key
    originalDhPubKey = (DHPublicKey) kp.getPublic();
    // get P, G and Y specs
    p = originalDhPubKey.getParams().getP();
    g = originalDhPubKey.getParams().getG();
    y = originalDhPubKey.getY();

    // get a DH KeyFactory
    keyFactory = KeyFactory.getInstance(""DH"");

    // create a DHPublicKeySpec with the specs you have
    dhPubKeySpecs = new DHPublicKeySpec(y, p, g);

    // get the DHPublicKey
    fromSpecsDhPubKey = (DHPublicKey) keyFactory.generatePublic(dhPubKeySpecs);

    // Check that the DH public values are equal
    System.out.println(originalDhPubKey.getY().equals(fromSpecsDhPubKey.getY()));
</code></pre>
","338","<java><public-key-encryption><diffie-hellman>","1","2","1","2014-03-28 15:48:25","22717472","0","1","","","","2013-12-09 17:06:21",""
"29483924","Is there any way to specify the range for the Diffie-Hellman prime using javax.net.ssl.SSLServerSocket?","<p>I'm trying to reproduce the issue that was raised in <a href=""https://stackoverflow.com/questions/6851461/java-why-does-ssl-handshake-give-could-not-generate-dh-keypair-exception"">Java: Why does SSL handshake give &#39;Could not generate DH keypair&#39; exception?</a>.</p>

<p>I have a log that shows an exception with this cause:</p>

<pre><code>Caused by: javax.net.ssl.SSLException: java.lang.RuntimeException: Could not generate DH keypair
    at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1886)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1844)
    at sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1827)
    at sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1753)
    at sun.security.ssl.AppOutputStream.write(AppOutputStream.java:127)
    at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)
    at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)
    at org.apache.axis2.transport.http.AxisRequestEntity.writeRequest(AxisRequestEntity.java:94)
    ... 27 more
Caused by: java.lang.RuntimeException: Could not generate DH keypair
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:136)
    at sun.security.ssl.ClientHandshaker.serverKeyExchange(ClientHandshaker.java:621)
    at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:205)
    at sun.security.ssl.Handshaker.processLoop(Handshaker.java:868)
    at sun.security.ssl.Handshaker.process_record(Handshaker.java:804)
    at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1016)
    at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1312)
    at sun.security.ssl.SSLSocketImpl.writeRecord(SSLSocketImpl.java:702)
    at sun.security.ssl.AppOutputStream.write(AppOutputStream.java:122)
    ... 30 more
Caused by: java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 1024 (inclusive)
    at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
    at java.security.KeyPairGenerator$Delegate.initialize(KeyPairGenerator.java:658)
    at sun.security.ssl.DHCrypt.&lt;init&gt;(DHCrypt.java:127)
    ... 38 more
</code></pre>

<p>I'm using Axis2 to call a web service. I also have the ""Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files"" in jre/lib/security (but as someone mentioned on the other post this didn't work for them).</p>

<p>For reproducing this issue I'm trying to host a web service in a separate deployment with a similar environment (also using Axis2). This has a custom SSLServerSocketFactory which is creating and configuring the SSLServerSocket.</p>

<p>Using Wireshark (and also javax.net.debug JVM argument) I can see that the cipher suite that is negotiated is TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA but the Prime DH Server Param in the ServerKeyExchange is only 96 bytes (768 bits).</p>

<p>Is there any way I can configure the SSLServerSocket to use a larger prime during the handshake?</p>

<p>I'm guessing the key is being generated by the security provider for RSA from the JRE. Do I need to add my own provider and add it to jre/lib/security/java.security?</p>

<p>Appologies if this is a silly question, I'm new to DHE an Cipher Suites in general. I just need to know enough to get the server test to work (I'm not touching the client implementation).</p>
","<p>So with the push in the right direction from EJP I eventually managed to track down exactly where the strength (and subsequently the DH parameters) is determined. It is indeed in the JRE (specifically in the ServerHandshaker).</p>

<p>Using the security providers with an older JRE with the strength limitation (as mentioned in the original post) will not work here. While using other security providers will probably prevent this error client side the strength is already determined before the implementation of the KeyPairGenerator is initialized.</p>

<p>As a side note I didn't bother upgrading the JRE to reproduce this. I just added the BouncyCastle JCE provider with debug info, put a breakpoint in the org.bouncycastle.jcajce.provider.asymmetric.dh.KeyPairGeneratorSpi.initialize(int, SecureRandom) method and manually changed the strength. This was good enough for my tests.</p>
","330","<java><ssl><rsa><diffie-hellman><public-key-exchange>","0","0","1","2015-04-08 00:59:41","","5","0","-1","","2017-05-23 12:22:11","2015-04-07 04:44:51",""
"21157722","how to get Diffie–Hellman key exchange parameters?","<p>I want to decrypt https stream in my https server. I have succeeded in decrypting it which used RSA secret exchange when i have private key. But I dont know how to descryt it when it uses DHE for secret exchange   because I dont have any parameters.how to get Diffie–Hellman key exchange parameters?</p>
","<p>This should not be possible. The whole idea behind forward secrecy is that you use Diffie-Hellman key exchange because this way a captured session cannot be decrypted later, even if an attacker gets access to the private key of the certificate.</p>
","322","<ssl><encryption><diffie-hellman>","1","3","2","2014-01-16 20:17:38","","0","1","1395034","","2014-01-16 09:34:19","2014-01-16 09:19:34",""
"21157722","how to get Diffie–Hellman key exchange parameters?","<p>I want to decrypt https stream in my https server. I have succeeded in decrypting it which used RSA secret exchange when i have private key. But I dont know how to descryt it when it uses DHE for secret exchange   because I dont have any parameters.how to get Diffie–Hellman key exchange parameters?</p>
","<p>The ""E"" in DHE is for <em>ephemeral.</em> It means transient, fleeting, or temporary. The key material that you need to decrypt the conversation is not permanently stored anywhere. It's generated for a single TLS session and then discarded, ensuring that no one, even the original parties, can retroactively decrypt the conversation.</p>
","322","<ssl><encryption><diffie-hellman>","1","3","2","2014-01-16 20:17:38","","0","1","1395034","","2014-01-16 09:34:19","2014-01-16 09:19:34",""
"50268041","Diffie-Hellman key exchange using OpenSSL in Delphi","<p>I want to implement Diffie-Hellman key exchange into my existing protocol. I've searched quite a few sites on this topic and most I could get is ""you exchange the DH parameters between parties and that's all"". It was clearly not enough information on the topic or I was looking for at a wrong place.</p>

<p>After a couple of days of work I found good OpenSSL header files for Delphi (<a href=""https://github.com/Arvur/OpenSSL-Delphi"" rel=""nofollow noreferrer"">https://github.com/Arvur/OpenSSL-Delphi</a>). Using this headers, source code from OpenSSL and a couple of example programs I've created a full Diffie-Hellman key exchange from generating DH parameters and public keys to getting a shared secret. For exchange itself I used simple files, but it can be used in any way (like sockets).</p>

<pre><code>procedure CommonSecretKeyGeneration;
var parameters_context:PEVP_PKEY_CTX;
key_generation_context:PEVP_PKEY_CTX;
key_generation_context2:PEVP_PKEY_CTX;
shared_context1:PEVP_PKEY_CTX;
shared_context2:PEVP_PKEY_CTX;
parameters:PEVP_PKEY;
parameters2:PEVP_PKEY;
private_key:PEVP_PKEY;
private_key2:PEVP_PKEY;
public_key:PEVP_PKEY;
public_key2:PEVP_PKEY;
bio_file:PBIO;
keylen:cardinal;
arr:array of byte;
str:string;
i:integer;
begin
  SSL_InitEVP;
  SSL_InitBIO;
  SSL_InitPEM;

  Log('-------------Generating parameters---------------');
  parameters_context:=EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nil);
  if parameters_context&lt;&gt;nil then Log('Context for parameters created')
  else
  begin
    Log('Failed to generate parameters context');
    exit;
  end;

  i:=EVP_PKEY_paramgen_init(parameters_context);
  if i=1 then Log('Parameter context init done')
  else
  begin
    Log('Error initializing parameter context, return='+inttostr(i));
    exit;
  end;

  //equal to EVP_PKEY_CTX_set_dh_paramgen_prime_len(parameters_context, 1024)
  i:=EVP_PKEY_CTX_ctrl(parameters_context, EVP_PKEY_DH, EVP_PKEY_OP_PARAMGEN, EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN, 1024, nil);
  if i=1 then Log('Setting prime length done')
  else
  begin
    Log('Error setting prime length, return='+inttostr(i));
    exit;
  end;

  i:=EVP_PKEY_paramgen(parameters_context,@parameters);
  if i=1 then Log('Generation of parameters sucsessful')
  else
  begin
    Log('Error while generating parameters, return='+inttostr(i));
    exit;
  end;

  Log('-------------Output parameters to file---------------');
  //writing parameters to file
  bio_file:=BIO_new_file('C:\DH_parameters_test.pem', 'w');
  i:=PEM_write_bio_Parameters(bio_file,parameters);
  Log('PEM write return='+inttostr(i));
  BIO_free_all(bio_file);

  Log('-------------Client reading parameters---------------');
  //sending parameters via sockets
  //reading parameters
  bio_file:=BIO_new_file('C:\DH_parameters_test.pem', 'r');
  parameters2:=PEM_read_bio_Parameters(bio_file,nil);
  BIO_free_all(bio_file);
  if parameters2&lt;&gt;nil then Log('Readed parameters sucsess for client')
  else
  begin
    Log('Error reading parameters');
    exit;
  end;

  Log('-------------Generating private/public keys on server---------------');
  //making a key on server
  key_generation_context:=EVP_PKEY_CTX_new(parameters, nil);
  if key_generation_context&lt;&gt;nil then Log('Created key generation context')
  else
  begin
    Log('Error creating key generation context');
    exit;
  end;

  i:=EVP_PKEY_keygen_init(key_generation_context);
  if i=1 then Log('Initialized key generation sucsessfully')
  else
  begin
    Log('Error initializing key generation, return='+inttostr(i));
    exit;
  end;

  i:=EVP_PKEY_keygen(key_generation_context, @private_key);
  if i=1 then Log('Generated keys')
  else
  begin
    Log('Error generating keys, return='+inttostr(i));
    exit;
  end;

  Log('-------------Generating private/public keys on client---------------');
  //making key on client
  key_generation_context2:=EVP_PKEY_CTX_new(parameters2, nil);
  if key_generation_context&lt;&gt;nil then Log('Created key generation context on client')
  else
  begin
    Log('Error creating key generation context on client');
    exit;
  end;

  i:=EVP_PKEY_keygen_init(key_generation_context2);
  if i=1 then Log('Initialized key generation sucsessfully on client')
  else
  begin
    Log('Error initializing key generation on client, return='+inttostr(i));
    exit;
  end;

  i:=EVP_PKEY_keygen(key_generation_context2, @private_key2);
  if i=1 then Log('Generated keys on client')
  else
  begin
    Log('Error generating keys, return='+inttostr(i));
    exit;
  end;

  Log('-------------Public key exchange---------------');
  Log('-------------Outputing public key on server---------------');
  //outputing public keys
  bio_file:=BIO_new_file('C:\public_key1.pem', 'w');
  i:=PEM_write_bio_PUBKEY(bio_file,private_key);
  Log('PEM write return='+inttostr(i));
  BIO_free_all(bio_file);

  Log('-------------Outputing public key on client---------------');
  bio_file:=BIO_new_file('C:\public_key2.pem', 'w');
  i:=PEM_write_bio_PUBKEY(bio_file,private_key2);
  Log('PEM write return='+inttostr(i));
  BIO_free_all(bio_file);

  //public key exchange

  Log('-------------Reading public key1 (for client)---------------');
  //reading public keys
  bio_file:=BIO_new_file('C:\public_key1.pem', 'r');
  public_key:=PEM_read_bio_PUBKEY(bio_file,nil,nil,nil);
  BIO_free_all(bio_file);
  if public_key&lt;&gt;nil then Log('Readed public key1 sucsessfully')
  else
  begin
    Log('Error reading public key1');
    exit;
  end;

  Log('-------------Reading public key2 (for server)---------------');
  bio_file:=BIO_new_file('C:\public_key2.pem', 'r');
  public_key2:=PEM_read_bio_PUBKEY(bio_file,nil,nil,nil);
  BIO_free_all(bio_file);
  if public_key2&lt;&gt;nil then Log('Readed public key2 sucsessfully')
  else
  begin
    Log('Error reading public key2');
    exit;
  end;

  Log('-------------Calculating secret on server---------------');
  shared_context1:=EVP_PKEY_CTX_new(private_key,nil);
  if shared_context1&lt;&gt;nil then Log('Created shared context for key1')
  else
  begin
    Log('Error creating shared context for key1');
    exit;
  end;

  i:=EVP_PKEY_derive_init(shared_context1);
  if i=1 then Log('Derive init sucsessful on server')
  else
  begin
    Log('Error while initializing derive on server, return='+inttostr(i));
    exit;
  end;

  i:=EVP_PKEY_derive_set_peer(shared_context1,public_key2);
  if i=1 then Log('Set peer on server done')
  else
  begin
    Log('Error setting peer on server');
    exit;
  end;

  keylen:=0;
  Log('Before query secret key length='+inttostr(keylen));
  i:=EVP_PKEY_derive(shared_context1,nil,cardinal(@keylen));
  if i=1 then Log('Query secret key length sucsessful, len='+inttostr(keylen))
  else
  begin
    Log('Error query secret key length');
    exit;
  end;

  setlength(arr,keylen);
  FillChar(arr[0],length(arr),0);
  i:=EVP_PKEY_derive(shared_context1,@arr[0],cardinal(@keylen));
  if i=1 then
  begin
    Log('Output secret key sucsessful, len='+inttostr(keylen));
    str:='';
    for i:=0 to length(arr)-1 do
      str:=str+inttohex(arr[i],2);
    Log('Secret on server='+str);
  end
  else
  begin
    Log('Error query secret key');
    exit;
  end;

  Log('-------------Calculating secret on client---------------');
  shared_context2:=EVP_PKEY_CTX_new(private_key2,nil);
  if shared_context1&lt;&gt;nil then Log('Created shared context for key2')
  else
  begin
    Log('Error creating shared context for key2');
    exit;
  end;

  i:=EVP_PKEY_derive_init(shared_context2);
  if i=1 then Log('Derive init sucsessful on client')
  else
  begin
    Log('Error while initializing derive on client, return='+inttostr(i));
    exit;
  end;

  i:=EVP_PKEY_derive_set_peer(shared_context2,public_key);
  if i=1 then Log('Set peer on client done')
  else
  begin
    Log('Error setting peer on client');
    exit;
  end;

  keylen:=0;
  Log('Before query secret key length='+inttostr(keylen));
  i:=EVP_PKEY_derive(shared_context2,nil,cardinal(@keylen));
  if i=1 then Log('Query secret key length sucsessful, len='+inttostr(keylen))
  else
  begin
    Log('Error query secret key length');
    exit;
  end;

  setlength(arr,keylen);
  FillChar(arr[0],length(arr),0);
  i:=EVP_PKEY_derive(shared_context2,@arr[0],cardinal(@keylen));
  if i=1 then
  begin
    Log('Output secret key sucsessful, len='+inttostr(keylen));
    str:='';
    for i:=0 to length(arr)-1 do
      str:=str+inttohex(arr[i],2);
    Log('Secret on client='+str);
  end
  else
  begin
    Log('Error query secret key');
    exit;
  end;

  Log('===============DONE================');
end;
</code></pre>

<p>The question is:  </p>

<ol>
<li>Did I miss any essential part of DH key exchange? Is this enought to guarantee that both parties will have same secret key?  </li>
</ol>
","","316","<delphi><openssl><diffie-hellman>","0","","0","2018-05-10 10:10:20","","4","","9769024","","2018-05-10 10:10:20","2018-05-10 07:46:24",""
"9372424","Prime's notation in RFC3526 about Diffie Hellman Key Exchange","<p>In RFC3526, the prime is presented by
2^1536 - 2^1472 - 1 + 2^64 * { [2^1406 pi] + 741804 } form</p>

<p>I wanna know the ""[2^1406 pi]"" part means what</p>

<p>THKS</p>
","<p>The [] notation represents the greatest integer or <a href=""http://en.wikipedia.org/wiki/Floor_function"" rel=""nofollow"">floor</a> function. Therefore [2^1406 pi] means multiply pi (3.141...) by 2^1406 and throw away the fractional part. Enter <code>Floor[2^1406 * Pi]</code> into <a href=""http://www.wolframalpha.com/"" rel=""nofollow"">Wolfram Alpha</a> to see the result.</p>
","310","<diffie-hellman>","0","0","1","2012-02-22 13:05:35","9395341","0","","","","","2012-02-21 05:00:35",""
"3637995","ColdFusion 8 Diffie-Helman Encryption","<p>I am integrating with a 3rd party that requires I use the Diffie-Hellman encryption algorithm. The CF docs <a href=""http://livedocs.adobe.com/coldfusion/8/htmldocs/help.html?content=functions_e-g_01.html"" rel=""nofollow noreferrer"">indicate that this is a supported algorithm</a>.</p>

<p>When I attempt to call <code>Encrypt()</code> with either ""Diffie-Helman"" or ""DH"" I get the error message: ""The Diffie-Hellman algorithm is not supported by the Security Provider you have chosen.""</p>

<p>Is it possible to configure CF to use a different Security Provider that would include DH? Or, Is it possible to use java objects directly to accomplish this?</p>
","<p>The Diffie-Hellman algorithm is only supported by Enterprise edition.<br>
<em>(this is documented in the page you linked to, but it's not entirely clear)</em></p>

<p>If you only have Standard edition then you'll need to find an <a href=""http://www.google.com/search?q=Diffie-Hellman%20java"" rel=""nofollow noreferrer"">existing Java implementation</a> you can use with <code>createObject('java','...')</code>, or maybe reimplement one with pure CFML.</p>

<p>If you do the latter, it would be great to share the code on <a href=""http://riaforge.org/"" rel=""nofollow noreferrer"">riaforge</a>/<a href=""http://github.com/"" rel=""nofollow noreferrer"">github</a>/wherever, so other CFML users can benefit.</p>
","307","<java><encryption><coldfusion><coldfusion-8><diffie-hellman>","2","4","1","2010-09-05 20:13:51","","0","","751","","2010-09-05 20:13:51","2010-09-03 17:12:01",""
"49805714","Using DER key from Java in mbedtls Diffie-Hellman","<p>I have a Java application that is producing keys for a Diffie-Hellman key exchange. These keys are generated, and the public key is exported as follows:</p>

<pre><code>/*
 * Alice creates her own DH key pair with 2048-bit key size
 */
System.out.println(""ALICE: Generate DH keypair ..."");
KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(""DH"");
aliceKpairGen.initialize(2048);
KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

// Alice creates and initializes her DH KeyAgreement object
System.out.println(""ALICE: Initialization ..."");
KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(""DH"");
aliceKeyAgree.init(aliceKpair.getPrivate());

// Alice encodes her public key, and sends it over to Bob.
byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();
</code></pre>

<p>Contained in <code>alicePubKeyEnc</code> is the public key I am sending over to my C++ application. As I understand it, this data is an encoded DER key for my DHE parameters. On the other side I am attempting to use this key with mbedtls as follows:</p>

<pre><code>// An example DER (?) key from Java.
unsigned char buf[] = {
    0x30, 0x82, 0x02, 0x28, 0x30, 0x82, 0x01, 0x1b, 0x06, 0x09, 0x2a, 0x86,
    0x48, 0x86, 0xf7, 0x0d, 0x01, 0x03, 0x01, 0x30, 0x82, 0x01, 0x0c, 0x02,
    0x82, 0x01, 0x01, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
    0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
    0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22, 0x51, 0x4a, 0x08, 0x79,
    0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
    0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d,
    0x6d, 0x51, 0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
    0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff, 0x5c, 0xb6,
    0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb, 0x5a, 0x89, 0x9f, 0xa5,
    0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b, 0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51,
    0xec, 0xe4, 0x5b, 0x3d, 0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63, 0xbf, 0x05,
    0x98, 0xda, 0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
    0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3, 0xad, 0x96,
    0x1c, 0x62, 0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb, 0x9e, 0xd5, 0x29, 0x07,
    0x70, 0x96, 0x96, 0x6d, 0x67, 0x0c, 0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04,
    0xf1, 0x74, 0x6c, 0x08, 0xca, 0x18, 0x21, 0x7c, 0x32, 0x90, 0x5e, 0x46,
    0x2e, 0x36, 0xce, 0x3b, 0xe3, 0x9e, 0x77, 0x2c, 0x18, 0x0e, 0x86, 0x03,
    0x9b, 0x27, 0x83, 0xa2, 0xec, 0x07, 0xa2, 0x8f, 0xb5, 0xc5, 0x5d, 0xf0,
    0x6f, 0x4c, 0x52, 0xc9, 0xde, 0x2b, 0xcb, 0xf6, 0x95, 0x58, 0x17, 0x18,
    0x39, 0x95, 0x49, 0x7c, 0xea, 0x95, 0x6a, 0xe5, 0x15, 0xd2, 0x26, 0x18,
    0x98, 0xfa, 0x05, 0x10, 0x15, 0x72, 0x8e, 0x5a, 0x8a, 0xac, 0xaa, 0x68,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x01, 0x02, 0x02,
    0x02, 0x04, 0x00, 0x03, 0x82, 0x01, 0x05, 0x00, 0x02, 0x82, 0x01, 0x00,
    0x2f, 0x6e, 0xa3, 0xd8, 0x5c, 0xca, 0x06, 0x99, 0xbd, 0x35, 0x90, 0xb5,
    0xc3, 0x11, 0xa6, 0x48, 0x5b, 0x5a, 0xe9, 0x14, 0xac, 0x4a, 0xed, 0x2d,
    0x46, 0xb1, 0x6b, 0xc7, 0x5b, 0x88, 0xc6, 0xa7, 0x51, 0x07, 0xa0, 0x4d,
    0x5f, 0xc0, 0x32, 0x54, 0x9d, 0x63, 0x35, 0xa2, 0x3b, 0x6a, 0x9a, 0x0a,
    0xb9, 0x46, 0xff, 0x0b, 0x78, 0x5d, 0xa7, 0x17, 0x94, 0x58, 0x28, 0x28,
    0xf2, 0xa0, 0xea, 0x3a, 0xf0, 0xe8, 0x8f, 0xc2, 0xa1, 0x7c, 0xb1, 0x50,
    0x38, 0xb7, 0x01, 0xe1, 0x69, 0x42, 0x30, 0x1e, 0x06, 0x06, 0x06, 0x17,
    0x46, 0xc8, 0x1f, 0xb1, 0xb4, 0xd2, 0xff, 0xf1, 0x32, 0xdc, 0xc2, 0xfc,
    0x2c, 0x15, 0xe4, 0xfe, 0xae, 0xb2, 0x1f, 0x8b, 0x20, 0x29, 0x87, 0xbe,
    0x31, 0x8c, 0xf2, 0x01, 0x95, 0x51, 0x35, 0x76, 0x4c, 0x83, 0xe4, 0x06,
    0x46, 0x96, 0x62, 0x42, 0x2f, 0x23, 0xb4, 0xb7, 0xc7, 0x41, 0x4b, 0x4e,
    0xf5, 0xab, 0x20, 0xb0, 0x45, 0x27, 0x52, 0x64, 0x63, 0x18, 0x87, 0x72,
    0xa7, 0x41, 0x80, 0xbd, 0x15, 0x4d, 0xa8, 0x48, 0x69, 0x69, 0x8b, 0x64,
    0x38, 0x03, 0xa7, 0x72, 0xf7, 0xeb, 0x2b, 0xdd, 0x19, 0x2d, 0x63, 0x3a,
    0xa6, 0x1b, 0x6f, 0xcc, 0x81, 0x14, 0xde, 0x29, 0xd9, 0x55, 0x66, 0xd1,
    0x95, 0x8d, 0x2f, 0x15, 0x5e, 0x29, 0xad, 0xf8, 0x82, 0xf0, 0x68, 0xac,
    0x65, 0xf7, 0x54, 0x4f, 0x3e, 0x52, 0x64, 0xe8, 0x28, 0x52, 0x0f, 0x7c,
    0xbe, 0xc4, 0xf2, 0x20, 0x40, 0x97, 0xfa, 0x0a, 0x78, 0x5b, 0x1d, 0xf8,
    0xdb, 0x15, 0x02, 0xbe, 0xc3, 0xf0, 0xb0, 0x3a, 0xda, 0x6a, 0xe6, 0x5f,
    0x74, 0x48, 0x74, 0x0e, 0xe9, 0x1d, 0x02, 0xda, 0x25, 0x37, 0x4f, 0x41,
    0x11, 0x63, 0x32, 0x93, 0x44, 0xfe, 0x5b, 0x3a, 0x7e, 0x25, 0xcc, 0x9f,
    0xd5, 0x99, 0x41, 0x9f, 0x00
};

size_t size = 557; // 556 + NULL terminating byte per the docs.

mbedtls_dhm_context ctx;
mbedtls_dhm_init(&amp;ctx);
int res = mbedtls_dhm_parse_dhm(&amp;ctx, buf, size);

if (res != 0) {
    printf(""FAIL\n"", -res);
}
</code></pre>

<p><code>res</code> results in a negative, non-zero value (<code>0xffffcc1e</code>). I've checked the error codes for x509 parsing in mbedtls, but can't find a matching error code.</p>

<p>Any idea why I can't load this certificate? </p>

<p><strong>Update</strong></p>

<p>I updated my C code to print out the associated error message for mbedtls:</p>

<pre><code>0x0000023c4f9fb2b0 ""DHM - The ASN.1 data is not formatted correctly : ASN1 - ASN1 tag was of an unexpected value""
</code></pre>

<p>So I took the hex values from my key and ran it through <a href=""http://lapo.it/asn1js/#308202283082011B06092A864886F70D0103013082010C0282010100FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF020102020204000382010500028201002F6EA3D85CCA0699BD3590B5C311A6485B5AE914AC4AED2D46B16BC75B88C6A75107A04D5FC032549D6335A23B6A9A0AB946FF0B785DA71794582828F2A0EA3AF0E88FC2A17CB15038B701E16942301E0606061746C81FB1B4D2FFF132DCC2FC2C15E4FEAEB21F8B202987BE318CF201955135764C83E406469662422F23B4B7C7414B4EF5AB20B04527526463188772A74180BD154DA84869698B643803A772F7EB2BDD192D633AA61B6FCC8114DE29D95566D1958D2F155E29ADF882F068AC65F7544F3E5264E828520F7CBEC4F2204097FA0A785B1DF8DB1502BEC3F0B03ADA6AE65F7448740EE91D02DA25374F411163329344FE5B3A7E25CC9FD599419F"" rel=""nofollow noreferrer"">http://lapo.it/asn1js/</a> (&lt;-- That links the the actual output from the key) which indicates some structure to my key and <em>seems</em> to parse the key just fine. Perhaps it's an issue with how I'm passing the key to mbedtls?</p>
","<p>You are passing the wrong thing to mbed TLS's <code>mbedtls_dhm_parse_dhm</code>. That function expects the DER (or PEM) encoded DH <em>parameters</em>, not the key.</p>

<p>Using BouncyCastle's <a href=""https://android.googlesource.com/platform/external/bouncycastle/+/master/bcprov/src/main/java/org/bouncycastle/asn1/pkcs/DHParameter.java"" rel=""nofollow noreferrer""><code>DHParameter</code></a> you can get the DER encoded parameters like this:</p>

<pre><code>DHParameterSpec dhParams = ((DHPublicKey) aliceKeyPair.getPublic()).getParams();
DHParameter dhP = new DHParameter(dhParams.getP(), dhParams.getG(), 0);
byte[] encodedParams = dhP.getEncoded(ASN1Encodable.DER);
</code></pre>

<p>This will give you the bytes that you can then pass into <code>mbedtls_dhm_parse_dhm</code>, either as raw bytes as you are doing now or PEM encoded as that function will accept that as well. Note that I'm passing 0 for L as mbed TLS discards it anyway. Also note that <code>getEncoded</code> throws so make sure to handle the exception.</p>

<p>Steps to complete a key exchange:</p>

<p>In Java:</p>

<pre><code>KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(""DH"");
aliceKpairGen.initialize(2048);
KeyPair aliceKpair = aliceKpairGen.generateKeyPair();
KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(""DH"");
aliceKeyAgree.init(aliceKpair.getPrivate());
DHParameterSpec dhParams = ((DHPublicKey) aliceKpair.getPublic()).getParams();
DHParameter dhP = new DHParameter(dhParams.getP(), dhParams.getG(), 0);
byte[] encodedParams = dhP.getEncoded(ASN1Encodable.DER);
byte[] javaPub = ((DHPublicKey)aliceKeyPair.getPublic()).getY().toByteArray();
</code></pre>

<p>Then in C++:</p>

<pre><code>mbedtls_dhm_context ctx;
mbedtls_dhm_init(&amp;ctx);
...
mbedtls_dhm_parse_dhm(&amp;ctx, encodedParams, encodedParamsLen);
...
uint_8t mbedtlspub[128];
mbedtls_dhm_make_public(&amp;ctx, 128, mbedtlspub, sizeof(mbedtlspub), mbedtls_ctr_drbg_random, &amp;rnd_info);
...
mbedtls_dhm_read_public(&amp;ctx, javaPub, javaPubLen);
...
uint_8t mbedtlssecret[128];
mbedtls_dhm_calc_secret(&amp;ctx, mbedtlssecret, (size_t)secret_len, &amp;olen, mbedtls_ctr_drbg_random, &amp;rnd_info);
</code></pre>

<p>And back in Java (assuming you encoded mbedtlspub from the previous steps in Base64, but you can do it however you want):</p>

<pre><code>byte[] yBinary = Base64.decodeBase64(mbedtlspub.getBytes()); 
BigInteger y = new BigInteger(yBinary); 
DHPublicKeySpec dhPublicKeySpec = new DHPublicKeySpec(y, dhParams.getP(), dhParams.getG()); 
KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM); 
DHPublicKey mbedtlsPubKey = (DHPublicKey) KeyFactory.generatePublic(dhPublicKeySpec);
aliceKeyAgree.doPhase(mbedtlsPubKey, true);
byte[] javaSecretKey = aliceKeyAgree.generateSecret();
</code></pre>

<p>That completes the key exchange and at this point <code>mbedtlssecret</code> and <code>javaSecretKey</code> should match. So the data passing hands is <code>encodedParams</code> and <code>javaPub</code> (from Java) and <code>mbedtlspub</code> (from C++). I omitted some detail to focus on the core steps. Also note that a lot of these functions either return an error code or throw, so please take care using them.</p>
","306","<java><c++><c><diffie-hellman><mbedtls>","1","2","1","2018-04-20 15:38:24","49842820","2","","309706","","2018-04-20 15:38:24","2018-04-12 20:55:52",""
"51831922","SSL handshake failure with Linux server, but not with Windows","<p>I've found some <a href=""https://stackoverflow.com/questions/6851461/java-why-does-ssl-handshake-give-could-not-generate-dh-keypair-exception"">related questions</a>, but mine is a little different.</p>

<p>Client app running on Windows, using Java 1.7 (71) with bouncycastle connecting to a tomcat 8.5.xx server running Java 1.8 (161) on either Linux RH or Windows 10. The Linux and Windows server installations should be identical (other than being Linux and Windows). We control the software on both sides.</p>

<p>Client app works correctly when connecting to Windows. When connecting to Linux it fails the SSL handshake with:</p>

<pre><code>java.security.InvalidAlgorithmParameterException: Prime size must be multiple of 64, and can only range from 512 to 1024 (inclusive)
  at com.sun.crypto.provider.DHKeyPairGenerator.initialize(DHKeyPairGenerator.java:120)
  at java.security.KeyPairGenerator$Delegate.initialize(Unknown Source)
</code></pre>

<p>This isn't totally surprising, because Java 7 can't handle large DH keys. But
when the client connects to the Windows server (same version of tomcat, same version of Java), the SSL handshake works flawlessly and the connection goes through.</p>

<p>Setting javax.net.debug appropriately shows that, yes, the Linux server is sending a 2048 bit DH key and Windows is sending 1024. I have no idea why.</p>

<p>The java.security files are the same for the Windows and Linux server (except windows has sun.security.mscapi.SunMSCAPI provider). crypto.policy=unlimited is commented out on both.</p>

<p>Two part question:</p>

<ol>
<li>Where else can I look to find out why the two systems behave differently? Is this an OS crypto library difference?</li>
<li>Is there a way to resolve this problem without changing the client code (it's legacy code and we'd rather not patch)?</li>
</ol>
","","305","<java><linux><ssl><diffie-hellman>","2","","0","2018-08-14 00:42:19","","3","","608639","","2018-08-14 00:42:19","2018-08-13 23:43:13",""
"52800998",".NET ECDiffieHellmanCng and BouncyCastle Core compatible agreement","<p>I have to make a Diffie Hellman agreement with a third party that communicates the  public keys in the .NET ECDiffieHellmanCng XmlString format. I cannot change their code.
What they send looks like this:</p>

<pre><code>&lt;ECDHKeyValue xmlns=""http://www.w3.org/2001/04/xmldsig-more#""&gt;
  &lt;DomainParameters&gt;
    &lt;NamedCurve URN=""urn:oid:1.3.132.0.35"" /&gt;
  &lt;/DomainParameters&gt;
  &lt;PublicKey&gt;
    &lt;X Value=""11"" xsi:type=""PrimeFieldElemType"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" /&gt;
    &lt;Y Value=""17"" xsi:type=""PrimeFieldElemType"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" /&gt;
  &lt;/PublicKey&gt;
&lt;/ECDHKeyValue&gt;
</code></pre>

<p>They generate that using typical .NET Framework code like this:</p>

<pre><code>using (ECDiffieHellmanCng dhKey = new ECDiffieHellmanCng())
{
    dhKey.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
    dhKey.HashAlgorithm = CngAlgorithm.Sha256;

    Console.WriteLine(dhKey.PublicKey.ToXmlString());
}
</code></pre>

<p>They expect to receive my public key in the same format.
They use my public key like this:</p>

<pre><code>ECDiffieHellmanCngPublicKey pbkey = ECDiffieHellmanCngPublicKey.FromXmlString(xmlHere);
</code></pre>

<p>I work in .NET core 2.1. Unfortunately the ECDiffieHellmanCng classes and the like are currently not implemented in .NET core.
I thought I could use the BouncyCastle for .NET Core package for this: <a href=""https://www.nuget.org/packages/BouncyCastle.NetCore/"" rel=""nofollow noreferrer"">https://www.nuget.org/packages/BouncyCastle.NetCore/</a>
I would assume these both implement the same standard and they would be compatible.</p>

<p>I know how to do the agreement completely with the bouncy castle, however it's not clear to me how to do that starting with the X and Y values in the xml that come out of the .NET ECDiffieHellmanCng and how to make sure I use compatible parameters.
It's also not clear to me how I get the X and Y values from the bouncy castle public key that I generate to send back to them.
It doesn't help that the bouncy castle for .net api is not exactly the same as the java api and the documentation is limited.</p>

<p>Update 1:
After reading some comments below, it appears indeed that the ECDiffieHellmanCng are partially implemented in .NET Core. Most of the logic works but only ToXmlString and FromXmlString don't work. That's ok, I can work around that.
However I'm now running into a different problem. The curve that the other side uses is oid:1.3.132.0.35.
However when I try to use this in .NET core, even with a basic example like this:</p>

<pre><code>    using (ECDiffieHellman dhBob = ECDiffieHellman.Create(ECCurve.CreateFromValue(""1.3.132.0.35"")))
    {
        using (ECDiffieHellman dhAlice = ECDiffieHellman.Create(ECCurve.CreateFromValue(""1.3.132.0.35"")))
        {
            byte[] b = dhAlice.DeriveKeyMaterial(dhBob.PublicKey);

            byte[] b2 = dhBob.DeriveKeyMaterial(dhAlice.PublicKey);

            Console.WriteLine(b.SequenceEqual(b2));
        }
    }
</code></pre>

<p>Then I get this error:</p>

<pre><code>Unhandled Exception: System.PlatformNotSupportedException: The specified curve 'ECDSA_P521' or its parameters are not valid for this platform. ---&gt; Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException: The parameter is incorrect
   at System.Security.Cryptography.CngKeyLite.SetProperty(SafeNCryptHandle ncryptHandle, String propertyName, Byte[] value)
   at System.Security.Cryptography.CngKeyLite.SetCurveName(SafeNCryptHandle keyHandle, String curveName)
   at System.Security.Cryptography.CngKeyLite.GenerateNewExportableKey(String algorithm, String curveName)
   at System.Security.Cryptography.ECCngKey.GenerateKey(ECCurve curve)
   --- End of inner exception stack trace ---
   at System.Security.Cryptography.ECCngKey.GenerateKey(ECCurve curve)
   at System.Security.Cryptography.ECDiffieHellman.Create(ECCurve curve)
   at TestCore.Program.Main(String[] args) 
</code></pre>

<p>The error message is not clear to me. Is that curve really not supported? Or is something wrong in the parameters, but then what exactly?
It would surprise me if the curve is not supported because nistP521 curve is supported and according to this IBM document I found online they are the same: <a href=""https://www.ibm.com/support/knowledgecenter/en/linuxonibm/com.ibm.linux.z.wskc.doc/wskc_r_ecckt.html"" rel=""nofollow noreferrer"">https://www.ibm.com/support/knowledgecenter/en/linuxonibm/com.ibm.linux.z.wskc.doc/wskc_r_ecckt.html</a></p>
","<p>It looks like there's just an equivalence problem with the handling of these OIDs with ECDH (it's turning it into the Windows ECDSA name instead of the Windows ECDH name).  You can solve it with something like</p>

<pre><code>private static ECCurve GetCurveByOid(string oidValue)
{
    switch (oidValue)
    {
        case ""1.2.840.10045.3.1.7"":
            return ECCurve.NamedCurves.nistP256;
        case ""1.3.132.0.34"":
            return ECCurve.NamedCurves.nistP384;
        case ""1.3.132.0.35"":
            return ECCurve.NamedCurves.nistP521;
    }

    return ECCurve.CreateFromValue(oidValue);
}
</code></pre>
","304","<c#><.net><.net-core><bouncycastle><diffie-hellman>","4","0","2","2018-10-30 20:28:11","53072408","4","1","968698","","2018-10-18 11:21:11","2018-10-14 08:50:45",""
"52800998",".NET ECDiffieHellmanCng and BouncyCastle Core compatible agreement","<p>I have to make a Diffie Hellman agreement with a third party that communicates the  public keys in the .NET ECDiffieHellmanCng XmlString format. I cannot change their code.
What they send looks like this:</p>

<pre><code>&lt;ECDHKeyValue xmlns=""http://www.w3.org/2001/04/xmldsig-more#""&gt;
  &lt;DomainParameters&gt;
    &lt;NamedCurve URN=""urn:oid:1.3.132.0.35"" /&gt;
  &lt;/DomainParameters&gt;
  &lt;PublicKey&gt;
    &lt;X Value=""11"" xsi:type=""PrimeFieldElemType"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" /&gt;
    &lt;Y Value=""17"" xsi:type=""PrimeFieldElemType"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" /&gt;
  &lt;/PublicKey&gt;
&lt;/ECDHKeyValue&gt;
</code></pre>

<p>They generate that using typical .NET Framework code like this:</p>

<pre><code>using (ECDiffieHellmanCng dhKey = new ECDiffieHellmanCng())
{
    dhKey.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
    dhKey.HashAlgorithm = CngAlgorithm.Sha256;

    Console.WriteLine(dhKey.PublicKey.ToXmlString());
}
</code></pre>

<p>They expect to receive my public key in the same format.
They use my public key like this:</p>

<pre><code>ECDiffieHellmanCngPublicKey pbkey = ECDiffieHellmanCngPublicKey.FromXmlString(xmlHere);
</code></pre>

<p>I work in .NET core 2.1. Unfortunately the ECDiffieHellmanCng classes and the like are currently not implemented in .NET core.
I thought I could use the BouncyCastle for .NET Core package for this: <a href=""https://www.nuget.org/packages/BouncyCastle.NetCore/"" rel=""nofollow noreferrer"">https://www.nuget.org/packages/BouncyCastle.NetCore/</a>
I would assume these both implement the same standard and they would be compatible.</p>

<p>I know how to do the agreement completely with the bouncy castle, however it's not clear to me how to do that starting with the X and Y values in the xml that come out of the .NET ECDiffieHellmanCng and how to make sure I use compatible parameters.
It's also not clear to me how I get the X and Y values from the bouncy castle public key that I generate to send back to them.
It doesn't help that the bouncy castle for .net api is not exactly the same as the java api and the documentation is limited.</p>

<p>Update 1:
After reading some comments below, it appears indeed that the ECDiffieHellmanCng are partially implemented in .NET Core. Most of the logic works but only ToXmlString and FromXmlString don't work. That's ok, I can work around that.
However I'm now running into a different problem. The curve that the other side uses is oid:1.3.132.0.35.
However when I try to use this in .NET core, even with a basic example like this:</p>

<pre><code>    using (ECDiffieHellman dhBob = ECDiffieHellman.Create(ECCurve.CreateFromValue(""1.3.132.0.35"")))
    {
        using (ECDiffieHellman dhAlice = ECDiffieHellman.Create(ECCurve.CreateFromValue(""1.3.132.0.35"")))
        {
            byte[] b = dhAlice.DeriveKeyMaterial(dhBob.PublicKey);

            byte[] b2 = dhBob.DeriveKeyMaterial(dhAlice.PublicKey);

            Console.WriteLine(b.SequenceEqual(b2));
        }
    }
</code></pre>

<p>Then I get this error:</p>

<pre><code>Unhandled Exception: System.PlatformNotSupportedException: The specified curve 'ECDSA_P521' or its parameters are not valid for this platform. ---&gt; Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException: The parameter is incorrect
   at System.Security.Cryptography.CngKeyLite.SetProperty(SafeNCryptHandle ncryptHandle, String propertyName, Byte[] value)
   at System.Security.Cryptography.CngKeyLite.SetCurveName(SafeNCryptHandle keyHandle, String curveName)
   at System.Security.Cryptography.CngKeyLite.GenerateNewExportableKey(String algorithm, String curveName)
   at System.Security.Cryptography.ECCngKey.GenerateKey(ECCurve curve)
   --- End of inner exception stack trace ---
   at System.Security.Cryptography.ECCngKey.GenerateKey(ECCurve curve)
   at System.Security.Cryptography.ECDiffieHellman.Create(ECCurve curve)
   at TestCore.Program.Main(String[] args) 
</code></pre>

<p>The error message is not clear to me. Is that curve really not supported? Or is something wrong in the parameters, but then what exactly?
It would surprise me if the curve is not supported because nistP521 curve is supported and according to this IBM document I found online they are the same: <a href=""https://www.ibm.com/support/knowledgecenter/en/linuxonibm/com.ibm.linux.z.wskc.doc/wskc_r_ecckt.html"" rel=""nofollow noreferrer"">https://www.ibm.com/support/knowledgecenter/en/linuxonibm/com.ibm.linux.z.wskc.doc/wskc_r_ecckt.html</a></p>
","<p>Thanks all for your help. Eventually I wrote this code which works on .Net Core 2.1 and which is compatible with the .Net Framework To/FromXmlString:</p>

<pre><code>        using (ECDiffieHellmanCng dhBob = new ECDiffieHellmanCng())
        {
            dhBob.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            dhBob.HashAlgorithm = CngAlgorithm.Sha256;
            string xmlBob = ToXmlString(dhBob.PublicKey);
            //Console.WriteLine(xmlBob);

            using (ECDiffieHellmanCng dhAlice = new ECDiffieHellmanCng())
            {
                dhAlice.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
                dhAlice.HashAlgorithm = CngAlgorithm.Sha256;
                ECDiffieHellmanPublicKey keyBob = FromXmlString(xmlBob, dhAlice.KeySize);
                byte[] b = dhAlice.DeriveKeyMaterial(keyBob);


                string xmlAlice = ToXmlString(dhAlice.PublicKey);
                ECDiffieHellmanPublicKey keyAlice = FromXmlString(xmlAlice, dhBob.KeySize);
                byte[] b2 = dhBob.DeriveKeyMaterial(keyAlice);

                Console.WriteLine(b.SequenceEqual(b2));
            }
        }

public static string ToXmlString(ECDiffieHellmanPublicKey key)
{
    // the regular ToXmlString from ECDiffieHellmanPublicKey throws PlatformNotSupportedException on .net core 2.1
    ECParameters parameters = key.ExportParameters();
    return string.Format(""&lt;ECDHKeyValue xmlns='http://www.w3.org/2001/04/xmldsig-more#'&gt;&lt;DomainParameters&gt;&lt;NamedCurve URN='urn:oid:{0}' /&gt;"" +
                         ""&lt;/DomainParameters&gt;&lt;PublicKey&gt;&lt;X Value='{1}' xsi:type='PrimeFieldElemType' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' /&gt;"" +
                         ""&lt;Y Value='{2}' xsi:type='PrimeFieldElemType' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' /&gt;&lt;/PublicKey&gt;&lt;/ECDHKeyValue&gt;"",
        GetOid(parameters.Curve),
        new BigInteger(parameters.Q.X.Reverse().ToArray().Concat(new byte[] { 0 }).ToArray()).ToString(System.Globalization.CultureInfo.InvariantCulture), // watch out for big endian - little endian
        new BigInteger(parameters.Q.Y.Reverse().ToArray().Concat(new byte[] { 0 }).ToArray()).ToString(System.Globalization.CultureInfo.InvariantCulture));
}

public static ECDiffieHellmanPublicKey FromXmlString(string xml, int keySize)
{
    // the regular FromXmlString from ECDiffieHellmanPublicKey throws PlatformNotSupportedException on .net core 2.1
    XDocument doc = XDocument.Parse(xml);
    XNamespace nsSys = ""http://www.w3.org/2001/04/xmldsig-more#"";
    string xString = doc.Element(nsSys + ""ECDHKeyValue"").Element(nsSys + ""PublicKey"").Element(nsSys + ""X"").Attribute(""Value"").Value;
    string yString = doc.Element(nsSys + ""ECDHKeyValue"").Element(nsSys + ""PublicKey"").Element(nsSys + ""Y"").Attribute(""Value"").Value;
    string curve = doc.Element(nsSys + ""ECDHKeyValue"").Element(nsSys + ""DomainParameters"").Element(nsSys + ""NamedCurve"").Attribute(""URN"").Value;
    curve = curve.Replace(""urn:"", """").Replace(""oid:"", """");

    byte[] arrayX = BigInteger.Parse(xString, System.Globalization.CultureInfo.InvariantCulture).ToByteArray(false, true); // watch out for big endian - little endian
    byte[] arrayY = BigInteger.Parse(yString, System.Globalization.CultureInfo.InvariantCulture).ToByteArray(false, true);

    // make sure each part has the correct and same size
    int partSize = (int) Math.Ceiling(keySize / 8.0);
    ResizeRight(ref arrayX, partSize);
    ResizeRight(ref arrayY, partSize);

    ECParameters parameters = new ECParameters() { Q = new ECPoint() { X = arrayX, Y = arrayY }, Curve = GetCurveByOid(curve) };
    ECDiffieHellman dh = ECDiffieHellman.Create(parameters);
    return dh.PublicKey;
}

/// &lt;summary&gt;
/// Resize but pad zeroes to the left instead of to the right like Array.Resize
/// &lt;/summary&gt;
public static void ResizeRight(ref byte[] b, int length)
{
    if (b.Length == length)
        return;
    if (b.Length &gt; length)
        throw new NotSupportedException();

    byte[] newB = new byte[length];
    Array.Copy(b, 0, newB, length - b.Length, b.Length);
    b = newB;
}

private static ECCurve GetCurveByOid(string oidValue)
{
    // there are strange bugs in .net core 2.1 where the createfromvalue doesn't work for the named curves
    switch (oidValue)
    {
        case ""1.2.840.10045.3.1.7"":
            return ECCurve.NamedCurves.nistP256;
        case ""1.3.132.0.34"":
            return ECCurve.NamedCurves.nistP384;
        case ""1.3.132.0.35"":
            return ECCurve.NamedCurves.nistP521;
        default:
            return ECCurve.CreateFromValue(oidValue);
    }
}

private static string GetOid(ECCurve curve)
{
    // there are strange bugs in .net core 2.1 where the value of the oid of the named curves is empty
    if (curve.Oid.FriendlyName == ECCurve.NamedCurves.nistP256.Oid.FriendlyName)
        return ""1.2.840.10045.3.1.7"";
    else if (curve.Oid.FriendlyName == ECCurve.NamedCurves.nistP384.Oid.FriendlyName)
        return ""1.3.132.0.34"";
    else if (curve.Oid.FriendlyName == ECCurve.NamedCurves.nistP521.Oid.FriendlyName)
        return ""1.3.132.0.35"";
    else
        return curve.Oid.Value;
}
</code></pre>
","304","<c#><.net><.net-core><bouncycastle><diffie-hellman>","4","1","2","2018-10-30 20:28:11","53072408","4","1","968698","","2018-10-18 11:21:11","2018-10-14 08:50:45",""
"28140068","Ephemeral Diffie-Hellman requires certificate?","<p>In Ephemeral Diffie-Hellman, the key pair is generated every time. </p>

<p>In practice, does this mean I never need a certificate? Or that means I need a new cert every single time? </p>
","<blockquote>
  <p>In practice, does this mean I never need a certificate? Or that means I need a new cert every single time?</p>
</blockquote>

<p>It means that the generation of the key is independent of the certificate.
You could use DH without certificate (anonymous DH), but than the connection would be open to man-in-the-middle attacks. Thus in practices DH is used for key generation but the certificate is still used to make sure we talk to the right peer (identification).</p>
","297","<security><ssl><diffie-hellman><public-key-exchange>","0","0","1","2015-01-25 18:57:11","28140192","1","","","","","2015-01-25 18:46:06",""
"39389156","How the set the SFTP config to download/upload files? I got some troubles about the DiffieHellMan.dll","<p>I strongly-named all the tree packages (DiffieHellman.dll, Org.Mentalis.Security.dll, Tamir.SharpSSH.dll), and I already invoked the packages to my application which has to be strongly-named.<br>
But there is an exception which I cannot fix. I wrote another demo with no strongly-name packages which works OK, though.</p>

<pre><code>Connect Exception: Tamir.SharpSsh.jsch.JSchException: Session.connect: System.IO.FileLoadException: Could not load file or assembly 'DiffieHellman, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' or one of its dependencies. A strongly-named assembly is required. (Exception from HRESULT: 0x80131044)
File name: 'DiffieHellman, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'
   at Tamir.SharpSsh.jsch.jce.DH.getE()
   at Tamir.SharpSsh.jsch.DHG1.init(Session session, Byte[] V_S, Byte[] V_C, Byte[] I_S, Byte[] I_C)
   at Tamir.SharpSsh.jsch.Session.receive_kexinit(Buffer buf)
   at Tamir.SharpSsh.jsch.Session.connect(Int32 connectTimeout)
</code></pre>
","<p>I finally fixed this problem. 
The Tamir.SharpSSH.dll call the DiffieHellman.dll's version is 1.0.0.11, and I call the DiffieHellman.dll's version is 0.0.0.0. 
This is why I can not load the package. 
My solution likes this:
Download the DiffieHellman's source code to recompiled it to the 1.0.0.11 version and strong named it. </p>
","290","<c#><sftp><diffie-hellman>","0","0","1","2016-09-09 06:48:44","","0","0","45816","","2016-09-08 12:36:24","2016-09-08 10:58:04",""
"43860956","How to get Prime and Generator value from dhparam.pem?","<p>I use command in openssl to create a dhparam.pem.</p>

<pre><code>    openssl dhparam -outform PEM 2048 -out dhparam.pem
</code></pre>

<p>I need to calculate A = g^a mod p. With g is generator value and p is prime value from dhparam.pem file.</p>

<p>I am using C#, so How do I get value of g and p from dhparam.pem ?</p>

<p>Here is example of dhparam.pem</p>

<pre><code>    -----BEGIN DH PARAMETERS-----
    MIIBCAKCAQEAwJuVT+cebJvz0CSiOrdTA41St5XU+NcmE6decZxTcs449IO7rv4U
    Tts07i8RMqWQbDpqB7al9TU68QPDvG/0AzLfz9otzafS8GFr3WAsEt76oYB35j+m
    mwXlLorcA6RtZyq5mmoXLOxy03uGB/mXcWNvHjrps8nDcH439/TDlu4ZHKVxuEkc
    zWHssdqBMSNK0cMPnS1p8ECmnf6qNeP0gIRkLKrMTeY9vf7G0mR2phnyqGsFvgNy
    MSpa6X8vxJM0NzQ2uYyXqfFcXqEjIVQYoDSTaoeGvoNRIrzJc2xu0r2U7QjPHzVV
    6WA4yCfVE+M9Xgjyt/5cjYKz1CyE51+gcwIBAg==
    -----END DH PARAMETERS-----
</code></pre>
","","285","<c#><.net><pem><diffie-hellman>","2","","0","2017-05-09 04:09:25","","2","","","","","2017-05-09 04:09:25",""
"10908227","Is there a way to view the ECDH Shared Secret generated within microsoft CNG?","<p>I am trying to perform a ECDH key exchange between MS CNG and another device.  In order to debug things, I would like to see what shared secret is being generated in CNG so i can compare it with the secret generated by my other device. Anybody know of a way to do this? </p>
","<p>Take a look at CNG documentation at MSDN: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376289%28v=vs.85%29.aspx"" rel=""nofollow"">NCryptSecretAgreement function</a>. The <a href=""http://msdn.microsoft.com/en-us/library/bb298399.aspx"" rel=""nofollow"">same function</a> is accessible from .NET.</p>
","274","<encryption><encryption-asymmetric><diffie-hellman><cng>","1","-1","1","2012-07-25 23:59:55","","2","1","","","","2012-06-06 04:37:29",""
"31565562","Key Exchange between SQL Servers","<p>I have to implement ""secure communication"" between two Microsoft SQL servers. ""Communication"" in this case is an asynchronous high-latency operation and I have to work with the least possible amount of round trips. There is no shared secret available between the two servers, and no secure channel. The communication equipment does not support secure transmission.</p>

<p>(I know that under these circumstances I can't prevent against active MitM attacks, but that's above my paygrade, I just want to get everything else right.)</p>

<p>SQL Server allows for builtin AES256 encryption/decryption which I want to use, just that I have to make a key exchange beforehand.</p>

<p>I thought to use some builtin DHKE, since it is always better not to implement anything security-related by myself. <strong>Has SQL Server builtin DHKE functions, or can I setup SQL server to reliably support DHKE? Is there any other option I should look for?</strong></p>
","","270","<sql-server><security><diffie-hellman>","1","","0","2015-07-22 14:09:14","","6","","","","","2015-07-22 14:09:14",""
"42007978","Qt Android error: Diffie-Hellman parameters are not valid","<p>In a Qt app I make a GET request to <a href=""https://www.google.es"" rel=""nofollow noreferrer"">https://www.google.es</a> using QNetworkRequest. In Linux desktop this works fine, I get the page's content, but when I run it in my Android device I get the following error in my QNetworkReply:</p>

<blockquote>
  <p>Diffie-Hellman parameters are not valid</p>
</blockquote>

<p>Qt version is 5.8, device is Samsung S6 running Android 6.0.1. The problem happens with any https URL.</p>

<p>Anyone knows the meaning of this message? I've been googling for two hours with no result... Thanks a lot!!</p>

<p>Update: I'm not using any custom SSL configuration, just a QNetworkAccessManager and a QNetworkRequest. Calling QSslConfiguration::defaultConfiguration().diffieHellmanParameters().error() returns 2 (UnsafeParametersError) and QSslConfiguration::defaultConfiguration().diffieHellmanParameters().isValid() returns false.</p>
","","266","<android><qt><ssl><diffie-hellman>","3","","0","2017-04-03 09:39:48","","2","2","1406158","","2017-03-13 09:21:53","2017-02-02 16:56:51",""
"26176759","Self signed SSL key generation for a specific application","<p>I am trying to generate the re-generate the expired keys in <a href=""http://www.linuxjournal.com/article/4822"" rel=""nofollow"">this article</a>.</p>

<p>I followed the steps in <a href=""http://pages.cs.wisc.edu/~zmiller/ca-howto/"" rel=""nofollow"">this link</a>, but the certificates did not work. </p>

<p>The required certificates are as follows:</p>

<pre><code>client.pem
dh1024.pem
root.pem
server.pem
</code></pre>

<p>In my understanding dh is a diffie-hellman key. root.pem is used to sign client and server certificates. Anybody know's a good tutorial on generating the keys in the above manner so I can regenerate they keys for the example in <a href=""http://www.linuxjournal.com/article/4822"" rel=""nofollow"">this article</a>.</p>
","","264","<ssl><openssl><client-server><ca><diffie-hellman>","0","","0","2014-10-03 10:06:59","","4","","207421","","2014-10-03 10:06:59","2014-10-03 09:48:19",""
"6017615","Encrpytion between iPhone and a php page with Key exchange","<p>I need to send data to and from a php-page from my iPhone application and now I have a couple of questions to get it right the first time, and the best result:)</p>

<p>Lets start with the transfer of data.
Which is the best way to get the data from a php-page?</p>

<p>Option 1: Use NSString in a background thread</p>

<pre><code>[[NSString alloc] initWithContentsOfURL:url];
</code></pre>

<p>Or Option 2: Use NSURLConnection with delegates?</p>

<p>Then we have the encryption part. I have google a little bit but haven't found so much. I need to be able to encrypt and decrypt on both sides (both in the iPhone app and on the php-page). What encryption is best for this? Are there any implementations of any good encryption?</p>

<p>And last, for key-exchange. I thinking of using diffie-hellman, which ""require"" large prime-numbers. Are there any easy way to generate such thing (on both the iPhone and the php-page)?</p>
","<p>Have you considered using HTTPS? SSL/TLS seems to match what you're looking for in terms of encryption, key exchange, etc. HTTP on top of this will get you to transfer data to the PHP page.</p>
","254","<php><iphone><encryption><public-key-encryption><diffie-hellman>","0","1","1","2011-05-16 12:54:34","","1","","","","","2011-05-16 12:48:28",""
"32593249","Weak ethereal DH key Activemq","<p>I'm trying a set up a secure websocket in activemq using CA certs, but I keep getting this message in the browser:</p>

<blockquote>
  <p>SSL received a weak ephemeral Diffie-Hellman key in Server Key Exchange handshake message. (Error code: ssl_error_weak_server_ephemeral_dh_key)</p>
</blockquote>

<p>I believe this is related to the cipher suite, but I'm A) not finding using the right cipher suite or B) configuring it in the wrong area of Apache Activemq.  Currently, I've been adjusting the configuration of ssl in transport connector in activemq.xml( <a href=""http://activemq.apache.org/ssl-transport-reference.html"" rel=""nofollow noreferrer"">http://activemq.apache.org/ssl-transport-reference.html</a>).  However, I know that activemq uses a jetty server and i'm wondering if I should be configuring the suite in jetty.xml a la <a href=""https://stackoverflow.com/questions/30523324/how-to-config-local-jetty-ssl-to-avoid-weak-phermeral-dh-key-error"">How to config local Jetty ssl to avoid weak phermeral DH key error?</a>.
So, my questions are, is this the right approach?  If so, what's the correct cipher suite for activemq?  </p>

<p>The Java JDK version 1.7.0_79</p>
","<p>Alright, I was able to create a work around by reading the activemq-apollo guide and then matching it to closed JIRA's in activemq:
<a href=""http://activemq.apache.org/apollo/documentation/user-manual.html#Working_Around_Java_7_SSL_Bugs"" rel=""nofollow"">http://activemq.apache.org/apollo/documentation/user-manual.html#Working_Around_Java_7_SSL_Bugs</a>
<a href=""https://issues.apache.org/jira/browse/AMQ-4520"" rel=""nofollow"">https://issues.apache.org/jira/browse/AMQ-4520</a></p>
","245","<ssl><activemq><wss><diffie-hellman>","1","0","1","2015-09-16 22:17:22","32619704","0","1","-1","","2017-05-23 11:51:49","2015-09-15 18:37:12",""
"45107060","TOTP and Diffie-Hellman key exchange using Java","<p>I would like to ask how do I carry out a client server application that could do the operations of one time password and diffie hellman key exchange at the same time using java? The scenario is that the one time password is to be encrypted using the diffie hellman shared keys. The client will then send the encrypted OTP to the server and the server checks if it matches with the one it generates. I am not sure if the operations can be carried out together </p>
","<p>first of all you need to execute hellman key exchange and generate shared secret key between server and client. then after client take the key and perform encryption using shared secret key with some encryption algorithm and send it to server server decrypt the data. so you can generate shared secrete key one time for all encryption or you can generate all time. but i can suggest you use asymmetric key cryptography(RSA, ECC) it will reduce overhead of  hellman key exchange. and it will more secure as compare with symmetric key cryptography.   </p>
","237","<java><authentication><diffie-hellman><one-time-password>","0","0","1","2017-07-19 16:19:54","","0","","409228","","2017-07-19 16:19:54","2017-07-14 15:49:27",""
"32567478","Processing BigInteger issues","<p>Assume the following Diffie-Hellman info which can also be found on this <a href=""http://sandilands.info/sgordon/diffie-hellman-secret-key-exchange-with-openssl"" rel=""nofollow"">page</a></p>

<p><strong>1)P</strong></p>

<pre><code>string givenp = ""00e655cc9e04f3bebae76ecca77143ef5c4451876615a9f8b4f712b8f3bdf47ee7f717c09bb5b2b66450831367d9dcf85f9f0528bcd5318fb1dab2f23ce77c48b6b7381eed13e80a14cca6b30b5e37ffe53db15e2d6b727a2efcee51893678d50e9a89166a359e574c4c3ca5e59fae79924fe6f186b36a2ebde9bf09fe4de50453"";
        BigInteger p = new BigInteger(HexToBytesv2(givenp));
</code></pre>

<p><strong>2)G</strong></p>

<pre><code>BigInteger g = new BigInteger(2);
</code></pre>

<p><strong>3)Merchant  private key</strong></p>

<pre><code>string merchantPrivateKeyHEX = ""48887dfd090d175e33beea29e7b38334299289069f9ab492b67807905faa98d96d22d79205bef03f14af093f1797b904734132c34a388fdc79e20497bfa1465fec2aac4fabdf3bb0c9be8685d20f7bfe0346a9abdf7fa89838c3fa9ca6abdb70bea66795ab6699cc154db59490e4159f142f7bddff603c1d3d6c4fff8177e11d"";
        BigInteger a = new BigInteger(HexToBytesv2(merchantPrivateKeyHEX));
</code></pre>

<p>Using the formula <code>publickey = g ^ a mod p</code> I should get the public key provided in the initial link, yet when executing</p>

<pre><code>BigInteger A = BigInteger.ModPow(g, a, p);
ToHex(A.ToByteArray())
</code></pre>

<p>the result I get is</p>

<pre><code>00f85c41e84446ecfe43c9911df31d3cf60d83642afd496b741363290139badf75f8b8c5c010dda2446dd483dc553b6c2698c16c9d082391677785f81d54bc9c7c45f8b6d5bdb3e49fec7f5522b880c8c753fb7d3ff2c81e47dcb27d52842def40a812dc95cc679575baf237a955ee9944bd0797326f2a0a58c6c087f9b0b9e82c
</code></pre>

<p>instead of</p>

<pre><code>00d9abd78c93dfddeb920d57d6513126d8f1118c9237a45101408dbffe6cfd95b011a016e4e0ab8aef0601e836a452b8bb88be7ca71e4f22f97aa65f8358ee69348d1227d65db6e53641d1a6542aa4be4b4adc75fac816af79a8e3f5097f8313e7b725df37eadc8c774e2033dfa99c95ccef333bf402b066198c30481e2a83875c
</code></pre>

<p>Any ideas? I must be missing pretty obvious but I am not sure what that might be.</p>

<p>P.S. Adding the function being used:</p>

<pre><code> public static byte[] HexToBytesv2(this string hex)
    {
        if (hex.Length % 2 == 1)
            hex = '0' + hex;

        byte[] ret = new byte[hex.Length / 2];

        for (int i = 0; i &lt; ret.Length; i++)
            ret[i] = Convert.ToByte(hex.Substring(i * 2, 2), 16);

        return ret;

    }

  public static string ToHex(byte[] ba)
    {
        StringBuilder hex = new StringBuilder(ba.Length * 2);
        foreach (byte b in ba)
            hex.AppendFormat(""{0:x2}"", b);
        return hex.ToString();

    }
</code></pre>
","<p>It's an endian problem.</p>

<p>I've adjusted your encoding and decoding and now get the answer you're looking for:</p>

<pre><code>public static byte[] HexToBytesv2(string hex)
{
    if (hex.Length % 2 == 1)
        hex = '0' + hex;

    byte[] ret = new byte[hex.Length / 2];

    for (int i = 0; i &lt; ret.Length; i++)
        ret[i] = Convert.ToByte(hex.Substring(hex.Length - (i+1) * 2, 2), 16);

    return ret;

}

public static string ToHex( byte[] bytes)
{
    var sb = new StringBuilder();
    foreach (var b in bytes.Reverse())
    {
        sb.AppendFormat(""{0:x2}"", b);
    }
    return sb.ToString();
}
</code></pre>

<p>FYI I used LinqPad and the main method is your code from the question (as adjusted) with checks that the data has not lost anything on the way:</p>

<pre><code>void Main()
{
    string givenp = ""00e655cc9e04f3bebae76ecca77143ef5c4451876615a9f8b4f712b8f3bdf47ee7f717c09bb5b2b66450831367d9dcf85f9f0528bcd5318fb1dab2f23ce77c48b6b7381eed13e80a14cca6b30b5e37ffe53db15e2d6b727a2efcee51893678d50e9a89166a359e574c4c3ca5e59fae79924fe6f186b36a2ebde9bf09fe4de50453"";
    BigInteger p = new BigInteger(HexToBytesv2(givenp));
    (ToHex(p.ToByteArray()) == ""00e655cc9e04f3bebae76ecca77143ef5c4451876615a9f8b4f712b8f3bdf47ee7f717c09bb5b2b66450831367d9dcf85f9f0528bcd5318fb1dab2f23ce77c48b6b7381eed13e80a14cca6b30b5e37ffe53db15e2d6b727a2efcee51893678d50e9a89166a359e574c4c3ca5e59fae79924fe6f186b36a2ebde9bf09fe4de50453"").Dump();
    BigInteger g = new BigInteger(2);
    string merchantPrivateKeyHEX = ""48887dfd090d175e33beea29e7b38334299289069f9ab492b67807905faa98d96d22d79205bef03f14af093f1797b904734132c34a388fdc79e20497bfa1465fec2aac4fabdf3bb0c9be8685d20f7bfe0346a9abdf7fa89838c3fa9ca6abdb70bea66795ab6699cc154db59490e4159f142f7bddff603c1d3d6c4fff8177e11d"";
    BigInteger a = new BigInteger(HexToBytesv2(merchantPrivateKeyHEX));
    (ToHex(a.ToByteArray()) == ""48887dfd090d175e33beea29e7b38334299289069f9ab492b67807905faa98d96d22d79205bef03f14af093f1797b904734132c34a388fdc79e20497bfa1465fec2aac4fabdf3bb0c9be8685d20f7bfe0346a9abdf7fa89838c3fa9ca6abdb70bea66795ab6699cc154db59490e4159f142f7bddff603c1d3d6c4fff8177e11d"").Dump();
    BigInteger A = BigInteger.ModPow(g, a, p);
    (ToHex(A.ToByteArray()) == ""00f85c41e84446ecfe43c9911df31d3cf60d83642afd496b741363290139badf75f8b8c5c010dda2446dd483dc553b6c2698c16c9d082391677785f81d54bc9c7c45f8b6d5bdb3e49fec7f5522b880c8c753fb7d3ff2c81e47dcb27d52842def40a812dc95cc679575baf237a955ee9944bd0797326f2a0a58c6c087f9b0b9e82c"").Dump();
    (ToHex(A.ToByteArray()) == ""00d9abd78c93dfddeb920d57d6513126d8f1118c9237a45101408dbffe6cfd95b011a016e4e0ab8aef0601e836a452b8bb88be7ca71e4f22f97aa65f8358ee69348d1227d65db6e53641d1a6542aa4be4b4adc75fac816af79a8e3f5097f8313e7b725df37eadc8c774e2033dfa99c95ccef333bf402b066198c30481e2a83875c"").Dump();
}
</code></pre>

<p>Before I swapped the ordering, and included the <code>.Concat(new byte[] { 0 }).ToArray()</code> from your original question, the output was:</p>

<pre class=""lang-none prettyprint-override""><code>True
True
True
False
</code></pre>

<p>And now it's:</p>

<pre class=""lang-none prettyprint-override""><code>True
True
False
True
</code></pre>

<p>The other issue you're seeing is <code>BigInteger.Parse</code> and the <code>Byte[]</code> constructor always expect the top bit of the first nibble or last byte respectively to be the sign bit. So you need to include the extra <code>0</code> character or byte respectively to avoid that.</p>
","228","<c#><.net><biginteger><diffie-hellman>","3","3","2","2016-08-26 12:21:51","32568073","3","","256431","","2016-08-26 12:21:51","2015-09-14 14:33:30",""
"32567478","Processing BigInteger issues","<p>Assume the following Diffie-Hellman info which can also be found on this <a href=""http://sandilands.info/sgordon/diffie-hellman-secret-key-exchange-with-openssl"" rel=""nofollow"">page</a></p>

<p><strong>1)P</strong></p>

<pre><code>string givenp = ""00e655cc9e04f3bebae76ecca77143ef5c4451876615a9f8b4f712b8f3bdf47ee7f717c09bb5b2b66450831367d9dcf85f9f0528bcd5318fb1dab2f23ce77c48b6b7381eed13e80a14cca6b30b5e37ffe53db15e2d6b727a2efcee51893678d50e9a89166a359e574c4c3ca5e59fae79924fe6f186b36a2ebde9bf09fe4de50453"";
        BigInteger p = new BigInteger(HexToBytesv2(givenp));
</code></pre>

<p><strong>2)G</strong></p>

<pre><code>BigInteger g = new BigInteger(2);
</code></pre>

<p><strong>3)Merchant  private key</strong></p>

<pre><code>string merchantPrivateKeyHEX = ""48887dfd090d175e33beea29e7b38334299289069f9ab492b67807905faa98d96d22d79205bef03f14af093f1797b904734132c34a388fdc79e20497bfa1465fec2aac4fabdf3bb0c9be8685d20f7bfe0346a9abdf7fa89838c3fa9ca6abdb70bea66795ab6699cc154db59490e4159f142f7bddff603c1d3d6c4fff8177e11d"";
        BigInteger a = new BigInteger(HexToBytesv2(merchantPrivateKeyHEX));
</code></pre>

<p>Using the formula <code>publickey = g ^ a mod p</code> I should get the public key provided in the initial link, yet when executing</p>

<pre><code>BigInteger A = BigInteger.ModPow(g, a, p);
ToHex(A.ToByteArray())
</code></pre>

<p>the result I get is</p>

<pre><code>00f85c41e84446ecfe43c9911df31d3cf60d83642afd496b741363290139badf75f8b8c5c010dda2446dd483dc553b6c2698c16c9d082391677785f81d54bc9c7c45f8b6d5bdb3e49fec7f5522b880c8c753fb7d3ff2c81e47dcb27d52842def40a812dc95cc679575baf237a955ee9944bd0797326f2a0a58c6c087f9b0b9e82c
</code></pre>

<p>instead of</p>

<pre><code>00d9abd78c93dfddeb920d57d6513126d8f1118c9237a45101408dbffe6cfd95b011a016e4e0ab8aef0601e836a452b8bb88be7ca71e4f22f97aa65f8358ee69348d1227d65db6e53641d1a6542aa4be4b4adc75fac816af79a8e3f5097f8313e7b725df37eadc8c774e2033dfa99c95ccef333bf402b066198c30481e2a83875c
</code></pre>

<p>Any ideas? I must be missing pretty obvious but I am not sure what that might be.</p>

<p>P.S. Adding the function being used:</p>

<pre><code> public static byte[] HexToBytesv2(this string hex)
    {
        if (hex.Length % 2 == 1)
            hex = '0' + hex;

        byte[] ret = new byte[hex.Length / 2];

        for (int i = 0; i &lt; ret.Length; i++)
            ret[i] = Convert.ToByte(hex.Substring(i * 2, 2), 16);

        return ret;

    }

  public static string ToHex(byte[] ba)
    {
        StringBuilder hex = new StringBuilder(ba.Length * 2);
        foreach (byte b in ba)
            hex.AppendFormat(""{0:x2}"", b);
        return hex.ToString();

    }
</code></pre>
","<p>You're doing a number of unnecessary conversions and they're introducing an error somewhere.</p>

<p>If you remove the broken <code>string</code>-<code>byte[]</code>-<code>BigInteger</code>-<code>byte[]</code>-<code>string</code> steps and let <code>BigInteger</code> itself do the work for you then you'll generate the expected result:</p>

<pre><code>string givenp = ""00e655cc9e04f3bebae76ecca77143ef5c4451876615a9f8b4f712b8f3bdf47ee7f717c09bb5b2b66450831367d9dcf85f9f0528bcd5318fb1dab2f23ce77c48b6b7381eed13e80a14cca6b30b5e37ffe53db15e2d6b727a2efcee51893678d50e9a89166a359e574c4c3ca5e59fae79924fe6f186b36a2ebde9bf09fe4de50453"";
var p = BigInteger.Parse(givenp, NumberStyles.HexNumber);

var g = new BigInteger(2);

var merchantPrivateKeyHEX = ""48887dfd090d175e33beea29e7b38334299289069f9ab492b67807905faa98d96d22d79205bef03f14af093f1797b904734132c34a388fdc79e20497bfa1465fec2aac4fabdf3bb0c9be8685d20f7bfe0346a9abdf7fa89838c3fa9ca6abdb70bea66795ab6699cc154db59490e4159f142f7bddff603c1d3d6c4fff8177e11d"";
var a = BigInteger.Parse(merchantPrivateKeyHEX, NumberStyles.HexNumber);

var publicKey = BigInteger.ModPow(g, a, p);
Console.WriteLine(publicKey.ToString(""x""));  // displays 0d9abd7...
</code></pre>
","228","<c#><.net><biginteger><diffie-hellman>","3","3","2","2016-08-26 12:21:51","32568073","3","","256431","","2016-08-26 12:21:51","2015-09-14 14:33:30",""
"47614199","c++ openssl EVP_PKEY_Derive_set_peer returns 0","<p>Using OpenSSL, I've created my Diffie-Hellman Private/Public keys and am trying to derive the shared secret key. But, the function EVP_PKEY_derive_set_peer() always fails. Below is the function that should derive the key. I based the code off of the code found at <a href=""https://github.com/cfairweather/ec-diffie-hellman-openssl/wiki"" rel=""nofollow noreferrer"">https://github.com/cfairweather/ec-diffie-hellman-openssl/wiki</a>.  Any help would be appreciated. </p>

<pre><code>unsigned char* deriveSecretKey(key* k, const char *peerPublicKey, int peerPublicKeyLength, int *sharedSecretLength)
{
    unsigned char* sharedSecret;
    //We can reconstruct an EVP_PKEY on this side to represent the peer key by parsing their public key we received from them.
    //New memory buffer that we can allocate using OpenSSL's method
    BUF_MEM *bptr = BUF_MEM_new();
    BUF_MEM_grow(bptr, peerPublicKeyLength);
    //Create a new BIO method, again, memory
    BIO* bp = BIO_new(BIO_s_mem());

    memcpy(bptr-&gt;data, peerPublicKey, peerPublicKeyLength);

    BIO_set_mem_buf(bp, bptr, BIO_NOCLOSE);

    k-&gt;peerkey = PEM_read_bio_PUBKEY(bp, NULL, NULL, NULL);

    if (k-&gt;peerkey == NULL)
    {
        printf(""Peer Key is null.\n"");
    }

    //Memory cleanup from read/copy operation
    BIO_free(bp);
    BUF_MEM_free(bptr);

    //Now, let's derive the shared secret

    size_t secret_len = 0;

    /* Create the context for the shared secret derivation */
    if(NULL == (k-&gt;ctx_derive = EVP_PKEY_CTX_new(k-&gt;privkey, NULL)))
    {
        printf(""Could not create the context for the shared secret derivation\n"");
        return NULL;
    }

    /* Initialise */
    if(1 != EVP_PKEY_derive_init(k-&gt;ctx_derive))
    {
        printf(""Could not init derivation context\n"");
        return NULL;
    }

    /* Provide the peer public key */
    // This call fails
    if(1 != EVP_PKEY_derive_set_peer(k-&gt;ctx_derive, k-&gt;peerkey))
    {
        printf(""Could not set the peer key into derivation context\n"");
        return NULL;
    }

    /* Determine buffer length for shared secret */
    if(1 != EVP_PKEY_derive(k-&gt;ctx_derive, NULL, &amp;secret_len))
    {
        printf(""Could not determine buffer length for shared secret\n"");
        return NULL;
    }

    /* Create the buffer */
    if(NULL == (sharedSecret = (unsigned char*) OPENSSL_malloc(secret_len)))
    {
        printf(""Could not create the sharedSecret buffer\n"");
        return NULL;
    }

    /* Dervive the shared secret */
    if(1 != (EVP_PKEY_derive(k-&gt;ctx_derive, sharedSecret, &amp;secret_len)))
    {
        printf(""Could not dervive the shared secret\n"");
        return NULL;
    }

    (*sharedSecretLength) = (int)secret_len;

    // Hash the secret
    unsigned char key[] = ""df2677fbc0ddd3b4e059b82207e7840fbe7fd91a64b68935135b4f42b36899c2"";
    unsigned char iv[] = ""17620daa95f8cd7dfef9af3a516a1970"";

    int secretLength = encrypt(sharedSecret (*sharedSecretLength),key,iv,sharedSecret);

    return sharedSecret;
}
</code></pre>
","","227","<c++><openssl><key><diffie-hellman>","1","","0","2017-12-03 00:55:25","","1","","","","","2017-12-03 00:55:25",""
"34300276","ruby openssl diffie hellman implementation","<p>I'm having some trouble implementing some security measures over a network for one of my school projects. We already have a full network running using Ruby. We're trying to use AES 256 CBC using the OpenSSL library. We have experimented with using Diffie Hellman, but this is where we're having trouble:
node 1 runs:</p>

<pre><code>require 'openssl'
dh1 = OpenSSL::PKey::DH(256)
der = dh1.public_key.to_der
###we would send der to n2 here
</code></pre>

<p>Apparently it's alright to send der over to n2, so n2 would have this portion of code:</p>

<pre><code>require 'openssl'
dh2 = OpenSSL::PKey::DH(der)
</code></pre>

<p>and now they have each others' information. However wouldn't a node which was listening to traffic be able to pick this message up and be able to have dh1's key? Having trouble wrapping my head around this.</p>
","<p>Yes a listening node could have dh1's public key. That is how Diffie Hellman works. The eavesdropper does not know either private key and does not know the shared private key. Without knowing one of the private keys it cannot solve for the shared key.</p>

<p>The modulo equations are setup such that when dh2 raises dh1's public key to the value of its own private key (dh1_public_key^dh2_private_key) the result of the equation is the shared key, and vice versa. </p>
","222","<ruby><openssl><diffie-hellman>","-1","0","1","2015-12-15 22:32:00","","1","","","","","2015-12-15 22:03:26",""
"39536405","Details of TLS server key exchange message","<p>This is essentially the same as my <a href=""https://stackoverflow.com/questions/39374024/determine-diffie-hellman-parameters-length-for-a-tls-handshake-in-java"">other question about DH parameters</a> (which didn't get any answers), but I'm interested in getting information about the TLS server key exchange message(s) that are sent during the TLS handshake.</p>

<p>Are these messages -- or the information that comes from them like the negotiated ephemeral keys -- available at all through the Java API? I'm using Java <code>SSLSocketFactory</code> to obtain an <code>SSLSocket</code> and then connecting using that; there are no other APIs layered on top of it (like Apache http-client) that I have to break-through in order to get down to this level.</p>

<p>I'm just not sure if Java exposes this information at all. I tried using a <code>HandshakeCompletedListener</code> but that doesn't seem to provide me with any of the information I seek.</p>

<p>Does anyone know if/how this can be done?</p>
","<p>The Messages are not available through the API, however you can use libpcap to capture packets and then parse through the handshake data that comes through it and store it in your program.  </p>

<p>Following the reference from here <a href=""http://download.java.net/jdk7/archive/b123/docs/api/javax/net/ssl/SSLSocket.html"" rel=""nofollow"">http://download.java.net/jdk7/archive/b123/docs/api/javax/net/ssl/SSLSocket.html</a>
I do not think it is possible to  print the DH parameters from the API. </p>
","212","<java><ssl><diffie-hellman><public-key-exchange>","0","0","1","2016-09-17 17:08:04","","2","","-1","","2017-05-23 10:27:25","2016-09-16 16:40:14",""
"47590499","Concept TLS Handshake Diffie Hellman","<p>I try to understand the TLS Handshake with DH. I googled the concepts and I think I understood the basics. But there are somethings I'm still struggeling with.</p>

<p>Client and Server have to agree on the DH Params g and p. Who makes the suggestion for these parameters, always the server?</p>

<p>On various images I saw, that the first step is the exchange of a client random/server random. What are they used for? 
To calculate the pre-master-secret client and server only need to exchange g, p and their calculated public-value (client-public-value -> g,p and clients-Secret-Value; server-public-value -> g,p and server-secret-value. 
Why these client random and server random as a first step?</p>

<p>see: <a href=""https://www.google.ch/search?q=tls%20handshake%20diffie%20hellman&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjujMzKuujXAhVGK1AKHTmND3YQ_AUICigB&amp;biw=1745&amp;bih=899#imgrc=v5WFA7Tf6dtmkM:"" rel=""nofollow noreferrer"">Image1</a>; <a href=""https://cdn.wp.nginx.com/wp-content/uploads/2016/08/Sullivan-conf2015-slide4_ssl-handshake.png"" rel=""nofollow noreferrer"">Image2</a></p>

<p>What did I missunderstood?</p>

<p>Thank you guys</p>
","","207","<ssl><handshake><diffie-hellman>","0","","0","2017-12-01 09:40:04","","3","","","","","2017-12-01 09:40:04",""
"34430295","Android Diffie hellman BN_mod_inverse 0306E06C error","<p>I am trying to implement Diffie Hellman Algo between client and server. For that I am using below code to generate Public key</p>

<p>Shared p,g and public key from server end</p>

<pre><code>DH p:E1C66AFAB0E8518914EE1E58DDD9B337
DH g:05
DH public key(95D1FAFBFE8096BFF6C528A571B307B4)
</code></pre>

<p>Android code below</p>

<pre><code>final BigInteger p = new
BigInteger(""E1C66AFAB0E8518914EE1E58DDD9B337"", 16);//convert hex to BigInteger
final BigInteger g = new BigInteger(""05"", 16);//convert hex to BigInteger
final int l = 128;

KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"");
keyGen.initialize(new DHParameterSpec(p, g, l));
KeyPair ackp = keyGen.generateKeyPair(); 
PrivateKey priKey = ackp.getPrivate();
PublicKey pubKey = ackp.getPublic();
</code></pre>

<p>Output: pubKey value </p>

<pre><code>OpenSSLDHPublicKey{
        Y=8d664db67d53602ef3f2eb5dce616fb9,
        P=b7f51eb91d787dbcd74ab1d752abf207,
        G=5}
</code></pre>

<p>So far, so good but when I am using public key(95D1FAFBFE8096BFF6C528A571B307B4 shared by server end) to generate symmetric/final key </p>

<p>Code:</p>

<pre><code>final BigInteger p = new
    BigInteger(""95D1FAFBFE8096BFF6C528A571B307B4"", 16);//convert hex to BigInteger
    final BigInteger g = new BigInteger(""05"", 16);//convert hex to BigInteger
    final int l = 128;

    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"");
    keyGen.initialize(new DHParameterSpec(p, g, l));
    KeyPair ackp = keyGen.generateKeyPair(); 
    PrivateKey priKey = ackp.getPrivate();
    PublicKey pubKey = ackp.getPublic();
</code></pre>

<p>I am getting following error:</p>

<pre><code>12-23 12:16:35.801: W/System.err(12512): java.lang.RuntimeException: error:0306E06C:bignum routines:BN_mod_inverse:no inverse
</code></pre>

<p>What am I doing wrong. Any help will be appreciated :)</p>
","","206","<android><algorithm><security><public-key-encryption><diffie-hellman>","1","","0","2015-12-23 06:59:59","","0","1","","","","2015-12-23 06:59:59",""
"48032215","Explanation of Diffie-Hellman Key Exchange using colors?","<p>I was checking <a href=""https://www.youtube.com/watch?v=3QnD2c4Xovk"" rel=""nofollow noreferrer"">this</a> explanation of Diffie-Hellman algorithm using colors.</p>

<p>Alice and Bob want to communicate privately.</p>

<ol>
<li>A Common Color <code>C</code> is agreed upon by Alice and Bob.</li>
<li>Eve knows about the <code>C</code> because it is communicated over the Network.</li>
<li>Alice mixes her Private Color <code>A</code> to <code>C</code> and sends Alice's Mixture <code>AC</code> over the Network.</li>
<li>Bob mixes his Private Color <code>B</code> to <code>Yellow</code> and sends Bob' Mixture <code>BC</code> over the Network.</li>
<li>Alice and Bob add their own color to the other's mixture BCA = ACB.
They arrive at a common, color.</li>
</ol>

<p>However, I have the following question?</p>

<p>If Eve knows that the common color is <code>C</code>, and Alice's Mixture <code>AC</code>, can't she deduce Alice's secret color using <code>AC</code> - <code>C</code>? At-least in RGB color space, this is easy to calculate right?</p>

<p>In summary, will this algorithm work if the common color <code>C</code> is shared over the network?</p>

<p>PS: I am assuming that volume of the colors is the same as the video doesn't talk about quantity.</p>
","<p>Short answer: Yes, it will work. That is kind of the whole point of this concept. </p>

<p>As for that particular explanation (using paint as an example), it is just that - a simplified example to make the higher level concept understandable. </p>

<p>That higher level concept is in this case, that certain <em>known</em> pieces of data (the known color) can be combined with private / unknown pieces of data (the two ""private"" colors that are added by Alice and Bob) in such a way that only the intended parties (Alice and Bob) can make use of the resulting product. </p>

<p>In this simplified example, that resulting product is a secret color. In actual cryptography, the result is a secret message of some kind. </p>

<p>The paint is a metaphor. You should not try to over-analyze it. If you are thinking about RGB-codes and volumes of colored liquids, I'm afraid you're missing the point.</p>

<hr>

<p><strong>Addition/ update:</strong> For a slightly more technical description of the Diffie-Hellman exchange, see <a href=""https://security.stackexchange.com/a/45971/42360"">this answer provided at security.stackexchange.com</a>. As an answer to this current question, I'd like to quote a comment posted below the answer in the link: </p>

<blockquote>
  <p><em>I think it's worth mentioning that the reason this is secure is that,
  unlike normal log(x), the modular log(x) is thought to be hard to
  compute.</em></p>
</blockquote>

<p>That ""<em>hard to compute</em>"" part is what is alluded to with the metaphor of paint that is ""<em>hard to separate once it is mixed</em>"".</p>
","203","<security><diffie-hellman>","0","2","1","2018-01-03 08:38:54","48062612","5","","452102","","2017-12-30 11:45:22","2017-12-30 08:22:28",""
"54220584","How to import private key from X509Certificate2 into CngKey on NET 4.5.1","<p>The version of .NET that I am using (4.5.1) has no GetCngPrivateKey() method in X509Certificate2. Nothing I have found works.</p>

<p>The .NET version I am using is, unfortunately, not negotiable.</p>

<p>I'm trying to pull something like this off:</p>

<pre><code>X509Certificate2 cert = new X509Certificate2(@""alice.p12"", ""password"", X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.Exportable);
CngKey ck = CngKey.Import(cert.PrivateKey) // Fake line - not possible this way
using (var alice = new ECDiffieHellmanCng(ck))
{
    // ...
}
</code></pre>

<p>Again, there are no methods available to me such as GetCngPrivateKey(), HasCngKey(), GetRSAPrivateKey(), and so on.</p>

<p><strong>* UPDATE *</strong>
All of these Import attempts fail with exceptions:</p>

<pre><code>RSACryptoServiceProvider rsa = cert.PrivateKey as RSACryptoServiceProvider;
var cspBlob = rsa.ExportCspBlob(true);
CngKey a = CngKey.Import(cspBlob, CngKeyBlobFormat.EccPrivateBlob);
CngKey a = CngKey.Import(cspBlob, CngKeyBlobFormat.GenericPrivateBlob);
cspBlob = rsa.ExportCspBlob(false);
CngKey a = CngKey.Import(cspBlob, CngKeyBlobFormat.EccPrivateBlob);
CngKey a = CngKey.Import(cspBlob, CngKeyBlobFormat.GenericPrivateBlob);
</code></pre>
","","189","<c#><pkcs#12><diffie-hellman><ecdh>","0","","0","2019-01-16 16:35:05","","3","","5861178","","2019-01-16 16:35:05","2019-01-16 15:43:00",""
"30580533","In java SSL why is Diffie Hellman Key Exchange always using the same modulus and base?","<p>I wrote a test client in java using the HttpsURLConnection class and connected to Tomcat 8.</p>

<p>I ran with the following settings</p>

<p>-Dhttps.cipherSuites=TLS_DH_anon_WITH_AES_256_CBC_SHA
-Dhttps.cipherSuites=TLS_DHE_RSA_WITH_AES_128_CBC_SHA</p>

<p>From the SSL debugging a see the DH Modulus and DH Base are always the same.  I thought the DHE would cause the modulus and base to change for each connection.
Are these values hard coded into the JVM?  Why do they stay the same even for DHE?</p>
","<p>Consider having a look at the <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#DH2Ex"" rel=""nofollow"">Sample program</a> in the Oracle documentation for Diffie Hellman Key Exchange. </p>

<p>As long as the <code>run(String mode)</code> method is invoked with <code>""GENERATE_DH_PARAMS""</code>, the base and modulus parameters are generated.</p>
","183","<java><ssl><diffie-hellman>","1","0","1","2015-06-01 19:00:01","","0","","","","","2015-06-01 18:23:32",""
"53265077","Java 8 Diffie Hellman key size issues with 32 bit linux","<p>after upgrading our java from 1.7 to 1.8 on an old 32 bit linux system, we receive the following error message while communicating with a webservice:</p>

<blockquote>
  <p>Caused by: java.security.InvalidAlgorithmParameterException: DH key size must be multiple of 64, and can only range from 512 to 2048 (inclusive). The specific key size 4096 is not supported</p>
</blockquote>

<p>The linux distribution is:</p>

<blockquote>
  <p>uname -a </p>
  
  <p>Linux XXX-XXX-S018 2.6.16.21-0.8-default #1 Mon Jul 3
  18:25:39 UTC 2006 i686  i686 i386 GNU/Linux</p>
</blockquote>

<p>The distribution:</p>

<blockquote>
  <p>cat /etc/*release</p>
  
  <p>LSB_VERSION=""core-2.0-noarch:core-3.0-noarch:core-2.0-ia32:core-3.0-ia32""
  SUSE Linux Enterprise Server 10 (i586)
  VERSION = 10</p>
</blockquote>

<p>The Java Version we are using (32 bit and 64 bit the same releases)</p>

<blockquote>
  <p>Java Version:</p>
  
  <p>jdk1.8.0_151</p>
</blockquote>

<p>The strange thing is, after downgrading to java 1.7 it works without any problems. </p>

<p>Also the same application runs on a different 64 bit system (with java 1.8) - so we assume that this might be an issue with os architecture (32 bit), the age of the os (in this case from 2006) and java.</p>

<p>We found some bug reports regarding the open JDK that the maximum length was 2048 - but we are using the regular JDK from oracle in the moment.</p>

<p>Thanks for your help,</p>

<p>Hauke</p>
","<p>please read <a href=""https://www.oracle.com/technetwork/java/javase/8u151-relnotes-3850493.html"" rel=""nofollow noreferrer"">https://www.oracle.com/technetwork/java/javase/8u151-relnotes-3850493.html</a></p>

<p>in Oracle JRE 8u151 you shall find <code>java.security</code> file and set set the <em>crypto.policy</em> to a value of <code>'unlimited'</code>. </p>

<p>I assume your JRE7 has the Unlimited JRE strength policy already installed</p>

<p>Newer versions (8u161, ..) are having the unlimited strength enabled by default.</p>

<p>Please note Oracle JRE 8u151 has a serious issue with decoding gzip stream. When using with a web/application server such as Tomcat, .. you have to disable stream compression or upgrade to a little bit higher <a href=""https://bugs.java.com/view_bug.do?bug_id=JDK-8189789"" rel=""nofollow noreferrer"">https://bugs.java.com/view_bug.do?bug_id=JDK-8189789</a></p>
","180","<java><linux><encryption><diffie-hellman>","0","0","1","2018-11-12 15:28:26","","2","","846507","","2018-11-12 15:22:48","2018-11-12 15:15:52",""
"51462932","Java / Erlang: Diffie Hellman Key Exchange not Working","<p>I wanted to implement my own encryption for my application. I did a major overhaul of this post. I really didn't have much time until today to address it. Hopefully this being the more useful than my original. Spent a ridiculous amount of time on this issue. Hopefully can save others that time.</p>

<p>I encountered several issues while doing this. I did not realize what was happening until the very end. I was getting different shared secrets and later some exceptions.</p>

<p>This is what I tried:</p>

<ul>
<li>Used the built in facilities provided by both languages. Couldn't figure out how to get the raw public key into a form Java could use.</li>
<li>Scratched that and went with the simple formulas to calculate the public and private keys for each party. (This statistically could've worked ~25% of the time... luckily for me it didn't.) </li>
<li>Dived into ASN.1 documentation from the ITU and sent the Erlang public key encoded in a similar manner to Java's keys. Determined this by saving the Java key to a file and using a hex editor. I didn't go back and test at great length. It did get rid of <code>java.security.spec.InvalidKeySpecException: Inappropriate key specification</code>. Think statistics didn't work in my favor here either. The secrets still did not match.</li>
<li>Sent all numbers from Java to the Erlang-side to compute keys, shared secret using Java numbers... Same numbers. There is hope!!!</li>
<li>Started carefully examining the data they were communicating. This was a bit time consuming as Erlang has the data organized in unsigned bytes. The Eclipse IDE (maybe there's a setting somewhere to change) uses signed bytes in byte arrays and a signed integer array within <code>BigInteger</code>.</li>
</ul>

<p>This is where I began to see things. This all was manually entered over many iterations to make sure I found the correct pattern of events. In Erlang I see my public key beginning with <code>&lt;&lt;215, 101, 208, 153,</code>. The first element of the <code>BigInteger</code> on the Java-side is <code>681193318</code>. The buffer the byte data was read into reads: <code>[-41, 101, -48, -103</code>. (Same as Erlang's). However taking the time convert the 1st four elements of the binary string to an integer...</p>

<p><code>&lt;&lt;I:32/signed-integer&gt;&gt; = &lt;&lt;215,101,208,153&gt;&gt;.</code></p>

<p>That yields <code>-681193319</code> versus the big integer's <code>681193318</code></p>

<p>The code I was using was some what simple:</p>

<p>Erlang ""Server"":</p>

<pre><code>-module(echo).
-export([start/0]).

start() -&gt;
    crypto:start(),
    spawn(fun () -&gt; {ok, Sock} = gen_tcp:listen(12321, [binary, {packet, raw}]),
    echo_loop(Sock)
    end).

echo_loop(Sock) -&gt;
    {ok, Conn} = gen_tcp:accept(Sock),
    io:format(""Got connection: ~p~n"", [Conn]),
    Handler = spawn(fun () -&gt; handle(Conn) end),
    gen_tcp:controlling_process(Conn, Handler),
    echo_loop(Sock).

p() -&gt;
    16#ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff.

g() -&gt;
    2.

handle(Conn) -&gt;
    receive
        {tcp, Conn, Yc} -&gt;
            Xs = crypto:strong_rand_bytes(64),
            Ys = crypto:mod_pow(g(),Xs,p()),
            S = crypto:mod_pow(Yc, Xs, p()),

            AESKey = crypto:hash(sha256, S),

            gen_tcp:send(Conn, Ys),%KeyCert),
            handle(Conn);
        {tcp_closed, Conn} -&gt;
            io:format(""Connection closed: ~p~n"", [Conn])
    end.
</code></pre>

<p>Java ""Client"":</p>

<pre><code>public class MyProgram {
    private static Socket s;
    private static OutputStream out;
    private static InputStream in;
    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        MessageDigest hash;
        byte buffer[] = new byte[1024];
        byte buf2[];
        int len = 0;
        byte[] aeskey;

        try {
            hash = MessageDigest.getInstance(""SHA-256"");
            byte    keybuffer[] = new byte[64];
            SecureRandom srnd = SecureRandom.getInstance(""SHA1PRNG"");
            BigInteger Xc, Yc, Sc, Ys;

            srnd.nextBytes(keybuffer);
            Xc = new BigInteger(keybuffer);
            Yc = new BigInteger(""2"").modPow(Xc, DiffieHellman.Group2.P);

            s = new Socket(""localhost"",12321);
            out = s.getOutputStream();
            in = s.getInputStream();

            out.write(Yc.toByteArray());
            out.flush();

            len = in.read(buffer);
            buf2 = new byte[len];
            System.arraycopy(buffer, 0, buf2, 0, len);

            Ys = new BigInteger(buf2);          
            Sc = Ys.modPow(Xc, DiffieHellman.Group2.P);
            aeskey = hash.digest(Sc.toByteArray());

            out.close();
            in.close();
            s.close();
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }       
    }
}
</code></pre>

<p>What was wrong?</p>
","<p>The issue is reading but not understanding the documentation. I spend a lot of time in reference pages because I don't code very often. I did not think much of this particular detail in the documentation for <code>BigInteger</code>:  </p>

<blockquote>
  <p>All operations behave as if Bigintegers were represented in
  <strong>two's-complement notation</strong>...</p>
</blockquote>

<p>There are two spots in my original code where this presents an issue:</p>

<pre><code>       Ys = new BigInteger(buf2);          
       Sc = Ys.modPow(Xc, DiffieHellman.Group2.P);
</code></pre>

<p>The issue with the first line is that if bit 8 is set in the first byte the entire <code>buf2</code> array needs to be prepended with a <code>0x00</code> byte. There is an issue with the second line as well... it does not become evident until the following line is executed: <code>aeskey = hash.digest(Sc.toByteArray());</code></p>

<p>The issue here is if bit 8 is set in the first byte of the result... <code>0x00</code> is prepended to it. This is forwarded to the <code>digest()</code> function but needs to be omitted.</p>

<p>My code changed to what is below and works: :)</p>

<pre><code>    len = in.read(buffer);
    buf2 = new byte[len+1];
    System.arraycopy(buffer, 0, buf2, 1, len);
    buf2[0] = 0;

    if(buf2[1] &lt; 0)
        Ys = new BigInteger(buf2);
    else
        Ys = new BigInteger(Arrays.copyOfRange(buf2, 1, buf2.length));

    Sc = Ys.modPow(Xc, DiffieHellman.Group2.P);
    buffer = Sc.toByteArray();
    if(buffer[0] == 0)
        aeskey = hash.digest(Arrays.copyOfRange(buffer, 1, buffer.length));
    else
        aeskey = hash.digest(buffer);
</code></pre>

<p>These two lines were left as is:</p>

<pre><code>    Xc = new BigInteger(keybuffer);
    Yc = new BigInteger(""2"").modPow(Xc, DiffieHellman.Group2.P);
</code></pre>

<p>This is because the private key can be ""any random number."" The <code>0x00</code> byte is prepended if necessary to the public key of the client in the second line. However Erlang interprets integers as big-endian and any leading <code>0x00</code> bytes end up being irrelevant as it does not affect the numerical value and hence the result when conducting a <code>crypto:mod_pow()</code>.</p>

<p>Comments on how to improve code very welcome.</p>
","172","<java><erlang><x509><diffie-hellman>","2","2","1","2018-11-26 22:42:58","51853823","3","","479836","","2018-11-26 22:42:58","2018-07-22 07:25:50",""
"24228603","Cannot sign with DH key, cannot perform KeyAgreement with others","<p>I would like to know whether there exists a public/private key specification (preferrably in Java itself, no external libs) that can do both a KeyAgreement and Signature.</p>
","<p>Try elliptic curves:</p>

<pre><code>KeyPairGenerator eckpg = KeyPairGenerator.getInstance(""EC"");
ECGenParameterSpec p256 = new ECGenParameterSpec(""secp256r1"");
eckpg.initialize(p256);
KeyPair doubleUseKeyPair = eckpg.generateKeyPair();
KeyAgreement ecdh = KeyAgreement.getInstance(""ECDH"");
ecdh.init(doubleUseKeyPair.getPrivate());
// ...

Signature ecdsa = Signature.getInstance(""SHA256withECDSA"");
ecdsa.initSign(doubleUseKeyPair.getPrivate());
// ...

System.out.println(eckpg.getProvider());
System.out.println(ecdh.getProvider());
System.out.println(ecdsa.getProvider());
</code></pre>

<p>Should return:</p>

<blockquote>
  <p>SunEC version 1.7</p>
  
  <p>SunEC version 1.7</p>
  
  <p>SunEC version 1.7</p>
</blockquote>

<p>This is on Java 7 from Sun/Oracle of course.</p>

<p>Note that using the same key (pair) two different purposes is considered bad key management by most. It may allow for attacks that uses vulnerabilities in either or a combination in both the algorithms and the protocol. Using the same key type / strength is of course fine.</p>
","171","<java><encryption><rsa><digital-signature><diffie-hellman>","1","0","1","2014-06-15 12:24:30","24229557","0","2","","","","2014-06-15 10:15:22",""
"43746590","Diffie Hellman JavaCard","<p>I have a problem with DiffieHellman on JavaCard. I have this class:
<a href=""https://pastebin.com/2F2sQ2Pe"" rel=""nofollow noreferrer"">https://pastebin.com/2F2sQ2Pe</a> (<a href=""https://github.com/ASKGLab/DHApplet"" rel=""nofollow noreferrer"">https://github.com/ASKGLab/DHApplet</a>) ( its bigger file so I uplouded to pastebin not sure if its a problem )</p>

<p>And then I create 2 instance of it and call it like this ( show only one instance ):</p>

<pre><code>DiffieHellman dh = new DiffieHellman();
dh.init();
dh.getY(hostY, (short)0);
dh.setY(cardY, (short) 0, (short) cardY.length, (short) 0); 
AESKey encKey = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES_TRANSIENT_RESET, KeyBuilder.LENGTH_AES_128, false);
dh.doFinal(encKey);
</code></pre>

<p>hostY and cardY are public values. I tried it on desktop App so I have guarance that there is no probleme with Communication with JavaCard. So my question is that after all of this SharedSecret differ and I have no idea why because I execute Y = G^bobPrivKey mod P via RSA's decrypt to get Y's transfer them and then execute S = Y^a mod p via RSA's decrypt. </p>

<p>Thank's for any answer in advance.</p>
","<p>(Assuming you are using <a href=""https://jcardsim.org/"" rel=""nofollow noreferrer"">jCardSim</a> for Java Card API emulation on desktop)</p>

<p>There is a problem with jCardSim that it always uses CRT private keys (as used <code>RSAKeyPairGenerator</code> always generates CRT private keys which always implement <code>RSAPrivateCrtKeyParameters</code> -- see <a href=""https://github.com/licel/jcardsim/blob/jc2.2.1/src/main/java/com/licel/jcardsim/crypto/KeyPairImpl.java#L260"" rel=""nofollow noreferrer"">here</a> and <a href=""https://github.com/licel/jcardsim/blob/jc2.2.1/src/main/java/com/licel/jcardsim/crypto/KeyPairImpl.java#L111"" rel=""nofollow noreferrer"">here</a>).</p>

<p>So every jCardSim RSA private key (even that generated with <code>ALG_RSA</code>) is implemented by <code>RSAPrivateCrtKeyImpl</code> (you can check yourself with <code>.getClass().getCanonicalName()</code>).</p>

<p>The real problem is that <code>RSAPrivateCrtKeyImpl</code> class ignores the value of modulus when doing the actual crypto:</p>

<p><a href=""https://github.com/licel/jcardsim/blob/jc2.2.1/src/main/java/com/licel/jcardsim/crypto/AssymetricCipherImpl.java#L71"" rel=""nofollow noreferrer"">AssymetricCipherImpl.init()</a>:</p>

<pre><code>// ...some code above skipped...
KeyWithParameters key = (KeyWithParameters) theKey;
engine.init(theMode == MODE_ENCRYPT, key.getParameters());
// ...some code below skipped...
</code></pre>

<p><a href=""https://github.com/licel/jcardsim/blob/jc2.2.1/src/main/java/com/licel/jcardsim/crypto/RSAPrivateCrtKeyImpl.java#L121"" rel=""nofollow noreferrer"">RSAPrivateCrtKeyImpl.getParameters()</a> -- there is no use of <code>modulus</code> field:</p>

<pre><code>public CipherParameters getParameters() {
    if (!isInitialized()) {
        CryptoException.throwIt(CryptoException.UNINITIALIZED_KEY);
    }
    // modulus = p * q;
    return new RSAPrivateCrtKeyParameters(p.getBigInteger().multiply(q.getBigInteger()), null,
            null, p.getBigInteger(), q.getBigInteger(),
            dp1.getBigInteger(), dq1.getBigInteger(), pq.getBigInteger());
}
</code></pre>

<p>So the <a href=""https://github.com/ASKGLab/DHApplet/blob/5f335a7acad82edb35f2f96cf3c89ac559d094a3/src/dhapplet/DH.java#L191"" rel=""nofollow noreferrer""><code>setModulus()</code> call</a> used to set the desired DH Group prime has no effect and the original (generated) modulus is used.</p>

<p>Good luck!</p>
","169","<java><javacard><diffie-hellman>","0","2","1","2017-05-03 16:21:10","43765349","4","","","","","2017-05-02 20:22:11",""
"31681758","Diffie Hellman+AES on C# to Android data encryption","<p>Anyone know how to implement data exchange between Android app and c# Webservice and vice versa by using DH key exchange with AES encryption. Because writing hard-coded encryption key in Andoird is not secure that anyone can do re-engineering and collect the private hard-coded key..</p>
","","164","<c#><android><aes><diffie-hellman>","0","","0","2018-12-15 13:05:20","","2","","1033581","","2018-12-15 13:05:20","2015-07-28 16:10:40",""
"30698894","Diffie Hellman with authentication","<p>in this link:
<a href=""http://docstore.mik.ua/orelly/java-ent/security/ch13_07.htm"" rel=""nofollow"">http://docstore.mik.ua/orelly/java-ent/security/ch13_07.htm</a>
I found the implementation of Diffie Hellman exchange, but I don't undersand why it use X509EncodedKeySpec object;
Morover, how can I modify the program to avoid the ""man in the middle"" attack?
Thanks.</p>
","","153","<java><security><network-programming><diffie-hellman><network-security>","0","","0","2015-06-07 22:01:59","","2","","","","","2015-06-07 22:01:59",""
"50874329","How to Encode nodejs ecdh public key as pem","<p><a href=""https://stackoverflow.com/questions/39696888/unable-to-sign-a-file-with-nodejs-crypto/50873668#50873668"">Unable to sign a file with nodejs crypto</a></p>

<p>I am trying to verify a signed document created like in this thread using the method verify.verify() with the ECDH public key. Therefore, i guess, i have to format the raw public key into valid PEM.</p>

<p>How would i do that using the ans1.js and bn.js module?</p>
","","153","<node.js><sign><cryptojs><verify><diffie-hellman>","2","","0","2018-06-15 11:06:57","","0","","","","","2018-06-15 11:06:57",""
"31864533","SonarQube: weak ephemeral Diffie-Hellman key issue with SSL","<p>How do we by pass this issue with SonarQube server v5.1 and firefox? Chrome &amp; IE are working fine but firefox is not allowing to access the server in https mode. I looked at <a href=""https://weakdh.org/sysadmin.html"" rel=""nofollow"">https://weakdh.org/sysadmin.html</a> but I am not sure what server SonarQube uses and how to implement fix for this problem. Any help is appreciated. Thanks.</p>
","<p>When a user wants to enable (or restrict) access to a SonarQube instance over HTTPS, the recommended way is to put it behind another WebServer she configures at will.</p>

<p>So, the way to go here, is to add an Apache, Nginx or whatever in front of the SQ instance and configure it according to the recommendations in the <a href=""https://weakdh.org/sysadmin.html"" rel=""nofollow"">link</a> you provided and generate a ""safe"" server certificate.</p>
","149","<ssl><sonarqube><diffie-hellman>","1","0","2","2015-11-25 17:51:23","31874178","0","","","","","2015-08-06 19:48:39",""
"31864533","SonarQube: weak ephemeral Diffie-Hellman key issue with SSL","<p>How do we by pass this issue with SonarQube server v5.1 and firefox? Chrome &amp; IE are working fine but firefox is not allowing to access the server in https mode. I looked at <a href=""https://weakdh.org/sysadmin.html"" rel=""nofollow"">https://weakdh.org/sysadmin.html</a> but I am not sure what server SonarQube uses and how to implement fix for this problem. Any help is appreciated. Thanks.</p>
","<p>I fixed it by setting the following property in sonar.properties file. </p>

<p>sonar.web.https.ciphers=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA</p>
","149","<ssl><sonarqube><diffie-hellman>","1","0","2","2015-11-25 17:51:23","31874178","0","","","","","2015-08-06 19:48:39",""
"17187964","OpenId 2.0: session type vs. association type","<p>The <a href=""http://openid.net/specs/openid-authentication-2_0.html"" rel=""nofollow"">OpenID 2.0 specification</a> says very little about the relation between the session type and association type in OpenID association requests.  My questions: (1) Is a combination of session type ""DH-SHA1"" and association type ""HMAC-SHA256"" valid?  (2) How about the reverse, i.e. ""DH-SHA256"" and ""HMAC-SHA1""?</p>

<p>I don't think these mixed combinations are explicitly forbidden by the spec, but section 8.2.3 describes the process of encrypting the MAC key for transport as follows:</p>

<pre><code>enc_mac_key

     Value: base64(H(btwoc(g ^ (xa * xb) mod p)) XOR MAC key)

     Description: The MAC key (shared secret), encrypted with the
     secret Diffie-Hellman value.  H is either ""SHA1"" or ""SHA256""
     depending on the session type.
</code></pre>

<p>Does this imply that the MAC key length must be 20 bytes for session type DH-SHA1 and 32 byte for session type DH-SHA256?  Section 6.2 of the spec states</p>

<pre><code>OpenID Authentication supports two signature algorithms:
o  HMAC-SHA1 - 160 bit key length ([RFC2104] and [RFC3174])
o  HMAC-SHA256 - 256 bit key length ([RFC2104] and [FIPS180-2]
</code></pre>

<p>Does this then imply that DH-SHA1 always must be paired with HMAC-SHA1 and the same for the ...256 versions?</p>

<p>Another data point: the OpenId provider at <a href=""https://me.yahoo.com/"" rel=""nofollow"">https://me.yahoo.com/</a> seems to accept association requests with session type DH-SHA1 and association type HMAC-SHA256, returning a 20 byte MAC key.</p>
","","148","<openid><diffie-hellman><openid-provider>","2","","0","2013-06-19 09:41:35","","3","","","","","2013-06-19 09:41:35",""
"54536057","OpenSSL used fixed Values for Diffie Hellman Key generation","<p>According to that piece of documentation: <a href=""https://wiki.openssl.org/index.php/Diffie_Hellman#Using_the_Low_Level_APIs"" rel=""nofollow noreferrer"">https://wiki.openssl.org/index.php/Diffie_Hellman#Using_the_Low_Level_APIs</a></p>

<p>Using the Low level API's for Diffie Hellman (need to perform a group Key agreement). </p>

<p>For simplicity I need to provide fixed values for Diffie Hellman <code>p</code> and <code>g</code> values for now I use the function <code>DH_generate_parameters_ex</code> but any solution using these options may add a communication overhead and there are fixed values for <code>p</code> and <code>g</code> for Diffie Hellman offering good security.</p>

<p>So using the approach convention over configuration, how I can set fixed values especially the ones specified in this <a href=""https://tools.ietf.org/html/rfc3526"" rel=""nofollow noreferrer"">RFC</a> to openssl low-level api fore diffie hellman instyead of generating ones on the fly?</p>

<p>PS I use the OpenSSL version 1.0.2g.</p>
","<p>The (outer) <em>primes</em> for the RFC3526 and RFC2409 groups are builtin, per <a href=""https://www.openssl.org/docs/man1.1.0/man3/DH_get_1024_160.html"" rel=""nofollow noreferrer"">this man page</a> (should also be on your system under those names if 1.1.0+) -- they are actually in the code back to before 1.0.0 but without the <code>BN_</code> prefix (though in the <code>bn.h</code> header) and previously undocumented. (In 1.1.0+ the old names are additionally #define'd if compatibility is set.) </p>

<p>AFAICS you must add the generator yourself, something like:</p>

<pre><code>DH *dh = DH_new(); BIGNUM *two = BN_new(); 
if( !dh || !two ) /* error */;
BN_set_word(two,2); 

// corrected AGAIN!
DH_set0_pqg (dh, BN_dup(BN_get_rfc3526_prime_2048(NULL)), NULL, two);

// added: below 1.1.0 many API structs were not opaque, just
dh-&gt;p = BN_dup(/*not BN_*/ get_rfc3526_prime_2048(NULL));
dh-&gt;g = two; 
// leave q as unspecified
</code></pre>

<p>Note RFC5114 modp parameters are available prebuilt in <code>DH*</code> form but only in 1.1.0+. </p>
","147","<c><openssl><diffie-hellman>","2","2","1","2019-02-17 04:50:55","","0","1","4706711","","2019-02-05 20:56:09","2019-02-05 13:57:09",""
"50985879","Failed to unwrap key exception android O on Diffie-Hellman encryption","<p>I am using Diffie-Hellman encryption and decryption algorithm for my app username and password.I am using my keystore to store information and retrieving It is working properly working in below android O.Recently i am facing this issue please help me</p>

<pre><code>java.security.InvalidKeyException: Failed to unwrap key
java.security.InvalidKeyException: Failed to unwrap key\n
Caused by: com.sample.example.sdk.manager.utils.CustomException: java.security.InvalidKeyException: Failed to unwrap key\n\tat 
com.sample.example.sdk.manager.KeyPairHelper.getDevicePrivatekKey(KeyPairHelper.java:60)\n\tat 
com.sample.example.sdk.manager.SampleTask.buildAesKey(SampleTask.java:100)\n\tat 
com.sample.example.sdk.manager.SampleTask.call(SampleTask.java:186)\n\tat 
com.sample.example.sdk.manager.SampleTask.call(SampleTask.java:66)\n\tat 
io.reactivex.internal.operators.observable.ObservableFromCallable.subscribeActual(ObservableFromCallable.java:42)\n\tat 
io.reactivex.Observable.subscribe(Observable.java:10842)\n\tat 
io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)\n\tat 
io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)\n\tat io.reactivex.internal.
schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat 
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)\n\tat 
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n\tat 
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n\tat 
java.lang.Thread.run(Thread.java:764)\n
Caused by: java.security.InvalidKeyException: Failed to unwrap key\n\tat 
android.security.keystore.AndroidKeyStoreCipherSpiBase.engineUnwrap(AndroidKeyStoreCipherSpiBase.java:682)\n\tat 
javax.crypto.Cipher.unwrap(Cipher.java:2121)\n\tat 
com.sample.example.sdk.manager.utils.Custom.getEncryptionKey(Custom.java:312)\n\tat 
com.sample.example.sdk.manager.utils.Custom.\u003cinit\u003e(Custom.java:108)\n\t
... 15 more\nCaused by: javax.crypto.IllegalBlockSizeException\n\tat 
android.security.keystore.AndroidKeyStoreCipherSpiBase.engineDoFinal(AndroidKeyStoreCipherSpiBase.java:519)\n\tat 
android.security.keystore.AndroidKeyStoreCipherSpiBase.engineUnwrap(AndroidKeyStoreCipherSpiBase.java:680)\n\t... 18 more\n
Caused by: android.security.KeyStoreException: Unknown error\n\tat 
android.security.KeyStore.getKeyStoreException(KeyStore.java:1137)\n\tat android.security.keystore.KeyStoreCryptoOp
</code></pre>
","","147","<android><android-8.0-oreo><android-keystore><diffie-hellman>","3","","0","2018-06-22 11:51:08","","0","1","2991069","","2018-06-22 11:51:08","2018-06-22 10:24:04",""
"55536893","How to convert hex public key to ASN.1 SubjectPublicKeyInfo structure for Diffie-Hellman key exchange?","<p>I am trying to implement Diffie-Hellman key exchange to generate the symmetric key for encryption/decryption using JAVA cryptography packages. This requires a public key exchange between the two parties. </p>

<p>The public key shared by the client is 1024 bit hexadecimal string, which should be used to calculate the shared secret key. How to convert this string into an encoded key format (ASN.1 SubjectPublicKeyInfo structure) to create a PublicKey object.</p>

<p>Considering a sample public key string. Parameters <em>p</em> and <em>g</em> are fed into <em>inputDHParameterSpec</em> object.</p>

<p><strong>Sample implementation:
AutoGen keypair:</strong></p>

<pre class=""lang-java prettyprint-override""><code>    KeyPairGenerator clientKpairGen = keyPairGenerator.getInstance(""DiffieHellman"");
    clientKpairGen.initialize(inputDHParameterSpec);
    KeyPair clientKpair = clientKpairGen.generateKeyPair();
    byte[] clientPubKeyEnc = clientKpair.getPublic().getEncoded();

    X509EncodedKeySpec testPubKeySpec = new X509EncodedKeySpec(clientPubKeyEnc);
    KeyFactory keyFactory = KeyFactory.getInstance(""DiffieHellman"");
    PublicKey clientPubKey = keyFactory.generatePublic(testPubKeySpec);
</code></pre>

<p><strong>Hex PublicKey - failing:</strong></p>

<pre class=""lang-java prettyprint-override""><code>    String testPublicKey = ""85f04dd00345642ad12b65bd1a7c38728bff0b8e281ddb6ac4f2739e82a02145daabf23d173c933913b1f844059710e9125591569de427eae1d269accbfa3305069deb7622d1da3ad9820d11bd24fdcce5381d2df99bda314394738dfcbe210eae247b1303e79297ff746cd919e189f6a5776e6ecc24c8900de0f38f159072de"";
    X509EncodedKeySpec testPubKeySpec = new X509EncodedKeySpec(hexStringToByteArray(testPublicKey));
    KeyFactory keyFactory = KeyFactory.getInstance(""DiffieHellman"");
    PublicKey clientPubKey = keyFactory.generatePublic(testPubKeySpec);//Failing here
</code></pre>

<p>byte[] created in first code block has public key in ASN.1 encoded format, but <em>hexStringToByteArray(testPublicKey)</em> merely converts the hex to byte[]. Getting the below error on the marked line, due to this. </p>

<pre><code>Exception in thread ""main"" java.security.spec.InvalidKeySpecException: Inappropriate key specification
    at com.sun.crypto.provider.DHKeyFactory.engineGeneratePublic(DHKeyFactory.java:85)
    at java.security.KeyFactory.generatePublic(KeyFactory.java:334)
    at MWK_DHGen.main(MWK_DHGen.java:87)
Caused by: java.security.InvalidKeyException: Error parsing key encoding
    at com.sun.crypto.provider.DHPublicKey.&lt;init&gt;(DHPublicKey.java:178)
    at com.sun.crypto.provider.DHKeyFactory.engineGeneratePublic(DHKeyFactory.java:78)
    ... 2 more
</code></pre>

<p>Can someone help on how to convert this hex to the requried format here? A different implementation that would use this hex string to arrive at the secret key is also encouraged.</p>
","<p>If you already have the domain parameters (p, g) and just the integer value of the public key then a <a href=""https://docs.oracle.com/javase/8/docs/api/javax/crypto/spec/DHPublicKeySpec.html"" rel=""nofollow noreferrer""><code>DHPublicKeySpec</code></a> rather than an <code>X509EncodedKeySpec</code> is the way to go:</p>

<pre><code>String testPublicKey = ""85f04dd00345642ad12b65bd1a7c38728bff0b8e281ddb6ac4f2739e82a02145daabf23d173c933913b1f844059710e9125591569de427eae1d269accbfa3305069deb7622d1da3ad9820d11bd24fdcce5381d2df99bda314394738dfcbe210eae247b1303e79297ff746cd919e189f6a5776e6ecc24c8900de0f38f159072de"";
BigInteger publicKeyInteger = new BigInteger(testPublicKey, 16);
KeyFactory keyFactory = KeyFactory.getInstance(""DiffieHellman"");
PublicKey clientPubKey = keyFactory.generatePublic(new DHPublicKeySpec(publicKeyInteger, g, p));
</code></pre>
","147","<java><public-key><asn.1><diffie-hellman><public-key-exchange>","1","1","1","2019-04-05 16:00:10","55539379","0","","","","","2019-04-05 13:49:57",""
"53669673","Diffie Hellman Key Exchange using ECDSA x509 certificates","<p>I am trying to perform a Diffie-Hellman key exchange using 2 ECDSA x509 certificates.</p>

<p>Here is the method where I extract the keys from the certificates for computation of the derived key.</p>

<pre><code>private byte[] GetDerivedKey(X509Certificate2 publicCertificate, X509Certificate2 privateCertificate)
    {
        byte[] derivedKey;

        using (var privateKey = privateCertificate.GetECDsaPrivateKey())
        using (var publicKey = publicCertificate.GetECDsaPublicKey())
        {
            var privateParams = privateKey.ExportParameters(true);  //This line is failing
            var publicParams = publicKey.ExportParameters(false);

            using (var privateCng = ECDiffieHellmanCng.Create(privateParams))
            using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
            {
                derivedKey = privateCng.DeriveKeyMaterial(publicCng.PublicKey);
            }
        }


        return derivedKey;
    }
</code></pre>

<p>I've commented on the line that is failing <code>privateKey.ExportParameters(true)</code> with the error:</p>

<blockquote>
  <p>System.Security.Cryptography.CryptographicException : The requested operation is not supported.  </p>
  
  <p>at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)<br>
     at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)<br>
     at System.Security.Cryptography.ECCng.ExportParameters(CngKey key, Boolean includePrivateParameters, ECParameters&amp; ecparams)<br>
     at System.Security.Cryptography.ECDsaCng.ExportParameters(Boolean includePrivateParameters)</p>
</blockquote>

<p>Because this is a self signed certificate that I am generating, I assume I am doing something wrong.</p>

<p>I first create a root CA certificate and pass in the private key to sign my certificate.</p>

<pre><code>private X509Certificate2 CreateECSDACertificate(string certificateName,
        string issuerCertificateName,
        TimeSpan lifetime,
        AsymmetricKeyParameter issuerPrivateKey,
        string certificateFriendlyName = null)
    {
        // Generating Random Numbers
        var randomGenerator = new CryptoApiRandomGenerator();
        var random = new SecureRandom(randomGenerator);

        var signatureFactory = new Asn1SignatureFactory(""SHA256WithECDSA"", issuerPrivateKey, random);

        // The Certificate Generator
        var certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        var serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Issuer and Subject Name
        var subjectDistinguishedName = new X509Name($""CN={certificateName}"");
        var issuerDistinguishedName = new X509Name($""CN={issuerCertificateName}"");
        certificateGenerator.SetSubjectDN(subjectDistinguishedName);
        certificateGenerator.SetIssuerDN(issuerDistinguishedName);

        // Valid For
        var notBefore = DateTime.UtcNow.Date;
        var notAfter = notBefore.Add(lifetime);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        //key generation
        var keyGenerationParameters = new KeyGenerationParameters(random, _keyStrength);
        var keyPairGenerator = new ECKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        var subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        var certificate = certificateGenerator.Generate(signatureFactory);

        var store = new Pkcs12Store();
        var certificateEntry = new X509CertificateEntry(certificate);
        store.SetCertificateEntry(certificateName, certificateEntry);
        store.SetKeyEntry(certificateName, new AsymmetricKeyEntry(subjectKeyPair.Private), new[] { certificateEntry });

        X509Certificate2 x509;

        using (var pfxStream = new MemoryStream())
        {
            store.Save(pfxStream, null, new SecureRandom());
            pfxStream.Seek(0, SeekOrigin.Begin);
            x509 = new X509Certificate2(pfxStream.ToArray());
        }

        x509.FriendlyName = certificateFriendlyName;

        return x509;
    }
</code></pre>

<p>The <code>.HasPrivateKey()</code> method returns true, which I've read can return a false positive.  </p>

<p>When I add my certificates to the store, I can verify the cert chain.</p>

<pre><code>    [Test]
    public void CreateSelfSignedCertificate_AfterAddingToStore_CanBuildChain()
    {
        var result = _target.CreateSelfSignedCertificate(_subject, _issuer, TimeSpan.FromDays(356), _certificateFriendlyName, _issuerFriendlyName);

        _store.TryAddCertificateToStore(result.CertificateAuthority, _caStoreName, _location);
        _store.TryAddCertificateToStore(result.Certificate, _certStoreName, _location);

        var chain = new X509Chain
        {
            ChainPolicy =
            {
                RevocationMode = X509RevocationMode.NoCheck
            }
        };

        var chainBuilt = chain.Build(result.Certificate);

        if (!chainBuilt)
        {
            foreach (var status in chain.ChainStatus)
            {
                Assert.Warn(string.Format(""Chain error: {0} {1}"", status.Status, status.StatusInformation));
            }
        }

        Assert.IsTrue(chainBuilt, ""Chain"");
    }
</code></pre>

<p>I thought at first that maybe the private cert had to come from the cert store, so I imported it and then pulled it back out, but I get the same error, which is another reason I believe I'm not doing something quite right.</p>

<p><strong>EDIT:</strong></p>

<p>I have another class generating RSA x509's using the same code for putting the private key into the certificate.  It allows me to export the RSA private key.  </p>

<p>The variable <code>_keyStrength</code> is 384 and my signature factory is using <code>""SHA256withECDSA""</code>.  I have also tried using <code>""SHA384withECDSA""</code> but I get the same error.</p>
","<p>OK. It's a blind shot but after looking at your code I noticed two things:</p>

<ul>
<li>When you create PFX you set null password. But when you load the PFX into <code>X509Certificate2</code> class you are using wrong constructor. You should use one with a password parameter and give a null into it</li>
<li>When you load PFX into <code>X509Certificate2</code> class you do not specify, if the private key should be exportable. I think that this is the reason why <code>privateKey.ExportParameters(true)</code> gives you an exception. You should use <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509certificate2.-ctor?view=netframework-4.7.2#System_Security_Cryptography_X509Certificates_X509Certificate2__ctor_System_Byte___System_Security_SecureString_System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_"" rel=""nofollow noreferrer"">this</a> constructor and specify <code>null</code> as password</li>
</ul>

<hr>

<h1>Made it working</h1>

<p>I thought it was a bug. It's possible that it is. We clearly stated in X509Constructor that the private key should be exportable. I used <code>X509KeyStorageFlags.EphemeralKeySet | X509KeyStorageFlags.Exportable</code> flags too. But when I looked at the CngKey it had ExportPolicy set to <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.cngexportpolicies?view=netframework-4.7.2"" rel=""nofollow noreferrer""><code>AllowExport</code></a> but not <code>AllowPlaintextExport</code>. </p>

<p>It was exportable in some way. <code>privateKey.Key.Export(CngKeyBlobFormat.OpaqueTransportBlob)</code> worked. But <code>privateKey.ExportParameters(true)</code> did not.</p>

<p>I've searched for a solution how to change ExportPolicy of CngKey. I found <a href=""https://stackoverflow.com/q/48542233/3245057"">this SO question</a> that helped me to change it. After that the <code>ExportParameters</code> worked.</p>

<p>The fixed version of your <code>GetDerivedKey</code> method is</p>

<pre><code>private byte[] GetDerivedKey(X509Certificate2 publicCertificate, X509Certificate2 privateCertificate)
{
    byte[] derivedKey;

    using (var privateKey = privateCertificate.GetECDsaPrivateKey())
    using (var publicKey = privateCertificate.GetECDsaPublicKey())
    {
        var myPrivateKeyToMessWith = privateKey as ECDsaCng;

        // start - taken from https://stackoverflow.com/q/48542233/3245057 
        // make private key exportable:
        byte[] bytes = BitConverter.GetBytes((int)(CngExportPolicies.AllowExport | CngExportPolicies.AllowPlaintextExport));
        CngProperty pty = new CngProperty(NCryptExportPolicyProperty, bytes, CngPropertyOptions.Persist);
        myPrivateKeyToMessWith.Key.SetProperty(pty);
        // end - taken from https://stackoverflow.com/q/48542233/3245057

        var privateParams = myPrivateKeyToMessWith.ExportParameters(true);  //This line is NOT failing anymore
        var publicParams = publicKey.ExportParameters(false);

        using (var privateCng = ECDiffieHellmanCng.Create(privateParams))
        using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
        {
            derivedKey = privateCng.DeriveKeyMaterial(publicCng.PublicKey);
        }
    }

    return derivedKey;
}
</code></pre>
","146","<c#><bouncycastle><x509certificate2><ecdsa><diffie-hellman>","1","2","2","2018-12-07 16:34:19","53670577","0","","107455","","2018-12-07 14:27:20","2018-12-07 12:35:42",""
"53669673","Diffie Hellman Key Exchange using ECDSA x509 certificates","<p>I am trying to perform a Diffie-Hellman key exchange using 2 ECDSA x509 certificates.</p>

<p>Here is the method where I extract the keys from the certificates for computation of the derived key.</p>

<pre><code>private byte[] GetDerivedKey(X509Certificate2 publicCertificate, X509Certificate2 privateCertificate)
    {
        byte[] derivedKey;

        using (var privateKey = privateCertificate.GetECDsaPrivateKey())
        using (var publicKey = publicCertificate.GetECDsaPublicKey())
        {
            var privateParams = privateKey.ExportParameters(true);  //This line is failing
            var publicParams = publicKey.ExportParameters(false);

            using (var privateCng = ECDiffieHellmanCng.Create(privateParams))
            using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
            {
                derivedKey = privateCng.DeriveKeyMaterial(publicCng.PublicKey);
            }
        }


        return derivedKey;
    }
</code></pre>

<p>I've commented on the line that is failing <code>privateKey.ExportParameters(true)</code> with the error:</p>

<blockquote>
  <p>System.Security.Cryptography.CryptographicException : The requested operation is not supported.  </p>
  
  <p>at System.Security.Cryptography.NCryptNative.ExportKey(SafeNCryptKeyHandle key, String format)<br>
     at System.Security.Cryptography.CngKey.Export(CngKeyBlobFormat format)<br>
     at System.Security.Cryptography.ECCng.ExportParameters(CngKey key, Boolean includePrivateParameters, ECParameters&amp; ecparams)<br>
     at System.Security.Cryptography.ECDsaCng.ExportParameters(Boolean includePrivateParameters)</p>
</blockquote>

<p>Because this is a self signed certificate that I am generating, I assume I am doing something wrong.</p>

<p>I first create a root CA certificate and pass in the private key to sign my certificate.</p>

<pre><code>private X509Certificate2 CreateECSDACertificate(string certificateName,
        string issuerCertificateName,
        TimeSpan lifetime,
        AsymmetricKeyParameter issuerPrivateKey,
        string certificateFriendlyName = null)
    {
        // Generating Random Numbers
        var randomGenerator = new CryptoApiRandomGenerator();
        var random = new SecureRandom(randomGenerator);

        var signatureFactory = new Asn1SignatureFactory(""SHA256WithECDSA"", issuerPrivateKey, random);

        // The Certificate Generator
        var certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        var serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Issuer and Subject Name
        var subjectDistinguishedName = new X509Name($""CN={certificateName}"");
        var issuerDistinguishedName = new X509Name($""CN={issuerCertificateName}"");
        certificateGenerator.SetSubjectDN(subjectDistinguishedName);
        certificateGenerator.SetIssuerDN(issuerDistinguishedName);

        // Valid For
        var notBefore = DateTime.UtcNow.Date;
        var notAfter = notBefore.Add(lifetime);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        //key generation
        var keyGenerationParameters = new KeyGenerationParameters(random, _keyStrength);
        var keyPairGenerator = new ECKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        var subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        var certificate = certificateGenerator.Generate(signatureFactory);

        var store = new Pkcs12Store();
        var certificateEntry = new X509CertificateEntry(certificate);
        store.SetCertificateEntry(certificateName, certificateEntry);
        store.SetKeyEntry(certificateName, new AsymmetricKeyEntry(subjectKeyPair.Private), new[] { certificateEntry });

        X509Certificate2 x509;

        using (var pfxStream = new MemoryStream())
        {
            store.Save(pfxStream, null, new SecureRandom());
            pfxStream.Seek(0, SeekOrigin.Begin);
            x509 = new X509Certificate2(pfxStream.ToArray());
        }

        x509.FriendlyName = certificateFriendlyName;

        return x509;
    }
</code></pre>

<p>The <code>.HasPrivateKey()</code> method returns true, which I've read can return a false positive.  </p>

<p>When I add my certificates to the store, I can verify the cert chain.</p>

<pre><code>    [Test]
    public void CreateSelfSignedCertificate_AfterAddingToStore_CanBuildChain()
    {
        var result = _target.CreateSelfSignedCertificate(_subject, _issuer, TimeSpan.FromDays(356), _certificateFriendlyName, _issuerFriendlyName);

        _store.TryAddCertificateToStore(result.CertificateAuthority, _caStoreName, _location);
        _store.TryAddCertificateToStore(result.Certificate, _certStoreName, _location);

        var chain = new X509Chain
        {
            ChainPolicy =
            {
                RevocationMode = X509RevocationMode.NoCheck
            }
        };

        var chainBuilt = chain.Build(result.Certificate);

        if (!chainBuilt)
        {
            foreach (var status in chain.ChainStatus)
            {
                Assert.Warn(string.Format(""Chain error: {0} {1}"", status.Status, status.StatusInformation));
            }
        }

        Assert.IsTrue(chainBuilt, ""Chain"");
    }
</code></pre>

<p>I thought at first that maybe the private cert had to come from the cert store, so I imported it and then pulled it back out, but I get the same error, which is another reason I believe I'm not doing something quite right.</p>

<p><strong>EDIT:</strong></p>

<p>I have another class generating RSA x509's using the same code for putting the private key into the certificate.  It allows me to export the RSA private key.  </p>

<p>The variable <code>_keyStrength</code> is 384 and my signature factory is using <code>""SHA256withECDSA""</code>.  I have also tried using <code>""SHA384withECDSA""</code> but I get the same error.</p>
","<p>I started using the solution @pepo posted which lead me to discover 'GetECDsaPrivateKey' does not return an <code>ECDsa</code> object but an <code>ECDsaCng</code>.  I simplified the key derivation to this.</p>

<pre><code>byte[] derivedKey;

using (var privateKey = (ECDsaCng)certificate.GetECDsaPrivateKey())
using (var publicKey = (ECDsaCng)certificate.GetECDsaPublicKey())
{
    var publicParams = publicKey.ExportParameters(false);

    using (var publicCng = ECDiffieHellmanCng.Create(publicParams))
    using (var diffieHellman = new ECDiffieHellmanCng(privateKey.Key))
    {
        derivedKey = diffieHellman.DeriveKeyMaterial(publicCng.PublicKey);
    }
}

return derivedKey;
</code></pre>
","146","<c#><bouncycastle><x509certificate2><ecdsa><diffie-hellman>","1","0","2","2018-12-07 16:34:19","53670577","0","","107455","","2018-12-07 14:27:20","2018-12-07 12:35:42",""
"18166053","Is the code I wrote for my exercise efficient?","<p>I've learned to write code implementing the Diffie-Hellman key exchange algorithm below, but I feel that my code isn't at its most efficient. Can anyone correct my code please...?</p>

<pre><code>import java.math.BigInteger;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Random;;

    public class DH_key {
        static class DHGenParameterSpec implements AlgorithmParameterSpec{
            static BigInteger p;
            static BigInteger g;
            static int a,b;
            static BigInteger A,B;
        static BigInteger getPrimeP_G() {
            Random rand1= new Random(System.currentTimeMillis());
            Random rand2= new Random(System.currentTimeMillis()*10);

            p= BigInteger.probablePrime(32, rand1);
            g= BigInteger.probablePrime(32, rand2);
            System.out.println(""""+p+"",""+g);
            return null;
        }
        static int getExponent() {
            SecureRandom ranGen1 = new SecureRandom();

            a= ranGen1.nextInt(1000);
            b= ranGen1.nextInt(1000);
            System.out.println(a+""__""+b);
            return 0 ;

        }
        public static Object pow (){
            //g.pow(a);
            A = g.pow(getExponent()).mod(getPrimeP_G());
            B = g.pow(b).mod(p);

            return null;        
        }



    public static void main(String[]args){
        //System.out.println(DHGenParameterSpec.getPrimeP_G());
        DHGenParameterSpec.getPrimeP_G();
        DHGenParameterSpec.getExponent();
        A = g.pow(a).mod(p);
        B = g.pow(b).mod(p);

        BigInteger Sa,Sb;
        Sa=B.pow(a).mod(p);
        Sb=A.pow(b).mod(p);

            System.out.println(""""+A+""__""+B);
                System.out.println(""""+Sa+""__""+Sb);
        }

        }

    }
</code></pre>

<p>Was the code above appropriate with java rules??<br></p>
","<p>You have written modular exponentiation as:</p>

<pre><code>        A = g.pow(getExponent()).mod(getPrimeP_G());
        B = g.pow(b).mod(p);
</code></pre>

<p>This is inefficient because the intermediate result from the exponentiation can be a large number. You should use the <a href=""http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html#modPow%28java.math.BigInteger,%20java.math.BigInteger%29"" rel=""nofollow""><code>modPow</code></a> method instead, which does the two operations with an efficient algorithm:</p>

<pre><code>        A = g.modPow(getExponent(), getPrimeP_G());
        B = g.modPow(b, p);
</code></pre>
","132","<java><performance><diffie-hellman>","0","1","1","2013-08-11 00:42:39","18166137","1","1","485864","","2013-08-11 00:42:39","2013-08-10 20:27:10","2013-08-11 06:56:45"
"41080700","What does cracking a Diffie-Helman prime number mean?","<p>I am doing a project on the Diffie-Helman key exchange and this isn't necessary for my project but I am very interested in how you 'crack' a prime number.  </p>
","<p>You crack a Diffie-Hellman semi-prime by factoring it into its two constituent prime factors. The security of Diffie-Hellman comes from the fact that it is not possible, with current technology, to factor semi-primes of the size that are used in cryptography.</p>
","130","<primes><diffie-hellman>","-3","0","1","2019-08-26 13:01:51","","3","","225647","","2019-08-26 13:01:51","2016-12-10 21:52:15",""
"54976616","Java generate DH public key size is not the same size as sample that documentation have","<p>One of my documentation said </p>

<blockquote>
  <p>Generate the private and public keys using the Diffie-Hellman parameters (‘p’ and ‘g’). The result is
  ‘Pub_key’and ‘Priv_key’ (1024-bit/128 bytes).</p>
</blockquote>

<p>where P and G are giving by following:</p>

<blockquote>
  <p>Diffie-Hellman-Parameters: (1024 bit)
  Prime (p):
  e5:16:e4:3e:54:57:b2:f6:6f:6c:a3:67:b3:35:ea:
  d8:31:99:39:fa:4d:f6:c1:b7:f8:6e:73:e9:22:a6:
  d1:93:93:25:5e:41:90:96:66:81:74:e3:5c:81:8a:
  66:11:7f:79:9e:86:66:c8:05:0e:e4:36:f9:80:13:
  51:60:6c:55:d4:5f:ab:a0:3f:39:e2:92:3b:a9:26:
  a9:cd:75:d4:bd:bc:a9:de:78:b6:2a:9b:84:7a:78:
  1c:69:2c:06:3e:aa:cb:43:a3:96:f0:1d:12:1d:04:
  27:55:d0:b7:c0:b2:df:a8:b4:98:a5:7e:4d:90:c3:
  0c:a0:49:a7:ac:2b:7f:73</p>
  
  <p>generator (g): 5 (0x5)</p>
</blockquote>

<p>The sample data that documentation gave about the public key is following:</p>

<blockquote>
  <p>85:f0:4d:d0:03:45:64:2a:d1:2b:65:bd:1a:7c:38:72:8b:ff:0b:8e:28:1d:db:
  6a:c4:f2:73:9e:82:a0:21:45:da:ab:f2:3d:17:3c:93:39:13:b1:f8:44:05:97:
  10:e9:12:55:91:56:9d:e4:27:ea:e1:d2:69:ac:cb:fa:33:05:06:9d:eb:76:22:
  d1:da:3a:d9:82:0d:11:bd:24:fd:cc:e5:38:1d:2d:f9:9b:da:31:43:94:73:8d:
  fc:be:21:0e:ae:24:7b:13:03:e7:92:97:ff:74:6c:d9:19:e1:89:f6:a5:77:6e:
  6e:cc:24:c8:90:0d:e0:f3:8f:15:90:72:de</p>
</blockquote>

<p>However, when I try my self using Java to generate the DH public key using the parameter, I get something following like this:</p>

<blockquote>
  <p>30:82:01:24:30:81:99:06:09:2A:86:48:86:F7:0D:01:03:01:30:81:8B:02:81:81:00:E5:16:E4:3E:54:57:B2:F6:6F:6C:A3:67:B3:35:EA:D8:31:99:39:FA:4D:F6:C1:B7:F8:6E:73:E9:22:A6:D1:93:93:25:5E:41:90:96:66:81:74:E3:5C:81:8A:66:11:7F:79:9E:86:66:C8:05:0E:E4:36:F9:80:13:51:60:6C:55:D4:5F:AB:A0:3F:39:E2:92:3B:A9:26:A9:CD:75:D4:BD:BC:A9:DE:78:B6:2A:9B:84:7A:78:1C:69:2C:06:3E:AA:CB:43:A3:96:F0:1D:12:1D:04:27:55:D0:B7:C0:B2:DF:A8:B4:98:A5:7E:4D:90:C3:0C:A0:49:A7:AC:2B:7F:73:02:01:05:02:02:02:00:03:81:85:00:02:81:81:00:A9:AF:1C:F3:45:77:8C:BA:BC:32:59:52:7B:EA:90:80:74:9A:1D:A7:01:D4:C4:10:74:4C:6E:E9:35:36:49:6D:0D:03:F5:2D:EC:FA:C5:CE:CD:C9:23:D3:F5:2F:C2:E0:3E:54:3C:A1:20:6B:ED:CC:6C:1F:52:26:7D:CD:E7:0D:14:F8:34:B0:36:B7:F9:FD:AC:97:4C:C0:7D:50:7E:DC:E0:D4:62:52:27:7B:FE:0B:16:62:34:81:2A:E1:8B:6A:54:EE:55:6D:C3:D0:F4:89:A1:E8:11:F0:67:3E:17:AB:BF:C3:6C:B7:37:51:29:36:45:BA:26:BF:CB:90:AE:A7</p>
</blockquote>

<p>As you can see, it is way longer...</p>

<p>Here is the coding part I have</p>

<pre><code>import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;

public class DHKeyAgreement {

  // The 1024 bit Diffie-Hellman modulus values used by SKIP
  private static final byte skip1024ModulusBytes[] = {(byte) 0xe5, (byte) 0x16, (byte) 0xe4,
      (byte) 0x3e, (byte) 0x54, (byte) 0x57, (byte) 0xb2, (byte) 0xf6, (byte) 0x6f, (byte) 0x6c,
      (byte) 0xa3, (byte) 0x67, (byte) 0xb3, (byte) 0x35, (byte) 0xea, (byte) 0xd8, (byte) 0x31,
      (byte) 0x99, (byte) 0x39, (byte) 0xfa, (byte) 0x4d, (byte) 0xf6, (byte) 0xc1, (byte) 0xb7,
      (byte) 0xf8, (byte) 0x6e, (byte) 0x73, (byte) 0xe9, (byte) 0x22, (byte) 0xa6, (byte) 0xd1,
      (byte) 0x93, (byte) 0x93, (byte) 0x25, (byte) 0x5e, (byte) 0x41, (byte) 0x90, (byte) 0x96,
      (byte) 0x66, (byte) 0x81, (byte) 0x74, (byte) 0xe3, (byte) 0x5c, (byte) 0x81, (byte) 0x8a,
      (byte) 0x66, (byte) 0x11, (byte) 0x7f, (byte) 0x79, (byte) 0x9e, (byte) 0x86, (byte) 0x66,
      (byte) 0xc8, (byte) 0x05, (byte) 0x0e, (byte) 0xe4, (byte) 0x36, (byte) 0xf9, (byte) 0x80,
      (byte) 0x13, (byte) 0x51, (byte) 0x60, (byte) 0x6c, (byte) 0x55, (byte) 0xd4, (byte) 0x5f,
      (byte) 0xab, (byte) 0xa0, (byte) 0x3f, (byte) 0x39, (byte) 0xe2, (byte) 0x92, (byte) 0x3b,
      (byte) 0xa9, (byte) 0x26, (byte) 0xa9, (byte) 0xcd, (byte) 0x75, (byte) 0xd4, (byte) 0xbd,
      (byte) 0xbc, (byte) 0xa9, (byte) 0xde, (byte) 0x78, (byte) 0xb6, (byte) 0x2a, (byte) 0x9b,
      (byte) 0x84, (byte) 0x7a, (byte) 0x78, (byte) 0x1c, (byte) 0x69, (byte) 0x2c, (byte) 0x06,
      (byte) 0x3e, (byte) 0xaa, (byte) 0xcb, (byte) 0x43, (byte) 0xa3, (byte) 0x96, (byte) 0xf0,
      (byte) 0x1d, (byte) 0x12, (byte) 0x1d, (byte) 0x04, (byte) 0x27, (byte) 0x55, (byte) 0xd0,
      (byte) 0xb7, (byte) 0xc0, (byte) 0xb2, (byte) 0xdf, (byte) 0xa8, (byte) 0xb4, (byte) 0x98,
      (byte) 0xa5, (byte) 0x7e, (byte) 0x4d, (byte) 0x90, (byte) 0xc3, (byte) 0x0c, (byte) 0xa0,
      (byte) 0x49, (byte) 0xa7, (byte) 0xac, (byte) 0x2b, (byte) 0x7f, (byte) 0x73};


  // The SKIP 1024 bit modulus
  private static final BigInteger skip1024Modulus = new BigInteger(1, skip1024ModulusBytes);

  // The base used with the SKIP 1024 bit modulus
  private static final BigInteger skip1024Base = BigInteger.valueOf(5);

  public static void main(String[] args) throws Exception {
    DHParameterSpec dhSkipParamSpec;
    dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base);
    System.out.println(""ALICE: Generate DH keypair ..."");
    KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(""DH"");
    aliceKpairGen.initialize(dhSkipParamSpec);
    KeyPair aliceKpair = aliceKpairGen.generateKeyPair();
    System.out.println(""ALICE: Initialization ..."");
    KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(""DH"");
    aliceKeyAgree.init(aliceKpair.getPrivate());

    // Alice encodes her public key, and sends it over to Bob.
    byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();
    byte[] alicePrivKeyEnc = aliceKpair.getPrivate().getEncoded();


    System.out.println(""ALICE public key: "" + toHexString(alicePubKeyEnc));
    System.out.println(""Alice private key: "" + toHexString(alicePrivKeyEnc));

  }

  /*
   * Converts a byte to hex digit and writes to the supplied buffer
   */
  private static void byte2hex(byte b, StringBuffer buf) {
    char[] hexChars =
        {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    int high = ((b &amp; 0xf0) &gt;&gt; 4);
    int low = (b &amp; 0x0f);
    buf.append(hexChars[high]);
    buf.append(hexChars[low]);
  }

  /*
   * Converts a byte array to hex string
   */
  private static String toHexString(byte[] block) {
    StringBuffer buf = new StringBuffer();

    int len = block.length;

    for (int i = 0; i &lt; len; i++) {
      byte2hex(block[i], buf);
      if (i &lt; len - 1) {
        buf.append("":"");
      }
    }
    return buf.toString();
  }
}
</code></pre>

<p>Is it something I misunderstanding or the documentation is wrong?</p>
","<p>The final hex string which you see as a result of the <code>aliceKpair.getPublic().getEncoded()</code> is the ASN.1 DER encoded string. The hex string of the public key (removed <code>:</code>) that you have is</p>

<pre><code>3082012430819906092A864886F70D01030130818B02818100E516E43E5457B2F66F6CA367B335EAD8319939FA4DF6C1B7F86E73E922A6D19393255E419096668174E35C818A66117F799E8666C8050EE436F9801351606C55D45FABA03F39E2923BA926A9CD75D4BDBCA9DE78B62A9B847A781C692C063EAACB43A396F01D121D042755D0B7C0B2DFA8B498A57E4D90C30CA049A7AC2B7F73020105020202000381850002818100A9AF1CF345778CBABC3259527BEA9080749A1DA701D4C410744C6EE93536496D0D03F52DECFAC5CECDC923D3F52FC2E03E543CA1206BEDCC6C1F52267DCDE70D14F834B036B7F9FDAC974CC07D507EDCE0D46252277BFE0B166234812AE18B6A54EE556DC3D0F489A1E811F0673E17ABBFC36CB73751293645BA26BFCB90AEA7
</code></pre>

<p>which follows the following format below. The ASN.1 format is used to serialize and deserialize the data structures in a platform independent manner.</p>

<pre><code>SEQUENCE (2 elem)
  SEQUENCE (2 elem)
    OBJECT IDENTIFIER 1.2.840.113549.1.3.1 dhKeyAgreement (PKCS #3)
    SEQUENCE (3 elem)
      INTEGER (1024 bit) 160872061717711572653317052595503399048868038241656045229773297825253…
      INTEGER 5
      INTEGER 512
  BIT STRING (1 elem)
    INTEGER (1024 bit) 119156181916892940910396680345482295722468357006826527903397802475513…
</code></pre>

<p>The 3 elemenet sequence contains the prime (p) as the first element of the structure and the generator (g) as the second element. IN JDK each <code>PublicKey</code> types (EC/DH/RSA etc..,) contains corresponding <code>getEncoded()</code> implementation which creates an ASN.1 encoded DER string. <a href=""http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/f4c62eecf7fa/src/share/classes/com/sun/crypto/provider/DHPublicKey.java#l203"" rel=""nofollow noreferrer"">Here's such an implementation</a> from JDK for the <code>DHPublicKey</code>. There'll be a similar implementation for the <code>DHPrivateKey</code>.</p>

<p>In your case, the prime value in is 1024 bit and is what you're looking for and the public key value you're interested in is the 1024 bit <code>BIT STRING</code> value.</p>

<p>The sample public key you provided is 256 character hex encoded i.e. 128 byte array i.e. 1024 bit value. This is the first value of the 3 element sequence in the encoded public key structure.</p>
","128","<java><encryption><diffie-hellman>","0","1","1","2019-03-04 06:42:03","54976962","0","","","","","2019-03-04 04:24:56",""
"34994926","Are hashes and MACs vulnerable to bit-flipping attacks?","<p>Suppose there is an encrypted communication between A and B, through an <strong>unsecure</strong> medium, such that A and B shared a secret key with DH protocol.</p>

<p>If A sends an encrypted message and the hash/MAC/HMAC of this message to B, wouldn't it be easy for an eavesdropper to just intercept the hash/MAC/HMAC, change some bits in it, and send it to B?</p>

<p>B wouldn't be able to check the integrity of all messages sent by A and thus will destroy them everytime he gets a message from A, right?</p>

<p>B will then become non available ???</p>

<p>Thank you</p>
","<p>The process you describe is just a very specific form of corrupting the data. If an attacker can corrupt the data, then of course the attacker can prevent A from speaking to B. The attacker could just drop the packets on the ground. That would also prevent A from speaking to B.</p>

<p>Any data corruption, not just modifying the HMAC, will cause this same situation. If I modify the authenticated stream, then the (unmodified) HMAC won't match and it will be discarded.</p>

<p>The point of an HMAC is to ensure integrity. It has nothing to do with availability. Any Man-in-the-Middle can always trivially destroy availability in any system as long as the connection goes through them. (If they can't, they're not a MitM.)</p>
","128","<encryption><aes><private-key><diffie-hellman>","1","1","1","2016-01-25 14:39:16","34995203","2","","","","","2016-01-25 14:24:06",""
"48663500","SGX DH key exchange","<p>I'm trying to create a key exchange app using intel's sgx technology.
I used this - <a href=""https://software.intel.com/en-us/node/709011"" rel=""nofollow noreferrer"">https://software.intel.com/en-us/node/709011</a> page as guidance ,I send all the messages as this site shows but I don't know how to get the key!.
In the end of DH key exchange I should have a mutual key for the site and the server but I'm not sure where he is.
In the function <code>sgx_dh_initiator_proc_msg3</code>(as shown in the buttom of the site) there is a key called 'aek', is this the mutual key?
thanks</p>
","<p>The agreed DH Key is on both <code>Msg2</code> and <code>Msg3</code>. </p>

<p>The last executed methods on a DH session establishment on SGX are:</p>

<ul>
<li><code>sgx_dh_responder_proc_msg2</code> on the <em>responder</em> side, and </li>
<li><code>sgx_dh_initiator_proc_msg3</code> on the <em>initiator</em> side. </li>
</ul>

<p>Therefore, <em>they extract the Agreed Key from the message they are processing</em>.</p>

<p>The output of these methods is:</p>

<ul>
<li>the AEK key: <code>sgx_key_128bit_t</code>, and </li>
<li>the Peer identity: <code>sgx_dh_session_enclave_identity_t</code>.</li>
</ul>
","123","<diffie-hellman><sgx>","0","0","1","2018-05-15 15:03:09","50236057","0","1","","","","2018-02-07 12:12:02",""
"56062594","OpenSSL ECDH setting peer's public key in C","<p>I'm trying to integrate ECDH using OpenSSL in my C-SDK (which we will refer to as client) which is running on <strong>Ubuntu</strong> and needed some help regarding how to set the peer's (server) public key on the client side and eventually generating the shared secret.</p>

<h3>Some details:</h3>

<ol>
<li>I am successfully generating a public key and can also generate a shared secret on the server side which has an embedded microcontroller using the <code>mbedTLS</code> library.</li>
<li>The public key I receive from the server is in the form of a <code>uint8_t</code> array of size <code>32 bytes</code>.</li>
<li>I now want to use OpenSSL's ECDH to generate the public key for server and the shared secret on the client side.</li>
</ol>

<p>I found a sample code on the <a href=""https://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman"" rel=""nofollow noreferrer"">OpenSSL wiki website</a> which is as below:</p>



<pre><code>#include &lt;openssl/evp.h&gt;
#include &lt;openssl/ec.h&gt;


unsigned char *ecdh(size_t *secret_len)
{
    EVP_PKEY_CTX *pctx, *kctx;
    EVP_PKEY_CTX *ctx;
    unsigned char *secret;
    EVP_PKEY *pkey = NULL, *peerkey, *params = NULL;
    /* NB: assumes pkey, peerkey have been already set up */

    /* Create the context for parameter generation */
    if(NULL == (pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL))) handleErrors();

    /* Initialise the parameter generation */
    if(1 != EVP_PKEY_paramgen_init(pctx)) handleErrors();

    /* We're going to use the ANSI X9.62 Prime 256v1 curve */
    if(1 != EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_X9_62_prime256v1)) handleErrors();

    /* Create the parameter object params */
    if (!EVP_PKEY_paramgen(pctx, &amp;params)) handleErrors();

    /* Create the context for the key generation */
    if(NULL == (kctx = EVP_PKEY_CTX_new(params, NULL))) handleErrors();

    /* Generate the key */
    if(1 != EVP_PKEY_keygen_init(kctx)) handleErrors();
    if (1 != EVP_PKEY_keygen(kctx, &amp;pkey)) handleErrors();

    /* Get the peer's public key, and provide the peer with our public key -
     * how this is done will be specific to your circumstances */
    peerkey = get_peerkey(pkey);

    /* Create the context for the shared secret derivation */
    if(NULL == (ctx = EVP_PKEY_CTX_new(pkey, NULL))) handleErrors();

    /* Initialise */
    if(1 != EVP_PKEY_derive_init(ctx)) handleErrors();

    /* Provide the peer public key */
    if(1 != EVP_PKEY_derive_set_peer(ctx, peerkey)) handleErrors();

    /* Determine buffer length for shared secret */
    if(1 != EVP_PKEY_derive(ctx, NULL, secret_len)) handleErrors();

    /* Create the buffer */
    if(NULL == (secret = OPENSSL_malloc(*secret_len))) handleErrors();

    /* Derive the shared secret */
    if(1 != (EVP_PKEY_derive(ctx, secret, secret_len))) handleErrors();

    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(peerkey);
    EVP_PKEY_free(pkey);
    EVP_PKEY_CTX_free(kctx);
    EVP_PKEY_free(params);
    EVP_PKEY_CTX_free(pctx);

    /* Never use a derived secret directly. Typically it is passed
     * through some hash function to produce a key */
    return secret;
}
</code></pre>

<p>The example has a <code>peerkey = get_peerkey(pkey);</code> line where it sets the peerkey and basically leaves it on the user to implement this function. I would imagine it would be straightforward if I was using OpenSSL on the server side as well.</p>

<h3>My question:</h3>

<p>Referring to the above code,and keeping in mind that I'm receiving the server's public key as a <code>uint8_t</code> array, how do I set the <code>EVP_PKEY *peerkey</code> context so that it contains the server's public key?</p>

<p>If there's another straight-forward crypto library in C that I can use on Ubuntu then please do suggest!</p>

<p>Really appreciate any help.</p>

<p>Thank you!</p>
","","122","<public-key><diffie-hellman><openssl>","1","","0","2019-05-09 15:15:42","","4","","","","","2019-05-09 15:14:15",""
"43844654","Elliptic Curve Cryptography PHP: catchable fatal error argument 1 passed to __construct()","<p>I am trying to use Elliptic Curve Cryptography using Matyas Danter's phpecc libraries available in <a href=""https://github.com/DynamicCodeNinja/store/tree/master/src/models/ecc-lib"" rel=""nofollow noreferrer"">1</a> . However, I am getting the following error when I create the variable Alice , although the passed argument is a Point.. please help..</p>

<blockquote>
  <p>Catchable fatal error: Argument 1 passed to EcDH::__construct() must be an instance of Point, string given, called in C:\xampp\htdocs\ECC-example.php on line 31 and defined in C:\xampp\htdocs\classes\EcDH.php on line 39</p>
</blockquote>

<pre><code>         include 'autoload.inc.php';
         include 'classes/EcDH.php';
         include 'classes/PHPECC.class.php';
         include 'classes/SECurve.class.php';
         $keypair = PHPECC::hex_keypair_genorate();

         $g = NISTcurve::generator_192();
         echo $g;
         $Alice = new EcDH(g);
</code></pre>

<p>..........................................</p>

<p>NISTcurve.php has the below function:</p>

<pre><code>         public static function generator_192() {
         // NIST Curve P-192:
        if (extension_loaded('gmp') &amp;&amp; USE_EXT == 'GMP') {
        $_p = '6277101735386680763835789423207666416083908700390324961279';
        $_r = '6277101735386680763835789423176059013767194773182842284081';
        $_b = gmp_Utils::gmp_hexdec('0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1');
        $_Gx = gmp_Utils::gmp_hexdec('0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012');
        $_Gy = gmp_Utils::gmp_hexdec('0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811');

        $curve_192 = new CurveFp($_p, -3, $_b);
        $generator_192 = new Point($curve_192, $_Gx, $_Gy, $_r);
    } else if (extension_loaded('bcmath') &amp;&amp; USE_EXT == 'BCMATH') {
        $_p = '6277101735386680763835789423207666416083908700390324961279';
        $_r = '6277101735386680763835789423176059013767194773182842284081';
        $_b = bcmath_Utils::bchexdec('0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1');
        $_Gx = bcmath_Utils::bchexdec('0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012');
        $_Gy = bcmath_Utils::bchexdec('0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811');

        $curve_192 = new CurveFp($_p, -3, $_b);
        $generator_192 = new Point($curve_192, $_Gx, $_Gy, $_r);
    }
    return $generator_192;
}
</code></pre>
","<p>The error was in the last line</p>

<p>$Alice = new EcDH(g) -> wrong</p>

<p>$Alice = new EcDH($g) -> correct</p>

<p>A sily mistake that caused a huge error..</p>
","111","<php><encryption><public-key-encryption><elliptic-curve><diffie-hellman>","0","0","1","2017-05-22 08:34:47","","0","","","","","2017-05-08 09:54:28",""
"45926946","NTE_BAD_DATA in CryptSetKeyParam while setting KP_P in wincrypt","<p>I am having the below code. I am setting a prime for diffie-hellman algorithm using char *. 
I am getting bad data after i set the prime. Where am i doing wrong?
I followed the same example in this link.
<a href=""https://msdn.microsoft.com/en-us/library/aa381969(VS.85).aspx#exchanging_diffie-hellman_keys"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/aa381969(VS.85).aspx#exchanging_diffie-hellman_keys</a></p>

<p>What is the correct way to set prime in diffie-hellman using wincrypt?</p>

<pre><code>#define DHKEYSIZE 1024
int fld_sz = 256;
BYTE* g_rgbPrime = new BYTE[DHKEYSIZE/8];   
char * prime = ""A1BD60EBD2D43C53FA78D938C1EF8C9AD231F9862FC402739302DEF1B6BEB01E5BE59848A04C48B0069A8FB56143688678F7CC1097B921EA3E13E1EF9B9EB5381BEFDE7BBF614C13827493A1CA31DA76B4083B62C5073451D6B1F06A2F1049C291464AC68CBB2F69474470BBAD374073392696B6447C82BF55F20B2D015EB97B"";
string s_prime(prime, fld_sz);
vector&lt;std::string&gt; res;
// split the string two charactes for converting into hex format
for (size_t i = 0; i &lt; fld_sz; i += 2)
    res.push_back(s_prime.substr(i, 2));
for(int i = 0; i &lt; res.size(); i++) {
    BYTE b = static_cast&lt;BYTE&gt;(std::stoi(res[i], 0, 16));
    g_rgbPrime[i] = b;
}
BYTE g_rgbGenerator[128] = 
{
    0x02
};
BOOL fReturn;
HCRYPTPROV hProvParty1 = NULL; 
HCRYPTPROV hProvParty2 = NULL; 
CRYPT_DATA_BLOB P;
CRYPT_DATA_BLOB G;
HCRYPTKEY hPrivateKey1 = NULL;
HCRYPTKEY hPrivateKey2 = NULL;
PBYTE pbKeyBlob1 = NULL;
PBYTE pbKeyBlob2 = NULL;
HCRYPTKEY hSessionKey1 = NULL;
HCRYPTKEY hSessionKey2 = NULL;
PBYTE pbData = NULL;

/************************
Construct data BLOBs for the prime and generator. The P and G 
values, represented by the g_rgbPrime and g_rgbGenerator arrays 
respectively, are shared values that have been agreed to by both 
parties.
************************/
P.cbData = DHKEYSIZE / 8;
P.pbData = (BYTE*)(g_rgbPrime);

G.cbData = DHKEYSIZE / 8;
G.pbData = (BYTE*)(g_rgbGenerator);

/************************
Create the private Diffie-Hellman key for party 1. 
************************/
// Acquire a provider handle for party 1.
fReturn = CryptAcquireContext(
    &amp;hProvParty1, 
    NULL,
    MS_ENH_DSS_DH_PROV,
    PROV_DSS_DH, 
    CRYPT_VERIFYCONTEXT);
if(!fReturn)
{
    goto ErrorExit;
}

// Create an ephemeral private key for party 1.
fReturn = CryptGenKey(
    hProvParty1, 
    CALG_DH_EPHEM, 
    DHKEYSIZE &lt;&lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN,
    &amp;hPrivateKey1);
if(!fReturn)
{
    goto ErrorExit;
}

// Set the prime for party 1's private key.
fReturn = CryptSetKeyParam(
    hPrivateKey1,
    KP_P,
    (PBYTE)&amp;P,
    0);
if(!fReturn)
{
    std::cout &lt;&lt; GetLastError() &lt;&lt; endl;
    goto ErrorExit;
}

// Set the generator for party 1's private key.
fReturn = CryptSetKeyParam(
    hPrivateKey1,
    KP_G,
    (PBYTE)&amp;G,
    0);
if(!fReturn)
{
    std::cout &lt;&lt; GetLastError() &lt;&lt; endl;
    goto ErrorExit;
}
</code></pre>

<p>Thanks in advance. </p>

<p>Update 1:
Thanks to <a href=""https://stackoverflow.com/users/6401656/rbmm"">@RbMm</a> I was able to set the prime. The problem was with DHKEYSize. However i am getting an error in while setting <strong>KP_X</strong>. updated the code above to reflect the new code. </p>

<p>Here i converted the string to hex bytes array.</p>
","<p>size of prime <code>KP_P</code> (and <code>KP_G</code>) and DH key size hard connected. must be <code>cbKey == 8*cbP</code>. look for example <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa381967(v=vs.85).aspx"" rel=""nofollow noreferrer""><code>Diffie-Hellman Client Code for Creating the Master Key</code></a>:</p>

<p>as key size if used <code>cbP * 8</code> where <code>cbP</code> size of prime <code>P</code>. in your link also <code>P.cbData = DHKEYSIZE/8;</code></p>

<p>also in code instead hard-code size of <code>P</code> (and <code>G</code>) you can get it in runtime:</p>

<pre><code>ULONG dwDataLen;
CryptGetKeyParam(hPrivateKey1, KP_P, 0, &amp;(dwDataLen = 0), 0);
CryptGetKeyParam(hPrivateKey1, KP_G, 0, &amp;(dwDataLen = 0), 0);
</code></pre>

<p>and you can sure that <code>dwDataLen == DHKEYSIZE / 8</code> where <code>DHKEYSIZE</code> is key size.</p>

<p>because you use  512 as key size, the length of data for <code>P</code> and <code>G</code> must be <code>512/8=64</code>. but you use 256 (for <code>P</code>) and 1 (for <code>G</code>). as result and error.</p>
","109","<c++><windows><winapi><diffie-hellman><wincrypt>","0","1","1","2017-08-29 18:28:20","45928073","0","","1294545","","2017-08-29 18:28:20","2017-08-28 20:33:21",""
"52475881","Diffie-Hellman in swift can work with JAVA","<p>I am trying to develop key-exchange diffe-Hellman between swift and java server .
I read all link about Diffie hetlman and in all of them told I should use <code>(g^a mod p)^b mod p = g^ab mod p</code> for making PublicKey.</p>

<p>But when I started to share my PublicKey with server I faced with this exception</p>

<pre><code>java.security.spec.InvalidKeySpecException: Inappropriate key specification
  at com.sun.crypto.provider.DHKeyFactory.engineGeneratePublic(DHKeyFactory.java:85)
  at java.security.KeyFactory.generatePublic(KeyFactory.java:334)
  at com.pushro.server.managers.server.RequestsHandler.processKeyExchange(RequestsHandler.java:867)
  at com.pushro.server.managers.server.RequestsHandler.processPacket(RequestsHandler.java:275)
  at com.pushro.server.managers.server.RequestsHandler.processPacket(RequestsHandler.java:1315)
  at com.pushro.server.managers.server.RequestsHandler.access$000(RequestsHandler.java:40)
  at com.pushro.server.managers.server.RequestsHandler$1.handleEvent(RequestsHandler.java:96)
  at com.pushro.server.managers.queue.DisruptorManager$WriteEventHandler.onEvent(DisruptorManager.java:37)
  at com.pushro.server.managers.queue.DisruptorManager$WriteEventHandler.onEvent(DisruptorManager.java:34)
  at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:129)
  at java.lang.Thread.run(Thread.java:748)
Caused by: java.security.InvalidKeyException: Invalid key format
  at com.sun.crypto.provider.DHPublicKey.&lt;init&gt;(DHPublicKey.java:127)
  at com.sun.crypto.provider.DHKeyFactory.engineGeneratePublic(DHKeyFactory.java:78)
  ... 10 more
</code></pre>

<p>I used standard X509EncodedKeySpec for get key and generate Secret code in java. </p>

<pre><code>X509EncodedKeySpec ks = new X509EncodedKeySpec(PublicKey_byte);
KeyFactory keyFactory = KeyFactory.getInstance(""DH"");
PublicKey clientPublicKey = keyFactory.generatePublic(ks);
</code></pre>

<p>I'm read all of this link but they didn't help me.</p>

<ul>
<li><a href=""https://github.com/gsurma/diffie_hellman_key_exchange"" rel=""nofollow noreferrer"">https://github.com/gsurma/diffie_hellman_key_exchange</a></li>
<li><a href=""https://gist.github.com/jmcd/b9a212df5dfa88b6d8dcb52c51b6be6b"" rel=""nofollow noreferrer"">https://gist.github.com/jmcd/b9a212df5dfa88b6d8dcb52c51b6be6b</a></li>
<li><a href=""https://developer.apple.com/documentation/security/1643701-seckeycreatewithdata"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/security/1643701-seckeycreatewithdata</a></li>
<li><a href=""https://developer.apple.com/documentation/security/seckey"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/security/seckey</a></li>
<li><a href=""https://developer.apple.com/documentation/security/secure_transport#//apple_ref/doc/uid/TP30000155"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/security/secure_transport#//apple_ref/doc/uid/TP30000155</a></li>
</ul>
","","109","<java><swift4><diffie-hellman><public-key-exchange>","1","","0","2019-01-02 07:57:55","","1","","2862860","","2019-01-02 07:57:55","2018-09-24 09:05:02",""
"34889422","Diffie Hellman in actionscript","<p>I'm not a mathematician and haven't been able to create a procedure myself. Googled for a day and read a lot of posts, but there seems to be no working example around in AS: is anyone willing to share some working source to get me up and running??</p>
","<p>The <a href=""http://crypto.hurlant.com/docs/"" rel=""nofollow"">Hurlant Crypto library</a> has an implementation of BigInteger class. It does not have DH directly, but you can use the BigInteger class to roll your own </p>

<pre><code>var g:BigInteger = new BigInteger(""5"");
var x:ByteArray = new ByteArray;
var rnd:Random = new Random();
rnd.nextBytes(x, (512&gt;&gt;3));
x.position = 0;
var p:BigInteger = new BigInteger(x);
p.primify(512, 1);
x = new ByteArray;
rnd = new Random();
rnd.nextBytes(x, (512&gt;&gt;3));
x.position = 0;
var b:BigInteger = new BigInteger(x);
b.primify(512, 1);
var B:BigInteger = g.modPow(b,p);
</code></pre>

<p>send <code>g</code>,<code>p</code>,<code>B</code> to the other end and when <code>A</code> comes back do the calcs for <code>s</code></p>
","107","<encryption><actionscript><diffie-hellman>","0","0","1","2016-03-04 15:11:39","","0","","","","","2016-01-20 00:25:31",""
"45698520","ECDH Generating Public key causes the point to not be on the curve VB.net","<p>I am not sure whether this question was relevant for stackoverflow or cryptography stackexchange, but I thought that I would ask it here as the question might go into programming.</p>

<p>I am trying to generate a public and private keypair using elliptic curve diffie-hellman, I successfully generate a private key that is smaller than the order of the curve but when I calculate the public key by multiplying the base point by the private key I calculate a point that is not on the curve.</p>

<p>The code I am using to generate the keys looks like this:</p>

<pre><code>Public Shared Function generate_Keys(ByVal Param As Domain_Parameters) As Keys
        Dim __PrivateKey As BigInteger
        Dim __PublicKey As ECPoint
        Dim d As BigInteger
        Dim rng As New RNGCryptoServiceProvider
        Dim bytes(Param.n.ToByteArray.Length) As Byte
        Do
            rng.GetBytes(bytes)
            d = New BigInteger(bytes)
            If d.Sign = -1 Then
                d = d * -1
            End If
        Loop While d &gt;= Param.n
        __PrivateKey = d
        __PublicKey = Point_Operations.Scalar_Mult(Param.Base, Param, d)
        Dim Ret As Keys
        Ret.PublicKey = __PublicKey
        Ret.PrivateKey = __PrivateKey
        __PrivateKey = BigInteger.Zero()
        d = BigInteger.Zero()
        bytes = {0}
        Return Ret
    End Function
</code></pre>

<p>And the code that I have tested and works fine to multiply the base point by the private key looks like this:</p>

<pre><code>Public Class Point_Operations
''' &lt;summary&gt;
''' A structure that contains data returned from Extended_GCD function
''' &lt;/summary&gt;
Friend Structure RetGCD
    Public x As BigInteger
    Public y As BigInteger
    Public GCD As BigInteger
End Structure
''' &lt;summary&gt;
''' Perfomrs addition of two points
''' &lt;/summary&gt;
Public Shared Function Addition(ByVal P1 As ECPoint, ByVal P2 As ECPoint) As ECPoint
    'Details about the maths was found on https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
    'Tested with the site http://christelbach.com/ECCalculator.aspx
    If P1.IsPointInfinity() Then
        Return P2
    End If
    If P2.IsPointInfinity() Then
        Return P1
    End If
    If P1.p &lt;&gt; P2.p Then
        Return New ECPoint(-99, -99, -99) 'Add custom errors with ENUM
    End If
    If P1.x = P2.x And P1.y = P2.y Then
        Return New ECPoint(-99, -99, -99)
    End If
    Dim P3 As New ECPoint(P1)
    Dim l, z As BigInteger
    z = Inverse((P2.x - P1.x), P1.p)
    l = ((P2.y - P1.y) * z) Mod P1.p
    P3.x = ((l * l) Mod P1.p - P2.x - P1.x) Mod P1.p
    P3.y = (l * (P1.x - P3.x) Mod P1.p - P1.y) Mod P1.p
    If P3.x &lt; 0 Then 'Tested the code without the peice below and found that the input (10,10,47) and (20,20,47) returned wrong values found out that the difference between each was the prime number so if its less than zero we add the prime whcih seems to work
        P3.x += P1.p
    End If
    If P3.y &lt; 0 Then
        P3.y += P1.p
    End If
    Return P3
End Function
''' &lt;summary&gt;
''' A way of doubling a EC Point
''' &lt;/summary&gt;
Public Shared Function PDouble(ByVal P As ECPoint, ByVal a As Domain_Parameters) As ECPoint
    'Details about the maths was found on https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
    'Tested with the site http://christelbach.com/ECCalculator.aspx
    If P.p = 0 And a.Fp.p = 0 Then
        Return New ECPoint(-99, -99, -99)
    End If
    'If a.a = 0 Then
    '    Return New ECPoint(-99, -99, -99)
    'End If
    If P.IsPointInfinity() Then
        Return P
    End If
    Dim prime As BigInteger
    If P.p = 0 Then
        prime = a.Fp.p
    Else
        prime = P.p
    End If
    Dim Q As New ECPoint(P)
    Dim l, z As BigInteger
    z = Inverse(2 * P.y, P.p)
    l = ((((3 * P.x * P.x) Mod P.p + a.a) Mod P.p) * z) Mod P.p
    Q.x = ((l * l) Mod P.p - 2 * P.x) Mod P.p     'accidental set (2 * p.x) to (2 * P.p)
    Q.y = (l * (P.x - Q.x) Mod P.p - P.y) Mod P.p
    If Q.x &lt; 0 Then 'This code was tested and the same problem again with negative values for x and y so we must add the prime to p to correct that
        Q.x += P.p
    End If
    If Q.y &lt; 0 Then
        Q.y += P.p
    End If
    Return Q
End Function
''' &lt;summary&gt;
''' Performs point multiplication with a scalar
''' &lt;/summary&gt;
Public Shared Function Scalar_Mult(ByVal P As ECPoint, ByVal a As Domain_Parameters, ByVal Scalar As BigInteger) As ECPoint
    'Details about the maths was found on https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
    'Tested with the site http://christelbach.com/ECCalculator.aspx
    If P.p = 0 And a.Fp.p = 0 Then
        Return New ECPoint(-99, -99, -99)
    End If
    'If a.a = 0 Then
    '    Return New ECPoint(-99, -99, -99)
    'End If
    If P.IsPointInfinity Then
        Return P
    End If
    Dim prime As BigInteger
    If P.p = 0 Then
        prime = a.Fp.p
    Else
        prime = P.p
    End If
    'Dim k As New BigInteger(Scalar.ToByteArray)
    Dim N, S As New ECPoint(P)
    S = New ECPoint(0, 0, prime)                      'Accidentally set S.y = 1 was causing a bad value
    'Dim sc As New BigInteger(k.ToByteArray)        'Depreciated as now we can use bits.lenght
    'Dim bitlenght As Integer
    'While sc / 2 &lt;&gt; 0
    '    bitlenght += 1
    '    sc /= 2
    'End While
    Dim bits As New BitArray(Scalar.ToByteArray)
    For i = 0 To bits.Length - 1
        If bits(i) = True Then                      'Fixed error where BitArray uses True/False instead of 1/0
            S = Addition(S, N)
        End If
        N = PDouble(N, a)
    Next
    Return S
End Function
''' &lt;summary&gt;
''' Calcualtes the Greatest Common Divisor of two numbers
''' &lt;/summary&gt;
Private Shared Function Extended_GCD(ByVal a As BigInteger, b As BigInteger) As RetGCD
    'The pseudocode was found on https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode
    'Tested with the site http://planetcalc.com/3298/
    Dim r, o_r As BigInteger
    Dim t, o_t As BigInteger
    Dim s, o_s As BigInteger
    Dim p, q As BigInteger
    Dim ret As RetGCD
    s = 0
    t = 1
    r = b
    o_s = 1
    o_t = 0
    o_r = a
    While r &lt;&gt; 0
        q = o_r / r
        p = r
        r = o_r - q * p
        o_r = p
        p = s
        s = o_s - q * p
        o_s = p
        p = t
        t = o_t - q * p
        o_t = p
    End While
    ret.x = o_s
    ret.y = o_t
    ret.GCD = o_r
    Return ret
End Function
''' &lt;summary&gt;
''' Performs the modular multiplitcative inverse of a number so we can use multiplication instead of division in our arithmetic
''' &lt;/summary&gt;
Public Shared Function Inverse(ByVal a As BigInteger, ByVal p As BigInteger) As BigInteger
    'Not tested but works
    Dim ret As RetGCD
    ret = Extended_GCD(a, p)
    If ret.GCD &lt;&gt; 1 Then
        Return 0
    End If
    Return ret.x Mod p
End Function
</code></pre>

<p>I have a feeling that it is possibly the way I am generating a private key or that I am using the wrong operation when calculating G.d .
Any help would really be appreciated thanks.</p>

<p><strong>===EDIT===</strong></p>

<p>After spending some time check values I have found the problem to be caused by the scalar_mult function not returning the right value. Is this function written correctly because i am unsure I have tested it with values from a site and it has been adapted from the pseudocode on wikipedia. Is that the correct method for adding a point to itself x number of time?</p>
","","106","<vb.net><elliptic-curve><diffie-hellman>","2","","0","2017-08-15 19:53:06","","2","0","6656310","","2017-08-15 19:53:06","2017-08-15 17:47:43",""
"24253343","DH_free precise behavior","<p>I'm using openssl, specifically the DH and BIGNUM libraries, to implement my own Diffie Hellman key exchange process, and I have some concerns about how it works.</p>

<p>The documentation I've been able to find, mostly <a href=""https://www.openssl.org/docs/crypto/dh.html"" rel=""nofollow"">here</a>, hasn't been as accurate as I might have hoped.  My question is about how DH_free works.  Is it more or less a wrapper on free, or does openssl have its own internal functions that handle memory management?  What happens when DH_free gets called on a null pointer?</p>
","<blockquote>
  <p>My question is about how DH_free works. Is it more or less a wrapper on free, or does openssl have its own internal functions that handle memory management? What happens when DH_free gets called on a null pointer?</p>
</blockquote>

<p>When all else fails, go to the source.</p>

<pre><code>$ cd openssl-1.0.1h
$ grep -R DH_free * | grep void
crypto/dh/dh.h:void DH_free(DH *dh);
crypto/dh/dh_lib.c:void DH_free(DH *r)
doc/crypto/dh.pod: void DH_free(DH *dh);
doc/crypto/DH_new.pod: void DH_free(DH *dh);
</code></pre>

<p>The implementation is located in <code>dh_lib.c</code>. Below is the cleaned up version (some <code>#defines</code> were removed, and the source code was formatted):</p>

<pre><code>void DH_free(DH *r)
{
    int i;
    if(r == NULL) return;

    i = CRYPTO_add(&amp;r-&gt;references, -1, CRYPTO_LOCK_DH);
    if (i &gt; 0) return;

    if (r-&gt;meth-&gt;finish)
        r-&gt;meth-&gt;finish(r);

#ifndef OPENSSL_NO_ENGINE
    if (r-&gt;engine)
        ENGINE_finish(r-&gt;engine);
#endif

    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, &amp;r-&gt;ex_data);

    if (r-&gt;p != NULL) BN_clear_free(r-&gt;p);
    if (r-&gt;g != NULL) BN_clear_free(r-&gt;g);
    if (r-&gt;q != NULL) BN_clear_free(r-&gt;q);
    if (r-&gt;j != NULL) BN_clear_free(r-&gt;j);
    if (r-&gt;seed) OPENSSL_free(r-&gt;seed);
    if (r-&gt;counter != NULL) BN_clear_free(r-&gt;counter);
    if (r-&gt;pub_key != NULL) BN_clear_free(r-&gt;pub_key);
    if (r-&gt;priv_key != NULL) BN_clear_free(r-&gt;priv_key);
    OPENSSL_free(r);
}
</code></pre>
","106","<c++><memory-management><openssl><diffie-hellman>","1","1","1","2014-06-17 06:43:55","24253444","2","","","","","2014-06-16 22:46:56",""
"31666643","Why does EVP_PKEY_keygen() fail?","<p>From what I have gathered reading the OpenSSL wiki page, my code to generate a Diffie-Hellman key is correct.  But it fails on the last step -- EVP_PKEY_keygen().</p>

<p>Is there a way to get more detailed information besides pass/fail?  Perhaps even the reason it failed?</p>
","<p>Here's how to get more detailed information out of OpenSSL errors.  It's minimal but generally helpful.</p>

<pre><code>#include &lt;openssl/err.h&gt;

// Do this during construction or initialization
ERR_load_crypto_strings();

// Do this when an error occurs
unsigned long error = ERR_get_error();
cout &lt;&lt; ""Error code = "" &lt;&lt; error &lt;&lt; std::endl;
cout &lt;&lt; ERR_reason_error_string(error) &lt;&lt; std::endl;

// Do this when shutting down
ERR_free_strings();
</code></pre>
","105","<c++><openssl><diffie-hellman>","0","0","1","2015-07-31 19:22:27","","1","","","","","2015-07-28 02:59:53",""
"17486710","Java XpowYmodN function, DiffieHellman","<p>I need for the Diffie Hellman protocol to create a function XpowYmodN. I have found online the following function:</p>

<pre><code>    public long XpowYmodN(long x, long y, long N) {
    long result = 1;
    final long oneShift63 = ((long) 1) &lt;&lt; 63;

    for (int i = 0; i &lt; 64; y &lt;&lt;= 1, i++) {
        result = result * result % N;
        if ((y &amp; oneShift63) != 0)
            result = result * x % N;
    }
    return result;
}
</code></pre>

<p>For this example: XpowYmodN(29,83,53) the result is 43. According to the manufacturer of the device calculations the result should be 50. Could anyone point me where i am doing it wrong?
I have tried with Math.pow(X,Y) % N, for this example and i get result 28. Im condused and would like some tips on how to fix it. Thank you.</p>
","<p>Why don't you use the class <code>java.math.BigInteger</code>? This class has a method called <code>modPow()</code> which is designed for cryptography usage.</p>

<p>The usage would be</p>

<pre><code>BigInteger result = BigInteger.valueOf(x).modPow(BigInteger.valueof(y), BigInteger.valueOf(n));
</code></pre>

<p>By the way variables a named with lower case letters (<code>n</code> in my case).</p>
","105","<java><function><math><diffie-hellman>","0","0","3","2013-07-06 15:41:06","","1","","","","","2013-07-05 10:29:41",""
"17486710","Java XpowYmodN function, DiffieHellman","<p>I need for the Diffie Hellman protocol to create a function XpowYmodN. I have found online the following function:</p>

<pre><code>    public long XpowYmodN(long x, long y, long N) {
    long result = 1;
    final long oneShift63 = ((long) 1) &lt;&lt; 63;

    for (int i = 0; i &lt; 64; y &lt;&lt;= 1, i++) {
        result = result * result % N;
        if ((y &amp; oneShift63) != 0)
            result = result * x % N;
    }
    return result;
}
</code></pre>

<p>For this example: XpowYmodN(29,83,53) the result is 43. According to the manufacturer of the device calculations the result should be 50. Could anyone point me where i am doing it wrong?
I have tried with Math.pow(X,Y) % N, for this example and i get result 28. Im condused and would like some tips on how to fix it. Thank you.</p>
","<p>Your answer is correct. But the value the calculator provides is not the calculation but the exchanged key. And your answer refers to the public value as seen by the sender or receiver</p>
","105","<java><function><math><diffie-hellman>","0","0","3","2013-07-06 15:41:06","","1","","","","","2013-07-05 10:29:41",""
"17486710","Java XpowYmodN function, DiffieHellman","<p>I need for the Diffie Hellman protocol to create a function XpowYmodN. I have found online the following function:</p>

<pre><code>    public long XpowYmodN(long x, long y, long N) {
    long result = 1;
    final long oneShift63 = ((long) 1) &lt;&lt; 63;

    for (int i = 0; i &lt; 64; y &lt;&lt;= 1, i++) {
        result = result * result % N;
        if ((y &amp; oneShift63) != 0)
            result = result * x % N;
    }
    return result;
}
</code></pre>

<p>For this example: XpowYmodN(29,83,53) the result is 43. According to the manufacturer of the device calculations the result should be 50. Could anyone point me where i am doing it wrong?
I have tried with Math.pow(X,Y) % N, for this example and i get result 28. Im condused and would like some tips on how to fix it. Thank you.</p>
","<p>I tested various numbers into that function and it worked great. I then created a duplicate function that used the following code based on Uwe Plonus' answer:</p>

<pre><code>public long XpowYmodN(long x, long y, long N) {
    return BigInteger.valueOf(x).modPow(BigInteger.valueOf(y), BigInteger.valueOf(N)).longValue();
}
</code></pre>

<p>I tested your numbers into it and got 43, just like that function; so that function seems to be working perfectly. The person that posted 29,83,53 numbers as resulting in 50 appears to be wrong. The correct answer for 29,83,53 is 43.</p>

<p>Here's the complete code I used:</p>

<pre><code>public class Main {
    public static long XpowYmodN_(long x, long y, long N) {
        long result = 1;
        final long oneShift63 = ((long) 1) &lt;&lt; 63;

        for (int i = 0; i &lt; 64; y &lt;&lt;= 1, i++) {
            result = result * result % N;
            if ((y &amp; oneShift63) != 0)
                result = result * x % N;
        }
        return result;
    }

    public static long XpowYmodN(long x, long y, long N) {
        return BigInteger.valueOf(x).modPow(BigInteger.valueOf(y), BigInteger.valueOf(N)).longValue();
    }

    public static void main(String[] args)
    {
        System.out.println(""BEGIN main"");


        System.out.println(Main.XpowYmodN_(29,83,53));
        System.out.println(Main.XpowYmodN(29,83,53));
    }
}
</code></pre>

<p>which gave the output of:</p>

<pre>
BEGIN main
43
43
</pre>
","105","<java><function><math><diffie-hellman>","0","0","3","2013-07-06 15:41:06","","1","","","","","2013-07-05 10:29:41",""
"24652007","PHP - Glitchy mod (%) operator","<p>For some reason: the display looks like this:</p>

<pre><code>3 to the power of x mod 17 is 19. This is called v.

Shared person a (v):
19 
</code></pre>

<p>and in the script, it looks like this (this script is used to describe Diffie-Hellman key exchange algorithm.):</p>

<pre><code>$p=""17"";
$g=""3"";
$px=gmp_nextprime(rand());
$x=gmp_strval($px);
$a=$g^$x%$p;
echo ""$g to the power of x mod $p is $a. This is called v.&lt;br&gt;"";
echo ""&lt;br&gt;Shared person a (v):&lt;br&gt;"";
echo ""$a &lt;br&gt;"";
</code></pre>

<p>Wondering if this is kind of a PHP glitch, because: </p>

<pre><code>if{x mod y=z}, z&lt;y
</code></pre>

<p>Now my questions: 
How to fix this? 
Had I done anything wrong? 
Is this a PHP glitch?</p>

<p>(The code needs a clean up, I know.)</p>

<p>Additional notes:
$x = 2047401017</p>
","<p>Well, <code>^</code> is not the power operator <em>and</em> modulo precedes both of them; besides, GMP has a function for power-modulo already:</p>

<pre><code>$p=""17"";
$g=""3"";
$px=gmp_nextprime(rand());

$a = gmp_powm($g, $px, $p);

echo ""$g to the power of x mod $p is $a. This is called v.&lt;br&gt;"";
echo ""&lt;br&gt;Shared person a (v):&lt;br&gt;"";
echo ""$a &lt;br&gt;"";
</code></pre>
","98","<php><operators><modulo><diffie-hellman>","-2","0","2","2014-07-09 11:33:57","24652164","3","0","","","","2014-07-09 11:05:47",""
"24652007","PHP - Glitchy mod (%) operator","<p>For some reason: the display looks like this:</p>

<pre><code>3 to the power of x mod 17 is 19. This is called v.

Shared person a (v):
19 
</code></pre>

<p>and in the script, it looks like this (this script is used to describe Diffie-Hellman key exchange algorithm.):</p>

<pre><code>$p=""17"";
$g=""3"";
$px=gmp_nextprime(rand());
$x=gmp_strval($px);
$a=$g^$x%$p;
echo ""$g to the power of x mod $p is $a. This is called v.&lt;br&gt;"";
echo ""&lt;br&gt;Shared person a (v):&lt;br&gt;"";
echo ""$a &lt;br&gt;"";
</code></pre>

<p>Wondering if this is kind of a PHP glitch, because: </p>

<pre><code>if{x mod y=z}, z&lt;y
</code></pre>

<p>Now my questions: 
How to fix this? 
Had I done anything wrong? 
Is this a PHP glitch?</p>

<p>(The code needs a clean up, I know.)</p>

<p>Additional notes:
$x = 2047401017</p>
","<p><code>^</code> is not the exponent operator, it's the bitwise XOR operator. As of PHP 5.6, the exponent operator is <code>**</code>. So it should be either</p>

<pre><code>$a = ($g ** $x) % $p;
</code></pre>

<p>or</p>

<pre><code>$a = $g ** ($x % $p);
</code></pre>

<p>The exponent operator was added in PHP 5.6. Prior to this, you need to use the <code>pow()</code> function:</p>

<pre><code>$a = pow($g, $x) % $p;
</code></pre>
","98","<php><operators><modulo><diffie-hellman>","-2","0","2","2014-07-09 11:33:57","24652164","3","0","","","","2014-07-09 11:05:47",""
"55609785","Unable to resolve ssl3_check_cert_and_algorithm:dh key too small issue in nodejs https request","<p>I'm trying to invoke a webservice using https request in my node.js code. But Im getting <strong>SSL routines:ssl3_check_cert_and_algorithm:dh key too small:../deps/openssl/openssl/ssl/s3_clnt.c</strong> error. </p>

<p>Even tried downloading the full certificate chain from the host website and added the certificate to the https request while invoking the URL but still got the same error.</p>

<h2>Here is the https request code that I'm using to invoke the service.</h2>

<pre><code>var https = require(""https"");

let fs = require('fs');

exports.connect = function (param, callback) {
  try {
  const options = {
      protocol: 'https',
      host: 'hostname',
      path: 'fullpath',
      method: 'GET',
      cert = fs.readFileSync(cert.cer)
    };
    let jsonObj = """";
    var req = https.request(options, function (res, error) {
      var chunks = [];
      console.log(res);
      res.on('data', function (chunk) {
        chunks.push(chunk);
      });
      res.on(""end"", function () {
        var body = Buffer.concat(chunks);
        try {
          jsonObj=body.toString();
          console.log(""Response is "" + jsonObj);
          return(null, jsonObj);
        } catch (error) {
          console.log(error);
          return callback(error, null)
        }
      });
    });
    req.end();
  } catch (err) {
    console.log(err);
    return callback(err, null)
  }
}
</code></pre>
","","96","<node.js><ssl-certificate><httprequest><diffie-hellman>","0","","0","2019-04-10 10:00:14","","0","","","","","2019-04-10 10:00:14",""
"55531544","SOLVED : Android, Generate Diffie Hellman Public Key received as BigInteger (error : invalid DH public key)","<p>I have one application android in kotlin and one Python on raspberry-Pi.</p>

<p>In my android application, I receive the PublicKey from my raspberry-Pi as a <strong>Big Integer String and I need to convert it to PublicKey</strong> to continue my Diffie Hellman.</p>

<p>With an Android 5.0 API 21 that's works very well but not with Android 8.0 API 26, 
I have the following error on <em>generatePublic</em>: Caused by "" com.android.org.bouncycastle.jcajce.provider.asymmetric.util.ExtendedInvalidKeySpecException: <strong>invalid DH public key</strong>""</p>

<pre><code>fun setReceivePublicKey(PublicKey: String?){
        if(PublicKey != null) {
            receivePublickeyInteger = PublicKey.toBigInteger(10)
            val kf : KeyFactory  = KeyFactory.getInstance(algorithm)
            val spec = DHPublicKeySpec(receivePublickeyInteger,p, g)
            receivePublicKey = kf.generatePublic(spec)
        }
    }
</code></pre>

<p><em>Receive PublicKey : ""1186077227678271540134862509873546604676586024525309469618216434360152823434999056481566892156846842514101786948011297818911589672275028242935710062913875151954912314844969895542136815935639151551824495652302435339103572121293460269849673020899573708935559027341320000586684514537431365310888999481071742463382911267789320258863598830395069544603326989392097657769707348691804224452973533413701448224774045051066571001832939497012508127767764295590745468802146946779724762449738116225105818944048461975843796127501652102207854858881733445450269991549328843268527039094247517538751801284281148484990234735369353511299021673752336297213365909273938355910119789784912925756917470664241207684485528488651231599946627996206087756203382782153653973676758525394929513362198592517449044771216536426414806442100590541816453615234374853999116975727517908588868986511359049342004004550720151991928954078445791206686994303438508485508357012971719850862634083256955999083221834362950792135463522604929254266546089700839060745995960677398""</em></p>

<p><em>P : 5809605995369958062791915965639201402176612226902900533702900882779736177890990861472094774477339581147373410185646378328043729800750470098210924487866935059164371588168047540943981644516632755067501626434556398193186628990071248660819361205119793693985433297036118232914410171876807536457391277857011849897410207519105333355801121109356897459426271845471397952675959440793493071628394122780510124618488232602464649876850458861245784240929258426287699705312584509625419513463605155428017165714465363094021609290561084025893662561222573202082865797821865270991145082200656978177192827024538990239969175546190770645685893438011714430426409338676314743571154537142031573004276428701433036381801705308659830751190352946025482059931306571004727362479688415574702596946457770284148435989129632853918392117997472632693078113129886487399347796982772784615865232621289656944284216824611318709764535152507354116344703769998514148343807</em></p>

<p><em>G : 2</em></p>

<p><em>algorithm : ""DH""</em></p>
","<p>Later versions do more and better validation. One of the checks is to make sure that 2 &lt; y &lt; p-2, where y is the received public key, and you fail that check, hence the exception. As you can see, your received public key is much larger than p, suggesting that there is a bug somewhere in your system.</p>
","90","<android><kotlin><public-key><diffie-hellman>","0","0","1","2019-06-04 13:27:41","55539187","0","","11316010","","2019-04-08 19:53:51","2019-04-05 08:47:54",""
"55451757","Efficient way to do payload signing in HTML5 SPA","<p>I'm looking to implement some <em>efficient</em> (i.e. with good performance) logic that does payload signing in our web application. The goal is for the HTML5 client to have a guarantee that the contents of a received payload are indeed those that were generated by our backend.</p>

<p>We don't want to do payload hash generation with shared salt because the user can easily open the HTML5 source and find the salt phrase.</p>

<p>We have implemented RSA signing for now where our backend adds a payload signature using its Private Key and our HTML5 client validates it using its baked in Public Key. However the signature generation process takes 250ms (for a relatively small payload) and due to the nature of the signed request this amount of time is unacceptable.</p>

<p>The only other idea is to generate a shared secret at runtime every time a client initializes its session with the backend. The secret however can't be sent in plaintext form so it seems we're going to have to implement a Diffie-Hellman exchange mechanism, something we'd like to avoid if possible or automate with existing libraries.</p>

<p>Remember that the secrecy and encryption need to be done at the <strong>Application layer</strong>, due to the nature of how we sell our product. We're not looking to encrypt our traffic, this is something that our customers might or might not implement (since it's an intranet application). However, we have to avoid exposing stuff that are related to our licensing checking mechanisms etc to them. The backend is <strong>not</strong> cloud based and is <strong>not</strong> controlled by us, but installed on the customers' machines, on premises.</p>

<p>Frontend is Javascript and backend is Java.</p>
","<p>Note that Diffie-Hellman exchange mechanism is <em>not</em> protected against MITM attack, therefore not encrypting traffic means that you need to authenticate the DH data coming from the server. This is why a web server using a DH-based cipher suite signs the DH elements sent over the network with the private key of its server certificate, for the client to check that those elements are really from the server that he wants to connect to. Those elements are public but need to be signed.</p>

<p>What you call ""payload hash generation with shared salt"" is a keyed-hash message authentication code, so it is based on a shared secret, as you noticed, and since you do not want to use this mechanism, it means that you do not trust the client. Therefore, you have to use asymetric cryptography to sign your payload.</p>

<p>Signing a server payload with an asymetric algorithm means that you first need to let the server share a public key with the client. Since you do not encrypt data between the client and the server, you need to deploy the server public key inside the client source code.</p>

<p>You talk about the signature generation process, but the signature check process on the client side is also very important in your case, because the total time the user has to wait for the result is the addition of the time to sign and the time to check the signature (moreover, the signature can often be anticipated on the server, if the data to sign is not dynamically generated, but the verification can never be anticipated). So you need a rapid way of checking a signature on the client side. First, sign a hash, not the whole payload. Then choose the fastest asymetric signature algorithm that is available in your development environment, on the client side. Note that checking an RSA signature is faster that checking a DSA or ECDSA one, for respective keys length corresponding to the same security level. So you should stay with RSA.</p>

<p>All of this until this line may not help you so much! Now there is a way to increase the performances using RSA to sign and verify signatures, and this way is rather the same that SSL/TLS implements to increase browser performances when downloading multiple pages or other objects from the same server: <strong>use a session cache</strong>. You share a common secret for a specific session with one specific user. Never use this common secret for other sessions. When the user is connecting for the first time, use RSA only once, to exchange an ephemeral shared secret or exchange DH material to create this shared secret. Then, each time the server needs to sign an object, it creates a keyed-hash message authentication code with this specific secret. Therefore, if the user finds the secret, for instance using the debug mode of his browser, it's not a problem: this secret is only here to help him know that something that comes from the server has not been altered. So the user can not use this secret to alter data exchanges between the server and other users.</p>
","89","<javascript><java><single-page-application><diffie-hellman><shared-secret>","0","0","2","2019-04-09 15:06:56","55595934","0","","","","","2019-04-01 09:20:02",""
"55451757","Efficient way to do payload signing in HTML5 SPA","<p>I'm looking to implement some <em>efficient</em> (i.e. with good performance) logic that does payload signing in our web application. The goal is for the HTML5 client to have a guarantee that the contents of a received payload are indeed those that were generated by our backend.</p>

<p>We don't want to do payload hash generation with shared salt because the user can easily open the HTML5 source and find the salt phrase.</p>

<p>We have implemented RSA signing for now where our backend adds a payload signature using its Private Key and our HTML5 client validates it using its baked in Public Key. However the signature generation process takes 250ms (for a relatively small payload) and due to the nature of the signed request this amount of time is unacceptable.</p>

<p>The only other idea is to generate a shared secret at runtime every time a client initializes its session with the backend. The secret however can't be sent in plaintext form so it seems we're going to have to implement a Diffie-Hellman exchange mechanism, something we'd like to avoid if possible or automate with existing libraries.</p>

<p>Remember that the secrecy and encryption need to be done at the <strong>Application layer</strong>, due to the nature of how we sell our product. We're not looking to encrypt our traffic, this is something that our customers might or might not implement (since it's an intranet application). However, we have to avoid exposing stuff that are related to our licensing checking mechanisms etc to them. The backend is <strong>not</strong> cloud based and is <strong>not</strong> controlled by us, but installed on the customers' machines, on premises.</p>

<p>Frontend is Javascript and backend is Java.</p>
","<p>We ended up by using <a href=""https://tweetnacl.js.org/#/"" rel=""nofollow noreferrer"">TweetNaCl</a> both on the client and on the server side. The library provides a every easy and fast way to do DH-like shared secret exchange without going through a custom implementation. With an ephemeral shared secret we can easily generate hashes instead of signatures for our payloads dropping from 250ms to 10μs. Also RSA signing the initial DH exchange is important and the only place we use RSA.</p>

<p>Please read @AlexandreFenyo answer for proper theory on how to <em>usually</em> handle such cases.</p>
","89","<javascript><java><single-page-application><diffie-hellman><shared-secret>","0","0","2","2019-04-09 15:06:56","55595934","0","","","","","2019-04-01 09:20:02",""
"54559829","What checks should I perform when I create a Diffie Hellman Key agreement keys from fixed p and g values using OpenSSL1.1.0g?","<p>Hello I attempt to make a Diffie Hellman Keys using fixes p and g parameters via this piece of code base upon this <a href=""https://stackoverflow.com/a/54538811/4706711"">answer</a>:</p>

<pre><code>#include &lt;openssl/dh.h&gt;
#include &lt;openssl/bn.h&gt;

int generateKeys(DH *encryptionInfo) {
 int codes;
 BIGNUM *two = BN_new(), *p=NULL;

 puts(""Select fixed p and g parameters\n"");

 if(two == NULL) {
   return -1;
 };

 if(p=NULL){
    BN_free(two);
    return -1;
 }

 BN_set_word(two,2);
 if( 1 != DH_set0_pqg (encryptionInfo, get_rfc3526_prime_2048(p), NULL, two)) return -1;

//  if(1 != DH_generate_parameters_ex(encryptionInfo, 2048, DH_GENERATOR_2, NULL)) return -1;
 puts(""Checking for codes\n"");
 if(1 != DH_check(encryptionInfo, &amp;codes)) return -1;
 printf(""Codes values %d\n"", codes);
 switch(codes){
    case DH_CHECK_P_NOT_PRIME:
      puts(""DH_CHECK_P_NOT_PRIME\n"");
      break;
    case DH_CHECK_P_NOT_SAFE_PRIME:
      puts(""DH_CHECK_P_NOT_SAFE_PRIME\n"");
      break;
    case DH_UNABLE_TO_CHECK_GENERATOR:
      puts(""DH_UNABLE_TO_CHECK_GENERATOR\n"");
      break;
    case DH_NOT_SUITABLE_GENERATOR:
      puts(""DH_NOT_SUITABLE_GENERATOR\n"");
      break;
    case DH_CHECK_Q_NOT_PRIME:
      puts(""DH_CHECK_Q_NOT_PRIME\n"");
      break;
    case DH_CHECK_INVALID_Q_VALUE:
      puts(""DH_CHECK_INVALID_Q_VALUE\n"");
      break;
    case DH_CHECK_INVALID_J_VALUE:
      puts(""DH_CHECK_INVALID_J_VALUE\n"");
      break;
 }
 if(codes != 0) return -1;
 puts(""Generating Keys \n"");
 if(1 != DH_generate_key(encryptionInfo)) return -1;

 BN_free(two);
 BN_free(p);
 return 0;
}
</code></pre>

<p>But when I try to run this piece of code I get the following error:</p>

<blockquote>
  <p>Codes values 8</p>
  
  <p>DH_NOT_SUITABLE_GENERATOR</p>
</blockquote>

<p>By omitting the <code>DH_check</code> check seems to work: </p>

<pre><code>#include &lt;openssl/dh.h&gt;
#include &lt;openssl/bn.h&gt;

int generateKeys(DH *encryptionInfo) {
 int codes;
 BIGNUM *two = BN_new(), *p=NULL;

 puts(""Select fixed p and g parameters\n"");

 if(two == NULL) {
   return -1;
 };

 if(p=NULL){
    BN_free(two);
    return -1;
 }

 BN_set_word(two,2);
 if( 1 != DH_set0_pqg (encryptionInfo, get_rfc3526_prime_2048(p), NULL, two)) return -1;

//  if(1 != DH_generate_parameters_ex(encryptionInfo, 2048, DH_GENERATOR_2, NULL)) return -1;
 puts(""Checking for codes\n"");
 puts(""Generating Keys \n"");
 if(1 != DH_generate_key(encryptionInfo)) return -1;

 BN_free(two);
 BN_free(p);
 return 0;
}
</code></pre>

<p>But I am not sure whether I should do that, what is the recommended way in my case? What checks are required in my case?</p>
","","86","<c><openssl><diffie-hellman>","1","","0","2019-10-30 15:56:38","","4","1","4706711","","2019-10-30 15:56:38","2019-02-06 17:58:23",""
"17087895","is client based online encryption practical?","<p>I'm wondering whether a mechanism exists that allows client to client encryption. For example, when enabled, any information that is entered on one client can only be decrypted using a specific key.</p>

<p>Similar to how regular public key transactions work, but server agnostic.</p>

<p>A use case:</p>

<p>Everything on my Facebook profile is encrypted, and no body would be able to view that information (not even facebook). The users that I give the key would be able to decrypt that information.</p>

<p>This would allow complete control of data stored online.</p>

<p>The same idea can be applied for pictures uploaded to the internet.</p>

<p>One issue that I see is to have a practical mechanism to manage keys and a secure way to distribute keys to other users.</p>

<p>Has anyone done something like this before?</p>
","<p>In case of Facebook I can imagine encrypting the data with OpenPGP keys into armored (text) format. Then you can place encrypted block to facebook or anywhere else. Other users would take the block, decrypt it on the client side and see it.</p>

<p>The same applies with other social networks and places where you can store some text block. </p>

<p>You can easily do encryption in some client application and even in <a href=""http://www.openpgpjs.org/"" rel=""nofollow"">Javascript</a> (if you manage to make JavaScript load local user's keys somehow). </p>
","83","<security><encryption><public-key-encryption><diffie-hellman>","1","1","1","2013-06-13 13:35:01","17088451","0","","","","","2013-06-13 13:09:08",""
"55677357","Decode Diffie Hellman p,g,A given","<p>Decode Text encrypted with DH coded with Caesar Cipher.</p>

<p>We have to decode following text: FKXSQBQZACKFAHRSCAN DFYZSYQBSFN.
I have tried to ""guess"" the private Key for Alice with a for loop and think I got the right one but now I'm stuck.
p,g and A are given.</p>

<pre><code>p = 23
g = 15
A = 6 #exchangeKey Alice
</code></pre>

<p>I think the problem could be that I don't know how the text is coded. Did the teacher use an array like?:</p>

<pre><code>alphabet = [""A"",""B"",""C"",""D"",""E"",""F"",""G"",""H"",""I"",""J"",""K"",""L"",""M"",""N"",""O"",""P"",""Q"",""R"",""S"",""T"",""U"",""V"",""W"",""X"",""Y"",""Z""]
</code></pre>

<p>Or did she use the ASCII table.</p>

<p>But is it even possible to decode this text without any information about ""Bob"".
My research brought only information about MITM attacks where the hacker got p,g,A and B</p>

<p>Get Alicekey</p>

<pre><code>for getkeyalice in range(p):
    if (g**getkeyalice)%p == A:
        keyalice = getkeyalice
</code></pre>

<p>Decode</p>

<pre><code>for char in message:
    #index=(alphabet.index(char)-j)
    #decryptedlst.append(alphabet[index])
    decryptedlst.append(chr(ord(char)-i))
    decrypted = ''.join(decryptedlst)
    print(""decrypted message:\t""+str(decrypted))
</code></pre>

<p>I'm looking for the decryption key. I don't expect this should be a very high number. But even bruteforcing all numbers from 1-4096 didn't help. So back to the top.... perhaps the kind of decryption I'm using is different to the encryption of the teacher.</p>
","<p>This problem can not be resolved due to a lack of input.</p>

<p>Even if you can easily brute-force Alice's private key, that is <strong>14</strong> (15¹⁴[23]≡6[23]), you have not any information about Bob's choice of key values, so you have no information that could help you find the DH shared secret between Alice and Bob. This is because the shared secret depends both on informations chosen from Alice <strong>and on informations chosen by Bob</strong>. Therefore, you can not cryptanalyze this problem.</p>
","73","<python-3.x><caesar-cipher><diffie-hellman>","1","0","1","2019-04-23 10:45:43","","0","","","","","2019-04-14 16:10:20",""
"16335576","Exposing Diffie Hellman shared key in the logs for openssl lib","<p>In the openssl libarary there is a function called DH_Compute_key which will create the shared key.can we use it and expose it in the log for debugging purpose?</p>
","<p>Yes. OpenSSL is opensource as you know - so just add some printfs there, rebuild it, and expose everything you need.</p>
","73","<encryption><wireshark><diffie-hellman>","0","1","1","2013-05-02 13:29:42","16339314","0","","","","","2013-05-02 10:20:45",""
"57789276","How to integrate tcp-modbus with diffie hellman?","<p>I have a simple modbus client-server code and also have a diffie-hellman client-server key exchange. My aim is to integrate the two so that when modbus client initiates request to modbus server, first step is do a key exchange and then encrypt the data transmission from modbus client to server and vice versa.</p>

<p>I know that in python <strong>socketserver</strong> the class <code>BaseRequestHandler</code> the <code>handle()</code> method is overridden for communication between client and server which I have done for diffie-hellman key exchange.</p>

<p><strong>dh-server.py</strong></p>

<pre><code>import socketserver

# request handler
class Dh_Handler(socketserver.BaseRequestHandler):

    # instantiate request handler, one per connection
    def __init__(self, request, client_addr, server):
        self.params = load_dh_params()  # store DH parameters
        self.state = 0  # tracking state
        socketserver.BaseRequestHandler.__init__(self, request, client_addr, server)    # pass variables to BaseRequestHandler

    # must override handle() to implement communication to client
    def handle(self):
        # calculate shared secret
        shared_key = dh_key_exchange()

        # key derivation used for symmetric encryption
        key = key_derivation(shared_key)

def main():
    host, port = '10.8.8.11', 502

    # instance of TCP server class, params: ip_address, request_handler
    dh_server = socketserver.TCPServer((host, port), Dh_Handler)

    # stop server via keyboard interrupt
    try:
        # infinite loop listen
        dh_server.serve_forever()
    except KeyboardInterrupt:
        dh_server.shutdown()

</code></pre>

<p><strong>dh-client.py</strong></p>

<pre><code>import socket

def main():
    # we specify the server's address or hostname and port
    host, port = '10.8.8.11', 502

    # create a tcp socket for IPv4
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # connect to the tcp socket
    sock.connect((host, port))

    # key exchange from server
    shared_key = dh_key_exchange(sock)

    # key derivation for symmetric encryption
    key = key_derivation(shared_key)
</code></pre>

<p><strong>modbus-client.py</strong></p>

<pre><code>import socket

from umodbus import conf
from umodbus.client import tcp
import binascii

# Enable values to be signed (default is False).
conf.SIGNED_VALUES = True

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('10.8.8.11', 502))

# Returns a message or Application Data Unit (ADU) specific for doing
# Modbus TCP/IP.
message = tcp.write_multiple_coils(slave_id=1, starting_address=1, values=[1, 0, 1, 0])

# Response depends on Modbus function code. This particular returns the
# amount of coils written, in this case it is.

response = tcp.send_message(message, sock)

message = tcp.read_coils(slave_id=1, starting_address=1, quantity=4)
# message=b"""".join([message,b'\x64'])
print(binascii.b2a_hex(message))
responce = tcp.send_message(message, sock)
print(responce)
sock.close()
</code></pre>

<p><strong>modbus-server.py</strong></p>

<pre><code>import logging
from socketserver import TCPServer
from collections import defaultdict

from umodbus import conf
from umodbus.server.tcp import RequestHandler, get_server
from umodbus.utils import log_to_stream

# Add stream handler to logger 'uModbus'.
log_to_stream(level=logging.DEBUG)

# A very simple data store which maps addresses against their values.
data_store = defaultdict(int)

# Enable values to be signed (default is False).
conf.SIGNED_VALUES = True

TCPServer.allow_reuse_address = True
app = get_server(TCPServer, ('10.8.8.11', 502), RequestHandler)


@app.route(slave_ids=[1], function_codes=[1, 2], addresses=list(range(0, 10)))
def read_data_store(slave_id, function_code, address):
    """""""" Return value of address. """"""
    return data_store[address]


@app.route(slave_ids=[1], function_codes=[5, 15], addresses=list(range(0, 10)))
def write_data_store(slave_id, function_code, address, value):
    """""""" Set value for address. """"""
    data_store[address] = value


if __name__ == '__main__':
    try:
        app.serve_forever()
    finally:
        app.shutdown()
        app.server_close()
</code></pre>

<p>What would be the best way to approach this? Can I create a server that listens on two different ports? One for key exchange and the other for encrypted modbus transmission or use threading in socketserver. What about using selectors to handle each connection.</p>

<p>Any help is much appreciated.</p>
","","69","<python-3.x><encryption><diffie-hellman><socketserver><modbus-tcp>","1","","0","2019-09-04 13:17:39","","0","","","","","2019-09-04 13:17:39",""
"18817911","Diffie-Hellman using Casper","<p>I have an assignment to model the Diffie-Hellman Key exchange protocol using Casper (in a .spl file).  I got the basics down and am finding it really hard to come up with the correct protocol desciption (#Protocol description).  I searched everywhere and tries everything(as far as my knowledge of Casper can take me) and no solution.  I'm very surprised that there is so little documentation on this.</p>

<p>If anyone could help me get started on this, it would be greatly appreciated.</p>

<p>Thanks in advanced!</p>
","<p>here it is! ( done by Gavin Low)
I am doing a research in these stuff, and you are right it hard to fine. Copy this code to new file and save it as .spl  </p>

<pre><code>-- Diffie Hellman

#Free variables  
datatype Field = Gen | Exp(Field,Num)  unwinding 2  
A, B : Agent  
x, y : Num  
expx, expy, k : Field  
text : TEXT  

InverseKeys =  (k,k), (Exp,Exp), (Gen,Gen)  

#Processes  
INITIATOR(A, x, text)   
RESPONDER(B, y)   

#Protocol description  
0.    -&gt; A : B  
[A != B]  
1.  A -&gt; B : Exp(Gen,x) % expx  
[A != B and expx!=Gen]  
&lt;k := Exp(expx, y)&gt;  
2.  B -&gt; A : Exp(Gen,y) % expy  
&lt;k := Exp(expy, x)&gt;  
3.  A -&gt; B : {text}{k}  

#Specification  
Secret(A, text, [B])  
Secret(B, text, [A])  

#Actual variables  
Alice, Bob, Mallory : Agent  
X, Y, Z : Num  
Text1, Text2 : TEXT  

#Equivalences  
forall x, y : Num . Exp ( Exp(Gen,x), y ) = Exp( Exp(Gen,y), x )  

#System  
INITIATOR(Alice, X, Text1)  
RESPONDER(Bob,  Y)  

#Intruder Information
Intruder = Mallory
IntruderKnowledge = {Alice, Bob, Mallory, Z, Text2}
</code></pre>
","68","<model><key><protocols><spl><diffie-hellman>","0","0","1","2013-10-03 11:21:05","","0","","","","","2013-09-15 21:58:41",""
"40471439","JS Diffie Hellman SSL with blockchain auth","<p>I'm trying to figure out if the security quality of SSL can be mimicked without the need for a centralized CA.</p>

<p>There are many questions on here about setting up pure-JS diffie hellman in place of SSL. All of them are roundly refuted, and I think I understand why (although I completely disagree that there's no value in DH-keyed symmetric encryption for the millions of sites which are not going to be implementing full SSL anytime soon either way).</p>

<p>Anyway, question is this: it seems as though the only preventative reason JS DH wouldn't work is that you lose authentication so you're still subject to man-in-the-middle. All the <a href=""https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/"" rel=""nofollow noreferrer"">myriad other issues</a> flow from attempts to resolve this one. </p>

<p>But what if you used a blockchain as a certificate authority? The process would then be </p>

<ol>
<li>Form DH key</li>
<li>encrypt any handshake string with known public key from blockchain</li>
<li>encrypt this verify string with DH key</li>
<li>if handshake string received back, authentication verifies and DH is as secure as SSL DH</li>
</ol>

<p><strong>Edit:</strong> didn't mean to imply DH was symmetric, adjusted for clarity</p>
","","68","<javascript><encryption><blockchain><diffie-hellman>","0","","0","2016-11-08 16:11:33","","2","","5937695","","2016-11-08 16:11:33","2016-11-07 17:52:22",""
"52827550","Bouncy Castle - Diffie Hellman Secrets do not match","<p>I am using Bouncy castle library to use DH key exchange. So far i have tried this much but keys seem to not match. What am i doing wrong? PLEASE HELP!</p>

<pre><code>        var p = Org.BouncyCastle.Math.BigInteger.ProbablePrime(1024, new Random());
        var g = new Org.BouncyCastle.Math.BigInteger(""5"");

        var importedParameters = new Org.BouncyCastle.Crypto.Parameters.DHParameters(p, g);

        //---------------------bob---------------------------------------------------
        var scrnd = new SecureRandom();
        var bobkeyGen = GeneratorUtilities.GetKeyPairGenerator(""DH"");
        var kgp = new DHKeyGenerationParameters(scrnd, importedParameters);
        bobkeyGen.Init(kgp);
        var bobasypair = bobkeyGen.GenerateKeyPair();

        var dhPublicKeyParameters = bobasypair.Public as DHPublicKeyParameters;
        var dhPrivateKeyParameters = bobasypair.Private as DHPrivateKeyParameters;

        var internalKeyAgree = AgreementUtilities.GetBasicAgreement(""DH"");
        internalKeyAgree.Init(dhPrivateKeyParameters);
        var secret = internalKeyAgree.CalculateAgreement(dhPublicKeyParameters);

        //-----------------------------alice--------------------------------------------------------------------------------
        var alicekeyGen = GeneratorUtilities.GetKeyPairGenerator(""DH"");
        var allkgp = new DHKeyGenerationParameters(scrnd, importedParameters);
        alicekeyGen.Init(allkgp);
        var aliceasypair = alicekeyGen.GenerateKeyPair();

        var alicedhPublicKeyParameters = aliceasypair.Public as DHPublicKeyParameters;
        var alicedhPrivateKeyParameters = aliceasypair.Private as DHPrivateKeyParameters;

        var allinternalKeyAgree = AgreementUtilities.GetBasicAgreement(""DH"");
        allinternalKeyAgree.Init(alicedhPrivateKeyParameters);
        var tobesamesecret = allinternalKeyAgree.CalculateAgreement(alicedhPublicKeyParameters);

        if (!secret.Equals(tobesamesecret))
            throw new Exception();
</code></pre>
","","61","<c#><bouncycastle><diffie-hellman>","0","","0","2018-10-16 03:25:05","","2","","","","","2018-10-16 03:25:05",""
"36699103","Diffie Hellman key exchange for VM","<p>Here's a simpler model:</p>

<p>I'm planning to put 3 VM on VirtualBox - Alice, Bob and an intermediate node and implement Diffie Hellman key exchange between the three. Will this work? Is there any better way to do this? I plan to code the entire thing in JAVA.</p>

<p>Previous Question: </p>

<p>I am working on building a smaller version of TOR network in JAVA. In the model, two people Alice and Bob interact with each other, but indirectly through a fixed amount of intermediate nodes(3 for now). The path is pre-defined as of now, but later I wish to make it dynamic.</p>

<p>Can anyone guide me how do I go about it? I want to use Java for its extensive support for networking. Should I use multiple VM's for the Alice, Bob and the three servers? If yes, how will they communicate?</p>
","","57","<java><client-server><virtual-machine><tor><diffie-hellman>","0","","0","2016-04-19 03:58:58","","3","0","4818900","","2016-04-19 03:58:58","2016-04-18 16:07:58",""
"48915842","Does Thrift support Diffie Hellman ciphers for TLS?","<p>Looking at this file it seems Thrift doesn't include openssl functions for supporting Diffie Hellman.
<a href=""https://github.com/apache/thrift/blob/master/lib/cpp/src/thrift/transport/TSSLSocket.cpp"" rel=""nofollow noreferrer"">https://github.com/apache/thrift/blob/master/lib/cpp/src/thrift/transport/TSSLSocket.cpp</a></p>

<p>Is it implemented somewhere else?
Is there any special reason if it is not used on purpose?</p>

<p>Thanks in advance!</p>
","","57","<networking><openssl><diffie-hellman><thrift-protocol>","0","","0","2018-02-21 21:33:20","","7","","","","","2018-02-21 21:33:20",""
"40818024","Determine DH params from remote server","<p>is it possible to determine the SSL DH parameter bit size via Python?</p>

<p>I searched for days, but there is not single answer in the whole Internet.</p>

<p>The native OpenSSL can do this. Why not with Python?</p>
","","56","<python><diffie-hellman><pyopenssl>","1","","0","2016-11-26 16:29:00","","1","","608639","","2016-11-26 16:29:00","2016-11-26 11:49:02",""
"32439736","Load/Export RandomNumber","<p>In the frame of an home-made <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Diffie-Hellman"" rel=""nofollow""><code>ECDHE</code></a> application, both the client and the server have to send a randomly generated numbers (rng), in order to build later the <code>MasterSecret</code> during the handshake (TLS-like)...</p>

<p>With <a href=""http://www.cryptopp.com/"" rel=""nofollow"">crypto++</a>, it's easy to create these numbers, thanks to :</p>

<pre><code>AutoSeededRandomPool rng;
</code></pre>

<p>My problem is 1) <strong>to export them</strong> to a string or equivalent, and 2) <strong>to load them</strong> from a string.</p>

<p>I must put these numbers within a frame, and nor the <a href=""http://www.cryptopp.com/docs/ref/class_auto_seeded_random_pool.html"" rel=""nofollow"">Class definition</a>, nor the <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">examples</a> precise that.</p>

<p>On the web I haven't been able to find Save/Load examples (like the ones for <code>RSA::PublicKeys</code>).</p>

<p>Apparently I'm the first to want this, as their <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">examples</a> generate the client and the server <em>in the same program</em>, and thus don't need to transmit the numbers.</p>

<p>And, as part of this handshake, I also try to do the same with curvesID...</p>
","<p>This question was a misunderstanding from my part, so I'll explain it, in case of anyone having the same interrogations. It's largely inspired from the <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">crypto++ wiki</a>...</p>

<p>There are 2 distinct objects : </p>

<pre><code>AutoSeededRandomPool prng;

prng.GenerateBlock( scratch, scratch.size() );
</code></pre>

<p><code>AutoSeededRandomPool prng;</code> is the generator of random numbers (that will be auto-seeded)</p>

<p><code>prng.GenerateBlock</code> is the command that will extract bits from this random number to build the <code>std::string scratch</code> of the desired length.</p>

<p>And as the scratch is a string, we can do what we want with it, to use it anywhere... So please refer to the <strong>string</strong> import/export.</p>
","56","<c++><ssl><crypto++><diffie-hellman>","0","0","1","2015-09-08 11:52:54","32457123","4","","3494633","","2015-09-07 14:40:59","2015-09-07 13:19:36",""
"57943056","Java Diffie hellman initialize ECDHKeyAgreement","<p>I have a Diffie–Hellman security class like this: </p>

<pre><code>public class AESSecurityCap {

    private PublicKey publicKey;
    KeyAgreement keyAgreement;
    byte[] sharedsecret;

    AESSecurityCap() {
        makeKeyExchangeParams();
    }

    private void makeKeyExchangeParams() {
        KeyPairGenerator kpg = null;
        try {
            kpg = KeyPairGenerator.getInstance(""EC"");
            kpg.initialize(128);
            KeyPair kp = kpg.generateKeyPair();
            publicKey = kp.getPublic();
            keyAgreement = KeyAgreement.getInstance(""ECDH"");
            keyAgreement.init(kp.getPrivate());

        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            e.printStackTrace();
        }
    }

    public void setReceiverPublicKey(PublicKey publickey) {
        try {
            keyAgreement.doPhase(publickey, false);  // &lt;--- Error on this line
            sharedsecret = keyAgreement.generateSecret();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        }
    }
} 
</code></pre>

<p>and implemented this class:    </p>

<pre><code>public class Node extends AESSecurityCap {
}
</code></pre>

<p>Sometimes I need to reinitialize DH <code>keyAgreement</code>:    </p>

<pre><code>public class TestMainClass {
    public static void main(String[] args) {
        Node server = new Node();
        Node client = new Node();

        server.setReceiverPublicKey(client.getPublicKey());
        client.setReceiverPublicKey(server.getPublicKey());

        // My problem is this line ,
        // Second time result exception
        server.setReceiverPublicKey(client.getPublicKey()); 
    }
}
</code></pre>

<p>but receive this exception:     </p>

<pre><code>Exception in thread ""main"" java.lang.IllegalStateException: Phase already executed
    at jdk.crypto.ec/sun.security.ec.ECDHKeyAgreement.engineDoPhase(ECDHKeyAgreement.java:91)
    at java.base/javax.crypto.KeyAgreement.doPhase(KeyAgreement.java:579)
    at ir.moke.AESSecurityCap.setReceiverPublicKey(AESSecurityCap.java:37)
    at ir.moke.TestMainClass.main(TestMainClass.java:13)
</code></pre>

<p>Is there any way to reinitialize ECDH KeyAgreement multiple time?</p>

<p>This is my test case:</p>

<ol>
<li>Client initialize DH and generate public key.</li>
<li>Client sent public key to server.</li>
<li>Cerver initialize DH with client key and generate own public key and generate shared secret key.</li>
<li>Server send public key to client.</li>
<li>Client generate shared secret key with server public key.
In this step client and server has public keys and shared secret.</li>
</ol>

<p>My problem is client disconnected() and KeyAgreement initialized by singleton object and don't reinitialized second time.</p>

<p>Sometimes I need to do this subject.</p>

<p>Please guide me to fix this problem.</p>
","<p>The <code>IllegalStateException (Phase already executed)</code> seems to be especially caused by the ECDH-implementation of the SunEC-provider. The exception doesn't occur if an (additional) <a href=""https://docs.oracle.com/en/java/javase/12/docs/api/java.base/javax/crypto/KeyAgreement.html#init(java.security.Key)"" rel=""nofollow noreferrer""><code>init</code></a> is executed immediately before the <a href=""https://docs.oracle.com/en/java/javase/12/docs/api/java.base/javax/crypto/KeyAgreement.html#doPhase(java.security.Key,boolean)"" rel=""nofollow noreferrer""><code>doPhase</code></a>. However, this <code>init</code>-call shouldn't be necessary, since after the <code>doPhase</code>-call <a href=""https://docs.oracle.com/en/java/javase/12/docs/api/java.base/javax/crypto/KeyAgreement.html#generateSecret(java.lang.String)"" rel=""nofollow noreferrer""><code>generateSecret</code></a> is executed, which should reset the <code>KeyAgreement</code>-instance to the state after the <code>init</code>-call, at least according to the <code>generateSecret</code>-documentation: </p>

<blockquote>
  <p>This method resets this KeyAgreement object to the state that it was in after the most recent call to one of the init methods...</p>
</blockquote>

<p>Possibly it's a bug in the SunEC-provider. If DH is used instead of ECDH (and the SunJCE-provider instead of the SunEC-provider) the behavior is as expected, i.e. repeated <code>doPhase</code>-calls are possible (without additional <code>init</code>-calls). The same applies to ECDH using the <a href=""https://www.bouncycastle.org/"" rel=""nofollow noreferrer"">BouncyCastle</a>-provider. Therefore, you could take the BouncyCastle-provider instead of the SunEC-provider to run ECDH with your code.</p>

<p><em>Note</em>: The second parameter (<a href=""https://docs.oracle.com/en/java/javase/12/docs/api/java.base/javax/crypto/KeyAgreement.html#doPhase(java.security.Key,boolean)"" rel=""nofollow noreferrer""><code>lastPhase</code></a>) in <code>doPhase</code> should be set to true, otherwise an <code>IllegalStateException (Only two party agreement supported, lastPhase must be true)</code> is generated (at least for ECDH).</p>

<p><strong>EDIT:</strong></p>

<p>The bug is already known and fixed in JDK 12, see <a href=""https://bugs.openjdk.java.net/browse/JDK-8205476"" rel=""nofollow noreferrer"">JDK-8205476: <code>KeyAgreement#generateSecret</code> is not reset for ECDH based algorithmm</a>.</p>
","56","<java><java-ee><diffie-hellman>","2","1","1","2019-09-15 17:04:12","57945019","0","","1744774","","2019-09-15 10:15:53","2019-09-15 10:05:22",""
"55533670","Computing ECDH (secp256k1) shared secret gives wrong result","<p>I am trying to compute ECDH (<strong>secp256k1</strong>) shared secret based on private key ""5785cb919db4984453826032a411248184536c632096c647f72db4e66a8bd091"" and public key ""0425a4ef791d8d855077c4d5dd6ca87cbda2f3296939a350e4ea57b3f0235fe1ba4d02cb29f6391675e866944065f9905a30a3e472c45c7ad7afa06143d87efa13""</p>

<p>I use <a href=""https://github.com/bitcoin-core/secp256k1"" rel=""nofollow noreferrer"">secp256k1</a> with swift. </p>

<pre><code>    let myPrKeyBytes: [UInt8] = [87, 133, 203, 145, 157, 180, 152, 68,
                                 83, 130, 96, 50, 164, 17, 36, 129, 132,
                                 83, 108, 99, 32, 150, 198, 71, 247, 45,
                                 180, 230, 106, 139 ,208, 145]

    let myPubKeyBytes: [UInt8] = [4, 37, 164, 239, 121, 29, 141, 133,
                                  80, 119, 196, 213, 221, 108, 168, 124,
                                  189, 162, 243, 41, 105, 57, 163, 80,
                                  228, 234, 87, 179, 240, 35, 95, 225,
                                  186, 77, 2, 203, 41, 246, 57, 22, 117,
                                  232, 102, 148, 64, 101, 249, 144, 90,
                                  48, 163, 228, 114, 196, 92, 122, 215,
                                  175, 160, 97, 67, 216, 126, 250, 19]

    let ctx = secp256k1_context_create(UInt32(SECP256K1_CONTEXT_SIGN))

    var publicKeyParsed = secp256k1_pubkey()

    let publicKeyParseStatus = secp256k1_ec_pubkey_parse(
        ctx!,
        &amp;publicKeyParsed,
        myPubKeyBytes,
        myPubKeyBytes.count
    )

    guard publicKeyParseStatus == 1 else {

        fatalError(""Couldn't parse the public key"")
    }


    let sharedSecretLength = 32
    let sharedSecret = UnsafeMutablePointer&lt;UInt8&gt;
        .allocate(capacity: sharedSecretLength)

    let sharedSecretComputeStatus = secp256k1_ecdh(
        ctx!,
        sharedSecret,
        &amp;publicKeyParsed,
        myPrKeyBytes
    )

    guard sharedSecretComputeStatus == 1 else {

        fatalError(""Couldn't compute shared secret"")
    }

    var sharedSecretBytes: [UInt8] = []
    for i in 0..&lt;sharedSecretLength {

        sharedSecretBytes.append(sharedSecret[i])
    }

    let sharedSecretStr = sharedSecretBytes
        .map { String(format: ""%02x"", $0) }
        .joined()

    print(""Shared secret: \(sharedSecretStr)"")
    // Shared secret: 4d6f4351d68351c419408621efddfcfcc0bc10270669af822093fcf22c9ca26c
</code></pre>

<p>I've got ""4d6f4351d68351c419408621efddfcfcc0bc10270669af822093fcf22c9ca26c"" shared secret, but correct secret should be ""ccf231a0ce74e92d9a94265ab27aa4616a3683af5df5aa65f4a011ad83673b49""</p>
","","54","<swift><encryption><diffie-hellman><ecdh>","0","","0","2019-04-05 10:47:58","","5","","3100312","","2019-04-05 10:47:58","2019-04-05 10:43:38",""
"56884666","What are the ways to implement Diffie Hellman to generate public and private key in iOS swift/Objective C?(Other than Chilkat)","<p>The requirement is, there would be two devices(alice and bob)generates public and private keys using diffie hellman. public keys would get exchanged bewteen both the devices (alice and bob) and generate a secret key with their private keys. </p>

<p>This is for iOS, either in Objective C or Swift. I have tried with raorafat(GitHub code) and other source codes; however, no solution was really drawn for my requirement.</p>

<p>One thing if I share my public key to server how would server deal with my public key to generate symmetric key.</p>
","<p>You can use Apple's CommonCrypto library from Swift. For example of using CCDH, see  <a href=""https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60118.50.1/test/CommonCrypto/CommonDHtest.c.auto.html"" rel=""nofollow noreferrer"">https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60118.50.1/test/CommonCrypto/CommonDHtest.c.auto.html</a></p>

<p>You can import it using </p>

<pre><code>import CommonCrypto
</code></pre>

<p>in your Swift project.</p>
","52","<ios><objective-c><openssl><diffie-hellman><commoncrypto>","0","0","1","2019-07-15 11:31:47","","0","","9651313","","2019-07-15 11:31:47","2019-07-04 09:20:51",""
"56072214","How to deal with 128bit variable in MinGM32 bit compiler for Encryption (Diffie Hellman Algorithm) in Qt","<p>I want to use the below equation in one of the code</p>

<h2>A = g^a mod p; //g raise to a modulus p.</h2>

<p>(something like 2^5 % 3) = 32%3 = 2</p>

<p>(This equation looks like Diffie Hellman algorithm for security)</p>

<p>Where:</p>

<ul>
<li>^ is (power)</li>
<li>g is fixed number 0x05</li>
<li>a is 128bit(16bytes) randomly generated number,</li>
<li>p is fixed hex number of 128bit(16bytes). Something like (0x0xD4A283974897234CE908B3478387A3).</li>
</ul>

<p>I am using:</p>

<ul>
<li>Qt 4.8.7</li>
<li>Compiler MinGW32 (checked with boost library boost 1.70)</li>
</ul>

<h2>The solutions which I found which didn`t work for me are listed below:</h2>

<ol>
<li><p>one can use __int128 but to support that one should have used
latest GCC compiler or MinGW64 bit compiler, neither of that I am using now.</p></li>
<li><p>I found one latest version of Qt has QSslDiffieHellmanParameters class,
but again not supported in our Qt version.</p></li>
<li><p>I found some libraries like  boost/multiprecision/cpp_int.hpp (boost 1.70))
that does have data type such as int128_t and int256_t, but due to 
our compiler isssue or something else, we are not able to store
128bit number, meaning
if I do: </p></li>
</ol>

<pre><code>    int128_t ptval128 = 0xAB1232423243434343BAE3453345E34B;
    cout &lt;&lt; ""ptval128 = "" &lt;&lt; std::hex &lt;&lt; ptval128 &lt;&lt; endl;
    //will print only 0xAB12324232434343;//half digits only,
</code></pre>

<ol start=""4"">
<li>I tried using Bigint which much more useful, but again
5^(128bit number) is way too big, it takes hours to compute things,
(I waited till 1 hour  and 16 mins and kill the application).</li>
</ol>

<pre><code>    int myGval = 0x05;
    128_bit_data_type myPVal= 0xD4A283974897234CE908B3478387A3; 

    128_bit_data_type 128_bit_variable = 128_bit_random_data;
    myVal = (myGval)^(128_bit_variable) % (myPVal);
</code></pre>
","<p>That is not how to do modular exponentiation! The first problem is that <code>5 ^ 128_bit_variable</code> is <em>huge</em>, so big that it won't fit into memory in any computers available today. To keep the required storage space within bounds, you have to take the remainder <code>% myPVal</code> after every operation.</p>

<p>The second problem is that you can't compute <code>5 ^ 128_bit_variable</code> simply by multiplying by <code>5</code> by itself <code>128_bit_variable</code> times -- that would take longer than the age of the universe. You need to use an exponentiation ladder, which requires just <code>128</code> squarings and at most <code>128</code> multiplications. See <a href=""https://en.wikipedia.org/wiki/Exponentiation_by_squaring"" rel=""nofollow noreferrer"">this Wikipedia article</a> for the details. In the end, the operation <code>5 ^ 128_bit_number</code> should take a fraction of a second.</p>
","52","<c++><qt><boost><bigint><diffie-hellman>","-1","0","1","2019-05-10 11:27:00","56076752","1","","2110683","","2019-05-10 09:17:37","2019-05-10 06:51:12",""
"26658862","Exchange key between two clients through a server","<p>I have a problem about exchange a key between two clients through a server.</p>

<p>But I don't want the server being able to intercept the key or make a MitM.</p>

<p>What method can I use to avoid this problem?</p>
","","52","<security><protocols><diffie-hellman>","0","","0","2015-05-19 21:02:03","","2","","3906760","","2015-05-19 21:02:03","2014-10-30 16:52:47",""
"54334633","LibCrypt how to get my generated public key using low level apis","<p>In my project in order to implement a Group key agreement I decided to use the low-level apis of OpenSSl for Diffie Hellman (code snippet taken from <a href=""https://wiki.openssl.org/index.php/Diffie_Hellman"" rel=""nofollow noreferrer"">documentation</a> )</p>

<pre><code>#include &lt;libssl/dh.h&gt;
// Some code here

DH *privkey;
int codes;
int secret_size;

/* Generate the parameters to be used */
if(NULL == (privkey = DH_new())) handleErrors();
if(1 != DH_generate_parameters_ex(privkey, 2048, DH_GENERATOR_2, NULL)) handleErrors();

if(1 != DH_check(privkey, &amp;codes)) handleErrors();
if(codes != 0)
{
    /* Problems have been found with the generated parameters */
    /* Handle these here - we'll just abort for this example */
    printf(""DH_check failed\n"");
    abort();
}

/* Generate the public and private key pair */
if(1 != DH_generate_key(privkey)) handleErrors();

/* Send the public key to the peer.
 * How this occurs will be specific to your situation (see main text below)
 */

// Another code here

//Cleanups
OPENSSL_free(secret);
BN_free(pubkey);
DH_free(privkey);
</code></pre>

<p>But from a generated <code>DH</code> struct how I can generate a public key?</p>
","<p>If you read the documentation for <a href=""https://www.openssl.org/docs/man1.1.0/crypto/DH_generate_key.html"" rel=""nofollow noreferrer"">DH_generate_key</a>, it does (as the comment says).</p>

<blockquote>
  <p>DH_generate_key() expects dh to contain the shared parameters dh->p and dh->g. It generates a random private DH value unless dh->priv_key is already set, and computes the corresponding public value dh->pub_key, which can then be published.</p>
</blockquote>

<p>So the public ""key"" part of the Diffie Hellman exchange is in ""<strong>privkey->pub_key</strong>"" and you publish that along with your shared parameters ""<strong>privkey->p</strong>"" and ""<strong>privkey->g</strong>"" to the other side.</p>
","51","<c><openssl><diffie-hellman><libcrypto>","1","1","1","2019-01-25 12:43:00","54337740","0","1","4706711","","2019-01-25 12:43:00","2019-01-23 19:49:05",""
"53307899","Get a cryptographically secure random numder as an integer in python","<p>I try to perform some modular exponentiation in order to perform some chained Diffie Hellman key agreement (for research puproce).</p>

<p>Thus I generate the random key like that:</p>

<pre><code>priv_value=Random.get_random_bytes(128)
</code></pre>

<p>And I generate the Diffie Hellman public value like that:</p>

<pre><code>def dh_public(secret):
    g=2

    p=""""""FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
      E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
      83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
      E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
      DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
      15728E5A 8AACAA68 FFFFFFFF FFFFFFFF""""""
    p=re.sub(r""[\n\t\s]*"", """", p)
    p=int(p,16)
    return pow(g,secret,p)
</code></pre>

<p>So my script that does the calculation is:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -*- Mode: python; c-basic-offset: 4 -*-

from Crypto import Random
import re

priv=Random.get_random_bytes(128)

def dh_public(secret):
    g=2

    p=""""""FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
      E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
      83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
      E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
      DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
      15728E5A 8AACAA68 FFFFFFFF FFFFFFFF""""""
    p=re.sub(r""[\n\t\s]*"", """", p)
    p=int(p,16)
    return pow(g,secret,p)

print dh_public(priv)
</code></pre>

<p>With <code>g</code> and <code>p</code> values that are based upon <a href=""https://datatracker.ietf.org/doc/rfc3526/?include_text=1"" rel=""nofollow noreferrer"">RFC3526</a>.</p>

<p>But when I try to run it I get the following error:</p>

<pre><code>Traceback (most recent call last):
  File ""/home/pcmagas/Kwdikas/python/DHKeylist/dh_demo.py"", line 28, in &lt;module&gt;
    print dh_public(priv)
  File ""/home/pcmagas/Kwdikas/python/DHKeylist/dh_demo.py"", line 26, in dh_public
    return pow(g,secret,p)
TypeError: unsupported operand type(s) for pow(): 'int', 'str', 'long'
</code></pre>

<p>So my problem is on how to convert the <code>Random.get_random_bytes</code> value to integer. (I do not know the base to convert them with python's <code>int</code> method.)</p>
","<p>The key to your solution is the following...</p>

<p>Replace</p>

<pre><code>return pow(g,secret,p)
</code></pre>

<p>with (for python 3)</p>

<pre><code>return pow(g, int.from_bytes(secret, byteorder='big'), p)
</code></pre>

<p>or (for python 2.7)</p>

<pre><code>return pow(g, int(secret.encode('hex'), 16), p)
</code></pre>
","47","<python><python-2.7><diffie-hellman>","-1","1","1","2018-11-14 20:22:57","53308197","2","","4706711","","2018-11-14 20:06:05","2018-11-14 19:58:37",""
"58167034","ECDiffieHellman - mbedTLS vs C#","<p>I need to use elliptic curve Diffie Hellman between a ARM cortex M3 and the PC.
On the ARM, I use <a href=""https://tls.mbed.org/"" rel=""nofollow noreferrer"">mbed TLS</a>. On the PC side I want to us C# and the <a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.ecdiffiehellmancng?view=netframework-4.7.2"" rel=""nofollow noreferrer"">ECDiffieHellman(Cng)</a> class.</p>

<p>I can do the ECDH on ARM vs ARM, but I do have trouble when I try to replace one side with the PC.</p>

<ol>
<li>Problem was the key exchange.
I found out, that the key is exported by mbed TLS as <code>&lt;LEN&gt;&lt;0x04&gt;&lt;X&gt;&lt;Y&gt;</code>.</li>
</ol>

<p>Thus, In C# I am importing the public key using</p>

<p>private static EC</p>

<pre class=""lang-cs prettyprint-override""><code>DiffieHellmanPublicKey ToPublicKey(byte[] publicKey)
{
    var keyLength = 32;

    if (publicKey[0] != (2 + 2 * keyLength) - 1)
        throw new ArgumentException(""Invalid key length"", nameof(publicKey));
    if (publicKey[1] != 0x04)
        throw new ArgumentException(""Invalid key format"", nameof(publicKey));

    var parameters = new ECParameters()
    {
        Curve = ECCurve.NamedCurves.brainpoolP256r1,
        Q = new ECPoint()
        {
            X = publicKey.Skip(2).Take(keyLength).ToArray(),
            Y = publicKey.Skip(2 + keyLength).Take(keyLength).ToArray()
        }
    };

    using (var tmp = ECDiffieHellman.Create(parameters))
    {
        return tmp.PublicKey;
    }
}
</code></pre>

<ol start=""2"">
<li>To generate the key I tried</li>
</ol>

<pre class=""lang-cs prettyprint-override""><code>var ecdh = new ECDiffieHellmanCng(ECCurve.NamedCurves.brainpoolP256r1);
ecdh.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Tls;
ecdh.Seed = new byte[32];
ecdh.Label = Encoding.ASCII.GetBytes(""ECDiffieHellman"");

new RNGCryptoServiceProvider().GetBytes(ecdh.Seed);

// ...

var sharedSecret = ecdh.DeriveKeyMaterial(peersPublicKey);
</code></pre>

<p>My problem is that the generated shared secret is of different length compared to the one generated by mbed TLS and does not match.</p>

<p>Did someone already solve this problem?</p>

<p>Thanks!</p>

<p><strong>EDIT 1:</strong></p>

<p>I forgot to mention, that I use bare ECDH on ARM. So I don't think there is any key derivation function executing. Is it sufficient to hash (SHA256) the result to match the C# side (when configuring SHA256 as KDF there)?</p>
","<p>I solved the problem. In short: just hash the ECDH result.</p>

<p><strong>C/C++ side:</strong></p>

<ol>
<li>EC Diffie Hellman</li>
</ol>

<pre class=""lang-c prettyprint-override""><code>mbedtls_ecdh_init(...);
mbedtls_ecdh_setup(...);
mbedtls_ecdh_make_public(...); //make own public key and send it to peer
mbedtls_ecdh_read_public(...); //reed peers public key
mbedtls_ecdh_calc_secret(...); //note: i pass in my own RND func because of no OS
mbedtls_ecdh_free(...);
</code></pre>

<ol start=""2"">
<li>SHA256</li>
</ol>

<pre class=""lang-c prettyprint-override""><code>mbedtls_sha256_init(...);
mbedtls_sha256_starts_ret(...);
mbedtls_sha256_update_ret(...);
mbedtls_sha256_finish_ret(...);
mbedtls_sha256_free(...);
</code></pre>

<p><strong>C# side:</strong></p>

<pre class=""lang-cs prettyprint-override""><code>private void EllipticCurveDiffieHellman()
{
    var ecdh = new ECDiffieHellmanCng(ECCurve.NamedCurves.brainpoolP256r1);

    ecdh.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
    ecdh.HashAlgorithm = CngAlgorithm.Sha256;

    //get relevant point from own public key
    var ownPublicKey = ecdh.PublicKey.ExportExplicitParameters().Q;

    var peersPublicKey = SendPublicKey(ownPublicKey); //key exchange
    var sharedSecret = ecdh.DeriveKeyMaterial(peersPublicKey);

    Console.WriteLine(""Key: "" + HexValue.Parse(sharedSecret.ToArray()));
}

DiffieHellmanPublicKey ToPublicKey(byte[] publicKey)
{
    var keyLength = 32;

    if (publicKey[0] != (2 + 2 * keyLength) - 1)
        throw new ArgumentException(""Invalid key length"", nameof(publicKey));
    if (publicKey[1] != 0x04)
        throw new ArgumentException(""Invalid key format"", nameof(publicKey));

    var parameters = new ECParameters()
    {
        Curve = ECCurve.NamedCurves.brainpoolP256r1,
        Q = new ECPoint()
        {
            X = publicKey.Skip(2).Take(keyLength).ToArray(),
            Y = publicKey.Skip(2 + keyLength).Take(keyLength).ToArray()
        }
    };

    using (var tmp = ECDiffieHellman.Create(parameters))
    {
        return tmp.PublicKey;
    }
}
</code></pre>
","47","<c#><c><elliptic-curve><diffie-hellman><mbedtls>","1","0","1","2019-09-30 13:03:48","58168239","0","","1083111","","2019-09-30 12:15:12","2019-09-30 11:29:52",""
"58086169","Ephemeral Diffie-Hellman Java Key Exchange","<p>This is my first post on stackoverflow. I've always found what I needed but today I have to ask a question.</p>

<p>I am writing a program in which I want to connect to the server. The server encrypts data with the Diffie-Hellman algorithm.</p>

<p>And here the server code [C++]</p>

<pre><code>///// SEND KEY
Integer p(""0xB10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C6""
""9A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C0""
""13ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD70""
""98488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0""
""A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708""
""DF1FB2BC2E4A4371"");

Integer g(""0xA4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507F""
""D6406CFF14266D31266FEA1E5C41564B777E690F5504F213""
""160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1""
""909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28A""
""D662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24""
""855E6EEB22B3B2E5"");

Integer q(""0xF518AA8781A8DF278ABA4E7D64B7CB9D49462353"");

AutoSeededRandomPool asrp;

dh_.AccessGroupParameters().Initialize(p, q, g);

p = dh_.GetGroupParameters().GetModulus();
q = dh_.GetGroupParameters().GetSubgroupOrder();
g = dh_.GetGroupParameters().GetGenerator();

Integer v = ModularExponentiation(g, q, p);

SecByteBlock spubkey(dh2_.StaticPublicKeyLength());
SecByteBlock epubkey(dh2_.EphemeralPublicKeyLength());

sprivkey.New(dh2_.StaticPrivateKeyLength());
eprivkey.New(dh2_.EphemeralPrivateKeyLength());

dh2_.GenerateStaticKeyPair(asrp, sprivkey, spubkey);
dh2_.GenerateEphemeralKeyPair(asrp, eprivkey, epubkey);

send(spubkey, epubkey);


///////// KEY AGREE
//buf = recived keys [spubkey+epubkey]
const size_t spub_key_length = dh2_.StaticPublicKeyLength();
shared_.New(dh2_.AgreedValueLength());
dh2_.Agree(shared_, sprivkey, eprivkey, buf, buf + spub_key_length)
</code></pre>

<p>I now want to exchange keys with the program in JAVA.</p>

<p>I don't really understand how to do it. And all examples in JAVA do not include the parameter q and Ephemeral Key.</p>

<p>Stackoverflow. I hope you will help me! 
I'm sitting on it a few good days...</p>

<p>Thank you</p>
","","45","<java><diffie-hellman>","2","","0","2019-09-24 18:21:58","","0","1","","","","2019-09-24 18:21:58",""
"54969309","How to check whether a number is prime or not and ask the user again if it's not prime without exiting the program?","<p>I'm trying to check whether a number is prime or not as a part of Diffie Hellman algorithm and if it's not a prime number ask the user again to input another number without exiting the program.</p>

<p>Here's my code:</p>

<pre><code>def prime(p):
    for i in range(2,p):
        if (p % i) == 0:
            return(False)
            break
        else:
            return(True)


    def primRoots(p):
        roots = []
        required_set = set(num for num in range (1, p))

        for g in range(1, p):
            actual_set = set(pow(g, powers) % p for powers in range (1, p))
            if required_set == actual_set:
                roots.append(g)           
        return roots

    p=int(input(""enter any prime no:""))
    check=prime(p)
    if(check==True):

        primitive_roots = primRoots(p)

        g=primitive_roots[0]
        print(g)
        x=int(input(""Alice chooses value of X as:""))
        y=int(input(""Bob chooses value of y as:""))
        r1=(g**x) % p
        r2=(g**y) % p

        print(""value of r1 is"",r1)
        print(""value of r2 is"",r2)

        a=x*y

        k1=(r2**x) % p
        print(""k1 is"",k1)
        k2=(r1**y)% p
        print(""k2 is"",k2)
        k=(g**a)%p
        print(""shared key is"",k)    
    else:
        print(""It is not a prime num,enter again"")
        prime(p)
</code></pre>
","<pre><code>user_input = int(input(""Enter an integer !  ""))

def prime(n):
    isPrime = True
    for num in range(2, int(n/2)):
        if n % num == 0:
            isPrime = False
    return isPrime


while (prime(user_input)== False):
    user_input = int(input(""==&gt; Your input is incorrect, please enter  an other integer !""))
print(""{} is prime "".format(user_input))
</code></pre>
","41","<python><primes><diffie-hellman>","0","0","1","2019-03-05 20:42:21","","4","","11143706","","2019-03-05 20:42:21","2019-03-03 13:29:00",""
"53043510","How to encrypt a txt file after obtaining a public key shared between a client/server in Java","<p>I finally figured out how to perform a Diffie-Hellman key exchange in Java, the problem now is that I have to encrypt a txt file using the shared key. I do not know how to even start to do that. The txt file is just simply  the integers 1 2 3 4 5 each on a new line. Is there a simple line of code I do not know about that can perform this function? The shared key that I have is 18.0.</p>
","<blockquote>
  <p>encrypt a txt file after obtaining a public key shared between a client/server in Java</p>
</blockquote>

<p>Let's assume you are working on a learning or toy project, otherwise there's no point of (re)inventing your own secure communication. If you want to take the security seriously, just use TLS/SSL (optionally with 2-way client auth ssl) for online content transmission. </p>

<p>I really hope for your own sake you are just learning or playing with this.</p>

<blockquote>
  <p>to encrypt a txt file using the shared key. I do not know how to even start to do that.</p>
</blockquote>

<p>For encryption in rest (encrypting the file itself) - assuming from the question that the sender and receiver are having their own keypairs. </p>

<p>I suggest to create a random data encryption key to encrypt the content. Then you could simply use receiver's public key to encrypt the data encryption key and sign the content's hash using sender's private key. Never use plain (textbook) RSA, use propper padding.</p>

<p>I made a few notes <a href=""https://gusto77.wordpress.com/2017/10/30/encryption-reference-project/"" rel=""nofollow noreferrer"">about encryption</a> for myself, you can take some inspiration. </p>

<blockquote>
  <p>The shared key that I have is 18.0.</p>
</blockquote>

<p>Apprently you are using not long enough or not random enough public keys. Symmetric ciphers require keys of fixed length (e.g. AES requires 128, 192 or 256 bit keys). You could generate longer keys using any key derivation function or hash. If you want to use two-way communication, you need a separate key for each direction.</p>

<p>Regardless that - short key seed (small shared key, short public keys) would be feasible for brute-forcing. There are many ways how you could shoot yourself in your leg when dealing with crypto, so use some industrial standard when possible (e.g. TLS).</p>
","40","<java><encryption><diffie-hellman>","-2","-1","1","2018-10-29 15:26:24","","4","","","","","2018-10-29 10:29:07",""
"54128604","Generate Diffie Hellman Object using npm `threads` module: getPrime is undefined","<p>Using from npm <code>threads</code> library I try to create a diffie hellman in a non-blocking manner using a seperate thread instead of the main one:</p>

<pre><code>const spawn = require('threads').spawn;

const thread = spawn(function(input, done) {
  const cryptot = require('crypto');
  const dh = cryptot.createDiffieHellman(2048);
  done({dh});
});

thread.send({p:null, g:null}).on('message', (response) =&gt; {
  console.log(response.dh.getPrime(), response.dh.getGenerator());
  thread.kill();
}).on('error', (err)=&gt;{
  console.error(err);
}).on('exit', function() {
  console.log('Worker has been terminated.');
});
</code></pre>

<p>But I get the following error:</p>

<pre><code>/home/pcmagas/Kwdikas/master_thesis/custom_xmpp/dummy_src/thread_dh.js:10
  console.log(response.dh.getPrime(), response.dh.getGenerator());
                          ^

TypeError: response.dh.getPrime is not a function
    at Worker.thread.send.on (/home/pcmagas/Kwdikas/master_thesis/custom_xmpp/dummy_src/thread_dh.js:10:27)
    at Worker.emit (/home/pcmagas/Kwdikas/master_thesis/custom_xmpp/node_modules/eventemitter3/index.js:129:35)
    at Worker.handleMessage (/home/pcmagas/Kwdikas/master_thesis/custom_xmpp/node_modules/threads/lib/worker.node/worker.js:148:17)
    at ChildProcess.emit (events.js:182:13)
    at emit (internal/child_process.js:812:12)
</code></pre>

<p>Do you know why the received <code>dh</code> object does not contain the method <code>getPrime</code> and via an assumption the <code>getGenerator</code> as well?</p>
","<p>Well its it true that without proviting generator and prime the key generation is slow on the implementation provided in node.js. But what it makes it slow is the creation of the correct prime and generator where the prime will be <em>2048</em> bits.</p>

<p>So you can do the following:</p>

<ol>
<li>Generate the prime and the generator <strong>inside</strong> the thread</li>
<li>Pass the prime abd generator via done callback to the <code>message</code> event</li>
<li>Re-create a diffie-hellman object there with the generated prime and generator.</li>
</ol>

<p>These steps will be resulted from this code:</p>

<pre><code>const spawn = require('threads').spawn;

const thread = spawn(function(input, done) {
  const cryptot = require('crypto');
  console.time('dh-thread');
  const dh = cryptot.createDiffieHellman(2048);
  console.timeEnd('dh-thread');
  done({prime: dh.getPrime().toString('hex'), generator: dh.getGenerator().toString('hex')});
});

thread.send({p:null, g:null}).on('message', (response) =&gt; {
  const cryptot = require('crypto');
  const dh =  cryptot.createDiffieHellman(response.prime, response.generator);
  // Do whatever you want there
  thread.kill();
}).on('error', (err)=&gt;{
  console.error(err);
}).on('exit', function() {
  console.log('Worker has been terminated.');
});
</code></pre>

<p>Also to justify my statement above let me modify the code a bit using timers:</p>

<pre><code>const spawn = require('threads').spawn;

const thread = spawn(function(input, done) {
  const cryptot = require('crypto');
  console.time('dh-thread');
  const dh = cryptot.createDiffieHellman(2048);
  console.timeEnd('dh-thread');
  done({prime: dh.getPrime().toString('hex'), generator: dh.getGenerator().toString('hex')});
});

thread.send({p:null, g:null}).on('message', (response) =&gt; {
  console.time('dh');
  const cryptot = require('crypto');
  const dh =  cryptot.createDiffieHellman(response.prime, response.generator);
  console.timeEnd('dh');
  thread.kill();
}).on('error', (err)=&gt;{
  console.error(err);
}).on('exit', function() {
  console.log('Worker has been terminated.');
});
</code></pre>

<p>The execution of the code above will result:</p>

<pre><code>dh-thread: 12815.747ms
dh: 6.733ms
Worker has been terminated.
</code></pre>

<p>As you can see the diffie hellman generation without prime and generator takes <strong>WAY</strong> too long instead of provided prime and generator.</p>
","37","<node.js><multithreading><diffie-hellman>","0","0","1","2019-01-10 13:31:54","54129628","0","","","","","2019-01-10 12:20:46",""
"26546158","How to best to secure data over HTTPS","<p>My aim is to have an (iOS) app in which the user would login, then on sucsessful login, gain access to additional information over an  encrypted webservice (undecided).
<br><br>
From research, i understanding encryption techniques of diffie-hellman key exchange, and 'signatures' using HMAC with secret key (from the diffie-hellman).</p>

<p>Further research lead me to HTTPS to ensure no-eavesdropping.
<br><br>
However i'm now a little confused as to what i would need to do over the HTTPS connection to ensure that the login data is secured between app &amp; server.</p>

<p><b>1)</b>, is HTTPS enough security to pass POST 'username' &amp; 'password' data down the line to the server on its own? or would an additional security such as a hash of the password be needed?</p>

<p>or</p>

<p><b>2</b>, would i need to implement a full key exchange + request signature (and at some point an Access Token), over a HTTPS connection?</p>

<p>I'm unsure where to draw the line with encrypting. </p>
","","36","<ssl><encryption><hash><https><diffie-hellman>","0","","0","2014-10-24 10:27:03","","2","","","","","2014-10-24 10:27:03",""
"58749844","Why does my GUI freeze, brefore reading from Network stream, but works fine with - MessageBox.Sow(""""); before reading it?","<p>I am a Computer Science student and this is my second project in c#, so I am not used to it yet and this is my second question on stackoverflow... 
I need to create a program with server and client, but their communication must be safe(I used Diffie-Hellman and AES).
My program freezes when I'm trying to read sent message through NetworkStream, program works fine, if I add show any message with MessageBox, before reading from stream. Also is there any way for client and server to generate the same AES.IV, besides my implementation of global IV?</p>

<pre><code>using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Security.Cryptography;
using System.Linq;

namespace Kodiranje
{
public partial class Form1 : Form
{
    const int port = 22222;
    const string ip = ""127.0.0.1"";
    IPAddress ipServer = IPAddress.Parse(ip);
    TcpListener server = null;
    TcpClient client = null;
    Thread thServer = null;
    NetworkStream dataStream = null;
    string receivedMessage = """";
    bool? izbira = null;
    Aes myAes = Aes.Create();

    byte[] iv = null;


    public Form1()
    {
        InitializeComponent();
        iv = myAes.IV;
        thServer = new Thread(new ThreadStart(startServer));
        thServer.IsBackground = true;
        thServer.Start();
        myAes.Padding = PaddingMode.PKCS7;
        iv = myAes.IV;
    }

    void startServer() {

        server = new TcpListener(ipServer, port);
        server.Start();
        textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(""Strežnik: zagnan na: IP: "" + ip + "", port:"" + port)));
        client = new TcpClient();
        client = server.AcceptTcpClient();
        NetworkStream dataStream = client.GetStream();
        textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(Environment.NewLine + ""Strežnik: Sprejet nov uporabnik"")));


        if (izbira == true)
        {
            byte[] serverPublicKey;
            ECDiffieHellmanCng serverDH = new ECDiffieHellmanCng();
            serverDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            serverDH.HashAlgorithm = CngAlgorithm.Sha256;
            serverPublicKey = serverDH.PublicKey.ToByteArray();



            byte[] message = new byte[1024];
            while (!dataStream.DataAvailable) { }
            if (dataStream.DataAvailable)
                dataStream.Read(message, 0, message.Length);


            byte[] serverCommoneKey = serverDH.DeriveKeyMaterial(CngKey.Import(message, CngKeyBlobFormat.EccPublicBlob));
            textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(Environment.NewLine + ""Strežnik: Dobil sem sporočilo: "" + receivedMessage)));


            dataStream.Write(serverPublicKey, 0, serverPublicKey.Length);

            message = new byte[1024];

            myAes = Aes.Create();
            myAes.Padding = PaddingMode.PKCS7;
            myAes.Key = serverCommoneKey;
            myAes.IV = iv;
            ICryptoTransform encryptor = myAes.CreateEncryptor(myAes.Key, iv);
            byte[] encrypted;
            // Create the streams used for encryption.
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(""Serbus deda"");

                    }
                    encrypted = msEncrypt.ToArray();
                    int s = encrypted.Length;
                    MessageBox.Show(""""); // freezes without message
                    dataStream.Write(encrypted, 0, encrypted.Length);

                } 
            }
        }


        else {
            byte[] message = new byte[1024];
            message = Encoding.UTF8.GetBytes(""serbus"");
            dataStream.Write(message, 0, message.Length);


        }


    }

    void button1_Click(object sender, EventArgs e) { // happens when client connects to the server
        if (izbira == null) {
            textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(Environment.NewLine + ""Izbrati morate ali boste datoteko prenesli ali poslali!"")));
            return;
        }
        this.button1.Enabled = false;
        client = new TcpClient();
        IPAddress insertedIp = IPAddress.Parse(textBox1.Text);


        byte[] clientPublicKey;
        ECDiffieHellmanCng clientDH = new ECDiffieHellmanCng();
        clientDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
        clientDH.HashAlgorithm = CngAlgorithm.Sha256;
        clientPublicKey = clientDH.PublicKey.ToByteArray();


        client.Connect(insertedIp, Convert.ToInt32(textBox3.Text));
        dataStream = client.GetStream();


        if (izbira == true)
        {

            dataStream.Write(clientPublicKey, 0, clientPublicKey.Length);

            byte[] message = new byte[1024];

            MessageBox.Show(""""); // freezes without message
            while (true)
            {
                if (dataStream.DataAvailable)
                {

                    dataStream.Read(message, 0, message.Length);
                    textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(Environment.NewLine + ""Client: Dobil sem sporočilo: "" + receivedMessage)));
                    break;
                }
            }
            byte[] clientCommoneKey = clientDH.DeriveKeyMaterial(CngKey.Import(message, CngKeyBlobFormat.EccPublicBlob));




            byte[] encryptedMessage = new byte[16];
            while (!dataStream.DataAvailable) { }
            MessageBox.Show(""""); // freezes without message
            dataStream.Read(encryptedMessage, 0, encryptedMessage.Length);
            myAes = Aes.Create();
            myAes.Padding = PaddingMode.PKCS7;
            myAes.Key = clientCommoneKey;
            // Create a decryptor to perform the stream transform.
            ICryptoTransform decryptor = myAes.CreateDecryptor(myAes.Key, iv);

            // Create the streams used for decryption.
            using (MemoryStream msDecrypt = new MemoryStream(encryptedMessage))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {

                        // Read the decrypted bytes from the decrypting stream
                        // and place them in a string.
                        string plaintext;
                        plaintext = srDecrypt.ReadToEnd();
                        MessageBox.Show(""Sprejeto sporočilo "" + plaintext);

                    }
                }
            }


        }
        else {

            byte[] message = new byte[1024];
            //MessageBox.Show(""Serbus"");
            while (!dataStream.DataAvailable)
            { }
            dataStream.Read(message, 0, message.Length);

            receivedMessage = Encoding.UTF8.GetString(message);
            textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(Environment.NewLine + ""Strežnik: Dobil sem sporočilo: "" + receivedMessage)));
        }
    }

    void buttonUpload_Click(object sender, EventArgs e) {
        izbira = true;
        this.buttonDownload.Enabled = false;
    }
    void buttonDownload_Click(object sender, EventArgs e) {
        izbira = false;
        this.buttonUpload.Enabled = false;
        this.button2.Text = ""Prenesi"";
    }



}
</code></pre>

<p>}</p>
","","34","<c#><aes><networkstream><diffie-hellman>","0","","0","2019-11-07 13:31:42","","2","","","","","2019-11-07 13:31:42",""
"57632352","OverflowErro cannot fit 'int' into an index-sized integer","<p>I am trying to convert an int of size n bits to bytes. This returns an overflow error</p>

<p>Trying to convert the int to bytes to be used later with TCP</p>

<pre class=""lang-py prettyprint-override""><code>def diffie_hellman():
    global a,g,n
    a = random.randint(1,5000)
    g = random.getrandbits(4000)
    n = sympy.randprime(1, 100)
    #print(a,g,n)

def diffie_send(a,g,n):
    clientsocket.send(bytes(a))
    clientsocket.send(bytes(g))
    clientsocket.send(bytes(n))

</code></pre>

<p>I expect it to just convert to bytes but again all i get is an overflow error.</p>
","<p>I tried something that some may see as ""hacky"" but it worked for me so... I converted the int to a string before converting to bytes</p>

<pre><code>g = random.getrandbits(4000)
val = str(g) + ' '
</code></pre>
","33","<python><random><sympy><diffie-hellman>","1","0","1","2019-08-23 21:04:42","","1","","11912714","","2019-08-23 20:07:47","2019-08-23 19:59:36",""
"16857075","Can a user apply for another public key based on its pseudonym and use the obtained public key in DH key exchange?","<p>I have a scenario in which there are three parties: one user,one content provider and a proxy. The data is to be transferred between user and content provider anonymously though the proxy.  I have two questions.
1. If the user has a pseudonym based on its public key, can it apply for another public key?
2. For data confidentiality between user and content provider such that proxy cannot read the transferred contents, Diffie-Hellman key exchange can be used. But can I use the public key obtained in part 1 to get the encrypted data between user and content provider?</p>

<p>Best Regards</p>

<p>Alexandera</p>
","<p>Diffie-Hellman is a method for establishing a shared secret between two entities.
So, that's a part of secret key cryptography.</p>

<p>No number of public keys, unless you manage to generate the current shared secret, will get you the information shared between two parties using secret key crypto.  A public key should be matched to, and used with, a private key.  That's public key cryptography.</p>

<p>For part 1, I guess I don't understand what you want to do with the public key other than generate a pseudonym with it, I don't see why not.
Maybe I'm misunderstanding your question but I believe the answer for part 2 is no.</p>
","33","<public-key-encryption><diffie-hellman>","0","0","1","2013-05-31 12:30:13","","0","","","","","2013-05-31 12:17:42",""
"58274946","How to extract DH parameters from a DH key in PEM format","<p>I have generated a Diffie-Hellman key using certain <code>g</code> and <code>p</code> parameters, like this:</p>

<pre><code>$ cat dhparam.pem
-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEAnc5+uXl2K09Nrp1oxN/KbIcIYLg8HXCu9UNW7gFknkHil7OVAKHR
Km0Dc8IjqhJpDfoNKFoDo2Vd0KB9moSkDmhFmidcXO7Q8zSq0Z4BXFTO61OMukdd
dul1ovbleqfH4DcbCjH4LiZGICFUyGseiBakt3e2BORyjSA3IEg4hm9WvdCevWPW
Njc9reFgL6Vua8HkOGkLB+EvRP1YT4v5hGGP/6A7WxRevx5EjF9VgojyDLMPN26C
3c17KY2jNV0W1GEcKEciWS61QInUDBDPYNuQzTl0LucbOpJyV3BFr6pokRBaO3bI
ZYUPhjA2WSxJUeeJboJfisr+CQa9kc1dYwIBAg==
-----END DH PARAMETERS-----
$ openssl genpkey -paramfile dhparam.pem -out dh.pem
$ cat dh.pem
-----BEGIN PRIVATE KEY-----
MIICJgIBADCCARcGCSqGSIb3DQEDATCCAQgCggEBAJ3Ofrl5ditPTa6daMTfymyH
CGC4PB1wrvVDVu4BZJ5B4pezlQCh0SptA3PCI6oSaQ36DShaA6NlXdCgfZqEpA5o
RZonXFzu0PM0qtGeAVxUzutTjLpHXXbpdaL25Xqnx+A3Gwox+C4mRiAhVMhrHogW
pLd3tgTkco0gNyBIOIZvVr3Qnr1j1jY3Pa3hYC+lbmvB5DhpCwfhL0T9WE+L+YRh
j/+gO1sUXr8eRIxfVYKI8gyzDzdugt3NeymNozVdFtRhHChHIlkutUCJ1AwQz2Db
kM05dC7nGzqScldwRa+qaJEQWjt2yGWFD4YwNlksSVHniW6CX4rK/gkGvZHNXWMC
AQIEggEEAoIBAGJBY5qzXPRi62hzho+ebCeZMdVqGQrlc9h/1hmrlzXlna8Mu8WF
0hp/ol8s3AAvuG2w8sMHH/D0kHj2Ptf92khH2WObWAzyybf3IubpVumw6d2KSe1j
LhW0cJum/lbyhyGJNgdNrVlwyNcId2Z53K9TK1BQnb3/gJjM+cRZ1yyoPDTXZpLl
1dmLz3lw+kmowyNXtl/wgzDclR16/w7JSvM+tOFCs4X1ZZF9TbQi7czc0ov101gP
bJjbUaYNOLUQrI/vVEDmCzYIL3PDLV07gQu0FeLHnRChgdjal3xVIsp0oV+2cN7K
/UX4xqCSBXp8ieAoJ+r7zZD44JqhMVF+d5A=
-----END PRIVATE KEY-----
</code></pre>

<p>My understanding is that the key file <code>dh.pem</code> includes not only the secret part of the key, but also the non-secret <code>g</code> and <code>p</code> <em>parameters</em> with which it was generated — i.e., <code>dh.pem</code> is a superset of <code>dhparam.pem</code>.</p>

<p>I would like to reconstruct <code>dhparam.pem</code>, given <em>only</em> <code>dh.pem</code>. That is, given a DH key file, dump its parameters in PEM format.</p>

<p>It seems like <code>openssl</code> itself might not support this directly, but maybe there's some not-too-horrible way to extract the info with a shell script or something? <a href=""https://www.openssl.org/docs/man1.0.2/man1/dhparam.html"" rel=""nofollow noreferrer"">The man page for <code>openssl dhparam</code></a> says:</p>

<blockquote>
  <p>This program manipulates DH parameters not keys.<br>
  BUGS: There should be a way to generate and manipulate DH keys.</p>
</blockquote>

<p>Related: <a href=""https://superuser.com/questions/905557/openssl-display-dh-parameters"">OpenSSL: Display DH Parameters</a> — but in that question they're starting with a <em>certificate</em>, not a private key. (And I don't know the incantation to turn my key into a certificate.)</p>
","<p><a href=""https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail"" rel=""nofollow noreferrer"">PEM</a> files are base64-encoded <a href=""https://en.wikipedia.org/wiki/X.690#DER_encoding"" rel=""nofollow noreferrer"">DER</a> serialised <a href=""https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One"" rel=""nofollow noreferrer"">ASN.1</a> files with a header and footer guard. A ASN.1 parser with the right schema can decode them. It so happens that <code>openssl</code> has this helpfully built in:</p>

<pre><code>$ openssl asn1parse &lt;dhparam.pem
    0:d=0  hl=4 l= 264 cons: SEQUENCE
    4:d=1  hl=4 l= 257 prim: INTEGER           :9DCE7EB979762B4F4DAE9D68C4DFCA6C870860B83C1D70AEF54356EE01649E41E297B39500A1D12A6D0373C223AA12690DFA0D285A03A3655DD0A07D9A84A40E68459A275C5CEED0F334AAD19E015C54CEEB538CBA475D76E975A2F6E57AA7C7E0371B0A31F82E2646202154C86B1E8816A4B777B604E4728D2037204838866F56BDD09EBD63D636373DADE1602FA56E6BC1E438690B07E12F44FD584F8BF984618FFFA03B5B145EBF1E448C5F558288F20CB30F376E82DDCD7B298DA3355D16D4611C284722592EB54089D40C10CF60DB90CD39742EE71B3A9272577045AFAA6891105A3B76C865850F863036592C4951E7896E825F8ACAFE0906BD91CD5D63
  265:d=1  hl=2 l=   1 prim: INTEGER           :02

$ openssl asn1parse &lt;dh.pem
    0:d=0  hl=4 l= 550 cons: SEQUENCE
    4:d=1  hl=2 l=   1 prim: INTEGER           :00
    7:d=1  hl=4 l= 279 cons: SEQUENCE
   11:d=2  hl=2 l=   9 prim: OBJECT            :dhKeyAgreement
   22:d=2  hl=4 l= 264 cons: SEQUENCE
   26:d=3  hl=4 l= 257 prim: INTEGER           :9DCE7EB979762B4F4DAE9D68C4DFCA6C870860B83C1D70AEF54356EE01649E41E297B39500A1D12A6D0373C223AA12690DFA0D285A03A3655DD0A07D9A84A40E68459A275C5CEED0F334AAD19E015C54CEEB538CBA475D76E975A2F6E57AA7C7E0371B0A31F82E2646202154C86B1E8816A4B777B604E4728D2037204838866F56BDD09EBD63D636373DADE1602FA56E6BC1E438690B07E12F44FD584F8BF984618FFFA03B5B145EBF1E448C5F558288F20CB30F376E82DDCD7B298DA3355D16D4611C284722592EB54089D40C10CF60DB90CD39742EE71B3A9272577045AFAA6891105A3B76C865850F863036592C4951E7896E825F8ACAFE0906BD91CD5D63
  287:d=3  hl=2 l=   1 prim: INTEGER           :02
  290:d=1  hl=4 l= 260 prim: OCTET STRING      [HEX DUMP]:028201006241639AB35CF462EB6873868F9E6C279931D56A190AE573D87FD619AB9735E59DAF0CBBC585D21A7FA25F2CDC002FB86DB0F2C3071FF0F49078F63ED7FDDA4847D9639B580CF2C9B7F722E6E956E9B0E9DD8A49ED632E15B4709BA6FE56F287218936074DAD5970C8D708776679DCAF532B50509DBDFF8098CCF9C459D72CA83C34D76692E5D5D98BCF7970FA49A8C32357B65FF08330DC951D7AFF0EC94AF33EB4E142B385F565917D4DB422EDCCDCD28BF5D3580F6C98DB51A60D38B510AC8FEF5440E60B36082F73C32D5D3B810BB415E2C79D10A181D8DA977C5522CA74A15FB670DECAFD45F8C6A092057A7C89E02827EAFBCD90F8E09AA131517E7790
</code></pre>

<p>And Bob’s your uncle.</p>
","32","<openssl><pem><diffie-hellman>","1","0","1","2019-11-08 14:49:46","","0","1","","","","2019-10-07 18:07:46",""
"54962611","Calculating s in ECDSA over GF(2m)","<p>I tried to calculate s over GF(m) as integer, but it is not working since the integer in vhdl has limit size, especially since you're working with 2^163.</p>
","","29","<diffie-hellman><bignum>","0","","0","2019-03-03 01:31:47","","3","","1940850","","2019-03-03 01:31:47","2019-03-02 09:16:01",""
"58765697","How many bytes do I need to read from NetworkStream, when message incoming is encrypted with AES?","<p>I am a student and I am not used to c# or ""network programing"". We need to make a client server program, that supports file transfering.
I'm trying to send some information about the file to server, but if server reads more or less bytes, than client sent, program gives exception. I am asking how can the server side in advance know, the byte size of incoming encrypted message.</p>

<p>For example: if encrypted sent messages size is 48 bytes and on the server side I read 1024 (and not the exact same size - in this example 48) bytes from stream, program chrashes... The problem is, that the server doesn't know encrypted message size in advance...</p>

<p>My program is not even near the final product and I have many other issues too(with GUI freezing without MessageBox.Show("""") messages before reading/writing to NetworkStream), but this is my current question. I also don't know how to set the same IV on server and client side in AES ecncryption, without declaring global IV.</p>

<p>Here is the whole code:</p>

<pre><code>    using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Security.Cryptography;
using System.Linq;

namespace Kodiranje
{
    public partial class Form1 : Form
    {
        const int port = 22222;
        const string ip = ""127.0.0.1"";
        IPAddress ipServer = IPAddress.Parse(ip);
        TcpListener server = null;
        TcpClient client = null;
        Thread thServer = null;
        NetworkStream dataStream = null;
        string receivedMessage = """";
        bool? izbira = null;
        Aes myAes = Aes.Create();
        bool serverRunning = true;
        bool datotekaIzbrana = false;
        byte[] iv = null;
        string filePath, fileName, fileExtension;
        OpenFileDialog openFileDialog;
        long fileSize;
        long kolicnik;
        long ostanek;


        public Form1()
        {
            InitializeComponent();
            iv = myAes.IV;
            thServer = new Thread(new ThreadStart(startServer));
            thServer.IsBackground = true;
            thServer.Start();
            myAes.Padding = PaddingMode.PKCS7;
            iv = myAes.IV;  // global IV set - how to avoid that?
        }

        void startServer()
        {

            server = new TcpListener(ipServer, port);
            server.Start();
            textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(""Strežnik: zagnan na: IP: "" + ip + "", port:"" + port)));
            client = new TcpClient();
            client = server.AcceptTcpClient();

            NetworkStream dataStream = client.GetStream();
            textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(Environment.NewLine + ""Strežnik: Sprejet nov uporabnik"")));


            if (izbira == true)
            {
                byte[] serverPublicKey;
                ECDiffieHellmanCng serverDH = new ECDiffieHellmanCng();
                serverDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
                serverDH.HashAlgorithm = CngAlgorithm.Sha256;
                serverPublicKey = serverDH.PublicKey.ToByteArray();



                byte[] message = new byte[1024];
                while (!dataStream.DataAvailable) { }
                if (dataStream.DataAvailable)
                    try
                    {
                        dataStream.Read(message, 0, message.Length);
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }

                byte[] serverCommoneKey = serverDH.DeriveKeyMaterial(CngKey.Import(message, CngKeyBlobFormat.EccPublicBlob));
                textBox4.Invoke(new Action(() =&gt; textBox4.AppendText(Environment.NewLine + ""Strežnik: Dobil sem sporočilo: "" + receivedMessage)));


                dataStream.Write(serverPublicKey, 0, serverPublicKey.Length);


                // Here I'm reading sent message and I decrypt it, but if the size of new byte[] is 
                not the same as the size of recieved message my program chrashes... how can i avoid               
                chrasing wihtout knowing the message size, and if I for instance set reading size to 
                1024 bytes?                   

                byte[] encryptedMessage = new byte[48]; // for this file i know the sent size from 
                client but in reality, I wouldn't know the exact size...

                while (!dataStream.DataAvailable) { }
                MessageBox.Show(""""); // GUI freezes without this message
                dataStream.Read(encryptedMessage, 0, encryptedMessage.Length);
                string prejetoSporocilo = odkodirajString(serverCommoneKey, encryptedMessage);
                MessageBox.Show(""Odkodirano prejeto sporočilo:"" + prejetoSporocilo);

            }


            else // irrelevant
            {
                byte[] message = new byte[1024];
                message = Encoding.UTF8.GetBytes(""serbus"");
                dataStream.Write(message, 0, message.Length);


            }
            while (serverRunning) { }

        }



        void button1_Click(object sender, EventArgs e)
        {
            if (izbira == null)
            {
                this.textBox4.AppendText(Environment.NewLine + ""Izbrati morate ali boste datoteko prenesli ali poslali!"");
                return;
            }
            if (!datotekaIzbrana)
            {
                MessageBox.Show(""Izberite datoteko!"");
                return;
            }

            this.button2.Enabled = true;
            this.button4.Enabled = false;

            this.button1.Enabled = false;
            this.button3.Enabled = true;
            client = new TcpClient();
            IPAddress insertedIp = IPAddress.Parse(textBox1.Text);


            byte[] clientPublicKey;
            ECDiffieHellmanCng clientDH = new ECDiffieHellmanCng();
            clientDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            clientDH.HashAlgorithm = CngAlgorithm.Sha256;
            clientPublicKey = clientDH.PublicKey.ToByteArray();


            client.Connect(insertedIp, Convert.ToInt32(textBox3.Text));
            dataStream = client.GetStream();


            if (izbira == true)
            {

                dataStream.Write(clientPublicKey, 0, clientPublicKey.Length);

                byte[] message = new byte[1024];

                MessageBox.Show(""""); // GUI freezes without this message
                while (true)
                {
                    if (dataStream.DataAvailable)
                    {

                        dataStream.Read(message, 0, message.Length);
                        this.textBox4.AppendText(Environment.NewLine + ""Client: Dobil sem sporočilo: "" + receivedMessage);
                        break;
                    }
                }
                byte[] clientCommoneKey = clientDH.DeriveKeyMaterial(CngKey.Import(message, CngKeyBlobFormat.EccPublicBlob));


                message = new byte[1024];

                /// here I'm trying to send file information, then encrypt it and send it to server

                kolicnik = fileSize / 1024;
                ostanek = fileSize % 1024;
                string glava = fileName + ""|"" + fileExtension + ""|"" + fileSize.ToString() + ""|"" + kolicnik.ToString() + ""|"" + ostanek + ""|"";

                //MessageBox.Show(glava);
                message = Encoding.UTF8.GetBytes(glava);
                MessageBox.Show(""velikost stringa: "" + glava.Length + "" velikost bitov: "" + message.Length);
                message = kodirajString(clientCommoneKey,glava);
                MessageBox.Show(""Zakodiran size: "" + message.Length);
                dataStream.Write(message, 0, message.Length);





                ///


            }


            else // irrelevant
            {

                byte[] message = new byte[1024];
                while (!dataStream.DataAvailable)
                { }
                dataStream.Read(message, 0, message.Length);

                receivedMessage = Encoding.UTF8.GetString(message);
                this.textBox4.AppendText(Environment.NewLine + ""Strežnik: Dobil sem sporočilo: "" + receivedMessage);
            }
        }



        void buttonUpload_Click(object sender, EventArgs e)
        {
            izbira = true;
            this.buttonDownload.Enabled = false;
            this.button4.Enabled = true;
        }
        void buttonDownload_Click(object sender, EventArgs e) // irrelevant
        {
            izbira = false;
            this.buttonUpload.Enabled = false;
            this.button2.Text = ""Prenesi"";
        }

        void button3_Click(object sender, EventArgs e)
        {
            serverRunning = false;
        }

        void button4_Click(object sender, EventArgs e) // choose file
        {
            openFileDialog = new OpenFileDialog();
            openFileDialog.Title = ""IZBERI DATOTEKO"";
            openFileDialog.Filter = ""GIF Image|*.gif|text file|*.txt|PDF file|*.pdf"";
                if (openFileDialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                //break;
                datotekaIzbrana = true;
                filePath = openFileDialog.FileName;
                this.textBox4.AppendText(Environment.NewLine + ""Pot do datoteke:"" + filePath);
                fileName = openFileDialog.SafeFileName;
                fileExtension = Path.GetExtension(filePath);
                string getPath = @filePath;
                FileInfo info = new FileInfo(getPath);

                Stream file = File.OpenRead(filePath);
                fileSize = info.Length;
                fileName = Path.GetFileNameWithoutExtension(info.Name);



            }
            else {
                    MessageBox.Show(""IZBERITE DATOTEKO!"");
                }


        }

        void button2_Click(object sender, EventArgs e)
        {

        }

        byte[] kodirajString(byte[] commonKey, string messageToEncrypt)  // encrypt message
        {
            myAes = Aes.Create();
            myAes.Padding = PaddingMode.PKCS7;
            myAes.Key = commonKey;
            myAes.IV = iv;
            ICryptoTransform encryptor = myAes.CreateEncryptor(myAes.Key, iv);
            byte[] encrypted;
            // Create the streams used for encryption.
            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(messageToEncrypt);

                    }
                    encrypted = msEncrypt.ToArray();
                    int s = encrypted.Length;
                    MessageBox.Show(""Velikost "" + s.ToString());
                    return encrypted;

                }
            }
        }


        string odkodirajString(byte[] commonKey, byte[] encryptedMessage) {  // decrypt message
            myAes = Aes.Create();
            myAes.Padding = PaddingMode.PKCS7;
            myAes.Key = commonKey;
            // Create a decryptor to perform the stream transform.
            ICryptoTransform decryptor = myAes.CreateDecryptor(myAes.Key, iv);

            // Create the streams used for decryption.
            using (MemoryStream msDecrypt = new MemoryStream(encryptedMessage))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {

                        // Read the decrypted bytes from the decrypting stream
                        // and place them in a string.
                        string plaintext;
                        plaintext = srDecrypt.ReadToEnd();
                        MessageBox.Show(""Sprejeto sporočilo "" + plaintext);
                        return plaintext;
                    }
                }
            }
        }

    }
}
</code></pre>

<p>I thank you in advance!</p>
","","24","<c#><encryption><aes><networkstream><diffie-hellman>","0","","0","2019-11-08 11:28:11","","1","","","","","2019-11-08 11:28:11",""
"53819812","Would you expect two bluetooth devices to arrive at different values for DHKey when attempting pairing?","<p>I've been trying to get two Bluetooth devices to pair in BLE Secure Connections mode, and it isn't cooperating. During pairing, after the bluetooth devices ask the user to confirm their 6 digit numbers (i'm using Numeric Comparison for this test), the authentication process always fails. I didn't have a compelling explanation for why, but today I dug up the following from bluez's <em>btmon</em>... it seems like the two devices are calculating different Diffie Hellman keys?</p>

<pre><code>&lt; ACL Data TX: Handle 5 flags 0x00 dlen 21 //I interpret this as transmitting a Diffie Hellman key to the respondant
      SMP: Pairing DHKey Check (0x0d) len 16
        E: 9b6628f5e7a44dc1ce482b7d5d162dfc

@ MGMT Event: Command Complete (0x0001) plen 10 //irrelevant
      User Confirmation Reply (0x001c) plen 7                                            
        Status: Success (0x00)                                                                           
        LE Address: 00:16:A4:4A:3A:60 (Ezurio Ltd)                                      
&gt; HCI Event: Number of Completed Packets (0x13) plen 5                     
        Num handles: 1                                                                                       
        Handle: 5                                                                                                  
        Count: 1                                                                                                    

&gt; ACL Data RX: Handle 5 flags 0x02 dlen 21 //this is the respondant replying with it's own Diffie Hellman
      SMP: Pairing DHKey Check (0x0d) len 16
        E: ad2d6f48721273b576958623d7b008b2 //different than the previous DHKey?!
</code></pre>

<p>I'm reading <a href=""https://www.ellisys.com/technology/een_bt07.pdf"" rel=""nofollow noreferrer"">here</a> that DHKey is supposed to be a shared secret; they speak of it using singular pronouns. This says to me that DHKey is part of the symmetric cryptography that's supposed to encrypt traffic going forward, rather than the asymmetric cryptography that we've been using to pair up until this point. </p>

<p>If that analysis is correct, then fact that the two keys do not agree is relevant and should be investigated. But if I'm wrong, and these entries refer to trading keys in preparation for asymmetric cryptography, that these two DHKeys differ would not surprise me. Given the name and the context, what would everybody expect?</p>
","","23","<bluetooth><diffie-hellman>","0","","0","2018-12-17 16:59:11","","0","","","","","2018-12-17 16:59:11",""
"58375440","How to verify Logjam issue with openssl command?","<p>My application is being reported that having vulnerability issue, which is the <code>SSL/TLS Diffie-Hellman Modulus &lt;= 1024 bits (Logjam) CVE-2015-4000</code>. </p>

<p>Based on <a href=""https://developer.jboss.org/thread/278896"" rel=""nofollow noreferrer"">this</a> link, there is a solution to edit the <code>java.security</code> file to solve this issue.</p>

<p>I would like to test on it, but I am not sure how to verify it. I would like to see the different before my changes and after my changes. </p>

<p>I found a command from <a href=""https://tools.keycdn.com/logjam"" rel=""nofollow noreferrer"">this</a> link, </p>

<pre><code>openssl s_client -connect www.example.com:443
</code></pre>

<p>I run this command and I get some info, but I am not sure how to verify my website is having Logjam issue or not. (<code>SSL/TLS Diffie-Hellman Modulus &lt;= 1024 bits</code>). And how to check If my changes have overcome this.</p>
","<p>I guess you can use <a href=""https://www.ssllabs.com/index.html"" rel=""nofollow noreferrer"">Qualys SSL Labs tools</a>, an example can be found <a href=""https://blogs.oracle.com/java-platform-group/diagnosing-tls,-ssl,-and-https"" rel=""nofollow noreferrer"">At Oracle Blog</a>.</p>

<p>The test for a server can be found on this <a href=""https://www.ssllabs.com/ssltest/"" rel=""nofollow noreferrer"">link</a> and the <a href=""https://www.ssllabs.com/projects/index.html"" rel=""nofollow noreferrer"">User Agent Capabilities</a> is very useful.</p>
","20","<java><ssl><jboss><owasp><diffie-hellman>","0","0","1","2019-10-23 17:23:12","","0","","4420967","","2019-10-14 11:47:49","2019-10-14 11:03:48",""
"55675697","Diffie-Helman Program in C lanugage","<p>I have written a program for Diffie Hellman Program in C language i am getting following error while compiling the code. I am getting following error:</p>

<pre><code>$gcc Diffie-Helman.c -o Diffie-Helman
/usr/bin/ld: /tmp/ccedcUj8.o: in function `power':
Diffie-Helman.c:(.text+0x2e): undefined reference to `pow'
collect2: error: ld returned 1 exit status
</code></pre>

<p>Machine Spec : Linux Ubuntu 18.10
The Program is as bellow........</p>

<pre><code>/* This program calculates the Key for two persons 
using the Diffie-Hellman Key exchange algorithm */
#include&lt;stdio.h&gt; 
#include&lt;math.h&gt; 

// Power function to return value of a ^ b mod P 
long long int power(long long int a, long long int b, long long 
int P) 
{ 
if (b == 1) 
    return a; 

else
    return (((long long int)pow(a, b)) % P); 
} 

//Driver program 
int main() 
{ 
long long int P, G, x, a, y, b, ka, kb; 

// Both the persons will be agreed upon the 
    // public keys G and P 
P = 23; // A prime number P is taken 
printf(""The value of P : %lld\n"", P); 

G = 9; // A primitve root for P, G is taken 
printf(""The value of G : %lld\n\n"", G); 

// Alice will choose the private key a 
a = 4; // a is the chosen private key 
printf(""The private key a for Alice : %lld\n"", a); 
x = power(G, a, P); // gets the generated key 

// Bob will choose the private key b 
b = 3; // b is the chosen private key 
printf(""The private key b for Bob : %lld\n\n"", b); 
y = power(G, b, P); // gets the generated key 

// Generating the secret key after the exchange 
    // of keys 
ka = power(y, a, P); // Secret key for Alice 
kb = power(x, b, P); // Secret key for Bob 

printf(""Secret key for the Alice is : %lld\n"", ka); 
printf(""Secret Key for the Bob is : %lld\n"", kb); 

return 0; 
} 
</code></pre>
","","12","<c><diffie-hellman>","1","","0","2019-04-14 13:15:32","","3","1","","","","2019-04-14 13:15:32","2019-04-14 13:21:36"